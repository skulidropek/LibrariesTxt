[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Analyses.CallHieracrhy.CSharpCallHierarchyLanguageSpecific : object {
    public sealed virtual bool IsLanguageSpecificFunction(IDeclaredElement declaredElement);
    public sealed virtual CallHierarchyFindResult ExtractSubscriber(IReference reference);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Analyses.CallHieracrhy.CSharpCallHierarchyLanguageSpecific/<ExtractSubscribersFromDeclaration>d__2")]
public sealed virtual IEnumerable`1<CallHierarchyFindResult> ExtractSubscribersFromDeclaration(ITypeMember delegateTypeMember, IProgressIndicator pi);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Analyses.CallHieracrhy.CSharpCallHierarchyLanguageSpecific/<ExtractInitializersFromDeclaration>d__3")]
public sealed virtual IEnumerable`1<IExpression> ExtractInitializersFromDeclaration(IInitializerOwnerDeclaration initializerOwner);
    public sealed virtual IConstructor ExtractImplicitBaseConstructorCall(IConstructor constructor);
    public sealed virtual IExpression GetClosureExpression(ITreeNode element);
    public sealed virtual IExpression GetQuery(ITreeNode element);
    public sealed virtual string GetUnresolvedPresentation(ITreeNode unresolvedElement);
    public sealed virtual bool IsMethodGroupReference(IReference reference, IClrDeclaredElement declaredElement);
    public sealed virtual bool IsIncomingSkippedReference(IReference reference);
    public sealed virtual IEvent ExtractEventReadWrite(IReference reference, Boolean& isSubscription);
    public sealed virtual ITreeNode GetReferenceElement(IReference reference);
    public sealed virtual void ProcessReferences(IReference reference, IDeclaredElement declaredElement, List`1<CallHierarchyFindResult> result, DeclaredElementInstance`1<IDeclaredElement> sourceElement, OneToListMap`2<IDeclaredElement, ISubstitution> baseElements);
    public sealed virtual void GetSuperMembers(IDeclaredElement element, OneToListMap`2<IDeclaredElement, ISubstitution> result, CachingFinder finder, IProgressIndicator progressIndicator);
    public sealed virtual ICollection`1<CallHierarchyFindResult> FindOutgoing(DeclaredElementInstance`1<IDeclaredElement> declaredElementInstance, IProgressIndicator progressIndicator);
    public sealed virtual IDeclaration GetParentElementDeclaration(ITreeNode referenceElement);
    public sealed virtual bool IsClosureDeclaration(ITreeNode element);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Clipboard.CSharpCopyPasteAssist : object {
    private static HashSet`1<char> ourLineEndingSymbols;
    [NotNullAttribute]
private CSharpLanguage myLanguage;
    public CSharpCopyPasteAssist(CSharpLanguage language);
    private static CSharpCopyPasteAssist();
    public sealed virtual bool EscapePastedRegion(CutOrCopySourceInfo context, string pastedText, ITreeNode pasteTargetNode, DocumentRange pasteRange, String& suggestedEscapeText);
    private bool EscapeRawStringLiteral(CutOrCopySourceInfo context, string pastedText, DocumentRange pasteRange, IStringLiteralOwner containingStringLiteralOwner, RawStringInfo rawStringInfo);
    private static SpecialCharactersUsageInfo CalculateSpecialCharactersAfterPaste(IStringLiteralOwner containingStringLiteralOwner, RawStringPresentationParameters presentationParameters, DocumentRange pasteRange, List`1<ContentPart> pasteContent, SpecialCharactersUsageInfo charactersUsageInfo);
    private static bool PasteWillAddQuotesToRawStringBorders(IStringLiteralOwner containingStringLiteralOwner, RawStringInfo rawStringInfo, DocumentRange pasteRange, List`1<ContentPart> pasteContent);
    private static void Replace(IList`1<ContentPart> content, string oldSubstring, string newSubstring);
    [NotNullAttribute]
private IReadOnlyList`1<ValueTuple`2<DocumentOffset, int>> IncreaseIndentInRawString(IStringLiteralOwner containingStringLiteralOwner, RawStringInfo rawStringInfo, RawStringPresentationParameters presentationParameters, DocumentRange pasteRange, string pastedText, string additionalLineIndent, List`1<Action> escapeActions, DocumentRange& escapedPasteRange);
    private static void AdjustPastedIndentAndLineBreaksForRawString(IStringLiteralOwner containingStringLiteralOwner, SpecialCharactersUsageInfo charactersUsageInfo, RawStringPresentationParameters presentationParameters, List`1<ContentPart> pasteContent, DocumentRange pasteRange, string indent);
    private static void AdjustExistingRawInterpolationInsertBorders(IStringLiteralOwner containingStringLiteralOwner, IReadOnlyList`1<ValueTuple`2<DocumentOffset, int>> indentShifts, List`1<Action> escapeActions, DocumentRange pasteRange, Int32& offset, Int32& offsetBeforePaste, int additionalBracesCount);
    private static void ReplaceNewLines(IList`1<ContentPart> content, Func`2<string, string> newlineMutator);
    private static void RemoveCommonIndent(IList`1<ContentPart> content, string commonIndent);
    private static bool MatchesSubstringFromOffset(StringBuilder text, int offset, string substring);
    [NotNullAttribute]
private static string GetCommonIndent(IList`1<ContentPart> content, bool allowMissingFirstLineIndent);
    [CanBeNullAttribute]
private IStringLiteralOwner GetContainingLiteralOrInterpolatedExpression(ITreeNode pasteTargetNode, DocumentRange pasteRange);
    private bool EscapeRegularStringLiteralOrComment(CutOrCopySourceInfo context, string pastedText, ITreeNode pasteTargetNode, DocumentRange pasteRange, String& suggestedEscapedText);
    public sealed virtual CutOrCopySourceInfo GetSourceContext(string rawSourceText, ITreeNode treeNode, DocumentRange copyRange);
    [NotNullAttribute]
private static string GetEscapedPastedComment(CutOrCopySourceInfo context, string pastedText, ICSharpCommentNode commentNode, DocumentRange documentRange, CSharpLanguageLevel languageLevel);
    [CanBeNullAttribute]
private static IDocCommentNode TryGetEscapableXmlDocNode(ITreeNode treeNode, DocumentRange documentRange);
    [CanBeNullAttribute]
private static Nullable`1<bool> IsInCDataTag(string commentText);
    private static bool IsFormattingArgument(ITreeNode literalNode);
    [NotNullAttribute]
private static string EscapePastedText(CutOrCopySourceInfo context, string pastedText, StringVerbatimity resultVerbatimity, bool isFormattingArgument, bool isInterpolatedString, CSharpLanguageLevel languageLevel);
    [CanBeNullAttribute]
private static ICSharpLiteralWrapper TryGetFirstStringLiteralWrapper(ITreeNode treeNode, DocumentRange documentRange, ITokenNode& literalNode);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("tokenNode: null => null")]
private static ICSharpLiteralWrapper TryGetStringLiteralWrapper(ITokenNode tokenNode, Int32[] offsetsToValidate);
    [ContractAnnotationAttribute("stringLiteralOwner:null => false")]
private static bool ValidateRangeBordersInLiteral(IStringLiteralOwner stringLiteralOwner, DocumentRange range);
    private static bool ValidateOffsetsInLiteral(ICSharpLiteralWrapper literalWrapper, ITokenNode tokenNode, Int32[] offsetsToValidate);
    [NotNullAttribute]
private static IList`1<ContentPart> ConvertMarkupToContentParts(string text, IList`1<ValueTuple`2<TextRange, ContentType>> markup);
    [NotNullAttribute]
private IList`1<ValueTuple`2<TextRange, ContentType>> ExtractMarkup(IStringLiteralOwner stringLiteralOwner, DocumentRange copyRange, Boolean& isValid);
    private static int GetCharacterCountFromColumn(IDocument document, DocumentCoords coords);
    [NotNullAttribute]
private static string NormalizeLineBreaksForRider(string str);
    [CompilerGeneratedAttribute]
internal static void <RemoveCommonIndent>g__TryRemoveWhitespaceLine|12_0(StringBuilder text, int offset);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static string <GetCommonIndent>g__MergeIndent|14_0(string currentCommonIndent, StringBuilder currentIndent);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Code.CSharpReferenceSorterLanguageService : ReferenceSorterLanguageService {
    public virtual ReferenceComparatorDelegate GetReferenceComparator();
    private static bool ShouldProcessBefore(IReference referenceX, IReference referenceY, OneToListMap`2<ITreeNode, IReference> references);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.BranchFormatTask : object {
    [CompilerGeneratedAttribute]
private int <OpeningDirectiveNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClosingDirectiveNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInactive>k__BackingField;
    [CompilerGeneratedAttribute]
private SolverWithRhs <SolverWithRhs>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SolverWithRhs <PreviousSolver>k__BackingField;
    public int OpeningDirectiveNumber { get; public set; }
    public int ClosingDirectiveNumber { get; public set; }
    public bool IsInactive { get; public set; }
    public SolverWithRhs SolverWithRhs { get; public set; }
    [NullableAttribute("2")]
public SolverWithRhs PreviousSolver { get; public set; }
    [CompilerGeneratedAttribute]
public int get_OpeningDirectiveNumber();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OpeningDirectiveNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ClosingDirectiveNumber();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClosingDirectiveNumber(int value);
    [CompilerGeneratedAttribute]
public bool get_IsInactive();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsInactive(bool value);
    [CompilerGeneratedAttribute]
public SolverWithRhs get_SolverWithRhs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SolverWithRhs(SolverWithRhs value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SolverWithRhs get_PreviousSolver();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PreviousSolver(SolverWithRhs value);
    public string GetGroupingKey();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.CSharpFileHeaderUtils : object {
    [NotNullAttribute]
private ISettingsStore mySettingsStore;
    [NotNullAttribute]
private ICodeFormatter myFormatter;
    [NotNullAttribute]
private ITodoPatternStorage myTodoPatternStorage;
    private String[] myCommentedOutCodeMarkers;
    public CSharpFileHeaderUtils(ISettingsStore settingsStore, ICodeFormatter formatter, ITodoPatternStorage todoPatternStorage);
    [ItemNotNullAttribute]
private static IEnumerable`1<string> GetLines(string text);
    [CanBeNullAttribute]
private string ProcessRawHeaderText(IPsiSourceFile sourceFile, string rawText, IContextBoundSettingsStore boundSettingsStore);
    private bool IsAcceptableComment(ITreeNode node, bool insideRegion);
    public sealed virtual void UpdateFileHeader(IPsiSourceFile sourceFile);
    private string BuildOldTextFromCommentRange(ITreeRange commentRange);
    private ITreeRange FindExistingHeaderRange(IPsiSourceFile sourceFile, IContextBoundSettingsStore boundSettingsStore);
    public sealed virtual bool IsHeaderEmpty(IPsiSourceFile psiSourceFile);
    private bool DoInsertHeader(IPsiSourceFile psiSourceFile, string oldHeaderText, DocumentOffset startHeaderOffset, IContextBoundSettingsStore contextDependantSettingsStore, IContextBoundSettingsStore classicSettingsStore);
    public sealed virtual bool InsertHeader(IPsiSourceFile psiSourceFile, DocumentOffset startOffset);
    public sealed virtual DocumentRange GetExistingFileHeaderRange(IPsiSourceFile sourceFile);
    private Template RepackHeaderTemplate(IPsiSourceFile sourceFile, IContextBoundSettingsStore bss, Template template);
    [CanBeNullAttribute]
private Template CreateHeaderTemplate(IPsiSourceFile sourceFile, string oldHeaderRangeText, IContextBoundSettingsStore liftedConfigsSettingsStore, IContextBoundSettingsStore vanillaSettingsStore);
}
[CodeCleanupModuleAttribute("16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.CSharpReformatCodeCleanupModule : object {
    public static CodeCleanupOptionDescriptor`1<bool> REFORMAT_CODE_DESCRIPTOR;
    private static CodeCleanupOptionDescriptor`1<bool> ourCommentsDescriptor;
    public ICollection`1<CodeCleanupOptionDescriptor> Descriptors { get; }
    public string Name { get; }
    public PsiLanguageType LanguageType { get; }
    public bool IsAvailableOnSelection { get; }
    private static CSharpReformatCodeCleanupModule();
    public sealed virtual ICollection`1<CodeCleanupOptionDescriptor> get_Descriptors();
    public sealed virtual void SetDefaultSetting(CodeCleanupProfile profile, DefaultProfileType profileType);
    public sealed virtual string get_Name();
    public sealed virtual PsiLanguageType get_LanguageType();
    public sealed virtual bool get_IsAvailableOnSelection();
    public virtual bool IsAvailable(IPsiSourceFile sourceFile);
    public virtual bool IsMainFormatAvailable(IPsiSourceFile sourceFile);
    public sealed virtual bool IsAvailable(CodeCleanupProfile profile);
    public sealed virtual void Process(IPsiSourceFile sourceFile, IRangeMarker rangeMarker, CodeCleanupProfile profile, IProgressIndicator progressIndicator, IUserDataHolder cache);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PasteBranchTextTask : object {
    [CompilerGeneratedAttribute]
private int <FromOld>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ToOld>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FromNew>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ToNew>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldText>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int FromOld { get; public set; }
    public int ToOld { get; public set; }
    public int FromNew { get; public set; }
    public int ToNew { get; public set; }
    public string Text { get; public set; }
    public string OldText { get; public set; }
    public PasteBranchTextTask(int FromOld, int ToOld, int FromNew, int ToNew, string Text, string OldText);
    [CompilerGeneratedAttribute]
protected PasteBranchTextTask(PasteBranchTextTask original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_FromOld();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FromOld(int value);
    [CompilerGeneratedAttribute]
public int get_ToOld();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ToOld(int value);
    [CompilerGeneratedAttribute]
public int get_FromNew();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FromNew(int value);
    [CompilerGeneratedAttribute]
public int get_ToNew();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ToNew(int value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_OldText();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OldText(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PasteBranchTextTask left, PasteBranchTextTask right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PasteBranchTextTask left, PasteBranchTextTask right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PasteBranchTextTask other);
    [CompilerGeneratedAttribute]
public virtual PasteBranchTextTask <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& FromOld, Int32& ToOld, Int32& FromNew, Int32& ToNew, String& Text, String& OldText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.BranchConditionSolver : object {
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    public abstract virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    public abstract virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    public abstract virtual IReadOnlyList`1<string> get_Symbols();
    public virtual IEnumerable`1<string> ProvideActiveSymbols(bool forRhs);
    public bool TryEnsureSolvedEntirely();
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> GetSolutionsDynamic(bool rhsKind);
    protected abstract virtual bool SolveEntirely();
    public bool IsSolvedEntirely();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.BranchExpressionUtils : object {
    private static int AnalysisVariableNumberBound;
    public static BranchConditionSolver AnalyzeForStrategy(IPreprocessorExpression preprocessorExpression, bool rhs);
    private static BranchConditionSolver AnalyzeForTrueFalseConstants(IPreprocessorExpression preprocessorExpression, ICollection`1<string> symbols);
    private static bool EvalConstExpression(IPreprocessorExpression expression);
    private static BranchConditionSolver AnalyzeForTopLevelElementaryAssocOperation(IPreprocessorExpression preprocessorExpression, bool rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.CachingBranchConditionPartialEvaluator : object {
    private Dictionary`2<string, BranchConditionSolver> myCacheDict;
    public void Clear();
    private SolverWithRhs EvaluateLeafContainerCaching(IEvaluatableBranchConditionContainer singleContainer);
    public SolverWithRhs EvaluateContainerCaching(IBranchConditionContainer container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.ConjunctionBranchConditionContainer : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IBranchConditionContainer> <Children>k__BackingField;
    public IReadOnlyList`1<IBranchConditionContainer> Children { get; }
    public ConjunctionBranchConditionContainer(IReadOnlyList`1<IBranchConditionContainer> conjuncts);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IBranchConditionContainer> get_Children();
    public sealed virtual void DescribeSelfInto(StringBuilder sb);
    public sealed virtual SolverWithRhs Combine(IReadOnlyList`1<SolverWithRhs> containerEvalResults);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.ContainerEvalResultEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> UnwrapSolutionForExternalRhs(SolverWithRhs result, bool rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.DisjunctionBranchConditionContainer : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IBranchConditionContainer> <Children>k__BackingField;
    public IReadOnlyList`1<IBranchConditionContainer> Children { get; }
    public DisjunctionBranchConditionContainer(IReadOnlyList`1<IBranchConditionContainer> conjuncts);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IBranchConditionContainer> get_Children();
    public sealed virtual void DescribeSelfInto(StringBuilder sb);
    public sealed virtual SolverWithRhs Combine(IReadOnlyList`1<SolverWithRhs> solvers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.EnumerateSolver : SteppingBranchConditionSolver {
    [CompilerGeneratedAttribute]
private IPreprocessorExpression <PreprocessorExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Symbols>k__BackingField;
    private List`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> myTrueRhsSolutions;
    private List`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> myFalseRhsSolutions;
    private int myEnumerationState;
    private int myEnumerationMaxState;
    private Dictionary`2<string, SolverUnificationResult> myCurrentValues;
    public IPreprocessorExpression PreprocessorExpression { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public EnumerateSolver(IPreprocessorExpression preprocessorExpression, IReadOnlyList`1<string> symbols);
    [CompilerGeneratedAttribute]
public IPreprocessorExpression get_PreprocessorExpression();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<string> get_Symbols();
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    public virtual bool AdvanceToNextTrueSolutionYielding(Dictionary`2<string, SolverUnificationResult> result);
    public virtual bool AdvanceToNextFalseSolutionYielding(Dictionary`2<string, SolverUnificationResult> result);
    protected virtual bool SolveEntirely();
    private bool SolveWithBinaryTruthLabels(IPreprocessorExpression trav);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.ExcludedPresolvedSolutionsList : object {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> <ExcludedSolutions>k__BackingField;
    public int Count { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> ExcludedSolutions { get; }
    public IReadOnlyDictionary`2<string, SolverUnificationResult> Item { get; }
    public ExcludedPresolvedSolutionsList(IReadOnlyList`1<string> symbols, IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> excludedSolutions);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Symbols();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_ExcludedSolutions();
    public sealed virtual IEnumerator`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.ExcludedPresolvedSolutionsList/<UnpackBoolsFromIntegerBits>d__12")]
private static IEnumerable`1<SolverUnificationResult> UnpackBoolsFromIntegerBits(int bits);
    public sealed virtual IReadOnlyDictionary`2<string, SolverUnificationResult> get_Item(int index);
    private int ConvertDictToIndex(IReadOnlyDictionary`2<string, SolverUnificationResult> dict);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.FalseBranchConditionSolver : BranchConditionSolver {
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    public virtual IReadOnlyList`1<string> get_Symbols();
    protected virtual bool SolveEntirely();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.IBranchConditionContainer {
    public IReadOnlyList`1<IBranchConditionContainer> Children { get; }
    public abstract virtual IReadOnlyList`1<IBranchConditionContainer> get_Children();
    public abstract virtual void DescribeSelfInto(StringBuilder sb);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.ICompositeBranchConditionContainer {
    [NullableContextAttribute("1")]
public abstract virtual SolverWithRhs Combine(IReadOnlyList`1<SolverWithRhs> solvers);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.IEvaluatableBranchConditionContainer {
    public string PsiBranchConditionText { get; }
    public bool RightHandSide { get; }
    public abstract virtual BranchConditionSolver GetBranchSolver();
    public abstract virtual string get_PsiBranchConditionText();
    public abstract virtual bool get_RightHandSide();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.IfExpressionInfo : object {
    [CompilerGeneratedAttribute]
private IBranchConditionContainer <ConditionContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Cnt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsActive>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IBranchConditionContainer ConditionContainer { get; public set; }
    public int Cnt { get; public set; }
    public bool IsActive { get; public set; }
    public IfExpressionInfo(IBranchConditionContainer ConditionContainer, int Cnt, bool IsActive);
    [CompilerGeneratedAttribute]
protected IfExpressionInfo(IfExpressionInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IBranchConditionContainer get_ConditionContainer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ConditionContainer(IBranchConditionContainer value);
    [CompilerGeneratedAttribute]
public int get_Cnt();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Cnt(int value);
    [CompilerGeneratedAttribute]
public bool get_IsActive();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsActive(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(IfExpressionInfo left, IfExpressionInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(IfExpressionInfo left, IfExpressionInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(IfExpressionInfo other);
    [CompilerGeneratedAttribute]
public virtual IfExpressionInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IBranchConditionContainer& ConditionContainer, Int32& Cnt, Boolean& IsActive);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.IModifyingBranchConditionContainer {
    [NullableContextAttribute("1")]
public abstract virtual IBranchConditionContainer ExecuteModification();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.IndependentConjunctionHyperSolver : BranchConditionSolver {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> <TrueRhsSolutions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> <FalseRhsSolutions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Symbols>k__BackingField;
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    public IndependentConjunctionHyperSolver(IReadOnlyList`1<string> symbols);
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<string> get_Symbols();
    protected virtual bool SolveEntirely();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.IndependentDisjunctionHyperSolver : BranchConditionSolver {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> <TrueRhsSolutions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> <FalseRhsSolutions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Symbols>k__BackingField;
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    public IndependentDisjunctionHyperSolver(IReadOnlyList`1<string> symbols);
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<string> get_Symbols();
    protected virtual bool SolveEntirely();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.IndependentIntersectionSolver : SteppingOperationBranchConditionSolver {
    private List`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> myTrueRhsSolutions;
    private List`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> myFalseRhsSolutions;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Symbols>k__BackingField;
    private IntersectionFalseSolutionsGenerator myIntersectionFalseSolutionsGenerator;
    private IntersectionTrueSolutionsGenerator myIntersectionTrueSolutionsGenerator;
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    private IndependentIntersectionSolver(IReadOnlyList`1<SolverWithRhs> conjuncts, IReadOnlyList`1<string> symbols);
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<string> get_Symbols();
    public virtual bool AdvanceToNextTrueSolutionYielding(Dictionary`2<string, SolverUnificationResult> result);
    public virtual bool AdvanceToNextFalseSolutionYielding(Dictionary`2<string, SolverUnificationResult> result);
    protected virtual bool SolveEntirely();
    public static IndependentIntersectionSolver AnalyzeAndTryGet(IList`1<SolverWithRhs> branchConditionSolvers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.IndependentUnionSolver : SteppingOperationBranchConditionSolver {
    private List`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> myTrueRhsSolutions;
    private List`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> myFalseRhsSolutions;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Symbols>k__BackingField;
    private UnionTrueSolutionsGenerator myUnionTrueSolutionsGenerator;
    private UnionFalseSolutionsGenerator myUnionFalseSolutionsGenerator;
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    private IndependentUnionSolver(IReadOnlyList`1<SolverWithRhs> conjuncts, IReadOnlyList`1<string> symbols);
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<string> get_Symbols();
    public virtual bool AdvanceToNextTrueSolutionYielding(Dictionary`2<string, SolverUnificationResult> result);
    public virtual bool AdvanceToNextFalseSolutionYielding(Dictionary`2<string, SolverUnificationResult> result);
    protected virtual bool SolveEntirely();
    public static IndependentUnionSolver AnalyzeAndTryGet(IList`1<SolverWithRhs> branchConditionSolvers, bool rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.MultiKindSolutionGenerator : object {
    private int myCurrentRhsKindYieldingIndex;
    private bool myRhsKind;
    private List`1<int> myUsedUpRhsKindConjunctIndicies;
    private List`1<int> myIterationStatesBySolver;
    private IReadOnlyList`1<SolverWithRhs> myEvalResults;
    protected MultiKindSolutionGenerator(IReadOnlyList`1<SolverWithRhs> evalResults, bool rhsKind);
    public IReadOnlyDictionary`2<string, SolverUnificationResult> Next();
    private bool YieldFromSolvers(Dictionary`2<string, SolverUnificationResult> result, int startingWithSolverIndex);
    private bool MoveToTheNextBaseRhsKindSolution(SolverWithRhs currentRhsYielding);
    private void StepCurrentRhsKindIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.NegationBranchConditionContainer : object {
    [CompilerGeneratedAttribute]
private IBranchConditionContainer <NegatedContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IBranchConditionContainer> <Children>k__BackingField;
    public IBranchConditionContainer NegatedContainer { get; }
    public IReadOnlyList`1<IBranchConditionContainer> Children { get; }
    public NegationBranchConditionContainer(IBranchConditionContainer negatedContainer);
    [CompilerGeneratedAttribute]
public IBranchConditionContainer get_NegatedContainer();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IBranchConditionContainer> get_Children();
    public sealed virtual void DescribeSelfInto(StringBuilder sb);
    public sealed virtual IBranchConditionContainer ExecuteModification();
    private static PsiBranchConditionContainer InvertPsiContainer(PsiBranchConditionContainer psiBranchConditionContainer);
    private static DisjunctionBranchConditionContainer InvertConjunctionContainer(ConjunctionBranchConditionContainer conjunctionBranchConditionContainer);
    private static ConjunctionBranchConditionContainer InvertDisjunctionContainer(DisjunctionBranchConditionContainer disjunctionBranchConditionContainer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.NonAdvancableBranchConditionSolver : BranchConditionSolver {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> <TrueRhsSolutions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> <FalseRhsSolutions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Symbols>k__BackingField;
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    private NonAdvancableBranchConditionSolver(IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> trueRhsSolutions, IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> falseRhsSolutions, IEnumerable`1<string> symbols);
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<string> get_Symbols();
    protected virtual bool SolveEntirely();
    private static bool IsConsistent(IReadOnlyDictionary`2<string, SolverUnificationResult> l, IReadOnlyDictionary`2<string, SolverUnificationResult> r);
    private static IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> IntersectParams(List`1<IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>>> listOfSolutionsLists);
    private static IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> IntersectParamsStep(IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> l, IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> r);
    private static IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> IntersectParamsStep(ExcludedPresolvedSolutionsList l, IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> r);
    private static IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> IntersectParamsStep(ExcludedPresolvedSolutionsList l, ExcludedPresolvedSolutionsList r);
    private static IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> UniteExcludedsWithSymbols(IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> l, IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> r, IReadOnlyList`1<string> symbols);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.NonAdvancableBranchConditionSolver/<ExtendWithSymbols>d__17")]
private static IEnumerable`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> ExtendWithSymbols(IReadOnlyDictionary`2<string, SolverUnificationResult> toExtend, IReadOnlyList`1<string> symbols);
    private static bool SolutionEquals(IReadOnlyDictionary`2<string, SolverUnificationResult> l, IReadOnlyDictionary`2<string, SolverUnificationResult> r);
    public static NonAdvancableBranchConditionSolver FromSolversIntersection(IList`1<SolverWithRhs> evalResults, bool rhs);
    public static NonAdvancableBranchConditionSolver FromSolversUnion(IList`1<SolverWithRhs> evalResults, bool rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.PsiBranchConditionContainer : object {
    [CompilerGeneratedAttribute]
private IPreprocessorExpression <PsiBranchCondition>k__BackingField;
    private Lazy`1<string> myPsiBranchConditionText;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IBranchConditionContainer> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RightHandSide>k__BackingField;
    private IPreprocessorExpression PsiBranchCondition { get; }
    public string PsiBranchConditionText { get; }
    public IReadOnlyList`1<IBranchConditionContainer> Children { get; }
    public bool RightHandSide { get; }
    public PsiBranchConditionContainer(IPreprocessorExpression psiBranchCondition);
    private PsiBranchConditionContainer(IPreprocessorExpression psiBranchCondition, bool rightHandSide);
    [CompilerGeneratedAttribute]
private IPreprocessorExpression get_PsiBranchCondition();
    public sealed virtual string get_PsiBranchConditionText();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IBranchConditionContainer> get_Children();
    public sealed virtual void DescribeSelfInto(StringBuilder sb);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RightHandSide();
    public sealed virtual BranchConditionSolver GetBranchSolver();
    public PsiBranchConditionContainer InvertedCopy();
    [CompilerGeneratedAttribute]
private string <.ctor>b__13_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.ReformatInactiveBranchesProcessor : object {
    private Stack`1<IfExpressionInfo> myIfExpressionsParsingStack;
    private Stack`1<List`1<IBranchConditionContainer>> myElseConditionsByCascade;
    private int myDirectiveCounter;
    private CachingBranchConditionPartialEvaluator myPartialEvaluator;
    public ReformatInactiveBranchesProcessor(CachingBranchConditionPartialEvaluator evaluator);
    private ReformatInactiveBranchesProcessor ResetSelf();
    private ReformatInactiveBranchesProcessor ResetSelfToCounter(int counter);
    public IEnumerable`1<BranchFormatTask> CollectVisibleInactiveBranches(IFile parsedFile);
    public IEnumerable`1<BranchFormatTask> CollectVisibleInactiveBranches(IPreprocessorDirective start, IPreprocessorDirective end, int initialDirectiveCounter);
    [NullableContextAttribute("2")]
private static ITreeNode GetFirstNextableInHierarchy(ITreeNode trav);
    private void ProcessIfDirective(IIfDirective ifDirective);
    private void ProcessElifDirective(IElifDirective elifDirective, ICollection`1<BranchFormatTask> accumulator);
    private void ProcessElseDirective(IElseDirective elseDirective, ICollection`1<BranchFormatTask> accumulator);
    private void ProcessEndifDirective(IEndifDirective endifDirective, ICollection`1<BranchFormatTask> accumulator);
    private List`1<BranchFormatTask> DoCollectBranchInfoFromSubRoot(ITreeNode subRoot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.SingleKindSolutionGenerator : object {
    private IReadOnlyList`1<SolverWithRhs> myContainerEvalResults;
    private List`1<int> myIterationStatesBySolver;
    private bool myRhsKind;
    protected SingleKindSolutionGenerator(IReadOnlyList`1<SolverWithRhs> containerEvalResults, bool rhsKind);
    public IReadOnlyDictionary`2<string, SolverUnificationResult> Next();
    private bool YieldFromSolvers(Dictionary`2<string, SolverUnificationResult> result, int startingWithSolverIndex);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.SolverUnificationResult : Enum {
    public int value__;
    public static SolverUnificationResult True;
    public static SolverUnificationResult False;
    public static SolverUnificationResult Inconclusive;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.SolverWithRhs : object {
    [CompilerGeneratedAttribute]
private BranchConditionSolver <Solver>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Rhs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BranchConditionText>k__BackingField;
    public BranchConditionSolver Solver { get; }
    public bool Rhs { get; }
    public string BranchConditionText { get; }
    public SolverWithRhs(BranchConditionSolver solver, bool rhs, string conditionText);
    [CompilerGeneratedAttribute]
public BranchConditionSolver get_Solver();
    [CompilerGeneratedAttribute]
public bool get_Rhs();
    [CompilerGeneratedAttribute]
public string get_BranchConditionText();
    public IEnumerable`1<string> ProvideActiveSymbolsFromSolver();
    public static SolverWithRhs FromUnion(List`1<SolverWithRhs> solvers);
    public static SolverWithRhs FromIntersection(List`1<SolverWithRhs> solvers);
    private static ValueTuple`2<IList`1<SolverWithRhs>, Nullable`1<bool>> PerformIntersectionConstAnalysisFiltration(IEnumerable`1<SolverWithRhs> branchConditionSolvers);
    private static ValueTuple`2<IList`1<SolverWithRhs>, Nullable`1<bool>> PerformUnionConstAnalysisFiltration(IEnumerable`1<SolverWithRhs> branchConditionSolvers);
    public bool HasSatisfyingSolutions();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.SteppingBranchConditionSolver : BranchConditionSolver {
    public abstract virtual bool AdvanceToNextTrueSolutionYielding(Dictionary`2<string, SolverUnificationResult> result);
    public abstract virtual bool AdvanceToNextFalseSolutionYielding(Dictionary`2<string, SolverUnificationResult> result);
    public bool AdvanceToNextTrueSolution();
    public bool AdvanceToNextFalseSolution();
    public bool AdvanceToNextDynamicSolutionYielding(bool rhsKind, Dictionary`2<string, SolverUnificationResult> result);
    public bool AdvanceToNextDynamicSolution(bool rhsKind);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<string> ProvideActiveSymbols(bool forRhs);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.SteppingOperationBranchConditionSolver : SteppingBranchConditionSolver {
    [NullableContextAttribute("1")]
protected static ValueTuple`2<List`1<string>, bool> PerformIndependenceAnalysis(IEnumerable`1<SolverWithRhs> branchConditionSolvers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.PreprocessorProcessing.TrueBranchConditionSolver : BranchConditionSolver {
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> TrueRhsSolutions { get; }
    public IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> FalseRhsSolutions { get; }
    public IReadOnlyList`1<string> Symbols { get; }
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_TrueRhsSolutions();
    public virtual IReadOnlyList`1<IReadOnlyDictionary`2<string, SolverUnificationResult>> get_FalseRhsSolutions();
    public virtual IReadOnlyList`1<string> get_Symbols();
    protected virtual bool SolveEntirely();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CodeCleanupModuleAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.ReformatInactiveBranches : object {
    private static string ourInactiveBranchProgressText;
    public static CodeCleanupOptionDescriptor`1<bool> REFORMAT_INACTIVE_BRANCHES_DESCRIPTOR;
    private static NodeTypeSet ourImmediatelyCommitNodeTypes;
    public ICollection`1<CodeCleanupOptionDescriptor> Descriptors { get; }
    public string Name { get; }
    public PsiLanguageType LanguageType { get; }
    public bool IsAvailableOnSelection { get; }
    private static ReformatInactiveBranches();
    public sealed virtual ICollection`1<CodeCleanupOptionDescriptor> get_Descriptors();
    public sealed virtual void SetDefaultSetting(CodeCleanupProfile profile, DefaultProfileType profileType);
    public sealed virtual string get_Name();
    public sealed virtual PsiLanguageType get_LanguageType();
    public sealed virtual bool get_IsAvailableOnSelection();
    public sealed virtual bool IsAvailable(IPsiSourceFile sourceFile);
    public sealed virtual bool IsAvailable(CodeCleanupProfile profile);
    public sealed virtual void Process(IPsiSourceFile sourceFile, IRangeMarker rangeMarker, CodeCleanupProfile profile, IProgressIndicator progressIndicator, IUserDataHolder cache);
    public sealed virtual void RegisterInvocation(ISolution solution, CodeCleanupProfile profile, ScopeType scopeType, CleanupInvocationType silentAction, SortedSet`1<string> extensions);
    private void DoReformatBranchGroup(IPsiSourceFile sourceFile, IFile parsedFile, IEnumerable`1<BranchFormatTask> branchInfos);
    private static void DoSinglePasteTask(PasteBranchTextTask pasteBranchTextTask, IPsiSourceFile sourceFile);
    private static void DoPasteTask(PasteBranchTextTask pasteBranchTextTask, IPsiSourceFile sourceFile, Int32& offsetsMovedBy);
    private SingleBranchReformatResult DoReformatSingleBranch(IFile parsedFile, IPsiSourceFile sourceFile, BranchFormatTask branchInfo, SolverWithRhs currentSolver);
    private IEnumerable`1<ValueTuple`2<BranchFormatTask, SolverWithRhs>> FilterOnPreviousSolver(IEnumerable`1<BranchFormatTask> branchInfos);
    private static bool ShouldCommitImmediately(IEnumerable`1<ITreeNode> nodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.ReformatInactiveBranchesHelper : object {
    public static ValueTuple`2<IPreprocessorDirective, IPreprocessorDirective> GetPreprocessorDirectivesByNumbers(IFile parsedFile, int openingNumber, int closingNumber);
    [ExtensionAttribute]
public static bool IsUnparsedPreprocessorDirectiveToken(ITokenNode token);
    [ExtensionAttribute]
public static bool IsVisibleContext(Stack`1<IfExpressionInfo> ifExpressionInfos);
}
[CodeCleanupModuleAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.ReorderTypeMembers : object {
    public static CodeCleanupOptionDescriptor`1<bool> REORDER_TYPE_MEMBERS_DESCRIPTOR;
    public ICollection`1<CodeCleanupOptionDescriptor> Descriptors { get; }
    public string Name { get; }
    public PsiLanguageType LanguageType { get; }
    public bool IsAvailableOnSelection { get; }
    private static ReorderTypeMembers();
    public sealed virtual ICollection`1<CodeCleanupOptionDescriptor> get_Descriptors();
    public sealed virtual void SetDefaultSetting(CodeCleanupProfile profile, DefaultProfileType profileType);
    public sealed virtual string get_Name();
    public sealed virtual PsiLanguageType get_LanguageType();
    public sealed virtual bool get_IsAvailableOnSelection();
    public sealed virtual bool IsAvailable(IPsiSourceFile sourceFile);
    public sealed virtual bool IsAvailable(CodeCleanupProfile profile);
    public sealed virtual void Process(IPsiSourceFile sourceFile, IRangeMarker rangeMarker, CodeCleanupProfile profile, IProgressIndicator progressIndicator, IUserDataHolder cache);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.ReparsedFileWithDirectivesCookie : object {
    [CompilerGeneratedAttribute]
private IFile <ReparsedFile>k__BackingField;
    public IFile ReparsedFile { get; }
    private ReparsedFileWithDirectivesCookie(IFile reparsedFile);
    [CompilerGeneratedAttribute]
public IFile get_ReparsedFile();
    public sealed virtual void Dispose();
    public static ReparsedFileWithDirectivesCookie Create(IPsiSourceFile sourceFile, IFile parsedFile, IEnumerable`1<PreProcessingDirective> activeDirectivesForBranch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.SingleBranchReformatResult : object {
    [CompilerGeneratedAttribute]
private PasteBranchTextTask <PasteTask>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<BranchFormatTask> <NestedFormatTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCommitImmediately>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public PasteBranchTextTask PasteTask { get; public set; }
    public IList`1<BranchFormatTask> NestedFormatTasks { get; public set; }
    public bool ShouldCommitImmediately { get; public set; }
    public SingleBranchReformatResult(PasteBranchTextTask PasteTask, IList`1<BranchFormatTask> NestedFormatTasks, bool ShouldCommitImmediately);
    [CompilerGeneratedAttribute]
protected SingleBranchReformatResult(SingleBranchReformatResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public PasteBranchTextTask get_PasteTask();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PasteTask(PasteBranchTextTask value);
    [CompilerGeneratedAttribute]
public IList`1<BranchFormatTask> get_NestedFormatTasks();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NestedFormatTasks(IList`1<BranchFormatTask> value);
    [CompilerGeneratedAttribute]
public bool get_ShouldCommitImmediately();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShouldCommitImmediately(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SingleBranchReformatResult left, SingleBranchReformatResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SingleBranchReformatResult left, SingleBranchReformatResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SingleBranchReformatResult other);
    [CompilerGeneratedAttribute]
public virtual SingleBranchReformatResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(PasteBranchTextTask& PasteTask, IList`1& NestedFormatTasks, Boolean& ShouldCommitImmediately);
}
[CodeCleanupModuleAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCleanup.UpdateFileHeader : object {
    private static CodeCleanupOptionDescriptor`1<bool> ourDescriptor;
    private ILazy`1<FileHeaderUtils> myFileHeaderUtils;
    public ICollection`1<CodeCleanupOptionDescriptor> Descriptors { get; }
    public string Name { get; }
    public PsiLanguageType LanguageType { get; }
    public bool IsAvailableOnSelection { get; }
    public UpdateFileHeader(ILazy`1<FileHeaderUtils> fileHeaderUtils);
    private static UpdateFileHeader();
    public sealed virtual ICollection`1<CodeCleanupOptionDescriptor> get_Descriptors();
    public sealed virtual void SetDefaultSetting(CodeCleanupProfile profile, DefaultProfileType profileType);
    public sealed virtual string get_Name();
    public sealed virtual PsiLanguageType get_LanguageType();
    public sealed virtual bool get_IsAvailableOnSelection();
    public sealed virtual bool IsAvailable(IPsiSourceFile sourceFile);
    public sealed virtual bool IsAvailable(CodeCleanupProfile profile);
    public sealed virtual void Process(IPsiSourceFile sourceFile, IRangeMarker rangeMarker, CodeCleanupProfile profile, IProgressIndicator progressIndicator, IUserDataHolder cache);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.BracketsType : Enum {
    public int value__;
    public static BracketsType Parentheses;
    public static BracketsType Brackets;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CodeCompletionArgumentsContext : object {
    [CompilerGeneratedAttribute]
private BracketsType <BracketsType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArgumentsText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasRPar>k__BackingField;
    public BracketsType BracketsType { get; private set; }
    public string ArgumentsText { get; private set; }
    public bool HasRPar { get; private set; }
    [CompilerGeneratedAttribute]
public BracketsType get_BracketsType();
    [CompilerGeneratedAttribute]
private void set_BracketsType(BracketsType value);
    [CompilerGeneratedAttribute]
public string get_ArgumentsText();
    [CompilerGeneratedAttribute]
private void set_ArgumentsText(string value);
    [CompilerGeneratedAttribute]
public bool get_HasRPar();
    [CompilerGeneratedAttribute]
private void set_HasRPar(bool value);
    public static CodeCompletionArgumentsContext Create(ICSharpIdentifier identifier, TreeTextRange& argumentsListRange);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CodeCompletionContextOptions : object {
    [CompilerGeneratedAttribute]
private bool <PrefilterByPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateSeparateItemsForOverloads>k__BackingField;
    public bool PrefilterByPrefix { get; private set; }
    public bool CreateSeparateItemsForOverloads { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_PrefilterByPrefix();
    [CompilerGeneratedAttribute]
private void set_PrefilterByPrefix(bool value);
    [CompilerGeneratedAttribute]
public bool get_CreateSeparateItemsForOverloads();
    [CompilerGeneratedAttribute]
private void set_CreateSeparateItemsForOverloads(bool value);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CodeCompletionFollowingExpressionContext : object {
    [CompilerGeneratedAttribute]
private string <FollowingExpressionText>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentRange <FollowingExpressionRange>k__BackingField;
    public string FollowingExpressionText { get; }
    public DocumentRange FollowingExpressionRange { get; }
    private CodeCompletionFollowingExpressionContext(string followingExpressionText, DocumentRange followingExpressionRange);
    [CompilerGeneratedAttribute]
public string get_FollowingExpressionText();
    [CompilerGeneratedAttribute]
public DocumentRange get_FollowingExpressionRange();
    [CanBeNullAttribute]
public static CodeCompletionFollowingExpressionContext Create(ICSharpFile file, TreeTextRange selectedTreeRange);
    private static bool HasLineBreaks(ITreeNode node);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CSharpAnnotationsBuilder : object {
    public string Start { get; }
    public string End { get; }
    public sealed virtual string get_Start();
    public sealed virtual string get_End();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CSharpCodeCompletionUtil : object {
    [PureAttribute]
public static IType GetTypeToInstantiate(IDeclaredType expectedType, ICSharpTreeNode contextElement);
    [PureAttribute]
public static bool HasTypeParametersWhichCannotBeResolved(IDeclaredType declaredType, ITreeNode contextElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTypeUsageOfUnfinishedMethodParsedInAWrongPlace(ITypeUsage typeUsage);
    [PureAttribute]
public static UnfinishedDeconstructionIdentifierKind IsIsUnfinishedDeconstructionPart(ICSharpIdentifier identifier);
    [PureAttribute]
public static bool ExpressionLooksLikeType(ICSharpExpression expression, bool allowBrokenTypeArguments);
    [PureAttribute]
public static bool HasLineBreakExactlyBefore(ITreeNode treeNode);
    [PureAttribute]
public static bool IsTupleForeachIterationVariableNameOrInKeyword(ICSharpIdentifier identifier);
    [PureAttribute]
private static bool CanBeParsedAsTupleExpression(ITupleTypeUsage tupleTypeUsage);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsBrokenGenericTypeArgumentParsedAsNextField(IFieldDeclaration fieldDeclaration);
    [PureAttribute]
public static bool IsWhereSubpatternNameIsExpected(IReferenceExpression referenceExpression);
}
[ObsoleteAttribute("Deprecated, use aspect items")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CSharpDeclaredElementLookupItem : DeclaredElementLookupItem {
    [CompilerGeneratedAttribute]
private bool <EscapeKeywords>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveEscapeOnReplace>k__BackingField;
    public bool EscapeKeywords { get; public set; }
    private bool PreserveEscapeOnReplace { get; public set; }
    public CSharpDeclaredElementLookupItem(string name, DeclaredElementInstance instance, IElementPointerFactory elementPointerFactory, ILookupItemsOwner owner);
    [CompilerGeneratedAttribute]
public bool get_EscapeKeywords();
    [CompilerGeneratedAttribute]
public void set_EscapeKeywords(bool value);
    [CompilerGeneratedAttribute]
private bool get_PreserveEscapeOnReplace();
    [CompilerGeneratedAttribute]
public void set_PreserveEscapeOnReplace(bool value);
    public virtual bool AcceptIfOnlyMatched(LookupItemAcceptanceContext itemAcceptanceContext);
    public virtual MatchingResult Match(PrefixMatcher prefixMatcher);
    protected virtual string GetText();
    protected virtual string MakeSafe(string shortName);
    protected virtual DocumentRange DoReplaceText(ITextControl textControl, DocumentRange replaceRange, string typeInName);
    public virtual void Accept(ITextControl textControl, DocumentRange nameRange, LookupItemInsertType insertType, Suffix suffix, ISolution solution, bool keepCaretStill);
    protected virtual void OnAfterComplete(ITextControl textControl, DocumentRange& nameRange, DocumentRange& decorationRange, TailType tailType, Suffix& suffix, IRangeMarker& caretPositionRangeMarker);
}
[ObsoleteAttribute("Used only for live templates reparse, to be removed")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CSharpReparseContext : ReparseContext {
    private CSharpReparseContextType myContextType;
    private ICSharpParser myParser;
    public CSharpReparseContextType Type { get; }
    private CSharpReparseContext(string text, IPsiModule project, CSharpReparseContextType contextType);
    private void Prepare(IPsiModule module);
    public CSharpReparseContextType get_Type();
    [NotNullAttribute]
private static string GetPrefixedTextBetween(string addText, ITreeNode child1, ITreeNode child2);
    [NotNullAttribute]
public ITreeNode Parse(string addedText);
    [CanBeNullAttribute]
public static CSharpReparseContext FindContext(ITreeNode origin);
    [PureAttribute]
private static CSharpReparseContextType GetTypeMemberOrNamespaceContext(ITreeNode context);
    private static bool IncludeStatementInContext(ICSharpStatement node);
    private static bool IsTypeMemberDeclarationNode(ITreeNode node);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CSharpReparseContextEx : object {
    [NotNullAttribute]
private CSharpLanguageService myLanguageService;
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private PreProcessingDirective[] myPreProcessingDirectives;
    [CompilerGeneratedAttribute]
private CSharpReparseContextType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContextTail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContextHead>k__BackingField;
    public CSharpReparseContextType Type { get; }
    [NotNullAttribute]
public ITreeNode Origin { get; }
    [NotNullAttribute]
public string ContextTail { get; }
    [NotNullAttribute]
public string ContextHead { get; }
    public int HeadLength { get; }
    private CSharpReparseContextEx(ITreeNode origin, CSharpReparseContextType contextType, string contextHead, string contextTail);
    [CompilerGeneratedAttribute]
public CSharpReparseContextType get_Type();
    [CompilerGeneratedAttribute]
public ITreeNode get_Origin();
    [CompilerGeneratedAttribute]
public string get_ContextTail();
    [CompilerGeneratedAttribute]
public string get_ContextHead();
    public int get_HeadLength();
    [NotNullAttribute]
public ITreeNode Parse(string insertedText);
    [NotNullAttribute]
[PureAttribute]
private string GetFullCode(string insertedText);
    private static void DeleteFromParent(ITreeNode parsedNode);
    [CanBeNullAttribute]
public static CSharpReparseContextEx FindContext(IFile file, TreeTextRange range);
    [NotNullAttribute]
private static ITreeNode ChooseBetterOriginNode(ITreeNode origin);
    private static void SplitNode(ITreeNode node, TreeTextRange range, String& contextHead, String& contextTail);
    private static void FillNodeDecl(ITreeNode node, ITreeNode body, TreeTextRange selRange, StringBuilder& sbCur, StringBuilder sbTail);
    private static void CollapseNodeText(ITreeNode node, TreeTextRange selRange, StringBuilder& sbCur, StringBuilder sbTail);
    [NotNullAttribute]
public sealed virtual ReparseResult GetReparseResult(string newText);
    [CompilerGeneratedAttribute]
internal static ITreeNode <ChooseBetterOriginNode>g__GetPreviousMeaningfulChild|22_0(ITreeNode prevSibling);
    [CompilerGeneratedAttribute]
internal static bool <CollapseNodeText>g__IsAccessorOwnerDeclaration|25_0(ITreeNode someNode, IAccessorOwnerDeclaration& accessorOwner);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CSharpReparseContextType : Enum {
    public int value__;
    public static CSharpReparseContextType DocCommentBlock;
    public static CSharpReparseContextType ExtendsList;
    public static CSharpReparseContextType Statement;
    public static CSharpReparseContextType ArrowClause;
    public static CSharpReparseContextType ConstructorInitializer;
    public static CSharpReparseContextType TypeParametersConstraints;
    public static CSharpReparseContextType TypeMember;
    public static CSharpReparseContextType Namespace;
    public static CSharpReparseContextType File;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.CSharpReparsedCompletionContext : ReparsedCodeCompletionContext {
    public CSharpReparsedCompletionContext(IFile file, TreeTextRange range, string newText);
    protected virtual IReparseContext GetReparseContext(IFile file, TreeTextRange range);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Infrastructure.AspectLookupItems.CSharpKeywordInfo : TextualInfo {
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    public IPsiModule PsiModule { get; public set; }
    public CSharpKeywordInfo(string text, string identity);
    [CompilerGeneratedAttribute]
public IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PsiModule(IPsiModule value);
    public sealed virtual RichTextBlock GetDescription();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Infrastructure.AspectLookupItems.CSharpParameterNameInfo : TextualInfo {
    private DeclaredElementsOrPointers myParameterElement;
    [NotNullAttribute]
private ILookupItemsOwner myLookupItemsOwner;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    public IPsiModule PsiModule { get; public set; }
    public CSharpParameterNameInfo(string text, IDeclaredElement parameterElement, IElementPointerFactory elementPointerFactory, ILookupItemsOwner lookupItemsOwner);
    [CompilerGeneratedAttribute]
public IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PsiModule(IPsiModule value);
    public sealed virtual RichTextBlock GetDescription();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Infrastructure.CSharpCodeCompletionContext : ClrSpecificCodeCompletionContext {
    private ICSharpExpectedTypesProvider myExpectedTypesProvider;
    private bool myExpectedTypesContextCalculated;
    private ExpectedTypeCompletionContext myExpectedTypesContext;
    private HashSet`1<ILookupItem> myFrozenItems;
    private HashSet`1<ILookupItemBase> myFrozenItemsAlternative;
    [CompilerGeneratedAttribute]
private DocumentRange <ReplaceRangeWithJoinedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeArgumentsText>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCompletionArgumentsContext <ArgumentsContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCompletionFollowingExpressionContext <FollowingExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasArgumentListLBoundAfterCaret>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpReparsedCompletionContext <TerminatedContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpReparsedCompletionContext <UnterminatedContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsQualified>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccessContext <AccessContext>k__BackingField;
    [CompilerGeneratedAttribute]
private TextLookupRanges <CompletionRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <LanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpPrimaryParametersContext <PrimaryParametersContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolCache <SymbolCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContextId>k__BackingField;
    private Nullable`1<bool> mySpaceBeforeMethodCallParentheses;
    private Nullable`1<bool> mySpaceBeforeEmptyMethodCallParentheses;
    private Nullable`1<bool> mySpaceWithinMethodCallParentheses;
    private Nullable`1<bool> mySpaceWithinEmptyMethodCallParentheses;
    private Nullable`1<bool> mySpaceBeforeComma;
    private Nullable`1<bool> mySpaceAfterComma;
    [CanBeNullAttribute]
public ExpectedTypeCompletionContext ExpectedTypesContext { get; }
    public DocumentRange ReplaceRangeWithJoinedArguments { get; }
    public string TypeArgumentsText { get; }
    public CodeCompletionArgumentsContext ArgumentsContext { get; }
    public bool HasTypeArguments { get; }
    [CanBeNullAttribute]
public CodeCompletionFollowingExpressionContext FollowingExpression { get; }
    public bool HasArgumentListLBoundAfterCaret { get; }
    [NotNullAttribute]
public CSharpReparsedCompletionContext TerminatedContext { get; }
    [NotNullAttribute]
public CSharpReparsedCompletionContext UnterminatedContext { get; }
    public bool IsQualified { get; }
    public IAccessContext AccessContext { get; }
    public TextLookupRanges CompletionRanges { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public CSharpPrimaryParametersContext PrimaryParametersContext { get; }
    public ISymbolCache SymbolCache { get; }
    public ICSharpExpectedTypesProvider ExpectedTypesProvider { get; }
    public string ContextId { get; }
    public bool SpaceBeforeMethodCallParentheses { get; }
    public bool SpaceBeforeEmptyMethodCallParentheses { get; }
    public bool SpaceWithinMethodCallParentheses { get; }
    public bool SpaceWithinEmptyMethodCallParentheses { get; }
    public bool SpaceBeforeComma { get; }
    public bool SpaceAfterComma { get; }
    public CSharpCodeCompletionContext(ICSharpExpectedTypesProvider expectedTypesProvider, CodeCompletionContext context, CSharpReparsedCompletionContext terminatedContext, IPsiModule psiModule, bool isQualified, IAccessContext accessContext, TextLookupRanges completionRanges, ITreeNode nodeInFile, CSharpReparsedCompletionContext unterminatedContext, bool hasArgumentListLBoundAfterCaret, CodeCompletionFollowingExpressionContext followingExpression, bool hasTypeArguments, CodeCompletionArgumentsContext argumentsContext, string typeArgumentsText, DocumentRange replaceRangeWithJoinedArguments);
    public ExpectedTypeCompletionContext get_ExpectedTypesContext();
    [NotNullAttribute]
public static IReadOnlyList`1<ExpectedType> GetExpectedTypesWithoutDuplicates(IReadOnlyList`1<ExpectedType> expectedTypes);
    [CompilerGeneratedAttribute]
public DocumentRange get_ReplaceRangeWithJoinedArguments();
    [CompilerGeneratedAttribute]
public string get_TypeArgumentsText();
    [CompilerGeneratedAttribute]
public CodeCompletionArgumentsContext get_ArgumentsContext();
    [CompilerGeneratedAttribute]
public bool get_HasTypeArguments();
    [CompilerGeneratedAttribute]
public CodeCompletionFollowingExpressionContext get_FollowingExpression();
    [CompilerGeneratedAttribute]
public bool get_HasArgumentListLBoundAfterCaret();
    [CompilerGeneratedAttribute]
public CSharpReparsedCompletionContext get_TerminatedContext();
    [CompilerGeneratedAttribute]
public CSharpReparsedCompletionContext get_UnterminatedContext();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsQualified();
    [CompilerGeneratedAttribute]
public IAccessContext get_AccessContext();
    [CompilerGeneratedAttribute]
public TextLookupRanges get_CompletionRanges();
    [CompilerGeneratedAttribute]
public CSharpLanguageLevel get_LanguageLevel();
    [CompilerGeneratedAttribute]
public CSharpPrimaryParametersContext get_PrimaryParametersContext();
    [CompilerGeneratedAttribute]
public ISymbolCache get_SymbolCache();
    public ICSharpExpectedTypesProvider get_ExpectedTypesProvider();
    public bool IsAccessible(ITypeMember typeMember);
    public void Freeze(ILookupItem item);
    public void Freeze(LookupItem`1<DeclaredElementInfo> item);
    public bool IsFrozen(ILookupItemBase item);
    [CompilerGeneratedAttribute]
public virtual string get_ContextId();
    public bool get_SpaceBeforeMethodCallParentheses();
    public bool get_SpaceBeforeEmptyMethodCallParentheses();
    public bool get_SpaceWithinMethodCallParentheses();
    public bool get_SpaceWithinEmptyMethodCallParentheses();
    public bool get_SpaceBeforeComma();
    public bool get_SpaceAfterComma();
    [NotNullAttribute]
private string GetContextId();
}
[IntellisensePartAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Infrastructure.CSharpCodeCompletionContextProvider : CodeCompletionContextProviderBase {
    protected CSharpCodeCompletionManager CodeCompletionManager;
    private ILanguageManager myLanguageManager;
    public CSharpCodeCompletionContextProvider(CSharpCodeCompletionManager cSharpCodeCompletionManager, ILanguageManager languageManager);
    [NotNullAttribute]
protected virtual CSharpReparsedCompletionContext CreateReparseContext(CodeCompletionContext context, TreeTextRange selectedTreeRange, string newText);
    public virtual bool IsApplicable(CodeCompletionContext context);
    public virtual ISpecificCodeCompletionContext GetCompletionContext(CodeCompletionContext context);
    [PureAttribute]
private static bool InUnfinishedCharacterLiteral(ITreeNode elementToComplete);
    [PureAttribute]
private static bool IsElementFollowingStringLiteral(ITreeNode elementToComplete);
    [CanBeNullAttribute]
private string TypeArgumentsText(IReference reference);
    private static TreeTextRange GetElementRange(ITreeNode element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Infrastructure.CSharpPrimaryParametersContext : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IParameter, string> myShouldNotCapturePrimaryConstructorParameters;
    [CompilerGeneratedAttribute]
private bool <HasNonRecordPrimaryParametersInContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInContextWhereReferenceToPrimaryParameterIsAFormalParameterReference>k__BackingField;
    public bool HasNonRecordPrimaryParametersInContext { get; }
    public bool IsInContextWhereReferenceToPrimaryParameterIsAFormalParameterReference { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<IParameter, string> ShouldNotCapturePrimaryConstructorParameters { get; }
    internal CSharpPrimaryParametersContext(CSharpReparsedCompletionContext terminatedContext);
    private static void ScanParametersNotToCapture(Dictionary`2& shouldNotCaptureParameters, IList`1<IParameter> primaryConstructorParameters, IClassLikeDeclaration classLikeDeclaration);
    [CompilerGeneratedAttribute]
public bool get_HasNonRecordPrimaryParametersInContext();
    [CompilerGeneratedAttribute]
public bool get_IsInContextWhereReferenceToPrimaryParameterIsAFormalParameterReference();
    public IReadOnlyDictionary`2<IParameter, string> get_ShouldNotCapturePrimaryConstructorParameters();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <ScanParametersNotToCapture>g__LooksLikePrimaryConstructorParameterReference|2_0(ICSharpExpression expression, <>c__DisplayClass2_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Infrastructure.ExpectedTypeCompletionContext : ExpectedTypeCompletionContextBase {
    public CSharpReparsedCompletionContext ReparseContextUsed;
    [CompilerGeneratedAttribute]
private Dictionary`2<IDeclaredElement, IDeclaredElement> <ElementsToReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<IDeclaredElement> <ElementsToExclude>k__BackingField;
    [CompilerGeneratedAttribute]
private TailType <CommonTailType>k__BackingField;
    [CompilerGeneratedAttribute]
private HeadType <CommonHeadType>k__BackingField;
    public Dictionary`2<IDeclaredElement, IDeclaredElement> ElementsToReplace { get; }
    public HashSet`1<IDeclaredElement> ElementsToExclude { get; }
    public TailType CommonTailType { get; }
    public HeadType CommonHeadType { get; }
    public ExpectedTypeCompletionContext(IReadOnlyList`1<ExpectedType> expectedTypes, HashSet`1<IDeclaredElement> elementsToExclude, Dictionary`2<IDeclaredElement, IDeclaredElement> elementsToReplace, CSharpReparsedCompletionContext reparseContext, CodeCompletionContext context);
    [CompilerGeneratedAttribute]
public Dictionary`2<IDeclaredElement, IDeclaredElement> get_ElementsToReplace();
    [CompilerGeneratedAttribute]
public HashSet`1<IDeclaredElement> get_ElementsToExclude();
    [CompilerGeneratedAttribute]
public TailType get_CommonTailType();
    [CompilerGeneratedAttribute]
public HeadType get_CommonHeadType();
    [CanBeNullAttribute]
public static ICSharpExpression GetExpressionForExpectedTypes(CSharpReparsedCompletionContext& resparseContext, CSharpReparsedCompletionContext unterminatedContext, CSharpReparsedCompletionContext terminatedContext);
    public static void EvaluateElementsToExclude(bool isQualified, ICSharpExpression expression, HashSet`1<IDeclaredElement> elementsToExclude, Dictionary`2<IDeclaredElement, IDeclaredElement> elementsToReplace, CSharpReparsedCompletionContext reparseContext);
    private static void ExcludeNotAssignedTooScopyVariables(ICSharpExpression expression);
    [PureAttribute]
private static bool IsLikelyNotDefinitelyAssignedVariableDesignation(ISingleVariableDesignation variableDesignation, ICSharpExpression usageExpression);
    private static void ExcludeMemberItselfUnderItsReturnValueHolder(ICSharpExpression expression, HashSet`1<IDeclaredElement> elementsToExclude, Dictionary`2<IDeclaredElement, IDeclaredElement> elementsToReplace);
    private static void ExcludeRefLikeLocalVariables(ICSharpClosure closure, HashSet`1<IDeclaredElement> elementsToExclude);
    [CompilerGeneratedAttribute]
internal static void <ExcludeRefLikeLocalVariables>g__Append|19_0(IEnumerable`1<IDeclaredElement> elements, <>c__DisplayClass19_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Naming.CSharpNameCompletionUtil : NameCompletionUtil {
    [NotNullAttribute]
private IPsiSourceFile mySourceFile;
    [NotNullAttribute]
private NamingManager myNamingManager;
    [NotNullAttribute]
private INamingPolicyProvider myNamingPolicyProvider;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private string myPrefix;
    public CSharpNameCompletionUtil(IPsiSourceFile sourceFile, string prefix);
    [CanBeNullAttribute]
public IReadOnlyCollection`1<string> SuggestNamesOfIdentifier(ICSharpIdentifier identifier);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> ParameterDeclarationName(ICSharpParameterDeclaration parameterDeclaration);
    private static void SuggestConstructorParameterNameFromMembers(IType parameterType, IConstructorDeclaration constructorDeclaration, INamesCollection namesCollection);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> LocalVariableName(ILocalVariableDeclaration variableDeclaration);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> LocalConstantName(ILocalConstantDeclaration localConstantDeclaration);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> LocalFunctionName(ILocalFunctionDeclaration localFunctionDeclaration);
    [PureAttribute]
public static bool IsBrokenConstantPatternParsedAsDeclarationPattern(ITypePattern typePattern);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> TypePatternName(ITypePattern typePattern, ISingleVariableDesignation variableDesignation);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> VarPatternName(IVarPattern varPattern, ISingleVariableDesignation variableDesignation);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> RecursivePattern(IRecursivePattern recursivePattern, ISingleVariableDesignation variableDesignation);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> DeclarationExpressionName(IDeclarationExpression declarationExpression, IVariableDesignation variableDesignation);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> OutArgumentVariableName(ICSharpArgument outArgument, IDeclarationExpression declarationExpression, IVariableDesignation variableDesignation);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> ForeachVariableName(IForeachStatement foreachStatement, IDeclarationExpression declarationExpression, IVariableDesignation iteratorDeclaration);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> SuggestDeclarationExpressionName(INamesCollection namesCollection, IDeclarationExpression declarationExpression, IVariableDesignation variableDesignation, bool includeDiscard);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> VariableDesignationName(INamesCollection namesCollection, IVariableDesignation variableDesignation, bool includeDiscard);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> TupleComponentName(ITupleTypeComponent tupleComponent);
    private void SuggestByTupleExpressionsUnderReturn(ITupleTypeComponent tupleTypeComponent, INamesCollection namesCollection);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> CatchVariableName(ICatchVariableDeclaration catchVariableDeclaration);
    [NotNullAttribute]
private static IReadOnlyCollection`1<string> DestructorDeclarationName(IDestructorDeclaration destructorDeclaration);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> PropertyDeclarationName(IPropertyDeclaration propertyDeclaration);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> MethodPropertyEventFieldDeclarationName(IModifiersOwnerDeclaration modifiersOwnerDeclaration, IDeclaredElement declaredElement, ITypeUsage typeUsage);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> ConstantDeclarationName(IConstantDeclaration constantDeclaration);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> QueryRangeVariableName(IQueryRangeVariableDeclaration queryDeclaration);
    [NotNullAttribute]
private IReadOnlyCollection`1<string> SuggestNameForTypeOwner(IType type, NamedElementKinds namedElementKind, IDeclaredElement declaredElement, IElementKind elementKind);
    [NotNullAttribute]
[PureAttribute]
private INamesCollection CreateSuggestionCollection(PluralityKinds pluralityKind);
    [NotNullAttribute]
[PureAttribute]
private IReadOnlyCollection`1<string> SuggestNamesImpl(IEnumerable`1<NameRoot> roots, NamingPolicy namingPolicy);
    [NotNullAttribute]
[PureAttribute]
private static IReadOnlyCollection`1<string> SuggestUnresolvedNames(IReadOnlyCollection`1<string> suggestedNames, ITreeNode scope, Func`2<IDeclaredElement, bool> customFilter);
    private void AppendDeconstructionSuggestions(IDeconstructionReference deconstructionReference, int componentIndex, INamesCollection namesCollection);
    private void AppendPatternDispatchSourceSuggestions(IPattern pattern, INamesCollection namesCollection);
    [PureAttribute]
public static bool IsPrefixLocalVariableSuggestion(ICSharpIdentifier nameIdentifier, ICSharpExpression& initializedExpression);
    [CompilerGeneratedAttribute]
private void <SuggestByTupleExpressionsUnderReturn>g__ProcessReturnExpression|22_0(ICSharpExpression expression, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
internal static CSharpCodeBody <SuggestByTupleExpressionsUnderReturn>g__GetBodyByReturnTypeUsage|22_1(ITypeUsage returnTypeUsage);
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <MethodPropertyEventFieldDeclarationName>g__SuggestNameForField|26_0(IType type, <>c__DisplayClass26_0& );
    [CompilerGeneratedAttribute]
private NamedElementKinds <MethodPropertyEventFieldDeclarationName>g__GetFieldKind|26_1(<>c__DisplayClass26_0& );
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.CodeCompletion.Settings.AutopopupEnabledSettingsKey", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Settings.CSharpAutopopupEnabledSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "LetterAndDigitsSettingDescription")]
public AutopopupType OnIdent;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "AfterDotSettingDescription")]
public AutopopupType AfterDot;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "AfternewSettingDescription")]
public AutopopupType AfterNew;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "InStringLiteralsSettingDescription")]
public AutopopupType InStringLiterals;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "WhereValueIsExpectedSettingDescription")]
public AutopopupType WhereValueIsExpected;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "InDocCommentsSettingDescription")]
public AutopopupType InDocComments;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Settings.CSharpCodeCompletionManager : LanguageSpecificCodeCompletionManager {
    public PsiLanguageType PsiLanguage { get; }
    public CSharpCodeCompletionManager(CodeCompletionSettingsService codeCompletionSettings);
    public virtual SettingsScalarEntry GetSettingsEntry(ISettingsSchema settingsSchema);
    public virtual PsiLanguageType get_PsiLanguage();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.CodeCompletion.Settings.IntelliSenseCompletingCharactersSettingsKey", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Settings.CSharpCompletingCharactersSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CompleteOnSpaceSettingDescription")]
public bool CompleteOnSpace;
    [NullableAttribute("1")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "NonCompletingCharactersSettingDescription")]
public string NonCompletingCharacters;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "UpgradedFromVSSettingsSettingDescription")]
public bool UpgradedFromVSSettings;
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.CodeCompletion.Settings.IntellisenseEnabledSettingsKey", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CIntelliSenseEnabledSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.Settings.IntellisenseEnabledSettingCSharp : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CCsFilesAndCCodeInSupportedServerPagesSettingDescription")]
public bool IntellisenseEnabled;
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.SmartCompletion.ISmartCompleatebleReference {
}
[ShellComponentAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeCompletion.UprgadeCSharpCompletingCharsSettings : object {
    private GlobalCompletionSettingsService myGlobalCompletionSettingsService;
    private Nullable`1<bool> myUpgradedFromGlobalSettings;
    public static string VSDefaultCompleteCharacters;
    public UprgadeCSharpCompletingCharsSettings(GlobalCompletionSettingsService globalCompletionSettingsService);
    public void UpdateSettingsIfNecessary(IContextBoundSettingsStore settingsStore);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeInsight.CSharpLocalSymbolsServiceProvider : LocalSymbolsServiceProviderBase`2<IBlock, ICSharpStatement> {
    protected virtual List`1<TypedAndNamedEntity> GetAdditionalEntries(ITreeNode element);
    protected virtual ISymbolTable FilterVisibleVariables(ISymbolTable table, IAccessContext context, ITreeNode element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CodeStructureProcessingState : object {
    private Func`1<bool> myCheckForInterrupt;
    private CodeStructureOptions myOptions;
    private Stack`1<CSharpCodeStructureRegion> myRegions;
    public Func`1<bool> Interrupted { get; }
    public CodeStructureOptions Options { get; }
    public Stack`1<CSharpCodeStructureRegion> Regions { get; }
    public CodeStructureProcessingState(Func`1<bool> checkForInterrupt, CodeStructureOptions options);
    public Func`1<bool> get_Interrupted();
    public CodeStructureOptions get_Options();
    public Stack`1<CSharpCodeStructureRegion> get_Regions();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureAspect : CodeStructureDeclarationAspects {
    private CSharpCodeStructureDeclaredElement myElement;
    public bool InitiallyExpanded { get; }
    public CSharpCodeStructureAspect(CSharpCodeStructureDeclaredElement element, IDeclaration declaration);
    public virtual bool get_InitiallyExpanded();
    protected virtual IList`1<string> CalculateQuickSearchTexts(IDeclaration declaration);
    public virtual void Present(StructuredPresenter`2<TreeModelNode, IPresentableItem> presenter, IPresentableItem item, TreeModelNode modelNode, PresentationState state);
    public virtual bool CanMoveElements(RelativeLocation location, IList`1<CodeStructureElement> dropElements);
    public virtual void MoveElements(RelativeLocation location, IList`1<CodeStructureElement> dropElements);
    public virtual DocumentRange[] GetNavigationRanges();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureAttribute : CodeStructureElement {
    [NotNullAttribute]
private ITreeNodePointer`1<IAttribute> myAttributePointer;
    private DocumentRange myDocumentRange;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    public ITreeNode TreeNode { get; }
    public PsiLanguageType Language { get; }
    public IAttribute Attribute { get; }
    public DocumentRange NavigationRange { get; }
    private bool JetBrains.ReSharper.Feature.Services.CodeStructure.IFileStructureAspect.InitiallyExpanded { get; }
    public CSharpCodeStructureAttribute(CodeStructureElement parentElement, IAttribute attribute);
    public virtual ITreeNode get_TreeNode();
    [CompilerGeneratedAttribute]
public virtual PsiLanguageType get_Language();
    public IAttribute get_Attribute();
    public virtual IFileStructureAspect GetFileStructureAspect();
    public virtual IGotoFileMemberAspect GetGotoMemberAspect();
    public virtual IMemberNavigationAspect GetMemberNavigationAspect();
    public virtual DocumentRange GetTextRange();
    protected virtual void DumpSelf(TextWriter builder);
    private sealed virtual override DocumentRange[] JetBrains.ReSharper.Feature.Services.CodeStructure.IMemberNavigationAspect.GetNavigationRanges();
    private sealed virtual override void JetBrains.ReSharper.Feature.Services.CodeStructure.IFileStructureAspect.Present(StructuredPresenter`2<TreeModelNode, IPresentableItem> presenter, IPresentableItem item, TreeModelNode modelNode, PresentationState state);
    public sealed virtual DocumentRange get_NavigationRange();
    private sealed virtual override bool JetBrains.ReSharper.Feature.Services.CodeStructure.IFileStructureAspect.get_InitiallyExpanded();
    public sealed virtual IList`1<string> GetQuickSearchTexts();
    private sealed virtual override bool JetBrains.ReSharper.Feature.Services.CodeStructure.IFileStructureAspect.CanMoveElements(RelativeLocation location, IList`1<CodeStructureElement> dropElements);
    private sealed virtual override void JetBrains.ReSharper.Feature.Services.CodeStructure.IFileStructureAspect.MoveElements(RelativeLocation location, IList`1<CodeStructureElement> dropElements);
    private sealed virtual override bool JetBrains.ReSharper.Feature.Services.CodeStructure.IFileStructureAspect.CanRemove();
    private sealed virtual override void JetBrains.ReSharper.Feature.Services.CodeStructure.IFileStructureAspect.Remove();
    public sealed virtual bool CanRename();
    public sealed virtual string InitialName();
    public sealed virtual void Rename(string newName);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureClass : CSharpCodeStructureDeclaredElement {
    public CSharpCodeStructureClass(CodeStructureElement parentElement, IDeclaration declaration, CSharpCodeStructureProcessingState state);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureDeclaredElement : CodeStructureDeclarationElement {
    private InheritanceInformation myInheritanceInformation;
    private CSharpCodeStructureRegion myRegion;
    private CSharpCodeStructureAspect myAspect;
    [CompilerGeneratedAttribute]
private bool <InitiallyCollapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChildrenHasInheritance>k__BackingField;
    public ICodeStructureBlockStart ParentBlock { get; }
    public InheritanceInformation InheritanceInformation { get; }
    public bool InitiallyCollapsed { get; public set; }
    public bool ChildrenHasInheritance { get; public set; }
    public CSharpCodeStructureDeclaredElement(CodeStructureElement parentElement, IDeclaration declaration, CSharpCodeStructureProcessingState state);
    public virtual ICodeStructureBlockStart get_ParentBlock();
    public InheritanceInformation get_InheritanceInformation();
    [CompilerGeneratedAttribute]
public bool get_InitiallyCollapsed();
    [CompilerGeneratedAttribute]
public void set_InitiallyCollapsed(bool value);
    [CompilerGeneratedAttribute]
public bool get_ChildrenHasInheritance();
    [CompilerGeneratedAttribute]
public void set_ChildrenHasInheritance(bool value);
    public virtual IFileStructureAspect GetFileStructureAspect();
    public virtual IGotoFileMemberAspect GetGotoMemberAspect();
    public virtual IMemberNavigationAspect GetMemberNavigationAspect();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureEndRegion : CodeStructurePreprocessorElement {
    private CSharpCodeStructureRegion myRegion;
    public ICodeStructureBlockStart ParentBlock { get; }
    public CSharpCodeStructureEndRegion(CodeStructureElement parentElement, ITreeNode preprocessorDirective, CSharpCodeStructureProcessingState state);
    protected virtual string GetText();
    public virtual bool CanMoveElements(RelativeLocation location, IList`1<CodeStructureElement> dropElements);
    public virtual void MoveElements(RelativeLocation location, IList`1<CodeStructureElement> dropElements);
    public virtual ICodeStructureBlockStart get_ParentBlock();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureEnregionService : object {
    public PsiLanguageType Language { get; }
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual ITreeNode Execute(IList`1<CodeStructureElement> elements);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureLocalFunction : CSharpCodeStructureDeclaredElement {
    public CSharpCodeStructureLocalFunction(CodeStructureElement parentElement, ILocalFunctionDeclaration declaration, CSharpCodeStructureProcessingState state);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureNamespace : CSharpCodeStructureDeclaredElement {
    public CSharpCodeStructureNamespace(CodeStructureElement parentElement, IDeclaration declaration, CSharpCodeStructureProcessingState state);
    public virtual IMemberNavigationAspect GetMemberNavigationAspect();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureProcessingState : object {
    private CodeStructureOptions myOptions;
    private Stack`1<CSharpCodeStructureRegion> myRegions;
    public CodeStructureOptions Options { get; }
    public Stack`1<CSharpCodeStructureRegion> Regions { get; }
    public CSharpCodeStructureProcessingState(CodeStructureOptions options);
    public CodeStructureOptions get_Options();
    public Stack`1<CSharpCodeStructureRegion> get_Regions();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureProvider : object {
    public virtual CodeStructureRootElement Build(IFile file, CodeStructureOptions options);
    private static void ProcessElement(ITreeNode element, CodeStructureElement parentElement, CSharpCodeStructureProcessingState state);
    private static void ProcessAttributeSection(IAttributeSection section, CodeStructureElement parentElement);
    private static void ProcessPreprocessor(IPreprocessorDirective preprocessorDirective, CodeStructureElement parentElement, CSharpCodeStructureProcessingState state);
    private static void ProcessMultiDeclaration(IMultipleDeclaration multiDeclaration, CodeStructureElement parentElement, CSharpCodeStructureProcessingState state);
    private static void ProcessDeclaration(IDeclaration declaration, CodeStructureElement parentElement, CSharpCodeStructureProcessingState state);
    protected static void ProcessChildren(ITreeNode element, CodeStructureElement structureElement, CSharpCodeStructureProcessingState state);
    protected static void ProcessLocalFunctions(ITreeNode element, CodeStructureElement structureElement, CSharpCodeStructureProcessingState state);
    internal static ITreeNode GetLastToken(ITreeNode node);
    public static bool CanMoveElements(CodeStructureElement anchor, RelativeLocation relativeLocation, IEnumerable`1<CodeStructureElement> dropElements);
    public static void MoveElements(CodeStructureElement anchor, RelativeLocation location, IList`1<CodeStructureElement> elements);
    private static IList`1<IDeclarationsRange> FindRanges(IList`1<CodeStructureElement> items, CodeStructureElement anchor);
    private static IDeclarationsRange MoveItems(ITreeNode parent, ITreeNode anchor, bool moveBefore, IList`1<IDeclarationsRange> ranges);
    private static TreeTextRange JoinRanges(IEnumerable`1<IDeclarationsRange> ranges);
    private static IDeclarationsRange MoveDeclarations(IDeclarationsRangeContainer parent, IList`1<IDeclarationsRange> declarationsRanges, ITreeNode anchor, bool moveBefore);
    internal static void RemoveRegion(CSharpCodeStructureRegion region);
    public static void RenameRegion(CSharpCodeStructureRegion region, string name);
    public static ITreeNode EncloseInRegion(IList`1<CodeStructureElement> items);
    private static ITreeNode EncloseInRegionHandler(IList`1<CodeStructureElement> items);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureRegion : CodeStructurePreprocessorElement {
    [CanBeNullAttribute]
private CSharpCodeStructureRegion myRegion;
    [CompilerGeneratedAttribute]
private bool <Expanded>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpCodeStructureEndRegion <EndRegion>k__BackingField;
    public bool Expanded { get; public set; }
    public ICodeStructureBlockStart ParentBlock { get; }
    internal CSharpCodeStructureEndRegion EndRegion { get; internal set; }
    public CSharpCodeStructureRegion(CodeStructureElement parentElement, ITreeNode preprocessorDirective, CSharpCodeStructureProcessingState state);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Expanded();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Expanded(bool value);
    public virtual ICodeStructureBlockStart get_ParentBlock();
    [CompilerGeneratedAttribute]
internal CSharpCodeStructureEndRegion get_EndRegion();
    [CompilerGeneratedAttribute]
internal void set_EndRegion(CSharpCodeStructureEndRegion value);
    protected virtual string GetText();
    public virtual bool CanMoveElements(RelativeLocation location, IList`1<CodeStructureElement> dropElements);
    public virtual void MoveElements(RelativeLocation location, IList`1<CodeStructureElement> dropElements);
    public virtual bool CanRemove();
    public virtual void Remove();
    public virtual bool CanRename();
    public virtual string InitialName();
    public virtual void Rename(string newName);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStructure.CSharpCodeStructureRootElement : CodeStructureRootElement {
    public CSharpCodeStructureRootElement(ICSharpFile file);
    public virtual PresentationState CreatePresentationState();
    private static void CountState(CodeStructureElement element, Int32& namespaceCount, Int32& typeCount);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.AccessorOwnerBodyStyleInspector : CodeStyleInspectorBase`1<IArrangeAccessorOwnerBodyCodeStyleSuggestion> {
    public virtual void DetectSettings(IDetectionContext context);
    private static AccessorInfo GetAccessorAndBody(IAccessorOwnerDeclaration declaration, AccessorKind firstKind, AccessorKind secondKind);
    public virtual IArrangeAccessorOwnerBodyCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static AccessorOwnerContext CreateContext(IAccessorOwnerDeclaration accessorOwner);
    private static CSharpCodeBody GetCodeBodyFor(IAccessorOwnerDeclaration accessorOwner);
    private static bool CanInspect(AccessorOwnerContext accessorOwnerContext);
    private static Nullable`1<AccessorOwnerBodyFix> TrySuggestFix(AccessorOwnerContext accessorOwnerContext, AccessorOwnerBodyStyle bodyStyle, bool useHeuristics);
    [CanBeNullAttribute]
[PureAttribute]
private static Nullable`1<AccessorOwnerBodyFix> TryGetSuggestionForBlockBody(CSharpCodeBody getterOrAdderBody, CSharpCodeBody setterOrRemoverBody);
    [CanBeNullAttribute]
[PureAttribute]
private static Nullable`1<AccessorOwnerBodyFix> TryGetSuggestionForExpressionBody(CSharpCodeBody getterBody, CSharpCodeBody setterBody, IAccessorDeclaration getterDeclaration, bool useHeuristics);
    [CanBeNullAttribute]
[PureAttribute]
private static Nullable`1<AccessorOwnerBodyFix> TryGetSuggestionForExpressionBodiedAccessors(CSharpCodeBody accessorOwnerBody, CSharpCodeBody getterOrAdderBody, CSharpCodeBody setterOrRemoverBody, bool useHeuristics);
    [PureAttribute]
private static bool BlockBodyCanBecomeExpression(CSharpCodeBody body, bool useHeuristics);
    private static Nullable`1<StatementToExpressionConversion> TryGetExpressionConversionFor(CSharpCodeBody body);
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__AddCase|2_0(AccessorOwnerBodyStyle style, bool useHeuristics, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__Detect|2_1(AccessorInfo accessorInfo, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <TryGetSuggestionForExpressionBody>g__CanUseExpressionBodiedProperty|10_0(<>c__DisplayClass10_0& );
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ArgumentDescriptor : ValueType {
    [CompilerGeneratedAttribute]
private ICSharpArgument <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgumentsValueType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> <SettingAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStore <SettingsStore>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpArgumentsOwner <ArgumentsOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpParameterInstance <MatchingParameter>k__BackingField;
    [NotNullAttribute]
public ICSharpArgument Argument { get; }
    [NotNullAttribute]
public IParameter Parameter { get; }
    public ArgumentsValueType ValueType { get; }
    [NotNullAttribute]
public Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> SettingAccessor { get; }
    [NotNullAttribute]
public IContextBoundSettingsStore SettingsStore { get; }
    [NotNullAttribute]
public ICSharpArgumentsOwner ArgumentsOwner { get; }
    [NotNullAttribute]
public CSharpParameterInstance MatchingParameter { get; }
    public ArgumentsStyle Style { get; }
    public bool IsExpandedParamsParameter { get; }
    public ArgumentDescriptor(ArgumentsValueType valueType, IParameter parameter, ICSharpArgument argument, Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> settingAccessor, IContextBoundSettingsStore settingsStore, ICSharpArgumentsOwner argumentsOwner, CSharpParameterInstance matchingParameter);
    [CompilerGeneratedAttribute]
public ICSharpArgument get_Argument();
    [CompilerGeneratedAttribute]
public IParameter get_Parameter();
    [CompilerGeneratedAttribute]
public ArgumentsValueType get_ValueType();
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> get_SettingAccessor();
    [CompilerGeneratedAttribute]
public IContextBoundSettingsStore get_SettingsStore();
    [CompilerGeneratedAttribute]
public ICSharpArgumentsOwner get_ArgumentsOwner();
    [CompilerGeneratedAttribute]
public CSharpParameterInstance get_MatchingParameter();
    public ArgumentsStyle get_Style();
    public bool get_IsExpandedParamsParameter();
    public void Deconstruct(ICSharpArgument& argument, String& matchingParameterName, ArgumentsValueType& type);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ArgumentProcessor : MulticastDelegate {
    public ArgumentProcessor(object object, IntPtr method);
    public virtual bool Invoke(ArgumentDescriptor descriptor, ArgumentProcessorAdditionalParams additionalParams);
    public virtual IAsyncResult BeginInvoke(ArgumentDescriptor descriptor, ArgumentProcessorAdditionalParams additionalParams, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ArgumentProcessorAdditionalParams : ValueType {
    [CompilerGeneratedAttribute]
private IList`1<ArgumentCodeStyleSuggestion> <Suggestions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDetectionContext <DetectionContext>k__BackingField;
    [CanBeNullAttribute]
public IList`1<ArgumentCodeStyleSuggestion> Suggestions { get; public set; }
    [CanBeNullAttribute]
public IDetectionContext DetectionContext { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<ArgumentCodeStyleSuggestion> get_Suggestions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Suggestions(IList`1<ArgumentCodeStyleSuggestion> value);
    [CompilerGeneratedAttribute]
public IDetectionContext get_DetectionContext();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DetectionContext(IDetectionContext value);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ArgumentsCodeStyleInspector : CodeStyleInspectorBase`1<IArgumentsCodeStyleSuggestion> {
    [NotNullAttribute]
private static ArgumentProcessor ourSuggester;
    [NotNullAttribute]
private static ArgumentProcessor ourDetector;
    private static ArgumentsCodeStyleInspector();
    public virtual IArgumentsCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static bool Suggest(ArgumentDescriptor descriptor, ArgumentProcessorAdditionalParams params);
    public virtual void DetectSettings(IDetectionContext context);
    private static bool Detect(ArgumentDescriptor descriptor, ArgumentProcessorAdditionalParams params);
    private static bool ProcessArguments(ITreeNode node, IContextBoundSettingsStore settingsStore, ArgumentProcessorAdditionalParams processorAdditionalParams, ArgumentProcessor argumentProcessor);
    private static Nullable`1<ArgumentsOwnerDescriptor> TryGetArgumentsOwnerDescriptor(ITreeNode node);
    private static Nullable`1<ArgumentCodeStyleSuggestion> TrySuggestStyle(ArgumentDescriptor descriptor);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ArgumentsInspectionUtil : object {
    internal static Nullable`1<ArgumentsValueType> TryGetArgumentValueType(ICSharpExpression argumentValue);
    [CanBeNullAttribute]
internal static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> TryGetSettingAccessor(ArgumentsValueType argumentsValueType);
    private static bool IsStringLiteral(ILiteralExpression literalExpression);
    internal static bool IsIndexer(IDeclaredElement declaredElement);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ArgumentsOwnerDescriptor : ValueType {
    [CompilerGeneratedAttribute]
private ICSharpArgumentsOwner <ArgumentsOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private IParametersOwner <ParametersOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveResultWithInfo <ResolveResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRangeValid>k__BackingField;
    [NotNullAttribute]
public ICSharpArgumentsOwner ArgumentsOwner { get; public set; }
    [NotNullAttribute]
public IParametersOwner ParametersOwner { get; public set; }
    [NotNullAttribute]
public ResolveResultWithInfo ResolveResult { get; public set; }
    public bool IsRangeValid { get; public set; }
    [CompilerGeneratedAttribute]
public ICSharpArgumentsOwner get_ArgumentsOwner();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ArgumentsOwner(ICSharpArgumentsOwner value);
    [CompilerGeneratedAttribute]
public IParametersOwner get_ParametersOwner();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParametersOwner(IParametersOwner value);
    [CompilerGeneratedAttribute]
public ResolveResultWithInfo get_ResolveResult();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResolveResult(ResolveResultWithInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsRangeValid();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsRangeValid(bool value);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.AttributesCodeStyleInspector : CodeStyleInspectorBase`1<IArrangeAttributesCodeStyleSuggestion> {
    public virtual IArrangeAttributesCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static bool AtLeastTwoSectionsHaveSameTargets(TreeNodeCollection`1<IAttributeSection> sections);
    [CanBeNullAttribute]
private static IAttributeSectionList TryGetAttributeSectionList(ITreeNode node);
    public virtual void DetectSettings(IDetectionContext context);
    private static bool IsSeparateStyle(IAttributeSectionList attributeSectionList);
    private static bool IsJoinStyle(IAttributeSectionList attributeSectionList);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.BinaryExpressionDescriptor : ValueType {
    [CompilerGeneratedAttribute]
private IBinaryExpression <ParentExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IBinaryExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperationType <ParentExpressionOperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperationGroupType <ParentExpressionOperationGroupType>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperationType <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperationGroupType <OperationGroupType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParenthesized>k__BackingField;
    [CanBeNullAttribute]
public IBinaryExpression ParentExpression { get; public set; }
    [NotNullAttribute]
public IBinaryExpression Expression { get; public set; }
    public BinaryOperationType ParentExpressionOperationType { get; public set; }
    public BinaryOperationGroupType ParentExpressionOperationGroupType { get; public set; }
    public BinaryOperationType OperationType { get; public set; }
    public BinaryOperationGroupType OperationGroupType { get; public set; }
    public bool IsParenthesized { get; public set; }
    [CompilerGeneratedAttribute]
public IBinaryExpression get_ParentExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParentExpression(IBinaryExpression value);
    [CompilerGeneratedAttribute]
public IBinaryExpression get_Expression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Expression(IBinaryExpression value);
    [CompilerGeneratedAttribute]
public BinaryOperationType get_ParentExpressionOperationType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParentExpressionOperationType(BinaryOperationType value);
    [CompilerGeneratedAttribute]
public BinaryOperationGroupType get_ParentExpressionOperationGroupType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParentExpressionOperationGroupType(BinaryOperationGroupType value);
    [CompilerGeneratedAttribute]
public BinaryOperationType get_OperationType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OperationType(BinaryOperationType value);
    [CompilerGeneratedAttribute]
public BinaryOperationGroupType get_OperationGroupType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OperationGroupType(BinaryOperationGroupType value);
    [CompilerGeneratedAttribute]
public bool get_IsParenthesized();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsParenthesized(bool value);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.BracesCodeStyleInspector : CodeStyleInspectorBase`1<IBracesCodeStyleSuggestion> {
    public virtual IBracesCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    public virtual void DetectSettings(IDetectionContext context);
    private static bool CanOmitBraces(ICSharpStatement statement);
    [CanBeNullAttribute]
private static IBracesCodeStyleSuggestion TrySuggest(ICSharpStatement statement, IContextBoundSettingsStore settingsStore);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.BracesInspectorContext : ValueType {
    [NotNullAttribute]
private static Expression`1<Func`2<CSharpFormatSettingsKey, bool>> INDENT_NESTED_FOR_STMT;
    [NotNullAttribute]
private static Expression`1<Func`2<CSharpFormatSettingsKey, bool>> INDENT_NESTED_FOREACH_STMT;
    [NotNullAttribute]
private static Expression`1<Func`2<CSharpFormatSettingsKey, bool>> INDENT_NESTED_WHILE_STMT;
    [NotNullAttribute]
private static Expression`1<Func`2<CSharpFormatSettingsKey, bool>> INDENT_NESTED_USINGS_STMT;
    [NotNullAttribute]
private static Expression`1<Func`2<CSharpFormatSettingsKey, bool>> INDENT_NESTED_LOCK_STMT;
    [NotNullAttribute]
private static Expression`1<Func`2<CSharpFormatSettingsKey, bool>> INDENT_NESTED_FIXED_STMT;
    [NotNullAttribute]
private Func`2<ITreeNode, bool> myIsSameTypeFunc;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<CSharpFormatSettingsKey, bool>> <IndentNested>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> <SettingAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpStatement <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpStatement <Statement>k__BackingField;
    [CanBeNullAttribute]
public Expression`1<Func`2<CSharpFormatSettingsKey, bool>> IndentNested { get; }
    [NotNullAttribute]
public Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> SettingAccessor { get; }
    [NotNullAttribute]
public ICSharpStatement Body { get; }
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    public BracesInspectorContext(ICSharpStatement statement, ICSharpStatement body, Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> settingAccessor, Expression`1<Func`2<CSharpFormatSettingsKey, bool>> indentNested, Func`2<ITreeNode, bool> isSameTypeFunc);
    private static BracesInspectorContext();
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<CSharpFormatSettingsKey, bool>> get_IndentNested();
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> get_SettingAccessor();
    [CompilerGeneratedAttribute]
public ICSharpStatement get_Body();
    [CompilerGeneratedAttribute]
public ICSharpStatement get_Statement();
    public bool IsSameTypeAsStatement(ITreeNode otherNode);
    public void Deconstruct(ICSharpStatement& statement, ICSharpStatement& body);
    internal static Nullable`1<BracesInspectorContext> GetContext(ICSharpStatement statement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.BracesUtil : object {
    [NotNullAttribute]
public static Regex LineBreakRegex;
    private static BracesUtil();
    [ExtensionAttribute]
public static bool CanRemoveBracesFromStatementBlock(ICSharpStatement _, IBlock block);
    [PureAttribute]
internal static bool IsComplexNode(ITreeNode statementBody);
    [PureAttribute]
internal static bool IsMultilineStatement(ICSharpStatement statementBody);
    [PureAttribute]
private static bool IsMultilineNode(ICSharpTreeNode treeNode);
    [PureAttribute]
private static bool IsMultilineStatementBlock(IBlock block);
    internal static IfStatementBracesRedundancyMetadata GetRedundancyMetadata(IIfStatement ifElseStatement);
    internal static IfStatementBracesRedundancyMetadata GetRedundancyMetadataWithSettings(IIfStatement ifElseStatement, bool bracesRedundancyAllowed, bool specialElseIfTreatment);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.BuiltInTypeReferencesInspectionUtil : object {
    [CanBeNullAttribute]
internal static IScalarSetting TryGetSettingFrom(IReadOnlyDetectionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.BuiltInTypeReferenceStyleInspector : CodeStyleInspectorBase`1<IBuiltInTypeReferenceStyleSuggestion> {
    public virtual IBuiltInTypeReferenceStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    [PureAttribute]
private static bool ShouldProcessPredefinedTypeUsage(IPredefinedTypeUsage predefinedTypeUsage);
    [PureAttribute]
private static BuiltInTypeStyle GetCodeStylePreference(IContextBoundSettingsStore settingsStore, bool isExpression);
    [PureAttribute]
private static IBuiltInTypeReferenceStyleSuggestion InspectPredefinedTypeUsage(ITreeNode node, IReference predefinedTypeReference, IContextBoundSettingsStore boundSettingsStore);
    [PureAttribute]
private static bool ShouldProcessPredefinedTypeReference(IReference predefinedTypeReference);
    [PureAttribute]
private static IBuiltInTypeReferenceStyleSuggestion InspectClrTypeUsage(ITreeNode node, IQualifiableReference qualifiableReference, IContextBoundSettingsStore settingsStore);
    [PureAttribute]
private static bool ShouldInspectUserTypeUsage(IUserTypeUsage userTypeUsage);
    [PureAttribute]
private static bool IsStateOfExplicitLayoutStruct(IUserTypeUsage userTypeUsage);
    [PureAttribute]
private static bool ShouldApplyBuiltInTypeStyleToNativeNumeric(ITreeNode context, IContextBoundSettingsStore settingsStore);
    [PureAttribute]
private static bool IsPredefinedTypeReferenceByClrName(IQualifiableReference reference, Boolean& isNativeNumericTypeReference);
    public virtual void DetectSettings(IDetectionContext context);
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__ProcessQualifiableReference|10_0(IQualifiableReference reference, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__ProcessPredefinedTypeReference|10_1(IPredefinedTypeReference reference, <>c__DisplayClass10_0& );
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.CodeBodyInspectionUtil : object {
    [PureAttribute]
internal static bool CanBeConvertedToExpressionBody(IExpressionBodyOwnerDeclaration functionDeclaration, bool useHeuristics);
    internal static Nullable`1<StatementToExpressionConversion> TryGetStatementToExpressionConversion(IExpressionBodyOwnerDeclaration functionDeclaration);
    internal static bool CanConvertToExpressionBodyWithHeuristics(IExpressionBodyOwnerDeclaration functionDeclaration, StatementToExpressionConversion conversion);
    private static bool PreCheckCanBeExpressionBodyWithHeuristics(IExpressionBodyOwnerDeclaration functionDeclaration, ICSharpExpression expression, Kind conversionKind);
    private static bool IsVoidFunction(IExpressionBodyOwnerDeclaration functionDeclaration);
    internal static bool ShouldSuppressConversionForConstructorOrDestructor(IExpressionBodyOwnerDeclaration functionDeclaration, Kind conversionKind, ICSharpExpression expression);
    internal static bool IsNiceEnoughForExpressionBody(IExpressionBodyOwnerDeclaration declaration, ICSharpExpression expressionBody);
    private static Kind GuessConversionKindFrom(IExpressionBodyOwnerDeclaration declaration, ICSharpExpression expression);
    private static bool IsPossibleFromExpressionStatementConversion(IExpressionBodyOwnerDeclaration declaration);
    [PureAttribute]
public static bool IsFinishedDeclaration(IExpressionBodyOwnerDeclaration declaration, CSharpCodeBody body);
    [PureAttribute]
public static bool IsFinishedStatement(ICSharpStatement statement);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.CodeStyleQualifierUtil : object {
    public static bool SymbolIsHiddenInScope(IDeclaredElement symbol, IReferenceExpression referenceExpression);
    public static bool SymbolIsRedeclared(IDeclaredElement symbol, ITypeElement typeElement, ITypeElement originallyDeclaredIn, ICSharpTypeMemberDeclaration memberDeclaration);
    internal static bool IsOverridenMemberFromBaseClass(ITypeMember typeMember, MemberDeclaredIn declaredIn, ICSharpTypeDeclaration usedInType);
    internal static bool MemberIsRedeclared(ITypeMember member, IReferenceExpression expr);
    internal static QualifiedMember GetMemberKind(IDeclaredElement element);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DeclarationExpressionCodeStyleInspector : VariableDeclarationCodeStyleInspector`1<IDeclarationExpression> {
    protected virtual VarStyleSuggestion TrySuggest(IDeclarationExpression node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static bool IsApplicable(IDeclarationExpression node);
    private static Nullable`1<VariableDesignationDescriptor> TryGetDesignationDescriptor(IDeclarationExpression node, IVariableDesignation variableDesignation, ResolveContext resolveContext);
    public virtual void DetectSettings(IDetectionContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DeconstructionDeclarationVarKeywordCodeStyleInspector : CodeStyleInspectorBase`1<DeconstructedVariableVarKeywordUsageSuggestion> {
    public virtual DeconstructedVariableVarKeywordUsageSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static DeconstructedVariableVarKeywordUsageSuggestion GetSuggestion(ITreeNode node, List`1<ITokenNode> varKeywords);
    private static ValueTuple`2<Nullable`1<bool>, List`1<ITokenNode>> IsSeparateDeconstructedDeclaration(ITreeNode node);
    private static bool CheckIfDeclarationExpression(ITreeNode node);
    private static bool CheckIfVarDeconstructionPattern(ITreeNode node);
    private static bool CheckIfTupleExpression(ITreeNode node, List`1& varKeywords);
    private static bool CheckIfRecursivePattern(ITreeNode node, List`1& varKeywords);
    public virtual void DetectSettings(IDetectionContext context);
    [PureAttribute]
private static bool HasOnlySimpleVarDeclarations(ICSharpExpression expression, List`1<ITokenNode> varKeywords);
    [PureAttribute]
private static bool IsPositionalDeconstructionWithOnlyVars(IRecursivePattern pattern, List`1<ITokenNode> varKeywords);
    [CompilerGeneratedAttribute]
internal static bool <TrySuggest>g__SeparateDeclarationsArePreferred|0_0(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsPositionalDeconstructionWithOnlyVars>g__IsPositionalDeconstruction|9_0(IRecursivePattern recursivePattern, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <IsPositionalDeconstructionWithOnlyVars>g__IsVarDeconstruction|9_1(IPattern elementPattern, <>c__DisplayClass9_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DefaultAccessModifiersCodeStyleInspector : CodeStyleInspectorBase`1<IDefaultAccessModifiersCodeStyleSuggestion> {
    public virtual void DetectSettings(IDetectionContext context);
    private static Nullable`1<AccessRights> TryGetDefaultAccessRights(IModifiersListOwner modifiersListOwner);
    public virtual IDefaultAccessModifiersCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static IDefaultAccessModifiersCodeStyleSuggestion TrySuggestImpl(IModifiersListOwner modifiersListOwner, IContextBoundSettingsStore boundSettingsStore);
    private static bool CanInspect(IModifiersListOwner modifiersListOwner);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DefaultDeconstructionDeclarationVarKeywordUsageAdviser : object {
    [CompilerGeneratedAttribute]
private static IDeconstructionDeclarationVarKeywordUsageAdviser <Instance>k__BackingField;
    public static IDeconstructionDeclarationVarKeywordUsageAdviser Instance { get; }
    private static DefaultDeconstructionDeclarationVarKeywordUsageAdviser();
    [CompilerGeneratedAttribute]
public static IDeconstructionDeclarationVarKeywordUsageAdviser get_Instance();
    public sealed virtual bool PreferSeparateDeclarations(IContextBoundSettingsStore settingsStore);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DefaultDiscardDeclarationVarKeywordUsageAdviser : object {
    [CompilerGeneratedAttribute]
private static IDiscardDeclarationVarKeywordUsageAdviser <Instance>k__BackingField;
    public static IDiscardDeclarationVarKeywordUsageAdviser Instance { get; }
    private static DefaultDiscardDeclarationVarKeywordUsageAdviser();
    [CompilerGeneratedAttribute]
public static IDiscardDeclarationVarKeywordUsageAdviser get_Instance();
    public sealed virtual bool PreferExplicitDiscardDeclaration(IContextBoundSettingsStore settingsStore);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DefaultThisQualifierStyleAdviser : object {
    [NotNullAttribute]
private ThisQualifierSettingsKey mySettings;
    public DefaultThisQualifierStyleAdviser(ThisQualifierSettingsKey settingsKey);
    public sealed virtual ThisQualifierStyle Advise(QualifiedMember memberKind, MemberDeclaredIn declaredIn);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DefaultValue.DefaultValueStyleInspector : CodeStyleInspectorBase`1<IDefaultValueStyleSuggestion> {
    [NotNullAttribute]
private static Func`2<ICSharpExpression, ICSharpExpression> ourRemoveTypeSpecificationMutator;
    private static DefaultValueStyleInspector();
    public virtual IDefaultValueStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    public virtual void DetectSettings(IDetectionContext context);
    private static ValueTuple`2<ICSharpExpression, ITypeUsage> TryGetDefaultExpression(ITreeNode node);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DefaultVarStyleAdviser : VarStyleCodeStyleAdviserBase {
    [NotNullAttribute]
private IContextBoundSettingsStore mySettings;
    public DefaultVarStyleAdviser(IContextBoundSettingsStore settings);
    public virtual VariableStyle Advise(ITreeNode node, ICSharpExpression initializerExpression, VariableTypeKind typeKind, IType declaredType, IType inferredType, ICSharpLocalVariable variable);
    internal static bool AreNullableTypesEnabled(ICSharpTreeNode cSharpTreeNode);
    internal static bool DeclaredAndInferredTypesEqual(IType declaredType, IType inferredType, bool nullableTypesEnabled);
    public static VariableStyle Advise(IContextBoundSettingsStore settingsStore, ICSharpExpression initializerExpression, VariableTypeKind typeKind);
    private static VariableStyle Coalesce(IContextBoundSettingsStore settingsStore, ICSharpExpression expression, Expression`1<Func`2<CSharpVarKeywordUsageSettings, VariableStyle>> settingsKey);
    public virtual bool OutVarChangeAffectsTypeInference(IDeclarationExpression node, IType variableType, VariableStyle suggestedStyle);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.DiscardDeclarationCodeStyleInspector : CodeStyleInspectorBase`1<DiscardDeclarationVarKeywordSuggestion> {
    public virtual DiscardDeclarationVarKeywordSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static Nullable`1<bool> IsExplicitDiscardDeclaration(ITreeNode node);
    private static DiscardDeclarationVarKeywordSuggestion GetSuggestion(ITreeNode node);
    public virtual void DetectSettings(IDetectionContext context);
    [PureAttribute]
private static bool CanUseExplicitDiscard(IReferenceExpression discardReferenceExpression);
    [CompilerGeneratedAttribute]
internal static bool <TrySuggest>g__PreferExplicitDiscardDeclaration|0_0(<>c__DisplayClass0_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.EnforceUseVarAdviser : VarStyleCodeStyleAdviserBase {
    [NotNullAttribute]
public static EnforceUseVarAdviser Instance;
    private static EnforceUseVarAdviser();
    public virtual VariableStyle Advise(ITreeNode node, ICSharpExpression initializerExpression, VariableTypeKind typeKind, IType declaredType, IType inferredType, ICSharpLocalVariable variable);
    public virtual bool OutVarChangeAffectsTypeInference(IDeclarationExpression node, IType variableType, VariableStyle suggestedStyle);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ForeachVariableDeclarationCodeStyleInspector : VariableDeclarationCodeStyleInspector`1<IDeclarationExpression> {
    protected virtual VarStyleSuggestion TrySuggest(IDeclarationExpression declarationExpression, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static IType GetVariableType(IVariableDesignationContainer container, IVariableDesignation designation, IDeclarationExpression declarationExpression);
    [CanBeNullAttribute]
private static IType TryGetCollectionElementType(IDeclarationExpression declarationExpression);
    private static IType GetInferredType(IVariableDesignation variableDesignation, IType variableType, IType collectionElementType, VariableStyle currentStyle);
    public virtual void DetectSettings(IDetectionContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.FunctionBodyStyleInspector : CodeStyleInspectorBase`1<IArrangeFunctionBodyCodeStyleSuggestion> {
    public virtual IArrangeFunctionBodyCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static IArrangeFunctionBodyCodeStyleSuggestion TrySuggest(IExpressionBodyOwnerDeclaration functionDeclaration, FunctionBodyStyle functionBodyStyle, bool useHeuristics);
    public virtual void DetectSettings(IDetectionContext context);
    [CanBeNullAttribute]
private static IExpressionBodyOwnerDeclaration TryGetDeclaration(ITreeNode node);
    private static Expression`1<Func`2<CSharpCodeStyleSettingsKey, FunctionBodyStyle>> GetSettingAccessor(IExpressionBodyOwnerDeclaration declaration);
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__AddCase|2_0(FunctionBodyStyle style, bool useHeuristics, <>c__DisplayClass2_0& );
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.IDeconstructionDeclarationVarKeywordUsageAdviser {
    public abstract virtual bool PreferSeparateDeclarations(IContextBoundSettingsStore settingsStore);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.IDiscardDeclarationVarKeywordUsageAdviser {
    public abstract virtual bool PreferExplicitDiscardDeclaration(IContextBoundSettingsStore settingsStore);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.IfStatementDetectionHelper : object {
    internal static void DetectSettings(IIfStatement statement, IDetectionContext context);
    private static void DetectSettings(IIfStatement ifStatement, ICSharpStatement thenOrElseStatement, bool otherPartRequiresBraces, IDetectionContext context);
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__AddCase|1_0(IfElseBracesCodeStyle style, Nullable`1<bool> bracesRedundancy, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__AddCases|1_1(bool negative, Nullable`1<bool> bracesRedundancy, <>c__DisplayClass1_0& );
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.IfStatementSuggestionHelper : object {
    private static Expression`1<Func`2<CSharpFormatSettingsKey, bool>> SPECIAL_ELSE_IF_TREATMENT;
    private static IfStatementSuggestionHelper();
    [CanBeNullAttribute]
internal static IBracesCodeStyleSuggestion TrySuggestBracesStyle(IIfStatement ifStatement, IContextBoundSettingsStore boundSettingsStore);
    [CanBeNullAttribute]
private static IBracesCodeStyleSuggestion TrySuggestBracesStyleChained(IIfStatement ifStatement, IfElseBracesCodeStyle bracesCodeStyle, bool bracesRedundancyAllowed);
    [CanBeNullAttribute]
private static BracesForIfElseStatementCodeStyleSuggestion TrySuggestBracesStyle(IfStatementBracesRedundancyMetadata bracesRedundancyMetadata, IfElseBracesCodeStyle bracesCodeStyle, Nullable`1<bool> canRemoveAllBracesOverride);
    [CanBeNullAttribute]
private static BracesForIfElseStatementCodeStyleSuggestion TrySuggestBracesStyle(IIfStatement ifStatement, IfStatementBracesRedundancyMetadata bracesRedundancyMetadata, bool ifThenBracesRequired, bool ifElseBracesRequired);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.IThisQualifierStyleAdviser {
    public abstract virtual ThisQualifierStyle Advise(QualifiedMember memberKind, MemberDeclaredIn declaredIn);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.IVarStyleCodeStyleAdviser {
    public abstract virtual VariableStyle Advise(ITreeNode node, ICSharpExpression initializerExpression, VariableTypeKind typeKind, IType declaredType, IType inferredType, ICSharpLocalVariable variable);
    public abstract virtual VariableStyle GetPossibleStyles(VariableStyle currentStyle, IType variableType, ITreeNode context);
    public abstract virtual bool OutVarChangeAffectsTypeInference(IDeclarationExpression node, IType variableType, VariableStyle suggestedStyle);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ModifiersOrderGraph : object {
    [NotNullAttribute]
private ISet`1<string> myProcessedModifiers;
    [NotNullAttribute]
private String[] myAllModifiers;
    [NotNullAttribute]
private IDictionary`2<string, IDictionary`2<string, int>> myGraph;
    public ModifiersOrderGraph(String[] allModifiers);
    public sealed virtual void UpdateWith(IDetectionContext context);
    private void Add(string firstModifier, string secondModifier);
    public sealed virtual FormatterSettingValues GetSettings(ICalculatedSettingsSchema schema);
    private String[] GetOrder();
    public virtual string ToString();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ModifiersOrderInspector : CodeStyleInspectorBase`1<IModifiersOrderCodeStyleSuggestion> {
    private static Func`2<IDetectionContext, ISettingsDetectionResult> ourDetectionResultCreator;
    private static ModifiersOrderInspector();
    public virtual IModifiersOrderCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    [PureAttribute]
private static bool CheckForDuplicates(LocalList`1& existingModifiers);
    public virtual void DetectSettings(IDetectionContext context);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ModifiersOrderUtil : object {
    internal static bool TryFillModifiers(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration, LocalList`1& existingModifiers);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.MultipleVariableDeclarationCodeStyleInspector : VariableDeclarationCodeStyleInspector`1<IMultipleLocalVariableDeclaration> {
    private static Nullable`1<MultipleLocalVariableDeclarationDescriptor> TryGetDescriptor(IMultipleLocalVariableDeclaration node);
    protected virtual VarStyleSuggestion TrySuggest(IMultipleLocalVariableDeclaration node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    public virtual void DetectSettings(IDetectionContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.NamespaceBodyStyleInspector : CodeStyleInspectorBase`1<INamespaceBodyStyleSuggestion> {
    public virtual INamespaceBodyStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static ICSharpNamespaceDeclaration TryGetNamespaceDeclaration(ITreeNode node);
    [CanBeNullAttribute]
[PureAttribute]
public static INamespaceBodyStyleSuggestion SuggestStyle(ICSharpNamespaceDeclaration namespaceDeclaration, IContextBoundSettingsStore settingsStore);
    private static NamespaceBodyStyle GetCurrentNamespaceBodyStyle(ICSharpNamespaceDeclaration namespaceDeclaration);
    public virtual void DetectSettings(IDetectionContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ObjectCreation.ObjectCreationStyleInspector : CodeStyleInspectorBase`1<IObjectCreationStyleSuggestion> {
    [NotNullAttribute]
private static Func`2<ICSharpExpression, ICSharpExpression> ourRemoveTypeSpecificationMutator;
    private static ObjectCreationStyleInspector();
    public virtual void DetectSettings(IDetectionContext context);
    [CanBeNullAttribute]
private static IObjectCreationExpression TryGetObjectCreationExpression(ITreeNode node);
    public virtual IObjectCreationStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.OtherStatementsInspectorHelper : object {
    [CanBeNullAttribute]
internal static IBracesCodeStyleSuggestion TrySuggestBracesStyle(BracesInspectorContext inspectorContext, IContextBoundSettingsStore boundSettingsStore);
    private static bool IsBodyMultiline(ICSharpStatement body);
    internal static void DetectSettings(ICSharpStatement statement, BracesInspectorContext bracesInspectorContext, IDetectionContext context);
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__AddCase|2_0(BracesCodeStyle style, Nullable`1<bool> bracesRedundancy, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <DetectSettings>g__AddCases|2_1(bool negative, Nullable`1<bool> bracesRedundancy, <>c__DisplayClass2_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.OutVariableCodeStyleInspector : VariableDeclarationCodeStyleInspector`1<IDeclarationExpression> {
    protected virtual VarStyleSuggestion TrySuggest(IDeclarationExpression node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static Nullable`1<OutVariableDescriptor> TryGetOutVariableDescriptor(IDeclarationExpression node);
    private static bool CheckResolveEquivalence(IDeclarationExpression node, VariableStyle suggestedStyle);
    private static bool CheckResolveEquivalence(IDeclarationExpression node);
    public virtual void DetectSettings(IDetectionContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ParenthesesCodeStyleInspector : object {
    private sealed virtual override ICodeStyleSuggestion JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleInspector.TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IReadOnlyCollection`1<ICodeStyleAdviser> advisers);
    public sealed virtual void DetectSettings(IDetectionContext context);
    private sealed virtual override IMissingParenthesesCodeStyleSuggestion JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleInspector<JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IMissingParenthesesCodeStyleSuggestion>.TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private sealed virtual override IRedundantParenthesesCodeStyleSuggestion JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleInspector<JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IRedundantParenthesesCodeStyleSuggestion>.TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static IRedundantParenthesesCodeStyleSuggestion IsRedundantParenthesizedExpression(IParenthesizedExpression parenthesizedExpression, IContextBoundSettingsStore settingsStore);
    private static bool IsNonObviousPrecedenceExpression(BinaryExpressionDescriptor descriptor, IContextBoundSettingsStore store);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ParenthesesInspectionsUtil : object {
    internal static BinaryExpressionDescriptor GetDescriptor(IBinaryExpression binaryExpression);
    private static BinaryOperationGroupType GetGroupType(IBinaryExpression expr);
    private static BinaryOperationType GetType(ICSharpExpression expr);
    internal static bool IsNonObviousPrecedenceExpression(BinaryOperationType operationType, BinaryOperationType nonObviousOperations);
    internal static bool CanRemoveParens(IParenthesizedExpression parenthesizedExpression);
    internal static bool ShouldAddParens(BinaryExpressionDescriptor descriptor);
    internal static bool ParentAndChildExpressionsHaveDifferentOperatorSigns(BinaryExpressionDescriptor descriptor);
    internal static bool ParentAndChildHaveSameGroupTypes(BinaryExpressionDescriptor descriptor);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ParenthesesInSwitchWithTupleCodeStyleInspector : CodeStyleInspectorBase`1<IRedundantParenthesesCodeStyleSuggestion> {
    public virtual IRedundantParenthesesCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.Patterns.NullCheckingPatternCodeStyleInspector : CodeStyleInspectorBase`1<NullCheckingPatternStyleSuggestion> {
    public virtual NullCheckingPatternStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static Nullable`1<NullCheckingPatternStyle> ClassifyNullCheckingStyle(IPattern pattern);
    private static bool IsSubjectForSuggestion(IPattern pattern);
    public virtual void DetectSettings(IDetectionContext context);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.QualificationStyleInfo`1 : ValueType {
    [CompilerGeneratedAttribute]
private TStyle <CurrentStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private TStyle <PossibleStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private TStyle <AdvisedStyle>k__BackingField;
    public TStyle CurrentStyle { get; }
    public TStyle PossibleStyle { get; }
    public TStyle AdvisedStyle { get; }
    public QualificationStyleInfo`1(TStyle currentStyle, TStyle possibleStyle, TStyle advisedStyle);
    [CompilerGeneratedAttribute]
public TStyle get_CurrentStyle();
    [CompilerGeneratedAttribute]
public TStyle get_PossibleStyle();
    [CompilerGeneratedAttribute]
public TStyle get_AdvisedStyle();
    public void Deconstruct(TStyle& currentStyle, TStyle& possibleStyle, TStyle& advisedStyle);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.StaticMemberQualificationContext : ValueType {
    [CompilerGeneratedAttribute]
private IReferenceExpression <ReferenceExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeMember <TypeMember>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExpression <QualifierExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveResultWithInfo <ReferenceExpressionResolveResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <QualifierTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TypeWhereQualifierWasUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <OwnerType>k__BackingField;
    [NotNullAttribute]
public IReferenceExpression ReferenceExpression { get; public set; }
    [NotNullAttribute]
public ITypeMember TypeMember { get; public set; }
    [CanBeNullAttribute]
public ICSharpExpression QualifierExpression { get; public set; }
    [NotNullAttribute]
public ResolveResultWithInfo ReferenceExpressionResolveResult { get; public set; }
    [CanBeNullAttribute]
public ITypeElement QualifierTypeElement { get; public set; }
    [NotNullAttribute]
public ITypeElement TypeWhereQualifierWasUsed { get; public set; }
    [NotNullAttribute]
public ITypeElement OwnerType { get; public set; }
    [CompilerGeneratedAttribute]
public IReferenceExpression get_ReferenceExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReferenceExpression(IReferenceExpression value);
    [CompilerGeneratedAttribute]
public ITypeMember get_TypeMember();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeMember(ITypeMember value);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_QualifierExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifierExpression(ICSharpExpression value);
    [CompilerGeneratedAttribute]
public ResolveResultWithInfo get_ReferenceExpressionResolveResult();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReferenceExpressionResolveResult(ResolveResultWithInfo value);
    [CompilerGeneratedAttribute]
public ITypeElement get_QualifierTypeElement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifierTypeElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeWhereQualifierWasUsed();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeWhereQualifierWasUsed(ITypeElement value);
    [CompilerGeneratedAttribute]
public ITypeElement get_OwnerType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OwnerType(ITypeElement value);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.StaticQualifierStyleInspector : CodeStyleInspectorBase`1<StaticQualifierCodeStyleSuggestion> {
    public virtual void DetectSettings(IDetectionContext detectionContext);
    private static void DetectMembersToQualifySetting(IDetectionContext detectionContext, QualificationStyleInfo`1<StaticMemberQualifierStyle> styleInfo, QualifiedMember member);
    private static void DetectStaticMemberQualifierSetting(IDetectionContext detectionContext, QualificationStyleInfo`1<StaticMemberQualifierStyle> styleInfo);
    private static Nullable`1<StaticMemberQualificationContext> TryGetStaticMemberQualificationContext(ITreeNode node);
    public virtual StaticQualifierCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static QualificationStyleInfo`1<StaticMemberQualifierStyle> GetStyleInfo(StaticMemberQualificationContext context, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static bool IsNameofOrDynamic(ResolveResultWithInfo resolveResult);
    private static bool CanResolveUnqualified(IStaticQualifierStyleAdviser adviser, StaticMemberQualificationContext context);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ThisQualificationContext : ValueType {
    [CompilerGeneratedAttribute]
private QualificationStyleInfo`1<ThisQualifierStyle> <StyleInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSymbolHiddenInScope>k__BackingField;
    [CompilerGeneratedAttribute]
private IReferenceExpression <ReferenceExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberDeclaredIn <DeclaredIn>k__BackingField;
    [CompilerGeneratedAttribute]
private QualifiedMember <MemberKind>k__BackingField;
    public QualificationStyleInfo`1<ThisQualifierStyle> StyleInfo { get; public set; }
    public bool IsSymbolHiddenInScope { get; public set; }
    [NotNullAttribute]
public IReferenceExpression ReferenceExpression { get; public set; }
    public MemberDeclaredIn DeclaredIn { get; public set; }
    public QualifiedMember MemberKind { get; public set; }
    [CompilerGeneratedAttribute]
public QualificationStyleInfo`1<ThisQualifierStyle> get_StyleInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StyleInfo(QualificationStyleInfo`1<ThisQualifierStyle> value);
    [CompilerGeneratedAttribute]
public bool get_IsSymbolHiddenInScope();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsSymbolHiddenInScope(bool value);
    [CompilerGeneratedAttribute]
public IReferenceExpression get_ReferenceExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReferenceExpression(IReferenceExpression value);
    [CompilerGeneratedAttribute]
public MemberDeclaredIn get_DeclaredIn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DeclaredIn(MemberDeclaredIn value);
    [CompilerGeneratedAttribute]
public QualifiedMember get_MemberKind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MemberKind(QualifiedMember value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.ThisQualifierStyleInspector : CodeStyleInspectorBase`1<ThisQualifierCodeStyleSuggestion> {
    public virtual void DetectSettings(IDetectionContext detectionContext);
    private static void DetectQualifierStyleSetting(IDetectionContext context, ThisQualifierStyle currentStyle, ThisQualifierStyle possibleStyle, MemberDeclaredIn declaredIn);
    private static void DetectUseThisForSetting(IDetectionContext context, ThisQualifierStyle currentStyle, ThisQualifierStyle possibleStyle, QualifiedMember member);
    private static void DetectSetting(IDetectionContext context, ThisQualifierStyle currentStyle, ThisQualifierStyle possibleStyle, IScalarSetting setting, object enumMember);
    public virtual ThisQualifierCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static Nullable`1<ThisQualificationContext> TryGetThisQualificationStyleContext(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static ThisQualifierStyle GetPossibleStyle(ICSharpTypeDeclaration usedInType, ITypeMember typeMember, ThisQualifierStyle currentStyle, IReferenceExpression referenceExpression, MemberDeclaredIn& declaredIn, Boolean& symbolIsHiddenInScope);
    private static ThisQualifierStyle GetAdvisedStyle(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, QualifiedMember memberKind, IEnumerable`1<ICodeStyleAdviser> advisers, MemberDeclaredIn declaredIn);
    [NullableContextAttribute("2")]
private static bool IsSymbolRedeclared(ITypeMember typeMember, ITypeElement usedInTypeElement, ITypeElement memberContainingType, ICSharpTypeMemberDeclaration containingTypeMember);
    [NullableContextAttribute("2")]
private static ThisQualifierStyle GetCurrentStyle(ICSharpExpression qualifierExpression);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TrailingCommaInspector : CodeStyleInspectorBase`1<ITrailingCommaSuggestion> {
    [NotNullAttribute]
private static TrailingCommaProcessor ourSuggester;
    [NotNullAttribute]
private static TrailingCommaProcessor ourDetector;
    private static TrailingCommaInspector();
    public virtual ITrailingCommaSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    private static ITrailingCommaSuggestion Suggest(TrailingCommaContext context, bool multiline, bool shouldPlaceTrailingComma, bool hasTrailingComma, Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> settingAccessor, IDetectionContext detectionContext);
    public virtual void DetectSettings(IDetectionContext detectionContext);
    private static ITrailingCommaSuggestion Detect(TrailingCommaContext context, bool multiline, bool shouldPlaceTrailingComma, bool hasTrailingComma, Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> settingAccessor, IDetectionContext detectionContext);
    [CanBeNullAttribute]
private static ITrailingCommaSuggestion TryProcess(ITreeNode node, IContextBoundSettingsStore settingsStore, TrailingCommaProcessor processor, IDetectionContext detectionContext);
    private static bool IsMultiline(ITreeNode node);
    private static bool IsElementLeftToComma(ITreeNode element, ITokenNode comma);
    [CanBeNullAttribute]
private static ITreeNode SkipComments(ITreeNode current);
    private static Nullable`1<TrailingCommaContext> TryGetTrailingCommaContext(ITreeNode node);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.IDefaultValueTypeSpecificationStyleAdviser {
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.IObjectCreationTypeSpecificationStyleAdviser {
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.ITypeSpecificationStyleAdviser {
    public abstract virtual TypeSpecificationSettings Advise(IContextBoundSettingsStore settingsStore);
    public abstract virtual bool ShouldRemoveInEvidentContext(IMultipleLocalVariableDeclaration variableDeclaration, IContextBoundSettingsStore settingsStore, ICodeStyleAdviser[] advisers);
}
internal enum JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.TypeSpecificationAnalysisResult : Enum {
    public int value__;
    public static TypeSpecificationAnalysisResult None;
    public static TypeSpecificationAnalysisResult Evident;
    public static TypeSpecificationAnalysisResult NotEvident;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.TypeSpecificationAnalyzer : object {
    [PureAttribute]
public static TypeSpecificationAnalysisResult Analyze(TypeSpecificationAnalyzerContext context);
    [PureAttribute]
public static bool IsTypeSpecificationRedundantInNotEvidentContext(TypeSpecificationAnalyzerContext context);
    [PureAttribute]
private static bool CheckResolveWithoutTypeSpecification(TypeSpecificationAnalyzerContext context);
    [PureAttribute]
private static ICSharpDeclaration TryGetBlockBodiedDeclarationByReturnValue(ICSharpExpression returnValue);
    [PureAttribute]
private static IObjectCreationExpression TryGetCollectionCreationExpression(ICSharpExpression expression);
    [NullableContextAttribute("2")]
[PureAttribute]
private static ITypeUsage GetExpressionBodyOwnerReturnTypeByBodyExpression(ICSharpExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.TypeSpecificationAnalyzerContext : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEqualityComparer`1<IType> <Comparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITypeUsage <TypeUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ICSharpExpression, ICSharpExpression> <RemoveTypeSpecificationMutator>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEqualityComparer`1<IType> Comparer { get; }
    public IType Type { get; }
    public ICSharpExpression Expression { get; }
    [NullableAttribute("2")]
public ITypeUsage TypeUsage { get; }
    public Func`2<ICSharpExpression, ICSharpExpression> RemoveTypeSpecificationMutator { get; }
    public bool HasTypeSpecification { get; }
    public ICSharpExpression ContainingParenthesizedExpression { get; }
    [NullableAttribute("2")]
public IExpressionInitializer ExpressionInitializer { get; }
    public TypeSpecificationAnalyzerContext(ICSharpExpression expression, ITypeUsage typeUsage, IType type, Func`2<ICSharpExpression, ICSharpExpression> removeTypeSpecificationMutator);
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<IType> get_Comparer();
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public ICSharpExpression get_Expression();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ITypeUsage get_TypeUsage();
    [CompilerGeneratedAttribute]
public Func`2<ICSharpExpression, ICSharpExpression> get_RemoveTypeSpecificationMutator();
    public bool get_HasTypeSpecification();
    public ICSharpExpression get_ContainingParenthesizedExpression();
    [NullableContextAttribute("2")]
public IExpressionInitializer get_ExpressionInitializer();
    [NullableContextAttribute("2")]
public bool IsSameTypeAsExpression(IType otherType);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.TypeSpecificationSettings : ValueType {
    public bool SpecifyWhenTypeEvident;
    public bool SpecifyWhenTypeNotEvident;
    public TypeSpecificationSettings(bool specifyWhenTypeEvident, bool specifyWhenTypeNotEvident);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.TypeSpecificationStyleAdviserBase : object {
    public abstract virtual TypeSpecificationSettings Advise(IContextBoundSettingsStore settingsStore);
    public virtual bool ShouldRemoveInEvidentContext(IMultipleLocalVariableDeclaration variableDeclaration, IContextBoundSettingsStore settingsStore, ICodeStyleAdviser[] advisers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.TypeSpecificationStyleSuggester : object {
    [PureAttribute]
public static TypeSpecificationSuggestion Suggest(ICSharpExpression expression, ITypeUsage typeUsage, Func`2<ICSharpExpression, ICSharpExpression> removeTypeSpecificationMutator, IContextBoundSettingsStore settingsStore, ICodeStyleAdviser[] advisers, ITypeSpecificationStyleAdviser typeSpecificationStyleAdviser);
    private static bool ShouldReturnNoneWhenRedundantEvident(TypeSpecificationAnalyzerContext context, IContextBoundSettingsStore settingsStore, ICodeStyleAdviser[] advisers, ITypeSpecificationStyleAdviser typeSpecificationStyleAdviser);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.TypeSpecification.TypeSpecificationSuggestion : Enum {
    public int value__;
    public static TypeSpecificationSuggestion None;
    public static TypeSpecificationSuggestion RedundantInEvidentContext;
    public static TypeSpecificationSuggestion MissingInEvidentContext;
    public static TypeSpecificationSuggestion RedundantInNotEvidentContext;
    public static TypeSpecificationSuggestion MissingInNotEvidentContext;
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.UsingsInspector : object {
    public sealed virtual ICodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IReadOnlyCollection`1<ICodeStyleAdviser> advisers);
    public sealed virtual void DetectSettings(IDetectionContext context);
    private static void DetectAddUsingsToDeepestScopeSetting(IDetectionContext context, IUsingList usingList);
    private static void DetectSystemAndWindowsShouldGoFirstSetting(IDetectionContext context, IUsingList usingList);
    private static bool IsUsingWindowsOrSystem(IUsingDirective usingDirective);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.VariableDeclarationCodeStyleInspector`1 : CodeStyleInspectorBase`1<VarStyleSuggestion> {
    public virtual VarStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    protected abstract virtual VarStyleSuggestion TrySuggest(TTreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    protected IScalarSetting GetSettingFromType(IExpressionType type, IDetectionContext context);
    protected void DetectVarSettings(IDetectionContext context, bool isVar, bool evidentRoslynLogic, bool evidentNonRoslynLogic, IScalarSetting setting);
    [NotNullAttribute]
protected static IType FindInferredTypeForDeconstructionVariable(IExpressionType expressionType, IReadOnlyList`1<DeconstructionIndex> deconstructionPositionIndices);
    protected Nullable`1<NullableAnnotation> GetRecommendedExplicitTypeAnnotation(ITreeNode typeDesignator, ICSharpLocalVariable variable);
    protected static bool CanChangeTypeDesignatorInNullableContext(ITreeNode typeDesignator, ICSharpLocalVariable variable);
    [CompilerGeneratedAttribute]
internal static void <DetectVarSettings>g__AddCaseWithRoslynLogic|3_0(VariableStyle style, bool useRoslynLogic, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <DetectVarSettings>g__AddBothRoslynCases|3_1(VariableStyle style, <>c__DisplayClass3_0& );
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.VariableStyleUtil : object {
    private static String[] ourEvidentFields;
    private static String[] ourEvidentFactoryMethods;
    private static VariableStyleUtil();
    public static bool IsTypeEvident(ICSharpExpression expression, bool useRoslynLogic);
    private static bool IsReferenceExpressionEvident(bool useRoslynLogic, IReferenceExpression referenceExpression, IReference qualifierReferenceReference);
    private static bool IsInvocationExpressionEvident(bool useRoslynLogic, IInvocationExpression invocationExpression, IType typeInDeclaration, bool fromAwait);
    private static bool ContainsAnyOf(string str, String[] substrings, string additionalSubstring);
    private static bool IsTuple(IType type);
    public static bool IsVarTypeVisible(ITreeNode node);
    public static VariableTypeKind GetTypeKind(IExpressionType expressionType);
    private static bool IsBuiltinType(IType type);
    private static bool IsSimpleType(IType type);
    public static bool IsInitializedRecursively(ILocalVariable variable, ICSharpExpression initializer);
    public static bool IsExpressionTypeAllowsToUseVar(IExpressionType expressionType);
    private static bool IsArrayCreationExpressionTypeEvident(IArrayCreationExpression topmostArrayCreationExpression);
    [CompilerGeneratedAttribute]
internal static void <IsInvocationExpressionEvident>g__CheckAreAllArgumentsEvident|4_0(Boolean& returnAndContainingTypeMatch, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsArrayCreationExpressionTypeEvident>g__IsArrayInitializerTypeEvident|13_0(IArrayInitializer currentArrayInitializer, IType elementType, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsArrayCreationExpressionTypeEvident>g__IsArrayCreationTypeEvident|13_1(IArrayCreationExpression arrayCreationExpression, IType expectedElementType, <>c__DisplayClass13_0& );
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Inspections.VarStyleCodeStyleAdviserBase : object {
    public abstract virtual VariableStyle Advise(ITreeNode node, ICSharpExpression initializerExpression, VariableTypeKind typeKind, IType declaredType, IType inferredType, ICSharpLocalVariable variable);
    public sealed virtual VariableStyle GetPossibleStyles(VariableStyle currentStyle, IType variableType, ITreeNode context);
    protected virtual bool CanUseExplicitly(IType variableType, ITreeNode context);
    public abstract virtual bool OutVarChangeAffectsTypeInference(IDeclarationExpression node, IType variableType, VariableStyle suggestedStyle);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Suggestions.ArgumentCodeStyleSuggestion : ValueType {
    [CompilerGeneratedAttribute]
private ICSharpArgument <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MatchingParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgumentsCodeStyleSuggestionType <SuggestionType>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgumentsValueType <ArgumentValueType>k__BackingField;
    [NotNullAttribute]
public ICSharpArgument Argument { get; }
    [NotNullAttribute]
public string MatchingParameterName { get; }
    public ArgumentsCodeStyleSuggestionType SuggestionType { get; }
    public ArgumentsValueType ArgumentValueType { get; }
    private ArgumentCodeStyleSuggestion(ICSharpArgument argument, string matchingParameterName, ArgumentsCodeStyleSuggestionType suggestionType, ArgumentsValueType argumentValueType);
    [CompilerGeneratedAttribute]
public ICSharpArgument get_Argument();
    [CompilerGeneratedAttribute]
public string get_MatchingParameterName();
    [CompilerGeneratedAttribute]
public ArgumentsCodeStyleSuggestionType get_SuggestionType();
    [CompilerGeneratedAttribute]
public ArgumentsValueType get_ArgumentValueType();
    public bool IsValid();
    public void Apply();
    public Pointer CreatePointer();
    public static Nullable`1<ArgumentCodeStyleSuggestion> Required(ICSharpArgument argument, string matchingParameterName, ArgumentsValueType argumentValueType);
    public static Nullable`1<ArgumentCodeStyleSuggestion> Redundant(ICSharpArgument argument, string matchingParameterName, ArgumentsValueType argumentValueType);
    public static Nullable`1<ArgumentCodeStyleSuggestion> NotSupported(ICSharpArgument argument, string matchingParameterName, ArgumentsValueType argumentValueType);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Suggestions.ArgumentsCodeStyleSuggestion : CodeStyleSuggestion`1<IArgumentsOwner> {
    [CompilerGeneratedAttribute]
private ArgumentCodeStyleSuggestion[] <Suggestions>k__BackingField;
    public ArgumentCodeStyleSuggestion[] Suggestions { get; }
    public ArgumentsCodeStyleSuggestion(IArgumentsOwner argumentsOwner, ArgumentCodeStyleSuggestion[] suggestions);
    [CompilerGeneratedAttribute]
public sealed virtual ArgumentCodeStyleSuggestion[] get_Suggestions();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IArgumentsOwner argumentsOwner);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Suggestions.ArgumentsCodeStyleSuggestionType : Enum {
    public int value__;
    public static ArgumentsCodeStyleSuggestionType Remove;
    public static ArgumentsCodeStyleSuggestionType Add;
    public static ArgumentsCodeStyleSuggestionType NotSupported;
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Suggestions.ArgumentsValueType : Enum {
    public int value__;
    public static ArgumentsValueType Literal;
    public static ArgumentsValueType StringLiteral;
    public static ArgumentsValueType NamedExpression;
    public static ArgumentsValueType AnonymousFunction;
    public static ArgumentsValueType Other;
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Suggestions.IArgumentsCodeStyleSuggestion {
    [NotNullAttribute]
public ArgumentCodeStyleSuggestion[] Suggestions { get; }
    public abstract virtual ArgumentCodeStyleSuggestion[] get_Suggestions();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.CodeStyle.Suggestions.NamedArgumentsUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNameRedundant(ICSharpArgument argument, ICSharpArgumentsOwner argumentsOwner);
    public static void RemoveNamesFromThisAndPreviousArguments(ICSharpArgument targetArgument);
    [PureAttribute]
public static bool CanRemoveArgumentName(ICSharpArgument argument);
    public static void RemoveArgumentName(ICSharpArgument argument, bool checkResolve);
    public static void AddNamesToThisAndFollowingArguments(ICSharpArgument targetArgument);
    public static void AddArgumentName(ICSharpArgument argument);
    [PureAttribute]
public static bool CanUseNamedArguments(ICSharpArgumentsOwner argumentsOwner, bool allowExpandedParams);
    [CanBeNullAttribute]
[PureAttribute]
public static string GetArgumentNameToUse(ICSharpArgumentInfo targetArgument);
    [PureAttribute]
private static TreeNodeEnumerable`1<ICSharpArgument> GetArgumentsEnumerable(ICSharpArgument argument);
    [PureAttribute]
private static bool IsOutOfPosition(ICSharpArgument argument, int argumentIndex, IList`1<IParameter> parameters);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Comment.CSharpBlockCommentActionProvider : object {
    public string NestedStartBlockCommentMarker { get; }
    public string NestedEndBlockCommentMarker { get; }
    public string StartBlockCommentMarker { get; }
    public string EndBlockCommentMarker { get; }
    public sealed virtual string get_NestedStartBlockCommentMarker();
    public sealed virtual string get_NestedEndBlockCommentMarker();
    public sealed virtual DocumentOffset InsertBlockCommentPosition(ITokenNode tokenNode, DocumentOffset position);
    public sealed virtual bool IsAvailable(IFile file, DocumentRange range, Boolean& disableAllProviders);
    public sealed virtual DocumentRange GetBlockComment(ITokenNode tokenNode);
    public sealed virtual string get_StartBlockCommentMarker();
    public sealed virtual string get_EndBlockCommentMarker();
    private bool ValidateOffset(IFile file, DocumentOffset documentOffset);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Comment.CSharpCommentOrDirectiveInserter : CommentOrDirectiveInserterBase {
    public CSharpCommentOrDirectiveInserter(PsiLanguageType languageType, IBlockCommentActionProvider blockCommentActionProvider);
    private sealed virtual override bool JetBrains.ReSharper.Feature.Services.Comment.ICommentOrDirectiveInserter.InsertBlockComment(TreeTextRange treeRange, IFile file, string actionName, string insertBefore, string insertAfter);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Comment.CSharpLineCommentActionProvider : SimpleLineCommentActionProvider {
    protected virtual bool IsNewLine(TokenNodeType tokenType);
    protected virtual bool IsEndOfLineComment(TokenNodeType tokenType, string tokenText);
    protected virtual bool IsWhitespace(TokenNodeType tokenType);
    public virtual bool ShouldInsertAtLineStart(IContextBoundSettingsStore settingsStore);
    protected virtual SpecialCommentFlags IsSpecialEndOfLineComment(TokenNodeType tokenType, string tokenText);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CompleteStatement.CSharpCompleteStatementActionProvider : ElementBasedCompleteStatementActionProvider {
    private static void FixTryStatement(ITryStatement statement, FixContext fixContext);
    private static void FixLambdaExpression(ILambdaExpression lambdaExpression, FixContext fixContext);
    private static void FixConditionalTernaryExpression(IConditionalTernaryExpression ternaryExpression, FixContext fixContext);
    private static void FixReferenceExpression(IReferenceExpression referenceExpression, FixContext fixContext);
    private static void FixForStatement(IForStatement forStatement, FixContext fixContext);
    [PureAttribute]
private static bool IsEmptySingleLineBlock(IBlock block);
    private static void FixBlock(IBlock block, FixContext fixContext);
    private static void FixYieldStatement(IYieldStatement yieldStatement, FixContext fixContext);
    private static void FixSwitchCaseLabel(ISwitchCaseLabel switchCaseLabel, FixContext fixContext);
    private static bool IsUnfinishedSwitchCase(ISwitchCaseLabel switchCaseLabel);
    private static void FixCollectionInitializer(ICollectionInitializer collectionInitializer, FixContext fixContext);
    private static bool CheckIfShouldInsertRBrace(ICreationExpressionInitializer collectionInitializer, FixContext fixContext, DocumentRange innerRange);
    private static void FixObjectInitializer(IObjectInitializer objectInitializer, FixContext fixContext);
    private static void FixEventDeclaration(IMultipleEventDeclaration eventDeclaration, FixContext fixContext);
    private static void FixDelegateDeclaration(IDelegateDeclaration delegateDeclaration, FixContext fixContext);
    private static void SimpleFixFieldOrMethodDeclaration(FixContext fixContext);
    private static void FixFieldDeclaration(IMultipleFieldDeclaration fieldDeclaration, FixContext fixContext);
    private static void FixTypeParameterOfTypeList(ITypeParameterOfTypeList typeParameterOfTypeListNode, FixContext fixContext);
    private static void FixEnumDeclaration(IEnumDeclaration enumDeclaration, FixContext fixContext);
    private static void FixClassLikeDeclaration(IClassLikeDeclaration classLikeDeclaration, FixContext fixContext);
    private static void FixArrayCreationExpression(IArrayCreationExpression arrayCreationExpression, FixContext fixContext);
    private static void FixMethodDeclaration(IMethodDeclaration methodDeclaration, FixContext fixContext);
    private static void FixLonelyStatementWhereABlockCouldBe(ICSharpStatement statement, FixContext fixContext);
    private static bool IsControlTransferStatement(ICSharpStatement statement);
    private static void FixAccessorDeclaration(IAccessorDeclaration accessorDeclaration, FixContext fixContext);
    private static void FixPropertyDeclaration(IPropertyDeclaration property, FixContext fixContext);
    private static void FixLiteralExpression(ICSharpLiteralExpression literalExpression, FixContext fixContext);
    private static void FixObjectCreationExpression(IObjectCreationExpression objectCreationExpression, FixContext fixContext);
    private static void FixElementAccessExpression(IElementAccessExpression elementAccessExpression, FixContext fixContext);
    private static void FixUsingStatement(IUsingStatement usingStatement, FixContext fixContext);
    private static void FixContinueStatement(IContinueStatement continueStatement, FixContext fixContext);
    private static void FixBreakStatement(IBreakStatement breakStatement, FixContext fixContext);
    private static void FixWhileStatement(IWhileStatement whileStatement, FixContext fixContext);
    private static void FixThrowStatement(IThrowStatement throwStatement, FixContext fixContext);
    private static void FixLockStatement(ILockStatement lockStatement, FixContext fixContext);
    private static void FixSwitchStatement(ISwitchStatement switchStatement, FixContext fixContext);
    private static void FixSimpleStatement(string statementName, ICSharpStatement statement, ICSharpExpression condition, ICSharpTreeNode statementBody, ITokenNode rPar, ITokenNode lPar, FixContext fixContext);
    private static void FixReturnStatementValue(IReturnStatement returnStatement, FixContext fixContext);
    private static void FixForeachStatementBody(IForeachStatement foreachStatement, FixContext fixContext);
    private static void FixDoStatement(IDoStatement doStatement, FixContext fixContext);
    private static void FixIfStatementBranches(IIfStatement statement, FixContext fixContext);
    private static void FixIfStatementCondition(IIfStatement statement, FixContext fixContext);
    private static void FixDeclarationStatement(IDeclarationStatement statement, FixContext fixContext);
    private static void FixExpressionStatement(IExpressionStatement statement, FixContext fixContext);
    private static void FixInvocationExpression(IInvocationExpression invocationExpression, FixContext fixContext);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.CompleteStatement.MatchingUtil : object {
    [ExtensionAttribute]
public static bool Match(ITreeNode e);
    [ExtensionAttribute]
public static T Is(ITreeNode e);
    [ExtensionAttribute]
public static P HasParent(ITreeNode e);
    [ExtensionAttribute]
public static T IsAfter(ITreeNode e);
    [ExtensionAttribute]
public static T IsBefore(ITreeNode e);
    [ExtensionAttribute]
public static T Follows(ITokenNode e);
    [ExtensionAttribute]
public static ITokenNode FollowedBy(ITokenNode e, TokenNodeType tokenType);
    private static ITreeNode ApplyFiltered(ITreeNode element, Func`2<ITreeNode, ITreeNode> f);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.AccessExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IAccess TryMergeTopWithSubset(IAccess access, IAccess previousAccess);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static QualifiedCheckAccess ToCheckAccess(IAccess access, bool falseIfNull);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IAccess ToNoopAccess(IAccess access);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IAccess ToNullableValueAccessIfLifted(IAccess access);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IAccess UnliftBy(IAccess access, ISplitableConditionalAccess separator);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IAccess UnwrapNoopAccess(IAccess access);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeRepresentedInContext(IAccess access, ICSharpTreeNode context);
    [ExtensionAttribute]
[ContractAnnotationAttribute("access: null => null; access: notnull => notnull")]
internal static IAccess UnwrapNullableDotValueAccess(IAccess access);
    [ExtensionAttribute]
[ContractAnnotationAttribute("access: null => null; access: notnull => notnull")]
internal static IAccess UnwrapNullableDotValueAccess(IAccess access, Boolean& nullableUnwrap);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeMergedAsSubset(IAccess access);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSideEffectsFree(ICSharpExpression expression);
    [ExtensionAttribute]
public static bool CanAffectDefiniteAssignmentAnalysis(IAccess access);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IAccess FindByExpression(IAccess accessChain, ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.AccessFactory : object {
    [ThreadStaticAttribute]
private static int ourExpressionDepth;
    [CanBeNullAttribute]
[ContractAnnotationAttribute("expression: null => null")]
public static ICheckAccess TryBuildCheck(ICSharpExpression expression);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccess TryBuildAccess(ICSharpExpression expression);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccess TryBuildAccessNoImplicitConversionWrap(ICSharpExpression expression);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccess TryBuildAccessNoWrapInImplicitConversion(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
internal static IAccess TryBuildQualifier(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.AnyExpressionAccess : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public int Level { get; }
    public bool IsLifted { get; }
    public bool CanBeMerged { get; }
    public AnyExpressionAccess(ICSharpExpression expression);
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpExpression get_Expression();
    public sealed virtual bool IsValid();
    public sealed virtual int get_Level();
    public sealed virtual bool get_IsLifted();
    public sealed virtual IAccess Unlift();
    public sealed virtual bool get_CanBeMerged();
    public sealed virtual IAccess MergeWithSubset(IAccess previousAccess);
    public sealed virtual bool CheckParentAfterMerge(IAccess parentAccess);
    public sealed virtual IAccess Map(Func`2<IAccess, IAccess> func);
    public sealed virtual TAcc Fold(TAcc seed, Func`3<TAcc, IAccess, TAcc> func);
    public sealed virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public sealed virtual IExpressionType TryCalculateCreatedExpressionType();
    public sealed virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.BinaryOperatorAccess : MultiQualifiersAccess {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IBinaryExpression myBinaryOperator;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public bool IsLifted { get; }
    public bool CanBeMerged { get; }
    private IAccess JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ISplitableConditionalAccess.Qualifier { get; }
    public BinaryOperatorAccess(IReadOnlyList`1<IAccess> qualifiers, IBinaryExpression binaryOperator);
    public virtual ICSharpExpression get_Expression();
    public virtual bool get_IsLifted();
    public virtual bool get_CanBeMerged();
    private sealed virtual override IAccess JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ISplitableConditionalAccess.get_Qualifier();
    private sealed virtual override TreeTextRange JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ISplitableConditionalAccess.GetConditionalSignRange();
    protected virtual IAccess UnliftSingleQualifier(IAccess qualifier, int index);
    protected virtual IAccess MergeWithSubset(IAccess previousAccess, IReadOnlyList`1<IAccess> newQualifiers, int mergedQualifierIndex);
    public virtual MultiQualifiersAccess ChangeQualifiers(IReadOnlyList`1<IAccess> newQualifiers);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
    public virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    public virtual string ToString();
    [NotNullAttribute]
internal static ICSharpExpression CreateBinaryExpression(IBinaryExpression binaryOperator, IReadOnlyList`1<IAccess> qualifiers, CSharpElementFactory factory);
    [CanBeNullAttribute]
[PureAttribute]
public static BinaryOperatorAccess TryBuildBinaryOperatorAccess(ICSharpExpression expression);
    private static bool IsLiftedReturnValueOperator(IBinaryExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.BinaryOperatorCheck : MultiQualifiersAccess {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IBinaryExpression myBinaryOperator;
    [CompilerGeneratedAttribute]
private CheckAccessKind <CheckAccessKind>k__BackingField;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public bool IsLifted { get; }
    public CheckAccessKind CheckAccessKind { get; }
    public TreeTextRange CheckRange { get; }
    public bool CanBeMerged { get; }
    private IAccess JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ISplitableConditionalAccess.Qualifier { get; }
    public BinaryOperatorCheck(IReadOnlyList`1<IAccess> qualifiers, IBinaryExpression binaryOperator, CheckAccessKind accessKind);
    public virtual ICSharpExpression get_Expression();
    public virtual bool get_IsLifted();
    [CompilerGeneratedAttribute]
public sealed virtual CheckAccessKind get_CheckAccessKind();
    public sealed virtual TreeTextRange get_CheckRange();
    public sealed virtual bool IsGoodEnoughToSuggest();
    public sealed virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
    public virtual bool get_CanBeMerged();
    private sealed virtual override IAccess JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ISplitableConditionalAccess.get_Qualifier();
    private sealed virtual override TreeTextRange JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ISplitableConditionalAccess.GetConditionalSignRange();
    protected virtual IAccess UnliftSingleQualifier(IAccess qualifier, int index);
    public virtual MultiQualifiersAccess ChangeQualifiers(IReadOnlyList`1<IAccess> newQualifiers);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
    public virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    protected virtual IAccess MergeWithSubset(IAccess previousAccess, IReadOnlyList`1<IAccess> newQualifiers, int mergedQualifierIndex);
    [CanBeNullAttribute]
public static BinaryOperatorCheck TryBuildBinaryOperatorCheck(ICSharpExpression expression);
    [PureAttribute]
public static Nullable`1<bool> OperatorCanBeLifted(IReference operatorReference);
    private static Nullable`1<CheckAccessKind> GetCheckAccessIfCanBeLifted(TokenNodeType signType);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.BooleanContractCheck : QualifiedCheckAccess {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private ICSharpExpression myInvocationExpression;
    private bool myOriginalIsFalseIfNull;
    [CompilerGeneratedAttribute]
private IType <QualifierParameterType>k__BackingField;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    [NotNullAttribute]
public IType QualifierParameterType { get; }
    private BooleanContractCheck(IAccess qualifier, CheckAccessKind checkAccessKind, TreeTextRange checkRange, ICSharpExpression invocationExpression, bool originalIsFalseIfNull, IType qualifierParameterType);
    public virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public IType get_QualifierParameterType();
    public virtual bool IsGoodEnoughToSuggest();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
    [CanBeNullAttribute]
public static BooleanContractCheck TryBuildBooleanContractCheck(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private static BooleanContractCheck TryBuildBooleanContractCheck(ICSharpExpression expression, ICSharpExpression originalExpression, bool isInverted);
    [CanBeNullAttribute]
private static BooleanContractCheck TryBuildFromInvocation(IInvocationExpression invocationExpression, ICSharpExpression originalExpression, bool isInverted);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> null, qualifierExpression: null")]
[ContractAnnotationAttribute("=> notnull, qualifierExpression: notnull")]
internal static DeclaredElementInstance`1<IMethod> TryFindSimpleStaticMethod(IInvocationExpression invocationExpression, ICSharpExpression& qualifierExpression);
    [PureAttribute]
private static Nullable`1<bool> IsNullCheckingMethod(IInvocationExpression invocationExpression, IMethod method);
    [CompilerGeneratedAttribute]
internal static IInvocationExpression <CreateExpression>g__GetInvocation|10_0(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.BooleanValueCheck : QualifiedCheckAccess {
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private ICSharpExpression myExpression;
    [CompilerGeneratedAttribute]
private bool <IsCheckForTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanCheckRepresentation <OriginalCheckRepresentation>k__BackingField;
    public bool IsCheckForTrue { get; }
    public ICSharpExpression Expression { get; }
    public BooleanCheckRepresentation OriginalCheckRepresentation { get; }
    public bool IsLifted { get; }
    private BooleanValueCheck(IAccess qualifier, CheckAccessKind checkAccessKind, bool isCheckForTrue, TreeTextRange checkRange, BooleanCheckRepresentation originalCheckRepresentation, ICSharpExpression expression);
    [CompilerGeneratedAttribute]
public bool get_IsCheckForTrue();
    public virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public BooleanCheckRepresentation get_OriginalCheckRepresentation();
    public virtual bool get_IsLifted();
    public sealed virtual TreeTextRange GetConditionalSignRange();
    public virtual bool IsGoodEnoughToSuggest();
    public virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
    public virtual IAccess Unlift();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    [CanBeNullAttribute]
[PureAttribute]
public static BooleanValueCheck TryBuildBooleanValueCheck(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private static BooleanValueCheck TryBuildBooleanValueCheckImpl(ICSharpExpression expression, bool isNegated);
    [CanBeNullAttribute]
[PureAttribute]
private static BooleanValueCheck TryBuildCoalescingBooleanCheck(INullCoalescingExpression coalescingExpression, bool isNegated);
    [CanBeNullAttribute]
[PureAttribute]
private static BooleanValueCheck TryBuildBooleanEqualityExpressionValueCheck(IEqualityExpression equalityExpression, bool isNegated);
    [PureAttribute]
private static Nullable`1<bool> IsPureBooleanLiteral(ICSharpExpression expression);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.CastAccessBase : MandatoryQualifiedAccess {
    [CompilerGeneratedAttribute]
private IType <TypeOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    [NotNullAttribute]
public IType TypeOperand { get; }
    public bool IsLifted { get; }
    public bool CanBeMerged { get; }
    protected CastAccessBase(IAccess qualifier, IType typeOperand, bool isLiftedCast);
    [CompilerGeneratedAttribute]
public IType get_TypeOperand();
    [CompilerGeneratedAttribute]
public virtual bool get_IsLifted();
    public virtual bool IsValid();
    public virtual bool get_CanBeMerged();
    public static bool TryMergeTypes(IType leftType, IType rightType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.CheckAccessExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool ChecksForNull(CheckAccessKind checkAccess);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasCompatibleCheckKind(ICheckAccess checkAccess, CheckAccessKind accessKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasCompatibleCheckKind(ICheckAccess leftAccess, ICheckAccess rightAccess);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.CheckAccessKind : Enum {
    public int value__;
    public static CheckAccessKind FalseIfNull;
    public static CheckAccessKind TrueIfNull;
    public static CheckAccessKind ThrowsIfNull;
    public static CheckAccessKind NullCoalescing;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.CoalescingCheck : QualifiedCheckAccess {
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private INullCoalescingExpression myCoalescingExpression;
    [CompilerGeneratedAttribute]
private ICSharpExpression <DefaultExpression>k__BackingField;
    public ICSharpExpression Expression { get; }
    [NotNullAttribute]
public ICSharpExpression DefaultExpression { get; }
    public CoalescingCheck(IAccess qualifier, TreeTextRange checkRange, ICSharpExpression defaultExpression, INullCoalescingExpression coalescingExpression);
    public virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public ICSharpExpression get_DefaultExpression();
    public virtual bool IsValid();
    public virtual IAccess Unlift();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    public sealed virtual TreeTextRange GetConditionalSignRange();
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual bool IsGoodEnoughToSuggest();
    public virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
    public virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
    [CanBeNullAttribute]
public static CoalescingCheck TryBuildCoalescingCheck(ICSharpExpression expression);
    [PureAttribute]
internal static NotNullTailExpressionKind InspectTailExpression(ICSharpExpression expression);
    [PureAttribute]
private static NotNullTailExpressionKind InspectQualifier(IAccess access);
    [PureAttribute]
private static NotNullTailExpressionKind InspectDeclaredElement(IDeclaredElement declaredElement, ISubstitution substitution);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ConditionalAccess : QualifiedAccess {
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private IConditionalAccessExpression myConditionalAccess;
    [CompilerGeneratedAttribute]
private bool <IsConditionalAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysLifted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NullableUnwrap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonLiftableType>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredElementInstance <DeclaredElementInstance>k__BackingField;
    public ICSharpExpression Expression { get; }
    public bool IsConditionalAccess { get; }
    protected bool AlwaysLifted { get; }
    protected bool NullableUnwrap { get; }
    public bool NonLiftableType { get; }
    [NotNullAttribute]
public DeclaredElementInstance DeclaredElementInstance { get; }
    public bool IsLifted { get; }
    protected ConditionalAccess(IAccess qualifier, IConditionalAccessExpression conditionalAccess, DeclaredElementInstance declaredElementInstance, bool nullableUnwrap, bool isConditionalAccess);
    protected ConditionalAccess(IAccess qualifier, IConditionalAccessExpression conditionalAccess, DeclaredElementInstance declaredElementInstance, bool nullableUnwrap, bool isConditionalAccess, bool alwaysLifted, bool nonLiftableType);
    public virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public bool get_IsConditionalAccess();
    [CompilerGeneratedAttribute]
protected bool get_AlwaysLifted();
    [CompilerGeneratedAttribute]
protected bool get_NullableUnwrap();
    [CompilerGeneratedAttribute]
public bool get_NonLiftableType();
    [CompilerGeneratedAttribute]
public DeclaredElementInstance get_DeclaredElementInstance();
    public virtual bool get_IsLifted();
    public virtual bool CheckParentAfterMerge(IAccess parentAccess);
    public abstract virtual TreeTextRange GetConditionalSignRange();
    protected static bool IsAllowedReturnType(IType type);
    protected bool MergeConditionalAccess(IAccess newQualifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ConditionalExpressionAccess : MandatoryQualifiedAccess {
    [CompilerGeneratedAttribute]
private IConditionalTernaryExpression <expression>P;
    public ICSharpExpression Expression { get; }
    public ConditionalExpressionAccess(IAccess qualifier, IConditionalTernaryExpression expression);
    public virtual ICSharpExpression get_Expression();
    [NullableContextAttribute("2")]
protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ConditionalExpressionAccess TryBuildConditionalExpressionAccess(ICSharpExpression expression);
    [NullableContextAttribute("2")]
[PureAttribute]
[ContractAnnotationAttribute("=> null, conditionCheck: null; => notnull, conditionCheck: notnull")]
public static IAccess TryMerge(IConditionalTernaryExpression conditionalExpression, ICheckAccess& conditionCheck);
    public static bool IsNullValue(ICSharpExpression operand);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <IsNullValue>g__CanContainNull|10_0(IType type);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ContractInvocationAccess : MandatoryQualifiedAccess {
    [NotNullAttribute]
private IInvocationExpression myInvocationExpression;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public ContractInvocationAccess(IAccess qualifier, IInvocationExpression invocationExpression);
    public virtual ICSharpExpression get_Expression();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    [CanBeNullAttribute]
[PureAttribute]
public static ContractInvocationAccess TryBuildContractInvocationAccess(ICSharpExpression expression);
    private static bool IsNullPropagatingMethod(IInvocationExpression invocationExpression, IMethod method);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.DirectCastAccess : CastAccessBase {
    [CanBeNullAttribute]
private ICastExpression myCastExpression;
    [CompilerGeneratedAttribute]
private bool <IsNullableDotValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnboxingCast>k__BackingField;
    public ICSharpExpression Expression { get; }
    public bool IsNullableDotValue { get; }
    public bool IsUnboxingCast { get; }
    public DirectCastAccess(IAccess qualifier, IType typeOperand, ICastExpression castExpression, bool isNullableDotValue, bool isLiftedCast, bool isUnboxingCast);
    public virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public virtual bool get_IsNullableDotValue();
    [CompilerGeneratedAttribute]
public bool get_IsUnboxingCast();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    [CanBeNullAttribute]
[PureAttribute]
public static DirectCastAccess TryBuildDirectCast(ICSharpExpression expression);
    [CompilerGeneratedAttribute]
private bool <MergeWithPreviousEx>g__CanLiftType|10_0(DirectCastAccess directCastAccess);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.IAccess {
    [CanBeNullAttribute]
public ICSharpExpression Expression { get; }
    public int Level { get; }
    public bool IsLifted { get; }
    public bool CanBeMerged { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual bool IsValid();
    public abstract virtual int get_Level();
    public abstract virtual bool get_IsLifted();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAccess Unlift();
    public abstract virtual bool get_CanBeMerged();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IAccess MergeWithSubset(IAccess previousAccess);
    public abstract virtual bool CheckParentAfterMerge(IAccess parentAccess);
    [NotNullAttribute]
public abstract virtual IAccess Map(Func`2<IAccess, IAccess> func);
    public abstract virtual TAcc Fold(TAcc seed, Func`3<TAcc, IAccess, TAcc> func);
    [NotNullAttribute]
public abstract virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    [CanBeNullAttribute]
public abstract virtual IExpressionType TryCalculateCreatedExpressionType();
    [NotNullAttribute]
public abstract virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
    public abstract virtual void VisitExecutedCode(Action`1<ITreeNode> action);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ICheckAccess {
    public CheckAccessKind CheckAccessKind { get; }
    public TreeTextRange CheckRange { get; }
    public abstract virtual CheckAccessKind get_CheckAccessKind();
    public abstract virtual TreeTextRange get_CheckRange();
    public abstract virtual bool IsGoodEnoughToSuggest();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ImplicitConversionAccess : MandatoryQualifiedAccess {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private ICSharpExpression myExpression;
    [CompilerGeneratedAttribute]
private bool <IsDangerousToMerge>k__BackingField;
    public bool IsDangerousToMerge { get; }
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    private ImplicitConversionAccess(ICSharpExpression expression, IAccess qualifier, bool isDangerousToMerge);
    [CompilerGeneratedAttribute]
public bool get_IsDangerousToMerge();
    public virtual ICSharpExpression get_Expression();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    [NotNullAttribute]
public static IAccess TryWrapWith(ICSharpExpression expression, IAccess qualifier);
    private static bool IsInsideConversionOperator(ICSharpExpression context, Conversion conversion);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.IndexerAccess : ConditionalAccess {
    private int myElementIndex;
    private bool myIndexFromEnd;
    [CanBeNullAttribute]
public IElementAccessExpression Expression { get; }
    public bool CanBeMerged { get; }
    private IndexerAccess(IndexerAccess copySource, IAccess qualifier, bool nullableUnwrap, bool isConditionalAccess, bool alwaysLifted, bool nonLiftableType);
    public IndexerAccess(IAccess qualifier, IElementAccessExpression elementAccess, DeclaredElementInstance declaredElementInstance, bool nullableUnwrap, bool isConditionalAccess);
    private IndexerAccess(IAccess qualifier, int elementIndex, bool indexFromEnd, DeclaredElementInstance declaredElementInstance, bool nullableUnwrap, bool isConditionalAccess);
    public IElementAccessExpression get_Expression();
    public virtual TreeTextRange GetConditionalSignRange();
    public virtual IAccess Unlift();
    public virtual bool get_CanBeMerged();
    protected virtual IAccess MergeWithPrevious(IAccess previousAccess, IAccess newQualifier);
    private static bool CheckEqualArgumentsPassed(IndexerAccess left, IndexerAccess right);
    public virtual IAccess ChangeQualifier(IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static IndexerAccess TryBuildIndexerAccess(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
public static IndexerAccess TryBuildFromListPatternItemPattern(IAccess qualifier, IPattern pattern);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static ConstantValue <CheckEqualArgumentsPassed>g__GetPossibleFromEndConstant|12_0(ICSharpArgument argument, Boolean& isFromEnd);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.InvocationAccess : ConditionalAccess {
    [CompilerGeneratedAttribute]
private bool <IsDelegateInvoke>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullableDotValue>k__BackingField;
    [NotNullAttribute]
public IInvocationExpression Expression { get; }
    public bool IsDelegateInvoke { get; }
    public bool IsNullableDotValue { get; }
    private InvocationAccess(IAccess qualifier, IInvocationExpression invocation, DeclaredElementInstance declaredElementInstance, bool nullableUnwrap, bool nullableValueAccess, bool isDelegateInvoke, bool isConditionalAccess, bool alwaysLifted, bool nonLiftableType);
    public InvocationAccess(IAccess qualifier, IInvocationExpression invocation, DeclaredElementInstance declaredElementInstance, bool nullableUnwrap, bool nullableValueAccess, bool isDelegateInvoke, bool isConditionalAccess);
    public IInvocationExpression get_Expression();
    [CompilerGeneratedAttribute]
public bool get_IsDelegateInvoke();
    public virtual TreeTextRange GetConditionalSignRange();
    public virtual IAccess Unlift();
    [CompilerGeneratedAttribute]
public virtual bool get_IsNullableDotValue();
    protected virtual IAccess MergeWithPrevious(IAccess previousAccess, IAccess newQualifier);
    public virtual IAccess ChangeQualifier(IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static InvocationAccess TryBuildInvocationAccess(ICSharpExpression expression);
    [PureAttribute]
private static DelegateInvokeKind GetDelegateInvokeKind(IMethod method, IPrimaryExpression invokedExpression);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ISplitableConditionalAccess {
    [CanBeNullAttribute]
public IAccess Qualifier { get; }
    public abstract virtual IAccess get_Qualifier();
    [PureAttribute]
public abstract virtual TreeTextRange GetConditionalSignRange();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.MandatoryQualifiedAccess : QualifiedAccess {
    [NotNullAttribute]
public IAccess Qualifier { get; }
    protected MandatoryQualifiedAccess(IAccess qualifier);
    public sealed virtual IAccess get_Qualifier();
    protected sealed virtual IAccess MergeWithPrevious(IAccess previousAccess, IAccess newQualifier);
    [CanBeNullAttribute]
protected abstract virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public sealed virtual IAccess ChangeQualifier(IAccess newQualifier);
    [NotNullAttribute]
public virtual IAccess ChangeQualifierEx(IAccess newQualifier);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.MultiQualifiersAccess : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IAccess> <Qualifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IReadOnlyList`1<IAccess> Qualifiers { get; }
    public int Level { get; }
    public ICSharpExpression Expression { get; }
    [CanBeNullAttribute]
public IAccess SingleQualifier { get; }
    public bool IsLifted { get; }
    public bool CanBeMerged { get; }
    protected MultiQualifiersAccess(IReadOnlyList`1<IAccess> qualifiers);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IAccess> get_Qualifiers();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Level();
    public abstract virtual ICSharpExpression get_Expression();
    public IAccess get_SingleQualifier();
    public sealed virtual bool IsValid();
    public virtual bool get_IsLifted();
    public sealed virtual IAccess Unlift();
    public virtual bool get_CanBeMerged();
    [NotNullAttribute]
protected virtual IAccess UnliftSingleQualifier(IAccess qualifier, int index);
    public sealed virtual IAccess MergeWithSubset(IAccess previousAccess);
    public virtual bool CheckParentAfterMerge(IAccess parentAccess);
    [CanBeNullAttribute]
protected abstract virtual IAccess MergeWithSubset(IAccess previousAccess, IReadOnlyList`1<IAccess> newQualifiers, int mergedQualifierIndex);
    [NotNullAttribute]
public abstract virtual MultiQualifiersAccess ChangeQualifiers(IReadOnlyList`1<IAccess> newQualifiers);
    public sealed virtual IAccess Map(Func`2<IAccess, IAccess> func);
    public sealed virtual TAcc Fold(TAcc seed, Func`3<TAcc, IAccess, TAcc> func);
    public abstract virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public abstract virtual IExpressionType TryCalculateCreatedExpressionType();
    public abstract virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
    public virtual void VisitExecutedCode(Action`1<ITreeNode> action);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.NoopAccess : MandatoryQualifiedAccess {
    [DebuggerBrowsableAttribute("0")]
private bool myIsLifted;
    public ICSharpExpression Expression { get; }
    public bool IsLifted { get; }
    public NoopAccess(IAccess qualifier, bool isLifted);
    public virtual ICSharpExpression get_Expression();
    public virtual bool get_IsLifted();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.NullableValueAccess : MandatoryQualifiedAccess {
    public ICSharpExpression Expression { get; }
    public bool IsLifted { get; }
    public NullableValueAccess(IAccess qualifier);
    public virtual ICSharpExpression get_Expression();
    public virtual bool get_IsLifted();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.NullCheckAccess : QualifiedCheckAccess {
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private NullCheckKind <CheckRepresentation>k__BackingField;
    public ICSharpExpression Expression { get; }
    public NullCheckKind CheckRepresentation { get; }
    public bool CanBeMerged { get; }
    public NullCheckAccess(IAccess qualifier, CheckAccessKind checkAccessKind, NullCheckKind checkRepresentation);
    public NullCheckAccess(IAccess qualifier, CheckAccessKind checkAccessKind, NullCheckKind checkRepresentation, TreeTextRange nullCheckRange, ICSharpExpression expression);
    [CompilerGeneratedAttribute]
public virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public NullCheckKind get_CheckRepresentation();
    public virtual bool get_CanBeMerged();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
    [CanBeNullAttribute]
public static NullCheckAccess TryBuildNullCheck(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ParenthesizedAccess : MandatoryQualifiedAccess {
    [NotNullAttribute]
private IParenthesizedExpression myExpression;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public bool CanBeMerged { get; }
    public bool IsLifted { get; }
    public ParenthesizedAccess(IParenthesizedExpression expression, IAccess qualifier);
    public virtual ICSharpExpression get_Expression();
    public virtual bool get_CanBeMerged();
    public virtual bool get_IsLifted();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    [CanBeNullAttribute]
[PureAttribute]
public static IAccess TryBuild(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.PatternCheckAccess : QualifiedCheckAccess {
    [CompilerGeneratedAttribute]
private IPattern <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <TypeCheckType>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [NotNullAttribute]
private IPattern Pattern { get; }
    [CanBeNullAttribute]
public IType TypeCheckType { get; }
    public ICSharpExpression Expression { get; }
    public bool CanBeMerged { get; }
    public PatternCheckAccess(IAccess qualifier, IPattern pattern, CheckAccessKind checkAccessKind);
    public PatternCheckAccess(IAccess qualifier, IPattern pattern, CheckAccessKind checkAccessKind, TreeTextRange patternCheckRange, ICSharpExpression expression);
    [CompilerGeneratedAttribute]
private IPattern get_Pattern();
    [CompilerGeneratedAttribute]
public IType get_TypeCheckType();
    [CompilerGeneratedAttribute]
public virtual ICSharpExpression get_Expression();
    public virtual bool get_CanBeMerged();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
    [CanBeNullAttribute]
public static PatternCheckAccess TryBuildPatternCheck(ICSharpExpression expression);
    [CanBeNullAttribute]
public static PatternCheckAccess TryBuildPatternCheck(ICSharpExpression expression, bool inverted, ICSharpExpression topExpression);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.QualifiedAccess : object {
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccess <Qualifier>k__BackingField;
    public ICSharpExpression Expression { get; }
    public int Level { get; }
    [CanBeNullAttribute]
public IAccess Qualifier { get; }
    public bool IsLifted { get; }
    public bool CanBeMerged { get; }
    public bool IsNullableDotValue { get; }
    protected QualifiedAccess(IAccess qualifier);
    public abstract virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual IAccess get_Qualifier();
    public virtual bool IsValid();
    public virtual bool get_IsLifted();
    public virtual IAccess Unlift();
    public virtual bool get_CanBeMerged();
    public virtual bool get_IsNullableDotValue();
    public sealed virtual IAccess Map(Func`2<IAccess, IAccess> func);
    public sealed virtual TAcc Fold(TAcc seed, Func`3<TAcc, IAccess, TAcc> func);
    public sealed virtual IAccess MergeWithSubset(IAccess previousAccess);
    [CanBeNullAttribute]
private IAccess MergeAndCheckParent(IAccess previousAccess, IAccess newQualifier);
    public virtual bool CheckParentAfterMerge(IAccess parentAccess);
    [CanBeNullAttribute]
protected abstract virtual IAccess MergeWithPrevious(IAccess previousAccess, IAccess newQualifier);
    [NotNullAttribute]
[PureAttribute]
public virtual IAccess ChangeQualifier(IAccess newQualifier);
    public abstract virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public abstract virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
    public virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
protected ITreeNode TryGetContextTreeNode();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.QualifiedCheckAccess : MandatoryQualifiedAccess {
    [CompilerGeneratedAttribute]
private CheckAccessKind <CheckAccessKind>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeTextRange <CheckRange>k__BackingField;
    public CheckAccessKind CheckAccessKind { get; }
    public TreeTextRange CheckRange { get; }
    protected QualifiedCheckAccess(IAccess qualifier, CheckAccessKind checkAccessKind, TreeTextRange checkRange);
    [CompilerGeneratedAttribute]
public virtual CheckAccessKind get_CheckAccessKind();
    [CompilerGeneratedAttribute]
public sealed virtual TreeTextRange get_CheckRange();
    public virtual bool IsGoodEnoughToSuggest();
    public abstract virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
    public virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ReferenceAccess : ConditionalAccess {
    [CompilerGeneratedAttribute]
private bool <IsNullableDotValue>k__BackingField;
    [CanBeNullAttribute]
public IReferenceExpression Expression { get; }
    public bool CanBeMerged { get; }
    public bool IsNullableDotValue { get; }
    public ReferenceAccess(IAccess qualifier, IReferenceExpression expression, DeclaredElementInstance declaredElementInstance, bool nullableUnwrap, bool nullableValueAccess, bool isConditionalAccess);
    private ReferenceAccess(IAccess qualifier, IReferenceExpression expression, DeclaredElementInstance declaredElementInstance, bool nullableUnwrap, bool nullableValueAccess, bool isConditionalAccess, bool alwaysLifted, bool nonLiftableType);
    public IReferenceExpression get_Expression();
    public virtual bool get_CanBeMerged();
    [CompilerGeneratedAttribute]
public virtual bool get_IsNullableDotValue();
    public virtual IAccess Unlift();
    protected virtual IAccess MergeWithPrevious(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual TreeTextRange GetConditionalSignRange();
    [PureAttribute]
internal static TreeTextRange GetConditionalSignRange(IReferenceExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
public static ReferenceAccess TryBuildReferenceAccess(ICSharpExpression expression);
    [CanBeNullAttribute]
public static ReferenceAccess TryBuildReferenceAccess(IVariableDeclaration variableDeclaration);
    [CanBeNullAttribute]
[PureAttribute]
public static ReferenceAccess TryBuildReferenceAccess(ILocalVariable localVariable);
    [CanBeNullAttribute]
[PureAttribute]
public static ReferenceAccess TryBuildFromSubpatternMemberAccess(IAccess qualifier, ISubpattern subpattern);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
[PureAttribute]
internal static ReferenceAccess <TryBuildFromSubpatternMemberAccess>g__TryBuild|18_0(ICSharpExpression accessExpression, <>c__DisplayClass18_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.SplitableConditionalAccessExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ISplitableConditionalAccess FindSplitByRange(IAccess accessChain, TreeTextRange range);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ISplitableConditionalAccess FindFirstSplit(IAccess accessChain);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.ThisExpressionAccess : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public int Level { get; }
    public bool IsLifted { get; }
    public bool CanBeMerged { get; }
    public ThisExpressionAccess(IThisExpression thisExpression);
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpExpression get_Expression();
    public sealed virtual bool IsValid();
    public sealed virtual int get_Level();
    public sealed virtual bool get_IsLifted();
    public sealed virtual IAccess Unlift();
    public sealed virtual bool get_CanBeMerged();
    public sealed virtual IAccess MergeWithSubset(IAccess previousAccess);
    public sealed virtual bool CheckParentAfterMerge(IAccess parentAccess);
    public sealed virtual IAccess Map(Func`2<IAccess, IAccess> func);
    public sealed virtual TAcc Fold(TAcc seed, Func`3<TAcc, IAccess, TAcc> func);
    public sealed virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public sealed virtual IExpressionType TryCalculateCreatedExpressionType();
    public sealed virtual ICSharpExpression CreateDefaultValue(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    public virtual string ToString();
    [CanBeNullAttribute]
[PureAttribute]
public static IAccess TryBuild(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.TryCastAccess : CastAccessBase {
    [CanBeNullAttribute]
private IAsExpression myAsExpression;
    public ICSharpExpression Expression { get; }
    public TryCastAccess(IAccess qualifier, IType typeOperand, IAsExpression asExpression, bool isLiftedCast);
    public virtual ICSharpExpression get_Expression();
    public virtual IAccess Unlift();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    [CanBeNullAttribute]
[PureAttribute]
public static TryCastAccess TryBuildTryCast(ICSharpExpression expression);
    public static bool IsValidTryCastType(IType type);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.TypeCheckAccess : QualifiedCheckAccess {
    [CompilerGeneratedAttribute]
private IType <TypeOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [NotNullAttribute]
public IType TypeOperand { get; }
    public ICSharpExpression Expression { get; }
    public bool CanBeMerged { get; }
    public TypeCheckAccess(IAccess qualifier, IType typeOperand, CheckAccessKind checkAccessKind);
    public TypeCheckAccess(IAccess qualifier, IType typeOperand, CheckAccessKind checkAccessKind, TreeTextRange typeCheckRange, ICSharpExpression expression);
    [CompilerGeneratedAttribute]
public IType get_TypeOperand();
    [CompilerGeneratedAttribute]
public virtual ICSharpExpression get_Expression();
    public virtual bool get_CanBeMerged();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    public virtual ICheckAccess SpecifyCheckAccessKind(CheckAccessKind checkAccessKind);
    [CanBeNullAttribute]
public static TypeCheckAccess TryBuildTypeCheck(ICSharpExpression expression);
    [CanBeNullAttribute]
public static TypeCheckAccess TryBuildTypeCheck(ICSharpExpression expression, bool inverted, ICSharpExpression topExpression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Expressions.UnaryOperatorAccess : MandatoryQualifiedAccess {
    [NotNullAttribute]
private IUnaryOperatorExpression myUnaryOperator;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public bool IsLifted { get; }
    public bool CanBeMerged { get; }
    public UnaryOperatorAccess(IAccess qualifier, IUnaryOperatorExpression unaryOperator);
    public virtual ICSharpExpression get_Expression();
    public virtual bool get_IsLifted();
    public virtual bool get_CanBeMerged();
    public virtual IAccess Unlift();
    protected virtual IAccess MergeWithPreviousEx(IAccess previousAccess, IAccess newQualifier);
    public virtual ICSharpExpression CreateExpression(CSharpElementFactory factory);
    public virtual IExpressionType TryCalculateCreatedExpressionType();
    [CanBeNullAttribute]
[PureAttribute]
public static UnaryOperatorAccess TryBuildUnaryOperatorAccess(ICSharpExpression expression);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.NullPropagation.IfStatementBasedPattern : NullPropagatingPattern {
    [CompilerGeneratedAttribute]
private ICheckAccess <ConditionCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpStatement <ThenStatement>k__BackingField;
    [NotNullAttribute]
public IIfStatement IfStatement { get; }
    [NotNullAttribute]
public ICheckAccess ConditionCheck { get; }
    [NotNullAttribute]
public ICSharpStatement ThenStatement { get; }
    public TreeTextRange SuggestionTextRange { get; }
    public DisjointedTreeTextRange ActionTextRange { get; }
    protected IfStatementBasedPattern(IIfStatement ifStatement, ICheckAccess conditionCheck, ICSharpStatement thenStatement);
    public IIfStatement get_IfStatement();
    [CompilerGeneratedAttribute]
public ICheckAccess get_ConditionCheck();
    [CompilerGeneratedAttribute]
public ICSharpStatement get_ThenStatement();
    public virtual TreeTextRange get_SuggestionTextRange();
    public virtual DisjointedTreeTextRange get_ActionTextRange();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.NullPropagation.IfStatementInvertedPattern : IfStatementBasedPattern {
    [CompilerGeneratedAttribute]
private LiftedJumpStatement <ThenJumpStatement>k__BackingField;
    [NotNullAttribute]
public LiftedJumpStatement ThenJumpStatement { get; }
    public IfStatementInvertedPattern(IIfStatement ifStatement, ICheckAccess conditionCheck, ICSharpStatement thenStatement, LiftedJumpStatement thenJumpStatement);
    [CompilerGeneratedAttribute]
public LiftedJumpStatement get_ThenJumpStatement();
    protected virtual bool Inspect(LiftingVisitor visitor);
    public virtual NullPropagationSuggestion IsAvailable();
    private static bool IsGoodEnoughToSuggest(IList`1<ILiftedStatement> statements);
    public virtual void Transform(CSharpElementFactory factory);
    [CanBeNullAttribute]
[PureAttribute]
public static IfStatementInvertedPattern TryBuildIfInvertedCheck(ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.NullPropagation.IfStatementLastCheckPattern : IfStatementBasedPattern {
    public DisjointedTreeTextRange ActionTextRange { get; }
    public IfStatementLastCheckPattern(IIfStatement ifStatement, ICheckAccess conditionCheck, ICSharpStatement thenStatement);
    public virtual DisjointedTreeTextRange get_ActionTextRange();
    protected virtual bool Inspect(LiftingVisitor visitor);
    public virtual NullPropagationSuggestion IsAvailable();
    public virtual void Transform(CSharpElementFactory factory);
    [CanBeNullAttribute]
[PureAttribute]
public static IfStatementLastCheckPattern TryBuildIfLastCheck(ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.NullPropagation.IfStatementWithCheckPattern : IfStatementBasedPattern {
    [CanBeNullAttribute]
private ICSharpStatement myJumpStatementToRemove;
    [CompilerGeneratedAttribute]
private LiftedJumpStatement <ElseJumpStatement>k__BackingField;
    [CanBeNullAttribute]
public LiftedJumpStatement ElseJumpStatement { get; private set; }
    public IfStatementWithCheckPattern(IIfStatement ifStatement, ICheckAccess conditionCheck, ICSharpStatement thenStatement, LiftedJumpStatement elseJumpStatement);
    [CompilerGeneratedAttribute]
public LiftedJumpStatement get_ElseJumpStatement();
    [CompilerGeneratedAttribute]
private void set_ElseJumpStatement(LiftedJumpStatement value);
    protected virtual bool Inspect(LiftingVisitor visitor);
    public virtual NullPropagationSuggestion IsAvailable();
    private bool IsGoodEnoughToSuggest(IList`1<ILiftedStatement> statements);
    [NotNullAttribute]
[PureAttribute]
public ITreeRange GetThenBodyRange();
    public virtual void Transform(CSharpElementFactory factory);
    [NotNullAttribute]
private IfStatementWithCheckPattern PrepareForTransform();
    [CanBeNullAttribute]
[PureAttribute]
public static IfStatementWithCheckPattern TryBuildIfWithCheck(ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.NullPropagation.LiftingVisitor : object {
    [NotNullAttribute]
private ICSharpTreeNode myContext;
    [CanBeNullAttribute]
private LiftingVisitor myParentVisitor;
    [NotNullAttribute]
[ItemNotNullAttribute]
private List`1<ILiftedStatement> myStatements;
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private List`1<IAccess> myLiftedQualifiers;
    private bool myShouldStopLifting;
    [CompilerGeneratedAttribute]
private bool <IsFailedToLift>k__BackingField;
    [NotNullAttribute]
public IList`1<ILiftedStatement> Statements { get; }
    public bool IsFailedToLift { get; private set; }
    public LiftingVisitor(ICSharpTreeNode context);
    public LiftingVisitor(LiftingVisitor parentVisitor);
    public IList`1<ILiftedStatement> get_Statements();
    [CanBeNullAttribute]
public ILiftedStatement GetLastStatement();
    [CompilerGeneratedAttribute]
public bool get_IsFailedToLift();
    [CompilerGeneratedAttribute]
private void set_IsFailedToLift(bool value);
    private bool FailedToLift();
    public void AppendCheck(ICheckAccess checkAccess);
    public bool AppendQualifier(IAccess access);
    public void AppendStatement(ILiftedStatement statement);
    public bool ReplaceStatement(ILiftedStatement oldStatement, ILiftedStatement newStatement);
    public void LiftNullableVariablesAccess(CSharpElementFactory factory);
    public void TransformInplace(CSharpElementFactory factory);
    public bool LiftStatementIgnoringTopLevelBlock(ICSharpStatement statement);
    public bool LiftStatement(ICSharpStatement statement);
    public bool LiftStatementsFrom(ITreeNode firstNode);
    [CanBeNullAttribute]
public IAccess TryLiftWithPrevious(IAccess access);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.NullPropagation.NullPropagatingPattern : object {
    [CompilerGeneratedAttribute]
private ICSharpStatement <Statement>k__BackingField;
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    public TreeTextRange SuggestionTextRange { get; }
    public DisjointedTreeTextRange ActionTextRange { get; }
    protected NullPropagatingPattern(ICSharpStatement statement);
    [CompilerGeneratedAttribute]
public ICSharpStatement get_Statement();
    protected abstract virtual bool Inspect(LiftingVisitor visitor);
    public virtual NullPropagationSuggestion IsAvailable();
    [NotNullAttribute]
public static IList`1<ILocalVariable> CollectLiftedVariables(IList`1<ILiftedStatement> statements);
    private static void CollectLiftedVariables(ILiftedStatement liftedStatement, LocalList`1& variables);
    protected static bool HasVariableUsagesToLift(IList`1<ILiftedStatement> statements);
    public abstract virtual void Transform(CSharpElementFactory factory);
    public abstract virtual TreeTextRange get_SuggestionTextRange();
    public abstract virtual DisjointedTreeTextRange get_ActionTextRange();
    [ContractAnnotationAttribute("null => null; notnull => canbenull")]
public static NullPropagatingPattern TryBuild(ICSharpStatement statement);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.NullPropagation.NullPropagationSuggestion : Enum {
    public int value__;
    public static NullPropagationSuggestion NotAvailable;
    public static NullPropagationSuggestion Suggested;
    public static NullPropagationSuggestion Available;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.AndPatternMergeIntoRecursivePattern : AndPatternMergeOpportunity {
    [CanBeNullAttribute]
private IType myTypeCheckType;
    [CanBeNullAttribute]
private ITreeNode myDeconstructionClause;
    [CanBeNullAttribute]
private IPropertyPatternClause myPropertyPatternClause;
    [CanBeNullAttribute]
private IVariableDesignation myDesignation;
    public bool ShouldHighlightLeftPattern { get; }
    public AndPatternMergeIntoRecursivePattern(IType typeCheckType, ITreeNode deconstructionClause, IPropertyPatternClause propertyPatternClause, IVariableDesignation designation);
    public virtual bool IsValid();
    public virtual bool get_ShouldHighlightLeftPattern();
    public virtual IPattern CreateMergedPattern(CSharpElementFactory factory);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.AndPatternMergeIntoTypePattern : AndPatternMergeOpportunity {
    [NotNullAttribute]
private IType myTypeCheckType;
    [CanBeNullAttribute]
private IVariableDesignation myDesignation;
    public bool ShouldHighlightLeftPattern { get; }
    public AndPatternMergeIntoTypePattern(IType typeCheckType, IVariableDesignation designation);
    public virtual bool IsValid();
    public virtual bool get_ShouldHighlightLeftPattern();
    public virtual IPattern CreateMergedPattern(CSharpElementFactory factory);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.AndPatternMergeOpportunity : object {
    public bool ShouldHighlightLeftPattern { get; }
    public abstract virtual bool IsValid();
    public abstract virtual bool get_ShouldHighlightLeftPattern();
    [NotNullAttribute]
public abstract virtual IPattern CreateMergedPattern(CSharpElementFactory factory);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.AndPatternMergeUtil : object {
    [PureAttribute]
[CanBeNullAttribute]
public static AndPatternMergeOpportunity TryCreateAndPatternMergeOpportunity(IPattern firstPattern, IPattern secondPattern);
    [PureAttribute]
[CanBeNullAttribute]
public static AndPatternMergeOpportunity TryCreateAndPatternMergeOpportunity(IPattern firstPattern, SwitchCaseCheck secondCheck);
    [CanBeNullAttribute]
private static AndPatternMergeOpportunity TryMergeIntoSingleRecursivePattern(IPattern firstPattern, IPattern secondPattern);
    [ExtensionAttribute]
[PureAttribute]
private static bool IsConstantLikePattern(IPattern pattern, IType& expressionNominalCheckType);
    [ExtensionAttribute]
[PureAttribute]
private static bool CanParticipateInRecursivePattern(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
private static bool IsRecursiveOnlyCheckingForNull(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
private static bool IsRecursiveWithNoActualChecks(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
private static IVariableDesignation GetDesignationIfAny(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
private static IType TryGetTypeFromTypeCheck(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
private static bool IsTypeCheckWithoutDesignation(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
private static bool IsSubtype(IType type, IType otherType);
    [ExtensionAttribute]
[PureAttribute]
private static bool CanBreakIfInputTypeChanges(IPattern pattern);
    private static bool TryMergeTypes(IPattern firstPattern, IPattern secondPattern, IType& mergedType);
    [CompilerGeneratedAttribute]
internal static bool <TryMergeIntoSingleRecursivePattern>g__CanMergeDeconstruction|2_0(<>c__DisplayClass2_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.AndPatternMergeWithRedundantLeft : AndPatternMergeOpportunity {
    [NotNullAttribute]
private IPattern myRightPattern;
    public bool ShouldHighlightLeftPattern { get; }
    public AndPatternMergeWithRedundantLeft(IPattern rightPattern);
    public virtual bool IsValid();
    public virtual bool get_ShouldHighlightLeftPattern();
    public virtual IPattern CreateMergedPattern(CSharpElementFactory factory);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.AndPatternMergeWithRedundantRight : AndPatternMergeOpportunity {
    [NotNullAttribute]
private IPattern myLeftPattern;
    public bool ShouldHighlightLeftPattern { get; }
    public AndPatternMergeWithRedundantRight(IPattern leftPattern);
    public virtual bool IsValid();
    public virtual bool get_ShouldHighlightLeftPattern();
    public virtual IPattern CreateMergedPattern(CSharpElementFactory factory);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.FutureListPatternTargetInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <PatternCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <TargetIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SlicePatternIndex>k__BackingField;
    public int PatternCount { get; public set; }
    public Index TargetIndex { get; public set; }
    public Nullable`1<int> SlicePatternIndex { get; public set; }
    public FutureListPatternTargetInfo(int PatternCount, Index TargetIndex, Nullable`1<int> SlicePatternIndex);
    [CompilerGeneratedAttribute]
public int get_PatternCount();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PatternCount(int value);
    [CompilerGeneratedAttribute]
public Index get_TargetIndex();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetIndex(Index value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SlicePatternIndex();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SlicePatternIndex(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FutureListPatternTargetInfo left, FutureListPatternTargetInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FutureListPatternTargetInfo left, FutureListPatternTargetInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FutureListPatternTargetInfo other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& PatternCount, Index& TargetIndex, Nullable`1& SlicePatternIndex);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.IPatternMergeTarget {
    [NotNullAttribute]
public ITreeNode TreeNode { get; }
    public bool IsCheckNegated { get; }
    public bool HasDesignations { get; }
    public abstract virtual ITreeNode get_TreeNode();
    public abstract virtual bool get_IsCheckNegated();
    public abstract virtual bool get_HasDesignations();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual SubpatternTarget FindTarget(IReferenceExpression qualifierReference, PatternMergeContext mergeContext);
}
internal enum JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.MergeIntoExistingKind : Enum {
    public int value__;
    public static MergeIntoExistingKind ReplaceLeft;
    public static MergeIntoExistingKind OrPattern;
    public static MergeIntoExistingKind AndPattern;
    public static MergeIntoExistingKind MergedAndPattern;
    public static MergeIntoExistingKind InnerAndPattern;
    public static MergeIntoExistingKind InnerMergedAndPattern;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeCandidate : object {
    public abstract virtual bool IsValid();
    [PureAttribute]
public abstract virtual DisjointedTreeTextRange GetAvailabilityRange(ITokenNode mergeSign);
    public abstract virtual ISingleVariableDesignation ExecuteMergeIntoPattern();
    [PureAttribute]
protected static ISingleVariableDesignation TryFindUsedDesignation(ICSharpExpression variableExpression);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static ICSharpExpression <TryFindUsedDesignation>g__GetQualifier|3_0(ICSharpExpression referenceOrElementAccess);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeChainCandidate : PatternMergeCandidate {
    [NotNullAttribute]
private PatternMergeIntoRecursiveSubpattern myRootCandidate;
    [NotNullAttribute]
private SwitchCaseCheck mySwitchCaseCheck;
    [NotNullAttribute]
private IReferenceExpression myMemberReference;
    public PatternMergeChainCandidate(PatternMergeIntoRecursiveSubpattern rootCandidate, SwitchCaseCheck switchCaseCheck, IReferenceExpression memberReference);
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetAvailabilityRange(ITokenNode mergeSign);
    public virtual ISingleVariableDesignation ExecuteMergeIntoPattern();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeContext : ValueType {
    [CompilerGeneratedAttribute]
private IUsagesProvider <UsagesProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForSuggestion>k__BackingField;
    public static PatternMergeContext DefaultForActions;
    public static PatternMergeContext DefaultForSuggestion;
    [NotNullAttribute]
public IUsagesProvider UsagesProvider { get; }
    public bool ForSuggestion { get; }
    public PatternMergeContext(IUsagesProvider usagesProvider, bool forSuggestion);
    private static PatternMergeContext();
    [CompilerGeneratedAttribute]
public IUsagesProvider get_UsagesProvider();
    [CompilerGeneratedAttribute]
public bool get_ForSuggestion();
    [PureAttribute]
public bool HasUsagesOutsideOf(ILocalVariable variable, ITreeNode allowedContext);
    [PureAttribute]
public bool HasUsagesOutsideOf(ILocalVariable variable, TreeTextRange allowedContext);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeIntoExistingPattern : PatternMergeCandidate {
    [NotNullAttribute]
private SubpatternTarget myExistingTarget;
    [NotNullAttribute]
private SwitchCaseCheck mySwitchCaseCheck;
    [CompilerGeneratedAttribute]
private MergeIntoExistingKind <MergeKind>k__BackingField;
    public MergeIntoExistingKind MergeKind { get; }
    public PatternMergeIntoExistingPattern(SubpatternTarget existingTarget, SwitchCaseCheck switchCaseCheck, MergeIntoExistingKind mergeKind);
    [CompilerGeneratedAttribute]
public MergeIntoExistingKind get_MergeKind();
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetAvailabilityRange(ITokenNode mergeSign);
    public virtual ISingleVariableDesignation ExecuteMergeIntoPattern();
    [CanBeNullAttribute]
private static IPattern NegateIfBetter(IPattern pattern);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeIntoRecursiveSubpattern : PatternMergeCandidate {
    [NotNullAttribute]
private SubpatternTarget mySubpatternTarget;
    [NotNullAttribute]
private IReferenceExpression myMemberReference;
    [NotNullAttribute]
private SwitchCaseCheck mySwitchCaseCheck;
    public PatternMergeIntoRecursiveSubpattern(SubpatternTarget subpatternTarget, IReferenceExpression memberReference, SwitchCaseCheck switchCaseCheck);
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetAvailabilityRange(ITokenNode mergeSign);
    public virtual ISingleVariableDesignation ExecuteMergeIntoPattern();
    [CanBeNullAttribute]
public ISingleVariableDesignation ExecuteMergeIntoPattern(IPattern& createdPattern);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeTargetExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static SubpatternTarget FindSubpatternTarget(IPatternMergeTarget mergeTarget, PatternMergeContext mergeContext, ICSharpExpression variableExpression, bool canCheckCaptureNull);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
private static SubpatternTarget FindSubpatternTarget(IPatternMergeTarget mergeTarget, PatternMergeContext mergeContext, ICSharpExpression memberOrElementAccess, int depth, ICSharpExpression variableExpression, bool canCheckCaptureNull);
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange FindDefinitelyAssignedScopeRange(IPatternMergeTarget mergeTarget);
    [CompilerGeneratedAttribute]
internal static bool <FindSubpatternTarget>g__CanExtendWithSubpattern|1_0(SubpatternTarget patternTarget, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static TreeTextRange <FindDefinitelyAssignedScopeRange>g__FromExpression|2_0(ICSharpExpression checkExpression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeTargetFromNullCheck : object {
    [NotNullAttribute]
private ICSharpExpression myCheckExpression;
    [NotNullAttribute]
private ICSharpExpression myCheckOperand;
    [CompilerGeneratedAttribute]
private bool <IsCheckNegated>k__BackingField;
    public bool IsCheckNegated { get; }
    public bool HasDesignations { get; }
    private ITreeNode JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.IPatternMergeTarget.TreeNode { get; }
    public PatternMergeTargetFromNullCheck(ICSharpExpression checkExpression, ICSharpExpression checkOperand, bool isCheckNegated);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCheckNegated();
    public sealed virtual bool get_HasDesignations();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.IPatternMergeTarget.get_TreeNode();
    public sealed virtual SubpatternTarget FindTarget(IReferenceExpression qualifierReference, PatternMergeContext mergeContext);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeTargetFromPattern : object {
    [NotNullAttribute]
private IPattern myPattern;
    [CanBeNullAttribute]
private SwitchPatternDispatchExpressionTracker mySwitchTracker;
    [CompilerGeneratedAttribute]
private bool <IsCheckNegated>k__BackingField;
    public bool IsCheckNegated { get; }
    public bool HasDesignations { get; }
    private ITreeNode JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.IPatternMergeTarget.TreeNode { get; }
    public PatternMergeTargetFromPattern(IPattern pattern, bool isCheckNegated, SwitchPatternDispatchExpressionTracker switchTracker);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCheckNegated();
    public sealed virtual bool get_HasDesignations();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.IPatternMergeTarget.get_TreeNode();
    public sealed virtual SubpatternTarget FindTarget(IReferenceExpression qualifierReference, PatternMergeContext mergeContext);
    [CanBeNullAttribute]
private static SubpatternTarget TraverseDefinitelyAssignedDesignations(IPattern pattern, ILocalVariable variable, IReferenceExpression qualifierExpression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeTargetFromTempVariable : object {
    [NotNullAttribute]
private SubpatternTarget myTempVariableTarget;
    [NotNullAttribute]
private ILocalVariable myTempVariable;
    [NotNullAttribute]
private ITreeNode myContext;
    public bool IsCheckNegated { get; }
    public bool HasDesignations { get; }
    private ITreeNode JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.IPatternMergeTarget.TreeNode { get; }
    public PatternMergeTargetFromTempVariable(SubpatternTarget tempVariableTarget, ILocalVariable tempVariable, ITreeNode context);
    public sealed virtual bool get_IsCheckNegated();
    public sealed virtual bool get_HasDesignations();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.IPatternMergeTarget.get_TreeNode();
    public sealed virtual SubpatternTarget FindTarget(IReferenceExpression qualifierReference, PatternMergeContext mergeContext);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeTargetFromValueCheck : object {
    [NotNullAttribute]
private ICSharpExpression myCheckExpression;
    [NotNullAttribute]
private SwitchCaseCheck myValueCheck;
    [CompilerGeneratedAttribute]
private bool <IsCheckNegated>k__BackingField;
    public ITreeNode TreeNode { get; }
    public bool IsCheckNegated { get; }
    public bool HasDesignations { get; }
    public PatternMergeTargetFromValueCheck(ICSharpExpression checkExpression, SwitchCaseCheck valueCheck, bool isCheckNegated);
    public sealed virtual ITreeNode get_TreeNode();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCheckNegated();
    public sealed virtual bool get_HasDesignations();
    public sealed virtual SubpatternTarget FindTarget(IReferenceExpression qualifierReference, PatternMergeContext mergeContext);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.PatternMergeUtil : object {
    public static int MaxListPatternMergeSize;
    [CanBeNullAttribute]
[PureAttribute]
public static IPatternMergeTarget TryCreateMergeTargetFromCheckExpression(ICSharpExpression checkExpression, PatternMergeContext mergeContext);
    [CanBeNullAttribute]
[PureAttribute]
public static PatternMergeCandidate TryCreateMergeCandidate(IPatternMergeTarget mergeTarget, ICSharpExpression nextCheckExpression, bool isAlternation, PatternMergeContext mergeContext);
    [CanBeNullAttribute]
[PureAttribute]
private static PatternMergeCandidate TryMergeIntoLogicalPattern(IPatternMergeTarget mergeTarget, ICSharpExpression nextCheckExpression, bool isAlternation, CSharpLanguageLevel languageLevel, PatternMergeContext mergeContext);
    [PureAttribute]
private static bool HasDesignationsUnderNegatedPattern(SwitchCaseCheck caseCheck);
    [PureAttribute]
private static bool HasDesignations(SwitchCaseCheck caseCheck);
    [PureAttribute]
public static bool IsFineToChangeTheInputType(SwitchCaseCheck caseCheck);
    [CanBeNullAttribute]
[PureAttribute]
private static SwitchCaseCheck TryBuildCheckFromExpression(ICSharpExpression expression, CSharpLanguageLevel languageLevel, bool allowNegatedEqualityChecks);
    [PureAttribute]
public static bool IsValidRecursivePatternMember(ITypeMember typeMember);
    [PureAttribute]
public static bool CompareQualifiers(ICSharpExpression left, ICSharpExpression right, PatternMergeContext mergeContext);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static SubpatternTarget TryFindTargetForCollectionElementFromExistingPattern(SubpatternTarget target, IPattern pattern, IElementAccessExpression elementAccess);
    [PureAttribute]
internal static Nullable`1<FutureListPatternTargetInfo> TryCreateFutureListPatternTargetInfo(IReferenceExpression lengthAccess, IType collectionType, ConstantValue lengthValue, bool isRelationalCheck, IElementAccessExpression elementAccess);
    [PureAttribute]
public static bool IsIndexableCollectionLengthProperty(IType collectionType, IReferenceExpression propertyExpression, IResolveContext resolveContext);
    [PureAttribute]
public static Nullable`1<int> TryGetNonNegativeIntValue(ConstantValue constantValue);
    [PureAttribute]
private static Nullable`1<Index> TryGetCollectionElementIndex(IElementAccessExpression elementAccess);
    [PureAttribute]
private static Nullable`1<Index> TryMapElementIndexToListPatternIndex(Index elementIndex, int patternCount, Nullable`1<int> slicePatternIndex);
    [CompilerGeneratedAttribute]
internal static bool <CompareQualifiers>g__CanMergeUsingAccessApi|8_0(<>c__DisplayClass8_0& );
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SequentialPatternCheck : object {
    [NotNullAttribute]
public ITreeNode ContextNode { get; }
    [NotNullAttribute]
public ITokenNode MergeSign { get; }
    public bool IsLogicalPatternMerge { get; }
    public abstract virtual ITreeNode get_ContextNode();
    public abstract virtual ITokenNode get_MergeSign();
    [PureAttribute]
public abstract virtual bool CheckAvailabilityRange(TreeTextRange selectionRange);
    [PureAttribute]
public abstract virtual bool IsValid();
    public abstract virtual bool get_IsLogicalPatternMerge();
    [NotNullAttribute]
public abstract virtual MergeResult Execute(bool createNextCheck);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SequentialPatternCheck/<TryCreateFromChecks>d__10")]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<SequentialPatternCheck> TryCreateFromChecks(Polyadic`1<ICSharpExpression> polyadic, PatternMergeContext mergeContext);
    [PureAttribute]
[CanBeNullAttribute]
public static SequentialPatternCheck TryCreateFromAllOperands(Polyadic`1<ICSharpExpression> polyadic, PatternMergeContext mergeContext);
    [CanBeNullAttribute]
[PureAttribute]
public static SequentialPatternCheck TryCreateFromGuard(IPattern pattern, IPatternGuardClause guard, SwitchPatternDispatchExpressionTracker tracker, PatternMergeContext mergeContext);
    [CanBeNullAttribute]
[PureAttribute]
public static SequentialPatternCheck TryCreateFromSwitchExpressionArm(ISwitchExpressionArm switchExpressionArm);
    [CanBeNullAttribute]
[PureAttribute]
public static SequentialPatternCheck TryCreateFromSwitchCaseLabel(ISwitchCaseLabel switchCaseLabel);
    [CanBeNullAttribute]
[PureAttribute]
private static SequentialPatternCheck TryCreateFromSwitchCaseThenBody(IPattern pattern, ICSharpTreeNode switchCaseLabel, ICSharpExpression returnExpression, ITokenNode mergeSign, PatternMergeContext mergeContext);
    [CanBeNullAttribute]
[PureAttribute]
public static SequentialPatternCheck TryCreateFromIfStatementWithInnerIf(IIfStatement containingIfStatement, PatternMergeContext mergeContext);
    [CanBeNullAttribute]
[PureAttribute]
public static SequentialPatternCheck TryCreateFromIfStatementWithInnerVariableDeclarationAndIf(IIfStatement containingIfStatement, PatternMergeContext mergeContext);
    [CanBeNullAttribute]
[PureAttribute]
public static SequentialPatternCheck TryCreateFromIfStatementWithExitJump(IIfStatement ifStatement, PatternMergeContext mergeContext);
    [CompilerGeneratedAttribute]
internal static DisjointedTreeTextRange <TryCreateFromIfStatementWithInnerIf>g__BuildRange|16_0(<>c__DisplayClass16_0& , <>c__DisplayClass16_1& );
    [CompilerGeneratedAttribute]
internal static DisjointedTreeTextRange <TryCreateFromIfStatementWithInnerIf>g__BuildRange|16_1(<>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
internal static DisjointedTreeTextRange <TryCreateFromIfStatementWithInnerVariableDeclarationAndIf>g__BuildRange|17_0(<>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static DisjointedTreeTextRange <TryCreateFromIfStatementWithExitJump>g__BuildRange|18_0(<>c__DisplayClass18_0& );
    [CompilerGeneratedAttribute]
internal static ICSharpStatement <TryCreateFromIfStatementWithExitJump>g__UnwrapFromBlock|18_1(ICSharpStatement statement, bool forSuggestion);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTarget : object {
    public bool CanHaveSubpattern { get; }
    [CanBeNullAttribute]
public ISingleVariableDesignation ExistingDesignation { get; }
    [PureAttribute]
public abstract virtual bool IsValid();
    [PureAttribute]
public abstract virtual DisjointedTreeTextRange GetDesignationNameRange();
    [PureAttribute]
public abstract virtual bool IsNotNull(PatternMergeContext mergeContext);
    [PureAttribute]
protected static bool IsNotNull(ICSharpExpression expression);
    [PureAttribute]
protected static bool IsNotNull(IPattern pattern);
    public abstract virtual bool get_CanHaveSubpattern();
    public abstract virtual ISingleVariableDesignation get_ExistingDesignation();
    [PureAttribute]
public virtual bool HasSubpatternTargetForMember(ITypeMember typeMember, SubpatternTargetInfo& targetInfo);
    [NotNullAttribute]
public abstract virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
    [CanBeNullAttribute]
[PureAttribute]
public virtual SubpatternTarget TryFindTargetForCollectionElement(IElementAccessExpression elementAccess);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetCreateNewSubpattern : SubpatternTarget {
    [NotNullAttribute]
private SubpatternTarget myInnerTarget;
    [CompilerGeneratedAttribute]
private IReferenceExpression <MemberToReference>k__BackingField;
    [NotNullAttribute]
public IReferenceExpression MemberToReference { get; }
    public bool CanHaveSubpattern { get; }
    public bool CanMergeAlternation { get; }
    public ISingleVariableDesignation ExistingDesignation { get; }
    public SubpatternTargetCreateNewSubpattern(SubpatternTarget innerTarget, IReferenceExpression memberToReference);
    [CompilerGeneratedAttribute]
public IReferenceExpression get_MemberToReference();
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    public virtual bool get_CanHaveSubpattern();
    public bool get_CanMergeAlternation();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromCollectionLengthPattern : SubpatternTargetFromFutureListPatternElement {
    private SubpatternTarget myInnerTarget;
    [NullableAttribute("2")]
public ISingleVariableDesignation ExistingDesignation { get; }
    public SubpatternTargetFromCollectionLengthPattern(SubpatternTarget innerTarget, FutureListPatternTargetInfo targetInfo, IElementAccessExpression elementAccess);
    public static SubpatternTargetFromCollectionLengthPattern TryCreateFromValueCheck(SubpatternTarget subpatternTarget, SwitchCaseCheck valueCheck, IElementAccessExpression elementAccess);
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    [NullableContextAttribute("2")]
public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromConditionalAccess : SubpatternTarget {
    private ICSharpExpression myCheckExpression;
    private ICSharpExpression myQualifier;
    private IReferenceExpression myConditionalMemberAccess;
    private SwitchCaseCheck mySubpatternMemberCheck;
    private bool myIsCheckNegated;
    public bool CanHaveSubpattern { get; }
    [NullableAttribute("2")]
public ISingleVariableDesignation ExistingDesignation { get; }
    private SubpatternTargetFromConditionalAccess(ICSharpExpression checkExpression, ICSharpExpression qualifier, IReferenceExpression conditionalMemberAccess, SwitchCaseCheck subpatternMemberCheck, bool isCheckNegated);
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual bool get_CanHaveSubpattern();
    [NullableContextAttribute("2")]
public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual SubpatternTarget TryFindTargetForCollectionElement(IElementAccessExpression elementAccess);
    public static SubpatternTargetFromConditionalAccess TryCreate(ICSharpExpression checkExpression, ICSharpExpression checkOperand, ICSharpExpression qualifier, SwitchCaseCheck subpatternMemberCheck, bool isCheckNegated, PatternMergeContext mergeContext);
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
    public virtual bool HasSubpatternTargetForMember(ITypeMember typeMember, SubpatternTargetInfo& targetInfo);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromDiscardedTuplePattern : SubpatternTarget {
    [NotNullAttribute]
private IPattern myDiscardPattern;
    private int myComponentIndex;
    private int myComponentsCount;
    public bool CanHaveSubpattern { get; }
    public ISingleVariableDesignation ExistingDesignation { get; }
    public SubpatternTargetFromDiscardedTuplePattern(IPattern discardPattern, int componentIndex, int componentsCount);
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual bool get_CanHaveSubpattern();
    public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual bool HasSubpatternTargetForMember(ITypeMember typeMember, SubpatternTargetInfo& targetInfo);
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromExistingListPatternElement : SubpatternTargetFromExistingPattern {
    private IElementAccessExpression myElementAccess;
    public bool CanHaveSubpattern { get; }
    public SubpatternTargetFromExistingListPatternElement(IPattern pattern, IElementAccessExpression elementAccess);
    public virtual bool get_CanHaveSubpattern();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromExistingPattern : SubpatternTarget {
    [CompilerGeneratedAttribute]
private IPattern <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FoundByDesignation>k__BackingField;
    [NotNullAttribute]
public IPattern Pattern { get; }
    public bool FoundByDesignation { get; }
    public bool CanHaveSubpattern { get; }
    public ISingleVariableDesignation ExistingDesignation { get; }
    public SubpatternTargetFromExistingPattern(IPattern pattern, bool foundByDesignation);
    [CompilerGeneratedAttribute]
public IPattern get_Pattern();
    [CompilerGeneratedAttribute]
public bool get_FoundByDesignation();
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual bool get_CanHaveSubpattern();
    public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual SubpatternTarget TryFindTargetForCollectionElement(IElementAccessExpression elementAccess);
    public virtual bool HasSubpatternTargetForMember(ITypeMember typeMember, SubpatternTargetInfo& targetInfo);
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromFutureListPatternElement : SubpatternTarget {
    private IElementAccessExpression myElementAccess;
    [CompilerGeneratedAttribute]
private FutureListPatternTargetInfo <TargetInfo>k__BackingField;
    protected FutureListPatternTargetInfo TargetInfo { get; }
    public bool CanHaveSubpattern { get; }
    protected SubpatternTargetFromFutureListPatternElement(FutureListPatternTargetInfo targetInfo, IElementAccessExpression elementAccess);
    [CompilerGeneratedAttribute]
protected FutureListPatternTargetInfo get_TargetInfo();
    public virtual bool get_CanHaveSubpattern();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    protected IListPattern CreateListPattern(CSharpElementFactory factory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromMemberAccessPart : SubpatternTarget {
    private ISubpattern mySubpattern;
    private IReferenceExpression myMemberAccessPart;
    public bool CanHaveSubpattern { get; }
    [NullableAttribute("2")]
public ISingleVariableDesignation ExistingDesignation { get; }
    public SubpatternTargetFromMemberAccessPart(ISubpattern subpattern, IReferenceExpression memberAccessPart);
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    public virtual bool get_CanHaveSubpattern();
    [NullableContextAttribute("2")]
public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual SubpatternTarget TryFindTargetForCollectionElement(IElementAccessExpression elementAccess);
    public virtual bool HasSubpatternTargetForMember(ITypeMember typeMember, SubpatternTargetInfo& targetInfo);
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromNullCheckExpression : SubpatternTarget {
    [NotNullAttribute]
private ICSharpExpression myCheckExpression;
    [NotNullAttribute]
private ICSharpExpression myCheckedOperand;
    private bool myIsCheckNegated;
    public bool CanHaveSubpattern { get; }
    public ISingleVariableDesignation ExistingDesignation { get; }
    public SubpatternTargetFromNullCheckExpression(ICSharpExpression checkExpression, ICSharpExpression checkedOperand, bool isCheckNegated);
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual bool get_CanHaveSubpattern();
    public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
    [PureAttribute]
public bool CanUnliftDispatchTypeWhenBecamePattern();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromValueCheckExpression : SubpatternTarget {
    [NotNullAttribute]
private ICSharpExpression myCheckExpression;
    [NotNullAttribute]
private SwitchCaseCheck myValueCheck;
    private bool myIsCheckNegated;
    public bool CanHaveSubpattern { get; }
    public ISingleVariableDesignation ExistingDesignation { get; }
    public SubpatternTargetFromValueCheckExpression(ICSharpExpression checkExpression, SwitchCaseCheck valueCheck, bool isCheckNegated);
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual bool get_CanHaveSubpattern();
    public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual SubpatternTarget TryFindTargetForCollectionElement(IElementAccessExpression elementAccess);
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetFromVarDeconstructionDesignation : SubpatternTarget {
    [NotNullAttribute]
private IReferenceExpression myQualifierExpression;
    [CompilerGeneratedAttribute]
private IVarDeconstructionPattern <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private ISingleVariableDesignation <Designation>k__BackingField;
    [NotNullAttribute]
public IVarDeconstructionPattern Pattern { get; }
    [NotNullAttribute]
public ISingleVariableDesignation Designation { get; }
    public bool CanHaveSubpattern { get; }
    public ISingleVariableDesignation ExistingDesignation { get; }
    public SubpatternTargetFromVarDeconstructionDesignation(IVarDeconstructionPattern pattern, ISingleVariableDesignation designation, IReferenceExpression qualifierExpression);
    [CompilerGeneratedAttribute]
public IVarDeconstructionPattern get_Pattern();
    [CompilerGeneratedAttribute]
public ISingleVariableDesignation get_Designation();
    public virtual bool IsValid();
    public virtual DisjointedTreeTextRange GetDesignationNameRange();
    public virtual bool IsNotNull(PatternMergeContext mergeContext);
    public virtual bool get_CanHaveSubpattern();
    public virtual ISingleVariableDesignation get_ExistingDesignation();
    public virtual bool HasSubpatternTargetForMember(ITypeMember typeMember, SubpatternTargetInfo& targetInfo);
    public virtual IPattern GetOrCreateTargetPattern(CSharpElementFactory factory, bool includeNegation);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SubpatternTargetInfo : ValueType {
    [CanBeNullAttribute]
private object myValue;
    public static SubpatternTargetInfo Null { get; }
    private SubpatternTargetInfo(object value);
    public static SubpatternTargetInfo get_Null();
    public static SubpatternTargetInfo Pattern(IPattern pattern);
    public static SubpatternTargetInfo MemberAccessPart(IReferenceExpression memberAccessPart);
    public bool IsNull();
    [ContractAnnotationAttribute("=> false, pattern:null; => true, pattern:notnull")]
public bool IsPattern(IPattern& pattern);
    [ContractAnnotationAttribute("=> false, memberAccessPart:null; => true, memberAccessPart:notnull")]
public bool IsMemberAccessPart(IReferenceExpression& memberAccessPart);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Patterns.SwitchPatternDispatchExpressionTracker : object {
    public abstract virtual void ExecuteGuard(IPatternGuardClause patternGuardClause);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression TryGetDispatchExpressionFor(IPattern pattern);
    [NotNullAttribute]
public virtual IEnumerable`1<ValueTuple`2<ICSharpExpression, int>> GetPossibleComponents(Int32& componentsCount);
    [NotNullAttribute]
[PureAttribute]
public static SwitchPatternDispatchExpressionTracker BuildFor(ICSharpExpression governingExpression);
    [NotNullAttribute]
[PureAttribute]
private static SwitchPatternDispatchExpressionTracker TryBuildForTupleCondition(ITupleExpression tupleCondition);
    [NotNullAttribute]
[PureAttribute]
public static SwitchPatternDispatchExpressionTracker TryBuildUntil(ISwitchCaseLabel caseLabel, bool executeGuardAfterPattern);
    [NotNullAttribute]
[PureAttribute]
public static SwitchPatternDispatchExpressionTracker TryBuildUntil(ISwitchExpressionArm expressionArm, bool executeGuardAfterPattern);
    [NotNullAttribute]
[PureAttribute]
public static SwitchPatternDispatchExpressionTracker TryBuildForPattern(IPattern pattern, bool executeGuardAfterPattern);
    [PureAttribute]
private static bool IsSwitchTopLevelPattern(IPattern pattern);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.IControlJumpLiftedStatement {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IControlJumpLiftedStatement MergeWith(IControlJumpLiftedStatement elseStatement);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.ILiftedBlockLikeStatement {
    [NotNullAttribute]
public LiftingVisitor BodyVisitor { get; }
    public abstract virtual LiftingVisitor get_BodyVisitor();
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.ILiftedStatement {
    [CanBeNullAttribute]
public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    public abstract virtual ICSharpStatement get_Statement();
    public abstract virtual bool get_StopsLifting();
    public abstract virtual void TransformInplace(CSharpElementFactory factory);
    public abstract virtual void VisitExecutedCode(Action`1<ITreeNode> action);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedAssignmentStatement : object {
    [CompilerGeneratedAttribute]
private IExpressionStatement <ExpressionStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccess <LiftedSource>k__BackingField;
    [NotNullAttribute]
public IExpressionStatement ExpressionStatement { get; }
    [NotNullAttribute]
public IAccess LiftedSource { get; }
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    public LiftedAssignmentStatement(IExpressionStatement statement, IAccess liftedSource);
    [CompilerGeneratedAttribute]
public IExpressionStatement get_ExpressionStatement();
    [CompilerGeneratedAttribute]
public IAccess get_LiftedSource();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedAssignmentStatement TryCreate(LiftingVisitor visitor, ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedBlockStatement : object {
    [CompilerGeneratedAttribute]
private LiftingVisitor <BodyVisitor>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlock <Block>k__BackingField;
    public LiftingVisitor BodyVisitor { get; }
    [NotNullAttribute]
public IBlock Block { get; }
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    public LiftedBlockStatement(IBlock block, LiftingVisitor bodyVisitor);
    [CompilerGeneratedAttribute]
public sealed virtual LiftingVisitor get_BodyVisitor();
    [CompilerGeneratedAttribute]
public IBlock get_Block();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedBlockStatement TryCreate(LiftingVisitor visitor, ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedDeclarationStatement : object {
    [CompilerGeneratedAttribute]
private IDeclarationStatement <Declaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAccess> <LiftedInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedTypeUsageLift>k__BackingField;
    [NotNullAttribute]
public IDeclarationStatement Declaration { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<IAccess> LiftedInitializers { get; }
    public bool NeedTypeUsageLift { get; }
    public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    public LiftedDeclarationStatement(IDeclarationStatement declaration, bool needTypeUsageLift);
    [CompilerGeneratedAttribute]
public IDeclarationStatement get_Declaration();
    [CompilerGeneratedAttribute]
public IList`1<IAccess> get_LiftedInitializers();
    [CompilerGeneratedAttribute]
public bool get_NeedTypeUsageLift();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedDeclarationStatement TryCreate(LiftingVisitor visitor, ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedExpressionStatement : object {
    [CompilerGeneratedAttribute]
private IExpressionStatement <ExpressionStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccess <LiftedExpression>k__BackingField;
    [NotNullAttribute]
public IExpressionStatement ExpressionStatement { get; }
    [NotNullAttribute]
public IAccess LiftedExpression { get; }
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    public LiftedExpressionStatement(IExpressionStatement statement, IAccess liftedExpression);
    [CompilerGeneratedAttribute]
public IExpressionStatement get_ExpressionStatement();
    [CompilerGeneratedAttribute]
public IAccess get_LiftedExpression();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedExpressionStatement TryCreate(LiftingVisitor visitor, ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedIfStatement : object {
    [CompilerGeneratedAttribute]
private IIfStatement <IfStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private ICheckAccess <LiftedCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConjunctedCondition>k__BackingField;
    [NotNullAttribute]
public IIfStatement IfStatement { get; }
    [NotNullAttribute]
public ICheckAccess LiftedCheck { get; }
    public bool ConjunctedCondition { get; }
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    private LiftedIfStatement(IIfStatement ifStatement, ICheckAccess liftedCheck, bool conjunctedCondition);
    [CompilerGeneratedAttribute]
public IIfStatement get_IfStatement();
    [CompilerGeneratedAttribute]
public ICheckAccess get_LiftedCheck();
    [CompilerGeneratedAttribute]
public bool get_ConjunctedCondition();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedIfStatement TryCreate(LiftingVisitor visitor, ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedInvertedIfStatement : object {
    [CompilerGeneratedAttribute]
private IIfStatement <IfStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private ICheckAccess <LiftedCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private LiftedJumpStatement <ThenJump>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OrCondition>k__BackingField;
    [NotNullAttribute]
public IIfStatement IfStatement { get; }
    [NotNullAttribute]
public ICheckAccess LiftedCheck { get; }
    [NotNullAttribute]
public LiftedJumpStatement ThenJump { get; }
    public bool OrCondition { get; }
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    public LiftedInvertedIfStatement(IIfStatement ifStatement, ICheckAccess liftedCheck, LiftedJumpStatement thenJump, bool orCondition);
    [CompilerGeneratedAttribute]
public IIfStatement get_IfStatement();
    [CompilerGeneratedAttribute]
public ICheckAccess get_LiftedCheck();
    [CompilerGeneratedAttribute]
public LiftedJumpStatement get_ThenJump();
    [CompilerGeneratedAttribute]
public bool get_OrCondition();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    public sealed virtual IControlJumpLiftedStatement MergeWith(IControlJumpLiftedStatement elseStatement);
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedInvertedIfStatement TryCreate(LiftingVisitor visitor, ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedJumpStatement : object {
    [CompilerGeneratedAttribute]
private ICSharpStatement <JumpStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private object <JumpIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private JumpKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveOnTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnwrapDepth>k__BackingField;
    [CanBeNullAttribute]
public ICSharpStatement JumpStatement { get; }
    [CanBeNullAttribute]
public object JumpIdentity { get; }
    public JumpKind Kind { get; }
    public bool RemoveOnTransform { get; }
    public int UnwrapDepth { get; }
    public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    public LiftedJumpStatement(ICSharpStatement jumpStatement, JumpKind jumpKind, object jumpIdentity, int unwrapDepth, bool removeOnTransform);
    [CompilerGeneratedAttribute]
public ICSharpStatement get_JumpStatement();
    [CompilerGeneratedAttribute]
public object get_JumpIdentity();
    [CompilerGeneratedAttribute]
public JumpKind get_Kind();
    [CompilerGeneratedAttribute]
public bool get_RemoveOnTransform();
    [CompilerGeneratedAttribute]
public int get_UnwrapDepth();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    [CanBeNullAttribute]
public ICSharpTreeNode CreateStatement(CSharpElementFactory factory);
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    public sealed virtual IControlJumpLiftedStatement MergeWith(IControlJumpLiftedStatement elseStatement);
    [PureAttribute]
public bool Equals(LiftedJumpStatement other);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedJumpStatement TryCreate(ICSharpStatement statement, int unwrapDepth);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedJumpStatement TryCreateFromNext(ICSharpStatement anchorStatement, int unwrapDepth);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedReturnStatement : object {
    [CompilerGeneratedAttribute]
private IReturnStatement <ReturnStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccess <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnAccessKind <Kind>k__BackingField;
    [NotNullAttribute]
public IReturnStatement ReturnStatement { get; }
    [NotNullAttribute]
public IAccess ReturnValue { get; }
    public ReturnAccessKind Kind { get; }
    public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    private LiftedReturnStatement(IReturnStatement returnStatement, IAccess returnValue, ReturnAccessKind kind);
    [CompilerGeneratedAttribute]
public IReturnStatement get_ReturnStatement();
    [CompilerGeneratedAttribute]
public IAccess get_ReturnValue();
    [CompilerGeneratedAttribute]
public ReturnAccessKind get_Kind();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    public bool IsGoodEnoughToSuggest();
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    public sealed virtual IControlJumpLiftedStatement MergeWith(IControlJumpLiftedStatement elseStatement);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedReturnStatement TryCreate(LiftingVisitor visitor, ICSharpStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ConditionalAccess.Statements.LiftedUsingStatement : object {
    [CompilerGeneratedAttribute]
private IUsingStatement <UsingStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAccess> <LiftedInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private LiftingVisitor <BodyVisitor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedTypeUsageLift>k__BackingField;
    [NotNullAttribute]
public IUsingStatement UsingStatement { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<IAccess> LiftedInitializers { get; }
    public LiftingVisitor BodyVisitor { get; }
    public bool NeedTypeUsageLift { get; }
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    public bool StopsLifting { get; }
    public LiftedUsingStatement(IUsingStatement usingStatement, bool needTypeUsageLift, LiftingVisitor parentVisitor);
    [CompilerGeneratedAttribute]
public IUsingStatement get_UsingStatement();
    [CompilerGeneratedAttribute]
public IList`1<IAccess> get_LiftedInitializers();
    [CompilerGeneratedAttribute]
public sealed virtual LiftingVisitor get_BodyVisitor();
    [CompilerGeneratedAttribute]
public bool get_NeedTypeUsageLift();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual bool get_StopsLifting();
    public sealed virtual void TransformInplace(CSharpElementFactory factory);
    public sealed virtual void VisitExecutedCode(Action`1<ITreeNode> action);
    [CanBeNullAttribute]
[PureAttribute]
public static LiftedUsingStatement TryCreate(LiftingVisitor visitor, ICSharpStatement statement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.ContextActions.ContextActionDataProviderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IClassMemberDeclaration GetSelectedClassMemberDeclaration(IContextActionDataProvider`1<ICSharpFile> dataProvider);
}
[ContextActionDataBuilderAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ContextActions.ICSharpContextActionDataProvider", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ContextActions.CSharpContextActionDataBuilder : ContextActionDataBuilderBase`2<CSharpLanguage, ICSharpFile> {
    public virtual IContextActionDataProvider BuildFromPsi(ISolution solution, ITextControl textControl, ICSharpFile psiFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.ContextActions.CSharpContextActionDataProvider : CachedContextActionDataProviderBase`1<ICSharpFile> {
    [NullableAttribute("2")]
private ICSharpControlFlowGraph myCachedControlFlowGraph;
    private bool myIsControlFlowGraphCached;
    [CompilerGeneratedAttribute]
private CSharpElementFactory <ElementFactory>k__BackingField;
    public CSharpElementFactory ElementFactory { get; }
    public CSharpContextActionDataProvider(ISolution solution, ITextControl textControl, ICSharpFile file);
    [CompilerGeneratedAttribute]
public sealed virtual CSharpElementFactory get_ElementFactory();
    [NullableContextAttribute("2")]
public sealed virtual ICSharpControlFlowGraph GetControlFlowGraph();
    public sealed virtual CSharpContextActionDataProvider TryTranslateToCurrentFork(IContentModelForkTranslator translator);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.ContextActions.CSharpContextActionKeys : object {
    public static Key`1<string> AvailableKey;
    private static CSharpContextActionKeys();
}
[ContextActionGroupAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.ContextActions.CSharpContextActions : object {
    public static string GroupID;
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Feature.Services.CSharp.ContextActions.ICSharpContextActionDataProvider {
    public CSharpElementFactory ElementFactory { get; }
    public abstract virtual CSharpElementFactory get_ElementFactory();
    [NullableContextAttribute("2")]
public abstract virtual ICSharpControlFlowGraph GetControlFlowGraph();
}
[ShellComponentAttribute("16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.CSharpClrLanguage : object {
    public PsiLanguageType Language { get; }
    public sealed virtual PsiLanguageType get_Language();
}
[GeneratorBuilderAttribute("EventSubscriptions", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.CSharpEventSubscriptionsBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    public double Priority { get; }
    public CSharpEventSubscriptionsBuilder(ILanguageManager languageManager);
    public virtual double get_Priority();
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    public void Process(CSharpGeneratorContext context, AccessRights handlerAccessRights, IProgressIndicator progress);
    [CanBeNullAttribute]
public IDelegate GetMatchingDelegateType(GeneratorEventElement declaredElement, ISubstitution& substitution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.Daemon.CSharpDaemonStageBase : object {
    protected abstract virtual IDaemonStageProcess CreateProcess(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind, ICSharpFile file);
    public sealed virtual IEnumerable`1<IDaemonStageProcess> CreateProcess(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind);
    protected virtual bool IsSupported(IPsiSourceFile sourceFile);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Daemon.CSharpDaemonUtil : object {
    public static bool CheckTypeInference(ICSharpExpression invocationExpression, ICSharpInvocationInfo invocationInfo, TParametersOwner parametersOwner, Dictionary`2<IExpression, IExpressionType> typeOverrides);
    [MustUseReturnValueAttribute("This method is way too heavy to not use the result :O")]
public static bool CheckResolveEquivalence(ICSharpExpression expression, Action`1<ITreeNode> mutator, Func`2<ITreeNode, bool> customCheck);
    private static bool CheckPatternDesignationTypeEquivalence(ICSharpTreeNode switchNode, Func`2<ICSharpTreeNode, IEnumerable`1<IPattern>> enumeratePatternsFunc, Action`1<ITreeNode> mutator);
    [NotNullAttribute]
private static IReadOnlyList`1<ISingleVariableDesignation> CollectImplicitlyTypedDesignations(IPattern pattern);
    [NotNullAttribute]
private static IReadOnlyList`1<ISingleVariableDesignation> CollectImplicitlyTypedDesignations(IEnumerable`1<IPattern> patterns);
    private static bool CustomCheckForSwitchStatementOrExpression(ITreeNode treeNode, Func`2<T, IType> getGoverningType, Func`2<T, IEnumerable`1<IPattern>> getPatternsEnumerable);
    private static bool CheckResolveEquivalenceForTargetTypedExpression(Action`1<ITreeNode> mutator, Func`2<ITreeNode, bool> customCheck, ITargetTypedExpressionsContainer targetTypedExpression);
    private static bool CheckLocalVariableResolveEquivalence(ILocalVariableDeclaration variableDeclaration, IMultipleLocalVariableDeclaration localVariableDeclaration, Action`1<ITreeNode> mutator, Func`2<ITreeNode, bool> customCheck);
    private static bool CheckArgumentResolveEquivalence(ICSharpArgument argument, Action`1<ITreeNode> mutator, Func`2<ITreeNode, bool> customCheck);
    [PureAttribute]
[NotNullAttribute]
private static ICSharpExpression GetClosureExpressionToCheck(ICSharpClosure closure);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Daemon.CSharpDaemonUtil/<GetClosuresThatMayBeAffectByMutation>d__11")]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
private static IEnumerable`1<ICSharpClosure> GetClosuresThatMayBeAffectByMutation(ITreeNode element);
    [PureAttribute]
[NotNullAttribute]
private static ICollection`1<IParameter> CollectUsedLambdaParameters(ITreeNode element);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static IParametersOwner GetIncorrectArgumentsNumberInvocable(IDeclaredElement element);
    [CompilerGeneratedAttribute]
internal static NullableAnnotation <CheckTypeInference>g__GetDeclaredTopLevelLValueNullability|0_0(ICSharpExpression expression, IPsiModule psiModule);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Daemon.CSharpDaemonUtil/<<CheckResolveEquivalence>g__EnumeratePatterns|2_3>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<IPattern> <CheckResolveEquivalence>g__EnumeratePatterns|2_3(ISwitchStatement newSwitchStatement);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static IEnumerable`1<IPattern> <CheckResolveEquivalence>g__EnumerateArmPatterns|2_10(ISwitchExpression switchExpression);
    [CompilerGeneratedAttribute]
internal static void <CollectImplicitlyTypedDesignations>g__Collect|5_0(IPattern pattern, LocalList`1& results);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Daemon.CSharpImmediateInvokeUtil : object {
    public static bool TryReplaceWithMethodInvocation(ICSharpExpression operand, IInvocationExpression invocation);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression GetContainingDelegateCreation(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
public static IInvocationExpression GetContainingDelegateInvocation(ICSharpExpression delegateExpression);
    [PureAttribute]
public static DocumentRange GetDelegateCreationRange(ICSharpExpression expression);
    public static void MapParameterNames(IInvocationExpression invocation, IMethod sourceMethod, IMethod targetMethod);
    [CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IMethod> FindMethodGroupReference(ICSharpExpression operand);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.Daemon.CSharpNonUserFileDaemonStageBase : CSharpDaemonStageBase {
    protected virtual bool IsSupported(IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Daemon.RedundantCastAnalyzer : object {
    [NotNullAttribute]
private ICSharpTypeConversionRule myTypeConversionRule;
    [NotNullAttribute]
private TreeNodeMarker myRedundantCastMarker;
    private ICSharpExpression myCastExpression;
    private ICSharpExpression myCastedExpression;
    private CastType myCastType;
    public RedundantCastAnalyzer(ICSharpTypeConversionRule typeConversionRule);
    public bool TypeUpCastIsRedundant(ICSharpExpression castExpression);
    public bool TypeDownCastIsRedundant(ICastExpression castExpression);
    private bool TypeCastIsRedundant(ICSharpExpression castExpression, CastType castType);
    private bool CastToObjectInComparisonStringOrNullableWithNull(IType castTargetType);
    private bool CheckContextualTypeChange(ICSharpExpression outerExpression, IType targetType);
    private bool CheckInvariantSemantics(IType targetType);
    [PureAttribute]
private static bool ContainsTargetTypedExpression(ICSharpExpression expression);
    private bool CheckUserDefinedOperators(IExpressionType sourceType, IExpressionType castType, IType targetType);
    private static ICSharpExpression GetCastOperand(ICSharpExpression expression);
    [CanBeNullAttribute]
private static IType GetConvertedTo(ICSharpExpression expression, IType targetType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("10")]
public class JetBrains.ReSharper.Feature.Services.CSharp.DataConstants.CSharpDataRules : object {
    public CSharpDataRules(IActionManager actionManager, Lifetime lifetime);
    private static ICollection`1<IDeclaredElement> GetImplicitDeclaredElements(IDataContext dataContext);
    private static ICollection`1<IDeclaredElement> GetImplicitDeclaredElements(IPsiView psiView);
    private static ICollection`1<DeclaredElementInstance`1<ITypeElement>> GetVarTypeFromContext(IDataContext dataContext);
    [NullableContextAttribute("2")]
[PureAttribute]
private static ICollection`1<DeclaredElementInstance`1<ITypeElement>> ToDeclaredElements(IType type);
    private static ICollection`1<IDeclaredElement> GetDeclaredElementsBySignature(IDataContext dataContext);
    [PureAttribute]
public static bool IsInSignatureRange(ICSharpParametersOwnerDeclaration parametersOwnerDeclaration, TreeTextRange selectedRange);
    [PureAttribute]
public static bool IsInSignatureRange(IAccessorOwnerDeclaration accessorOwnerDeclaration, TreeTextRange selectedRange);
    [PureAttribute]
public static bool IsIndexerHeaderSelected(IIndexerDeclaration indexerDeclaration, TreeTextRange selectedRange);
    [PureAttribute]
public static bool IsPropertyHeaderSelected(IPropertyDeclaration propertyDeclaration, TreeTextRange selectedRange);
    [PureAttribute]
public static bool IsInSignatureRange(IMultipleEventDeclaration multipleEventDeclaration, TreeTextRange selectedRange);
    [PureAttribute]
public static bool IsInSignatureRange(IProperTypeDeclaration properTypeDeclaration, TreeTextRange selectedRange);
    [PureAttribute]
private static ITreeNode FindFirstChildSkipAttributesAndXmlDoc(ITreeNode declaration);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.DataConstants.CSharpPsiDataConstants : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DataConstant`1<ICollection`1<DeclaredElementInstance`1<ITypeElement>>> VAR_TYPE_FROM_CONTEXT;
    private static CSharpPsiDataConstants();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.CSharpBreakpointVariantsProvider : object {
    private static ILogger ourLogger;
    private static CSharpBreakpointVariantsProvider();
    public sealed virtual IReadOnlyList`1<IBreakpoint> GetBreakpointVariants(IProjectFile file, int line, ISolution solution);
    private void SearchInsideIndexers(ITreeNode startNode, DocumentRange lineTextRange, List`1<IBreakpoint> variants);
    private void SearchInTopLevelStatements(ITreeNode startNode, DocumentRange& lineTextRange, List`1<IBreakpoint> variants);
    private static void SearchInInactiveBranches(ITreeNode startNode, DocumentRange lineTextRange, List`1<IBreakpoint> variants);
    private void SearchInsideFields(IClassBody parentNode, DocumentRange lineTextRange, List`1<IBreakpoint> variants);
    private void SearchInsideProperties(IClassBody parentNode, DocumentRange lineTextRange, List`1<IBreakpoint> variants);
    private void SearchInsidePrimaryConstructors(ITreeNode startNode, DocumentRange lineTextRange, List`1<IBreakpoint> variants);
    private void SearchInsideExpressionBodyOwnerDeclaration(DocumentRange lineTextRange, List`1<IBreakpoint> variants, IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclaration);
    private void SearchInsideFunctions(IClassBody parentNode, DocumentRange lineTextRange, List`1<IBreakpoint> variants);
    public sealed virtual IEnumerable`1<string> GetSupportedFileExtensions();
    private List`1<IBreakpoint> FindBreakpointVariantsInside(ITreeNode node, DocumentRange lineRange);
    private bool AllChildrenVariantsStartsWithBiggerStartOffset(ITreeNode node, List`1<IBreakpoint> childrenVariants);
    private DocumentRange SpecifyTextRangeForStatementBreakpoint(ITreeNode statement);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.CSharpDebuggerLocalSymbolProvider : object {
    public sealed virtual Tuple`2<ITreeNode, IDeclaredElement> FindLocalDeclarationAt(IFile file, DocumentRange range, string name);
    public sealed virtual ITreeNode FindContainingFunctionDeclarationBody(ITreeNode node);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.CSharpExpressionEvaluationInfoProvider : object {
    private sealed virtual override IEnumerable`1<EvaluationExpressionInfo> JetBrains.ReSharper.Feature.Services.Debugger.ITrivialExpressionsWithoutSideEffectsEvaluationInfoProvider.FindExpressions(IFile psiFile, DocumentRange range);
    [CanBeNullAttribute]
private static string TryFixPatternVariable(ICSharpExpression csharpExpression, ICollection`1& evaluatedNodes);
    public sealed virtual EvaluationExpressionInfo FindExpression(IFile psiFile, DocumentRange range, EvaluationMode evaluationMode, IFile evaluationPointFile, DocumentOffset evaluationPointOffset, bool promoteToInvocation);
    private static EvaluationExpressionInfo MakeInfo(ICSharpExpression expression, string actualExpression);
    private static ICSharpExpression FixUpExpression(ICSharpExpression originExpression);
    [CompilerGeneratedAttribute]
internal static bool <FindExpression>g__NoSideEffectsCondition|3_0(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <FindExpression>g__PropertiesAllowedCondition|3_1(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <FindExpression>g__ExpressionIsValid|3_2(EvaluationMode mode, <>c__DisplayClass3_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.CSharpMethodDeclarationTreeNodeProvider : object {
    private ILogger myLogger;
    public CSharpMethodDeclarationTreeNodeProvider(ILogger logger);
    public sealed virtual ITreeNode GetMethodDeclarationTreeNode(IPsiSourceFile sourceFile, DocumentRange documentRange);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.CSharpOnDeclarationEvaluationProvider : object {
    public sealed virtual EvaluationExpressionInfo FindExpression(IFile psiFile, DocumentRange range, EvaluationMode evaluationMode, IFile evaluationPointFile, DocumentOffset evaluationPointOffset, bool promoteToInvocation);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.CSharpSmartStepIntoInfoProvider : object {
    public sealed virtual IEnumerable`1<SmartStepIntoTargetInfo> GetStepIntoInformation(IFile file, DocumentRange documentRange);
    private void ProcessTreeNode(ITreeNode node, DocumentRange range, List`1<SmartStepIntoTargetInfo> result);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.LocalSymbolFilter : SimpleSymbolFilter {
    public ResolveErrorType ErrorType { get; }
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.PropertiesSymbolFinder : SimpleSymbolFilter {
    public ResolveErrorType ErrorType { get; }
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.Debugger.ZoneMarker : object {
}
public class JetBrains.ReSharper.Feature.Services.CSharp.DebuggerVs.CreateTracepointContextAction : ContextActionBase {
    [NotNullAttribute]
public static Key HasBreakpointOnLine;
    private ICSharpContextActionDataProvider myDataProvider;
    private static string Caption;
    public string Text { get; }
    public CreateTracepointContextAction(ICSharpContextActionDataProvider dataProvider);
    private static CreateTracepointContextAction();
    public virtual string get_Text();
    protected virtual Action`1<ITextControl> ExecutePsiTransaction(ISolution solution, IProgressIndicator progress);
    public virtual void Execute(ISolution solution, ITextControl textControl);
    public virtual bool IsAvailable(IUserDataHolder cache);
    private bool HasBreakpoint();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.DebuggerVs.ZoneMarker : object {
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.EditorUIAdornment.ICodePositionPreviewProvider {
    public bool EmptyLinesAround { get; }
    [CanBeNullAttribute]
public abstract virtual IconId GetIcon(IStatementPositionCandidate candidate);
    [CanBeNullAttribute]
public abstract virtual RichText GetPreview(IStatementPositionCandidate candidate);
    [CanBeNullAttribute]
public abstract virtual RichText GetSingleLinePreview(IStatementPositionCandidate candidate);
    [CanBeNullAttribute]
public abstract virtual RichText GetTooltip();
    public abstract virtual bool get_EmptyLinesAround();
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.EditorUIAdornment.IStatementPositionCandidate {
    [CanBeNullAttribute]
public ITreeNode Anchor { get; }
    public bool Before { get; }
    public abstract virtual ITreeNode get_Anchor();
    public abstract virtual bool get_Before();
    [NotNullAttribute]
public abstract virtual TStatement InsertStatement(TStatement statement);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.EditorUIAdornment.StatementPositionCandidateBase`1 : object {
    [NotNullAttribute]
private ITreeNodePointer`1<TNode> myAnchorPointer;
    [CompilerGeneratedAttribute]
private ICodePositionPreviewProvider <PreviewProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Before>k__BackingField;
    [NotNullAttribute]
public ICodePositionPreviewProvider PreviewProvider { get; }
    private ITreeNode JetBrains.ReSharper.Feature.Services.CSharp.EditorUIAdornment.IStatementPositionCandidate.Anchor { get; }
    [CanBeNullAttribute]
public TNode Node { get; }
    public bool Before { get; public set; }
    protected StatementPositionCandidateBase`1(TNode anchor, bool before, ICodePositionPreviewProvider previewProvider);
    [CompilerGeneratedAttribute]
public ICodePositionPreviewProvider get_PreviewProvider();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Feature.Services.CSharp.EditorUIAdornment.IStatementPositionCandidate.get_Anchor();
    public TNode get_Node();
    public sealed virtual bool IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(bool value);
    public virtual CodePositionPresentationData GetPresentationInfo(Nullable`1& lBrace, Nullable`1& rBrace);
    protected static Nullable`1<CodePositionPresentationData> ToInlineBraceHintData(Nullable`1<int> position, bool lBrace);
    public abstract virtual TStatement InsertStatement(TStatement statement);
    protected abstract virtual bool HasInterlinePosition(TNode anchor, Nullable`1& blockStart, Nullable`1& blockEnd);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.EditorUIAdornment.StatementPositionFromExpression : StatementPositionCandidateBase`1<ICSharpExpression> {
    public StatementPositionFromExpression(ICSharpExpression anchor, bool before, ICodePositionPreviewProvider previewProvider);
    public virtual TStatement InsertStatement(TStatement statement);
    protected virtual bool HasInterlinePosition(ICSharpExpression anchor, Nullable`1& blockStart, Nullable`1& blockEnd);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.EditorUIAdornment.StatementPositionFromStatement : StatementPositionCandidateBase`1<ICSharpStatement> {
    public StatementPositionFromStatement(ICSharpStatement anchor, bool before, ICodePositionPreviewProvider previewProvider);
    public virtual TStatement InsertStatement(TStatement statement);
    public virtual CodePositionPresentationData GetPresentationInfo(Nullable`1& lBrace, Nullable`1& rBrace);
    protected virtual bool HasInterlinePosition(ICSharpStatement anchor, Nullable`1& blockStart, Nullable`1& blockEnd);
    private static bool HasInterlineSpace(ICSharpStatement anchor, bool before);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.EditorUIAdornment.StatementPositionFromStatementsOwner : StatementPositionCandidateBase`1<IStatementsOwner> {
    public StatementPositionFromStatementsOwner(IStatementsOwner anchor, bool before, ICodePositionPreviewProvider previewProvider);
    public virtual CodePositionPresentationData GetPresentationInfo(Nullable`1& lBrace, Nullable`1& rBrace);
    public virtual TStatement InsertStatement(TStatement statement);
    protected virtual bool HasInterlinePosition(IStatementsOwner anchor, Nullable`1& blockStart, Nullable`1& blockEnd);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ExpressionSelection.CSharpExpressionSelectionProvider : ExpressionSelectionProviderBase`1<ICSharpExpression> {
    protected virtual bool IsTokenSkipped(ITokenNode token);
}
[GeneratorElementProviderAttribute("DisposePattern", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpAutoPropertyOfDisposableTypeProvider : CSharpAutoPropertyProviderBase {
    protected virtual bool PropertyFilter(IProperty property, ISubstitution substitution, ITreeNode context);
}
[GeneratorElementProviderAttribute("RelationalMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpAutoPropertyOfRelationalTypeProvider : CSharpAutoPropertyProviderBase {
    protected virtual bool PropertyFilter(IProperty property, ISubstitution substitution, ITreeNode context);
}
[GeneratorElementProviderAttribute("EqualityMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpAutoPropertyProvider : CSharpAutoPropertyProviderBase {
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpAutoPropertyProviderBase : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public double Priority { get; }
    public virtual double get_Priority();
    public virtual void Populate(CSharpGeneratorContext context);
    protected virtual bool PropertyFilter(IProperty property, ISubstitution substitution, ITreeNode context);
}
[GeneratorElementProviderAttribute("Constructor", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorElementProviderAttribute("Implementations", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpBaseConstructorProvider : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public virtual void Populate(CSharpGeneratorContext context);
    private static void PopulateClassConstructors(CSharpGeneratorContext context, IClass typeElement);
    private static void PopulateStructConstructors(CSharpGeneratorContext context);
    private static bool AnyExplicitInstanceConstructorExists(ITypeElement typeElement);
    private static bool BaseDefaultConstructorExists(List`1<IConstructor> baseConstructors);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpBuilderOptions : object {
    public static string AccessRights;
    public static string Virtual;
    public static string ReadOnly;
    public static string ImplementationKind;
    public static string PropertyBody;
    public static string CanBeNull;
    public static string Async;
    public static string NotifyPropertyChanged;
    public static string Mutable;
    public static string AccessRightsPublic;
    [NotNullAttribute]
public static Key ForDelegation;
    [NotNullAttribute]
private static String[] ourAccessRightsChoices;
    public static string ImplementationKindPublicMember;
    public static string ImplementationKindExplicit;
    public static string ImplementationKindAbstract;
    public static string ImplementationKindVirtual;
    [NotNullAttribute]
public static String[] ImplementationKindChoices;
    public static string PropertyBodyDefault;
    public static string PropertyBodyAutomatic;
    public static string PropertyBodyBackingField;
    [NotNullAttribute]
public static String[] PropertyBodyChoices;
    public static Dictionary`2<AccessorImplementationKind, string> PropertyBodyOptions;
    [NotNullAttribute]
public static String[] ReadOnlyChoices;
    public static string AccessRightsAutomatic { get; }
    private static CSharpBuilderOptions();
    public static string get_AccessRightsAutomatic();
    [NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<string> GetAccessRightsChoices(CSharpGeneratorContext context);
    [NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<string> GetAccessRightsChoicesWithAutomatic(CSharpGeneratorContext context);
    [PureAttribute]
public static AccessRights GetAccessRights(string optionValue);
}
[GeneratorBuilderAttribute("Constructor", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Implementations", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Overrides", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Properties", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("ReadProperties", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Delegating", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Formatting", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("EqualityMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("RelationalMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("DisposePattern", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpCodeBodyStyleApplier : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    public double Priority { get; }
    public virtual double get_Priority();
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpComparerBuilderBase : GeneratorComparerBuilderBase`1<CSharpGeneratorContext> {
    [CompilerGeneratedAttribute]
private ILanguageManager <LanguageManager>k__BackingField;
    [NotNullAttribute]
protected ILanguageManager LanguageManager { get; }
    [NotNullAttribute]
protected String[] ComparerTypePostfixes { get; }
    [NotNullAttribute]
protected string GenericComparerTypeFqn { get; }
    protected CSharpComparerBuilderBase(ILanguageManager manager);
    [CompilerGeneratedAttribute]
protected ILanguageManager get_LanguageManager();
    protected abstract virtual String[] get_ComparerTypePostfixes();
    protected abstract virtual string get_GenericComparerTypeFqn();
    protected virtual IDeclaredType GetMemberSource(CSharpGeneratorContext context);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private void CreateExposedProperty(CSharpGeneratorContext context, CSharpElementFactory factory, string propertyName, string fieldName, string regionName, IDeclaredElement comparerTypeElement);
    [NotNullAttribute]
protected abstract virtual IClassMemberDeclaration CreateComparerType(CSharpGeneratorContext context, CSharpElementFactory factory, string comparerTypeName, IReadOnlyList`1<GeneratorComparisonMemberDescriptor> members);
    protected abstract virtual void CreateComparerMembers(CSharpGeneratorContext context, CSharpElementFactory factory, IReadOnlyList`1<GeneratorComparisonMemberDescriptor> members);
    [NotNullAttribute]
protected IDeclaredType GetGenericComparerType(IPsiModule module, IDeclaredType typeArgument);
}
[GeneratorBuilderAttribute("Constructor", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Implementations", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpConstructorBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    protected virtual void BuildOptions(CSharpGeneratorContext context, ICollection`1<IGeneratorOption> options);
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private static void FilterConflictingMembers(List`1<GeneratorDeclaredElement`1<IConstructor>> constructors);
    private static IClassMemberDeclaration CreateInstanceCtorDeclaration(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IConstructor> constructorElement);
    private static void PropagateAnnotations(IConstructorDeclaration constructorDeclaration, IConstructor constructor, CSharpElementFactory elementFactory, IPsiModule psiModule);
    private static bool CreateAndPutPrimaryCtorDeclaration(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IConstructor> constructorElement);
    private static ICSharpTreeNode GetResolveContext(IClassLikeDeclaration declaration);
    private static AccessRights GetConstructorAccessRights(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IConstructor> inputElement);
    [NotNullAttribute]
private static IClassMemberDeclaration CreateStaticCtorDeclaration(CSharpGeneratorContext context);
    [CompilerGeneratedAttribute]
internal static bool <Process>g__CanEmitPrimaryConstructor|2_0(GeneratorDeclaredElement`1& result, <>c__DisplayClass2_0& );
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpConstructorInitializationHelper : object {
    [NotNullAttribute]
private CSharpGeneratorContext myContext;
    [NotNullAttribute]
private ITypeElement myContainingType;
    [NotNullAttribute]
private IConstructorDeclaration myConstructorDeclaration;
    [NotNullAttribute]
private IReadOnlyList`1<ITypeOwner> myMembers;
    [NotNullAttribute]
private CSharpElementFactory myFactory;
    [NotNullAttribute]
private NullnessProvider myNullnessProvider;
    [ItemNotNullAttribute]
private TreeNodeCollection`1<ICSharpParameterDeclaration> myConstructorParameters;
    private bool myCheckParametersForNull;
    private bool myMakeParametersOptional;
    public CSharpConstructorInitializationHelper(CSharpGeneratorContext context, ITypeElement containingType, IConstructorDeclaration constructorDeclaration, IReadOnlyList`1<ITypeOwner> members, bool checkParametersForNull, bool makeParametersOptional);
    public void Generate();
    [NotNullAttribute]
private ICSharpParameterDeclaration GetOrCreateParameterDeclaration(ITypeOwner member, bool insertAfterBase);
    [NotNullAttribute]
[PureAttribute]
public static string SuggestParameterName(ITreeNode usageContext, ITypeOwner member);
    [CanBeNullAttribute]
[PureAttribute]
private ICSharpParameterDeclaration FindParameterByName(string parameterName);
    private void AnnotateNullability(ITypeOwner member, ITypeMemberRegularParameterDeclaration parameterDeclaration, IParameter parameter);
    [PureAttribute]
private bool IsAnnotatedAs(ITypeOwner member, CodeAnnotationNullableValue nullability);
    private bool EmitStructInitializationViaZeroingCtorCall();
    private void MakeParametersOptional();
    [CompilerGeneratedAttribute]
internal static bool <GetOrCreateParameterDeclaration>g__HasCompatibleRefKind|11_0(ITypeOwner member, IParameter parameter);
}
[GeneratorBuilderAttribute("Constructor", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpConstructorTypeOwnerInitializer : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    public static string CheckParametersForNullOption;
    public static string MakeParametersOptionalOption;
    public double Priority { get; }
    public virtual double get_Priority();
    protected virtual void BuildOptions(CSharpGeneratorContext context, ICollection`1<IGeneratorOption> options);
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private static void InitializeMembersByPrimaryParameter(IPrimaryConstructorDeclaration primaryConstructorDeclaration, IReadOnlyList`1<ITypeOwner> members);
    [NotNullAttribute]
[PureAttribute]
private static IReadOnlyList`1<ITypeOwner> GetMembersToInitialize(CSharpGeneratorContext context);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static IExpressionInitializer <InitializeMembersByPrimaryParameter>g__AddPrimaryParameterAndCreateInitializer|7_0(<>c__DisplayClass7_0& , <>c__DisplayClass7_1& );
}
[GeneratorBuilderAttribute("Deconstructor", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpDeconstructorBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
}
[GeneratorBuilderAttribute("Delegating", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpDelegatingMembersBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    public CSharpDelegatingMembersBuilder(ILanguageManager languageManager);
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private void GenerateWrapper(CSharpGeneratorContext context, GeneratorDelegatingElement inputElement, IOverridableMember overridableMember, bool canImplementExplicitly);
    public static void SetAccessorsRights(IAccessorOwnerDeclaration accessorOwnerDeclaration, AccessRights accessRights, IOverridableMember member);
}
[GeneratorElementProviderAttribute("Delegating", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpDelegatingMembersProvider : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public virtual void Populate(CSharpGeneratorContext context);
    private static bool IsFromObject(OverridableMemberInstance overridableMember);
}
[GeneratorBuilderAttribute("DisposePattern", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpDisposePatternBuilder : GeneratorDisposePatternBuilderBase`1<CSharpGeneratorContext> {
    private static string RegionName;
    private static string ChangeDisposeAsyncOption;
    protected string FinalizeName { get; }
    protected virtual string get_FinalizeName();
    protected virtual ITypeElement GetContainingType(CSharpGeneratorContext context);
    protected virtual bool HasFinalize(CSharpGeneratorContext context);
    protected virtual void BuildOptions(CSharpGeneratorContext context, IReadOnlyList`1<ITypeOwner> members, ICollection`1<IGeneratorOption> options);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private static bool IsValueTaskAction(IMethod method);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpDisposePatternHelper : object {
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IReadOnlyList`1<ITypeOwner> myMembers;
    private bool myCanMembersBeNull;
    [CompilerGeneratedAttribute]
private IClassLikeDeclaration <Declaration>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpGeneratorContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpElementFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasManagedResources>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnmanagedResources>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDisposableBaseClass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeInherited>k__BackingField;
    [NotNullAttribute]
public IClassLikeDeclaration Declaration { get; }
    [NotNullAttribute]
public ITypeElement ContainingType { get; }
    [NotNullAttribute]
public CSharpGeneratorContext Context { get; }
    [NotNullAttribute]
public CSharpElementFactory Factory { get; }
    [NotNullAttribute]
public PredefinedType PredefinedType { get; }
    public bool HasManagedResources { get; public set; }
    public bool HasUnmanagedResources { get; public set; }
    public bool HasDisposableBaseClass { get; public set; }
    public bool CanBeInherited { get; public set; }
    public bool HasOnlyManagedResources { get; }
    public bool HasOnlyUnmanagedResources { get; }
    public CSharpDisposePatternHelper(CSharpGeneratorContext context, ITypeElement containingType, IReadOnlyList`1<ITypeOwner> members, bool canMembersBeNull);
    [CompilerGeneratedAttribute]
public IClassLikeDeclaration get_Declaration();
    [CompilerGeneratedAttribute]
public ITypeElement get_ContainingType();
    [CompilerGeneratedAttribute]
public CSharpGeneratorContext get_Context();
    [CompilerGeneratedAttribute]
public CSharpElementFactory get_Factory();
    public PredefinedType get_PredefinedType();
    [CompilerGeneratedAttribute]
public bool get_HasManagedResources();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasManagedResources(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasUnmanagedResources();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasUnmanagedResources(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasDisposableBaseClass();
    [CompilerGeneratedAttribute]
public void set_HasDisposableBaseClass(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanBeInherited();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanBeInherited(bool value);
    public bool get_HasOnlyManagedResources();
    public bool get_HasOnlyUnmanagedResources();
    [CanBeNullAttribute]
public ICSharpStatement PopulateMembersDisposingBlock(IBlock disposingBlock, IBlock methodBody, bool isAsync);
    private void ApplyCodeStylesAndInspections(ICSharpStatement disposeStatement);
    public void AddDisposableInterface(IDeclaredType interface, bool reimplement);
    public static ICSharpStatement CreateDisposeStatement(IDeclaredElement member, bool canBeNull, bool isAsync, IMethod disposeMethod, ITreeNode context);
    private static ICSharpStatement CreateNullSafeStatement(bool canBeNull, IDeclaredElement valueToCheck, ICSharpExpression expression, CSharpElementFactory factory);
    [CompilerGeneratedAttribute]
private IDeclarationStatement <PopulateMembersDisposingBlock>g__FetchDisposeMethodsAndCreateHelperIfNeeded|38_0(<>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
private ICSharpStatement <PopulateMembersDisposingBlock>g__AddCastAndDisposeStatements|38_1(IDeclaredElement disposableElement, IBlock block, ICSharpStatement anchor, bool canBeNull, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
private string <PopulateMembersDisposingBlock>g__DiscardIfSupported|38_2(string template, <>c__DisplayClass38_0& );
}
[GeneratorBuilderAttribute("EqualityComparer", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpEqualityComparerBuilder : CSharpComparerBuilderBase {
    protected String[] ComparerTypePostfixes { get; }
    protected string GenericComparerTypeFqn { get; }
    public CSharpEqualityComparerBuilder(ILanguageManager manager);
    protected virtual String[] get_ComparerTypePostfixes();
    protected virtual string get_GenericComparerTypeFqn();
    protected virtual void BuildOptions(CSharpGeneratorContext context, ICollection`1<IGeneratorOption> options);
    protected virtual IClassMemberDeclaration CreateComparerType(CSharpGeneratorContext context, CSharpElementFactory factory, string comparerTypeName, IReadOnlyList`1<GeneratorComparisonMemberDescriptor> members);
    protected virtual void CreateComparerMembers(CSharpGeneratorContext context, CSharpElementFactory factory, IReadOnlyList`1<GeneratorComparisonMemberDescriptor> members);
    private static void ApplyCodeStyle(IMethodDeclaration methodDeclaration);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpEqualityHelper : object {
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IReadOnlyList`1<GeneratorComparisonMemberDescriptor> myMembers;
    [CompilerGeneratedAttribute]
private IDeclaredType <MemberSource>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpElementFactory <Factory>k__BackingField;
    private static string EqualityComparerCLRTypeName;
    private static string StringComparisonCLRTypeName;
    private static string StringComparerCLRTypeName;
    private static string NullableCLRTypeName;
    [NotNullAttribute]
public IDeclaredType MemberSource { get; }
    [NotNullAttribute]
public ITreeNode Context { get; }
    public bool HasMembers { get; }
    [NotNullAttribute]
public CSharpElementFactory Factory { get; }
    public CSharpEqualityHelper(ITreeNode context, IDeclaredType memberSource, IReadOnlyList`1<GeneratorComparisonMemberDescriptor> members);
    [CompilerGeneratedAttribute]
public IDeclaredType get_MemberSource();
    [CompilerGeneratedAttribute]
public ITreeNode get_Context();
    public bool get_HasMembers();
    [CompilerGeneratedAttribute]
public CSharpElementFactory get_Factory();
    private static DeclaredElementInstance GetTypeMember(IPsiModule module, string typeName, string memberName, IType parameterType);
    public IBlock GenerateNoMembersTypedEqualsBody(object comparand, bool emitBaseCall, bool emitChecks);
    public IBlock GenerateTypedEqualsBody(object comparand, bool emitBaseCall, bool emitChecks);
    public IBlock GenerateObjectEqualsBody(object comparand, TypeEqualityCheckMode mode);
    public IBlock GenerateComparatorEqualsBody(object lhsComparand, object rhsComparand);
    private void AppendMembersComparison(StringBuilder builder, List`1<object> args, object baseOperand, string lhsPrefix, string rhsPrefix);
    private static void AppendComparison(IPsiModule module, StringBuilder builder, List`1<object> args, ValueTuple`2<string, object> lhs, ValueTuple`2<string, object> rhs, IType commonComparandType, StringComparison stringComparison, bool canBeNull);
    [PureAttribute]
private static bool IsSuitableForEqualityOperator(IType type, bool isOrdinalStringComparison);
    [PureAttribute]
public static ICSharpExpression CreateEqualityCheckExpression(CSharpElementFactory factory, IPsiModule module, IType commonType, object lhsComparand, object rhsComparand);
    public IBlock GenerateNoMembersGetHashCodeBody(bool hasHashCodeOverride);
    public IBlock GenerateGetHashCodeBody(bool emitBaseCall, bool useSystemHashCode, object operand);
    [NotNullAttribute]
[PureAttribute]
private IBlock GenerateGetHashCodeBodyWithoutSystemHashCode(bool emitBaseCall, object operand);
    [NotNullAttribute]
[PureAttribute]
private string GenerateHashCodeAccumulatorVariableName();
    private void AppendHashMember(StringBuilder builder, string operandPrefix, GeneratorComparisonMemberDescriptor member, List`1<object> args, bool isSystemHashCodeArgument);
    [NotNullAttribute]
[PureAttribute]
private IBlock GenerateGetHashCodeBodyWithSystemHashCode(bool emitBaseCall, object operand);
    [CompilerGeneratedAttribute]
private string <GenerateObjectEqualsBody>g__GenerateTypeCheckTemplate|21_0(<>c__DisplayClass21_0& );
}
[GeneratorBuilderAttribute("EqualityMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpEqualityMembersBuilder : GeneratorEqualityMembersBuilderBase`1<CSharpGeneratorContext> {
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    public CSharpEqualityMembersBuilder(ILanguageManager manager);
    protected virtual IDeclaredType GetMemberSource(CSharpGeneratorContext context);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private void CreateTypedEquals(CSharpGeneratorContext context, CSharpEqualityHelper helper);
    private static void ApplyCodeStyle(IMethodDeclaration methodDeclaration);
    private void CreateObjectEquals(CSharpGeneratorContext context, CSharpEqualityHelper helper);
    private void CreateGetHashCode(CSharpGeneratorContext context, CSharpEqualityHelper helper);
    private void CreateEqualityOperators(CSharpGeneratorContext context, CSharpElementFactory factory);
    [CanBeNullAttribute]
private static IMethodDeclaration GetOrCreateMethodDeclaration(IGeneratorContext context, ITypeMember replaceMember, string replaceOptionKey, Func`2<IGeneratorContext, IMethodDeclaration> factory);
    private void SetDefaultBody(IDeclaration declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratorBuilderAttribute("Formatting", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpFormattingBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    private static string ChangeCurrentImplementationOption;
    private static string ImplementMembersOption;
    private static string UseNameOfOption;
    private static string AllowOverrideOption;
    private static string NoneSelectorValue;
    private static string UpToFormattableSelectorValue;
    private static string UpToSpanFormattableSelectorValue;
    private static string UpToUtf8SpanFormattableSelectorValue;
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void BuildOptions(CSharpGeneratorContext context, ICollection`1<IGeneratorOption> options);
    private static void PreselectAllMembersExceptNonCapturedPrimaryParameters(CSharpGeneratorContext context);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpFormattingMembersGenerator : object {
    [CompilerGeneratedAttribute]
private CSharpGeneratorContext <context>P;
    [CompilerGeneratedAttribute]
private Nullable`1<ExistingMemberConflictMode> <conflictMode>P;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITypeOwner> <members>P;
    [CompilerGeneratedAttribute]
private bool <useNameOf>P;
    [CompilerGeneratedAttribute]
private bool <makeOverridable>P;
    private static string ToStringMethodName;
    private static string TryFormatMethodName;
    [NullableAttribute("2")]
private ITypeElement myTypeElement;
    [NullableAttribute("2")]
private CSharpElementFactory myFactory;
    [NullableAttribute("2")]
private PredefinedType myPredefinedType;
    private ITypeElement TypeElement { get; }
    private CSharpElementFactory Factory { get; }
    private PredefinedType PredefinedType { get; }
    public CSharpFormattingMembersGenerator(CSharpGeneratorContext context, Nullable`1<ExistingMemberConflictMode> conflictMode, IReadOnlyList`1<ITypeOwner> members, bool useNameOf, bool makeOverridable);
    private ITypeElement get_TypeElement();
    private CSharpElementFactory get_Factory();
    private PredefinedType get_PredefinedType();
    [PureAttribute]
public static GenerationContextInformation CollectInformation(CSharpGeneratorContext context);
    public void ImplementIFormattable();
    public void ImplementISpanFormattable();
    public void ImplementIUtf8SpanFormattable();
    private void ImplementISpanFormattableInternal(IDeclaredType baseType, IDeclaredType destinationSpanElementType, IMethod tryWriteMethod, string writtenParameterDefaultName);
    [PureAttribute]
private ValueTuple`2<string, string> GenerateCharsWrittenNames(string charsWrittenName);
    private void EnsureImplementsInterface(IDeclaredType requiredInterface);
    [PureAttribute]
private static IMethod GetSpanFormattableTryWriteMethod(PredefinedType predefinedType);
    [PureAttribute]
private static IMethod GetUtf8SpanFormattableTryWriteMethod(PredefinedType predefinedType);
    [NullableContextAttribute("2")]
[PureAttribute]
private static IMethod GetTryWriteMethod(ITypeElement typeElement, bool isExtension, Predicate`1<IType> destinationElementTypeFilter);
    public void GenerateObjectToString();
    [NullableContextAttribute("2")]
private IMethodDeclaration GetOrCreateMethodDeclaration(ITypeMember replaceMember, Func`2<IGeneratorContext, IMethodDeclaration> factory);
    private ICSharpExpression GenerateToStringExpression(bool isInterpolation, string baseInvocation, bool startWithComma);
    private string GetFormatMemberName(ITypeOwner typeOwner);
    private static IOverridableMember FindObjectToString(ITypeElement type);
    [NullableContextAttribute("2")]
private static OverridableMemberInstance TryGetOverridableMemberInstance(ITypeElement baseTypeElement, string methodName);
    private void SetSingleExpressionToReturnPreservingArrowClause(ICSharpFunctionDeclaration functionDeclaration, ICSharpExpression expression);
    private void FinishMethodDeclarationGeneration(IMethodDeclaration declaration);
    [CompilerGeneratedAttribute]
private IMethodDeclaration <ImplementIFormattable>b__19_0(IGeneratorContext _);
    [CompilerGeneratedAttribute]
private IMethodDeclaration <GenerateObjectToString>b__28_0(IGeneratorContext _);
    [CompilerGeneratedAttribute]
private void <FinishMethodDeclarationGeneration>g__HandleMakeOverridable|35_0(IMethodDeclaration methodDeclaration);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpGenerateUtil : object {
    [PureAttribute]
public static bool CanMethodBeAsync(IMethod method, ITreeNode context);
    [NotNullAttribute]
public static ICSharpTypeMemberDeclaration CreateMemberDeclaration(IClassLikeDeclaration classDeclaration, ISubstitution substitution, IOverridableMember member, bool forDelegation, ISubstitution& newSubstitution);
    [NotNullAttribute]
public static ICSharpTypeMemberDeclaration CreateMemberDeclaration(IClassLikeDeclaration classDeclaration, ISubstitution substitution, IOverridableMember member, bool forDelegation, bool isWritable, ISubstitution& newSubstitution);
    [NotNullAttribute]
public static ICSharpTypeMemberDeclaration CreateEventHandlerDeclaration(IClassLikeDeclaration classDeclaration, IDelegate handlerDelegateType, ISubstitution substitution);
    [NotNullAttribute]
private static ICSharpTypeMemberDeclaration CreateMethod(CSharpElementFactory factory, IMethod method, ISubstitution substitution, IClassLikeDeclaration classDeclaration, ISubstitution& newSubstitution);
    private static void AddParameters(CSharpElementFactory factory, IParametersOwner parametersOwner, IClassLikeDeclaration classDeclaration, ISubstitution newSubstitution, ICSharpParametersOwnerDeclaration parametersOwnerDeclaration);
    [NotNullAttribute]
private static ICSharpTypeMemberDeclaration CreateOperator(CSharpElementFactory factory, IOperator operator, ISubstitution substitution, IClassLikeDeclaration classDeclaration, ISubstitution& newSubstitution);
    [NotNullAttribute]
private static string GetNameSafe(IParameter parameter);
    [NotNullAttribute]
private static ICSharpTypeMemberDeclaration CreateProperty(IClassLikeDeclaration classDeclaration, CSharpElementFactory factory, IProperty property, ISubstitution substitution, IAccessContext accessContext, bool isWritable, ISubstitution& newSubstitution);
    [NotNullAttribute]
public static IType MakeSafeType(IType type, ISubstitution substitution, ITreeNode context);
    [NotNullAttribute]
private static ICSharpTypeMemberDeclaration CreateEvent(IClassLikeDeclaration classDeclaration, CSharpElementFactory factory, IEvent member, ISubstitution substitution, ISubstitution& newSubstitution, bool forDelegation);
    private static void SetModifiers(ITypeMember typeMember, ICSharpModifiersOwnerDeclaration declaration, IClassLikeDeclaration targetClassDeclaration);
    [NotNullAttribute]
public static string CreateFieldName(IDeclaredElement declaredElement, IPsiSourceFile sourceFile);
    public static void CopyTypeParametersConstraints(ITypeParametersOwner from, IMethodDeclaration to, ISubstitution substitution);
    public static bool CopyTypeParametersConstraintsForOverrideOrExplicitImplementation(IMethod overriddenMethod, IMethodDeclaration targetMethodDeclaration, ISubstitution substitution, bool replaceExistingConstraints);
    [PureAttribute]
public static bool IsPartial(ITypeElement typeElement);
    [PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<IParameter> GetNonRecordPrimaryParametersNotPassedToBaseType(ITypeElement typeElement);
    [CompilerGeneratedAttribute]
internal static bool <SetModifiers>g__IsMemberFromUnsafeType|11_0(<>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static bool <SetModifiers>g__MemberSignatureContainsUnsafeTypes|11_1(<>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static bool <SetModifiers>g__TargetTypeDeclarationIsUnsafe|11_2(<>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static IReadOnlyList`1<ValueTuple`2<ITypeParameter, bool>> <CopyTypeParametersConstraintsForOverrideOrExplicitImplementation>g__GetTypeParametersToAddConstraints|14_0(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static void <CopyTypeParametersConstraintsForOverrideOrExplicitImplementation>g__ProcessType|14_2(IType type, <>c__DisplayClass14_0& , <>c__DisplayClass14_1& );
    [CompilerGeneratedAttribute]
internal static ITypeParameterConstraintsClause <CopyTypeParametersConstraintsForOverrideOrExplicitImplementation>g__CreateWhereClause|14_1(ITypeParameter typeParameter, string constraint, <>c__DisplayClass14_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpGeneratorContext : CSharpGeneratorContextBase {
    [NotNullAttribute]
private IClassLikeDeclaration myClassDeclaration;
    [NotNullAttribute]
private Dictionary`2<object, ITreeNode> myRegions;
    [NotNullAttribute]
public IClassLikeDeclaration ClassDeclaration { get; }
    public ITreeNode Root { get; }
    public IPsiModule PsiModule { get; }
    public ISolution Solution { get; }
    private CSharpGeneratorContext(string kind, IClassLikeDeclaration classDeclaration, ITreeNode anchor);
    [CanBeNullAttribute]
[PureAttribute]
public static CSharpGeneratorContext CreateContext(string kind, IPsiDocumentRangeView psiDocumentRangeView);
    [CanBeNullAttribute]
[PureAttribute]
public static CSharpGeneratorContext CreateContext(string kind, IClassLikeDeclaration classLikeDeclaration, ITreeNode anchor);
    public IClassLikeDeclaration get_ClassDeclaration();
    public virtual ITreeNode get_Root();
    public virtual IPsiModule get_PsiModule();
    public virtual ISolution get_Solution();
    protected virtual GeneratorWorkflowPointer CreatePointerCore();
    [NotNullAttribute]
public TClassMemberDeclaration PutMemberDeclaration(TClassMemberDeclaration declaration, IGeneratorElement inputElement, Func`2<TClassMemberDeclaration, IGeneratorElement> itemCreator, string regionName);
    private IClassMemberDeclaration PutMemberDeclarationImpl(IClassMemberDeclaration declaration, IGeneratorElement inputElement, string regionName);
    [NotNullAttribute]
private IClassMemberDeclaration PutMemberDeclarationAtDefaultLocation(IClassMemberDeclaration declaration);
    private static Pair`2<IStartRegion, IEndRegion> EnRegion(IDeclaration declaration, string regionName);
    [NotNullAttribute]
private IClassMemberDeclaration InsertWithRegions(IClassMemberDeclaration declaration, IGeneratorElement inputElement, string regionName);
    [NotNullAttribute]
[PureAttribute]
private static string GetRegionNameFor(object regionKey);
    [PureAttribute]
private bool IsAnchorInsideExistingRegionFor(object regionKey);
    [NotNullAttribute]
private static string PresentTypeForRegion(IType sourceType);
    [NotNullAttribute]
private IClassMemberDeclaration InsertNearOtherFromSameBaseType(IClassMemberDeclaration declaration, IGeneratorElement inputElement);
    [NotNullAttribute]
private static ICollection`1<OverridableMemberInstance> GetInheritanceChain(OverridableMemberInstance member);
    [NotNullAttribute]
private IClassMemberDeclaration InsertProperty(IPropertyDeclaration declaration, IGeneratorElement inputElement);
    [NotNullAttribute]
private IClassMemberDeclaration InsertConstructor(IConstructorDeclaration declaration);
    [NotNullAttribute]
private IClassMemberDeclaration InsertField(IFieldDeclaration declaration);
    [NotNullAttribute]
private IClassMemberDeclaration InsertEventHandler(IMethodDeclaration declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpGeneratorContextBase : GeneratorContextBase {
    private List`1<ITreeNodePointer`1<ITreeNode>> myCaretCandidates;
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITreeNode <Anchor>k__BackingField;
    public IPsiServices PsiServices { get; }
    [NullableAttribute("2")]
public ITreeNode Anchor { get; public set; }
    public PsiLanguageType Language { get; }
    protected CSharpGeneratorContextBase(string kind, ITreeNode anchor, IPsiServices psiServices);
    [CompilerGeneratedAttribute]
public IPsiServices get_PsiServices();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_Anchor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Anchor(ITreeNode value);
    public sealed virtual PsiLanguageType get_Language();
    public void PutCaretCandidate(ITreeNode caretCandidateNode);
    [NullableContextAttribute("2")]
public sealed virtual IGeneratorContextPointer CreatePointer();
    [NullableContextAttribute("2")]
protected abstract virtual GeneratorWorkflowPointer CreatePointerCore();
    public sealed virtual TreeTextRange GetSelectionTreeRange();
    private static CaretCandidate CreateCaretCandidate(ITreeNodePointer`1<ITreeNode> candidate);
    private static ITreeNode GetElementForCaretPosition(ITreeNode candidateNode);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static ITreeNode <GetElementForCaretPosition>g__GetElementFromCodeBody|17_0(CSharpCodeBody codeBody);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpGeneratorContextFactory : object {
    public sealed virtual IGeneratorContext TryCreate(string kind, IPsiDocumentRangeView psiDocumentRangeView);
    public sealed virtual IGeneratorContext TryCreate(string kind, ITreeNode targetContext, ITreeNode anchor);
    public sealed virtual IGeneratorContext TryCreate(string kind, IDeclaredElement contextElement);
}
[GeneratorBuilderAttribute("Implementations", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Overrides", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpImplementingMembersBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    public double Priority { get; }
    public virtual double get_Priority();
    protected virtual bool IsAvailable(CSharpGeneratorContext context);
    protected virtual void BuildOptions(CSharpGeneratorContext context, ICollection`1<IGeneratorOption> options);
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    [PureAttribute]
private static bool HasTaskReturningMethods(IGeneratorContext context);
    [PureAttribute]
private static bool HasInterfaceMembers(CSharpGeneratorContext context, bool excludeImplicitTypedEquals);
    [PureAttribute]
private static bool HasInstanceMembersToImplement(IGeneratorContext context);
    [PureAttribute]
private static bool HasGetOnlyInterfaceProperties(IGeneratorContext context);
    private static void GenerateInheritor(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IOverridableMember> inputElement, IOverridableMember overridableMember);
    [CanBeNullAttribute]
private static IClassMemberDeclaration CreateImplementation(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IOverridableMember> inputElement, IOverridableMember baseMember);
    private static void SetAccessorsRights(IAccessorOwnerDeclaration accessorOwner, AccessRights accessRights, IOverridableMember member);
    [PureAttribute]
private static bool IsTypedEqualsImplementationInRecord(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IOverridableMember> element);
    [PureAttribute]
private static MemberImplementation ComputeMemberImplementation(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IOverridableMember> element);
    [PureAttribute]
private static MemberImplementation ComputeMemberImplementationWithRespectToOtherMember(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IOverridableMember> inputElement, OverridableMemberInstance otherMemberInstance);
    [PureAttribute]
private static bool IsAutoOrCanBeImplementedAsAuto(IProperty property);
    [PureAttribute]
private static bool IsBetterToImplementImplicitly(GeneratorDeclaredElement`1<IOverridableMember> element, GeneratorDeclaredElement`1<IOverridableMember> otherElement, ICSharpTypeConversionRule conversionRule);
}
[GeneratorBuilderAttribute("Implementations", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Overrides", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInheritedBodyBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    public double Priority { get; }
    public CSharpInheritedBodyBuilder(ILanguageManager languageManager);
    public virtual double get_Priority();
    protected virtual void BuildOptions(CSharpGeneratorContext context, ICollection`1<IGeneratorOption> options);
    [PureAttribute]
private static bool CanBeAutomaticProperty(CSharpGeneratorContext context, IPropertyDeclaration propertyDeclaration, GeneratorDeclaredElement element);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private static void ConvertToAutoProperty(CSharpGeneratorContext context, IPropertyDeclaration property, IProperty inheritedProperty);
    private void EnsureBody(ICSharpFunctionDeclaration functionDeclaration, CSharpGeneratorContext context, GeneratorOverrideDeclarationElement outputElement);
    private bool BuildDelegationBody(CSharpGeneratorContext context, GeneratorOverrideDeclarationElement outputElement, IDeclaration declaration);
    private void EnsureBody(IAccessorDeclaration accessorDeclaration, CSharpGeneratorContext context, GeneratorOverrideDeclarationElement outputElement);
    [PureAttribute]
private static bool ShouldCreateBackingFieldForAccessor(GeneratorOverrideDeclarationElement outputElement, IAccessorDeclaration accessorDeclaration, CSharpGeneratorContext context);
    [NotNullAttribute]
private static IField GetOrCreateFieldFor(IAccessorDeclaration declaration, GeneratorOverrideDeclarationElement outputElement, CSharpGeneratorContext context);
    [CompilerGeneratedAttribute]
internal static bool <BuildOptions>g__HasProperties|4_0(CSharpGeneratorContext context);
}
[GeneratorElementProviderAttribute("RelationalComparer", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInstanceDataMemberOfRelationalTypeProvider : CSharpInstanceDataMemberProviderBase {
    [NullableContextAttribute("1")]
protected virtual bool MemberFilter(ITypeOwner declaredElement, ISubstitution substitution, ITreeNode context);
}
[GeneratorElementProviderAttribute("Deconstructor", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorElementProviderAttribute("EqualityComparer", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInstanceDataMemberProvider : CSharpInstanceDataMemberProviderBase {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInstanceDataMemberProviderBase : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public double Priority { get; }
    public virtual double get_Priority();
    public virtual void Populate(CSharpGeneratorContext context);
    protected virtual bool MemberFilter(ITypeOwner declaredElement, ISubstitution substitution, ITreeNode context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratorElementProviderAttribute("EqualityMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInstanceEventProviderBase : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public virtual void Populate(CSharpGeneratorContext context);
}
[GeneratorElementProviderAttribute("DisposePattern", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInstanceFieldOfDisposableTypeProvider : CSharpInstanceFieldProviderBase {
    protected virtual bool FieldFilter(IField field, ISubstitution substitution, ITreeNode context);
    [PureAttribute]
public static bool MemberTypeFilter(IType memberType, ITreeNode context);
}
[GeneratorElementProviderAttribute("RelationalMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInstanceFieldOfRelationalTypeProvider : CSharpInstanceFieldProviderBase {
    protected virtual bool FieldFilter(IField field, ISubstitution substitution, ITreeNode context);
}
[GeneratorElementProviderAttribute("Formatting", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorElementProviderAttribute("EqualityMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInstanceFieldProvider : CSharpInstanceFieldProviderBase {
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpInstanceFieldProviderBase : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public virtual void Populate(CSharpGeneratorContext context);
    protected virtual bool FieldFilter(IField field, ISubstitution substitution, ITreeNode context);
}
[GeneratorElementProviderAttribute("Constructor", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpMemberToInitializeProvider : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public double Priority { get; }
    public virtual double get_Priority();
    public virtual void Populate(CSharpGeneratorContext context);
    [PureAttribute]
private static bool HasNonConstantInitializer(ITypeOwner typeOwner);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpNotifyPropertyChangedUtil : object {
    [NotNullAttribute]
public static ICSharpStatement EmitNotifyCall(IMethod notifyMethod, IPropertyDeclaration propertyDeclaration, IProperty propertyToNotify, object backingField);
    private static bool IsCallerMemberNameParameter(IParameter parameter);
    public static void EmitDependentNotificationsIfPossible(IMethod notifyMethod, ICSharpStatement notificationStatement, IPropertyDeclaration propertyDeclaration, ITypeMember[] propertyOrFields);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpOverridesUtil : OverridesUtil {
    private static void AddParameter(StringBuilder sb, ICollection`1<object> parameters, object item);
    private static void AddTypeParameters(StringBuilder pattern, IMethod method, ICollection`1<object> formatParameters, ITypeElement inheritor);
    private static void CollectProhibitedNames(ICollection`1<string> prohibitedNames, ITypeElement inheritor);
    public static bool CanImplementImplicitly(OverridableMemberInstance overridableMember);
    public static IClassMemberDeclaration OverridableMemberDeclaration(IOverridableMember typeMember, ISubstitution substitution, IClassLikeDeclaration inheritorDeclaration, bool addConstraints, bool preserveComments);
    public static void CallGenericMethod(IMethodDeclaration getEnumeratorDeclaration, OverridableMemberInstance genericMethodInstance);
    public static ITreeNode[] AddCallToBase(ITypeMemberDeclaration declaration, ISubstitution substitution);
    public static AccessRights GetAccessRights(IOverridableMember superMember, IPsiModule module);
    public static bool CanCallGenericMethod(OverridableMemberInstance moreGenericInstance, OverridableMemberInstance lessGenericInstance, ICSharpTypeConversionRule conversionRule);
    [CompilerGeneratedAttribute]
internal static bool <GetAccessRights>g__InternalsAreVisibleToTargetModule|8_0(<>c__DisplayClass8_0& );
}
[GeneratorBuilderAttribute("Implementations", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Overrides", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpOverridingMembersBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    protected virtual bool IsAvailable(CSharpGeneratorContext context);
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void BuildOptions(CSharpGeneratorContext context, ICollection`1<IGeneratorOption> options);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private static bool HasTaskReturningMethods(CSharpGeneratorContext context);
    [NotNullAttribute]
private static List`1<ValueTuple`2<GeneratorDeclaredElement`1<IOverridableMember>, IOverridableMember>> GetMembersToOverride(CSharpGeneratorContext context);
    private static void FilterConflictingMembers(List`1<ValueTuple`2<GeneratorDeclaredElement`1<IOverridableMember>, IOverridableMember>> abstractMembers);
    private static void GenerateInheritor(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IOverridableMember> inputElement, IOverridableMember overridableMember);
    [NotNullAttribute]
private static IClassMemberDeclaration CreateImplementation(CSharpGeneratorContext context, GeneratorDeclaredElement`1<IOverridableMember> inputElement, IOverridableMember baseMember);
    private static void SetAccessorsRights(IAccessorOwnerDeclaration accessorOwnerDeclaration, IOverridableMember member, AccessRights accessRights);
}
[GeneratorBuilderAttribute("PartialMethods", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpPartialMethodsBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    public CSharpPartialMethodsBuilder(ILanguageManager manager);
    protected virtual bool IsAvailable(CSharpGeneratorContext context);
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
}
[GeneratorElementProviderAttribute("PartialMethods", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpPartialMethodsProvider : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public virtual void Populate(CSharpGeneratorContext context);
}
[GeneratorElementProviderAttribute("DisposePattern", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpPrimaryConstructorParameterDisposableTypeProvider : CSharpPrimaryConstructorParametersProviderBase {
    [NullableContextAttribute("1")]
protected virtual bool ParameterFilter(IParameter parameter, ITreeNode context);
}
[GeneratorElementProviderAttribute("Formatting", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpPrimaryConstructorParametersProvider : CSharpPrimaryConstructorParametersProviderBase {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpPrimaryConstructorParametersProviderBase : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public virtual void Populate(CSharpGeneratorContext context);
    protected virtual bool ParameterFilter(IParameter parameter, ITreeNode context);
}
[GeneratorBuilderAttribute("Properties", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("ReadProperties", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpPropertiesBuilder : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    private static string NotifyChangesOptionTitle;
    private static string NotifyChangesOptionTitleFormat;
    private static CSharpPropertiesBuilder();
    protected virtual void BuildOptions(CSharpGeneratorContext context, ICollection`1<IGeneratorOption> options);
    [CanBeNullAttribute]
private static IGeneratorOption GetNotifyOption(CSharpGeneratorContext context, IClass classType);
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    [PureAttribute]
private static bool IsReadOnlyFieldLike(ITypeOwner fieldLike);
    private static void EmitNotifyPropertyChange(CSharpGeneratorContext context, CSharpElementFactory factory, IAccessorDeclaration setterDeclaration, ICSharpStatement assignmentStatement, ITypeOwner fieldLike, string notifyOption);
}
[GeneratorElementProviderAttribute("Properties", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorElementProviderAttribute("ReadProperties", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpPropertiesFieldProvider : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public virtual void Populate(CSharpGeneratorContext context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpPropertiesFieldProvider/<GetFields>d__1")]
[NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<IField> GetFields(ITypeElement typeElement, HashSet`1<string> usedFieldsNames);
    [NotNullAttribute]
private static ICSharpTreeNode GetResolveContext(IClassLikeDeclaration declaration);
}
[GeneratorElementProviderAttribute("Formatting", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpReadablePropertyProvider : GeneratorProviderBase`1<CSharpGeneratorContext> {
    public double Priority { get; }
    public virtual double get_Priority();
    public virtual void Populate(CSharpGeneratorContext context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpRelationalCompareHelper : object {
    [NotNullAttribute]
private ITreeNode myContext;
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IReadOnlyList`1<GeneratorComparisonMemberDescriptor> myMembers;
    [CompilerGeneratedAttribute]
private IDeclaredType <MemberSource>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpElementFactory <Factory>k__BackingField;
    [NotNullAttribute]
public IDeclaredType MemberSource { get; }
    [NotNullAttribute]
public CSharpElementFactory Factory { get; }
    public bool HasMembers { get; }
    public CSharpRelationalCompareHelper(ITreeNode context, IDeclaredType memberSource, IReadOnlyList`1<GeneratorComparisonMemberDescriptor> members);
    [CompilerGeneratedAttribute]
public IDeclaredType get_MemberSource();
    [CompilerGeneratedAttribute]
public CSharpElementFactory get_Factory();
    public bool get_HasMembers();
    [NotNullAttribute]
[PureAttribute]
public IBlock GenerateTypedCompareToBody(IParameter comparand, bool emitBaseCall);
    [NotNullAttribute]
[PureAttribute]
public IBlock GenerateObjectCompareToBody(IParameter comparand);
    [NotNullAttribute]
[PureAttribute]
public IBlock GenerateComparisonOperatorBody(IParameter left, IParameter right, string operatorSign);
    [NotNullAttribute]
[PureAttribute]
public IBlock GenerateComparatorCompareBody(IParameter left, IParameter right);
    private void EmitBaseCall(IClass memberSource, StringBuilder builder, object comparandIndex);
    private void AppendMembersComparison(StringBuilder builder, List`1<object> arguments, string lhsPrefix, string rhsPrefix);
    private void EmitTypeCheck(StringBuilder builder, List`1<object> arguments, object comparandIndex, object typeIndex);
    [NotNullAttribute]
[PureAttribute]
private string GenerateComparisonVariableName(IDeclaredElement member, Func`2<string, bool> isNameUnique);
    [CanBeNullAttribute]
[PureAttribute]
private IDeclaredType GetExplicitCompareToImplementationType(IType type);
    [NotNullAttribute]
[PureAttribute]
private DeclaredElementInstance GetTypeMember(IClrTypeName typeName, string memberName, IType parameterType);
}
[GeneratorBuilderAttribute("RelationalComparer", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpRelationalComparerBuilder : CSharpComparerBuilderBase {
    protected String[] ComparerTypePostfixes { get; }
    protected string GenericComparerTypeFqn { get; }
    public CSharpRelationalComparerBuilder(ILanguageManager manager);
    protected virtual String[] get_ComparerTypePostfixes();
    protected virtual string get_GenericComparerTypeFqn();
    protected virtual IClassMemberDeclaration CreateComparerType(CSharpGeneratorContext context, CSharpElementFactory factory, string comparerTypeName, IReadOnlyList`1<GeneratorComparisonMemberDescriptor> members);
    protected virtual void CreateComparerMembers(CSharpGeneratorContext context, CSharpElementFactory factory, IReadOnlyList`1<GeneratorComparisonMemberDescriptor> members);
}
[GeneratorBuilderAttribute("RelationalMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpRelationalMembersBuilder : GeneratorRelationalMembersBuilderBase`1<CSharpGeneratorContext> {
    private static string RegionName;
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    public CSharpRelationalMembersBuilder(ILanguageManager manager);
    protected virtual IDeclaredType GetMemberSource(CSharpGeneratorContext context);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private void CreateTypedCompareTo(CSharpGeneratorContext context, CSharpRelationalCompareHelper helper);
    private static void CreateObjectCompareTo(CSharpGeneratorContext context, CSharpRelationalCompareHelper helper);
    private void CreateRelationalOperators(CSharpGeneratorContext context, CSharpRelationalCompareHelper helper);
    private void CreateRelationalOperator(CSharpGeneratorContext context, CSharpRelationalCompareHelper helper, string operatorSign);
    [CanBeNullAttribute]
private static IMethodDeclaration GetOrCreateCompareToDeclaration(CSharpGeneratorContext context, CSharpRelationalCompareHelper helper, bool isTypedParameter);
    private static void AddIComparableSuperInterface(CSharpGeneratorContext context, ITypeElement typeElement, bool isGeneric);
    private static bool IsSuperTypeImplementsIComparable(CSharpGeneratorContext context, bool isTypedParameter);
    [CanBeNullAttribute]
private static IMethod GetBaseCompareToObjectMethod(CSharpGeneratorContext context);
}
[GeneratorBuilderAttribute("Constructor", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Properties", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("ReadProperties", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Implementations", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Overrides", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Delegating", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("Formatting", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("EqualityMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("RelationalMembers", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
[GeneratorBuilderAttribute("DisposePattern", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.CSharpXmlDocumentationInitializer : GeneratorBuilderBase`1<CSharpGeneratorContext> {
    public double Priority { get; }
    public virtual double get_Priority();
    protected virtual bool HasProcessableElements(CSharpGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(CSharpGeneratorContext context, IProgressIndicator progress);
    private static void CopyCommentsFor(GeneratorDeclarationElement declarationElement);
    private static bool CopyComments(IDeclaredElement sourceElement, IDeclaration generatedDeclaration);
    private static void CreateCommentsForOperator(ISignOperatorDeclaration generatedDeclaration);
    [CanBeNullAttribute]
[PureAttribute]
private static string GetXmlCommentFormatForOperator(TokenNodeType operatorTokenType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.InstanceDataMemberFilter : SimpleSymbolFilter {
    private ITreeNode myUsageContext;
    private IAccessContext myAccessContext;
    public ResolveErrorType ErrorType { get; }
    public InstanceDataMemberFilter(ITreeNode usageContext, IAccessContext accessContext);
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public static bool CheckField(IField field, ISubstitution substitution, ITreeNode usageContext);
    public static bool CheckProperty(IProperty property, ISubstitution substitution, ITreeNode usageContext, IAccessContext accessContext);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.Generate.MemberBody.CSharpDelegatingMemberBodyProvider : object {
    [NotNullAttribute]
[PureAttribute]
public static IBlock CreateDelegatingBody(IDeclaration declaration, IClrDeclaredElement qualifier, IOverridableMember delegateTo);
    [NotNullAttribute]
[PureAttribute]
private static IBlock CreateDelegatingBody(IDeclaration declaration, object qualifier, IOverridableMember delegateTo, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
private static IBlock CreateEventAccessorBody(IAccessorDeclaration declaration, object qualifier, IOverridableMember delegateTo, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
private static IBlock CreatePropertyAccessorBody(IAccessorDeclaration declaration, object qualifier, IOverridableMember delegateTo, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
private static IBlock CreateIndexerAccessorBody(IAccessorDeclaration declaration, object qualifier, IOverridableMember delegateTo, ISubstitution substitution);
    private static void AddArguments(IParametersOwnerDeclaration declaration, ICSharpArgumentsOwner argumentsOwner);
    [NotNullAttribute]
[PureAttribute]
private static IBlock CreateMethodBody(IMethodDeclaration declaration, object qualifier, IOverridableMember delegateTo, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
private static IBlock CreateSignOperatorBody(ISignOperatorDeclaration declaration);
    [NotNullAttribute]
[PureAttribute]
private static IBlock CreateConversionOperatorBody(IConversionOperatorDeclaration declaration);
    [NotNullAttribute]
[PureAttribute]
private static IReferenceExpression CreateAndBindReference(IDeclaration declaration, object qualifier, IOverridableMember delegateTo, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
private static IElementAccessExpression CreateAndBindIndexerExpression(IAccessorDeclaration declaration, object qualifier, IOverridableMember delegateTo, ISubstitution substitution);
    private static void BindReference(IDeclaration declaration, object qualifier, IOverridableMember delegateTo, ISubstitution substitution, IReference reference);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.MemberBody.CSharpMemberBodyOperations : object {
    public sealed virtual DocumentRange GetBodyRange(IDeclaration declaration);
    public sealed virtual DocumentRange SetBodyToDefault(IDeclaration declaration);
    public sealed virtual DocumentRange SetBody(IDeclaration declaration, MethodImplementationKind implementationKind);
    public sealed virtual DocumentRange SetDelegatingCall(ITypeMemberDeclaration declaration, IClrDeclaredElement qualifier, IOverridableMember delegateTo);
    public sealed virtual void RemoveBody(IDeclaration declaration);
    public sealed virtual DocumentRange SetParameterlessMethodCall(IDeclaration declaration, IMethod methodToCall);
    private DocumentRange SetBody(ICSharpDeclaration declaration, IBlock bodyBlock);
    private DocumentRange SetBody(IAccessorOwnerDeclaration accessorOwnerDeclaration, MethodImplementationKind implementationKind);
    private DocumentRange SetBody(ICSharpFunctionDeclaration declaration, MethodImplementationKind implementationKind);
    private DocumentRange SetBody(ILocalFunctionDeclaration declaration, MethodImplementationKind implementationKind);
    [NotNullAttribute]
private static IBlock CreateMethodBody(ICSharpDeclaration declaration, MethodImplementationKind implementationKind);
    private static void FormatBody(IBlock body);
    private static DocumentRange GetBodyRange(IClassMemberDeclaration ownerDeclaration, IBlock body);
    [PureAttribute]
private static DocumentRange GetBodyRange(CSharpCodeBody codeBody);
    [PureAttribute]
private static DocumentRange GetBodyRange(IBlock body);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.MemberBody.CSharpPropertyBodyUtil : object {
    [NotNullAttribute]
private CSharpMemberBodyOperations myBodyOperations;
    public CSharpPropertyBodyUtil(CSharpMemberBodyOperations bodyOperations);
    public DocumentRange SetAutoPropertyBody(IAccessorDeclaration declaration);
    public DocumentRange SetAutoPropertyBody(IAccessorOwnerDeclaration declaration);
    private static void EnsureAccessor(IAccessorOwnerDeclaration declaration, AccessorKind kind);
    public DocumentRange SetDefaultBody(IAccessorDeclaration declaration);
    public DocumentRange SetDefaultBody(IAccessorOwnerDeclaration declaration);
    public DocumentRange SetBackingFieldBody(IAccessorDeclaration declaration, string backingFieldName);
    public DocumentRange SetBackingFieldBody(IAccessorOwnerDeclaration declaration, string backingFieldName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Generate.MemberBody.CSharpPropertyBodyUtil/<GetBackingFieldCandidates>d__9")]
public IEnumerable`1<string> GetBackingFieldCandidates(IPropertyDeclaration propertyDeclaration);
    public string SuggestBackingFieldName(IPropertyDeclaration propertyDeclaration);
    public bool IsBackingFieldAvailable(IPropertyDeclaration propertyDeclaration, string fieldName);
    public void CreateBackingField(IPropertyDeclaration propertyDeclaration, string backingFieldName);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Generate.MemberBody.CSharpReturnStatementMemberBodyProvider : object {
    [CanBeNullAttribute]
public static IBlock CreateBody(ICSharpDeclaration declaration);
    [NotNullAttribute]
private static IBlock CreateBodyForOrdinalDeclaration(ICSharpDeclaration declaration);
    [NotNullAttribute]
[PureAttribute]
private static IBlock CreateReturnStatement(ICSharpDeclaration declaration);
    [NotNullAttribute]
[PureAttribute]
private static IBlock ThrowNotImplementedException(CSharpElementFactory factory, PredefinedType predefinedType);
    [CanBeNullAttribute]
[PureAttribute]
private static IBlock ReturnDefaultValue(IType returnType, CSharpElementFactory factory, ICSharpDeclaration context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.GeneratorTypePatternElement : GeneratorDeclaredElement`1<ITypeElement> {
    [CompilerGeneratedAttribute]
private IDeclaredType <Type>k__BackingField;
    [NotNullAttribute]
public IDeclaredType Type { get; }
    [NotNullAttribute]
public DeclaredElementInstance`1<ITypeElement> SuperTypeElementInstance { get; }
    public GeneratorTypePatternElement(IDeclaredType type, ITypeElement declaredElement, IDeclaredType superType);
    [CompilerGeneratedAttribute]
public IDeclaredType get_Type();
    public DeclaredElementInstance`1<ITypeElement> get_SuperTypeElementInstance();
}
internal interface JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.IPatternAlternativesInfo`1 {
    [CanBeNullAttribute]
public TBranchNode LastGuarded { get; }
    [CanBeNullAttribute]
public TBranchNode Unguarded { get; }
    public abstract virtual TBranchNode get_LastGuarded();
    public abstract virtual TBranchNode get_Unguarded();
    public abstract virtual void RemoveUnguarded();
}
internal interface JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.IPatternMatchingBuilder`1 {
    [NotNullAttribute]
public abstract virtual TAlternativeNode AppendTypePatternAlternative(IDeclaredType type);
    public abstract virtual void Skip(TAlternativeNode alternativeNode);
    [NotNullAttribute]
public abstract virtual TAlternativeNode AppendWildcardPatternAlternative(TAlternativeNode anchor);
    [NotNullAttribute]
public abstract virtual TAlternativeNode AppendNullPatternAlternative(TAlternativeNode anchor);
}
internal interface JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.IPatternMatchingInfo`1 {
    [NotNullAttribute]
public IPatternAlternativesInfo`1<TAlternativeNode> NullPatternAlternatives { get; }
    [NotNullAttribute]
public IPatternAlternativesInfo`1<TAlternativeNode> WildcardAlternatives { get; }
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IPatternAlternativesInfo`1<TAlternativeNode> TryGetAlternativesFor(IDeclaredType type);
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<IDeclaredType> EnumerateHandledTypes();
    public abstract virtual IPatternAlternativesInfo`1<TAlternativeNode> get_NullPatternAlternatives();
    public abstract virtual IPatternAlternativesInfo`1<TAlternativeNode> get_WildcardAlternatives();
    [PureAttribute]
public abstract virtual bool IsEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.PatternMatchingGeneratorContext : CSharpGeneratorContextBase {
    [CompilerGeneratedAttribute]
private ITreeNode <Root>k__BackingField;
    public ITreeNode Root { get; }
    public ISolution Solution { get; }
    public IPsiModule PsiModule { get; }
    public PatternMatchingGeneratorContext(ITreeNode root, ITreeNode anchor);
    [CompilerGeneratedAttribute]
public virtual ITreeNode get_Root();
    public virtual ISolution get_Solution();
    public virtual IPsiModule get_PsiModule();
    protected virtual GeneratorWorkflowPointer CreatePointerCore();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.PatternMatchingHelper : object {
    public static string GenerationKind;
    private static string NullCaseOption;
    private static string WildcardCaseOption;
    private static string GeneratePatternVariable;
    [NotNullAttribute]
[PureAttribute]
public static IGeneratorWorkflow CreateWorkflow(ITreeNode patternMatchingConstruct, ITextControl textControl);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static Action`1<IGeneratorContext> GetContextInitializer(ISwitchStatement switchStatement, IProgressIndicator progress);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static Action`1<IGeneratorContext> GetContextInitializer(ISwitchExpression switchExpression, IProgressIndicator progress);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private static Action`1<IGeneratorContext> GetContextInitializer(ITreeNode patternMatchingConstruct, IDeclaredType governingType, IProgressIndicator progress);
    [ExtensionAttribute]
[PureAttribute]
internal static bool IsNullCaseSelected(PatternMatchingGeneratorContext context);
    [ExtensionAttribute]
[PureAttribute]
internal static bool IsDefaultCaseSelected(PatternMatchingGeneratorContext context);
    [ExtensionAttribute]
internal static void BuildOptions(PatternMatchingGeneratorContext context, ICollection`1<IGeneratorOption> options);
    [ExtensionAttribute]
[PureAttribute]
internal static bool ShouldGenerateVariable(PatternMatchingGeneratorContext context);
    private static void SetInitialSelection(IReadOnlyList`1<GeneratorTypePatternElement> providedElements, IPatternMatchingInfo`1<ITreeNode> switchStatementInfo, IGeneratorContext context, bool selectAll);
    [CompilerGeneratedAttribute]
internal static bool <SetInitialSelection>g__HasUnguardedPatternFor|12_0(IDeclaredType type, <>c__DisplayClass12_0& );
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.SwitchCaseLabelsInfo : object {
    [CompilerGeneratedAttribute]
private ISwitchCaseLabel <LastGuarded>k__BackingField;
    [CompilerGeneratedAttribute]
private ISwitchCaseLabel <Unguarded>k__BackingField;
    public ISwitchCaseLabel LastGuarded { get; private set; }
    public ISwitchCaseLabel Unguarded { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual ISwitchCaseLabel get_LastGuarded();
    [CompilerGeneratedAttribute]
private void set_LastGuarded(ISwitchCaseLabel value);
    [CompilerGeneratedAttribute]
public sealed virtual ISwitchCaseLabel get_Unguarded();
    [CompilerGeneratedAttribute]
private void set_Unguarded(ISwitchCaseLabel value);
    public void AddCaseLabel(ISwitchCaseLabel caseLabel);
    public sealed virtual void RemoveUnguarded();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.SwitchExpressionArmsInfo : object {
    [CompilerGeneratedAttribute]
private ISwitchExpressionArm <LastGuarded>k__BackingField;
    [CompilerGeneratedAttribute]
private ISwitchExpressionArm <Unguarded>k__BackingField;
    public ISwitchExpressionArm LastGuarded { get; private set; }
    public ISwitchExpressionArm Unguarded { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual ISwitchExpressionArm get_LastGuarded();
    [CompilerGeneratedAttribute]
private void set_LastGuarded(ISwitchExpressionArm value);
    [CompilerGeneratedAttribute]
public sealed virtual ISwitchExpressionArm get_Unguarded();
    [CompilerGeneratedAttribute]
private void set_Unguarded(ISwitchExpressionArm value);
    public void AddArm(ISwitchExpressionArm arm);
    public sealed virtual void RemoveUnguarded();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.SwitchExpressionBuilder : object {
    [NotNullAttribute]
private ISwitchExpression mySwitchExpression;
    private MethodImplementationKind myImplementationKind;
    [NotNullAttribute]
private CSharpElementFactory myFactory;
    [CanBeNullAttribute]
private VariableNamesGenerator myVariableNamesGenerator;
    [CanBeNullAttribute]
private ISwitchExpressionArm myAnchor;
    [CanBeNullAttribute]
private ICSharpExpression myDefaultValue;
    public SwitchExpressionBuilder(ISwitchExpression switchExpression, bool shouldGenerateVariable, MethodImplementationKind implementationKind);
    public sealed virtual void Skip(ISwitchExpressionArm alternativeNode);
    public sealed virtual ISwitchExpressionArm AppendTypePatternAlternative(IDeclaredType type);
    public sealed virtual ISwitchExpressionArm AppendNullPatternAlternative(ISwitchExpressionArm anchor);
    public sealed virtual ISwitchExpressionArm AppendWildcardPatternAlternative(ISwitchExpressionArm anchor);
    [NotNullAttribute]
[PureAttribute]
private ICSharpExpression CreateDefaultValue();
    [NotNullAttribute]
[PureAttribute]
private IThrowExpression CreateThrowArgumentOutOfRangeExpression();
    [CanBeNullAttribute]
[PureAttribute]
private static ICSharpExpression GetOperandThroughCastOrParenthesis(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.SwitchExpressionInfo : object {
    [NotNullAttribute]
private ISwitchExpression mySwitchExpression;
    [NotNullAttribute]
private Dictionary`2<IDeclaredType, SwitchExpressionArmsInfo> myTypePatternArms;
    [CanBeNullAttribute]
private IDeclaredType myGoverningType;
    [NotNullAttribute]
private SwitchExpressionArmsInfo myNullPatternAlternatives;
    [NotNullAttribute]
private SwitchExpressionArmsInfo myDefaultPatternAlternatives;
    public IPatternAlternativesInfo`1<ISwitchExpressionArm> NullPatternAlternatives { get; }
    public IPatternAlternativesInfo`1<ISwitchExpressionArm> WildcardAlternatives { get; }
    public SwitchExpressionInfo(ISwitchExpression switchExpression);
    public sealed virtual IPatternAlternativesInfo`1<ISwitchExpressionArm> get_NullPatternAlternatives();
    public sealed virtual IPatternAlternativesInfo`1<ISwitchExpressionArm> get_WildcardAlternatives();
    public sealed virtual IPatternAlternativesInfo`1<ISwitchExpressionArm> TryGetAlternativesFor(IDeclaredType type);
    public sealed virtual IEnumerable`1<IDeclaredType> EnumerateHandledTypes();
    public sealed virtual bool IsEmpty();
    [NotNullAttribute]
public static SwitchExpressionInfo Build(ISwitchExpression switchExpression);
    private void AddArm(ISwitchExpressionArm arm);
    private void AddTypePatternArm(IDeclaredType type, ISwitchExpressionArm arm);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.SwitchStatementBuilder : object {
    [NotNullAttribute]
private ISwitchStatement mySwitchStatement;
    [NotNullAttribute]
private CSharpElementFactory myFactory;
    [CanBeNullAttribute]
private VariableNamesGenerator myVariableNamesGenerator;
    [CanBeNullAttribute]
private ITreeNode myAnchor;
    public SwitchStatementBuilder(ISwitchStatement switchStatement, bool shouldGenerateVariable);
    public sealed virtual void Skip(ISwitchCaseLabel alternativeNode);
    public sealed virtual ISwitchCaseLabel AppendTypePatternAlternative(IDeclaredType type);
    public sealed virtual ISwitchCaseLabel AppendNullPatternAlternative(ISwitchCaseLabel anchor);
    public sealed virtual ISwitchCaseLabel AppendWildcardPatternAlternative(ISwitchCaseLabel anchor);
    [NotNullAttribute]
[PureAttribute]
private ISwitchSection CreateSwitchSection(string caseTemplate);
    [CanBeNullAttribute]
[PureAttribute]
private static ITreeNode GetAnchorFor(ISwitchCaseLabel caseLabel);
    [NotNullAttribute]
[PureAttribute]
private ISwitchSection CreateSwitchSection(IDeclaredType type, string variableName);
    private ISwitchCaseLabel AppendSwitchSection(ISwitchSection newSection);
    [PureAttribute]
private static bool HasDependentPatternsInParentSection(ISwitchSection newSection, ISwitchSection parentSection, ISwitchCaseLabel inclusiveSeparator);
    private void SplitSection(ISwitchSection section, ISwitchCaseLabel inclusiveSeparator);
    [NotNullAttribute]
[PureAttribute]
private IThrowStatement CreateThrowStatement();
    [CanBeNullAttribute]
[PureAttribute]
private static ICSharpExpression GetOperandThroughCastOrParenthesis(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.SwitchStatementInfo : object {
    [NotNullAttribute]
private ISwitchStatement mySwitchStatement;
    [NotNullAttribute]
private Dictionary`2<IDeclaredType, SwitchCaseLabelsInfo> myTypePatternCases;
    [CanBeNullAttribute]
private IDeclaredType myGoverningType;
    [NotNullAttribute]
private SwitchCaseLabelsInfo myNullPatternAlternatives;
    [NotNullAttribute]
private SwitchCaseLabelsInfo myDefaultPatternAlternatives;
    public IPatternAlternativesInfo`1<ISwitchCaseLabel> NullPatternAlternatives { get; }
    public IPatternAlternativesInfo`1<ISwitchCaseLabel> WildcardAlternatives { get; }
    private SwitchStatementInfo(ISwitchStatement switchStatement);
    [NotNullAttribute]
[PureAttribute]
public static SwitchStatementInfo Build(ISwitchStatement switchStatement);
    public sealed virtual IPatternAlternativesInfo`1<ISwitchCaseLabel> get_NullPatternAlternatives();
    public sealed virtual IPatternAlternativesInfo`1<ISwitchCaseLabel> get_WildcardAlternatives();
    public sealed virtual bool IsEmpty();
    public sealed virtual IPatternAlternativesInfo`1<ISwitchCaseLabel> TryGetAlternativesFor(IDeclaredType type);
    public sealed virtual IEnumerable`1<IDeclaredType> EnumerateHandledTypes();
    public void RemoveUnguardedPatternFor(IDeclaredType type);
    private void AddCaseLabel(ISwitchCaseLabel caseLabel);
    private void AddTypePatternCase(IDeclaredType type, ISwitchCaseLabel caseLabel);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.TypePatternElementsProvider : object {
    [NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<GeneratorTypePatternElement> GetInheritorsElements(IDeclaredType governingType, ITreeNode context, IProgressIndicator progress);
    [CanBeNullAttribute]
private static IDeclaredType SubstituteOpenTypeArgumentsWithTodoType(IDeclaredType type, ITreeNode context);
    [CompilerGeneratedAttribute]
internal static IType <SubstituteOpenTypeArgumentsWithTodoType>g__GetTodoType|1_0(<>c__DisplayClass1_0& );
}
[GeneratorBuilderAttribute("PatternMatching", "JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.TypePatternsBuilder : GeneratorBuilderBase`1<PatternMatchingGeneratorContext> {
    protected virtual bool IsAvailable(PatternMatchingGeneratorContext context);
    protected virtual void BuildOptions(PatternMatchingGeneratorContext context, ICollection`1<IGeneratorOption> options);
    protected virtual bool HasProcessableElements(PatternMatchingGeneratorContext context, IEnumerable`1<IGeneratorElement> elements);
    protected virtual void Process(PatternMatchingGeneratorContext context, IProgressIndicator progress);
    private static void GenerateCore(IPatternMatchingInfo`1<TAlternativeNode> patternMatchingInfo, IPatternMatchingBuilder`1<TAlternativeNode> patternMatchingBuilder, PatternMatchingGeneratorContext context, IProgressIndicator progress);
    private static void ProcessSpecialPattern(PatternMatchingGeneratorContext context, IPatternMatchingInfo`1<TAlternativeNode> patternMatchingInfo, IPatternMatchingBuilder`1<TAlternativeNode> patternMatchingBuilder, SpecialPatternKind specialPatternKind);
    private static void RemoveUncheckedTypePatterns(ISet`1<IDeclaredType> selectedTypes, IPatternMatchingInfo`1<TAlternativeNode> patternMatchingInfo, IEnumerable`1<IDeclaredType> providedTypes);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.TypeSortingUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static List`1<IDeclaredType> SortTypes(HashSet`1<IDeclaredType> types, IEnumerable`1<IDeclaredType> typesOrder);
    private static void StableTopoSort(List`1<IDeclaredType> types);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Generate.PatternMatching.VariableNamesGenerator : object {
    [NotNullAttribute]
private IPsiSourceFile myPsiSourceFile;
    [NotNullAttribute]
private NameSuggestionManager myNameSuggestionManager;
    [NotNullAttribute]
private SuggestionOptions mySuggestionOptions;
    [NotNullAttribute]
private EntryOptions myEntryOptions;
    public VariableNamesGenerator(ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public string GenerateNameFor(IDeclaredType type);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CopyLocalFixUtil : object {
    public static void Execute(IReferenceExpression expression);
    private static IEnumerable`1<IReference> FindReferences(ITreeNode domain, IDeclaredElement variable);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CSharpAnnotateWithAttributeIntention : object {
    public sealed virtual void Annotate(IDeclaration declaration, ITypeElement markBy, AttributeValue[] fixedArguments, Pair`2[] namedArguments);
    public sealed virtual bool HasAnnotation(IDeclaration declaration, ITypeElement annotationType);
    [CanBeNullAttribute]
[PureAttribute]
private static ITypeElement ResolvedTypeElement(IAttribute attribute);
    public sealed virtual void UpdateAnnotations(IDeclaration markedDeclaration, UpdateArgumentsDelegate provideArguments);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CSharpChangeBaseTypeRequiredIntention : object {
    [NullableContextAttribute("1")]
public sealed virtual void Execute(IClass classToProcess, IDeclaredType fromType, IDeclaredType toType);
    [NullableContextAttribute("1")]
private static void FixTypeOf(ITypeofExpression typeOf, ITypeUsage typeUsageNode, IList`1<ITypeofExpression> changes);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CSharpChangeSignatureIntention : object {
    [NotNullAttribute]
private CSharpLanguage myLanguage;
    [NotNullAttribute]
private INamingLanguageService myNamingLanguageService;
    public CSharpChangeSignatureIntention(CSharpLanguage language, INamingLanguageService namingLanguageService);
    public sealed virtual void ChangeSignature(IParametersOwnerDeclaration signatureToChange, IParametersOwner sourcePattern, ISubstitution sourceSubstitution, SignatureChangeKind changeKind);
    private static void FixReturnType(IParametersOwnerDeclaration signatureToChange, IParametersOwner sourcePattern, ISubstitution sourceSubstitution);
    private void FixParameters(ICSharpParametersOwnerDeclaration declaration, InvocableSignature signature, String[] paramNames);
    private static void FixRefness(IParametersOwnerDeclaration signatureToChange, IParametersOwner source);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CSharpCreateNameSpaceIntention : object {
    public sealed virtual ITypeAndNamespaceHolderDeclaration CreateOrFindNameSpace(IFile file, string nameSpaceName);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CSharpCreateTypeParameterDeclarationIntention : object {
    public sealed virtual void ExecuteEx(ITypeParametersOwner destination, string newTypeParamName);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CSharpImplementInterfaceIntention : object {
    public static void Implement(ITypeElement implementor, IDeclaredType[] interfacesToImplement);
    public static void Implement(IClassLikeDeclaration declaration, IDeclaredType[] interfacesToImplement);
    private static void ImplementMembers(IClassLikeDeclaration classLikeDeclaration, ITypeElement current, ISubstitution substitution);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CSharpIntentionLanguageService : IntentionLanguageSpecific {
    [NotNullAttribute]
private CSharpPropertyBodyUtil myPropertyBodyUtil;
    public FinderFactory FinderFactory { get; }
    public IEqualityComparer`1<string> NamesComparer { get; }
    public bool IsVoidMethodDeclarationHasTypeUsage { get; }
    public string InterfaceKeyword { get; }
    public string ClassKeyword { get; }
    public string StructKeyword { get; }
    public string EnumKeyword { get; }
    public string RecordKeyword { get; }
    public string RecordStructKeyword { get; }
    public CSharpIntentionLanguageService(CSharpPropertyBodyUtil propertyBodyUtil);
    public virtual FinderFactory get_FinderFactory();
    public virtual IEqualityComparer`1<string> get_NamesComparer();
    public virtual ITypeConversionRule GetTypeConversionRule(ITreeNode context);
    public virtual ITypeConstraintsVerifier GetTypeConstraintsVerifier(ITreeNode context);
    public virtual void SetIsParamArray(IParameterDeclaration parameterDeclaration, bool isSet);
    public virtual void SetAccessorBodies(ITypeMemberDeclaration typeMemberDeclaration, AccessorImplementationKind accessorImplementationKind, List`1<ITemplateFieldHolder> holders);
    public virtual void SetTypeSmart(ITypeOwnerDeclaration declaration, IType type);
    public virtual bool TypeSupportsOnlyStaticMembers(ITreeNode targetDeclaration);
    public virtual bool TypeMembersAreStaticImplicitly(IDeclaration targetDeclaration);
    public virtual bool IsInactivePreprocessorBranch(ITreeNode node);
    public virtual void SetAccessorOwnerName(ITypeMemberDeclaration accessorOwnerDeclaration, string name);
    public virtual bool get_IsVoidMethodDeclarationHasTypeUsage();
    public virtual ITypeMemberDeclaration AddToOwnerDeclaration(ITypeMemberDeclaration declarationToAdd, ITypeDeclaration typeDeclaration, ICreationTarget target);
    public virtual TDeclaration AddToTarget(TDeclaration declarationToAdd, ICreationTarget target);
    private static bool CheckAddWithoutAnchor(T declarationToAdd);
    public virtual void ToExtensionMethod(ITypeMemberDeclaration method);
    public virtual void SetAsync(IParametersOwnerDeclaration method, bool isAsync);
    public virtual bool CanUseExplicitly(IType type, ITreeNode context);
    public virtual IList`1<string> GuessTypeParamNames(int typeArgumentsCount, ITreeNode context);
    public virtual IList`1<string> GuessTypeParamNames(IList`1<IType> typeArguments, ITreeNode context);
    public virtual IDeclaration CreateLocalFunctionDeclaration(IPsiModule psiModule, bool inInterface);
    public virtual ITypeMemberDeclaration CreateConstructorDeclaration(IPsiModule psiModule, bool isPrimary);
    public virtual ITypeMemberDeclaration CreatePropertyDeclaration(IPsiModule psiModule, bool inInterface);
    public virtual ITypeMemberDeclaration CreateEventDeclaration(IPsiModule psiModule);
    public virtual ITypeMemberDeclaration CreateIndexerDeclaration(IPsiModule psiModule, bool inInterface);
    public virtual IFunctionDeclaration AddAccessorDeclaration(ITypeMemberDeclaration ownerDeclaration, AccessorKind kind);
    public virtual void AddBaseConstructorCall(ITypeMemberDeclaration constructorDeclaration);
    public virtual ITypeMemberDeclaration CreateFieldDeclaration(IPsiModule psiModule);
    public virtual ITypeMemberDeclaration CreateConstDeclaration(IPsiModule psiModule);
    public virtual ITypeMemberDeclaration CreateDelegateDeclaration(IPsiModule psiModule);
    public virtual IParameterDeclaration SetParameterScope(IParameterDeclaration declaration, ScopedKind scope, Nullable`1<bool> requiresUnscopedRefAttribute);
    public virtual void SetReturnKind(IDeclaration declaration, ReferenceKind returnKind);
    public virtual ITypeParameter AddTypeParameter(IDeclaration typeParametersOwner, string typeParameterName);
    public virtual void AddTypeConstraints(IDeclaration typeParameterDeclaration, ITypeParameter typeParameter, ISubstitution substitution, string parameterName);
    public virtual ITypeMemberDeclaration CreateEnumMember(IPsiModule psiModule);
    public virtual ITypeMemberDeclaration CreateMethodDeclaration(IPsiModule psiModule, bool inInterface);
    public virtual ITypeDeclaration CreateClassDeclaration(IPsiModule psiModule, bool isStatic);
    public virtual ITypeDeclaration CreateRecordDeclaration(IPsiModule psiModule);
    public virtual ITypeDeclaration CreateInterfaceDeclaration(IPsiModule module);
    public virtual void SetPartial(ITypeDeclaration declaration, bool isPartial);
    public virtual void AddBaseType(ITypeDeclaration typeDeclaration, IDeclaredType inheritsFrom);
    public virtual bool IsPurePropertyDeclaration(IDeclaration declaration);
    public virtual string get_InterfaceKeyword();
    public virtual string get_ClassKeyword();
    public virtual string get_StructKeyword();
    public virtual string get_EnumKeyword();
    public virtual string get_RecordKeyword();
    public virtual string get_RecordStructKeyword();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.CSharpSetAccessRightsIntention : object {
    public sealed virtual void SetAccessRights(IAccessRightsOwnerDeclaration declaration, AccessRights accessRights);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.DataProviders.AnonymousFunctionTypeProvider : object {
    private IPsiModule myModule;
    private IDeclaredType myObject;
    public AnonymousFunctionTypeProvider(IPsiModule module);
    private ITypeImage Create(IAnonymousFunctionType anonymousFunctionType);
    public ITypeImage Create(ICSharpExpression value);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.DataProviders.CSharpMethodSignatureProvider : MemberSignatureProvider {
    public CSharpMethodSignatureProvider(IPsiServices psiServices);
    [NotNullAttribute]
public static MemberSignature CreateFromInvocation(IReferenceExpression referenceExpression, bool checkOnlyResolved, bool allowVoid, IType defaultType);
    [NotNullAttribute]
public static MemberSignature CreateFromInvocation(ICSharpInvocationInfo invocationInfo, bool checkOnlyResolved, bool allowVoid, IType defaultType, IPsiModule psiModule);
    [PureAttribute]
private static ReferenceKind GetExpectedReturnKind(ICSharpExpression expression);
    public static ITypeImage CreateTypeImageFromExpression(ICSharpExpression value, IPsiModule psiModule);
    [NotNullAttribute]
private static ITypeImage GuessReturnType(ICSharpInvocationInfo invocationInfo, bool checkOnlyResolved, bool allowVoid, IType defaultType);
    [NotNullAttribute]
private static SimpleTypeImage GuessReturnType(IReferenceExpression referenceExpression, bool checkOnlyResolved, bool allowVoid, IType defaultType);
    [NotNullAttribute]
private static IList`1<IExpression> FilterInvocations(IReadOnlyCollection`1<IReferenceExpression> referenceExpressions);
    [NotNullAttribute]
private static IEnumerable`1<ParameterInfoBase> GetParameters(IEnumerable`1<ICSharpArgumentInfo> argumentInfos, IPsiModule psiModule, bool byRefParametersAllowed, ITreeNode context);
    [NotNullAttribute]
public static MemberSignature CreateFromArguments(IEnumerable`1<ICSharpArgument> arguments, IType returnType, IPsiModule psiModule);
    [NotNullAttribute]
public static MemberSignature CreateFromArguments(IEnumerable`1<ICSharpArgument> arguments, IEnumerable`1<IType> returnTypes, IPsiModule psiModule);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static ParameterKind <GetParameters>g__GetHeuristicalParameterKind|8_0(ParameterKind argumentKind, ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.DataProviders.DeclaredTypeProvider : object {
    [NotNullAttribute]
private IDeclaredType myObject;
    public DeclaredTypeProvider(IPsiModule module);
    [NotNullAttribute]
public ITypeImage Create(ICSharpExpression value);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.DataProviders.MethodGroupTypeProvider : object {
    private IPsiModule myModule;
    public MethodGroupTypeProvider(IPsiModule module);
    public ITypeImage Create(ICSharpExpression value);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpClassExtendsFinder : ClassExtendsFinder {
    public CSharpClassExtendsFinder(ClassLikeDeclarationFinder parent);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpClassExtendsFinder/<Find>d__1")]
public virtual IEnumerable`1<ITreeNode> Find(IDeclaration obj);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpConstructorInitializerArgumentsFinder : ConstructorInitializerArgumentsFinder {
    public CSharpConstructorInitializerArgumentsFinder(ITypeMemberDeclaration declaration);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpConstructorInitializerArgumentsFinder/<Find>d__1")]
public virtual IEnumerable`1<ITreeNode> Find(IDeclaration obj);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ITreeNode> <>n__0(IDeclaration obj);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpFinderFactory : FinderFactory {
    public static FinderFactory Instance;
    private static CSharpFinderFactory();
    public virtual ParamTypeUsageFinder CreateParamTypeUsageFinder(ParametersOwnerDeclarationFinder parent, int paramIndex);
    public virtual TypeArgumentFinder CreateTypeArgumentFinder(TypeUsageFinder parent, int typeArgIndex);
    public virtual ParamNameFinder CreateParamNameFinder(ParametersOwnerDeclarationFinder parent, int paramIndex);
    public virtual ReturnTypeFinder CreateReturnTypeFinder(TypeOwnerDeclarationFinder parent);
    public virtual MethodNameFinder CreateMethodNameFinder(ParametersOwnerDeclarationFinder parent);
    public virtual ClassExtendsFinder CreateClassExtendsFinder(ClassLikeDeclarationFinder parent);
    public virtual TypeKindFinder CreateTypeKindFinders(ClassLikeDeclarationFinder parent);
    public virtual DocumentRange GetInitializerExpressionRange(IDeclaration fieldLikeDeclaration);
    public virtual ConstructorInitializerArgumentsFinder CreateConstructorInitializerArgumentsFinder(ITypeMemberDeclaration declaration);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpMethodNameFinder : MethodNameFinder {
    public CSharpMethodNameFinder(NestedFinder parent);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpMethodNameFinder/<Find>d__1")]
public virtual IEnumerable`1<ITreeNode> Find(IDeclaration obj);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpParamNameFinder : ParamNameFinder {
    public CSharpParamNameFinder(ParametersOwnerDeclarationFinder parent, int paramIndex);
    public virtual IEnumerable`1<ITreeNode> Find(IDeclaration obj);
    [CompilerGeneratedAttribute]
private ICSharpIdentifier <Find>b__1_0(ICSharpParametersOwnerDeclaration method);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpParamTypeUsageFinder : ParamTypeUsageFinder {
    private int myParamNo;
    public PsiLanguageType Language { get; }
    public CSharpParamTypeUsageFinder(ParametersOwnerDeclarationFinder parent, int index);
    public virtual PsiLanguageType get_Language();
    public virtual IEnumerable`1<ITreeNode> Find(IDeclaration obj);
    [CompilerGeneratedAttribute]
private ITypeUsage <Find>b__4_0(IParametersOwnerDeclaration method);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpReturnTypeFinder : ReturnTypeFinder {
    public PsiLanguageType Language { get; }
    public CSharpReturnTypeFinder(NestedFinder parent);
    public virtual PsiLanguageType get_Language();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpReturnTypeFinder/<Find>d__3")]
public virtual IEnumerable`1<ITreeNode> Find(IDeclaration obj);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpTypeArgumentFinder : TypeArgumentFinder {
    public PsiLanguageType Language { get; }
    public CSharpTypeArgumentFinder(TypeUsageFinder parent, int typeArgIndex);
    public virtual PsiLanguageType get_Language();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpTypeArgumentFinder/<Find>d__3")]
public virtual IEnumerable`1<ITreeNode> Find(IDeclaration obj);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpTypeKindFinder : TypeKindFinder {
    public CSharpTypeKindFinder(ClassLikeDeclarationFinder parent);
    public virtual IEnumerable`1<DocumentRange> GetTypeKindRanges(IDeclaration declaration);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Finders.CSharpTypeKindFinder/<FindElement>d__2")]
private IEnumerable`1<ITreeNode> FindElement(IDeclaration obj);
    public virtual string ToString();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.MemberBody.CSharpMemberBodyTemplateItemsProvider : object {
    private IMemberBodyOperations myBodyOperations;
    private CSharpPropertyBodyUtil myPropertyBodyUtil;
    public CSharpMemberBodyTemplateItemsProvider(CSharpPropertyBodyUtil propertyBodyUtil, IMemberBodyOperations bodyOperations);
    public sealed virtual IList`1<ILookupItem> GetLookupItems(IDeclaration declaration);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.MemberBody.LookupItems.AutoPropertyLookupItem : PropertyBodyLookupItemBase {
    [NotNullAttribute]
private CSharpPropertyBodyUtil myPropertyBodyUtil;
    public RichText DisplayName { get; }
    public AutoPropertyLookupItem(PsiLanguageType languageType, CSharpPropertyBodyUtil propertyBodyUtil);
    public virtual RichText get_DisplayName();
    protected virtual void SetBody(IPropertyDeclaration propertyDeclaration);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.MemberBody.LookupItems.BackingFieldLookupItem : PropertyBodyLookupItemBase {
    [NotNullAttribute]
private string myBackingFieldName;
    [NotNullAttribute]
private CSharpPropertyBodyUtil myPropertyBodyUtil;
    private bool myCreate;
    public RichText DisplayName { get; }
    public BackingFieldLookupItem(IPropertyDeclaration propertyDeclaration, string backingFieldName, CSharpPropertyBodyUtil propertyBodyUtil);
    public virtual RichText get_DisplayName();
    protected virtual void SetBody(IPropertyDeclaration propertyDeclaration);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.MemberBody.LookupItems.MethodBodyLookupItem : MemberBodyLookupBase {
    private string myMessage;
    private IMemberBodyOperations myBodyOperations;
    public RichText DisplayName { get; }
    public MethodBodyLookupItem(string message, PsiLanguageType languageType, IMemberBodyOperations bodyOperations);
    public virtual RichText get_DisplayName();
    protected virtual void DoCommand(ITreeNode element);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.MemberBody.LookupItems.PropertyBodyLookupItemBase : MemberBodyLookupBase {
    protected PropertyBodyLookupItemBase(PsiLanguageType languageType);
    protected virtual void DoCommand(ITreeNode element);
    protected abstract virtual void SetBody(IPropertyDeclaration propertyDeclaration);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.Util.CSharpTypeProcessUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<IExpressionType> Expand(IEnumerable`1<IExpressionType> types, IType objectType);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<IType> GetParametersTypes(IAnonymousFunctionType anonymousFunctionType);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.XmlToLinqPredifinedTypes : object {
    [CompilerGeneratedAttribute]
private IDeclaredType <XNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredType <XElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredType <XDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredType <XDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredType <XAttribute>k__BackingField;
    public IDeclaredType XNamespace { get; }
    public IDeclaredType XElement { get; }
    public IDeclaredType XDocument { get; }
    public IDeclaredType XDeclaration { get; }
    public IDeclaredType XAttribute { get; }
    public XmlToLinqPredifinedTypes(IPsiModule psiModule);
    [CompilerGeneratedAttribute]
public IDeclaredType get_XNamespace();
    [CompilerGeneratedAttribute]
public IDeclaredType get_XElement();
    [CompilerGeneratedAttribute]
public IDeclaredType get_XDocument();
    [CompilerGeneratedAttribute]
public IDeclaredType get_XDeclaration();
    [CompilerGeneratedAttribute]
public IDeclaredType get_XAttribute();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Intentions.XmlTreeVisitorCodeCreator : XmlTreeVisitor`2<ITreeNode, ICSharpExpression> {
    [CompilerGeneratedAttribute]
private ICSharpExpression <XDocumentExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExpression <XElementExpression>k__BackingField;
    [NotNullAttribute]
private CSharpElementFactory myFactory;
    [NotNullAttribute]
private XmlNamespaceManager myNsMgr;
    [NotNullAttribute]
private XmlToLinqPredifinedTypes myXtypes;
    [NotNullAttribute]
private IStringConcatenationClrWrapper myStringConcatenationWrapper;
    [CanBeNullAttribute]
public ICSharpExpression XDocumentExpression { get; private set; }
    [CanBeNullAttribute]
public ICSharpExpression XElementExpression { get; private set; }
    public XmlTreeVisitorCodeCreator(IPsiModule psiModule, IStringConcatenationClrWrapper stringConcatenationWrapper);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_XDocumentExpression();
    [CompilerGeneratedAttribute]
private void set_XDocumentExpression(ICSharpExpression value);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_XElementExpression();
    [CompilerGeneratedAttribute]
private void set_XElementExpression(ICSharpExpression value);
    public virtual ICSharpExpression Visit(IXmlFile document, ITreeNode context);
    private ICSharpExpression MakeDocumentCreationExpression(IXmlProcessingInstruction processingInstruction);
    [CanBeNullAttribute]
public virtual ICSharpExpression Visit(IXmlAttribute attribute, ITreeNode context);
    [CanBeNullAttribute]
private IExpression MakeSamePresentation(TextRange xmlValueStringRange);
    [CanBeNullAttribute]
public virtual ICSharpExpression Visit(IXmlTag tag, ITreeNode context);
    private void SetNamespaces(IXmlTag tag);
    [CanBeNullAttribute]
private IExpression CreateSamePresentationNode(IXmlIdentifier node, bool mustSpecifyDefaultNs);
    private ICSharpExpression MakeConstantTreeNode(string text);
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "ReSharper Interceptors' Hints settings")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Interceptors.CSharpInterceptorsHintsOptions : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowInterceptedCallsDescription")]
public PushToHintMode ShowInterceptedCalls;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowInterceptsLocationNavigationHintDescription")]
public PushToHintMode ShowInterceptsLocationNavigationHint;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowInterceptedCallsDescription")]
public IIndexedEntry`2<string, bool> ExclusionList;
}
[OptionsPageAttribute("CSharpInterceptorsHintsOptionsPage", "Interceptor Hints", "JetBrains.Application.UI.Icons.FeaturesIntellisenseThemedIcons.FeaturesIntellisenseThemedIcons/ParameterInfoPage")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Interceptors.CSharpInterceptorsHintsOptionsPage : InlayHintsOptionPageBase {
    public static string PID;
    public CSharpInterceptorsHintsOptionsPage(Lifetime lifetime, IIconHost iconHost, OptionsPageContext optionsPageContext, OptionsSettingsSmartContext optionsSettingsSmartContext);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Interceptors.CSharpInterceptorsSettingsRegistrar : object {
    public CSharpInterceptorsSettingsRegistrar(InlayHintsOptionsStore inlayHintsOptionsStore, ISettingsStore settingsStore);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.Interceptors.ZoneMarker : object {
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.CSharpLinqToolsLanguageHelper : object {
    private StructuralSearchPatternParams mySsStructuralSearchPatternParams;
    [CompilerGeneratedAttribute]
private String[] <WherePatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WhereInversePatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SelectOrLetPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TakeWhilePatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <DistinctPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <DistinctPatternsWithContinue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <DistinctSetVarDeclPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CastPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <OfTypePatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <OfTypePatternsWithContinue1>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <OfTypePatternsWithContinue2>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CountPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <MinPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <MaxPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SumPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AssignAnyPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ReturnAnyPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <IfAnyPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <IfAnyPatternsWithBreak>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FirstOrDefaultPatternsWithBreak>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FirstOrDefaultPatternsWithReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <YieldReturnPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ForLoopPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ElementAccessPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TypeInstantiationPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TypeInstantiationOneParamPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <EqualsPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <DeclarationAndReturnPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AssignmentAndReturnPatterns>k__BackingField;
    public IEnumerable`1<Type> TypesToMarkOnCopy { get; }
    public String[] WherePatterns { get; }
    public String[] WhereInversePatterns { get; }
    public String[] SelectOrLetPatterns { get; }
    public String[] TakeWhilePatterns { get; }
    public String[] DistinctPatterns { get; }
    public String[] DistinctPatternsWithContinue { get; }
    public String[] DistinctSetVarDeclPatterns { get; }
    public String[] CastPatterns { get; }
    public String[] OfTypePatterns { get; }
    public String[] OfTypePatternsWithContinue1 { get; }
    public String[] OfTypePatternsWithContinue2 { get; }
    public String[] CountPatterns { get; }
    public String[] MinPatterns { get; }
    public String[] MaxPatterns { get; }
    public String[] SumPatterns { get; }
    public String[] AssignAnyPatterns { get; }
    public String[] ReturnAnyPatterns { get; }
    public String[] IfAnyPatterns { get; }
    public String[] IfAnyPatternsWithBreak { get; }
    public String[] FirstOrDefaultPatternsWithBreak { get; }
    public String[] FirstOrDefaultPatternsWithReturn { get; }
    public String[] YieldReturnPatterns { get; }
    public String[] ForLoopPatterns { get; }
    public String[] ElementAccessPatterns { get; }
    public String[] TypeInstantiationPatterns { get; }
    public String[] TypeInstantiationOneParamPatterns { get; }
    public String[] EqualsPatterns { get; }
    public String[] DeclarationAndReturnPatterns { get; }
    public String[] AssignmentAndReturnPatterns { get; }
    public bool VariablesInLoopCollectionConflictWithIterator { get; }
    public string FromQueryFormatString { get; }
    public string FromQueryExplicitTypeFormatString { get; }
    public string SelectQueryFormatString { get; }
    public string SelectIntoQueryFormatString { get; }
    public string WhereQueryFormatString { get; }
    public string LetQueryFormatString { get; }
    public bool CanOmitTrivialSelect { get; }
    public sealed virtual IPlaceholder CreateIdentifierPlaceholder(string name);
    public sealed virtual IPlaceholder CreateExpressionPlaceholder(string name);
    public sealed virtual IPlaceholder CreateStatementPlaceholder(string name);
    public sealed virtual IPlaceholder CreateStatementsPlaceholder(string name);
    public sealed virtual IPlaceholder CreateTypePlaceholder(string name);
    public sealed virtual IPlaceholder CreateElementPlaceholder(string name, ITreeNode node);
    public sealed virtual IStructuralSearchPattern CreatePattern(string text, IEnumerable`1<IPlaceholder> placeholders);
    public sealed virtual bool IsForeachStatement(IStatement statement, IStatementsRange& body, ILocalVariable& iteratorVar, IExpression& collectionExpr, Boolean& isAsync);
    public sealed virtual bool CanUseGetEnumeratorFromIEnumerable(IStatement statement, Boolean& usesGetEnumeratorFromIEnumerable);
    public sealed virtual bool IsForStatement(IStatement statement, IStatementsRange& body);
    public sealed virtual bool IsLabelStatement(IStatement statement);
    public sealed virtual bool IsLoopBodyBlock(IStatement statement);
    public sealed virtual bool IsAsyncForeachStatement(IStatement statement);
    public sealed virtual IStatementsRange StatementToRange(IStatement statement);
    public sealed virtual IStatementsRange StatementsToRange(IList`1<IStatement> statements);
    public sealed virtual IStatementsRange ToStatementsRange(ITreeRange treeRange);
    public sealed virtual IStatementsRange SkipStatements(IList`1<IStatement> statements, int n);
    public sealed virtual bool IsTheOnlyExecutedStatement(IStatement statement);
    public sealed virtual bool IsLastExecutedStatement(IStatement statement, bool allowIfs, IExpression& valueReturned, IStatement& returnStatementToRemove);
    public sealed virtual IReference ReferenceExpressionReference(IExpression expression);
    public sealed virtual IExpression ReferenceExpressionByReference(IReference reference);
    public sealed virtual bool IsInvocationQualifier(IExpression qualifier, IExpression& invocation, IMethod& targetMethod, IList`1& args);
    public sealed virtual IExpression ReferenceExpressionByQualifier(IExpression qualifier);
    public sealed virtual IExpression ElementAccessByArgument(IExpression argument);
    public sealed virtual IReference InvocationExpressionReference(IExpression expression);
    public sealed virtual IReference ElementAccessReference(IExpression expression);
    public sealed virtual bool IsCastExpressionOperand(IExpression expression, IExpression& castExpr);
    public sealed virtual ITypeOwnerDeclaration SingleVariableDeclaration(IStatement statement, bool checkIsRegular);
    public sealed virtual bool IsVariableAssignment(IStatement statement, ITypeOwner& variable, IExpression& valueAssigned);
    public sealed virtual bool IsVariableAssignmentValue(IExpression expression, IStatement& statement, ITypeOwner& variable);
    public sealed virtual bool IsInvocation(IStatement statement, IMethod& targetMethod, IExpression& qualifier, IList`1& args);
    public sealed virtual bool IsInvocation(IExpression expression, IMethod& targetMethod, IExpression& qualifier, IList`1& args);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.CSharpLinqToolsLanguageHelper/<StatementsBefore>d__33")]
public sealed virtual IEnumerable`1<IStatement> StatementsBefore(IStatement statement);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.CSharpLinqToolsLanguageHelper/<StatementsAfter>d__34")]
public sealed virtual IEnumerable`1<IStatement> StatementsAfter(IStatement statement);
    public sealed virtual bool IsVariableUsage(IExpression expression, string name);
    public sealed virtual bool IsReturnOwner(ITreeNode node, IType& returnType);
    public sealed virtual bool IsYieldStatement(IStatement statement);
    [CanBeNullAttribute]
private static ICSharpExpression AssignmentToResultExpression(IAssignmentExpression assignment);
    private static ICSharpExpression CastIfNeeded(ICSharpExpression expr, IType requiredType);
    public sealed virtual bool CheckNoEscapes(IStatement statement, EscapeType escapeTypes, Predicate`1<IStatement> filter);
    public sealed virtual ILocalVariable DeclareTempVariable(IType type, string name, IStatementsRange& beforeStatementsRange, bool applyCodeFormatter);
    public sealed virtual void ChangeVariableType(ITypeOwnerDeclaration declaration, IType newType, bool applyCodeFormatter);
    public sealed virtual void SetTypeOrVar(ITypeOwnerDeclaration localVarDeclaration, IType type);
    public sealed virtual ITreeNode GetScopeToCopy(IStatement loop);
    public sealed virtual ConstantValue ConvertConstantValueToTypeImplicit(ConstantValue value, IType type, IFile context);
    public sealed virtual ITypeConversionRule TypeConversionRule(ITreeNode context);
    public sealed virtual IExpression InvertCondition(IExpression condition, bool applyCodeFormatter);
    public sealed virtual IEnumerable`1<Type> get_TypesToMarkOnCopy();
    public sealed virtual ILocalVariable CreateDummyVariable(IPsiModule module, IType type);
    public sealed virtual bool IsImplicitlyTyped(ILocalVariable local);
    public sealed virtual bool IsCastExpression(IExpression expression, IExpression& operand);
    public sealed virtual bool CanReplaceCastOperator(IType sourceType, IType targetType, ITreeNode context);
    public sealed virtual IStatement AddStatement(IStatement statement, IStatement& anchor, bool before);
    public sealed virtual void RemoveStatement(IStatement statement);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_WherePatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_WhereInversePatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_SelectOrLetPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_TakeWhilePatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_DistinctPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_DistinctPatternsWithContinue();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_DistinctSetVarDeclPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_CastPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_OfTypePatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_OfTypePatternsWithContinue1();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_OfTypePatternsWithContinue2();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_CountPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_MinPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_MaxPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_SumPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_AssignAnyPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ReturnAnyPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_IfAnyPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_IfAnyPatternsWithBreak();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_FirstOrDefaultPatternsWithBreak();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_FirstOrDefaultPatternsWithReturn();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_YieldReturnPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ForLoopPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ElementAccessPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_TypeInstantiationPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_TypeInstantiationOneParamPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_EqualsPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_DeclarationAndReturnPatterns();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_AssignmentAndReturnPatterns();
    public sealed virtual IExpression CreateVariableUsageExpression(IPsiModule module, ITypeOwner variable, bool applyCodeFormatter);
    public sealed virtual IExpression CreateVariableUsageExpression(IPsiModule module, string variableName, bool applyCodeFormatter);
    public sealed virtual IExpression CreateInvocationExpression(IPsiModule module, IMethod targetMethod, IList`1<IType> typeArgs, object qualifier, string methodName, bool wrapWithAwait, Object[] args);
    public sealed virtual IExpression CreateLambdaExpression(IPsiModule module, bool isAsync, String[] argNames, IExpression body);
    public sealed virtual IExpression CreateCastExpression(IExpression expression, IType type, bool applyCodeFormatter);
    public sealed virtual IExpression CreateSumExpression(IPsiModule module, IExpression operand1, IExpression operand2);
    public sealed virtual IExpression CreateLogicalAndExpression(IPsiModule module, IExpression condition1, IExpression condition2);
    public sealed virtual IExpression CreateOneElementArrayCreationExpression(IPsiModule module, IType elementType, IExpression element);
    public sealed virtual IExpression CreateQueryExpression(IPsiModule module, string text, IEnumerable`1<object> args);
    public sealed virtual IStatement CreateReturnStatement(IPsiModule module, IExpression returnValue);
    public sealed virtual IStatement CreateInvocationStatement(IPsiModule module, IMethod targetMethod, IList`1<IType> typeArgs, object qualifier, string methodName, bool wrapWithAwait, Object[] args);
    public sealed virtual IStatement CreateAssignmentStatement(IPsiModule module, ITypeOwner targetVar, IExpression expression);
    public sealed virtual IStatement CreateAddValueStatement(IPsiModule module, ITypeOwner targetVar, IExpression expression);
    public sealed virtual IStatement CreateIfStatement(IPsiModule module, IExpression condition, IStatementsRange thenStatements);
    public sealed virtual IStatement ReplaceWithForeachLoop(IStatement loop, IExpression iteratorExpression, IType elementType, string iteratorName, IExpression enumerableExpr, IStatementsRange body, bool forceUseBlock);
    private static object TypeOrVar(IType type, ITreeNode context);
    public sealed virtual IExpression ReplaceBy(IExpression oldExpr, IExpression newExpr);
    public sealed virtual IStatement ReplaceBy(IStatement oldStatement, IStatement newStatement);
    public sealed virtual void SetInitializer(IDeclaration localVarDeclaration, IExpression value);
    public sealed virtual IExpression GetInitializer(IDeclaration localVarDeclaration);
    public sealed virtual bool IsSimpleExpression(IExpression expression);
    public sealed virtual bool get_VariablesInLoopCollectionConflictWithIterator();
    public sealed virtual void RenameVarRef(IReference reference, IExpression newExpr, IExpression& expr);
    public sealed virtual bool IsWriteElementAccess(IExpression refExpr);
    public sealed virtual bool HasAwaitExpressions(IExpression expression);
    public sealed virtual bool VarCanAggregateMultipleTimes(ILocalVariable workingVar, IStatement setVarDeclStatement);
    public sealed virtual bool IsIndexerUsed(IExpression indexer);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.CSharpLinqToolsLanguageHelper/<GetDeclaredVariables>d__171")]
public sealed virtual IEnumerable`1<ILocalVariable> GetDeclaredVariables(IExpression expression);
    public sealed virtual bool CanUseInClosure(IExpression expression);
    public sealed virtual IExpression GenerateFunctionalForm(IExpression queryExpression, ITreeNode context);
    public sealed virtual void CopyLocal(IExpression refExpression);
    public sealed virtual bool CanUseAsCollectionInForeach(IType collectionType, ITreeNode context);
    public sealed virtual bool CanMoveToWhereQuery(IExpression whereCondition, ILocalVariable& ofTypeVariable, IExpression& updatedPreCondition, IExpression& updatedPostCondition);
    public sealed virtual string get_FromQueryFormatString();
    public sealed virtual string get_FromQueryExplicitTypeFormatString();
    public sealed virtual string get_SelectQueryFormatString();
    public sealed virtual string get_SelectIntoQueryFormatString();
    public sealed virtual string get_WhereQueryFormatString();
    public sealed virtual string get_LetQueryFormatString();
    public sealed virtual bool get_CanOmitTrivialSelect();
    [CompilerGeneratedAttribute]
internal static bool <CanUseAsCollectionInForeach>g__IsInAsyncOrIteratorDeclaration|175_0(ICSharpTreeNode treeNode);
    [CompilerGeneratedAttribute]
internal static bool <CanMoveToWhereQuery>g__CanBeTrackedByNullableAnalysis|176_0(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.CSharpStructuralSearchMatchersCacheExtension : object {
    public sealed virtual IStructuralMatcher CreateExpressionMatcher(IStructuralSearchPattern pattern);
    public sealed virtual IStructuralMatcher CreateStatementMatcher(IStructuralSearchPattern pattern);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.ActionQueryBase : object {
    protected IInvocationExpression myInvocation;
    protected IExpression myEnumerable;
    private IType myElementType;
    private IExpression myWhereExpr;
    private IExpression mySelectExpr;
    protected IType mySelectedElementType;
    protected ElementPointersStore myPointersStore;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    private static IStructuralSearchPattern[] ourStupidAssignmentPatterns;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public bool IsAsync { get; }
    [CanBeNullAttribute]
protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    protected IPsiSourceFile SourceFile { get; }
    protected ActionQueryBase(bool isAsync, IExpression invocation, IExpression enumerable, IType elementType, IExpression whereExpr, IExpression selectExpr, IType selectedElementType);
    private static ActionQueryBase();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    protected abstract virtual string get_ResultVariableNameSuggestion();
    protected abstract virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected abstract virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected abstract virtual bool get_SkipResultVariableWhenInReturn();
    protected abstract virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected abstract virtual bool get_SkipResultVariableWhenInIfCondition();
    protected abstract virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected abstract virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    [CompilerGeneratedAttribute]
protected IPsiSourceFile get_SourceFile();
    public sealed virtual IForeachStatement TransformToLoop(LinqCache cache, Boolean& canInlineIteratorVar);
    public virtual IForeachStatement TransformToLoop(LinqCache cache, Boolean& canInlineIteratorVar, ITypeOwner& resultVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.AggregateQuery : ActionQueryBase {
    private bool myIsAwait;
    private IElementPointer`1<IExpression> mySeedPtr;
    private IElementPointer`1<IExpression> myFuncPtr;
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public AggregateQuery(bool isAsync, bool isAwait, IExpression invocation, IExpression enumerable, IType elementType, IExpression seed, IExpression func);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.AggregateQueryWithNoSeed : object {
    private bool myIsAwait;
    private IInvocationExpression myInvocation;
    private ICSharpExpression myEnumerable;
    private IType myElementType;
    private ICSharpExpression myFunc;
    private IPsiSourceFile mySourceFile;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsAsync { get; }
    public AggregateQueryWithNoSeed(bool isAsync, bool isAwait, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, ICSharpExpression func);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    public sealed virtual IForeachStatement TransformToLoop(LinqCache cache, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.AggregateQueryWithResultSelector : object {
    private bool myIsAwait;
    private IInvocationExpression myInvocation;
    private ICSharpExpression myEnumerable;
    private IType myElementType;
    private IType myAccumulatorType;
    private ICSharpExpression mySeed;
    private ICSharpExpression myFunc;
    private ICSharpExpression myResultSelector;
    private IPsiSourceFile mySourceFile;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsAsync { get; }
    public AggregateQueryWithResultSelector(bool isAsync, bool isAwait, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, IType accumulatorType, ICSharpExpression seed, ICSharpExpression func, ICSharpExpression resultSelector);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    public sealed virtual IForeachStatement TransformToLoop(LinqCache cache, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.AllQuery : ActionQueryBase {
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public AllQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, ICSharpExpression whereExpr);
    private static ICSharpExpression InvertConditionDelegate(ICSharpExpression cond);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.AnyQuery : ActionQueryBase {
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public AnyQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, ICSharpExpression whereExpr);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.ContainsQuery : ActionQueryBase {
    private IElementPointer`1<IExpression> myElementExprPtr;
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public ContainsQuery(bool isAsync, IInvocationExpression invocation, IExpression enumerable, IType elementType, IExpression elementExpr);
    public virtual IForeachStatement TransformToLoop(LinqCache cache, Boolean& canInlineIteratorVar, ITypeOwner& resultVar);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    private IExpression GenerateComparison(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.CountQuery : ActionQueryBase {
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public CountQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, ICSharpExpression whereExpr);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.FirstOrDefaultQuery : ActionQueryBase {
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public FirstOrDefaultQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, ICSharpExpression whereExpr);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.MatchActionQueryInvocation : object {
    [CanBeNullAttribute]
public static IActionQuery Match(IInvocationExpression invocation, LinqCache cache);
    private static bool UsesVariablesDefinedInsideStatement(IInvocationExpression invocation, ICSharpStatement containingStatement);
    private static SumQuery MatchSum(bool isAsync, IInvocationExpression invocation, IMethod method, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static MaxOrMinQuery MatchMaxOrMin(bool isAsync, IInvocationExpression invocation, IMethod method, Dictionary`2<IParameter, ICSharpExpression> arguments, bool isMin);
    private static IActionQuery MatchAggregate(bool isAsync, bool isAwait, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static ToListQuery MatchToList(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static ToArrayQuery MatchToArray(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static ToDictionaryQuery MatchToDictionary(bool isAsync, bool isAwait, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments, LinqCache cache);
    private static CountQuery MatchCount(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments, LinqCache cache);
    private static AnyQuery MatchAny(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static AllQuery MatchAll(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static FirstOrDefaultQuery MatchFirstOrDefault(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static ContainsQuery MatchContains(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.MaxOrMinQuery : ActionQueryBase {
    private bool myIsMin;
    private ICSharpExpression myInitial;
    private static IStructuralSearchPattern[] ourConcatPatterns;
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public MaxOrMinQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, bool isMin);
    private static MaxOrMinQuery();
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.SumQuery : ActionQueryBase {
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public SumQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, ICSharpExpression selectExpr, IType selectedElementType);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.ToArrayQuery : object {
    [NotNullAttribute]
private IInvocationExpression myInvocation;
    [NotNullAttribute]
private ICSharpExpression myEnumerable;
    [NotNullAttribute]
private IType myElementType;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsAsync { get; }
    public ToArrayQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    public sealed virtual IForeachStatement TransformToLoop(LinqCache cache, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.ToDictionaryQuery : ActionQueryBase {
    private bool myIsAwait;
    private IType myKeyType;
    private IType myValueType;
    private IElementPointer`1<ICSharpExpression> myKeySelectorPtr;
    [CanBeNullAttribute]
private IElementPointer`1<ICSharpExpression> myValueSelectorPtr;
    [CanBeNullAttribute]
private IElementPointer`1<ICSharpExpression> myComparerPtr;
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public ToDictionaryQuery(bool isAsync, bool isAwait, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType, IType keyType, IType valueType, ICSharpExpression keySelector, ICSharpExpression valueSelector, ICSharpExpression comparer);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ActionQueries.ToListQuery : ActionQueryBase {
    protected string ResultVariableNameSuggestion { get; }
    protected bool SkipResultVariableWhenInReturn { get; }
    protected bool SkipResultVariableWhenInIfCondition { get; }
    protected bool SkipResultVariableWhenInInverseIfCondition { get; }
    public ToListQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType elementType);
    protected virtual string get_ResultVariableNameSuggestion();
    protected virtual IExpression InitialResultVariableValue(LinqCache cache, ITreeNode context);
    protected virtual ICSharpStatement GenerateLoopBody(ITypeOwner resultVar, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInReturn();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInReturn(ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
    protected virtual bool get_SkipResultVariableWhenInIfCondition();
    protected virtual bool get_SkipResultVariableWhenInInverseIfCondition();
    protected virtual ICSharpStatement GenerateLoopBodyWhenInIfCondition(ICSharpStatement ifBody, bool inverseCondition, ILocalVariable iteratorVar, LinqCache cache, ITreeNode context, Boolean& canInlineIteratorVar);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.DelayedRename : object {
    private static Key`1<INamesCollection> KEY;
    private static DelayedRename();
    public static void AddVariableToRename(IDeclaredElement variable, INamesCollection namesCollection);
    public static void ReplaceDelayedRename(IDeclaredElement oldVar, IDeclaredElement newVar);
    public static void ClearDelayedRename(IDeclaredElement var);
    public static bool HasDelayedRename(IDeclaredElement var);
    public static void PerformDelayedRenames(ITreeNode scope);
    private static IDeclaration GetDeclaration(IDeclaredElement variable);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.FromLinqUtil : object {
    private static CSharpStructuralSearchPattern ourIndexVarPattern;
    private static FromLinqUtil();
    [ExtensionAttribute]
public static object TypeOrVar(IType type, ITreeNode context);
    public static ITypeOwner DeclareResultVariableIfNeeded(TExpression& expression, string nameSuggested, IPsiSourceFile sourceFile);
    public static bool MatchEnumerableMethod(IInvocationExpression invocation, LinqCache cache, bool isAsync, IMethod& method, ISubstitution& substitution, Dictionary`2& arguments);
    public static ILocalVariable DeclareIndexVariable(IForeachStatement& loop, ICSharpExpression delegate, IPsiSourceFile sourceFile);
    public static void IncrementIndexVariable(ILocalVariable variable, IForeachStatement loop, ICSharpStatement existingIncrement);
    [CanBeNullAttribute]
public static ILocalVariable DetectIndexVariable(IForeachStatement loop, ICSharpStatement& incrementStatement, IDeclarationStatement& indexVarDecl);
    public static ICSharpStatement ImproveForeach(IForeachStatement loop, LinqCache cache);
    private static IForStatement ConvertForeachToFor(IForeachStatement loop, ILocalVariable indexVariable, ICSharpStatement incrementStatement, IDeclarationStatement indexVarDecl, LinqCache cache);
    [ExtensionAttribute]
public static ICSharpExpression SkipParenthesisUp(ICSharpExpression expr);
    [ExtensionAttribute]
public static ICSharpExpression SkipParenthesisDown(ICSharpExpression expr);
    public static bool InlineLocal(ILocalVariable variable, bool ifOneUsageOnly);
    public static bool HasExitsFrom(ICSharpStatement statement);
    public static bool IsSimpleExpression(ICSharpExpression expr);
    public static IExpression GenerateExpressionByDelegate(IExpression delegate, string workingVarName, string secondWorkingVarName, ITreeNode scope, bool wrapWithAwaitIfTaskReturning);
    public static bool CanGenerateExpressionByDelegate(IExpression delegate, bool withSecondWorkingVar);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsValueTaskOfBool(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsValueTaskOf(IType type, IType typeArgument);
    [PureAttribute]
public static bool HasNonDefaultCancellationTokenArgument(IMethod method, Dictionary`2<IParameter, ICSharpExpression> arguments);
}
internal interface JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.IActionQuery {
    public bool IsAsync { get; }
    public abstract virtual bool get_IsAsync();
    [NotNullAttribute]
public abstract virtual IForeachStatement TransformToLoop(LinqCache cache, Boolean& canInlineIteratorVar);
}
internal interface JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.IFunctionalSequenceQuery {
    public bool IsAsync { get; }
    public abstract virtual bool get_IsAsync();
    [NotNullAttribute]
public abstract virtual IForeachStatement Inline(LinqCache cache, bool canInlineIteratorVar);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.NamingUtil : object {
    private static Random ourRandom;
    private static NamingUtil();
    public static string GenerateTempVariableName();
    public static INamesCollection ChooseIteratorVariableName(IType elementType, IExpression enumerableExpr, ITreeNode namingContext);
    public static INamesCollection ChooseValueVariableName(IExpression valueExpr, IPsiSourceFile sourceFile);
    public static INamesCollection ChooseVariableName(IType type, string nameSuggested, IPsiModule module, IPsiSourceFile sourceFile);
    public static INamesCollection ChooseIndexVariableName(string suggestedName, IPsiSourceFile sourceFile, ITreeNode context);
    public static INamesCollection ChooseVariableNameFromLambdaParameter(ILambdaExpression lambda, int index, IPsiSourceFile sourceFile);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.ReturnToYieldReturns : object {
    public static bool CanTransformToLoopWithYieldReturns(IReturnStatement return, Boolean& isAsync, IType& elementType);
    private static bool IsEnumerable(IType type, Boolean& isAsync, IType& elementType);
    public static IForeachStatement TransformToLoopWithYieldReturns(IReturnStatement return);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.CastQuery : object {
    private IInvocationExpression myInvocation;
    private ICSharpExpression myEnumerable;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsAsync { get; }
    public CastQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    public sealed virtual IForeachStatement Inline(LinqCache cache, bool canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.DistinctQuery : object {
    private IInvocationExpression myInvocation;
    private ICSharpExpression myEnumerable;
    private IType myEnumerableElementType;
    private ICSharpExpression myComparer;
    private IPsiSourceFile mySourceFile;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsAsync { get; }
    public DistinctQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType enumerableElementType, ICSharpExpression comparer);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    public sealed virtual IForeachStatement Inline(LinqCache cache, bool canInlineIteratorVar);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.MatchSequenceQueryInvocation : object {
    [CanBeNullAttribute]
public static IFunctionalSequenceQuery Match(IInvocationExpression invocation, LinqCache cache);
    private static WhereQuery MatchWhere(bool isAsync, bool isAwait, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static SelectQuery MatchSelect(bool isAsync, bool isAwait, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static SelectManyQuery MatchSelectMany(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static CastQuery MatchCast(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static OfTypeQuery MatchOfType(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static TakeWhileQuery MatchTakeWhile(bool isAsync, bool isAwait, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
    private static DistinctQuery MatchDistinct(bool isAsync, IInvocationExpression invocation, IMethod method, ISubstitution substitution, Dictionary`2<IParameter, ICSharpExpression> arguments);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.OfTypeQuery : object {
    private IInvocationExpression myInvocation;
    private ICSharpExpression myEnumerable;
    private IType myEnumerableElementType;
    private IType myTargetElementType;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsAsync { get; }
    public OfTypeQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType enumerableElementType, IType targetElementType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    public sealed virtual IForeachStatement Inline(LinqCache cache, bool canInlineIteratorVar);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.QueryWithCondition : object {
    protected IInvocationExpression Invocation;
    private ICSharpExpression myEnumerable;
    private IType myEnumerableElementType;
    protected ICSharpExpression Condition;
    private bool myWithIndex;
    private IPsiSourceFile mySourceFile;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsAsync { get; }
    protected QueryWithCondition(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType enumerableElementType, ICSharpExpression condition, bool withIndex);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    protected abstract virtual void ModifyLoopBody(IForeachStatement loop, ITypeOwner iteratorVar, string indexVarName);
    public sealed virtual IForeachStatement Inline(LinqCache cache, bool canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.SelectManyQuery : object {
    private IInvocationExpression myInvocation;
    private ICSharpExpression myEnumerable;
    private IType mySourceElementType;
    private IType myTargetElementType;
    private ICSharpExpression myCollectionSelector;
    private IType myResultElementType;
    private ICSharpExpression myResultSelector;
    private bool myWithIndex;
    private IPsiSourceFile mySourceFile;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsAsync { get; }
    public SelectManyQuery(bool isAsync, IInvocationExpression invocation, ICSharpExpression enumerable, IType sourceElementType, IType targetElementType, ICSharpExpression collectionSelector, IType resultElementType, ICSharpExpression resultSelector, bool withIndex);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    public sealed virtual IForeachStatement Inline(LinqCache cache, bool canInlineIteratorVar);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.SelectQuery : object {
    private IInvocationExpression myInvocation;
    private ICSharpExpression myEnumerable;
    private IType myEnumerableElementType;
    private ICSharpExpression mySelectExpr;
    private bool myWithIndex;
    private bool myIsAwait;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    private static IStructuralSearchPattern[] ourLetPatterns;
    private IPsiSourceFile myPsiSourceFile;
    public bool IsAsync { get; }
    public SelectQuery(bool isAsync, bool isAwait, IInvocationExpression invocation, ICSharpExpression enumerable, IType enumerableElementType, ICSharpExpression selectExpr, bool withIndex);
    private static SelectQuery();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    public sealed virtual IForeachStatement Inline(LinqCache cache, bool canInlineIteratorVar);
    private static bool IsAnonymousTypeFieldUse(IReferenceExpression expr, IParameter owner);
    private static void TransformLet(IDeclarationStatement declStatement);
    private static void RemoveRedundantCast(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.TakeWhileQuery : QueryWithCondition {
    private bool myIsAwait;
    public TakeWhileQuery(bool isAsync, bool isAwait, IInvocationExpression invocation, ICSharpExpression enumerable, IType enumerableElementType, ICSharpExpression condition, bool withIndex);
    protected virtual void ModifyLoopBody(IForeachStatement loop, ITypeOwner iteratorVar, string indexVarName);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.SequenceQueries.WhereQuery : QueryWithCondition {
    private bool myIsAwait;
    public WhereQuery(bool isAsync, bool isAwait, IInvocationExpression invocation, ICSharpExpression enumerable, IType enumerableElementType, ICSharpExpression condition, bool withIndex);
    protected virtual void ModifyLoopBody(IForeachStatement loop, ITypeOwner iteratorVar, string indexVarName);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.LinqTools.FromLinq.Transform : object {
    public static bool IsAvailableOnQuery(IQueryExpression query, LinqCache cache, IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
[PureAttribute]
private static IReturnStatement GetReturnStatementByValue(ICSharpExpression expression);
    private static bool CanConvertToSequenceQuery(IQueryExpression query, LinqCache cache);
    public static void TransformQuery(IQueryExpression query, LinqCache cache);
    public static bool IsAvailableOnInvocation(IInvocationExpression invocation, LinqCache cache);
    public static void TransformInvocation(IInvocationExpression invocation, LinqCache cache);
    private static void TransformLoop(IForeachStatement loop, bool canInlineIteratorVar, LinqCache cache);
    private static IInvocationExpression QueryToMethodChain(IQueryExpression query);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.LiveTemplates.CSharpTemplateUtil : object {
    private static void SetVarSetting(ISettingsStore settingsStore, Func`3<Lifetime, DataContexts, IDataContext> context, bool value);
    private static bool GetVarSetting(ISettingsStore settingsStore, Func`3<Lifetime, DataContexts, IDataContext> context);
    public static TemplateField CreateTypeTemplateField(IExpectedTypeConstraint typeConstraint, ICSharpTreeNode anchor, IType objType, bool canBeVar, bool canBeVoid, IPsiModule module);
    [ObsoleteAttribute]
public static void ExecuteTemplate(ISolution solution, ITextControl textControl, IExpectedTypeConstraint typeConstraint, TCSharpTreeNode templateFieldRangeNode, bool canBeVar, bool canBeVoid, DocumentRange endSelectionRange, Action postAction, IEnumerable`1<TCSharpTreeNode> additionalNodesForHotsposts);
    public static IBulbActionCommand ExecuteTemplate2(IExpectedTypeConstraint typeConstraint, TCSharpTreeNode templateFieldRangeNode, bool canBeVar, bool canBeVoid, Nullable`1<DocumentRange> endSelectionRange, IEnumerable`1<TCSharpTreeNode> additionalNodesForHotsposts);
}
[ObsoleteAttribute("To be removed")]
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "WhetherOrNotLiveTemplatesShouldUsevarInsteadOfASpecificTypeNameSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.LiveTemplates.LiveTemplatesUseVarSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "WhetherToUseVarInsteadOfTypeSettingDescription")]
[ObsoleteAttribute("To be removed")]
public bool UseVar;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "WhetherToUseVarInsteadOfTypeSettingDescription")]
[ObsoleteAttribute("To be removed")]
public bool PreferVar;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MacroDefinitionAttribute("nameOfEntity")]
public class JetBrains.ReSharper.Feature.Services.CSharp.LiveTemplates.Macros.Implementations.NameOfEntityMacroDef : SimpleMacroDefinition {
    public ParameterInfo[] Parameters { get; }
    public virtual ParameterInfo[] get_Parameters();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[MacroImplementationAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.LiveTemplates.Macros.Implementations.NameOfEntityMacroImpl : SimpleMacroImplementation {
    private IMacroParameterValueNew myArgument;
    private Nullable`1<bool> myCanUseNameof;
    public NameOfEntityMacroImpl(MacroParameterValueCollection arguments);
    [NullableContextAttribute("1")]
public virtual string EvaluateQuickResult(IHotspotContext context);
    [CompilerGeneratedAttribute]
internal static bool <EvaluateQuickResult>g__CanUseNameof|3_0(<>c__DisplayClass3_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.MatchingBrace.CSharpMatchingBraceProvider : object {
    public sealed virtual bool IsLeftBracket(TokenNodeType tokenType);
    public sealed virtual bool IsRightBracket(TokenNodeType tokenType);
    public sealed virtual bool Match(TokenNodeType token1, TokenNodeType token2);
    public sealed virtual int Compare(TokenNodeType x, TokenNodeType y);
}
[ActionAttribute("CSharpAutoNaming", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CSharpAutoNamingAction_Text")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.AutoNaming.CSharpAutoNamingAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[SolutionComponentAttribute("4")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.AutoNaming.CSharpAutoNamingCollector : object {
    public IProperty`1<CSharpAutoNamingCollectorState> State;
    [NotNullAttribute]
private IPsiFiles myPsiFiles;
    [NotNullAttribute]
private Lifetime mySolutionLifetime;
    [NotNullAttribute]
private PersistentIndexManager myIndexManager;
    [NotNullAttribute]
private SourcesTrigramIndex myTrigramIndex;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private IPsiCachesState myPsiCachesState;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private CSharpAutoNamingDetection myDetection;
    [NotNullAttribute]
private CSharpAutoNamingParameters myParameters;
    [NotNullAttribute]
private Random myRandom;
    private static String[] ourPrivateStaticQueries;
    private static String[] ourConstQueries;
    private static String[] ourPrivateConstQueries;
    private static String[] ourEventQueries;
    private static String[] ourEnumQueries;
    private static String[] ourInterfaceQueries;
    public CSharpAutoNamingCollector(ISolution solution, PersistentIndexManager indexManager, SourcesTrigramIndex trigramIndex, IPsiCachesState psiCachesState, CSharpAutoNamingParameters parameters, CSharpAutoNamingDetection detection, IPsiFiles psiFiles, ILogger logger);
    public CSharpAutoNamingCollector(ISolution solution, PersistentIndexManager indexManager, SourcesTrigramIndex trigramIndex, IPsiCachesState psiCachesState, CSharpAutoNamingParameters parameters, CSharpAutoNamingDetection detection, IPsiFiles psiFiles, ILogger logger, bool anyThing);
    private static CSharpAutoNamingCollector();
    public void Collect(bool isManual);
    private void CollectInner(bool isManual);
    private void TryHandleFilesAsync(IEnumerator`1<IPsiSourceFile> enumerator);
    private void HandleFile(IEnumerator`1<IPsiSourceFile> enumerator);
    private ISet`1<IPsiSourceFile> CollectFiles(Random random, List`1<IPsiSourceFile> allFiles, int maxFileCountFromIndexManager, int maxFileCountPerSpecificGroup);
    private static void AddExtraData(HashSet`1<IPsiSourceFile> files, TrigramIndex index, int maxCount, Random rnd, IEnumerable`1<string> queries, bool isWord);
    private static void AddPrivateStaticReadOnly(HashSet`1<IPsiSourceFile> files, TrigramIndex index, int count, Random rnd);
    private static void AddConst(HashSet`1<IPsiSourceFile> files, TrigramIndex index, int count, Random rnd);
    private static void AddPrivateConst(HashSet`1<IPsiSourceFile> files, TrigramIndex index, int count, Random rnd);
    private static void AddEvent(HashSet`1<IPsiSourceFile> files, TrigramIndex index, int count, Random rnd);
    private static void AddEnum(HashSet`1<IPsiSourceFile> files, TrigramIndex index, int count, Random rnd);
    private static void AddInterface(HashSet`1<IPsiSourceFile> files, TrigramIndex index, int count, Random rnd);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.Naming.AutoNaming.CSharpAutoNamingCollectorState : Enum {
    public int value__;
    public static CSharpAutoNamingCollectorState NotRunning;
    public static CSharpAutoNamingCollectorState Running;
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.AutoNaming.CSharpAutoNamingDetection : AutoNamingDetectionBase`1<NamedElementKinds> {
    [NotNullAttribute]
private CSharpAutoNamingValuesProvider myAutoNamingValuesProvider;
    private IContextBoundSettingsStore myMachineWideSettings;
    public CSharpAutoNamingDetection(Lifetime lifetime, IShellLocks locks, ISettingsStore settingsStore, ISolution solution, NamingManager namingManager, CSharpAutoNamingParameters parameters, CSharpAutoNamingValuesProvider autoNamingValuesProvider, ILogger logger);
    protected virtual bool IsNotificationEnabled();
    public virtual bool CanStartAutoDetection();
    private bool IsAutoDetectionCompleted();
    protected virtual void SetAutoDetectionAsCompleted();
    public virtual void DisableNotification();
    public virtual bool IsRuleDetectedFor(IDeclaredElement element);
    public virtual void Disable();
    public virtual void Enable();
    public virtual bool IsAutoDetectedValuesEnabled();
    protected virtual void PatchPolicyFor(NamedElementKinds kind, NamingPolicy policy);
    protected virtual void ResetDetectedRules();
    protected virtual bool IsAnyThingPatched();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.AutoNaming.CSharpAutoNamingGroupBuilder : TreeNodeVisitor {
    private Random myRandom;
    private IAutoNamingParameters`1<NamedElementKinds> myParameters;
    private OneToSetMap`2<NamedElementKinds, string> myGroups;
    public bool ProcessingIsFinished { get; }
    public CSharpAutoNamingGroupBuilder(Random random, IAutoNamingParameters`1<NamedElementKinds> parameters);
    public OneToSetMap`2<NamedElementKinds, string> BuildGroups(IPsiSourceFile file);
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public virtual void VisitFieldDeclaration(IFieldDeclaration fieldDeclarationParam);
    public virtual void VisitLocalFunctionDeclaration(ILocalFunctionDeclaration localFunctionDeclarationParam);
    public virtual void VisitEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclarationParam);
    public virtual void VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam);
    public virtual void VisitTypeMemberRegularParameterDeclaration(ITypeMemberRegularParameterDeclaration regularParameterDeclarationParam);
    public virtual void VisitLocalRegularParameterDeclaration(ILocalRegularParameterDeclaration localRegularParameterDeclarationParam);
    public virtual void VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam);
    public virtual void VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam);
    public virtual void VisitEventDeclaration(IEventDeclaration eventDeclarationParam);
    public virtual void VisitConstantDeclaration(IConstantDeclaration constantDeclarationParam);
    public virtual void VisitLocalConstantDeclaration(ILocalConstantDeclaration localConstantDeclarationParam);
    public virtual void VisitTypeParameterOfLocalFunctionDeclaration(ITypeParameterOfLocalFunctionDeclaration typeParameterOfLocalFunctionDeclarationParam);
    public virtual void VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam);
    public virtual void VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam);
    public virtual void VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam);
    public virtual void VisitStructDeclaration(IStructDeclaration structDeclarationParam);
    public virtual void VisitClassDeclaration(IClassDeclaration classDeclarationParam);
    public virtual void VisitRecordDeclaration(IRecordDeclaration recordDeclarationParam);
    public virtual void VisitClassLikeDeclaration(IClassLikeDeclaration classDeclarationParam);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    private void RegisterName(NamedElementKinds kind, string name);
    [CompilerGeneratedAttribute]
private bool <VisitClassLikeDeclaration>b__24_0(IMethodDeclaration t);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.AutoNaming.CSharpAutoNamingParameters : AutoNamingDefaultParameters`1<NamedElementKinds> {
    public virtual double GetMinimalCoverageForPrefix(NamedElementKinds kind);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.Naming.Settings.NamingSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CAutoNamingSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.AutoNaming.CSharpAutoNamingSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CAutoNamingNotificationStateSettingDescription")]
public bool IsNotificationDisabled;
}
[SolutionInstanceComponentAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.AutoNaming.CSharpAutoNamingValuesProvider : object {
    private static string Version;
    private static string DbName;
    private AutoDetectedValuesSettingsProvider myAutoDetectedValuesSettingsProvider;
    private OptimizedPersistentSortedMap`2<int, NamingPolicy> myAutoNamingValues;
    private static OneToListMap`2<NamedElementKinds, ValueTuple`2<Guid, ClrNamedElementDescriptor>> ourNamingStyleKindsToDefaultUserRules;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <Enabled>k__BackingField;
    protected IProperty`1<bool> Enabled { get; }
    public CSharpAutoNamingValuesProvider(Lifetime lifetime, ISolution solution, ISolutionCaches solutionCaches, ISettingsStore settingsStore, AutoDetectedValuesSettingsProvider autoDetectedValuesSettingsProvider);
    private static CSharpAutoNamingValuesProvider();
    [CompilerGeneratedAttribute]
protected IProperty`1<bool> get_Enabled();
    private void WriteNamingPolicy(UnsafeWriter writer, NamingPolicy value);
    private void WriteNamingRule(UnsafeWriter writer, NamingRule rule);
    private NamingPolicy ReadNamingPolicy(UnsafeReader reader);
    private NamingRule ReadNamingRule(UnsafeReader reader);
    public void InitializeSettings();
    public sealed virtual void InitializeSettings(IContextBoundSettingsStore settings);
    public void ResetSettings(bool clearCachedValue);
    public sealed virtual void ResetSettings(IContextBoundSettingsStore settings, bool clearCachedValue);
    public bool IsAutoDetectionCompleted();
    public void UpdateVersion();
    public void UpdateAutoDetectedValue(NamedElementKinds kind, NamingPolicy value);
    public bool IsAnyThingPatched();
    public bool IsRuleDetectedFor(NamedElementKinds kind);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1(PropertyChangedEventArgs`1<bool> t);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.CSharpNamingOptionsPage : NamingStylePage`1<CSharpNamingSettings> {
    [ObsoleteAttribute]
public static string PID;
    public CSharpNamingOptionsPage(Lifetime lifetime, OptionsSettingsSmartContext settings, IThemedIconManager uiIconsComponent, HighlightingSettingsManager manager, IAdvancedNamingSettingsFormFactory advancedNamingSettingsFormFactory, IComponentContainer container);
    private static NamedElementKinds[] GetSupportedElementKinds();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.Naming.ZoneMarker : object {
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Navigation.CSharpNavigateToExtendsList : object {
    public sealed virtual bool Navigate(ITypeElement sourceTypeElement, ITypeElement targetTypeElement);
    [CanBeNullAttribute]
private static IExtendsList GetExtendsList(IDeclaration declaration);
}
[OccurrenceProviderAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.Navigation.CSharpOccurrencesProvider : object {
    public sealed virtual IOccurrence MakeOccurrence(FindResult findResult);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Navigation.CSharpReferencedCodeSearchHelper : ReferencedCodeSearchHelperBase {
    public sealed virtual bool RemoveNamespaceImport(ITreeNode importNamespaceNode);
    public sealed virtual ICollection`1<NamespaceImportData> GetNamespaceImportsList(IFile file);
    public sealed virtual ICollection`1<Pair`2<IReference, IDeclaredElement>> GetUpdatedTargets(IReference reference, IDeclaredElement target);
    public sealed virtual IDeclaredElement ProvideDeclaredElementsFromResolve(IReference reference, IResolveResult resolveResult);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IReferenceName, INamespace> <GetNamespaceImportsList>g__GetTargetNamespace|1_0(IUsingDirective usingDirective);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Navigation.ExposingApies.CSharpExposingApiesTypeMemberFinder : object {
    public sealed virtual ITypeMember TryGetTypeMember(ITreeNode treeNode);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Navigation.GotoCodeBLock.CSharpCodeBlockProvider : object {
    public sealed virtual DocumentOffset TryGetCodeBlockStart(IFile file, DocumentOffset caretOffset);
    public sealed virtual DocumentOffset TryGetCodeBlockEnd(IFile file, DocumentOffset caretOffset);
    private static DocumentOffset TryGetCodeBlockBrace(IFile file, DocumentOffset caretOffset, bool moveToBlockStart);
    private static bool TryGetTargetOffset(ITokenNode lBrace, ITokenNode rBrace, DocumentOffset caretOffset, bool moveToBlockStart, bool caretOutsideLocation, DocumentOffset& targetOffset);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.NullableReferenceTypes.NullableReferenceTypesAnalysisUtil : object {
    [ExtensionAttribute]
public static void EnsureNullableAnalysisIsFinished(ICSharpTreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[MustUseReturnValueAttribute]
public static INullableDataFlowAnalysisResult GetTheNullableAnalysisResultsIfNotAnalyzed(ICSharpTreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNotNullValueExpression(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasAllNotNullComplexMemberAccess(ISubpattern subpattern, bool checkTopOne);
    [CompilerGeneratedAttribute]
internal static bool <HasAllNotNullComplexMemberAccess>g__IsNotNull|3_0(IReferenceExpression expression);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ThrowIfNull_Text", "2000", "False", "ArgumentNullException.ThrowIfNull(arg, nameof(arg));", "System.ArgumentNullException.ThrowIfNull($EXPR$, $NAME$);", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.ArgumentNullExceptionThrowIfNullPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CodeContract_Text", "200", "False", "Contract.Requires(arg != null, "arg != null");", "System.Diagnostics.Contracts.Contract.Requires($EXPR$ != null, $MESSAGE$);", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.ContractRequiresPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private static IMethod GetContractRequiresMethod(ITreeNode context);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.CSharpNullCheckUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static NullCheckFactory GetNullCheckFactory(ITreeNode context, bool isAssertionFactory);
    [NotNullAttribute]
[PureAttribute]
public static ICSharpExpression CreateNullCheckExpression(ITreeNode usageContext, ICSharpExpression operand, bool createEqualsNullCheck, bool onlyPredefinedNullCheck);
    [CanBeNullAttribute]
[PureAttribute]
public static IConditionalAccessExpression FindExpressionForInlineNullCheck(IParameter parameter, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpStatement FindParameterCheckAnchor(IBlock block, IParameterDeclaration parameterDeclaration, IParameter parameter, TreeNodeCollection`1<TParameterDeclaration> parameterDeclarations);
    [CanBeNullAttribute]
[PureAttribute]
private static ICSharpStatement FindCheckStatement(IBlock block, IParameter parameter, INullCheckPattern pattern);
    [PureAttribute]
private static bool IsNullCheck(ICSharpStatement statement, IParameter parameter, INullCheckPattern pattern);
    [CanBeNullAttribute]
[PureAttribute]
private static ICSharpExpression ExtractReturnValueFromSimpleBodyOwner(IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclaration);
}
[EditableNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CustomExpression_Text", "49", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.CustomExpressionBasedPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.CustomPatternUtil : object {
    [NotNullAttribute]
private static Regex ourPlaceholderRegex;
    [NotNullAttribute]
private static Regex ourCommentRegex;
    private static CustomPatternUtil();
    [NotNullAttribute]
[PureAttribute]
public static string GetPatternText(bool isExpressionBased, IContextBoundSettingsStore settingsStore);
    [NotNullAttribute]
[PureAttribute]
public static IProperty`1<string> GetPatternText(bool isExpressionBased, Lifetime lifetime, IContextBoundSettingsStoreLive settingsStore);
    [CanBeNullAttribute]
[PureAttribute]
public static string GetValidatedPatternText(ITreeNode context, bool isExpressionBased);
    [NotNullAttribute]
[PureAttribute]
public static IProperty`1<bool> CanUseForAssertion(bool isExpressionBased, Lifetime lifetime, IContextBoundSettingsStoreLive settings);
    [PureAttribute]
public static bool CanUseForAssertion(bool isExpressionBased, IContextBoundSettingsStore settings);
    [NotNullAttribute]
[PureAttribute]
public static ITreeNode TransformPattern(string patternText, NullCheckOperand nullCheckOperand, ITreeNode context, CSharpElementFactory factory, bool isExpression);
    [NotNullAttribute]
[PureAttribute]
public static PatternValidationResult ValidatePattern(string patternText, bool isExpressionBased);
    [NotNullAttribute]
[PureAttribute]
public static string GetExample(string patternText);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("notnull => notnull; null => null")]
private static string DeleteComments(string patternText);
    [NotNullAttribute]
[PureAttribute]
private static ICSharpParser GetParserFor(string text);
    [PureAttribute]
private static bool HasMoreTextThanParsed(string text, ITreeNode parsedNode);
    [NotNullAttribute]
[PureAttribute]
public static TTreeNode Simplify(NullCheckOperand nullCheckOperand, TTreeNode node, ITreeNode context);
    private static void ShortenQualifiedReferences(ITreeNode node, Boolean& hasExtensionMethods);
    [PureAttribute]
private static bool ShouldResetInvocationQualifier(IMethod method, IReferenceExpression invokedExpression);
    private static void InvokeAsExtensionMethods(ITreeNode node);
    [PureAttribute]
private static bool CanBeInvokedAsExtensionMethod(IInvocationExpression invocationExpression, DeclaredElementInstance`1<IMethod> method);
    [PureAttribute]
public static Nullable`1<NullCheckOperand> MatchNullCheckOperand(ITreeNode node, string patternText, bool isExpressionBased);
    [CanBeNullAttribute]
[PureAttribute]
private static TTreeNode DeSimplify(TTreeNode originalNode);
    [NotNullAttribute]
[PureAttribute]
private static IReferenceExpression CreateQualifiedReference(CSharpElementFactory factory, DeclaredElementInstance memberInstance);
    [NotNullAttribute]
[PureAttribute]
private static IReferenceName CreateQualifiedReferenceName(CSharpElementFactory factory, DeclaredElementInstance`1<ITypeElement> memberInstance);
    [CompilerGeneratedAttribute]
internal static void <ShortenQualifiedReferences>g__InsertFirstArgumentMadeFromQualifier|14_0(IReferenceExpression invokedExpression, IMethod extensionMethod);
}
[EditableNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CustomStatement_Text", "50", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.CustomStatementBasedPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "DebugAssert_Text", "100", "True", "Debug.Assert(arg != null, "arg != null");", "System.Diagnostics.Debug.Assert($EXPR$ != null, $MESSAGE$);", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.DebugAssertPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private static IMethod GetDebugAssertMethod(ITreeNode context);
}
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.INullCheckPattern")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.EditableNullCheckPatternAttribute : NullCheckPatternAttribute {
    public EditableNullCheckPatternAttribute(Type nameResourceType, string nameResourceName, int defaultPriority, Instantiation instantiation);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CodeContractGeneric_Text", "199", "False", "Contract.Requires<ArgumentNullException>(arg != null, "arg != null");", "System.Diagnostics.Contracts.Contract.Requires<System.ArgumentNullException>($EXPR$ != null, $MESSAGE$);", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.GenericContractRequiresPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private static DeclaredElementInstance`1<IMethod> GetContractRequiresMethod(ITreeNode context);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ReferenceEquals_Text", "500", "False", "if (ReferenceEquals(arg, null)) throw new ArgumentNullException(nameof(arg));", "if (ReferenceEquals($EXPR$, null)) throw new System.ArgumentNullException($NAME$);", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.IfReferenceEqualsThenThrowPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    [PureAttribute]
[CanBeNullAttribute]
private static ITypeMember GetReferenceEqualsMethod(ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "Classic_Text", "3000", "False", "if (arg == null) throw new ArgumentNullException(nameof(arg));", "if ($EXPR$ == null) throw new System.ArgumentNullException($NAME$);", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.IfThenThrowPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.IfThenThrowPatternUtil : object {
    [PureAttribute]
public static ValueTuple`2<TConditionExpression, IThrowStatement> Match(ICSharpStatement statement);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.InlineNullCheckHelper : object {
    [CanBeNullAttribute]
[PureAttribute]
public static IAssignmentExpression FindInlineTarget(QualifiedAccess inlineSource, IStatementsOwner statementsOwner, int startStatementIndex);
    [CanBeNullAttribute]
[PureAttribute]
public static IAssignmentExpression FindInlineTarget(NullCheckOperand inlineSource, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
private static IAssignmentExpression FindInlineTarget(InlineSource inlineSource, IStatementsOwner statementsOwner, int startStatementIndex);
    [CanBeNullAttribute]
[PureAttribute]
private static IAssignmentExpression FindInlineTarget(InlineSource inlineSource, ICSharpExpression expressionBody);
    [PureAttribute]
private static bool HasSourceUsages(ITreeNode node, InlineSource inlineSource);
    private static bool HasMoreThanNUsages(ITreeNode node, InlineSource inlineSource, int n);
    [CanBeNullAttribute]
[PureAttribute]
private static IStatementsOwner GetStatementsOwnerOf(NullCheckOperand nullCheckOperand, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
private static ICSharpExpression GetExpressionBody(NullCheckOperand nullCheckOperand, ITreeNode context);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.INullCheckPattern {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    [PureAttribute]
public abstract virtual bool IsAvailable(ITreeNode context);
    public abstract virtual bool get_IsExpressionBasedCheck();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    [PureAttribute]
public abstract virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    [PureAttribute]
public abstract virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
    public abstract virtual bool get_CanCompareWithNull();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NotNullAssertionPatternUtil : object {
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("method: null => null")]
public static IConditionalAccessExpression ExtractOperand(ICSharpStatement statement, IMethod method);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("method: null => null")]
public static IConditionalAccessExpression ExtractOperand(ICSharpStatement statement, DeclaredElementInstance`1<IMethod> method);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("method: null => null")]
public static TExpression ExtractFirstArgument(ICSharpStatement statement, DeclaredElementInstance`1<IMethod> method);
    [CanBeNullAttribute]
[PureAttribute]
public static IInvocationExpression ExtractInvocation(ICSharpStatement statement);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static TExpression ExtractFirstArgument(IInvocationExpression invocationExpression);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static DeclaredElementInstance`1<IMethod> GetInvokedMethod(IInvocationExpression invocationExpression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckFactory : object {
    [NotNullAttribute]
private ITreeNode myContext;
    [CompilerGeneratedAttribute]
private INullCheckPattern <StatementBasedPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private INullCheckPattern <ExpressionBasedPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExpressionFormPreferred>k__BackingField;
    [NotNullAttribute]
public INullCheckPattern StatementBasedPattern { get; }
    [CanBeNullAttribute]
public INullCheckPattern ExpressionBasedPattern { get; }
    public bool IsExpressionFormPreferred { get; }
    internal NullCheckFactory(ITreeNode context, INullCheckPattern statementBasedPattern, INullCheckPattern expressionBasedPattern, bool isExpressionFormPreferred);
    [CompilerGeneratedAttribute]
public INullCheckPattern get_StatementBasedPattern();
    [CompilerGeneratedAttribute]
public INullCheckPattern get_ExpressionBasedPattern();
    [CompilerGeneratedAttribute]
public bool get_IsExpressionFormPreferred();
    [NotNullAttribute]
[PureAttribute]
public ICSharpStatement CreateStatement(NullCheckOperand operand);
    [NotNullAttribute]
[PureAttribute]
public ICSharpExpression CreateExpression(NullCheckOperand operand);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckOperand : ValueType {
    [NotNullAttribute]
private object myOperand;
    [CanBeNullAttribute]
public ITypeOwner DeclaredElement { get; }
    [CanBeNullAttribute]
public ICSharpExpression SourceExpression { get; }
    public NullCheckOperand(ITypeOwner declaredElement);
    public NullCheckOperand(ICSharpExpression sourceExpression);
    public ITypeOwner get_DeclaredElement();
    public ICSharpExpression get_SourceExpression();
    [NotNullAttribute]
[PureAttribute]
public ICSharpExpression ToExpression(CSharpElementFactory factory);
    [NotNullAttribute]
[PureAttribute]
public ICSharpExpression ToNameExpression(ITreeNode context, CSharpElementFactory factory);
    [NotNullAttribute]
[PureAttribute]
public ICSharpExpression ToNotNullMessage(ITreeNode context, CSharpElementFactory factory);
    [PureAttribute]
private static bool IsReferenceExpressionWeCanNameof(ICSharpExpression sourceExpression);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckPatternAttribute : ComponentAttribute {
    [CompilerGeneratedAttribute]
private string <PatternName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultPriority>k__BackingField;
    [NotNullAttribute]
public string PatternName { get; }
    public int DefaultPriority { get; }
    protected NullCheckPatternAttribute(Type nameResourceType, string nameResourceName, int defaultPriority, Instantiation instantiation);
    [CompilerGeneratedAttribute]
public string get_PatternName();
    [CompilerGeneratedAttribute]
public int get_DefaultPriority();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckPatternDescriptor : object {
    [CompilerGeneratedAttribute]
private INullCheckPattern <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private NullCheckPatternAttribute <Annotation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SettingsKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEditable>k__BackingField;
    [NotNullAttribute]
public INullCheckPattern Pattern { get; }
    [NotNullAttribute]
public NullCheckPatternAttribute Annotation { get; }
    [NotNullAttribute]
public string SettingsKey { get; }
    public bool IsEditable { get; }
    public NullCheckPatternDescriptor(INullCheckPattern pattern, NullCheckPatternAttribute annotation);
    [CompilerGeneratedAttribute]
public INullCheckPattern get_Pattern();
    [CompilerGeneratedAttribute]
public NullCheckPatternAttribute get_Annotation();
    [CompilerGeneratedAttribute]
public string get_SettingsKey();
    [CompilerGeneratedAttribute]
public bool get_IsEditable();
    [PureAttribute]
public bool CanUseForAssertion(IContextBoundSettingsStore settings);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckPatternPlaceholders : object {
    [NotNullAttribute]
public static string Expression;
    [NotNullAttribute]
public static string Name;
    [NotNullAttribute]
public static string Message;
    [NotNullAttribute]
public static string ExpressionRaw;
    [NotNullAttribute]
public static string NameRaw;
    [NotNullAttribute]
public static string MessageRaw;
    [NotNullAttribute]
public static String[] All;
    private static NullCheckPatternPlaceholders();
}
[ShellComponentAttribute("10")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckPatternsManager : object {
    [NotNullAttribute]
private IReadOnlyList`1<NullCheckPatternDescriptor> myNullCheckPatterns;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<NullCheckPatternDescriptor> Patterns { get; }
    public NullCheckPatternsManager(Lifetime lifetime, ShellPartCatalogSet catalogSet, IComponentContainer componentContainer);
    public IReadOnlyList`1<NullCheckPatternDescriptor> get_Patterns();
    [PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<NullCheckPatternDescriptor> GetSortedPatterns(ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public NullCheckFactory GetNullCheckFactory(ITreeNode context, bool isAssertionFactory);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<NullCheckPatternDescriptor> GetSortedPatterns(IContextBoundSettingsStore settingsStore);
    [PureAttribute]
private static int GetPatternPriority(NullCheckPatternDescriptor patternDescriptor, NullCheckPatternsSettings settingsKey);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeEditingSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "NullCheckPatternsSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckPatternsSettings : object {
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "PriorityOfNullCheckingPatternsSettingDescription")]
public IIndexedEntry`2<string, int> PatternTypeNamesToPriority;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "NullCheckPatternsSettings_CustomStatementPatternText_Description")]
public string CustomStatementPatternText;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "NullCheckPatternsSettings_CustomExpressionPatternText_Description")]
public string CustomExpressionPatternText;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CanUseCustomStatementBasedPatternForAssertionSettingDescription")]
public bool CanUseCustomStatementPatternForAssertion;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CanUseCustomExpressionBasedPatternForAssertionSettingDescription")]
public bool CanUseCustomExpressionPatternForAssertion;
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckPatternsSettingsAccessor : object {
    [NotNullAttribute]
public static Expression`1<Func`2<NullCheckPatternsSettings, IIndexedEntry`2<string, int>>> PatternTypeNamesToPriority;
    [NotNullAttribute]
public static Expression`1<Func`2<NullCheckPatternsSettings, string>> CustomStatementPatternText;
    [NotNullAttribute]
public static Expression`1<Func`2<NullCheckPatternsSettings, string>> CustomExpressionPatternText;
    [NotNullAttribute]
public static Expression`1<Func`2<NullCheckPatternsSettings, bool>> CanUseCustomStatementPatternForAssertion;
    [NotNullAttribute]
public static Expression`1<Func`2<NullCheckPatternsSettings, bool>> CanUseCustomExpressionPatternForAssertion;
    private static NullCheckPatternsSettingsAccessor();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.NullCheckWithThrowPattern : object {
    [NotNullAttribute]
private IIfStatement myNullCheckStatement;
    [NotNullAttribute]
private QualifiedCheckAccess myNullCheck;
    [NotNullAttribute]
private IThrowStatement myThrowStatement;
    private bool myIsAnalyzed;
    private UseThrowExpressionSuggestion myResult;
    [CanBeNullAttribute]
private IAssignmentExpression myAssignmentExpression;
    [NotNullAttribute]
public IIfStatement NullCheckStatement { get; }
    public TreeTextRange SuggestionTextRange { get; }
    public TreeTextRange ActionTextRange { get; }
    private NullCheckWithThrowPattern(IIfStatement nullCheckStatement, QualifiedCheckAccess nullCheck, IThrowStatement throwStatement);
    public IIfStatement get_NullCheckStatement();
    public TreeTextRange get_SuggestionTextRange();
    public TreeTextRange get_ActionTextRange();
    [CanBeNullAttribute]
[PureAttribute]
public static NullCheckWithThrowPattern TryBuild(ICSharpStatement statement);
    public UseThrowExpressionSuggestion IsAvailable();
    public void Transform(CSharpElementFactory factory);
    private bool NotAvailable();
    private bool AnalyzeAvailability();
    private bool IsGoodEnoughToSuggest();
    [NotNullAttribute]
[PureAttribute]
private ICSharpExpression GetNullCheckedExpression(CSharpElementFactory factory);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "PatternMatchingC70_Text", "1000", "False", "if (arg is null) throw new ArgumentNullException(nameof(arg));", "if ($EXPR$ is null) throw new System.ArgumentNullException($NAME$);", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.PatternMatchingIfThenThrowPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.PatternValidationResult : object {
    [NotNullAttribute]
public static PatternValidationResult Ok;
    [NotNullAttribute]
public static PatternValidationResult Empty;
    [NotNullAttribute]
public static PatternValidationResult SyntaxError;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public bool IsValid { get; }
    [NotNullAttribute]
public string Message { get; }
    private PatternValidationResult(bool isValid, string message);
    private static PatternValidationResult();
    [NotNullAttribute]
[PureAttribute]
public static PatternValidationResult InvalidPlaceholder(string name);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public string get_Message();
}
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.INullCheckPattern")]
[MeansImplicitUseAttribute]
[PublicAPIAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.ReadOnlyNullCheckPatternAttribute : NullCheckPatternAttribute {
    [CompilerGeneratedAttribute]
private bool <CanUseForAssertion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Example>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public bool CanUseForAssertion { get; private set; }
    [NotNullAttribute]
public string Example { get; private set; }
    [NotNullAttribute]
public string Pattern { get; private set; }
    public ReadOnlyNullCheckPatternAttribute(Type nameResourceType, string nameResourceName, int defaultPriority, bool canUseForAssertion, string example, string pattern, Instantiation instantiation);
    [CompilerGeneratedAttribute]
public bool get_CanUseForAssertion();
    [CompilerGeneratedAttribute]
private void set_CanUseForAssertion(bool value);
    [CompilerGeneratedAttribute]
public string get_Example();
    [CompilerGeneratedAttribute]
private void set_Example(string value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
private void set_Pattern(string value);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ThrowExpressionC70_Text", "5000", "False", "arg ?? throw new ArgumentNullException(nameof(arg))", "$EXPR$ ?? throw new System.ArgumentNullException($NAME$)", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.ThrowExpressionNullCheckPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
}
[ReadOnlyNullCheckPatternAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "TraceAssert_Text", "99", "True", "Trace.Assert(arg != null, "arg != null");", "System.Diagnostics.Trace.Assert($EXPR$ != null, $MESSAGE$);", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.TraceAssertPattern : object {
    public bool IsExpressionBasedCheck { get; }
    public bool CanCompareWithNull { get; }
    public sealed virtual bool get_IsExpressionBasedCheck();
    public sealed virtual bool get_CanCompareWithNull();
    public sealed virtual bool IsAvailable(ITreeNode context);
    public sealed virtual ICSharpStatement CreateCheckStatement(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCheckExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual ICSharpExpression CreateCompareWithNullExpression(NullCheckOperand operand, ITreeNode context);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckStatement(ICSharpStatement statement);
    public sealed virtual Nullable`1<NullCheckOperand> MatchCheckExpression(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private static IMethod GetTraceAssertMethod(ITreeNode context);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.UseThrowExpressionSuggestion : Enum {
    public int value__;
    public static UseThrowExpressionSuggestion NotAvailable;
    public static UseThrowExpressionSuggestion Available;
    public static UseThrowExpressionSuggestion Suggested;
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.NullChecking.WellKnownPatternsDefaultPriority : object {
    public static int ThrowExpression;
    public static int IfThenThrow;
    public static int Net6ThrowIfNull;
    public static int PatternMatchingIfThenThrow;
    public static int IfReferenceEqualsThenThrow;
    public static int ContractRequires;
    public static int GenericContractRequires;
    public static int DebugAssert;
    public static int TraceAssert;
    public static int CustomStatement;
    public static int CustomExpression;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.OptionPages.BeEditNamingPolicySchema : object {
    [CompilerGeneratedAttribute]
private IListEvents`1<NamingPolicyProps> <Policies>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <EnableInspections>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <WarnAboutUsingPrefixesAndSuffixesFromThisRule>k__BackingField;
    private IProperty`1<int> mySelectedPolicyPosition;
    private string myRuleName;
    private IList`1<UserFriendlySettingsLayer> myLayers;
    private UserFriendlySettingsLayer myDefaultLayer;
    private Action`2<NamingPolicy, IContextBoundSettingsStore> mySaveRuleAction;
    private IListEvents`1<NamingPolicyProps> Policies { get; }
    private IProperty`1<bool> EnableInspections { get; }
    private IProperty`1<bool> WarnAboutUsingPrefixesAndSuffixesFromThisRule { get; }
    public NamingPolicy NamingPolicy { get; }
    public BeEditNamingPolicySchema(NamingPolicy policyToChange, string ruleName, IList`1<UserFriendlySettingsLayer> layers, UserFriendlySettingsLayer defaultLayer, Action`2<NamingPolicy, IContextBoundSettingsStore> saveRule);
    [CompilerGeneratedAttribute]
private IListEvents`1<NamingPolicyProps> get_Policies();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_EnableInspections();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_WarnAboutUsingPrefixesAndSuffixesFromThisRule();
    public NamingPolicy get_NamingPolicy();
    private BeControl GetNavigationButtonsGrid(Lifetime lifetime, BeTreeGrid table, bool isEnabled);
    private bool TrySwapValuesAt(int lowerPosition, int higherPosition);
    private void RemoveValueHandler(IList`1<BeTreeGridLine> elements);
    private BeControl GetPrefixEditor(Lifetime lifetime, bool isEnabled);
    private BeControl GetSuffixEditor(Lifetime lifetime, bool isEnabled);
    private List`1<string> GetStyleNames();
    private BeControl GetStyleEditor(Lifetime lifetime, bool isEnabled);
    private string GetShortNamingRulePresentation(NamingPolicyProps namingPolicyProps, bool addDefault);
    private BeControl GetValuesPresentation(Lifetime lifetime, bool isEnabled);
    public BeDialog GetPresentation(Lifetime lifetime);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.OptionPages.BeEditNamingRuleSchema : object {
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private IListEvents`1<NamingPolicyProps> <Policies>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <EnableInspections>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <WarnAboutUsingPrefixesAndSuffixesFromThisRule>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <StaticMemberTypesAndNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <InstanceMembersAndLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <PrivateAccessRight>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <ProtectedAccessRight>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <InternalAccessRight>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <PublicAccessRight>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <ProtectedInternalAccessRight>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <PrivateProtectedAccessRight>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <FileLocalAccessRight>k__BackingField;
    private IDictionary`2<IElementKind, IProperty`1<Nullable`1<bool>>> mySelectedElementKinds;
    private IElementKindSet myInitialElementKinds;
    private PsiLanguageType myLanguageType;
    private IProperty`1<int> mySelectedPolicyPosition;
    public IProperty`1<string> Description { get; }
    private IListEvents`1<NamingPolicyProps> Policies { get; }
    private IProperty`1<bool> EnableInspections { get; }
    private IProperty`1<bool> WarnAboutUsingPrefixesAndSuffixesFromThisRule { get; }
    private IProperty`1<bool> StaticMemberTypesAndNamespaces { get; }
    private IProperty`1<bool> InstanceMembersAndLocals { get; }
    private IProperty`1<bool> PrivateAccessRight { get; }
    private IProperty`1<bool> ProtectedAccessRight { get; }
    private IProperty`1<bool> InternalAccessRight { get; }
    private IProperty`1<bool> PublicAccessRight { get; }
    private IProperty`1<bool> ProtectedInternalAccessRight { get; }
    private IProperty`1<bool> PrivateProtectedAccessRight { get; }
    private IProperty`1<bool> FileLocalAccessRight { get; }
    public StaticnessKinds Staticness { get; }
    public NamingPolicy NamingPolicy { get; }
    public AccessRightKinds AccessRightKinds { get; }
    public IElementKindSet ElementKinds { get; }
    public BeEditNamingRuleSchema(ClrUserDefinedNamingRule rule, PsiLanguageType languageType);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_Description();
    [CompilerGeneratedAttribute]
private IListEvents`1<NamingPolicyProps> get_Policies();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_EnableInspections();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_WarnAboutUsingPrefixesAndSuffixesFromThisRule();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_StaticMemberTypesAndNamespaces();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_InstanceMembersAndLocals();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_PrivateAccessRight();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_ProtectedAccessRight();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_InternalAccessRight();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_PublicAccessRight();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_ProtectedInternalAccessRight();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_PrivateProtectedAccessRight();
    [CompilerGeneratedAttribute]
private IProperty`1<bool> get_FileLocalAccessRight();
    public StaticnessKinds get_Staticness();
    public NamingPolicy get_NamingPolicy();
    public AccessRightKinds get_AccessRightKinds();
    public IElementKindSet get_ElementKinds();
    private BeControl GetNavigationButtonsGrid(Lifetime lifetime, BeTreeGrid table, bool isEnabled);
    private bool TrySwapValuesAt(int lowerPosition, int higherPosition);
    private void RemoveValueHandler(IList`1<BeTreeGridLine> elements);
    private BeControl GetPrefixEditor(Lifetime lifetime, bool isEnabled);
    private BeControl GetSuffixEditor(Lifetime lifetime, bool isEnabled);
    private List`1<string> GetStyleNames();
    private BeControl GetStyleEditor(Lifetime lifetime, bool isEnabled);
    private string GetShortNamingRulePresentation(NamingPolicyProps namingPolicyProps, bool addDefault);
    private BeControl GetValuesPresentation(Lifetime lifetime, bool isEnabled);
    private BeControl GetAccessRightsPresentation(Lifetime lifetime, bool isEnabled);
    private IList`1<IElementKind> GetAvailableElementKinds();
    private BeControl GetEntitiesSelectionTable(Lifetime lifetime, bool isEnabled);
    private static IEnumerable`1<IElementKind> GetRootElementKinds(IEnumerable`1<IElementKind> allKinds);
    private static IDictionary`2<IElementKind, List`1<IElementKind>> GetChildrenMapForElementKinds(IList`1<IElementKind> allKinds);
    public BeControl GetPresentation(Lifetime lifetime, bool isEnabled);
    [CompilerGeneratedAttribute]
private void <get_ElementKinds>g__Recursive|47_0(IElementKind kind, <>c__DisplayClass47_0& );
    [CompilerGeneratedAttribute]
private void <GetPresentation>b__66_0(string s);
}
[OptionsPageAttribute("CSharpInlayHintsOptions", "C#", "JetBrains.ReSharper.Feature.Services.Resources.CommonFeaturesOptionsThemedIcons/CsharpOptionPage")]
public class JetBrains.ReSharper.Feature.Services.CSharp.OptionPages.CSharpInlayHintsPage : BeSimpleOptionsPage {
    public static string PID;
    public CSharpInlayHintsPage(Lifetime lifetime, OptionsPageContext optionsPageContext, OptionsSettingsSmartContext optionsSettingsSmartContext, bool wrapInScrollablePanel);
}
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OptionsPageAttribute("CSharpNamingStylePage3", "Naming Style New", "JetBrains.ReSharper.Feature.Services.Resources.FeaturesEnvironmentOptionsThemedIcons/NamingConvention")]
public class JetBrains.ReSharper.Feature.Services.CSharp.OptionPages.CSharpNamingOptionsPage2 : BeSimpleOptionsPage {
    public static string PID;
    private PsiLanguageType myLanguageType;
    private Property`1<RuleItem> mySelectedValue;
    private IDictionary`2<RuleItem, ValueTuple`3<BeLabel, BeLabel, BeLabel>> myRulePresentations;
    private IDialogHost myDialogHost;
    private IIconHost myIconHost;
    public CSharpNamingOptionsPage2(Lifetime lifetime, OptionsPageContext optionsPageContext, OptionsSettingsSmartContext optionsSettingsSmartContext, HighlightingSettingsManager manager, IComponentContainer container, bool wrapInScrollablePanel);
}
[OptionsPageAttribute("Csharp", "C#", "JetBrains.ReSharper.Feature.Services.Resources.CommonFeaturesOptionsThemedIcons/CsharpOptionPage")]
public class JetBrains.ReSharper.Feature.Services.CSharp.OptionPages.CsharpPage : AEmptyOptionsPage {
    public static string PID;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.OptionPages.EditAbbreviationsSchema : object {
    public IListEvents`1<string> Abbreviations;
    private IProperty`1<int> mySelectedIndex;
    public EditAbbreviationsSchema(IEnumerable`1<string> abbreviations);
    public BeControl GetPresentation(Lifetime lifetime);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.OptionPages.NamingPolicyProps : ValueType {
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<NamingStyleKinds> <Value>k__BackingField;
    public IProperty`1<string> Prefix { get; public set; }
    public IProperty`1<string> Suffix { get; public set; }
    public IProperty`1<NamingStyleKinds> Value { get; public set; }
    public NamingPolicyProps(IProperty`1<string> Prefix, IProperty`1<string> Suffix, IProperty`1<NamingStyleKinds> Value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_Suffix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Suffix(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<NamingStyleKinds> get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(IProperty`1<NamingStyleKinds> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NamingPolicyProps left, NamingPolicyProps right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NamingPolicyProps left, NamingPolicyProps right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NamingPolicyProps other);
    [CompilerGeneratedAttribute]
public void Deconstruct(IProperty`1& Prefix, IProperty`1& Suffix, IProperty`1& Value);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.OptionPages.ZoneMarker : object {
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.CollectionElementInitializerCandidate : ParameterInfoCandidate {
    public CollectionElementInitializerCandidate(ISolution solution, PsiLanguageType language, InvocationCandidate invocationCandidate, int positionalParameterCount);
    protected virtual RichText GetSignatureInternal(String[] namedArguments, ParameterInfoSettings settings, TextRange[]& parameterRanges, TextRange& returnTypeRange, Int32[]& mapToOriginalOrder, ExtensionMethodInfo& extensionMethodInfo, RichText[]& annotations);
    protected virtual DeclaredElementPresenterStyle GetStyles(IParametersOwner parametersOwner);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.CSCollectionInitializerInfoContext : CSParameterInfoContext {
    public CSCollectionInitializerInfoContext(CsParameterInfoInvocationContext invocationContext, Converter`2<InvocationCandidate, ICandidate> candidateConverter, int parameter, DocumentRange range, int selectedInvocable, ParameterInfoSettings settings);
    protected virtual string GetSortString(ICandidate candidate);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.CSObjectInitializerContext : CSParameterInfoContext {
    [CanBeNullAttribute]
private ICandidate myObjectInitializerCandidate;
    private List`1<CollectionElementInitializerCandidate> myMethodCandidates;
    private ICandidate[] mySortedCandidates;
    [NotNullAttribute]
public ICandidate[] Candidates { get; }
    public CSObjectInitializerContext(ObjectInitializerCandidate candidate, List`1<CollectionElementInitializerCandidate> candidates, int parameter, DocumentRange contextRange, ITreeNode initializer, ParameterInfoSettings settings);
    private void UpdateNameArguments(TreeNodeCollection`1<TNode> memberInitializers, Func`2<TNode, string> getNameFunc);
    private static int FixParameterNumber(ITreeNode initializer, int parameter);
    [NotNullAttribute]
private static ICandidate[] AllCandidates(ObjectInitializerCandidate candidate, IList`1<CollectionElementInitializerCandidate> candidates);
    private static int SelectInvocableAndFilter(ITreeNode initializer, int parameter, ObjectInitializerCandidate objectCandidate, IList`1<CollectionElementInitializerCandidate> collectionElementCandidates);
    public virtual ICandidate[] get_Candidates();
    [CompilerGeneratedAttribute]
private int <get_Candidates>b__9_0(CollectionElementInitializerCandidate x, CollectionElementInitializerCandidate y);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.CSParameterInfoContext : ParameterInfoContextBase {
    internal CSParameterInfoContext(ICandidate[] candidates, int parameter, DocumentRange range, int selectedInvocable, Type parameterListNodeType, ParameterInfoSettings settings, Type[] parameterNodeTypes);
    internal CSParameterInfoContext(ICandidate[] candidates, int parameter, DocumentRange range, int selectedInvocable, ParameterInfoSettings settings);
    internal CSParameterInfoContext(CsParameterInfoInvocationContext invocationContext, Converter`2<InvocationCandidate, ICandidate> candidateConverter, int parameter, DocumentRange range, int selectedInvocable, ParameterInfoSettings settings);
    public void FilterOut(CsParameterInfoInvocationContext invocationContext);
}
[ParameterInfoContextFactoryAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.CSParameterInfoContextFactory : object {
    private static Char[] POPUP_CHARS;
    private static Char[] IMPORTANT_CHARS;
    public PsiLanguageType Language { get; }
    public IEnumerable`1<char> ImportantChars { get; }
    private static CSParameterInfoContextFactory();
    public sealed virtual bool IsIntellisenseEnabled(ISolution solution, IContextBoundSettingsStore settingsStore);
    public sealed virtual IParameterInfoContext CreateContext(ISolution solution, DocumentOffset caretOffset, DocumentOffset expectedLParenthOffset, char invocationChar, IContextBoundSettingsStore settingsStore);
    [NotNullAttribute]
private static IParameterInfoContext CreateCollectionElementInitializerContext(ISolution solution, DocumentOffset caretOffset, CsParameterInfoInvocationContext invocationContext, ParameterInfoSettings parameterInfoSettings);
    [NotNullAttribute]
private static IParameterInfoContext CreateAttributeContext(ISolution solution, DocumentOffset caretOffset, CsParameterInfoInvocationContext invocationContext, ParameterInfoSettings parameterInfoSettings);
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual IEnumerable`1<char> get_ImportantChars();
    public sealed virtual bool ShouldPopup(DocumentOffset caretOffset, char c, ISolution solution, IContextBoundSettingsStore settingsStore);
    [CanBeNullAttribute]
public IParameterInfoContext CreateParameterContext(ISolution solution, DocumentOffset caretOffset, CsParameterInfoInvocationContext invocationContext, ParameterInfoSettings parameterInfoSettings);
    private static int GetParameterNumber(CsParameterInfoInvocationContext invocationContext, DocumentOffset caretOffset);
    private static int GetParametersBetweenBraces(ITreeNode nodeWithBraces, DocumentOffset caretOffset, ITokenNode lBrace, ITokenNode rBrace, TreeNodeEnumerable`1<ITokenNode> commas, DocumentRange& contextRange);
    private static int GetInitializerParameters(ICreationExpressionInitializer initializer, DocumentOffset caretOffset, DocumentRange& contextRange);
    [CanBeNullAttribute]
private static IParameterInfoContext TryCreateInitializerContext(ISolution solution, ITokenNode node, DocumentOffset caretOffset, ParameterInfoSettings parameterInfoSettings);
    [CanBeNullAttribute]
private static IParameterInfoContext TryCreateWithExpressionContext(ISolution solution, ITokenNode node, DocumentOffset caretOffset, ParameterInfoSettings parameterInfoSettings);
    [CanBeNullAttribute]
private static IParameterInfoContext TryCreateRecursiveSubpatternContext(ISolution solution, ITokenNode node, DocumentOffset caretOffset, ParameterInfoSettings parameterInfoSettings);
    [CanBeNullAttribute]
private static IParameterInfoContext TryCreateAnonymousObjectContext(ISolution solution, ITokenNode node, DocumentOffset caretOffset, ParameterInfoSettings parameterInfoSettings);
    [NullableContextAttribute("1")]
private static IParameterInfoContext TryCreateListItemContext(ISolution solution, ITokenNode node, DocumentOffset caretOffset, ParameterInfoSettings settings);
    [NullableContextAttribute("1")]
private static IParameterInfoContext TryCreateDeconstructionContext(ISolution solution, ITokenNode node, DocumentOffset caretOffset, ParameterInfoSettings parameterInfoSettings);
    [NullableContextAttribute("1")]
private static ITokenNode FixAnchor(ITokenNode tokenNode);
    [NullableContextAttribute("1")]
private static DeconstructionCandidate[] TryGetDeconstructionCandidates(ISolution solution, ICSharpExpression expression);
    [NullableContextAttribute("1")]
private static DeconstructionCandidate[] TryGetDeconstructionCandidates(ISolution solution, IPattern pattern);
    [NullableContextAttribute("1")]
private static DeconstructionCandidate[] TryGetDeconstructionCandidates(ISolution solution, IParenthesizedVariableDesignation parenthesizedVariableDesignation);
    [NullableContextAttribute("1")]
private static DeconstructionCandidate[] TryGetTupleCandidates(ISolution solution, ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.CsParameterInfoInvocationContext : object {
    private InvocationCandidatesEngine myCandidatesEngine;
    [CompilerGeneratedAttribute]
private ICSharpArgumentsOwner <Invocation>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentRange <BoundsRange>k__BackingField;
    [NotNullAttribute]
public ICSharpArgumentsOwner Invocation { get; }
    public DocumentRange BoundsRange { get; }
    [NotNullAttribute]
public IList`1<ICSharpArgument> Arguments { get; }
    [NotNullAttribute]
public IList`1<IPropertyAssignment> PropertyAssignments { get; }
    [NotNullAttribute]
public IList`1<InvocationCandidate> Candidates { get; }
    private CsParameterInfoInvocationContext(ICSharpArgumentsOwner invocation, int argumentIndex, DocumentRange range);
    [CompilerGeneratedAttribute]
public ICSharpArgumentsOwner get_Invocation();
    [CompilerGeneratedAttribute]
public DocumentRange get_BoundsRange();
    public IList`1<ICSharpArgument> get_Arguments();
    public IList`1<IPropertyAssignment> get_PropertyAssignments();
    private static void CheckLeftParOffset(TreeOffset leftParOffset, ITokenNode lParNode, ITokenNode rParNode, ITokenNode& start, ITokenNode& end);
    public static CsParameterInfoInvocationContext CreateInvocationContext(ITreeNode node, TreeOffset caretTreeOffset, TreeOffset leftParOffset, UseParentContext useParent);
    public IList`1<InvocationCandidate> get_Candidates();
    [NotNullAttribute]
public IList`1<ApplicableInvocationCandidate> GetAcceptedCandidates();
    [NotNullAttribute]
public IList`1<InvocationCandidate> GetFilteredOut();
    public int GetDefaultInvocableIndex();
    [CanBeNullAttribute]
public InvocationCandidate GetDefaultInvocable();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.CSTypeArgumentsInfoContext : ParameterInfoContextBase {
    public CSTypeArgumentsInfoContext(int parameter, TypeArgumentCandidate[] candidates, DocumentRange range, int selectedInvocable, ITypeArgumentList argList, ParameterInfoSettings settings);
}
[ParameterInfoContextFactoryAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.CSTypeArgumentsInfoContextFactory : object {
    private static Char[] POPUP_CHARS;
    private static Char[] IMPORTANT_CHARS;
    public PsiLanguageType Language { get; }
    public IEnumerable`1<char> ImportantChars { get; }
    private static CSTypeArgumentsInfoContextFactory();
    public sealed virtual bool IsIntellisenseEnabled(ISolution solution, IContextBoundSettingsStore settingsStore);
    public sealed virtual IParameterInfoContext CreateContext(ISolution solution, DocumentOffset caretOffset, DocumentOffset expectedLParenthOffset, char invocationChar, IContextBoundSettingsStore settingsStore);
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual IEnumerable`1<char> get_ImportantChars();
    public sealed virtual bool ShouldPopup(DocumentOffset caretOffset, char c, ISolution solution, IContextBoundSettingsStore settingsStore);
    private static ICompletableReference GetCompleteableReference(ITypeArgumentList argList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.DeconstructionCandidate : CachingCandidate {
    private IDeconstruction myDeconstruction;
    private DeclaredElementPresenterTextStyles myTextStyles;
    private RichTextBlock myDescription;
    private RichTextBlock myObsoleteDescription;
    [CompilerGeneratedAttribute]
private bool <IsFilteredOut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsObsolete>k__BackingField;
    public int PositionalParameterCount { get; }
    public bool IsFilteredOut { get; public set; }
    public bool IsObsolete { get; }
    public RichTextBlock ObsoleteDescription { get; }
    public DeconstructionCandidate(DecoratedType`1<TupleTypeDecoration> tupleType, ISolution solution, PsiLanguageType languageType);
    public DeconstructionCandidate(IDeconstruction deconstruction, ISolution solution, PsiLanguageType languageType);
    private static IDeconstruction CreateTupleDeconstructionFromType(DecoratedType`1<TupleTypeDecoration> tupleType);
    protected virtual bool IsValid();
    protected virtual RichText GetSignatureInternal(String[] namedArguments, ParameterInfoSettings settings, TextRange[]& parameterRanges, TextRange& returnTypeRange, Int32[]& mapToOriginalOrder, ExtensionMethodInfo& extensionMethodInfo, RichText[]& annotations);
    public virtual RichTextBlock GetDescription(ParameterInfoSettings settings);
    public virtual int get_PositionalParameterCount();
    [CompilerGeneratedAttribute]
public virtual bool get_IsFilteredOut();
    [CompilerGeneratedAttribute]
public virtual void set_IsFilteredOut(bool value);
    public virtual void GetParametersInfo(ParamPresentationInfo[]& paramInfos, Int32& paramsParameterIndex);
    public virtual bool Matches(IDeclaredElement signature);
    [CompilerGeneratedAttribute]
public virtual bool get_IsObsolete();
    public virtual RichTextBlock get_ObsoleteDescription();
    protected virtual IList`1<string> GetParameterNames();
    private static RichText TryGetComponentName(IDeconstructionComponent component);
    private bool MatchesDeconstruction(ITreeNode deconstructNode, int parameterIndex);
    private bool MatchesTuple(ITupleExpression tupleExpression, int parameter);
    public static int FilterDeconstructionCandidates(DeconstructionCandidate[] candidates, int parameter, ITreeNode deconstructNode);
    public static int FilterTupleCandidates(DeconstructionCandidate[] candidates, int parameter, ITupleExpression tupleExpression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.DeconstructionContext : CSParameterInfoContext {
    [NullableContextAttribute("1")]
internal DeconstructionContext(DeconstructionCandidate[] candidates, int parameter, DocumentRange range, int selectedInvocable, ParameterInfoSettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.ListItemCandidate : CachingCandidate {
    private IType myElementType;
    private char myLeftBorder;
    private char myRightBorder;
    private DeclaredElementPresenterTextStyles myTextStyles;
    [CompilerGeneratedAttribute]
private bool <IsFilteredOut>k__BackingField;
    [CompilerGeneratedAttribute]
private RichTextBlock <ObsoleteDescription>k__BackingField;
    public int PositionalParameterCount { get; }
    public bool IsFilteredOut { get; public set; }
    public bool IsObsolete { get; }
    public RichTextBlock ObsoleteDescription { get; }
    public ListItemCandidate(IType elementType, ISolution solution, PsiLanguageType languageType, char leftBorder, char rightBorder);
    protected virtual bool IsValid();
    protected virtual RichText GetSignatureInternal(String[] namedArguments, ParameterInfoSettings settings, TextRange[]& parameterRanges, TextRange& returnTypeRange, Int32[]& mapToOriginalOrder, ExtensionMethodInfo& extensionMethodInfo, RichText[]& annotations);
    public virtual RichTextBlock GetDescription(ParameterInfoSettings settings);
    public virtual int get_PositionalParameterCount();
    [CompilerGeneratedAttribute]
public virtual bool get_IsFilteredOut();
    [CompilerGeneratedAttribute]
public virtual void set_IsFilteredOut(bool value);
    public virtual void GetParametersInfo(ParamPresentationInfo[]& paramInfos, Int32& paramsParameterIndex);
    public virtual bool Matches(IDeclaredElement signature);
    public virtual bool get_IsObsolete();
    [CompilerGeneratedAttribute]
public virtual RichTextBlock get_ObsoleteDescription();
    protected virtual IList`1<string> GetParameterNames();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ParameterInfo.ListItemsContext : CSParameterInfoContext {
    [NullableContextAttribute("1")]
internal ListItemsContext(ListItemCandidate[] candidates, int parameter, DocumentRange range, int selectedInvocable, ParameterInfoSettings settings);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpCodeAnnotationHintBulbActionsProvider : ManagedLanguageCodeAnnotationHintBulbActionsProvider`1<CSharpOtherInlayHintsOptions> {
    public virtual string GetOptionsPageId();
}
[SettingsKeyAttribute("JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.InlayHintsSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "COtherInlayHintsSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpOtherInlayHintsOptions : ManagedLanguageOtherInlayHintsOptionsBase {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowMissingConstructsAsEditorHintsSettingDescription")]
public PushToHintMode ShowMissingConstructHints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowResourceDisposeRequiredAsEditorHintsSettingDescription")]
public PushToHintMode ShowResourcesDisposeRequired;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowResourceDisposePointsAsEditorHintsSettingDescription")]
public PushToHintMode ShowResourcesDisposePoints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowTupleComponentNameHintsSettingDescription")]
public PushToHintMode ShowTupleComponentNamesHints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowUnnamedTupleComponentTypeNamesHintsSettingDescription")]
public bool ShowUnnamedTupleComponentTypeNamesHints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowDeconstructionPatternComponentNamesHints")]
public PushToHintMode ShowDeconstructionPatternComponentNamesHints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowDiscardTypeNameHints")]
public PushToHintMode ShowDiscardTypeNameHints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowInferredDiscardNames")]
public bool ShowInferredDiscardNames;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowPragmaDescriptionHints")]
public PushToHintMode ShowPragmaDescriptionHints;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowImplicitJumpHintsBeforeLocalFunctionsDescription")]
public PushToHintMode ShowImplicitJumpHintsBeforeLocalFunctions;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowCommentBeforeLocalFunctionsWhenThereIsCodeInOuterScope")]
public bool ShowCommentBeforeLocalFunctionsWhenThereIsCodeInOuterScope;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "MinimumLinesToShowCommentBeforeLocalFunctions")]
public int MinimumLinesToShowCommentBeforeLocalFunctions;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ShowCommentBeforeLocalFunctionsWhenThereIsCodeInOuterScope")]
public PushToHintMode ShowBlockHeaderAfterItsClosingBrace;
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpOtherInlayHintsOptionsMigration : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpOtherInlayHintsOptionsMigration/<GetEntriesToMigrate>d__0")]
public sealed virtual IEnumerable`1<SettingsEntry> GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpOtherInlayHintsOptionsMigration/<GetKeysToMigrate>d__1")]
public sealed virtual IEnumerable`1<SettingsKey> GetKeysToMigrate(ISettingsSchema schema);
    public sealed virtual void Migrate(IContextBoundSettingsStoreImplementation store);
}
[OptionsPageAttribute("CSharpOtherInlayHintsOptions", "Other", "JetBrains.Application.UI.Icons.FeaturesIntellisenseThemedIcons.FeaturesIntellisenseThemedIcons/ParameterInfoPage")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpOtherInlayHintsOptionsPage : InlayHintsOptionPageBase {
    public static string PID;
    public CSharpOtherInlayHintsOptionsPage(Lifetime lifetime, OptionsPageContext optionsPageContext, OptionsSettingsSmartContext optionsSettingsSmartContext);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsBulbActionsProvider : ParameterNameHintBulbActionsProvider`1<CSharpParameterNameHintsOptions> {
    public virtual string GetOptionsPageId();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsExclusionListPredefinedValues : ManagedLanguageParameterNameHintsExclusionListPredefinedValues`1<CSharpParameterNameHintsOptions> {
    public string Name { get; }
    public CSharpParameterNameHintsExclusionListPredefinedValues(ISettingsSchema settingsSchema, ILogger logger);
    public virtual string get_Name();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsExclusionListStore : InlayHintsExclusionListStore {
    private Guid myExclusionListCacheKey;
    public virtual Guid GetExclusionListCacheKey();
    public virtual SettingsIndexedEntry GetIndexedEntry(IContextBoundSettingsStore settingsStore);
}
[SettingsKeyAttribute("JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.InlayHintsSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CParameterNameHintsSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsOptions : ManagedLanguageParameterNameHintsOptionsBase {
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsOptionsAutoFixExclusionListMigration : ParameterNameHintsOptionsAutoFixExclusionListMigration`1<CSharpParameterNameHintsOptions> {
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsOptionsMigration : ManagedParameterNameHintsOptionsMigration`1<CSharpParameterNameHintsOptions> {
}
[OptionsPageAttribute("CSharpParameterNameHintsOptions", "Parameter Name Hints", "JetBrains.Application.UI.Icons.FeaturesIntellisenseThemedIcons.FeaturesIntellisenseThemedIcons/ParameterInfoPage")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsOptionsPage : ManagedLanguageParameterNameHintsOptionsPage`1<CSharpParameterNameHintsOptions> {
    public static string PID;
    public CSharpParameterNameHintsOptionsPage(Lifetime lifetime, OptionsPageContext optionsPageContext, OptionsSettingsSmartContext optionsSettingsSmartContext, IconHostBase iconHost, LanguageManager languageManager);
    protected virtual void AddLanguageSpecificOptions();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsOptionsRegistrar : object {
    public CSharpParameterNameHintsOptionsRegistrar(InlayHintsOptionsStore inlayHintsOptionsStore, ISettingsStore settingsStore);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsOptions", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "NUnitParameterNameHintsSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.UnitTesting.NUnitParameterNameHintsOptions : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "OverrideTestCaseAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription")]
public bool OverrideTestCaseArgumentNames;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "OverrideInlineAutoDataAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription")]
public bool OverrideInlineAutoDataArgumentNames;
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.CSharpParameterNameHintsOptions", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "XUnitParameterNameHintsSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.UnitTesting.XUnitParameterNameHintsOptions : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "OverrideInlineDataAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription")]
public bool OverrideInlineDataArgumentNames;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "OverrideInlineAutoDataAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription")]
public bool OverrideInlineAutoDataArgumentNames;
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.ParameterNameHints.ZoneMarker : object {
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Behaviors.CSharpExpressionPostfixTemplateBehavior`1 : PostfixTemplateBehavior {
    protected CSharpExpressionPostfixTemplateBehavior`1(PostfixTemplateInfo info);
    protected virtual ITreeNode ExpandPostfix(PostfixExpressionContext context);
    [NotNullAttribute]
protected abstract virtual TExpression CreateExpression(CSharpElementFactory factory, ICSharpExpression expression);
    [NotNullAttribute]
protected virtual TExpression DecorateExpression(CSharpElementFactory factory, TExpression expression);
    protected sealed virtual void AfterComplete(ITextControl textControl, ITreeNode node, Suffix suffix);
    protected virtual void AfterComplete(ITextControl textControl, TExpression expression, Suffix suffix);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Behaviors.CSharpStatementPostfixTemplateBehavior`1 : PostfixTemplateBehavior {
    private bool myUseBraces;
    private static string CaretTemplate;
    [NotNullAttribute]
protected string EmbeddedStatementBracesTemplate { get; }
    [NotNullAttribute]
protected string RequiredBracesTemplate { get; }
    protected CSharpStatementPostfixTemplateBehavior`1(PostfixTemplateInfo info);
    protected string get_EmbeddedStatementBracesTemplate();
    protected string get_RequiredBracesTemplate();
    protected virtual ITreeNode ExpandPostfix(PostfixExpressionContext context);
    [NotNullAttribute]
protected abstract virtual TStatement CreateStatement(CSharpElementFactory factory, ICSharpExpression expression);
    [NotNullAttribute]
protected virtual TStatement DecorateStatement(CSharpElementFactory factory, TStatement statement);
    [ContractAnnotationAttribute("null => null")]
[CanBeNullAttribute]
private static ICSharpStatement UnwrapFromBraces(ITreeNode statement);
    protected sealed virtual void AfterComplete(ITextControl textControl, ITreeNode node, Suffix suffix);
    protected virtual void AfterComplete(ITextControl textControl, TStatement statement, Suffix suffix);
    [CanBeNullAttribute]
protected TStatement PutStatementCaret(ITextControl textControl, TStatement statement);
    protected void FormatStatementOnSemicolon(TStatement statement);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.CanInstantiate : Enum {
    public int value__;
    public static CanInstantiate No;
    public static CanInstantiate DefaultConstructor;
    public static CanInstantiate ConstructorWithParameters;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Contexts.CSharpBrokenStatementPostfixTemplateContext : CSharpPostfixTemplateContext {
    private static string FixCommandName;
    public CSharpBrokenStatementPostfixTemplateContext(ITreeNode reference, ICSharpExpression expression, PostfixTemplateExecutionContext executionContext);
    private static CSharpBrokenStatementPostfixTemplateContext();
    public virtual CSharpPostfixExpressionContext FixExpression(CSharpPostfixExpressionContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Contexts.CSharpPostfixExpressionContext : PostfixExpressionContext {
    [CompilerGeneratedAttribute]
private IExpressionType <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <ReferencedElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredType <ReferencedType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBecameStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTopLevelExpressionStatement>k__BackingField;
    [NotNullAttribute]
public CSharpPostfixTemplateContext PostfixContext { get; }
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    [NotNullAttribute]
public IExpressionType ExpressionType { get; }
    [NotNullAttribute]
public IType Type { get; }
    [CanBeNullAttribute]
public IDeclaredElement ReferencedElement { get; }
    [CanBeNullAttribute]
public IDeclaredType ReferencedType { get; }
    public bool CanBecameStatement { get; }
    public bool IsTopLevelExpressionStatement { get; }
    [CanBeNullAttribute]
public IReferenceExpression ExpressionWithReference { get; }
    public CSharpPostfixExpressionContext(CSharpPostfixTemplateContext postfixContext, ICSharpExpression expression);
    public CSharpPostfixTemplateContext get_PostfixContext();
    public ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public IExpressionType get_ExpressionType();
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public IDeclaredElement get_ReferencedElement();
    [CompilerGeneratedAttribute]
public IDeclaredType get_ReferencedType();
    [CompilerGeneratedAttribute]
public bool get_CanBecameStatement();
    [CompilerGeneratedAttribute]
public bool get_IsTopLevelExpressionStatement();
    public IReferenceExpression get_ExpressionWithReference();
    [CanBeNullAttribute]
private static IDeclaredType IsBrokenAsExpressionCase(ICSharpExpression expression, ITreeNode reference);
    [CanBeNullAttribute]
private static IType IsBrokenByAwaitCase(ICSharpExpression expression, ITreeNode reference);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Contexts.CSharpPostfixTemplateContext : PostfixTemplateContext {
    [NotNullAttribute]
private ICSharpExpression myInnerExpression;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpPostfixExpressionContext> <Expressions>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpPostfixTemplatesFileTypeHelper <ProjectFileTypeHelper>k__BackingField;
    public PsiLanguageType Language { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<CSharpPostfixExpressionContext> Expressions { get; }
    [CanBeNullAttribute]
public CSharpPostfixExpressionContext InnerExpression { get; }
    [CanBeNullAttribute]
public CSharpPostfixExpressionContext OuterExpression { get; }
    [CanBeNullAttribute]
public CSharpPostfixExpressionContext TypeExpression { get; }
    [CanBeNullAttribute]
public CSharpPostfixExpressionContext OuterStatementExpression { get; }
    [NotNullAttribute]
public CSharpPostfixTemplatesFileTypeHelper ProjectFileTypeHelper { get; }
    protected CSharpPostfixTemplateContext(ITreeNode reference, ICSharpExpression expression, PostfixTemplateExecutionContext executionContext);
    public virtual PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CSharpPostfixExpressionContext> get_Expressions();
    public CSharpPostfixExpressionContext get_InnerExpression();
    public CSharpPostfixExpressionContext get_OuterExpression();
    public CSharpPostfixExpressionContext get_TypeExpression();
    public CSharpPostfixExpressionContext get_OuterStatementExpression();
    [CompilerGeneratedAttribute]
public CSharpPostfixTemplatesFileTypeHelper get_ProjectFileTypeHelper();
    [NotNullAttribute]
private IReadOnlyList`1<CSharpPostfixExpressionContext> BuildExpressions(ITreeNode reference);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Contexts.CSharpPostfixTemplateContext/<GetAllExpressionContexts>d__19")]
protected virtual IEnumerable`1<PostfixExpressionContext> GetAllExpressionContexts();
    public virtual bool IsSemanticallyMakeSense();
    public virtual PostfixExpressionContext FixExpression(PostfixExpressionContext context);
    public virtual string FixMatchingText(string templateName);
    [NotNullAttribute]
public virtual CSharpPostfixExpressionContext FixExpression(CSharpPostfixExpressionContext context);
    [NotNullAttribute]
public virtual ICSharpExpression GetOuterExpression(ICSharpExpression expression);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Contexts.CSharpPostfixTemplateContextFactory : object {
    public sealed virtual String[] GetReparseStrings();
    public sealed virtual PostfixTemplateContext TryCreate(ITreeNode position, PostfixTemplateExecutionContext executionContext);
    [CanBeNullAttribute]
private static PostfixTemplateContext TryCreateFromReferenceExpression(PostfixTemplateExecutionContext executionContext, ICSharpExpression qualifierExpression, IReferenceExpression referenceExpression);
    [CanBeNullAttribute]
private static ICSharpStatement FindBrokenStatement(ITreeNode node);
    [CanBeNullAttribute]
private static ICSharpExpression FindExpressionBrokenByKeyword(IExpressionStatement statement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Contexts.CSharpReferenceExpressionPostfixTemplateContext : CSharpPostfixTemplateContext {
    private static string FixCommandName;
    public CSharpReferenceExpressionPostfixTemplateContext(IReferenceExpression reference, ICSharpExpression expression, PostfixTemplateExecutionContext executionContext);
    private static CSharpReferenceExpressionPostfixTemplateContext();
    public virtual CSharpPostfixExpressionContext FixExpression(CSharpPostfixExpressionContext context);
    public virtual ICSharpExpression GetOuterExpression(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Contexts.CSharpReferenceNamePostfixTemplateContext : CSharpPostfixTemplateContext {
    private static string FixCommandName;
    public CSharpReferenceNamePostfixTemplateContext(IReferenceName reference, ICSharpExpression expression, PostfixTemplateExecutionContext executionContext);
    private static CSharpReferenceNamePostfixTemplateContext();
    public virtual CSharpPostfixExpressionContext FixExpression(CSharpPostfixExpressionContext context);
    [CompilerGeneratedAttribute]
private void <FixExpression>b__2_0();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.CSharpPostfixTemplate : object {
    public PsiLanguageType Language { get; }
    public sealed virtual PsiLanguageType get_Language();
    public abstract virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    private sealed virtual override PostfixTemplateInfo JetBrains.ReSharper.Feature.Services.PostfixTemplates.IPostfixTemplate.TryCreateInfo(PostfixTemplateContext context);
    [CanBeNullAttribute]
public abstract virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.CSharpPostfixTemplatesFileTypeHelper : object {
    [NotNullAttribute]
public static CSharpPostfixTemplatesFileTypeHelper DummyInstance;
    private static CSharpPostfixTemplatesFileTypeHelper();
    [NotNullAttribute]
public static CSharpPostfixTemplatesFileTypeHelper Get(ITreeNode context);
    public virtual bool IsTopLevelExpressionStatement(ICSharpExpression expression);
    public virtual bool CanBecameStatement(ICSharpExpression expression);
    [NotNullAttribute]
public virtual ICSharpStatement EnsureStatement(ICSharpExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.CSharpPostfixUtils : object {
    [NotNullAttribute]
private static ClrTypeName ConfigurableAwaitable;
    [NotNullAttribute]
private static ClrTypeName GenericConfigurableAwaitable;
    [NotNullAttribute]
private static ClrTypeName GenericConfigurableValueTaskAwaitable;
    private static CSharpPostfixUtils();
    [PureAttribute]
public static bool IsAssignmentLike(CSharpPostfixExpressionContext expressionContext);
    [PureAttribute]
public static bool IsThisOrBaseExpression(CSharpPostfixExpressionContext expressionContext);
    [PureAttribute]
public static bool CanTypeBecameExpression(ICSharpExpression expression);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsRelationalExpressionWithTypeOperand(ITreeNode node);
    [PureAttribute]
public static bool IsValidExpressionWithValue(ICSharpExpression expression);
    [PureAttribute]
[NotNullAttribute]
public static CSharpPostfixExpressionContext[] FindExpressionWithValuesContexts(CSharpPostfixTemplateContext context, Predicate`1<ICSharpExpression> predicate);
    [PureAttribute]
public static bool IsReferenceExpressionsChain(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsConfigurableAwaitable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericConfigurableAwaitable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericConfigurableValueTaskAwaitable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static string GetParenthesesTemplate(ParenthesesInsertType parenthesesType, bool atStatementEnd);
    [PureAttribute]
[ContractAnnotationAttribute("ownerDeclaration: null => false")]
public static bool IsAlreadyOrCanBecomeAsync(ICSharpDeclaration ownerDeclaration, Boolean& isAsync);
}
[PostfixTemplateAttribute("arg", "Surrounds expression with invocation", "Method(expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ArgumentExpressionTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    private static bool IsNiceArgument(ICSharpExpression expression);
}
[PostfixTemplateAttribute("to", "Assigns current expression to some variable", "lvalue = expr;")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.AssignmentExpressionTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("await", "Awaits expressions of 'Task' type", "await expr")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.AwaitExpressionTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    [PureAttribute]
private static bool IsAvailableInPreciseMode(CSharpPostfixExpressionContext expressionContext, ICSharpDeclaration ownerDeclaration);
    [PureAttribute]
private static bool IsAwaitableType(IType expressionType, ITreeNode context);
    private static bool IsAlreadyAwaited(CSharpPostfixExpressionContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.BooleanExpressionTemplateBase : CSharpPostfixTemplate {
    private static Key`1<object> IsBooleanKey;
    private static BooleanExpressionTemplateBase();
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    [PureAttribute]
private static bool IsBooleanExpressionContext(CSharpPostfixExpressionContext expressionContext, IDeclaredType booleanType);
    private static bool IsBooleanExpressionContextImpl(CSharpPostfixExpressionContext expressionContext, IDeclaredType booleanType);
    public abstract virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    [CanBeNullAttribute]
protected abstract virtual PostfixTemplateInfo TryCreateBooleanInfo(CSharpPostfixExpressionContext expression, bool inPreciseMode);
    [CanBeNullAttribute]
protected virtual PostfixTemplateInfo TryCreateBooleanInfo(CSharpPostfixExpressionContext[] expressions, bool inPreciseMode);
    private static bool IsBooleanExpressionEx(ICSharpExpression expression);
}
[PostfixTemplateAttribute("cast", "Surrounds expression with cast", "((SomeType) expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.CastExpressionTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.CheckForNullTemplateBase : CSharpPostfixTemplate {
    public sealed virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    [CanBeNullAttribute]
protected abstract virtual CheckForNullPostfixTemplateInfo TryCreateCheckInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    [ContractAnnotationAttribute("null => false")]
protected static bool IsNullable(CSharpPostfixExpressionContext expressionContext);
    protected static bool MakeSenseToCheckInPreciseMode(CSharpPostfixExpressionContext expressionContext);
}
[PostfixTemplateAttribute("null", "Checks expression to be null", "if (expr == null)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.CheckIsNullTemplate : CheckForNullTemplateBase {
    protected virtual CheckForNullPostfixTemplateInfo TryCreateCheckInfo(CSharpPostfixTemplateContext context);
}
[PostfixTemplateAttribute("notnull", "Checks expression to be not-null", "if (expr != null)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.CheckNotNullTemplate : CheckForNullTemplateBase {
    protected virtual CheckForNullPostfixTemplateInfo TryCreateCheckInfo(CSharpPostfixTemplateContext context);
}
[PostfixTemplateAttribute("else", "Checks boolean expression to be 'false'", "if (!expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ElseStatementTemplate : BooleanExpressionTemplateBase {
    protected virtual PostfixTemplateInfo TryCreateBooleanInfo(CSharpPostfixExpressionContext expression, bool inPreciseMode);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("foreach", "Iterates over enumerable collection", "foreach (var x in expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ForeachStatementTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    [PureAttribute]
private static bool IsAvailableInPreciseMode(CSharpPostfixExpressionContext context, Nullable`1& canBeSyncEnumerated, Nullable`1& canBeAsyncEnumerated);
    [PureAttribute]
private static bool ShouldUseAwaitForeach(PostfixTemplateInfo postfixTemplateInfo, ICSharpExpression collectionExpression);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("for", "Iterates over collection with index", "for (var i = 0; i < xs.Length; i++)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ForStatementTemplate : ForStatementTemplateBase {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    protected virtual PostfixTemplateBehavior CreateBehavior(ForLoopPostfixTemplateInfo info);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ForStatementTemplateBase : CSharpPostfixTemplate {
    [NotNullAttribute]
private DeclaredElementTypeFilter myPropertyFilter;
    protected bool CanBeLoopedOver(CSharpPostfixTemplateContext context, String& lengthName, Boolean& showInPreciseMode);
    public sealed virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    [NotNullAttribute]
protected abstract virtual PostfixTemplateBehavior CreateBehavior(ForLoopPostfixTemplateInfo info);
}
[PostfixTemplateAttribute("if", "Checks boolean expression to be 'true'", "if (expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.IfStatementTemplate : BooleanExpressionTemplateBase {
    protected virtual PostfixTemplateInfo TryCreateBooleanInfo(CSharpPostfixExpressionContext expression, bool inPreciseMode);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("field", "Introduces field for expression", "_field = expr;")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.IntroduceFieldTemplate : IntroduceMemberTemplateBase {
    public string TemplateName { get; }
    public virtual string get_TemplateName();
    protected virtual PostfixTemplateBehavior CreateBehavior(IntroduceMemberPostfixTemplateInfo info);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.IntroduceMemberTemplateBase : CSharpPostfixTemplate {
    [NotNullAttribute]
public string TemplateName { get; }
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public abstract virtual string get_TemplateName();
    public sealed virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    [NotNullAttribute]
protected abstract virtual PostfixTemplateBehavior CreateBehavior(IntroduceMemberPostfixTemplateInfo info);
}
[PostfixTemplateAttribute("prop", "Introduces property for expression", "Property = expr;")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.IntroducePropertyTemplate : IntroduceMemberTemplateBase {
    public string TemplateName { get; }
    public virtual string get_TemplateName();
    protected virtual PostfixTemplateBehavior CreateBehavior(IntroduceMemberPostfixTemplateInfo info);
}
[PostfixTemplateAttribute("lock", "Surrounds expression with lock block", "lock (expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.LockStatementTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("not", "Negates boolean expression", "!expr")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.NegateExpressionTemplate : BooleanExpressionTemplateBase {
    protected virtual PostfixTemplateInfo TryCreateBooleanInfo(CSharpPostfixExpressionContext expression, bool inPreciseMode);
    protected virtual PostfixTemplateInfo TryCreateBooleanInfo(CSharpPostfixExpressionContext[] expressions, bool inPreciseMode);
    private static bool IsNotUnderUnaryNegation(CSharpPostfixExpressionContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("new", "Produces instantiation expression for type", "new SomeType()")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ObjectCreationExpressionTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    [PureAttribute]
private static bool IsAvailableInPreciseMode(CSharpPostfixExpressionContext typeExpression);
    [CanBeNullAttribute]
private static PostfixTemplateInfo TryCreateExpressionInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("par", "Parenthesizes current expression", "(expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ParenthesizedExpressionTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("parse", "Parses string as value of some type", "int.Parse(expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ParseStringExpressionTemplate : ParseStringExpressionTemplateBase {
    public string TemplateName { get; }
    public bool IsTryParse { get; }
    public virtual string get_TemplateName();
    public virtual bool get_IsTryParse();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ParseStringExpressionTemplateBase : CSharpPostfixTemplate {
    [NotNullAttribute]
private static Type[] TypesWithParsers;
    [NotNullAttribute]
public string TemplateName { get; }
    public bool IsTryParse { get; }
    private static ParseStringExpressionTemplateBase();
    public abstract virtual string get_TemplateName();
    public abstract virtual bool get_IsTryParse();
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    [NotNullAttribute]
private static IList`1<IType> GetTypesWithParsers(ITreeNode context);
}
[PostfixTemplateAttribute("return", "Returns expression from current function", "return expr;")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ReturnStatementTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    private static bool IsAvailableInPreciseMode(CSharpPostfixExpressionContext expressionContext);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("forr", "Iterates over collection in reverse with index", "for (var i = xs.Length-1; i >= 0; i--)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ReverseForStatementTemplate : ForStatementTemplateBase {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    protected virtual PostfixTemplateBehavior CreateBehavior(ForLoopPostfixTemplateInfo info);
}
[PostfixTemplateAttribute("sel", "Selects expression in editor", "|selected + expression|")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.SelectExpressionTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("switch", "Produces switch statement", "switch (expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.SwitchStatementTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    [PureAttribute]
private static bool IsSwitchConditionType(CSharpPostfixExpressionContext expressionContext);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("throw", "Throws expression of 'Exception' type", "throw expr;")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.ThrowTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    private static bool IsAvailable(CSharpPostfixTemplateContext context, Boolean& useExpressionBehavior);
    [PureAttribute]
private static bool IsDefinitelyShouldUseExpressionBehavior(ICSharpExpression expression);
    [PureAttribute]
private static bool IsStatementAndExpressionBehaviorsApplicable(ICSharpExpression expression);
    private static bool CheckExpressionType(CSharpPostfixExpressionContext expressionContext, Boolean& insertNewExpression);
    private static bool IsInstantiableExceptionType(IDeclaredType declaredType, ICSharpExpression context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("tryparse", "Parses string as value of some type", "int.TryParse(expr, out value)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.TryParseStringExpressionTemplate : ParseStringExpressionTemplateBase {
    public string TemplateName { get; }
    public bool IsTryParse { get; }
    public virtual string get_TemplateName();
    public virtual bool get_IsTryParse();
}
[PostfixTemplateAttribute("typeof", "Wraps type usage with typeof() expression", "typeof(TExpr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.TypeOfExpressionTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    [PureAttribute]
private static bool TypeofExpressionCanBeUsedInContext(CSharpPostfixExpressionContext typeExpression);
    [PureAttribute]
private static bool TypeMakeSenseInPreciseMode(CSharpPostfixExpressionContext typeExpression);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("using", "Wraps resource with using statement", "using (expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.UsingStatementTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
    [CompilerGeneratedAttribute]
internal static bool <TryCreateInfo>g__IsDisposable|0_0(bool isAsyncContext, <>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static bool <TryCreateInfo>g__CanAbstractToDisposableCookie|0_1(<>c__DisplayClass0_0& );
}
[PostfixTemplateAttribute("while", "Iterating while boolean statement is 'true'", "while (expr)")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.WhileStatementTemplate : BooleanExpressionTemplateBase {
    protected virtual PostfixTemplateInfo TryCreateBooleanInfo(CSharpPostfixExpressionContext expression, bool inPreciseMode);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
[PostfixTemplateAttribute("yield", "Yields value from iterator method", "yield return expr;")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.Templates.YieldReturnStatementTemplate : CSharpPostfixTemplate {
    public virtual PostfixTemplateInfo TryCreateInfo(CSharpPostfixTemplateContext context);
    [PureAttribute]
private static bool IsAvailableInPreciseMode(CSharpPostfixExpressionContext expressionContext);
    [PureAttribute]
private static bool IsAlreadyOrCanBecameIterator(ICSharpDeclaration declaration, IType returnType);
    public virtual PostfixTemplateBehavior CreateBehavior(PostfixTemplateInfo info);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.PostfixTemplates.TypeUtils : object {
    public static CanInstantiate CanInstantiateType(IType type, ITreeNode context);
    [PureAttribute]
public static CanInstantiate CanInstantiateType(ITypeElement typeElement, ITreeNode context);
    [PureAttribute]
public static bool IsUsefulToCreateWithNew(ITypeElement typeElement);
    [PureAttribute]
public static bool IsUsefulToCreateWithNew(IDeclaredType type);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.DebuggerState2 : object {
    private ErasableAppendOnlyList`1<IPredictiveSavedEvaluation> myPrimitives;
    private ErasableAppendOnlyList`1<IPredictiveSavedEvaluation> myValueObjects;
    private ErasableAppendOnlyList`1<IPredictiveSavedEvaluation> myErrors;
    private ErasableAppendOnlyDictionary`2<long, IPredictiveSavedEvaluation> myPointers;
    private ErasableAppendOnlyOneToSetMap`2<SavedId, IClrDeclaredElement> myObjectKeys;
    private Builder<ValueTuple`2<SavedId, IClrDeclaredElement>, SavedId> myChilds;
    private Builder<IClrDeclaredElement, SavedId> myStatics;
    private ErasableAppendOnlyCollection`1<SavedId> myObjectChanges;
    private ErasableAppendOnlyCollection`1<IClrDeclaredElement> myStaticChanges;
    private ErasableAppendOnlyCollection`1<string> myVariableChanges;
    private Builder<string, SavedId> myVariables;
    [CompilerGeneratedAttribute]
private IModuleReferenceResolveContext <ResolveContext>k__BackingField;
    public IModuleReferenceResolveContext ResolveContext { get; private set; }
    public SavedId This { get; }
    public bool HasThis { get; }
    public DebuggerState2(ErasableAppendOnlyList`1<IPredictiveSavedEvaluation> primitives, ErasableAppendOnlyList`1<IPredictiveSavedEvaluation> valueObjects, ErasableAppendOnlyList`1<IPredictiveSavedEvaluation> errors, ErasableAppendOnlyDictionary`2<long, IPredictiveSavedEvaluation> pointers, ErasableAppendOnlyOneToSetMap`2<SavedId, IClrDeclaredElement> objectKeys, Builder<ValueTuple`2<SavedId, IClrDeclaredElement>, SavedId> childs, Builder<IClrDeclaredElement, SavedId> statics, ErasableAppendOnlyCollection`1<SavedId> objectChanges, ErasableAppendOnlyCollection`1<IClrDeclaredElement> staticChanges, ErasableAppendOnlyCollection`1<string> variableChanges, Builder<string, SavedId> variables);
    [CompilerGeneratedAttribute]
public IModuleReferenceResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
private void set_ResolveContext(IModuleReferenceResolveContext value);
    public SavedId get_This();
    public bool get_HasThis();
    public IPredictiveSavedEvaluation GetValue(SavedId id);
    private IPredictiveSavedEvaluation GetObjectValue(SavedId id);
    public SavedId GetChild(SourceId id);
    public bool TryGetChild(SourceId id, SavedId& savedId, bool allowInit);
    public Task`1<SavedEdge> GetChildAsync(SourceId id);
    public bool HasChanges(SourceId id);
    public bool HasObjectChanges(SourceId id);
    public SavedId CopyObject(SavedId id);
    public void Assign(SavedId obj, SourceId src, bool insert);
    public SavedEdge Evaluation(IPredictiveSavedEvaluation evaluation);
    public SavedEdge Evaluation(IPredictiveSavedEvaluation evaluation, SourceId source, bool insert);
    public void UpdateVariable(string name, SavedEdge property);
    public void UpdateVariable(string name, SavedId saved);
    private SavedId Register(IPredictiveSavedEvaluation evaluation);
    private bool InitObjectChild(SourceId id, SavedId& savedId);
    private Task`1<Nullable`1<SavedId>> InitObjectChild(SourceId id);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.DebuggerState2/<InitObjectChildImpl>d__37")]
private Task`1<Nullable`1<SavedId>> InitObjectChildImpl(SourceId id, SavedId pointer, IClrDeclaredElement element);
    public void ClearChild(SourceId accessor);
    public void Reset(IModuleReferenceResolveContext moduleReferenceResolveContext);
    public Snapshot GetSnapshot();
    public void RestoreSnapshot(Snapshot snapshot);
    public VariablesFork Fork(ImmutableDictionary`2<string, SavedEdge> attachBack);
    public void RestoreFork(VariablesFork fork);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.ErasableAppendOnlyCollection`1 : ValueType {
    private ICollection`1<T> myCollectionImplementation;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ErasableAppendOnlyCollection`1(ICollection`1<T> collectionImplementation);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.ErasableAppendOnlyDictionary`2 : ValueType {
    private IDictionary`2<TK, TV> myDictionaryImplementation;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TV Item { get; public set; }
    public ICollection`1<TK> Keys { get; }
    public ICollection`1<TV> Values { get; }
    public ErasableAppendOnlyDictionary`2(IDictionary`2<TK, TV> dictionaryImplementation);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TK, TV>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TK, TV> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TK, TV> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.Remove(KeyValuePair`2<TK, TV> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(TK key);
    public sealed virtual void Add(TK key, TV value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TK,TV>.Remove(TK key);
    public sealed virtual bool TryGetValue(TK key, TV& value);
    public sealed virtual TV get_Item(TK key);
    public sealed virtual void set_Item(TK key, TV value);
    public sealed virtual ICollection`1<TK> get_Keys();
    public sealed virtual ICollection`1<TV> get_Values();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.ErasableAppendOnlyList`1 : ValueType {
    private IList`1<T> myListImplementation;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ErasableAppendOnlyList`1(IList`1<T> listImplementation);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.ErasableAppendOnlyOneToSetMap`2 : ValueType {
    private OneToSetMap`2<TK, TV> myOneToManyMapImplementation;
    public ICollection`1<TK> Keys { get; }
    public ErasableAppendOnlyCollection`1<TV> Item { get; }
    public ErasableAppendOnlyOneToSetMap`2(OneToSetMap`2<TK, TV> oneToManyMapImplementation);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.ErasableAppendOnlyOneToSetMap`2/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TK, ErasableAppendOnlyCollection`1<TV>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ErasableAppendOnlyCollection`1<TV> GetValuesSafe(TK key);
    public sealed virtual void Add(TK key, TV value);
    private sealed virtual override bool JetBrains.Util.IOneToManyMap<TK,TV,JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.ErasableAppendOnlyCollection<TV>>.Remove(TK key, TV value);
    public sealed virtual ICollection`1<TK> get_Keys();
    public void Clear();
    public ErasableAppendOnlyCollection`1<TV> get_Item(TK key);
    public bool ContainsPair(TK key, TV value);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.EvaluationAccumulator : object {
    private PredictiveStackFrames myStack;
    private Key`1<Boxed`1<int>> myLastTs;
    private Key`1<WithTimeStamp`1<bool>> myChanges;
    private Key`1<WithTimeStamp`1<SavedEdge>> myKey;
    private Key`1<WithTimeStamp`1<IPredictiveSavedEvaluation>> myOutKey;
    private Key`1<WithTimeStamp`1<OneToSetMap`2<IPredictiveSavedEvaluation, ITreeNode>>> myCapture;
    private int myLastKey;
    [CompilerGeneratedAttribute]
private SavedEdge <Exception>k__BackingField;
    public int CurrentCall { get; }
    public SavedEdge Exception { get; public set; }
    public EvaluationAccumulator(PredictiveStackFrames stack);
    public int get_CurrentCall();
    [CompilerGeneratedAttribute]
public SavedEdge get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(SavedEdge value);
    private int GetLastTimeStamp(ITreeNode node);
    public void IncrementTimeStamp(ITreeNode owner);
    public void TimeStampSiftDown(ITreeNode node);
    public void TimeStampSiftDown(ITreeNode dest, ITreeNode src);
    public void IncrementTimeStamp(IStatementWithBody node);
    public void IncrementTimeStamp(ICSharpDeclaration node);
    public void PushVariable(ITreeNode src, SavedEdge evaluated);
    public void PushOutVariable(ICSharpArgument argument, IPredictiveSavedEvaluation evaluation);
    public void PushClosure(ILambdaExpression lambda, OneToSetMap`2<IPredictiveSavedEvaluation, ITreeNode> variable);
    [CanBeNullAttribute]
public OneToSetMap`2<IPredictiveSavedEvaluation, ITreeNode> GetClosure(ILambdaExpression lambdaExpression);
    public SavedEdge GetSavedObject(ITreeNode node);
    public SavedEdge GetSavedObjectThroughParenthesis(ITreeNode node);
    public IPredictiveSavedEvaluation GetOutVariable(ICSharpArgument argument);
    [ObsoleteAttribute("Use Substitute(ITreeNode, Int32)")]
[MustUseReturnValueAttribute]
public int Substitute(ITreeNode node);
    public T Substitute(T node, int assertionCount, bool substituteClosure);
    private void PrepareSubstitutes(ITreeNode node, IDictionary`2<ITreeNode, ITreeNode> modifications, ITreeNode copy, Int32& closureCount, int timestamp);
    private static ITreeNode HighestParent(ITreeNode node);
    private static IExpression CreateTreeNode(ITreeNode node, SavedEdge evaluated);
    private void AddValue(ITreeNode node, Key`1<WithTimeStamp`1<T>> key, T value);
    public void MarkChanged(IArgumentList node);
    public bool HasChanges(IArgumentList node);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.IndexDebuggerElement : object {
    public IClrDeclaredElement Element;
    public IndexValue[] Index;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    private IndexDebuggerElement(IClrDeclaredElement element, IndexValue[] index);
    internal static IndexDebuggerElement Create(IClrDeclaredElement element, IndexValue[] index);
    public static IndexDebuggerElement CreateByInt32(IClrDeclaredElement element, int index);
    public static IndexDebuggerElement CreateByInt32(IClrDeclaredElement element, Int32[] index);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    private bool Equals(IndexDebuggerElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.SavedEdge : object {
    private DebuggerState2 myState2;
    private SourceId mySource;
    private IPredictiveEvaluation myEvaluation { get; }
    private SavedId myTarget { get; }
    public string Value { get; }
    public IType Type { get; }
    public TypeClassification Classification { get; }
    public long Pointer { get; }
    public bool IsPrimitiveValue { get; }
    public IPredictiveSavedEvaluation Evaluation { get; }
    [CanBeNullAttribute]
public ITreeNode SavedAt { get; }
    public SavedEdge(DebuggerState2 state2, SourceId source);
    private IPredictiveEvaluation get_myEvaluation();
    private SavedId get_myTarget();
    public string get_Value();
    public IType get_Type();
    public TypeClassification get_Classification();
    public long get_Pointer();
    public bool get_IsPrimitiveValue();
    public IPredictiveSavedEvaluation get_Evaluation();
    public ITreeNode get_SavedAt();
    public bool IsNull();
    public string GetName();
    public IDeclaredElement GetElement();
    public SavedEdge GetChild(IProperty property, bool allowInitAuto);
    public SavedEdge GetChild(IField field, bool allowInit);
    [CanBeNullAttribute]
private SavedEdge GetChildInternal(IClrDeclaredElement property, bool allowInit);
    private SavedEdge GetIndexChildInternal(IndexDebuggerElement element, bool allowInit);
    [CanBeNullAttribute]
public SavedEdge GetChild(IDeclaredElement element, bool allowInit);
    public SavedEdge GetIndexChild(IClrDeclaredElement property, int index);
    public SavedEdge GetIndexChild(IClrDeclaredElement property, Int32[] index);
    private SavedEdge FindTupleElement(int index, DecoratedType`1<TupleTypeDecoration> tuple);
    [ContractAnnotationAttribute("null => null")]
public SavedEdge GetChildForce(ITypeMember member);
    private SavedEdge GetChildForce(IProperty property);
    public Task`1<SavedEdge> GetChildAsync(IDeclaredElement element, ImpureValidatorWithNode validator);
    public Task`1<SavedEdge> GetChildAsync(DeclaredElementWithPureCheck element);
    private Task`1<SavedEdge> GetChildImplPropertyAsync(DeclaredElementWithPureCheck element);
    public Task`1<SavedEdge> GetChildAsync(IProperty property, ImpureValidatorWithNode validator);
    public Task`1<SavedEdge> GetChildAsync(IField property);
    private Task`1<SavedEdge> GetChildInternalAsync(IClrDeclaredElement element);
    public Task`1<SavedEdge> GetIndexChildAsync(IndexDebuggerElement create);
    public SavedEdge AddChildren(IPredictiveSavedEvaluation evaluation, IClrDeclaredElement element);
    public SavedEdge Copy(SavedEdge other);
    public SavedEdge Move(SavedEdge other);
    public SavedEdge CopyObject();
    public SavedEdge CopyView();
    public SavedEdge Copy();
    public SavedEdge SaveToVariable(string name);
    public bool HasChanges();
    public bool HasObjectChanges();
    public SnapshotCookie ApplySnapshot(Snapshot snapshot);
    public void Unattach();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.SavedId : ValueType {
    public static SavedId Empty;
    public SavedTypes SavedType;
    private long myValue;
    public long Pointer { get; }
    public int Id { get; }
    private SavedId(long value, SavedTypes isPrimitive);
    private static SavedId();
    public long get_Pointer();
    public int get_Id();
    public static SavedId MakePointer(long p);
    public static SavedId MakePrimitive(int id);
    public static SavedId MakeValue(int id);
    public static SavedId MakeError(int id);
    public bool Equals(SavedId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Accumulator.SourceId : ValueType {
    public SourceTypes SourceType;
    public string VariableName;
    public SavedId SavedId;
    public IClrDeclaredElement Element;
    public ValueTuple`2<SavedId, IClrDeclaredElement> ChildAccessor { get; }
    private SourceId(SourceTypes sourceType, string variableName, SavedId savedId, IClrDeclaredElement element);
    public ValueTuple`2<SavedId, IClrDeclaredElement> get_ChildAccessor();
    public static SourceId MakeUnattached(SavedId id);
    public static SourceId MakeVariable(string name);
    public static SourceId MakeChildAccessor(SavedId ptr, IClrDeclaredElement element);
    public static SourceId MakeStaticMember(IClrDeclaredElement element);
    public string GetName();
    public bool Equals(SourceId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.ControlFlowWalker : object {
    [NotNullAttribute]
private IControlFlowGraph myControlFlowGraph;
    [NotNullAttribute]
private InterpreterVisitor myVisitor;
    [NotNullAttribute]
private PredictiveStackFrames myStack;
    [NotNullAttribute]
private TaskScheduler myScheduler;
    [NotNullAttribute]
private ILog myLogger;
    [NotNullAttribute]
private LastBatch myLastBatch;
    private Lifetime myLifetime;
    private string myPredictionFailedMessage;
    [NotNullAttribute]
private IControlFlowWalker myState { get; }
    public bool HasContinuation { get; }
    internal ControlFlowWalker(Lifetime lifetime, TaskScheduler scheduler, IControlFlowGraph controlFlowGraph, InterpreterVisitor visitor, PredictiveStackFrames state, ILog log, LastBatch lastBatch, bool isInternal);
    private IControlFlowWalker get_myState();
    public bool get_HasContinuation();
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.ControlFlowWalker/<StepAsync>d__13")]
private Task StepAsync();
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.ControlFlowWalker/<FirstStepAsync>d__14")]
private Task FirstStepAsync();
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.ControlFlowWalker/<PredictAsync>d__15")]
public Task PredictAsync();
    public Task ContinueAsync();
    public void SkipTo(ITreeNode node, ITreeNode method);
    public void SkipTo(IControlFlowElement element);
    private void CatchException(Exception e, IControlFlowElement current);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.ControlFlowWalkerState : object {
    private bool myFree;
    private State myState;
    private IControlFlowElement myCustom;
    private EvaluationAccumulator myEvaluationAccumulator;
    [CompilerGeneratedAttribute]
private IControlFlowElement <BeginControlFlowElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<IControlFlowElement> <TryStack>k__BackingField;
    public IControlFlowElement BeginControlFlowElement { get; private set; }
    public IControlFlowElement SelectingControlFlowElement { get; }
    public IControlFlowElement ControlFlowElement { get; }
    public Stack`1<IControlFlowElement> TryStack { get; }
    public bool HasContinuation { get; }
    public bool IsSuccessfullyFinished { get; }
    public ControlFlowWalkerState(IControlFlowElement controlFlowElement, EvaluationAccumulator evaluationAccumulator);
    [CompilerGeneratedAttribute]
public sealed virtual IControlFlowElement get_BeginControlFlowElement();
    [CompilerGeneratedAttribute]
private void set_BeginControlFlowElement(IControlFlowElement value);
    public sealed virtual IControlFlowElement get_SelectingControlFlowElement();
    public sealed virtual IControlFlowElement get_ControlFlowElement();
    [CompilerGeneratedAttribute]
public sealed virtual Stack`1<IControlFlowElement> get_TryStack();
    public sealed virtual bool get_HasContinuation();
    public sealed virtual bool get_IsSuccessfullyFinished();
    public sealed virtual void Stop();
    public sealed virtual void SetNext(IControlFlowElement next);
    public sealed virtual void SetSingleExit();
    public sealed virtual void MoveNext();
    public sealed virtual void Resume(IControlFlowElement next);
    public sealed virtual void ContinueAt(IControlFlowElement continuation);
    public sealed virtual void ContinueHere();
    public sealed virtual void SuccessfullyFinish();
    public sealed virtual void Continue();
    public sealed virtual void Fix(bool fix);
    private bool SetState(State state);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.DeadCodeUtils : object {
    [ExtensionAttribute]
private static void KillRange(IPredictiveEvaluationContainer container, TreeRange range);
    [ExtensionAttribute]
public static void KillNode(IPredictiveEvaluationContainer container, ITreeNode node);
    [ExtensionAttribute]
public static void KillIf(IPredictiveEvaluationContainer container, ITreeNode node, bool cond);
    [ExtensionAttribute]
public static void KillSwitchArm(IPredictiveEvaluationContainer container, ISwitchExpressionArm expressionArm);
    public static void KillSwitchSection(IPredictiveEvaluationContainer container, ISwitchSection switchSection);
    [ExtensionAttribute]
public static void KillReferenceExpression(IPredictiveEvaluationContainer container, IReferenceExpression expression);
    [ExtensionAttribute]
public static void KillElementAccessExpression(IPredictiveEvaluationContainer container, IElementAccessExpression expression);
    [ExtensionAttribute]
public static void KillArgumentList(IPredictiveEvaluationContainer container, IInvocationExpression expression);
    [ExtensionAttribute]
public static void KillCatches(IPredictiveEvaluationContainer container, ITryStatement statement);
    [ExtensionAttribute]
public static void KillToEnd(IPredictiveEvaluationContainer container, ITreeNode node);
    [ExtensionAttribute]
public static void KillToEndOf(IPredictiveEvaluationContainer container, ITreeNode node);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.DeclaredElementWithPureCheck : ValueType {
    private InterpretationUnit Unit;
    private ITreeNode myLabel;
    private bool myIsPure;
    public IDeclaredElement Element;
    public DeclaredElementWithPureCheck(InterpretationUnit unit, ITreeNode label, IDeclaredElement element);
    private DeclaredElementWithPureCheck(InterpretationUnit unit, ITreeNode label, IDeclaredElement element, bool isPure);
    private bool IsAllowed();
    public PurenessType GetPurenessType();
    public DeclaredElementWithPureCheck With(IDeclaredElement element);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EmptyContainer : object {
    [CompilerGeneratedAttribute]
private static EmptyContainer <Instance>k__BackingField;
    public static EmptyContainer Instance { get; }
    public int Count { get; }
    private static EmptyContainer();
    [CompilerGeneratedAttribute]
public static EmptyContainer get_Instance();
    public sealed virtual void Add(ITreeNode treeNode, IPredictiveEvaluation evaluation);
    public sealed virtual void Add(ITreeNode treeNode, SavedEdge edge, Snapshot snapshot);
    public sealed virtual void AddWarn(ITreeNode treeNode, string message);
    public sealed virtual void SetStopWarn(ITreeNode node, string message);
    public sealed virtual void ImpureWarn(ITreeNode treeNode, Key key, ImpureWarnInfo info, PredictiveStackFrames frames, DebuggerState2 state);
    public sealed virtual void AddHalt(ITreeNode node, string message);
    public sealed virtual void AddConditionHighlight(ITreeNode elementSourceElement, bool b);
    public sealed virtual void AddWarnHighlight(TreeRange range);
    public sealed virtual void AddHaltHighlight(TreeRange range);
    public sealed virtual void AddDeadCodeHighlight(TreeRange toBlind);
    public sealed virtual IPredictiveEvaluationContainer AddBatch();
    public sealed virtual IPredictiveIterationsContainer AddLoop(ILoopStatement loopStatement);
    public sealed virtual IPredictiveEvaluationContainer PredictInto(ITreeNode node, IDeclaredElement element);
    public sealed virtual void Clear();
    public sealed virtual int get_Count();
    public sealed virtual IPredictiveEvaluationContainer AddIteration();
    public sealed virtual IPredictiveEvaluationContainer Last();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationEx : object {
    [ExtensionAttribute]
public static IPredictiveSavedEvaluation GetChild(IPredictiveSavedEvaluation evaluation, IDeclaredElement element);
    [ExtensionAttribute]
public static TypeClassification Classification(IPredictiveEvaluation evaluation);
    [ExtensionAttribute]
public static IModuleReferenceResolveContext GetResolveContext(IPredictiveEvaluation evaluation);
    [ExtensionAttribute]
public static bool IsValid(IPredictiveEvaluation evaluation);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IPredictiveEvaluation FilterValid(IPredictiveEvaluation evaluation);
    [ExtensionAttribute]
public static IPredictiveSavedEvaluation ToSaved(IPredictiveEvaluation evaluation, ITreeNode expression, IExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static Task`1<IPredictiveSavedEvaluation> Resave(IPredictiveSavedEvaluation evaluation, InterpretationUnit Unit, ITreeNode lbl);
    [ExtensionAttribute]
public static IType SpecializeType(InterpretationUnit Unit, IType type, IModuleReferenceResolveContext context);
    [ExtensionAttribute]
private static IType GetTypeParameter(InterpretationUnit Unit, ITypeParameter parameter);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationEx/<Destruct>d__9")]
[ExtensionAttribute]
public static Task Destruct(InterpretationUnit Unit, IVariableDesignation designation, IPredictiveSavedEvaluation evaluation, ITreeNode lbl);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationEx/<Destruct>d__10")]
[ExtensionAttribute]
public static Task`1<List`1<IPredictiveSavedEvaluation>> Destruct(InterpretationUnit unit, IPredictiveSavedEvaluation evaluation, LocalList`1<IType> types, ITreeNode lbl);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationEx/<DestructTuple>d__11")]
[ExtensionAttribute]
public static Task`1<List`1<IPredictiveSavedEvaluation>> DestructTuple(InterpretationUnit unit, IPredictiveSavedEvaluation evaluation, ITreeNode lbl, int count);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationEx/<ImplicitCastCall>d__12")]
[ExtensionAttribute]
public static Task`1<SavedEdge> ImplicitCastCall(InterpretationUnit Unit, IType expressionType, SavedEdge dso, ITreeNode lbl);
    public static ICSharpExpression CreateElementAccessExpression(IPredictiveSavedEvaluation evaluation, DeclaredElementInstance`1<IndexDebuggerElement> element, DebuggerState2 state2);
    public static ICSharpExpression CreateChildExpression(IPredictiveSavedEvaluation evaluation, DeclaredElementInstance element);
    private static IType ToClosedType(DeclaredElementInstance element);
    private static IType FixSubstitution(IType destination, DeclaredElementInstance element);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationExtensions : object {
    public static string EvaluationThrownAnException;
    public static QualifierKind GetQualifierKind(IClrDeclaredElement element);
    [ExtensionAttribute]
public static Task`1<bool> HasVariableChanged(InterpretationUnit unit, IExpression variable, ITreeNode label);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationExtensions/<GetOrInsertVariable>d__4")]
[ExtensionAttribute]
public static Task`1<SavedEdge> GetOrInsertVariable(InterpretationUnit unit, IClrDeclaredElement element, ITreeNode lbl, bool isImpureEvaluation);
    [ExtensionAttribute]
private static Task`1<T> Evaluate(InterpretationUnit unit, IExpression expression, ITreeNode lbl, Func`2<IPredictiveEvaluation, T> onResult, Func`2<Task, T> onFailure, bool pure);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationExtensions/<Evaluate>d__6")]
[ExtensionAttribute]
public static Task`1<IPredictiveEvaluation> Evaluate(InterpretationUnit unit, IExpression expression, ITreeNode lbl, bool pure);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationExtensions/<EvaluateAndSave>d__7")]
[ExtensionAttribute]
public static Task`1<IPredictiveSavedEvaluation> EvaluateAndSave(InterpretationUnit unit, ICSharpExpression expression, ITreeNode lbl, IType type);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.EvaluationExtensions/<CustomEvaluate>d__8`1")]
[ExtensionAttribute]
public static Task`1<T> CustomEvaluate(InterpretationUnit unit, ICSharpExpression node, Func`4<InterpretationUnit, ICSharpExpression, IType, Task`1<T>> lambda, ITreeNode lbl, IType type);
    private static void AfterEvaluation(InterpretationUnit unit, ITreeNode lbl, IPredictiveEvaluation evaluation, IExpression expression);
    private static void CatchException(InterpretationUnit unit, ITreeNode lbl, IPredictiveEvaluation evaluation, IExpression expression);
    [ExtensionAttribute]
public static void CatchException(InterpretationUnit unit, ITreeNode lbl, SavedEdge exception);
    private static bool EvaluationContinuation(InterpretationUnit unit, ITreeNode lbl, Task`1<IPredictiveEvaluation> t, IExpression expression);
    private static Task`1<IPredictiveEvaluation> Evaluate(IExpressionEvaluator evaluator, ITreeNode node, bool pure);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.FakePredictiveEvaluation : object {
    [CompilerGeneratedAttribute]
private ITreeNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    public bool IsTrueSaved { get; }
    public ITreeNode Expression { get; }
    public string Value { get; }
    public IType Type { get; }
    public IProject Project { get; }
    public IPsiModule PsiModule { get; }
    public bool HasChildren { get; }
    public string Error { get; }
    public bool IsException { get; }
    public FakePredictiveEvaluation(IExpression expression);
    public sealed virtual bool get_IsTrueSaved();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IProject get_Project();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual bool get_HasChildren();
    public sealed virtual string get_Error();
    public sealed virtual bool get_IsException();
    public sealed virtual long GetPointer();
    public sealed virtual IPredictiveEvaluation GetChild(string name, string containingType);
    public sealed virtual IPredictiveEvaluation GetIndexChild(String[] index);
    public sealed virtual Task`1<IPredictiveSavedEvaluation> EvaluateChild(DeclaredElementInstance`1<IClrDeclaredElement> element, DebuggerState2 state);
    public sealed virtual Task`1<IPredictiveEvaluation> Reevaluate();
    public static FakePredictiveEvaluation NullForExpression(IExpression expression);
    public static FakePredictiveEvaluation BooleanForExpression(IExpression expression, bool value);
    public static FakePredictiveEvaluation DefaultForType(IType type, ITreeNode node);
    public static FakePredictiveEvaluation DefaultForExpression(IExpression expression);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.IExpressionEvaluator {
    [ObsoleteAttribute("Use Unit.Evaluate()")]
public abstract virtual Task`1<IPredictiveEvaluation> EvaluateAsync(ITreeNode expression);
    [ObsoleteAttribute("Use Unit.Evaluate()")]
public abstract virtual Task`1<IPredictiveEvaluation> EvaluateAsync(ITreeNode expression, bool pure);
    public abstract virtual Task`1<IPredictiveSavedEvaluation> CreateOutVariable(IType type, ITreeNode factory, IExpression expression);
    public abstract virtual Task`1<IPredictiveSavedEvaluation> EvaluateAndSaveAsync(ICSharpExpression expression, IType type);
    public abstract virtual Task`1<IPredictiveSavedEvaluation> EvaluateToRef(ICSharpExpression expression, IType type);
    public abstract virtual Task`1<IPredictiveSavedEvaluation> EvaluateChild(IPredictiveSavedEvaluation obj, TypeMemberInstance elementInstance);
    public abstract virtual Task`1<IPredictiveSavedEvaluation> EvaluateChild(IPredictiveSavedEvaluation obj, DeclaredElementInstance`1<IndexDebuggerElement> elementInstance, DebuggerState2 state);
    public abstract virtual IType GetTypeParameter(ITypeParameter typeParameter);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.ImpureWarnInfo : object {
    [CompilerGeneratedAttribute]
private PredictiveStackFrame <Frame>k__BackingField;
    [CompilerGeneratedAttribute]
private Snapshot <Snapshot>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public PredictiveStackFrame Frame { get; public set; }
    public Snapshot Snapshot { get; public set; }
    public ImpureWarnInfo(PredictiveStackFrame Frame, Snapshot Snapshot);
    [CompilerGeneratedAttribute]
protected ImpureWarnInfo(ImpureWarnInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public PredictiveStackFrame get_Frame();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Frame(PredictiveStackFrame value);
    [CompilerGeneratedAttribute]
public Snapshot get_Snapshot();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Snapshot(Snapshot value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ImpureWarnInfo left, ImpureWarnInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ImpureWarnInfo left, ImpureWarnInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ImpureWarnInfo other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual ImpureWarnInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(PredictiveStackFrame& Frame, Snapshot& Snapshot);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.InlineEvaluationResult : ValueType {
    private InlineKind myKind;
    public IPredictiveEvaluationContainer TempContainer;
    private InterpretationUnit Unit;
    private IControlFlowWalker Walker;
    private VariablesFork Fork;
    private SavedEdge Result;
    public bool HasContinuation { get; }
    public bool HasEmptyResult { get; }
    public bool IsFailed { get; }
    private InlineEvaluationResult(InlineKind kind, InterpretationUnit unit, VariablesFork fork, SavedEdge result, IPredictiveEvaluationContainer tempContainer);
    public bool get_HasContinuation();
    public bool get_HasEmptyResult();
    public bool get_IsFailed();
    public static InlineEvaluationResult CreateResult(SavedEdge edge);
    public static InlineEvaluationResult CreateResult();
    public static InlineEvaluationResult CreateException(SavedEdge exception);
    public static InlineEvaluationResult CreateWithContinuation(InterpretationUnit unit, VariablesFork fork, IPredictiveEvaluationContainer batchForImpure);
    public static InlineEvaluationResult CreateFailed(IPredictiveEvaluationContainer batchForImpure);
    public bool TryGetResult(SavedEdge& result);
    public bool TryGetException(SavedEdge& exception);
    public void Pop();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.InlineEvaluationUtils : object {
    [ExtensionAttribute]
private static IControlFlowGraph CreateInlinedPropertyExpression(InterpretationUnit unit, TypeMemberInstance`1<IProperty> property, ITreeNode& expression);
    [ExtensionAttribute]
private static IControlFlowGraph CreateInlinedPropertyExpression(InterpretationUnit unit, TypeMemberInstance`1<IAccessor> property, ITreeNode& expression);
    [ExtensionAttribute]
private static IControlFlowGraph CreateInlinedMethodExpression(InterpretationUnit unit, TypeMemberInstance`1<IMethod> method, ITreeNode& expression);
    [ExtensionAttribute]
private static IControlFlowGraph CreateInlinedExpression(InterpretationUnit unit, TypeMemberInstance method, ITreeNode& expression);
    [ExtensionAttribute]
public static Task`1<InlineEvaluationResult> InlinePredictProperty(InterpretationUnit Unit, TypeMemberInstance`1<IProperty> property, SavedEdge holder, ITreeNode lbl);
    [ExtensionAttribute]
public static Task`1<InlineEvaluationResult> InlinePredictProperty(InterpretationUnit Unit, TypeMemberInstance`1<IAccessor> property, SavedEdge holder, ITreeNode lbl);
    [ExtensionAttribute]
public static Task`1<InlineEvaluationResult> InlinePredictProperty(InterpretationUnit Unit, TypeMemberInstance`1<IAccessor> property, SavedEdge holder, ITreeNode lbl, SavedEdge value);
    [ExtensionAttribute]
public static Task`1<InlineEvaluationResult> InlinePredictMethod(InterpretationUnit Unit, TypeMemberInstance`1<IMethod> method, SavedEdge holder, IDictionary`2<string, ValueTuple`2<SavedEdge, IParameter>> args, ITreeNode lbl);
    [ExtensionAttribute]
private static TypeMemberInstance ToGeneric(TypeMemberInstance from);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.InlineEvaluationUtils/<InlinePredict>d__9")]
[ExtensionAttribute]
private static Task`1<InlineEvaluationResult> InlinePredict(InterpretationUnit Unit, TypeMemberInstance typeMember, SavedEdge holder, IDictionary`2<string, ValueTuple`2<SavedEdge, IParameter>> args, ITreeNode lbl, ITreeNode node);
    private static InlineEvaluationResult GetResult(ITreeNode expression, InterpretationUnit newUnit, IPredictiveEvaluationContainer batchForImpure);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.InlineEvaluationUtils/<Continue>d__11")]
[ExtensionAttribute]
public static Task`1<bool> Continue(InterpretationUnit Unit);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.IPredictiveEvaluation {
    public string Value { get; }
    public IType Type { get; }
    public IProject Project { get; }
    public IPsiModule PsiModule { get; }
    public bool HasChildren { get; }
    public string Error { get; }
    public bool IsException { get; }
    public abstract virtual string get_Value();
    public abstract virtual IType get_Type();
    public abstract virtual IProject get_Project();
    public abstract virtual IPsiModule get_PsiModule();
    public abstract virtual bool get_HasChildren();
    public abstract virtual string get_Error();
    public abstract virtual bool get_IsException();
    public abstract virtual long GetPointer();
    [CanBeNullAttribute]
public abstract virtual IPredictiveEvaluation GetChild(string name, string containingType);
    [CanBeNullAttribute]
public abstract virtual IPredictiveEvaluation GetIndexChild(String[] index);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.IPredictiveEvaluationContainer {
    public abstract virtual void Add(ITreeNode treeNode, IPredictiveEvaluation evaluation);
    public abstract virtual void Add(ITreeNode treeNode, SavedEdge edge, Snapshot snapshot);
    public abstract virtual void AddWarn(ITreeNode treeNode, string message);
    public abstract virtual void SetStopWarn(ITreeNode node, string message);
    public abstract virtual void ImpureWarn(ITreeNode treeNode, Key key, ImpureWarnInfo info, PredictiveStackFrames frames, DebuggerState2 state);
    public abstract virtual void AddHalt(ITreeNode node, string message);
    public abstract virtual void AddConditionHighlight(ITreeNode elementSourceElement, bool b);
    public abstract virtual void AddWarnHighlight(TreeRange range);
    public abstract virtual void AddHaltHighlight(TreeRange range);
    [ObsoleteAttribute("Use BlindUtils")]
public abstract virtual void AddDeadCodeHighlight(TreeRange toBlind);
    public abstract virtual IPredictiveEvaluationContainer AddBatch();
    public abstract virtual IPredictiveIterationsContainer AddLoop(ILoopStatement loopStatement);
    public abstract virtual IPredictiveEvaluationContainer PredictInto(ITreeNode node, IDeclaredElement element);
    public abstract virtual void Clear();
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.IPredictiveEvaluationDecorator {
    public IPredictiveEvaluation Implementation { get; }
    public abstract virtual IPredictiveEvaluation get_Implementation();
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.IPredictiveIterationsContainer {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual IPredictiveEvaluationContainer AddIteration();
    public abstract virtual IPredictiveEvaluationContainer Last();
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.IPredictiveSavedEvaluation {
    public bool IsTrueSaved { get; }
    public ITreeNode Expression { get; }
    public abstract virtual bool get_IsTrueSaved();
    public abstract virtual ITreeNode get_Expression();
    public abstract virtual Task`1<IPredictiveSavedEvaluation> EvaluateChild(DeclaredElementInstance`1<IClrDeclaredElement> element, DebuggerState2 state);
    public abstract virtual Task`1<IPredictiveEvaluation> Reevaluate();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.LoopIterationInfo : object {
    public static Key`1<LoopIterationInfo> Key;
    public int CurrentIteration;
    public int VisibleIteration;
    private static LoopIterationInfo();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.SavedEvaluationDecorator : object {
    private IPredictiveEvaluation myImplementation;
    private IExpressionEvaluator myEvaluator;
    [CompilerGeneratedAttribute]
private ITreeNode <Expression>k__BackingField;
    private IPredictiveEvaluation JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.IPredictiveEvaluationDecorator.Implementation { get; }
    public bool IsTrueSaved { get; }
    public ITreeNode Expression { get; }
    public string Value { get; }
    public IType Type { get; }
    public IProject Project { get; }
    public IPsiModule PsiModule { get; }
    public bool HasChildren { get; }
    public string Error { get; }
    public bool IsException { get; }
    public SavedEvaluationDecorator(IPredictiveEvaluation implementation, ITreeNode expression, IExpressionEvaluator evaluator);
    private sealed virtual override IPredictiveEvaluation JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.IPredictiveEvaluationDecorator.get_Implementation();
    public sealed virtual bool get_IsTrueSaved();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_Expression();
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.SavedEvaluationDecorator/<Reevaluate>d__9")]
public sealed virtual Task`1<IPredictiveEvaluation> Reevaluate();
    public sealed virtual string get_Value();
    public sealed virtual IType get_Type();
    public sealed virtual IProject get_Project();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual bool get_HasChildren();
    public sealed virtual string get_Error();
    public sealed virtual bool get_IsException();
    public sealed virtual long GetPointer();
    public sealed virtual IPredictiveEvaluation GetChild(string name, string containingType);
    public sealed virtual IPredictiveEvaluation GetIndexChild(String[] index);
    public sealed virtual Task`1<IPredictiveSavedEvaluation> EvaluateChild(DeclaredElementInstance`1<IClrDeclaredElement> element, DebuggerState2 state);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.TimeOutEvaluation : object {
    [CompilerGeneratedAttribute]
private IProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    public string Value { get; }
    public IType Type { get; }
    public IProject Project { get; }
    public IPsiModule PsiModule { get; }
    public bool HasChildren { get; }
    public string Error { get; }
    public bool IsException { get; }
    public TimeOutEvaluation(IProject project, IPsiModule psiModule);
    public sealed virtual string get_Value();
    public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IProject get_Project();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual bool get_HasChildren();
    public sealed virtual string get_Error();
    public sealed virtual bool get_IsException();
    public sealed virtual long GetPointer();
    public sealed virtual IPredictiveEvaluation GetChild(string name, string containingType);
    public sealed virtual IPredictiveEvaluation GetIndexChild(String[] index);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Evaluation.TimeOutSavedEvaluation : TimeOutEvaluation {
    public bool IsTrueSaved { get; }
    public ITreeNode Expression { get; }
    public TimeOutSavedEvaluation(IProject project, IPsiModule psiModule);
    public sealed virtual bool get_IsTrueSaved();
    public sealed virtual ITreeNode get_Expression();
    public sealed virtual Task`1<IPredictiveSavedEvaluation> EvaluateChild(DeclaredElementInstance`1<IClrDeclaredElement> element, DebuggerState2 state);
    public sealed virtual Task`1<IPredictiveEvaluation> Reevaluate();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.ForkCookie : ValueType {
    private VariableForkCookie myVariableForkCookie;
    private InterpretationUnit Unit;
    public VariablesFork Fork { get; }
    public ForkCookie(InterpretationUnit unit, VariableForkCookie variableFork);
    public VariablesFork get_Fork();
    [IsReadOnlyAttribute]
public sealed virtual void Dispose();
    public void Defuse();
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.IControlFlowWalker {
    [CanBeNullAttribute]
[ObsoleteAttribute("Use BeginControlFlowElement or SelectingControlFlowElement")]
public IControlFlowElement ControlFlowElement { get; }
    [CanBeNullAttribute]
public IControlFlowElement BeginControlFlowElement { get; }
    [CanBeNullAttribute]
public IControlFlowElement SelectingControlFlowElement { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public Stack`1<IControlFlowElement> TryStack { get; }
    public bool HasContinuation { get; }
    public bool IsSuccessfullyFinished { get; }
    public abstract virtual IControlFlowElement get_ControlFlowElement();
    public abstract virtual IControlFlowElement get_BeginControlFlowElement();
    public abstract virtual IControlFlowElement get_SelectingControlFlowElement();
    public abstract virtual Stack`1<IControlFlowElement> get_TryStack();
    public abstract virtual bool get_HasContinuation();
    public abstract virtual bool get_IsSuccessfullyFinished();
    [ObsoleteAttribute("Use Unit.Stop()")]
public abstract virtual void Stop();
    public abstract virtual void SetNext(IControlFlowElement next);
    public abstract virtual void SetSingleExit();
    public abstract virtual void Resume(IControlFlowElement next);
    public abstract virtual void ContinueAt(IControlFlowElement continuation);
    public abstract virtual void ContinueHere();
    public abstract virtual void SuccessfullyFinish();
    public abstract virtual void MoveNext();
    public abstract virtual void Fix(bool fix);
    public abstract virtual void Continue();
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.IIntermediatesStep {
    public abstract virtual Task StepAsync(IControlFlowElement element, StepParameter parameter);
    public abstract virtual Task StepDispose();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.ImpureValidatorWithNode : ValueType {
    private InterpretationUnit Unit;
    private ITreeNode myLabel;
    public ImpureValidatorWithNode(InterpretationUnit unit, ITreeNode label);
    public bool Impure(IDeclaredElement element, ImpureWarnInfo info);
    public DeclaredElementWithPureCheck ToDeclaredElementWithPureCheck(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.InterpretationUnit : object {
    public Lifetime Lifetime;
    [CompilerGeneratedAttribute]
private IPredictiveEvaluationContainer <Container>k__BackingField;
    [NotNullAttribute]
public IExpressionEvaluator Evaluator;
    [NotNullAttribute]
public DebuggerState2 State;
    [NotNullAttribute]
public EvaluationAccumulator Accumulator;
    [NotNullAttribute]
public IPredictiveForkBuilder ForkBuilder;
    [NotNullAttribute]
public PredictiveImpureValidator Pureness;
    [NotNullAttribute]
public TaskScheduler Scheduler;
    [NotNullAttribute]
public ILog Logger;
    [NotNullAttribute]
internal SingleExitInterpreter SkipInterpreter;
    [NotNullAttribute]
internal Stack`1<LoopInfo> Loops;
    [NotNullAttribute]
internal PredictiveStackFrames Stack;
    [NotNullAttribute]
private LastBatch myLastBatch;
    [NotNullAttribute]
public IPredictiveEvaluationContainer Container { get; private set; }
    [NotNullAttribute]
public IControlFlowWalker Callback { get; }
    internal InterpretationUnit(Lifetime lifetime, IExpressionEvaluator evaluator, IPredictiveEvaluationContainer container, DebuggerState2 state, EvaluationAccumulator accumulator, PredictiveImpureValidator pureness, IPredictiveForkBuilder forkBuilder, TaskScheduler scheduler, ILog logger, PredictiveStackFrames stack, LastBatch lastBatch);
    [CompilerGeneratedAttribute]
public IPredictiveEvaluationContainer get_Container();
    [CompilerGeneratedAttribute]
private void set_Container(IPredictiveEvaluationContainer value);
    public IControlFlowWalker get_Callback();
    public void Halt(ITreeNode node, string message);
    public void ResetAll(IModuleReferenceResolveContext moduleReferenceResolveContext, ITreeNode declaration);
    public void Stop(string message, ITreeNode lbl);
    public void Assert(bool cond, string message);
    public Task`1<T> Substitute(T src, int validationCount);
    public LoopContainerCookie EnterLoop(ILoopStatement loop);
    public LoopContainerCookie EnterLoop2(ITreeNode node);
    private static LoopIterationInfo LoopInfo(ILoopStatement loop);
    public BatchCookie CreateBatchCookie(IPredictiveEvaluationContainer container);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.<UsingInterpreter>FB0A91D9D05D217776D5650A31AFF608655FEC44D87A20C1D9DCFB935F9EA6378__UsingInterpreter : AsyncInterpreterBase {
    public <UsingInterpreter>FB0A91D9D05D217776D5650A31AFF608655FEC44D87A20C1D9DCFB935F9EA6378__UsingInterpreter(InterpretationUnit unit);
    public virtual Task EvaluateAsync(IControlFlowElement element);
    private static IControlFlowElement GetEndElement(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ArgumentInterpreter : AsyncTreeInterpreterBase {
    public ArgumentInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ArgumentInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ArgumentInterpreter/<OutVariable>d__2")]
private Task`1<bool> OutVariable(ICSharpArgument arg);
    private bool IsSaved(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ArrayConstructorInterpreter : AsyncTreeInterpreterBase {
    public ArrayConstructorInterpreter(InterpretationUnit unit);
    protected virtual Task EvaluateAsync(ITreeNode node);
    private static int ArrayInitializer(IArrayInitializer constructor);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.AsInterpreter : TreeInterpreterBase {
    public AsInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.AssignmentInterpreter : AsyncTreeInterpreterBase {
    public AssignmentInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.AssignmentInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
    private bool InlineSetter(IAssignmentExpression assignment, SavedEdge& holder, TypeMemberInstance`1& typeMemberInstance);
    private void ObjectUpdate(SavedEdge destination, SavedEdge source, ITreeNode destinationNode);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.AssignmentInterpreter/<Source>d__4")]
private Task`1<ValueTuple`2<SavedEdge, IType>> Source(IAssignmentExpression assignment);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.AssignmentInterpreter/<Destruct>d__5")]
private Task Destruct(ITupleExpression expression, IPredictiveSavedEvaluation evaluation);
    private void ShowVariablesInDesignation(IVariableDesignation designation);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.AsyncInterpreterBase : object {
    [NotNullAttribute]
protected InterpretationUnit Unit;
    protected AsyncInterpreterBase(InterpretationUnit unit);
    public abstract virtual Task EvaluateAsync(IControlFlowElement element);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.AsyncTreeInterpreterBase : AsyncInterpreterBase {
    protected AsyncTreeInterpreterBase(InterpretationUnit unit);
    protected abstract virtual Task EvaluateAsync(ITreeNode node);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.AsyncTreeInterpreterBase/<EvaluateAsync>d__2")]
public virtual Task EvaluateAsync(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.BeforeUsingDeclarationInterpreter : AsyncInterpreterBase {
    private IMultipleLocalVariableDeclaration myDeclaration;
    private IIntermediatesStep myStep;
    public BeforeUsingDeclarationInterpreter(InterpretationUnit unit, IMultipleLocalVariableDeclaration declaration, IIntermediatesStep step);
    public virtual Task EvaluateAsync(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.BranchingEvaluator : AsyncInterpreterBase {
    private IIntermediatesStep myStep;
    public BranchingEvaluator(InterpretationUnit unit, IIntermediatesStep step);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.BranchingEvaluator/<EvaluateAsync>d__2")]
public virtual Task EvaluateAsync(IControlFlowElement element);
    private void HighlightCondition(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.BranchingMultiplexorInterpreter : InterpreterBase {
    public BranchingMultiplexorInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement element);
    private static IIfStatement FindIf(ITreeNode conditionNode);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.CastInterpreter : AsyncTreeInterpreterBase {
    public CastInterpreter(InterpretationUnit unit);
    protected virtual Task EvaluateAsync(ITreeNode node);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.CastInterpreter/<EvaluateWithConversion>d__2")]
private Task EvaluateWithConversion(ITreeNode expression, IType expressionType, SavedEdge dso);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.CatchInterpreter : InterpreterBase {
    public CatchInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement element);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.Dag.PredictiveDagTestVisitor : DagTestVisitor`2<Context, Task> {
    private InterpretationUnit Unit;
    private SavedDagResultsContainer myEvaluations;
    public PredictiveDagTestVisitor(InterpretationUnit unit);
    public virtual Task VisitDagEvaluation(Context context, DagEvaluation dagEvaluation);
    public virtual Task VisitDagTypeEvaluation(Context context, DagTypeEvaluation dagTypeEvaluation);
    public virtual Task VisitDagFieldEvaluation(Context context, DagFieldEvaluation dagFieldEvaluation, IField declaredElement);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.Dag.PredictiveDagTestVisitor/<VisitDagPropertyEvaluation>d__3")]
public virtual Task VisitDagPropertyEvaluation(Context context, DagPropertyEvaluation dagPropertyEvaluation, IProperty declaredElement);
    public virtual Task VisitDagIndexEvaluation(Context context, DagIndexEvaluation dagIndexEvaluation, int index);
    public virtual Task VisitDagTupleComponentEvaluation(Context context, DagTupleComponentEvaluation dagTupleComponent);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.Dag.PredictiveDagTestVisitor/<VisitDagDeconstructEvaluation>d__6")]
public virtual Task VisitDagDeconstructEvaluation(Context context, DagDeconstructEvaluation dagDeconstructEvaluation);
    private Task DagObjectChildEvaluation(Context context, DagEvaluation dagFieldEvaluation, SavedEdge debuggerSavedObject);
    public Task Apply(IControlFlowElement element, SavedEdge obj, ITreeNode node);
    public virtual Task VisitDagTest(Context context, DagTest dagTest);
    public virtual Task VisitDagValueTest(Context context, DagTest dagTest, ConstantValue constantValue);
    public virtual Task VisitDagTypeTest(Context context, DagTypeTest dagTypeTest);
    public virtual Task VisitExplicitNullTest(Context context, DagExplicitNullTest dagTest);
    public virtual Task VisitDagNonNullTest(Context context, DagNonNullTest dagTest);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.Dag.PredictiveDagTestVisitor/<VisitDagRelationalTest>d__17")]
public virtual Task VisitDagRelationalTest(Context context, DagTest dagRelationalTest, ValueSetOperation relation, ConstantValue value);
    private static bool ExitCondition(bool condition, ICSharpControlFlowEdge cscfg);
    private Task ChooseBranch(Context context, bool condition);
    private SavedEdge GetValue(DagTest test, Context context);
    private SavedEdge GetValue(Context context, DagTempVariable dagTempVariable);
    public virtual Task VisitVariableBinding(Context context, IReadOnlyList`1<PatternBinding> bindingElementBindings, DecisionDagConclusion bindingElementDagConclusion, WhenDecisionDagNode bindingElementWhenDagNode);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.Dag.SavedDagResultsContainer : ValueType {
    private Dictionary`2<DagEvaluation, Dictionary`2<int, SavedEdge>> myEvaluations;
    public void Add(DagEvaluation dag, SavedEdge savedObject, ITreeNode node);
    public void Add(DagEvaluation dag, SavedEdge savedEdge, ITreeNode node, int index);
    public bool TryGetValue(DagEvaluation dag, SavedEdge& value, ITreeNode node, int index);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.DefaultInterpreter : TypeArgumentExpressionInterpreter {
    public DefaultInterpreter(InterpretationUnit unit);
    protected virtual IType Type(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.DisposeInterpreter : AsyncInterpreterBase {
    private IIntermediatesStep myStep;
    public DisposeInterpreter(InterpretationUnit unit, IIntermediatesStep step);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.DisposeInterpreter/<EvaluateAsync>d__2")]
public virtual Task EvaluateAsync(IControlFlowElement element);
    private Task DisposeValue(ITreeNode statement, SavedEdge value);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ElementAccessInterpreter : AsyncTreeInterpreterBase {
    public ElementAccessInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ElementAccessInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.EndOfLoopStatementInterpreter : TreeInterpreterBase {
    public EndOfLoopStatementInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.FailureInterpreter : InterpreterBase {
    public FailureInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement _);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.FirstStepLoopInterpreter : LoopInterpreter {
    public FirstStepLoopInterpreter(InterpretationUnit unit, IIntermediatesStep intermediate);
    protected virtual void SkipLoopNodes(ILoopStatement loopStatement);
    public virtual Task EvaluateAsync(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ForeachHeaderInterpreter : AsyncInterpreterBase {
    public ForeachHeaderInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ForeachHeaderInterpreter/<EvaluateAsync>d__1")]
public virtual Task EvaluateAsync(IControlFlowElement element);
    private static ICSharpExpression MoveNextExpression(ICSharpExpression collection, SavedEdge holder);
    private static ICSharpExpression CurrentExpression(ICSharpExpression collection, SavedEdge holder);
    private static ICSharpExpression DisposeExpression(ICSharpExpression collection, SavedEdge holder);
    private static ICSharpExpression CreateExpression(string expression, ICSharpExpression collection, SavedEdge holder);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ForeachStatementInterpreter : AsyncInterpreterBase {
    private static IReadOnlyList`1<IClrTypeName> ourPureCollections;
    public ForeachStatementInterpreter(InterpretationUnit unit);
    private static ForeachStatementInterpreter();
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ForeachStatementInterpreter/<EvaluateAsync>d__2")]
public virtual Task EvaluateAsync(IControlFlowElement element);
    private static IType FindEnumeratorType(IControlFlowElement element, ICSharpExpression collection, SavedEdge holder);
    private bool IsTypePure(IType holderType);
    private static ICSharpExpression EnumeratorExpression(ICSharpExpression collection, SavedEdge holder);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ImplicitReturnInterpreter : InterpreterBase {
    public ImplicitReturnInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.IncrementInterpreter : AsyncTreeInterpreterBase {
    public IncrementInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.IncrementInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
    private Task`1<ICSharpExpression> TransformExpression(ITreeNode node, string operation, ITreeNode operand);
    private static void ExpressionParameters(ITreeNode node, Boolean& needUpdate, IUnaryExpression& operand, String& operation);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.IntermediateInterpreter : AsyncTreeInterpreterBase {
    private int mySubstituteCount;
    public IntermediateInterpreter(InterpretationUnit unit, int substituteCount);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.IntermediateInterpreter/<EvaluateAsync>d__2")]
protected virtual Task EvaluateAsync(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InterpolatedStringInterpreter : AsyncTreeInterpreterBase {
    public InterpolatedStringInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InterpolatedStringInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InterpreterBase : AsyncInterpreterBase {
    protected InterpreterBase(InterpretationUnit unit);
    public virtual Task EvaluateAsync(IControlFlowElement element);
    protected abstract virtual void Evaluate(IControlFlowElement element);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InterpreterVisitor : TreeNodeVisitor`2<IControlFlowElement, AsyncInterpreterBase> {
    [NotNullAttribute]
protected InterpretationUnit Unit;
    [NotNullAttribute]
private CodeAnnotationsCache myCodeAnnotationsCache;
    [NotNullAttribute]
private PredictiveDagTestVisitor myDagTestVisitor;
    public InterpreterVisitor(InterpretationUnit unit, CodeAnnotationsCache codeAnnotationsCache);
    [NotNullAttribute]
public virtual AsyncInterpreterBase PrepareInterpreter(IControlFlowElement element, StepParameter stepParameter);
    public virtual AsyncInterpreterBase VisitNode(ITreeNode node, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitBlock(IBlock block, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitExpressionStatement(IExpressionStatement expression, IControlFlowElement context);
    internal void Reset(IModuleReferenceResolveContext moduleReferenceResolveContext, ITreeNode declaration);
    public virtual AsyncInterpreterBase VisitTupleComponent(ITupleComponent tupleComponentParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitTupleExpression(ITupleExpression tupleExpression, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitDeclarationExpression(IDeclarationExpression declarationExpressionParam, IControlFlowElement context);
    public sealed virtual Task StepAsync(IControlFlowElement current, StepParameter parameter);
    public Task StepInLoopAsync(IControlFlowElement current);
    public sealed virtual Task StepDispose();
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InterpreterVisitor/<ContinueOnStack>d__15")]
public Task ContinueOnStack();
    public virtual AsyncInterpreterBase VisitAsExpression(IAsExpression asExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitAssignmentExpression(IAssignmentExpression expression, IControlFlowElement _);
    public virtual AsyncInterpreterBase VisitConditionalTernaryExpression(IConditionalTernaryExpression _, IControlFlowElement __);
    public virtual AsyncInterpreterBase VisitCastExpression(ICastExpression castExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitObjectInitializer(IObjectInitializer objectInitializerParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitCollectionInitializer(ICollectionInitializer collectionInitializerParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitArrayInitializer(IArrayInitializer arrayInitializerParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitElementAccessExpression(IElementAccessExpression elementAccessExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitPostfixOperatorExpression(IPostfixOperatorExpression expression, IControlFlowElement _);
    public virtual AsyncInterpreterBase VisitPrefixOperatorExpression(IPrefixOperatorExpression expression, IControlFlowElement _);
    public virtual AsyncInterpreterBase VisitCSharpLiteralExpression(ICSharpLiteralExpression expression, IControlFlowElement _);
    public virtual AsyncInterpreterBase VisitUnaryOperatorExpression(IUnaryOperatorExpression unaryOperatorExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitBinaryExpression(IBinaryExpression expression, IControlFlowElement _);
    public virtual AsyncInterpreterBase VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitCheckedExpression(ICheckedExpression checkedExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitUncheckedExpression(IUncheckedExpression uncheckedExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitThisExpression(IThisExpression _, IControlFlowElement __);
    public virtual AsyncInterpreterBase VisitBaseExpression(IBaseExpression _, IControlFlowElement __);
    public virtual AsyncInterpreterBase VisitDefaultExpression(IDefaultExpression _, IControlFlowElement __);
    public virtual AsyncInterpreterBase VisitTypeofExpression(ITypeofExpression typeofExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitSuppressNullableWarningExpression(ISuppressNullableWarningExpression suppressNullableWarningExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitNullCoalescingExpression(INullCoalescingExpression nullCoalescingExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitInvocationExpression(IInvocationExpression _, IControlFlowElement __);
    public virtual AsyncInterpreterBase VisitCSharpArgument(ICSharpArgument _, IControlFlowElement __);
    public virtual AsyncInterpreterBase VisitIsExpression(IIsExpression isExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitConditionalAndExpression(IConditionalAndExpression conditionalAndExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitLambdaExpression(ILambdaExpression lambdaExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitForInitializer(IForInitializer _, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitForIterator(IForIterator _, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitForStatement(IForStatement forStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitDoStatement(IDoStatement doStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitWhileStatement(IWhileStatement whileStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitContinueStatement(IContinueStatement continueStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitBreakStatement(IBreakStatement breakStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitForeachHeader(IForeachHeader foreachHeaderParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitForeachStatement(IForeachStatement foreachStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitReferenceExpression(IReferenceExpression expression, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitReturnStatement(IReturnStatement returnStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitSwitchExpression(ISwitchExpression switchExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitSwitchExpressionArm(ISwitchExpressionArm switchExpressionArmParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitSwitchStatement(ISwitchStatement switchStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitSwitchCaseLabel(ISwitchCaseLabel switchCaseLabelParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitTryStatement(ITryStatement tryStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitThrowExpression(IThrowExpression throwExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitThrowStatement(IThrowStatement throwStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitUsingStatement(IUsingStatement usingStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitDeclarationStatement(IDeclarationStatement declarationStatementParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitWithExpression(IWithExpression withExpressionParam, IControlFlowElement context);
    public virtual AsyncInterpreterBase VisitWithInitializerAssignment(IWithInitializerAssignment withInitializerAssignmentParam, IControlFlowElement context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InvocationInterpreter : AsyncInterpreterBase {
    [NotNullAttribute]
private CodeAnnotationsCache myAnnotationsCache;
    public InvocationInterpreter(InterpretationUnit unit, CodeAnnotationsCache annotationsCache);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InvocationInterpreter/<EvaluateAsync>d__2")]
public virtual Task EvaluateAsync(IControlFlowElement element);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InvocationInterpreter/<EvaluateAsync>d__3")]
private Task EvaluateAsync(ITreeNode node);
    private static ITreeNode GetViewNode(ITreeNode node);
    private Task ReevaluateClosure(ICSharpArgument argument);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InvocationInterpreter/<ReevaluateClosure>d__6")]
private Task ReevaluateClosure(ILambdaExpression lambda);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.InvocationInterpreter/<SaveResult>d__7")]
private Task SaveResult(IInvocationExpression node, IPredictiveSavedEvaluation evaluation);
    private bool ReadContractAttribute(IInvocationExpression expression, IFunction func, Dictionary`2<string, ValueTuple`2<SavedEdge, IParameter>> args);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.IsInterpreter : AsyncInterpreterBase {
    private IIntermediatesStep myIntermediatesStep;
    public IsInterpreter(InterpretationUnit unit, IIntermediatesStep intermediatesStep);
    public virtual Task EvaluateAsync(IControlFlowElement element);
    private void CommonIs(IControlFlowElement element, SavedEdge savedObject, IIsExpression expression);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.IsInterpreter/<Loop>d__4")]
private Task Loop(PredictiveDagTestVisitor visitor, SavedEdge dso, IIsExpression end);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.LambdaInterpreter : AsyncTreeInterpreterBase {
    [NotNullAttribute]
private CodeAnnotationsCache myAnnotationsCache;
    [NotNullAttribute]
private static IReadOnlyCollection`1<string> ourLinqNamespace;
    public LambdaInterpreter(InterpretationUnit unit, CodeAnnotationsCache annotationsCache);
    private static LambdaInterpreter();
    protected virtual Task EvaluateAsync(ITreeNode node);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.LambdaInterpreter/<PrepareClosures>d__4")]
private Task PrepareClosures(ILambdaExpression lambda);
    private static bool IsArgumentOfLinq(ILambdaExpression lambda);
    private bool ValidatePureness(ICSharpExpression expression);
    private bool ValidateStatement(ICSharpStatement statement);
    private bool ValidatePattern(IPattern pattern);
    private bool ValidateNodePureness(IObjectCreationExpression objectCreationExpression);
    private bool ValidateNodePureness(IInvocationExpression invocationExpression);
    private bool ValidateNodePureness(IElementAccessExpression elementAccessExpression);
    private bool ValidateNodePureness(IReferenceExpression referenceExpression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.LiteralInterpreter : AsyncTreeInterpreterBase {
    public LiteralInterpreter(InterpretationUnit unit);
    protected virtual Task EvaluateAsync(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.LoopInfo : ValueType {
    public ILoopStatement LoopStatement;
    public ITreeNode LoopBody;
    public LoopContainerCookie LoopContainer;
    public LoopInfo(ILoopStatement loopStatement, LoopContainerCookie loopContainer);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.LoopInterpreter : AsyncInterpreterBase {
    private static int Limit;
    [NotNullAttribute]
private IIntermediatesStep myIntermediate;
    public LoopInterpreter(InterpretationUnit unit, IIntermediatesStep intermediate);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.LoopInterpreter/<EvaluateAsync>d__3")]
public virtual Task EvaluateAsync(IControlFlowElement element);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.LoopInterpreter/<Loop>d__4")]
protected Task Loop();
    protected virtual void SkipLoopNodes(ILoopStatement loop);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.NullCoalescingConstantNullInterpreter : InterpreterBase {
    public NullCoalescingConstantNullInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.NullCoalescingInterpreter : TreeInterpreterBase {
    public NullCoalescingInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ObjectConstructorInterpreter : AsyncTreeInterpreterBase {
    public ObjectConstructorInterpreter(InterpretationUnit unit);
    protected virtual Task EvaluateAsync(ITreeNode node);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ObjectConstructorInterpreter/<SaveResult>d__2")]
private Task SaveResult(IObjectCreationExpression node, int substitutionCount);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.OperatorInterpreter : AsyncTreeInterpreterBase {
    public OperatorInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.OperatorInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
    private Nullable`1<int> CountVariables(ITreeNode node, ITreeNode current, LocalList`1& localList);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ParenthesizeInterpreter : TreeInterpreterBase {
    public ParenthesizeInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ReferenceExpressionInterpreter : AsyncInterpreterBase {
    public ReferenceExpressionInterpreter(InterpretationUnit unit);
    public virtual Task EvaluateAsync(IControlFlowElement element);
    private bool ConditionalInvocationReference(IControlFlowElement element, IReferenceExpression expression, SavedEdge holder);
    private Task DotExpression(IControlFlowElement element, SavedEdge holder, IReferenceExpression expression);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ReferenceExpressionInterpreter/<EvaluateChild>d__4")]
private Task EvaluateChild(SavedEdge holder, DeclaredElementInstance`1<IClrDeclaredElement> instance, IControlFlowElement element, IReferenceExpression expression);
    private void SelectExit(IControlFlowElement element, SavedEdge edge);
    private Task SimpleName(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ReturnInterpreter : AsyncInterpreterBase {
    private IIntermediatesStep myStep;
    private static string MESSAGE;
    public ReturnInterpreter(InterpretationUnit unit, IIntermediatesStep step);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ReturnInterpreter/<EvaluateAsync>d__3")]
public virtual Task EvaluateAsync(IControlFlowElement element);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ReturnInterpreter/<UnwindDispose>d__4")]
public Task UnwindDispose();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.SingleExitInterpreter : InterpreterBase {
    public SingleExitInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.SkipInterpreter : InterpreterBase {
    [NotNullAttribute]
private IControlFlowElement myElement;
    public SkipInterpreter(IControlFlowElement element, InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement _);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.SuppressNullableWaningInterpreter : TreeInterpreterBase {
    public SuppressNullableWaningInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.SwitchExpressionInterpreter : AsyncInterpreterBase {
    private IIntermediatesStep myIntermediate;
    public SwitchExpressionInterpreter(InterpretationUnit unit, IIntermediatesStep intermediate);
    public virtual Task EvaluateAsync(IControlFlowElement element);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.SwitchExpressionInterpreter/<Loop2>d__3")]
private Task Loop2(PredictiveDagTestVisitor visitor, SavedEdge dso, ISwitchExpression end);
    private static IControlFlowElement Skip3(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.SwitchStatementInterpreter : AsyncInterpreterBase {
    [NotNullAttribute]
private IIntermediatesStep myIntermediate;
    public SwitchStatementInterpreter(InterpretationUnit unit, IIntermediatesStep intermediate);
    public virtual Task EvaluateAsync(IControlFlowElement element);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.SwitchStatementInterpreter/<Loop>d__3")]
private Task`1<ISwitchCaseLabel> Loop(PredictiveDagTestVisitor visitor, SavedEdge dso, ISwitchStatement end);
    private static bool IsBreak(IControlFlowElement element, ISwitchStatement parent);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TernaryOperatorInterpreter : TreeInterpreterBase {
    public TernaryOperatorInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ThrowEndInterpreter : AsyncInterpreterBase {
    [NotNullAttribute]
private IIntermediatesStep myIntermediate;
    public ThrowEndInterpreter(InterpretationUnit unit, IIntermediatesStep intermediate);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ThrowEndInterpreter/<EvaluateAsync>d__2")]
public virtual Task EvaluateAsync(IControlFlowElement element);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ThrowEndInterpreter/<Filter>d__3")]
private Task Filter(IControlFlowElement element, IExceptionFilterClause catchClauseFilter);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.ThrowInterpreter : TreeInterpreterBase {
    public ThrowInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(ITreeNode node);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TreeInterpreterBase : InterpreterBase {
    protected TreeInterpreterBase(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement element);
    protected abstract virtual void Evaluate(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TryBeginInterpreter : InterpreterBase {
    public TryBeginInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TryEndInterpreter : InterpreterBase {
    public TryEndInterpreter(InterpretationUnit unit);
    protected virtual void Evaluate(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TupleExpressionInterpreter : AsyncTreeInterpreterBase {
    public TupleExpressionInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TupleExpressionInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
    private int Count(ITupleExpression tuple);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TypeArgumentExpressionInterpreter : AsyncTreeInterpreterBase {
    private string myTemplate;
    protected TypeArgumentExpressionInterpreter(InterpretationUnit unit, string template);
    protected abstract virtual IType Type(ITreeNode node);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TypeArgumentExpressionInterpreter/<EvaluateAsync>d__3")]
protected virtual Task EvaluateAsync(ITreeNode node);
    private ICSharpExpression CreateExpression(ITreeNode node, IType expressionType, string template);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.TypeofInterpreter : TypeArgumentExpressionInterpreter {
    public TypeofInterpreter(InterpretationUnit unit);
    protected virtual IType Type(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.VariableDeclarationInterpreter : AsyncTreeInterpreterBase {
    public VariableDeclarationInterpreter(InterpretationUnit unit);
    protected virtual Task EvaluateAsync(ITreeNode node);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.VariableDeclarationInterpreter/<EvaluateArrayInitializer>d__2")]
private Task EvaluateArrayInitializer(ILocalVariableDeclaration expression);
    private bool PredictUsingVariableDeclaration(IControlFlowElement element);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.VariableDeclarationInterpreter/<EvaluateWithConversion>d__4")]
private Task EvaluateWithConversion(ILocalVariableDeclaration expression, IType expressionType, ICSharpIdentifier name, SavedEdge dso);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.VariableDeclarationInterpreter/<EvaluateVariableByName>d__5")]
private Task EvaluateVariableByName(ILocalVariableDeclaration node, ICSharpIdentifier name);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.WithAssignmentInterpreter : AsyncTreeInterpreterBase {
    public WithAssignmentInterpreter(InterpretationUnit unit);
    protected virtual Task EvaluateAsync(ITreeNode node);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.WithAssignmentInterpreter/<InlineProperty>d__2")]
private Task InlineProperty(TypeMemberInstance`1<IAccessor> typeMemberInstance, SavedEdge value, SavedEdge newChild, ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.WithBeginInterpreter : AsyncTreeInterpreterBase {
    public WithBeginInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.WithBeginInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.WithEndInterpreter : AsyncTreeInterpreterBase {
    public WithEndInterpreter(InterpretationUnit unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.Interpreter.WithEndInterpreter/<EvaluateAsync>d__1")]
protected virtual Task EvaluateAsync(ITreeNode node);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.IPredictiveForkBuilder {
    public abstract virtual ForkCookie Fork(IControlFlowGraph graph, TypeMemberInstance typeMemberInstance, InterpretationUnit& unit, ControlFlowWalker& walker, ITreeNode node, ImmutableDictionary`2<string, SavedEdge> attachBack, IPredictiveEvaluationContainer container, IPredictiveEvaluationContainer tempContainer);
    public abstract virtual ForkCookie Fork(InterpretationUnit currentUnit, InterpretationUnit& unit, ControlFlowWalker& walker);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.LastBatch : object {
    [CompilerGeneratedAttribute]
private IPredictiveEvaluationContainer <Container>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CanBeNullAttribute]
public IPredictiveEvaluationContainer Container { get; public set; }
    [CompilerGeneratedAttribute]
protected LastBatch(LastBatch original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IPredictiveEvaluationContainer get_Container();
    [CompilerGeneratedAttribute]
public void set_Container(IPredictiveEvaluationContainer value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LastBatch left, LastBatch right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LastBatch left, LastBatch right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(LastBatch other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual LastBatch <Clone>$();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.PredictiveBuilder : object {
    private Lifetime myLifetime;
    private TaskScheduler myTaskScheduler;
    private ILog myLog;
    private bool myIsInternal;
    private IExpressionEvaluator myEvaluator;
    private IPredictiveEvaluationContainer myContainer;
    private PredictiveImpureValidator myPureness;
    private CodeAnnotationsCache myCodeAnnotations;
    private DebuggerState2 myState;
    private EvaluationAccumulator myAccumulator;
    private PredictiveStackFrames myStack;
    private LastBatch myLastBatch;
    private int myCallCounter;
    public PredictiveBuilder(Lifetime lifetime, ISolution solution, IExpressionEvaluator evaluator, IPredictiveEvaluationContainer container, DebuggerState2 debuggerState2, PredictiveImpureValidator pureness, CodeAnnotationsCache codeAnnotations, TaskScheduler taskScheduler, ILog log);
    private void Build(IControlFlowGraph graph, TypeMemberInstance typeMemberInstance, IControlFlowElement element, InterpretationUnit& unit, ControlFlowWalker& walker, ITreeNode node, IPredictiveEvaluationContainer container, IPredictiveEvaluationContainer tempContainer);
    public ValueTuple`2<InterpretationUnit, ControlFlowWalker> Build(IControlFlowGraph graph, IControlFlowElement element, TypeMemberInstance typeMemberInstance);
    public sealed virtual ForkCookie Fork(IControlFlowGraph graph, TypeMemberInstance typeMemberInstance, InterpretationUnit& unit, ControlFlowWalker& walker, ITreeNode node, ImmutableDictionary`2<string, SavedEdge> attachBack, IPredictiveEvaluationContainer container, IPredictiveEvaluationContainer tempContainer);
    public sealed virtual ForkCookie Fork(InterpretationUnit currentUnit, InterpretationUnit& unit, ControlFlowWalker& walker);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.PredictiveImpureUtils : object {
    [ExtensionAttribute]
public static bool Impure(InterpretationUnit unit, ITreeNode node);
    [ExtensionAttribute]
public static bool SingleImpure(InterpretationUnit unit, IDeclaredElement declaredElement, ITreeNode label);
    [ExtensionAttribute]
private static bool Impure(InterpretationUnit unit, IDeclaredElement declaredElement, ITreeNode label, ImpureWarnInfo info);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.PredictiveImpureValidator : object {
    private static Key ourKey;
    protected CodeAnnotationsCache AnnotationsCache;
    protected IModuleReferenceResolveContext ResolveContext;
    private PureAnnotationProvider myPureAnnotationProvider;
    protected PredictiveImpureValidator(CodeAnnotationsCache annotationsCache, IModuleReferenceResolveContext resolveContext);
    private static PredictiveImpureValidator();
    public bool IsPure(ITreeNode node);
    public void ImpureWarn(InterpretationUnit Unit, ITreeNode node, ImpureWarnInfo info);
    public bool ValidatePureness(IDeclaredElement element, ITreeNode lbl);
    public Pureness ValidatePureness(IDeclaredElement element);
    protected abstract virtual Pureness ValidatePurenessImpl(IDeclaredElement element);
    public bool IsWithPure(IWithExpression expression, IConstructor& copyConstructor);
    public bool ValidatePureness(Conversion conversion);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.PredictiveStackFrame : object {
    public IControlFlowWalker Walker;
    public IPredictiveEvaluationContainer Container;
    public IControlFlowGraph Graph;
    public ITreeNode Expression;
    public int CurrentCall;
    public IPredictiveEvaluationContainer TempContainer;
    public TypeMemberInstance TypeMemberInstance;
    public PredictiveStackFrame Previous;
    [CompilerGeneratedAttribute]
private VariablesFork <Fork>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DataTip>k__BackingField;
    public VariablesFork Fork { get; public set; }
    public object DataTip { get; public set; }
    public PredictiveStackFrame(PredictiveStackFrame previous, IControlFlowWalker walker, VariablesFork fork, IPredictiveEvaluationContainer container, IControlFlowGraph graph, ITreeNode expression, int currentCall, IPredictiveEvaluationContainer tempContainer, TypeMemberInstance typeMemberInstance);
    [CompilerGeneratedAttribute]
public VariablesFork get_Fork();
    [CompilerGeneratedAttribute]
public void set_Fork(VariablesFork value);
    [CompilerGeneratedAttribute]
public object get_DataTip();
    [CompilerGeneratedAttribute]
public void set_DataTip(object value);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.PredictiveStackFrames : object {
    public PredictiveStackFrame CurrentTop;
    public bool Any();
    public PredictiveStackFrame Peek();
    public PredictiveStackFrame Push(IControlFlowWalker walker, TypeMemberInstance typeMemberInstance, VariablesFork fork, IPredictiveEvaluationContainer container, IControlFlowGraph graph, ITreeNode expression, int currentCall, IPredictiveEvaluationContainer tempContainer);
    public PredictiveStackFrame Pop();
    public bool CountMoreThan(int count);
    public void Restore(PredictiveStackFrame currentFrame);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.PredictiveUtils : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IControlFlowElement FindByNode(IControlFlowElement element, ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IControlFlowElement FindNearestNode(IControlFlowElement element, ITreeNode node);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IControlFlowElement FirstChild(IControlFlowElement element);
    [ExtensionAttribute]
public static bool TrySelectExit(IControlFlowElement element, EvaluationAccumulator accumulator, IControlFlowElement& exit);
    [ExtensionAttribute]
public static bool TrySingleExit(IControlFlowElement element, IControlFlowElement& exit);
    [ExtensionAttribute]
[ObsoleteAttribute("Use State.SetSingleExit()")]
public static IControlFlowElement SingleExit(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsTuple(IType type, IModuleReferenceResolveContext context);
    [ExtensionAttribute]
public static IType Type(IExpression expression, IModuleReferenceResolveContext context);
    [ExtensionAttribute]
public static IType Type(TypeMemberInstance expression, IModuleReferenceResolveContext context);
    [ExtensionAttribute]
public static Task StopWithCompletedTask(InterpretationUnit unit, string message);
    [ContractAnnotationAttribute("null => false")]
public static bool IsLoopStatement(ITreeNode statement);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITreeNode LoopBody(ITreeNode statement);
    public static ILoopStatement GetLoopStatement(ITreeNode node);
    [ExtensionAttribute]
public static bool IsTuple(ITypeElement type);
    [ExtensionAttribute]
public static IIfStatement IfStatement(ITreeNode node);
    [ExtensionAttribute]
public static ICSharpExpression SkipParenthesisDown(ICSharpExpression expr);
    [ExtensionAttribute]
public static IExpression SkipParenthesisDown(IExpression expr);
    [ExtensionAttribute]
public static ITreeNode SkipParenthesisUp(ITreeNode node);
    public static bool ShouldHighlightConditionalReferenceExpression(IReferenceExpression expression);
    [ExtensionAttribute]
public static T FindParentOf(ITreeNode node);
    public static bool IsLinqMethod();
    [NotNullAttribute]
[ItemNotNullAttribute]
public static OneToSetMap`2<IDeclaredElement, ITreeNode> CollectLocalContextClosures(ICSharpDeclaration closureDeclaration);
    [ExtensionAttribute]
public static bool IsPropertyWithBackingField(IProperty property, IField& backingField, IModuleReferenceResolveContext resolveContext);
    public static OverridableMemberInstance FindInheritor(IType type, IPsiModule module, OverridableMemberInstance baseInstance);
    public static IOverridableMember FindInheritor(IType type, IPsiModule module, IOverridableMember baseMember);
    [ExtensionAttribute]
public static IType SpecializedType(IExpression expression, InterpretationUnit Unit);
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.PredictiveUtils/<InitThis>d__26")]
public static Task InitThis(ITreeNode declaration, DebuggerState2 state, IExpressionEvaluator evaluator);
    [ExtensionAttribute]
public static Task`1<R> Continue(Task`1<T> task, Func`2<T, R> continuation, InterpretationUnit unit);
    [ExtensionAttribute]
public static Task`1<R> ContinueU(Task`1<T> task, Func`2<T, Task`1<R>> continuation, InterpretationUnit unit);
    [ExtensionAttribute]
public static Task ContinueU(Task`1<T> task, Func`2<T, Task> continuation, InterpretationUnit unit);
    [ExtensionAttribute]
public static Task Continue(Task`1<T> task, Action`1<T> continuation, InterpretationUnit unit);
    [ExtensionAttribute]
public static Task`1<T> Continue(Task task, Func`1<T> continuation, InterpretationUnit unit);
    [ExtensionAttribute]
public static Task ContinueU(Task task, Func`1<Task> continuation, InterpretationUnit unit);
    public static bool IsLoopBegins(IControlFlowElement element);
    private static bool DoWhileBegins(IControlFlowElement element);
    public static void CopyOrMove(SavedEdge source, SavedEdge destination, TypeClassification destinationClassification);
    public static ICSharpExpression CheckedContext(IOperator declaredElement, ICSharpExpression operatorExpression, ITreeNode lbl);
    public static ITypeUsage CreateTypeUsage(IType type, CSharpElementFactory factory);
    public static ITypeUsage CreateTypeUsage(IType type, string typeName, CSharpElementFactory factory);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Feature.Services.CSharp.PredictiveDebugger.StepParameter : Enum {
    public int value__;
    public static StepParameter None;
    public static StepParameter IgnoreBranching;
    public static StepParameter IgnoreLoops;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Projection.ProjectionContext : object {
    [CanBeNullAttribute]
private Dictionary`2<IType, Type> myTypeCache;
    [CanBeNullAttribute]
private Dictionary`2<IParameter, ParameterExpression> myParameters;
    [CanBeNullAttribute]
private Dictionary`2<ITypeParameter, Type> mySubstitution;
    [CanBeNullAttribute]
private ProjectionContext myParent;
    private ProjectionContext(ProjectionContext parent, Dictionary`2<ITypeParameter, Type> substitution);
    [CanBeNullAttribute]
[PureAttribute]
public Type FindType(IType type, bool allowOpenTypes);
    [CanBeNullAttribute]
[PureAttribute]
private Type FindTypeImpl(IType type, bool allowOpenTypes);
    [CanBeNullAttribute]
[PureAttribute]
private Type FindGenericSubstitution(Type resultType, bool allowOpenTypes, IDeclaredType declaredType, HybridCollection`1<ITypeParameter> allTypeParameters, Type[] genericArguments);
    [CanBeNullAttribute]
[PureAttribute]
private Type FindTypeElement(ITypeElement typeElement);
    [CanBeNullAttribute]
[PureAttribute]
public PropertyInfo FindPropertyInfo(IProperty property, ISubstitution substitution);
    [CanBeNullAttribute]
[PureAttribute]
public PropertyInfo FindPropertyInfo(IAnonymousTypeProperty property, ISubstitution substitution);
    [CanBeNullAttribute]
[PureAttribute]
public FieldInfo FindFieldInfo(IField field, ISubstitution substitution);
    [CanBeNullAttribute]
[PureAttribute]
public MethodInfo FindMethodInfo(IFunction function, ISubstitution substitution);
    [CanBeNullAttribute]
[PureAttribute]
private MethodInfo FindGenericMethodInfo(IMethod method, ISubstitution substitution, Type declaringType);
    [CanBeNullAttribute]
[PureAttribute]
public ConstructorInfo FindConstructorInfo(IConstructor ctor, ISubstitution substitution);
    private static BindingFlags GetBindingAttributes(bool isStatic);
    [CanBeNullAttribute]
[PureAttribute]
public ParameterExpression FindParameter(IParameter parameter);
    public void AddParameter(IParameter parameter, ParameterExpression parameterExpression);
    private void ApplyTo(ProjectionContext parentContext);
    [CanBeNullAttribute]
[PureAttribute]
private static Type GetFakeAnonymousType(int count);
    [PureAttribute]
public static bool IsFakeAnonymousType(Type type);
    [CompilerGeneratedAttribute]
internal static bool <FindTypeElement>g__IsFrameworkAssembly|9_0(<>c__DisplayClass9_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Projection.ProjectionInfo : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <PsiExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <LambdaExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ExpressionType>k__BackingField;
    [NotNullAttribute]
private ITreeNodePointer`1<ICSharpExpression> myExpressionPointer;
    [NotNullAttribute]
public ICSharpExpression PsiExpression { get; }
    [NotNullAttribute]
public LambdaExpression LambdaExpression { get; }
    [NotNullAttribute]
public Type ExpressionType { get; }
    private ProjectionInfo(ICSharpExpression psiExpression, LambdaExpression lambdaExpression, Type expressionType);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_PsiExpression();
    [CompilerGeneratedAttribute]
public LambdaExpression get_LambdaExpression();
    [CompilerGeneratedAttribute]
public Type get_ExpressionType();
    [CanBeNullAttribute]
public ICSharpExpression RestoreExpression();
    [CanBeNullAttribute]
public static ProjectionInfo TryBuild(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Projection.ProjectionVisitor : TreeNodeVisitor`2<ProjectionContext, Expression> {
    private static Dictionary`2<TokenNodeType, ExpressionType> BinaryExpressionTypesMap;
    private static Dictionary`2<TokenNodeType, ExpressionType> UnaryExpressionTypesMap;
    private static ProjectionVisitor();
    public virtual Expression VisitNode(ITreeNode node, ProjectionContext context);
    [CanBeNullAttribute]
private Expression Accept(ICSharpTreeNode expression, ProjectionContext context);
    [CanBeNullAttribute]
private static Expression ConvertIfNeeded(Expression expression, Type targetType);
    [CanBeNullAttribute]
private static Expression VisitConstantValue(ICSharpExpression expression, ProjectionContext context);
    public virtual Expression VisitAssignmentExpression(IAssignmentExpression assignmentExpression, ProjectionContext context);
    public virtual Expression VisitPostfixOperatorExpression(IPostfixOperatorExpression postfixExpression, ProjectionContext context);
    public virtual Expression VisitPrefixOperatorExpression(IPrefixOperatorExpression prefixExpression, ProjectionContext context);
    public virtual Expression VisitBaseExpression(IBaseExpression baseExpressionParam, ProjectionContext context);
    public virtual Expression VisitThisExpression(IThisExpression thisExpressionParam, ProjectionContext context);
    public virtual Expression VisitReferenceExpression(IReferenceExpression referenceExpression, ProjectionContext context);
    [CanBeNullAttribute]
private Expression VisitTypeMemberReferenceExpression(IReferenceExpression referenceExpression, ProjectionContext context, ResolveResultWithInfo resolveResult);
    public virtual Expression VisitInvocationExpression(IInvocationExpression invocationExpression, ProjectionContext context);
    public virtual Expression VisitElementAccessExpression(IElementAccessExpression elementAccessExpression, ProjectionContext context);
    [CanBeNullAttribute]
private Expression VisitArrayElementAccessExpression(IElementAccessExpression elementAccessExpression, ProjectionContext context);
    [CanBeNullAttribute]
private Expression VisitIndexerCallElementAccessExpression(IElementAccessExpression elementAccessExpression, ResolveResultWithInfo resolveResult, ProjectionContext context);
    public virtual Expression VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpression, ProjectionContext context);
    public virtual Expression VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreation, ProjectionContext context);
    [CanBeNullAttribute]
private static Expression VisitAnonymousTypeCreation(IAnonymousType anonymousType, ProjectionContext context, List`1<Expression> arguments);
    [CanBeNullAttribute]
private IList`1<MemberBinding> VisitObjectInitializer(IObjectInitializer objectInitializer, ProjectionContext context);
    [CanBeNullAttribute]
private MemberBinding VisitObjectInitializerPropertyBinding(IInitializedMemberInitializer propertyInitializer, IProperty property, ISubstitution substitution, ProjectionContext context);
    [CanBeNullAttribute]
private MemberBinding VisitObjectInitializerFieldBinding(IInitializedMemberInitializer fieldInitializer, IField field, ISubstitution substitution, ProjectionContext context);
    [CanBeNullAttribute]
private IList`1<ElementInit> VisitCollectionInitializer(ICollectionInitializer collectionInitializer, ProjectionContext context);
    [CanBeNullAttribute]
private IList`1<Expression> VisitInvocationArguments(ICSharpInvocationInfo invocationInfo, IParametersOwner parametersOwner, ISubstitution substitution, MethodBase methodInfo, ProjectionContext context, Func`2<ICSharpArgumentInfo, ICSharpExpression> getArgumentValue, Expression firstParameter, bool skipFirstArgument);
    public virtual Expression VisitConditionalTernaryExpression(IConditionalTernaryExpression conditionalExpression, ProjectionContext context);
    public virtual Expression VisitBinaryExpression(IBinaryExpression binaryExpression, ProjectionContext context);
    [CanBeNullAttribute]
private static MethodInfo GetStringConcatOperatorOverload(Type parameterType);
    public virtual Expression VisitUnaryOperatorExpression(IUnaryOperatorExpression unaryExpression, ProjectionContext context);
    public virtual Expression VisitCSharpArgument(ICSharpArgument argument, ProjectionContext context);
    public virtual Expression VisitAwaitExpression(IAwaitExpression awaitExpression, ProjectionContext context);
    public virtual Expression VisitCastExpression(ICastExpression castExpression, ProjectionContext context);
    public virtual Expression VisitAsExpression(IAsExpression asExpression, ProjectionContext context);
    public virtual Expression VisitIsExpression(IIsExpression isExpression, ProjectionContext context);
    public virtual Expression VisitTypeofExpression(ITypeofExpression typeofExpression, ProjectionContext context);
    public virtual Expression VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpression, ProjectionContext context);
    public virtual Expression VisitCheckedExpression(ICheckedExpression checkedExpression, ProjectionContext context);
    public virtual Expression VisitUncheckedExpression(IUncheckedExpression uncheckedExpression, ProjectionContext context);
    public virtual Expression VisitLambdaExpression(ILambdaExpression lambdaExpression, ProjectionContext context);
    public virtual Expression VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpression, ProjectionContext context);
    [CanBeNullAttribute]
private Expression VisitInitializerArrayCreationExpression(IArrayCreationExpression arrayCreationExpression, Int32[] dimensions, Type elementType, ProjectionContext context);
    public virtual Expression VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpression, ProjectionContext context);
    [CanBeNullAttribute]
private static string BuildFormatString(IInterpolatedStringExpression interpolatedString);
    public virtual Expression VisitQueryExpression(IQueryExpression queryExpression, ProjectionContext context);
    public virtual Expression VisitQueryFirstFrom(IQueryFirstFrom queryFirstFrom, ProjectionContext context);
    [CanBeNullAttribute]
private Expression VisitQueryClause(Expression source, ProjectionContext context, IQueryReference queryReference, IQueryParameterPlatform[] parameterPlatforms);
    public virtual Expression VisitQueryParameterPlatform(IQueryParameterPlatform parameterPlatform, ProjectionContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Projection.ValueProjection : object {
    [NotNullAttribute]
private ITreeNode myContext;
    [NotNullAttribute]
private IPsiModule myPsiModule;
    [NotNullAttribute]
private CSharpElementFactory myFactory;
    [NotNullAttribute]
private Dictionary`2<Type, Func`2<object, ICSharpExpression>> myPresenters;
    [CanBeNullAttribute]
private string myExceptionText;
    private static int ArrayLimit;
    [CanBeNullAttribute]
public string ExceptionText { get; }
    public ValueProjection(ITreeNode context);
    public string get_ExceptionText();
    private void RegisterUntyped(Func`2<object, ICSharpExpression> presenter);
    private void RegisterTyped(Func`2<T, ICSharpExpression> presenter);
    private static bool IsPureEnumerable(IEnumerable enumerable);
    [NotNullAttribute]
private static IList`1<Type> GetImplementationsOfGenericType(Type type, Type genericInterface);
    [NotNullAttribute]
public ICSharpExpression Present(object value);
    [NotNullAttribute]
private ICSharpExpression PresentEnumValue(Enum enumValue);
    [NotNullAttribute]
private ICSharpExpression PresentBoolean(bool value);
    [NotNullAttribute]
private ICSharpExpression PresentConstant(object value);
    [NotNullAttribute]
private ICSharpExpression PresentString(string value);
    [NotNullAttribute]
private ICSharpExpression PresentStringBuilder(StringBuilder value);
    [NotNullAttribute]
private ICSharpExpression PresentVersion(Version value);
    [NotNullAttribute]
private ICSharpExpression PresentDbNull(DBNull value);
    [NotNullAttribute]
private ICSharpExpression PresentType(Type value);
    [NotNullAttribute]
private ICSharpExpression PresentAnonymousValue(IAnonymousValue value);
    [NotNullAttribute]
private ICSharpExpression PresentTimeSpan(TimeSpan value);
    [NotNullAttribute]
private ICSharpExpression PresentDateTime(DateTime value);
    [NotNullAttribute]
private ICSharpExpression PresentDateTimeOffset(DateTimeOffset value);
    [NotNullAttribute]
private ICSharpExpression PresentArray(Array array);
    private void PresentDimension(Array array, Int32[] indices, int dimension, IArrayInitializer initializer, IType elementType);
    [NotNullAttribute]
private ICSharpExpression PresentEnumerable(IEnumerable enumerable);
    [NotNullAttribute]
private ICreationExpression PresentCollection(IEnumerable enumerable);
    [NotNullAttribute]
private ICSharpExpression PresentTask(Task task);
    [NotNullAttribute]
private ICollectionElementInitializer PresentCollectionElementInit(object item);
    private void PresentArrayOverflow(IArrayCreationExpression arrayCreation, string message);
    [NotNullAttribute]
private ICSharpExpression PresentXDocument(XDocument document);
    [NotNullAttribute]
private ICSharpExpression PresentXElement(XElement element);
    [NotNullAttribute]
private XmlTreeVisitorCodeCreator GenerateXCodeFromString(string stringData);
    [NotNullAttribute]
private ICSharpExpression PresentationFallback(object value, Type resultType);
    [NotNullAttribute]
private ICSharpExpression ConvertIfNeeded(ICSharpExpression expression, IType targetType, bool disableContextualTyping);
    [NotNullAttribute]
private IType ProjectTypeBack(Type type);
    [PureAttribute]
[ContractAnnotationAttribute("null => true")]
private static bool IsRootType(Type baseType);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.PropertiesExtender.ConfigureAwaitAnalysisMode : Enum {
    public int value__;
    public static ConfigureAwaitAnalysisMode Disabled;
    public static ConfigureAwaitAnalysisMode Library;
    public static ConfigureAwaitAnalysisMode UI;
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.PropertiesExtender.ConfigureAwaitAnalysisModeSetting : object {
    [NotNullAttribute]
public static Expression`1<Func`2<DaemonProjectSettings, ConfigureAwaitAnalysisMode>> ConfigureAwaitAnalysisModeKey;
    private static ConfigureAwaitAnalysisModeSetting();
    [PureAttribute]
public static ConfigureAwaitAnalysisMode Get(IContextBoundSettingsStore settingsStore);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.PropertiesExtender.CSharpLanguageProperty : object {
    [ExtensionAttribute]
public static ReSharperSettingsCSharpLanguageLevel GetCSharpLanguageProperty(IProject project);
    [ExtensionAttribute]
public static void SetCSharpLanguageProperty(IProject project, ReSharperSettingsCSharpLanguageLevel value);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PropertiesExtender.CSharpProjectPropertiesExtenderProvider : ProjectPropertiesExtenderProviderBase {
    public CSharpProjectPropertiesExtenderProvider(Lifetime lifetime, IShellLocks locks, ISettingsStore settingsStore);
    protected virtual bool IsSuitableProject(IProject project);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.PropertiesExtender.CSharpProjectPropertiesExtenderProvider/<GetProjectPropertyDescriptors>d__2")]
protected virtual IEnumerable`1<PropertyDescriptor> GetProjectPropertyDescriptors(IProject project);
}
[EditorConfigKeyAttribute("")]
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeInspectionSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "DaemonProjectSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.PropertiesExtender.DaemonProjectSettings : object {
    [EditorConfigEntryAliasAttribute("configure_await_analysis_mode", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ConfigureAwaitAnalysisModeSettingDescription")]
public ConfigureAwaitAnalysisMode ConfigureAwaitAnalysisMode;
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Psi.CSharpTypeNameService : TypeNameService {
    private static Char[] TYPE_DELIMITER_LEFT_CHARS;
    private static Char[] TYPE_DELIMITER_RIGHT_CHARS;
    private static CSharpTypeNameService();
    public virtual Range GetRangeOfTypeNamePartAtPosition(string text, int position);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Psi.CSharpUnresolvedTypesChooser : object {
    private ITreeNode myContext;
    public CSharpUnresolvedTypesChooser(ITreeNode context);
    public sealed virtual void AddUnresolvedTypes(string typeText, Dictionary`2<string, UnresolvedDeclaredType> result);
    public sealed virtual IType Apply(string typeText, Dictionary`2<string, UnresolvedDeclaredType> boundTypes, bool allowNotResolved);
    private static void QualifyReference(IDictionary`2<string, UnresolvedDeclaredType> boundTypes, IReferenceName refNameNode);
    internal void AddUnresolvedType(IReferenceName referenceName, Dictionary`2<string, UnresolvedDeclaredType> result);
    private static void QualifyNestedTypesFromReferenceName(IReferenceName referenceName, IDictionary`2<string, UnresolvedDeclaredType> dict);
    private void AddNestedTypesFromReferenceName(IReferenceName referenceName, Dictionary`2<string, UnresolvedDeclaredType> result);
    [MustDisposeResourceAttribute]
private IDisposable CreateTypeUsageNodeCookie();
    [CanBeNullAttribute]
private ITypeUsage CreateTypeUsageNode(string typeName);
    [CompilerGeneratedAttribute]
private IDisposable <CreateTypeUsageNodeCookie>b__8_0();
    [CompilerGeneratedAttribute]
private IDisposable <CreateTypeUsageNodeCookie>b__8_1();
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.QueryToExtensionMethodsUtil : object {
    public static ICSharpExpression GenerateFunctionalForm(IQueryExpression queryExpression, ITreeNode context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.QueryToExtensionVisitor : object {
    private CSharpElementFactory myFactory;
    private IPsiServices myPsiServices;
    private string myNullVar;
    private string myUndefinedVar;
    private QueryVariablesHolder myVariables;
    private ICSharpExpression myCurrentBase;
    internal ICSharpExpression Expression { get; }
    internal QueryToExtensionVisitor(IPsiModule module, string transparentVariableName, string nullVar, string undefinedVariableName);
    internal ICSharpExpression get_Expression();
    public sealed virtual void VisitFirstFrom(IQueryFirstFrom clause);
    public sealed virtual void VisitSelect(IQuerySelectClause clause);
    public sealed virtual void VisitWhere(IQueryWhereClause clause);
    public sealed virtual void VisitContinuation(IQueryContinuation continuation);
    public sealed virtual void VisitFrom(IQueryFromClause clause);
    public sealed virtual void VisitFromSelect(IQueryFromClause clause);
    public sealed virtual void VisitSelectEmpty(IQuerySelectClause clause);
    public sealed virtual void VisitLet(IQueryLetClause clause);
    public sealed virtual void VisitOrderBy(IQueryOrderByClause clause);
    public sealed virtual void VisitJoinSelect(IQueryJoinClause clause);
    public sealed virtual void VisitJoinIntoSelect(IQueryJoinClause clause);
    public sealed virtual void VisitJoin(IQueryJoinClause clause);
    public sealed virtual void VisitJoinInto(IQueryJoinClause clause);
    public sealed virtual void VisitGroupByShort(IQueryGroupClause clause);
    public sealed virtual void VisitGroupBy(IQueryGroupClause clause);
    [CanBeNullAttribute]
private static ICSharpExpression GetExpression(IQueryParameterPlatform platform);
    private string GetDeclaredName(IDeclaration declaration);
    [CanBeNullAttribute]
private ICSharpExpression ApplyCast(IQueryCastReferenceProvider castProvider);
    private static object GetMethodReference(IReference reference);
    [NotNullAttribute]
private object TranslateLambdaBody(ICSharpExpression lambdaBody);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.QueryTools.IQueryVisitor {
    public abstract virtual void VisitContinuation(IQueryContinuation continuation);
    public abstract virtual void VisitFirstFrom(IQueryFirstFrom clause);
    public abstract virtual void VisitFrom(IQueryFromClause clause);
    public abstract virtual void VisitFromSelect(IQueryFromClause clause);
    public abstract virtual void VisitSelect(IQuerySelectClause clause);
    public abstract virtual void VisitSelectEmpty(IQuerySelectClause clause);
    public abstract virtual void VisitWhere(IQueryWhereClause clause);
    public abstract virtual void VisitLet(IQueryLetClause clause);
    public abstract virtual void VisitOrderBy(IQueryOrderByClause clause);
    public abstract virtual void VisitJoinSelect(IQueryJoinClause clause);
    public abstract virtual void VisitJoin(IQueryJoinClause clause);
    public abstract virtual void VisitJoinInto(IQueryJoinClause clause);
    public abstract virtual void VisitJoinIntoSelect(IQueryJoinClause clause);
    public abstract virtual void VisitGroupByShort(IQueryGroupClause clause);
    public abstract virtual void VisitGroupBy(IQueryGroupClause clause);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.QueryTools.QueryIterator : object {
    private IQueryExpression myQueryExpression;
    private IQueryVisitor myQueryVisitor;
    private QueryIterator(IQueryExpression queryExpression, IQueryVisitor queryVisitor);
    public static void Do(IQueryExpression queryExpression, IQueryVisitor queryVisitor);
    private void Iterate();
    private void IterateClauses(IEnumerable`1<IQueryClause> clauses);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.QueryVariablesHolder : object {
    private IDictionary`2<string, Pair`2<IQueryRangeVariable, string>> myVariables;
    private string myTransparentVariableName;
    private string myUndefinedVariableName;
    private string myLastIntroducedVariable;
    public string LastIntroducedVariable { get; }
    public QueryVariablesHolder(string transparentVariableName, string undefinedVariableName);
    public string get_LastIntroducedVariable();
    public void AddVariable(IQueryRangeVariableDeclaration variableDeclaration);
    public void AddTransparentVariable();
    public void Clear();
    public sealed virtual IEnumerator`1<Pair`2<IQueryRangeVariable, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private Pair`2<IQueryRangeVariable, string> <AddTransparentVariable>b__8_1(KeyValuePair`2<string, Pair`2<IQueryRangeVariable, string>> variable);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpHtmlAttributesPresenter : HtmlAttributesPresenterBase {
    private IHtmlTypePresenter myTypePresenter;
    public CSharpHtmlAttributesPresenter(PsiLanguageType language, IHtmlTypePresenter typePresenter, IHtmlEnumPresenter enumPresenter);
    protected virtual IList`1<IAttributeInstance> GetAttributes(IAttributesSet attributesOwner);
    protected virtual void PresentTarget(RichText header, string target);
    protected virtual string GetNew();
    protected virtual string GetTypeOf();
    protected virtual string GetNull();
    protected virtual string GetAttributePropertyAssignChar();
    protected virtual string GetAttributeOpenChar();
    protected virtual string GetAttributeCloseChar();
    protected virtual string GetNewLine();
    protected virtual IHtmlTypePresenter GetTypePresenter();
    protected virtual string GetArrayBrackets();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpHtmlEnumMemberPresenter : HtmlEnumPresenterBase {
    public CSharpHtmlEnumMemberPresenter(PsiLanguageType language);
    protected virtual string TryGetXmlDocId(ITreeNode child);
    protected virtual ITreeNode ExtractTreeNode(IField element);
    protected virtual RichText PresentEnum(ConstantValue constantValue, bool isFieldDeclaration, TypePresentationStyle typePresentationStyle);
    protected virtual TextStyle SelectTextStyle(ITreeNode node, DeclaredElementPresenterTextStyles styles);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpHtmlTypePresenter : object {
    private PsiLanguageType myLanguage;
    public CSharpHtmlTypePresenter(PsiLanguageType language);
    public sealed virtual void PresentName(RichText builder, IType type, TypePresentationStyle typePresentationStyle, ElementLinkCollector linkCollector);
    private RichText CreateTypeLink(ITypeElement element, DeclaredElementPresenterTextStyles styles, ElementLinkCollector linkCollector);
    private void BuildPresentableName(IType type, RichText builder, TypePresentationStyle typePresentationStyle, ElementLinkCollector linkCollector);
    private void BuildPointerTypeString(IPointerType pointerType, RichText builder, TypePresentationStyle typePresentationStyle);
    private void BuildArrayTypeString(IArrayType arrayType, RichText builder, TypePresentationStyle typePresentationStyle);
    private void BuildDeclaredTypePresentableName(IDeclaredType declaredType, RichText builder, TypePresentationStyle typePresentationStyle, ElementLinkCollector linkCollector);
    [NotNullAttribute]
private static RichText ShortName(RichText name);
    [NotNullAttribute]
private static RichText CreateKeywordRichText(DeclaredElementPresenterTextStyles styles, string keyword);
    private void BuildTypeArgumentList(ITypeElement element, ISubstitution substitution, RichText builder, TypePresentationStyle typePresentationStyle);
    private static void AppendNullableAnnotation(IType annotatedType, RichText builder);
}
[QuickDocProviderAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpQuickQueryRangeVariableProvider : object {
    private ISolution mySolution;
    private DocumentManager myDocumentManager;
    private QuickDocTypeMemberProvider myQuickDocTypeMemberProvider;
    public CSharpQuickQueryRangeVariableProvider(ISolution solution, DocumentManager documentManager, QuickDocTypeMemberProvider quickDocTypeMemberProvider);
    public sealed virtual bool CanNavigate(IDataContext context);
    public sealed virtual void Resolve(IDataContext context, Action`2<IQuickDocPresenter, PsiLanguageType> resolved);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpXmlDocBaseElementsProvider : ClrXmlDocBaseElementsProviderBase {
    protected virtual bool ExcludeSuperType(IDeclaredType superType, ITypeElement currentType);
    protected virtual IConstructor GetBaseConstructor(IConstructor constructor);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpXmlDocHeaderPresenter : CommonXmlDocHeaderPresenter {
    private IHtmlAttributesPresenter myAttributesPresenter;
    private PsiLanguageType myLanguage;
    private IHtmlTypePresenter myTypePresenter;
    private IHtmlEnumPresenter myEnumPresenter;
    public CSharpXmlDocHeaderPresenter(PsiLanguageType language, IHtmlAttributesPresenter attributesPresenter, IHtmlTypePresenter typePresenter, IHtmlEnumPresenter enumPresenter);
    public virtual void Present(RichText header, DeclaredElementInstance declaredElementInstance, IPsiModule module, CrefManager crefManager, DeclaredElementPresenterTextStyles styles, ElementLinkCollector linkCollector, ITreeNode context);
    private void AppendSubstitution(RichText header, HTMLBuilder htmlBuilder, DeclaredElementInstance declaredElementInstance, DeclaredElementPresenterTextStyles styles, ElementLinkCollector linkCollector);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpXmlDocHeaderPresenter/<CreateSubstitutionDescriptions>d__7")]
[NotNullAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<RichText> CreateSubstitutionDescriptions(DeclaredElementInstance declaredElementInstance, DeclaredElementPresenterTextStyles styles, ElementLinkCollector linkCollector);
    private static IList`1<ITypeParameter> GetOrderedTypeParameters(DeclaredElementInstance declaredElementInstance);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpXmlDocHeaderPresenter/<FindAllRelevantTypeParametersOwners>d__9")]
private static IEnumerable`1<ITypeParametersOwner> FindAllRelevantTypeParametersOwners(IDeclaredElement declaredElement);
    private void AppendSignature(RichText header, HTMLBuilder htmlBuilder, IDeclaredElement declaredElement, DeclaredElementPresenterMarking marking, RichText presentation, int startOffset, TypePresentationStyle typePresentationStyle);
    private static bool IsComplexEnumValue(IField field);
    private static void ProcessConstantValue(RichText header, IDeclaredElement declaredElement, RichText valueText, TypePresentationStyle typePresentationStyle, Nullable`1<TextStyle> textStyle);
    private void AppendContainer(RichText header, HTMLBuilder htmlBuilder, IDeclaredElement declaredElement, RichText presentation, DeclaredElementPresenterMarking marking, DeclaredElementPresenterTextStyles styles);
    [NotNullAttribute]
private static List`1<IDeclaredType> GetFilteredSuperTypes(ITypeElement typeElement, IPsiModule psiModule);
    private void FormatBaseTypes(RichText header, HTMLBuilder htmlBuilder, ITypeElement typeElement, IPsiModule module, TypePresentationStyle typePresentationStyle);
    private static void FormatProperty(RichText header, IProperty property, DeclaredElementPresenterTextStyles textStyles);
    private static void FormatEvent(RichText header, IEvent event, DeclaredElementPresenterTextStyles textStyles);
    private void FormatSymbolAlias(RichText header, ISymbolAlias symbolAlias, TypePresentationStyle typePresentationStyle);
    private void PresentType(RichText builder, IType type, TypePresentationStyle typePresentationStyle);
    [CompilerGeneratedAttribute]
internal static bool <IsComplexEnumValue>g__ContainsComplexExpression|11_0(ITreeNode node);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.CSharpXmlDocLocator : object {
    public sealed virtual IDocCommentBlock FindCommentNode(IFile file, DocumentRange range);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.QuickDoc.QuickDocQueryRangeVariablePresenter : object {
    [CompilerGeneratedAttribute]
private QuickDocTypeMemberProvider <quickDocTypeMemberProvider>P;
    [NotNullAttribute]
private DeclaredElementEnvoy`1<IQueryRangeVariable> myEnvoy;
    public QuickDocQueryRangeVariablePresenter(QuickDocTypeMemberProvider quickDocTypeMemberProvider, IQueryRangeVariable element);
    public sealed virtual IQuickDocPresenter Resolve(string id);
    public sealed virtual QuickDocTitleAndText GetHtml(PsiLanguageType presentationLanguage);
    public sealed virtual string GetId();
    public sealed virtual void OpenInEditor(string navigationId);
    public sealed virtual void ReadMore(string navigationId);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableArgument : RearrangeableElementSwap`1<ICSharpArgument> {
    private RearrangeableArgument(ICSharpArgument argument);
    protected virtual IEnumerable`1<ICSharpArgument> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableArrayExpressionInitializer : RearrangeableElementSwap`1<IVariableInitializer> {
    public RearrangeableArrayExpressionInitializer(IVariableInitializer element);
    protected virtual IEnumerable`1<IVariableInitializer> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableAssignmentExpressionOperand : object {
    [NotNullAttribute]
private ICSharpExpression myExpression;
    public string Title { get; }
    public DocumentRange Range { get; }
    public Direction SupportedDirections { get; }
    [NotNullAttribute]
private IAssignmentExpression AssignmentExpression { get; }
    private bool IsDest { get; }
    public RearrangeableAssignmentExpressionOperand(ICSharpExpression expression);
    public sealed virtual string get_Title();
    public sealed virtual DocumentRange get_Range();
    public sealed virtual Direction get_SupportedDirections();
    public sealed virtual bool CanMove(Direction direction);
    public sealed virtual ValueTuple`2<DocumentRange, ITreeRange> Move(Direction direction);
    private IAssignmentExpression get_AssignmentExpression();
    private bool get_IsDest();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableAttributeSection : RearrangeableElementSwap`1<IAttributeSection> {
    private bool myAssemblyLevel;
    private RearrangeableAttributeSection(IAttributeSection section, bool assemblyLevel);
    protected virtual IEnumerable`1<IAttributeSection> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableBaseType : RearrangeableElementSwap`1<ITypeUsage> {
    private RearrangeableBaseType(ITypeUsage typeUsage, string title);
    protected virtual IEnumerable`1<ITypeUsage> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableBinaryExpressionOperand : RearrangeableElementSwap`1<ICSharpExpression> {
    [NotNullAttribute]
private ICSharpExpression myExpression;
    public RearrangeableBinaryExpressionOperand(ICSharpExpression expression);
    protected virtual IEnumerable`1<ICSharpExpression> GetSiblings();
    public virtual bool CanMove(Direction direction);
    protected virtual ICSharpExpression Swap(ICSharpExpression child, ICSharpExpression target);
    [NotNullAttribute]
private static string GetTitle(ICSharpExpression expression);
    [NotNullAttribute]
private IBinaryExpression GetTopmostBinaryExpression(IBinaryExpression binaryExpression);
    [CanBeNullAttribute]
private static IBinaryExpression GetBinaryExpression(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableBinaryExpressionOperand/<GetOperands>d__8")]
[NotNullAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<ICSharpExpression> GetOperands(ICSharpExpression expression);
    [PureAttribute]
private bool IsSameBinaryExpressionType(ITreeNode expression);
    [CanBeNullAttribute]
private IBinaryExpression GetBinaryExpressionParent(IBinaryExpression binaryExpression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableBinaryPatternOperand : RearrangeableElementSwap`1<IPattern> {
    [NotNullAttribute]
private IPattern myPattern;
    public RearrangeableBinaryPatternOperand(IPattern pattern);
    protected virtual IEnumerable`1<IPattern> GetSiblings();
    [NotNullAttribute]
private static string GetTitle(IPattern pattern);
    [NotNullAttribute]
private IBinaryPattern GetTopmostBinaryPattern(IBinaryPattern binaryPattern);
    [CanBeNullAttribute]
private static IBinaryPattern GetBinaryPattern(IPattern pattern);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableBinaryPatternOperand/<GetOperands>d__6")]
[NotNullAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<IPattern> GetOperands(IPattern pattern);
    [PureAttribute]
private bool IsSameBinaryPatternType(IPattern otherPattern);
    [CanBeNullAttribute]
private IBinaryPattern GetBinaryPatternParent(IBinaryPattern binaryPattern);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableBlockLBrace : RearrangeableStatementsOwner {
    [NotNullAttribute]
private IBlock myTarget;
    [CanBeNullAttribute]
private ILogicalItem<IStatementsOwner> myBlockOwner;
    private NestedStatementsOwner myOuterBlock;
    [ItemNotNullAttribute]
[NotNullAttribute]
private IReadOnlyList`1<ILogicalItem<IStatementsOwner>> myInnerItems;
    [ItemNotNullAttribute]
[NotNullAttribute]
private IReadOnlyList`1<ILogicalItem<IStatementsOwner>> myOuterItems;
    public Direction SupportedDirections { get; }
    private RearrangeableBlockLBrace(IReadOnlyList`1<ILogicalItem<IStatementsOwner>> selectedItems, ILogicalItem<IStatementsOwner> blockOwner, IBlock innerBlock, NestedStatementsOwner target, IReadOnlyList`1<ILogicalItem<IStatementsOwner>> innerItems, IReadOnlyList`1<ILogicalItem<IStatementsOwner>> outerItems);
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
    private void AddStatementsRangeToBlockBefore(IStatementsOwner statementsOwner, ILogicalItem<IStatementsOwner> movedItem, ILogicalItem<IStatementsOwner> fallbackMovedItem, ICSharpStatementsRange statementsAcnhor, Action`1<ICSharpStatementsRange> removeRange);
    [CompilerGeneratedAttribute]
private void <MoveUnderPsiTransaction>b__9_2(ICSharpStatementsRange range);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableBlockRBrace : RearrangeableStatementsOwner {
    [NotNullAttribute]
private IBlock myInnerBlock;
    private NestedStatementsOwner myTarget;
    [NotNullAttribute]
private IReadOnlyList`1<ILogicalItem<IStatementsOwner>> myInnerItems;
    [NotNullAttribute]
private IReadOnlyList`1<ILogicalItem<IStatementsOwner>> myOuterItems;
    public Direction SupportedDirections { get; }
    private RearrangeableBlockRBrace(IReadOnlyList`1<ILogicalItem<IStatementsOwner>> selectedItems, IBlock innerBlock, NestedStatementsOwner target, IReadOnlyList`1<ILogicalItem<IStatementsOwner>> innerItems, IReadOnlyList`1<ILogicalItem<IStatementsOwner>> outerItems);
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
    private void AddStatementsRangeToBlockBefore(IBlock block, ILogicalItem<IStatementsOwner> movedItem, ILogicalItem<IStatementsOwner> fallbackMovedItem, ILogicalItem<IStatementsOwner> anchor, Action`1<ICSharpStatementsRange> removeRange);
    [CompilerGeneratedAttribute]
private void <MoveUnderPsiTransaction>b__8_0(ICSharpStatementsRange range);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableCatchClause : RearrangeableElementSwap`1<ICSharpTreeNode> {
    private RearrangeableCatchClause(ICSharpTreeNode element);
    protected virtual IEnumerable`1<ICSharpTreeNode> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableClassDeclarationBrace : RearrangeableDeclarationRangeContainerRBraceBase {
    private RearrangeableClassDeclarationBrace(IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> selectedItems, IClassLikeDeclaration holder, IClassLikeDeclaration target, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> innerItems, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> outerItems);
    protected virtual DocumentRange GetBraceDocumentRange();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableClassDeclarationLBrace : RearrangeableDeclarationRangeContainerLBraceBase {
    private RearrangeableClassDeclarationLBrace(IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> selectedItems, IClassLikeDeclaration holder, IClassLikeDeclaration target, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> innerItems, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> outerItems);
    protected virtual DocumentRange GetLBraceDocumentRange();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableClassItem : RearrangeableCSharpLogicalItemBase`1<IClassLikeDeclaration> {
    [CompilerGeneratedAttribute]
private IDeclarationsRange <DeclarationsRange>k__BackingField;
    private IDeclarationsRange DeclarationsRange { get; }
    public Direction SupportedDirections { get; }
    private RearrangeableClassItem(IReadOnlyList`1<ILogicalItem<IClassLikeDeclaration>> selectedItems, IClassLikeDeclaration holder, IReadOnlyList`1<ILogicalItem<IClassLikeDeclaration>> holderItems);
    [CompilerGeneratedAttribute]
private IDeclarationsRange get_DeclarationsRange();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
    protected IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange movedItem, ILogicalItem<IClassLikeDeclaration> anchor, ILogicalItem<IClassLikeDeclaration> fallbackAnchor, Action`1<IDeclarationsRange> removeRange);
    protected IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange movedItem, ILogicalItem<IClassLikeDeclaration> anchor, ILogicalItem<IClassLikeDeclaration> fallbackAnchor, Action`1<IDeclarationsRange> removeRange);
    [CanBeNullAttribute]
private IClassLikeDeclaration GetNextClassLikeDeclaration();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableCollectionElementInitializer : RearrangeableElementSwap`1<ICollectionElementInitializer> {
    public RearrangeableCollectionElementInitializer(ICollectionElementInitializer element);
    protected virtual IEnumerable`1<ICollectionElementInitializer> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableCollectionExpressionElement : RearrangeableElementSwap`1<ICollectionExpressionElement> {
    public RearrangeableCollectionExpressionElement(ICollectionExpressionElement element);
    protected virtual IEnumerable`1<ICollectionExpressionElement> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableCSharpAttribute : RearrangeableElementSwap`1<IAttribute> {
    private RearrangeableCSharpAttribute(IAttribute element);
    protected virtual IEnumerable`1<IAttribute> GetSiblings();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableCSharpLogicalItemBase`1 : RearrangeableLogicalItemBase`1<THolder> {
    protected RearrangeableCSharpLogicalItemBase`1(IReadOnlyList`1<ILogicalItem<THolder>> selectedItems, THolder holder, IReadOnlyList`1<ILogicalItem<THolder>> holderItems);
    protected void FixLineCountAfter(ITreeNode anchor, int difference, ITreeNode newLineToken);
    protected void FixLineCountBefore(ITreeNode anchor, int difference, ITreeNode newLineToken);
    protected static int CountEmptyLinesAround(ITreeRange range);
    protected static int CountEmptyLinesAround(ITreeRange range, ITreeNode& newLineToken);
    protected static int CountEmptyLinesAfter(ITreeNode from);
    protected static int CountEmptyLinesAfter(ITreeNode from, ITreeNode& newLineToken);
    protected static int CountEmptyLinesBefore(ITreeNode from);
    protected static int CountEmptyLinesBefore(ITreeNode from, ITreeNode& newLineToken);
    private static int CountEmptyLines(IEnumerable`1<ITreeNode> nodes, ITreeNode& newLineToken);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableDeclaration : RearrangeableElementSwap`1<IMultipleDeclarationMember> {
    [NotNullAttribute]
private IMultipleDeclaration myParent;
    private RearrangeableDeclaration(IMultipleDeclarationMember element, IMultipleDeclaration parent, string title);
    protected virtual IEnumerable`1<IMultipleDeclarationMember> GetSiblings();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableDeclarationRangeContainerBraceBase : RearrangeableCSharpLogicalItemBase`1<IDeclarationsRangeContainer> {
    public Direction SupportedDirections { get; }
    protected RearrangeableDeclarationRangeContainerBraceBase(IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> selectedItems, IDeclarationsRangeContainer holder);
    public virtual Direction get_SupportedDirections();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableDeclarationRangeContainerLBraceBase : RearrangeableDeclarationRangeContainerBraceBase {
    [NotNullAttribute]
private IDeclarationsRangeContainer myInnerBlock;
    [NotNullAttribute]
private IDeclarationsRangeContainer myTarget;
    [ItemNotNullAttribute]
[NotNullAttribute]
private IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> myInnerItems;
    [ItemNotNullAttribute]
[NotNullAttribute]
private IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> myOuterItems;
    protected RearrangeableDeclarationRangeContainerLBraceBase(IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> selectedItems, IDeclarationsRangeContainer holder, IDeclarationsRangeContainer target, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> innerItems, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> outerItems);
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
    protected abstract virtual DocumentRange GetLBraceDocumentRange();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableDeclarationRangeContainerRBraceBase : RearrangeableDeclarationRangeContainerBraceBase {
    [NotNullAttribute]
private IDeclarationsRangeContainer myInnerBlock;
    [NotNullAttribute]
private IDeclarationsRangeContainer myTarget;
    [ItemNotNullAttribute]
[NotNullAttribute]
private IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> myInnerItems;
    [ItemNotNullAttribute]
[NotNullAttribute]
private IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> myOuterItems;
    protected RearrangeableDeclarationRangeContainerRBraceBase(IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> selectedItems, IDeclarationsRangeContainer holder, IDeclarationsRangeContainer target, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> innerItems, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> outerItems);
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
    protected abstract virtual DocumentRange GetBraceDocumentRange();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableDocCommentAttribute : object {
    [NotNullAttribute]
private IXmlAttribute myXmlAttribute;
    [NotNullAttribute]
private IRearrangeable myXmlRearrangeableAttribute;
    public string Title { get; }
    public DocumentRange Range { get; }
    public Direction SupportedDirections { get; }
    public RearrangeableDocCommentAttribute(IXmlAttribute xmlAttribute);
    public sealed virtual string get_Title();
    public sealed virtual DocumentRange get_Range();
    public sealed virtual Direction get_SupportedDirections();
    public sealed virtual bool CanMove(Direction direction);
    private sealed virtual override ValueTuple`2<DocumentRange, ITreeRange> JetBrains.ReSharper.Feature.Services.RearrangeCode.IRearrangeable.Move(Direction direction);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableDocCommentTag : object {
    [NotNullAttribute]
private IXmlTag myXmlTag;
    [NotNullAttribute]
private IRearrangeable myXmlRearrangeableTag;
    public string Title { get; }
    public DocumentRange Range { get; }
    public Direction SupportedDirections { get; }
    public RearrangeableDocCommentTag(IXmlTag xmlTag);
    public sealed virtual string get_Title();
    public sealed virtual DocumentRange get_Range();
    public sealed virtual Direction get_SupportedDirections();
    public sealed virtual bool CanMove(Direction direction);
    private sealed virtual override ValueTuple`2<DocumentRange, ITreeRange> JetBrains.ReSharper.Feature.Services.RearrangeCode.IRearrangeable.Move(Direction direction);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableElseIfBranch : RearrangeableElementSwap`1<IIfStatement> {
    public DocumentRange Range { get; }
    private RearrangeableElseIfBranch(IIfStatement element);
    public virtual DocumentRange get_Range();
    protected virtual IIfStatement Swap(IIfStatement child, IIfStatement target);
    [NotNullAttribute]
private static IIfStatement SwapBranch(IIfStatement child, IIfStatement parent);
    protected virtual IEnumerable`1<IIfStatement> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableEmbeddedStatement : RearrangeableCSharpLogicalItemBase`1<ICSharpStatement> {
    [NotNullAttribute]
private ICSharpStatement myEmbeddedStatement;
    public Direction SupportedDirections { get; }
    private RearrangeableEmbeddedStatement(IReadOnlyList`1<ILogicalItem<ICSharpStatement>> logicalItems, ICSharpStatement embeddedStatement, ICSharpStatement parentStatement);
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableEnumItem : RearrangeableCSharpLogicalItemBase`1<IEnumDeclaration> {
    [CompilerGeneratedAttribute]
private DeclarationsRange <DeclarationsRange>k__BackingField;
    private DeclarationsRange DeclarationsRange { get; }
    public Direction SupportedDirections { get; }
    private RearrangeableEnumItem(IReadOnlyList`1<ILogicalItem<IEnumDeclaration>> selectedItems, IEnumDeclaration holder, IReadOnlyList`1<ILogicalItem<IEnumDeclaration>> holderItems);
    [CompilerGeneratedAttribute]
private DeclarationsRange get_DeclarationsRange();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableEventAccessor : RearrangeableElementSwap`1<IAccessorDeclaration> {
    public RearrangeableEventAccessor(IAccessorDeclaration element);
    protected virtual IEnumerable`1<IAccessorDeclaration> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableFunctionPointerTypeParameter : RearrangeableElementSwap`1<IFunctionPointerParameter> {
    private RearrangeableFunctionPointerTypeParameter(IFunctionPointerParameter parameter);
    protected virtual IEnumerable`1<IFunctionPointerParameter> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableIfCondition : RearrangeableElementSwap`1<ICSharpExpression> {
    private RearrangeableIfCondition(ICSharpExpression element);
    protected virtual IEnumerable`1<ICSharpExpression> GetSiblings();
    [NotNullAttribute]
private static IReadOnlyList`1<ICSharpExpression> BuildConditionsList(IIfStatement ifStatement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableInterpolationStringInsert : RearrangeableElementSwap`1<IInterpolatedStringInsert> {
    private RearrangeableInterpolationStringInsert(IInterpolatedStringInsert insert);
    protected virtual IEnumerable`1<IInterpolatedStringInsert> GetSiblings();
    protected virtual IInterpolatedStringInsert Swap(IInterpolatedStringInsert child, IInterpolatedStringInsert target);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableListPatternItemPattern : RearrangeableElementSwap`1<IPattern> {
    private RearrangeableListPatternItemPattern(IPattern pattern);
    protected virtual IEnumerable`1<IPattern> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableLocalConstantDeclaration : RearrangeableElementSwap`1<ILocalConstantDeclaration> {
    private RearrangeableLocalConstantDeclaration(ILocalConstantDeclaration element);
    protected virtual IEnumerable`1<ILocalConstantDeclaration> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableLocalFunctionConstraintsClause : RearrangeableElementSwap`1<ITypeParameterConstraintsClause> {
    private RearrangeableLocalFunctionConstraintsClause(ITypeParameterConstraintsClause element);
    protected virtual IEnumerable`1<ITypeParameterConstraintsClause> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableLocalVariableDeclaration : RearrangeableElementSwap`1<ILocalVariableDeclaration> {
    private RearrangeableLocalVariableDeclaration(ILocalVariableDeclaration element);
    protected virtual IEnumerable`1<ILocalVariableDeclaration> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableMemberInitializer : RearrangeableElementSwap`1<IMemberInitializer> {
    private RearrangeableMemberInitializer(IMemberInitializer element);
    protected virtual IEnumerable`1<IMemberInitializer> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableMethodConstraintsClause : RearrangeableElementSwap`1<ITypeParameterConstraintsClause> {
    private RearrangeableMethodConstraintsClause(ITypeParameterConstraintsClause element);
    protected virtual IEnumerable`1<ITypeParameterConstraintsClause> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableParameter : RearrangeableElement {
    [NotNullAttribute]
private ICSharpRegularParameterDeclaration myParameterDeclaration;
    private int myParameterIndex;
    [NotNullAttribute]
private ICSharpParametersOwnerDeclaration myDeclarationWithParameters;
    private bool myCanMoveLeft;
    private bool myCanMoveRight;
    [NotNullAttribute]
private string myTitle;
    public string Title { get; }
    protected ITreeNode Element { get; }
    public Direction SupportedDirections { get; }
    public RearrangeableParameter(ICSharpRegularParameterDeclaration parameterDeclaration);
    public virtual string get_Title();
    protected virtual ITreeNode get_Element();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    protected virtual ITreeNode MoveUnderPsiTransaction(Direction direction);
    [NotNullAttribute]
private ITreeNode MoveLeft();
    [NotNullAttribute]
private ITreeNode MoveRight();
    private static bool HasThis(ICSharpParameterDeclaration parameterDeclaration);
    private static void SetThis(ICSharpParameterDeclaration parameterDeclaration, bool addThis);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeablePatternGuard : RearrangeableElement {
    [NotNullAttribute]
private IPatternGuardClause myPatternGuard;
    [NotNullAttribute]
private ISwitchCaseLabel myCaseLabel;
    [NotNullAttribute]
private IReadOnlyList`1<ISwitchCaseLabel> myCaseLabels;
    private int myCaseIndex;
    public string Title { get; }
    protected ITreeNode Element { get; }
    public Direction SupportedDirections { get; }
    public RearrangeablePatternGuard(IPatternGuardClause patternGuard, ISwitchCaseLabel caseLabel, ISwitchBlock switchBlock);
    public virtual string get_Title();
    protected virtual ITreeNode get_Element();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    protected virtual ITreeNode MoveUnderPsiTransaction(Direction direction);
    [NotNullAttribute]
[PureAttribute]
private static IReadOnlyList`1<ISwitchCaseLabel> GetAllNonDefaultCaseLabels(ISwitchBlock switchBlock);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeablePositionalPattern : RearrangeableElementSwap`1<IPattern> {
    private RearrangeablePositionalPattern(IPattern pattern);
    protected virtual IEnumerable`1<IPattern> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeablePropertyAccessor : RearrangeableElementSwap`1<IAccessorDeclaration> {
    public RearrangeablePropertyAccessor(IAccessorDeclaration element);
    protected virtual IEnumerable`1<IAccessorDeclaration> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableQueryClause : RearrangeableElementSwap`1<IQueryClause> {
    private RearrangeableQueryClause(IQueryClause clause);
    protected virtual IEnumerable`1<IQueryClause> GetSiblings();
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableStatementsOwner : RearrangeableCSharpLogicalItemBase`1<IStatementsOwner> {
    protected RearrangeableStatementsOwner(IReadOnlyList`1<ILogicalItem<IStatementsOwner>> selectedItems, IStatementsOwner statementsOwner, IReadOnlyList`1<ILogicalItem<IStatementsOwner>> blockItems);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableStatementsOwnerItem : RearrangeableStatementsOwner {
    [NotNullAttribute]
private ICSharpStatementsRange myStatementsRange;
    [CanBeNullAttribute]
private ICSharpStatement myFirstStatement;
    [CanBeNullAttribute]
private ICSharpStatement myLastStatement;
    private CSharpStatementsRange myActualRange;
    public Direction SupportedDirections { get; }
    private RearrangeableStatementsOwnerItem(IReadOnlyList`1<ILogicalItem<IStatementsOwner>> selectedItems, IStatementsOwner statementsOwner, IReadOnlyList`1<ILogicalItem<IStatementsOwner>> blockItems);
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    private void SafeRemoveStatements();
    private void SafeRemoveStatements(int linesIntroduced);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
    [NotNullAttribute]
protected ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange movedItem, ILogicalItem<IStatementsOwner> anchor, ILogicalItem<IStatementsOwner> fallbackAnchor, Action removeRange);
    [NotNullAttribute]
protected ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange movedItem, ILogicalItem<IStatementsOwner> anchor, ILogicalItem<IStatementsOwner> fallbackAnchor, Action removeRange);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableSubpattern : RearrangeableElementSwap`1<ISubpattern> {
    private RearrangeableSubpattern(ISubpattern subpattern);
    protected virtual IEnumerable`1<ISubpattern> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableSwitchCaseLabel : RearrangeableElement {
    [NotNullAttribute]
private ISwitchCaseLabel mySwitchCaseLabel;
    [NotNullAttribute]
private ISwitchSection mySwitchSection;
    private TreeNodeCollection`1<ISwitchCaseLabel> myCaseLabels;
    private TreeNodeCollection`1<ISwitchSection> mySections;
    private int myCaseLabelIndex;
    private int mySectionIndex;
    public string Title { get; }
    protected ITreeNode Element { get; }
    public Direction SupportedDirections { get; }
    private RearrangeableSwitchCaseLabel(ISwitchCaseLabel switchCaseLabel, ISwitchSection switchSection, ISwitchBlock switchBlock);
    public virtual string get_Title();
    protected virtual ITreeNode get_Element();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    protected virtual ITreeNode MoveUnderPsiTransaction(Direction direction);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableSwitchExpressionArm : RearrangeableElement {
    [NotNullAttribute]
private ISwitchExpressionArm mySwitchExpressionArm;
    [NotNullAttribute]
private ISwitchExpression mySwitchExpression;
    private TreeNodeCollection`1<ISwitchExpressionArm> myArms;
    private int myArmIndex;
    public string Title { get; }
    protected ITreeNode Element { get; }
    public Direction SupportedDirections { get; }
    private RearrangeableSwitchExpressionArm(ISwitchExpressionArm switchExpressionArm, ISwitchExpression switchExpression);
    public virtual string get_Title();
    protected virtual ITreeNode get_Element();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    protected virtual ITreeNode MoveUnderPsiTransaction(Direction direction);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableSwitchSection : RearrangeableElement {
    [NotNullAttribute]
private ISwitchSection mySwitchSection;
    [NotNullAttribute]
private ISwitchBlock mySwitchBlock;
    private TreeNodeCollection`1<ISwitchSection> mySections;
    private int mySectionIndex;
    public string Title { get; }
    protected ITreeNode Element { get; }
    public Direction SupportedDirections { get; }
    private RearrangeableSwitchSection(ISwitchSection switchSection, ISwitchBlock switchBlock);
    public virtual string get_Title();
    protected virtual ITreeNode get_Element();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    protected virtual ITreeNode MoveUnderPsiTransaction(Direction direction);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTernaryExpressionResult : RearrangeableElementSwap`1<ICSharpExpression> {
    [NotNullAttribute]
private IConditionalTernaryExpression myParent;
    private RearrangeableTernaryExpressionResult(IConditionalTernaryExpression parent, ICSharpExpression element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTernaryExpressionResult/<GetSiblings>d__2")]
protected virtual IEnumerable`1<ICSharpExpression> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTupleComponent : RearrangeableElementSwap`1<ITupleComponent> {
    private RearrangeableTupleComponent(ITupleComponent component);
    protected virtual IEnumerable`1<ITupleComponent> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTupleTypeComponent : RearrangeableElementSwap`1<ITupleTypeComponent> {
    private RearrangeableTupleTypeComponent(ITupleTypeComponent component);
    protected virtual IEnumerable`1<ITupleTypeComponent> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeArgument : RearrangeableElementSwap`1<ITypeUsage> {
    private RearrangeableTypeArgument(ITypeUsage element);
    protected virtual IEnumerable`1<ITypeUsage> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeConstraintsClause : RearrangeableElementSwap`1<ITypeParameterConstraintsClause> {
    private RearrangeableTypeConstraintsClause(ITypeParameterConstraintsClause element);
    protected virtual IEnumerable`1<ITypeParameterConstraintsClause> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeDeclarationHolderLBrace : RearrangeableDeclarationRangeContainerLBraceBase {
    private RearrangeableTypeDeclarationHolderLBrace(IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> selectedItems, IDeclarationsRangeContainer holder, ITypeAndNamespaceHolderDeclaration target, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> innerItems, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> outerItems);
    protected virtual DocumentRange GetLBraceDocumentRange();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeDeclarationHolderRBrace : RearrangeableDeclarationRangeContainerRBraceBase {
    private RearrangeableTypeDeclarationHolderRBrace(IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> selectedItems, IDeclarationsRangeContainer holder, ITypeAndNamespaceHolderDeclaration target, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> innerItems, IReadOnlyList`1<ILogicalItem<IDeclarationsRangeContainer>> outerItems);
    protected virtual DocumentRange GetBraceDocumentRange();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeOrNamespaceDeclaration : RearrangeableCSharpLogicalItemBase`1<ICSharpTypeAndNamespaceHolderDeclaration> {
    [CompilerGeneratedAttribute]
private IDeclarationsRange <DeclarationsRange>k__BackingField;
    [NotNullAttribute]
private IDeclarationsRange DeclarationsRange { get; }
    public Direction SupportedDirections { get; }
    public RearrangeableTypeOrNamespaceDeclaration(IReadOnlyList`1<ILogicalItem<ICSharpTypeAndNamespaceHolderDeclaration>> selectedItems, ICSharpTypeAndNamespaceHolderDeclaration holder, IReadOnlyList`1<ILogicalItem<ICSharpTypeAndNamespaceHolderDeclaration>> holderItems);
    [CompilerGeneratedAttribute]
private IDeclarationsRange get_DeclarationsRange();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
    [CanBeNullAttribute]
private IDeclarationsRangeContainer GetNextClassLikeDeclaration();
    [CanBeNullAttribute]
private IDeclarationsRangeContainer GetNextNamespaceDeclaration();
    [CanBeNullAttribute]
private IDeclarationsRangeContainer GetNextContainer();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeOrNamespaceHolderItem : RearrangeableCSharpLogicalItemBase`1<ICSharpTypeAndNamespaceHolderDeclaration> {
    [CompilerGeneratedAttribute]
private IDeclarationsRange <DeclarationsRange>k__BackingField;
    private IDeclarationsRange DeclarationsRange { get; }
    public Direction SupportedDirections { get; }
    private RearrangeableTypeOrNamespaceHolderItem(IReadOnlyList`1<ILogicalItem<ICSharpTypeAndNamespaceHolderDeclaration>> selectedItems, ICSharpTypeAndNamespaceHolderDeclaration holder, IReadOnlyList`1<ILogicalItem<ICSharpTypeAndNamespaceHolderDeclaration>> items);
    [CompilerGeneratedAttribute]
private IDeclarationsRange get_DeclarationsRange();
    public virtual Direction get_SupportedDirections();
    public virtual bool CanMove(Direction direction);
    public virtual ValueTuple`2<DocumentRange, ITreeRange> MoveUnderPsiTransaction(Direction direction);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeParameterConstraint : RearrangeableElementSwap`1<ITypeParameterConstraint> {
    private RearrangeableTypeParameterConstraint(ITypeParameterConstraint element);
    protected virtual IEnumerable`1<ITypeParameterConstraint> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeParameterOfLocalFunction : RearrangeableElementSwap`1<ITypeParameterOfLocalFunctionDeclaration> {
    private RearrangeableTypeParameterOfLocalFunction(ITypeParameterOfLocalFunctionDeclaration element);
    protected virtual IEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeParameterOfMethod : RearrangeableElementSwap`1<ITypeParameterOfMethodDeclaration> {
    private RearrangeableTypeParameterOfMethod(ITypeParameterOfMethodDeclaration element);
    protected virtual IEnumerable`1<ITypeParameterOfMethodDeclaration> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableTypeParameterOfType : RearrangeableElementSwap`1<ITypeParameterOfTypeDeclaration> {
    private RearrangeableTypeParameterOfType(ITypeParameterOfTypeDeclaration element);
    protected virtual IEnumerable`1<ITypeParameterOfTypeDeclaration> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableVariableDesignation : RearrangeableElementSwap`1<IVariableDesignation> {
    private RearrangeableVariableDesignation(IVariableDesignation variableDesignation);
    protected virtual IEnumerable`1<IVariableDesignation> GetSiblings();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.RearrangeCode.RearrangeableWithAssignment : RearrangeableElementSwap`1<IWithInitializerAssignment> {
    private RearrangeableWithAssignment(IWithInitializerAssignment element);
    protected virtual IEnumerable`1<IWithInitializerAssignment> GetSiblings();
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Refactoring.IntroduceVariableUtil : object {
    [NotNullAttribute]
public static Key`1<ExpressionData> MarkKey;
    private static IntroduceVariableUtil();
    [CanBeNullAttribute]
public static HotspotsRegistry IntroduceVariable(ICSharpExpression sourceExpression, ITreeNode scope);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static IntroduceVariableResult IntroduceDeconstructingDeclaration(ICSharpExpression sourceExpression, IDeconstruction deconstruction);
    [CanBeNullAttribute]
public static IntroduceVariableResult IntroduceVariable(IReadOnlyList`1<ITreeNode> expressions, ITreeNode sourceExpression, ISolution solution, ITreeNode containingLambdaElement, UsingDeclarationKind usingDeclarationKind);
    [NotNullAttribute]
private static IReadOnlyList`1<string> SuggestVariableNames(ISolution solution, ITreeNode context, IList`1<ICSharpExpression> expressions, IList`1<IType> possibleTypes, bool constOnly, ITreeNode uniqueNameContext);
    private static void ReplaceOccurrencesWithReference(List`1<ICSharpExpression> occurrences, ICSharpExpression variableReference, bool shouldCreateInUsing, ICSharpStatement commonStatement);
    public static void MakeImplicitTupleComponentNameExplicitIfNecessary(IReferenceExpression referenceExpression);
    [PureAttribute]
private static bool IsTupleExpressionTypeUsedForTypeInference(ICSharpExpression expression);
    [CanBeNullAttribute]
private static IntroduceVariableResult TryIntroduceQueryLetClause(ICSharpExpression sourceExpression, ITreeNode containingLambda, IReadOnlyList`1<string> uniqueNames, ISolution solution, IFile file);
    [NotNullAttribute]
private static IDeclarationStatement CreateLocalVariableDeclaration(ICSharpExpression expression, CSharpElementFactory factory, string variableName, ExpressionTypeSuggestion suggestion);
    [CanBeNullAttribute]
public static ITreeNode GetCommonLambda(IList`1<IReference> references, Func`2<ITreeNode, bool> isInnerElement);
    [CompilerGeneratedAttribute]
internal static bool <IsTupleExpressionTypeUsedForTypeInference>g__IsArgumentCanBeUsedForGenericMethodTypeArgumentsInference|6_0(CSharpParameterInstance matchingParameter);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.Refactoring.ZoneMarker : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string AfterDotSettingDescription { get; }
    public static string AfternewSettingDescription { get; }
    public static string AnnotateNullabilityOnAfterEntityNameSettingDescription { get; }
    public static string AnnotateNullabilityOnAfterTypeNameSettingDescription { get; }
    public static string AnnotateNullabilityOnAtOtherPositionsSettingDescription { get; }
    public static string CAnnotationTypingAssistOptionsSettingDescription { get; }
    public static string CanUseCustomExpressionBasedPatternForAssertionSettingDescription { get; }
    public static string CanUseCustomStatementBasedPatternForAssertionSettingDescription { get; }
    public static string CAutoNamingNotificationStateSettingDescription { get; }
    public static string CAutoNamingSettingsSettingDescription { get; }
    public static string CCsFilesAndCCodeInSupportedServerPagesSettingDescription { get; }
    public static string CIntelliSenseEnabledSettingDescription { get; }
    public static string CodeCleanupTask_CSharpFormatDocComments { get; }
    public static string CodeCleanupTask_CSReformatCode { get; }
    public static string CodeCleanupTask_CSReorderTypeMembers { get; }
    public static string CodeCleanupTask_CSUpdateFileHeader { get; }
    public static string CompleteOnSpaceSettingDescription { get; }
    public static string Component__Text { get; }
    public static string ConfigureAwaitAnalysisModeSettingDescription { get; }
    public static string COptionPageTitle { get; }
    public static string COtherInlayHintsSettingsSettingDescription { get; }
    public static string CParameterNameHintsSettingsSettingDescription { get; }
    public static string CSettingDescription { get; }
    public static string CTypingAssistOptionsSettingDescription { get; }
    public static string DaemonProjectSettingsSettingDescription { get; }
    public static string EnableInspections { get; }
    public static string EnterActionSettingDescription { get; }
    public static string ForeachStatementTemplate_Text { get; }
    public static string FormattingMembers_Text { get; }
    public static string ImplementMembers_Text { get; }
    public static string InDocCommentsSettingDescription { get; }
    public static string InsertDocumentationCommentStubOnTypingTheThirdSettingDescription { get; }
    public static string InStringLiteralsSettingDescription { get; }
    public static string InContainerKind_Text { get; }
    public static string LetterAndDigitsSettingDescription { get; }
    public static string MakeFormattingMethodsOverrideable_Text { get; }
    public static string NamingStyleOptionPageTitle { get; }
    public static string NewRegion_Text { get; }
    public static string NonCompletingCharactersSettingDescription { get; }
    public static string NullCheckPatternsSettingsSettingDescription { get; }
    public static string PredictionFailed_Text { get; }
    public static string PriorityOfNullCheckingPatternsSettingDescription { get; }
    public static string ReformatCode_Name_Reformat_C_ { get; }
    public static string ReorderTypeMembers_Name_Apply_file_layout { get; }
    public static string ReSharperCTypeConversionHintsSettingsSettingDescription { get; }
    public static string ReSharperCTypeNameHintsSettingsSettingDescription { get; }
    public static string ShowMissingConstructsAsEditorHintsSettingDescription { get; }
    public static string ShowResourceDisposePointsAsEditorHintsSettingDescription { get; }
    public static string ShowResourceDisposeRequiredAsEditorHintsSettingDescription { get; }
    public static string ShowTupleComponentNameHintsSettingDescription { get; }
    public static string ShowUnnamedTupleComponentTypeNamesHintsSettingDescription { get; }
    public static string ShowDeconstructionPatternComponentNamesHints { get; }
    public static string ShowImplicitJumpHintsBeforeLocalFunctionsDescription { get; }
    public static string ShowDiscardTypeNameHints { get; }
    public static string ShowPragmaDescriptionHints { get; }
    public static string ShowInferredDiscardNames { get; }
    public static string ShowInterceptedCallsDescription { get; }
    public static string ShowInterceptsLocationNavigationHintDescription { get; }
    public static string ShowCommentBeforeLocalFunctionsWhenThereIsCodeInOuterScope { get; }
    public static string ShowCommentBeforeLocalFunctionsWhenThereIsCodeInOuterScope_Tooltip { get; }
    public static string MinimumLinesToShowCommentBeforeLocalFunctions { get; }
    public static string ShowBlockHeaderAfterItsClosingBraceDescription { get; }
    public static string TabActionSettingDescription { get; }
    public static string PredictionEnds_Text { get; }
    public static string UpdateFileHeader_Name_Update_file_header { get; }
    public static string UpgradedFromVSSettingsSettingDescription { get; }
    public static string VisibilityModeOfTypeNameHintsForLambdaExpressionParametersSettingDescription { get; }
    public static string VisibilityModeOfTypeNameHintsForPatternMatchingExpressionsSettingDescription { get; }
    public static string VisibilityModeOfTypeNameHintsForQueryRangeVariablesInLINQQueriesSettingDescription { get; }
    public static string VisibilityModeOfTypeNameHintsForTargetTypedNewExpressionsSettingDescription { get; }
    public static string WhereValueIsExpectedSettingDescription { get; }
    public static string WhetherOrNotLiveTemplatesShouldUsevarInsteadOfASpecificTypeNameSettingDescription { get; }
    public static string WhetherToHideTypeNameHintsForLambdaExpressionParametersIfTheTypeIsEvidentSettingDescription { get; }
    public static string WhetherToHideTypeNameHintsForTargetTypedNewExpressionsIfTheTypeIsEvidentSettingDescription { get; }
    public static string WhetherToIncludePropertyFieldAndVariableAccessorsInTheInvocationChainSettingDescription { get; }
    public static string WhetherToUseVarInsteadOfTypeSettingDescription { get; }
    public static string NullCheckPatternsSettings_CustomStatementPatternText_Description { get; }
    public static string NullCheckPatternsSettings_CustomExpressionPatternText_Description { get; }
    public static string CSharpAutoNamingAction_Text { get; }
    public static string CodeAnnotationsForParameterDeclarations_Header_Text { get; }
    public static string TupleComponentNameUnnamedComponentTypeHints_Option_Text { get; }
    public static string ShowBlockHeaderAfterItsClosingBrace_Header_Text { get; }
    public static string General_Header_Text { get; }
    public static string ShowTypeConversionHintsAsIcons_BoolOption_Text { get; }
    public static string HideForSystemTypeConversions_BoolOption_Text { get; }
    public static string General_Header_Text2 { get; }
    public static string UseCompactTypeNamePresentation_BoolOption_Text { get; }
    public static string HideIfTypeNameIsEvidentFromVariable_BoolOption_Text { get; }
    public static string MethodReturnType_Header_Text { get; }
    public static string IncludePropertyFieldAndVariableAccessors_BoolOption_Text { get; }
    public static string HideForSingleInvocationsAndOneLineMethod_BoolOption_Text { get; }
    public static string HideForTheLastInvocationWhenHintIsIrrelevant_BoolOption_Text { get; }
    public static string JoinHintsForSequencesOfMethodInvocations_BoolOption_Text { get; }
    public static string ImplicitlyTypedVariables_Header_Text { get; }
    public static string HideIfTypeOfVariableIsEvident_BoolOption_Text { get; }
    public static string PatternMatchingExpressions_Header_Text { get; }
    public static string LambdaExpressionParameters_Header_Text { get; }
    public static string HideIfTypesOfParametersAreEvident_BoolOption_Text { get; }
    public static string LINQRangeVariables_Header_Text { get; }
    public static string TargetTypedNewExpressions_Header_Text { get; }
    public static string HideIfTargetTypeIsEvident_BoolOption_Text { get; }
    public static string Mode_ComboEnum_Caption { get; }
    public static string Assembly__Text { get; }
    public static string Assembly_Ellipsis_Text { get; }
    public static string CreateTracepoint_Text { get; }
    public static string ApplyingSyntaxStyle_Text { get; }
    public static string GeneratingConstructor_Text { get; }
    public static string GeneratingInitializations_Text { get; }
    public static string GeneratingDelegatingMembers_Text { get; }
    public static string GeneratingEventSubscriptions_Text { get; }
    public static string GeneratingImplementations_Text { get; }
    public static string GeneratingMemberBodies_Text { get; }
    public static string GeneratingOverrides_Text { get; }
    public static string GeneratingPartialMethods_Text { get; }
    public static string GeneratingProperties_Text { get; }
    public static string GeneratingXMLDocumentation_Text { get; }
    public static string GeneratingTypePatterns_Text { get; }
    public static string CPredefinedNamingPolicy_Text { get; }
    public static string PredefinedCParameterNameHintsExclusion_Text { get; }
    public static string CSharp_InconsistentNaming_Header { get; }
    public static string CSharp_InconsistentNaming_Text { get; }
    public static string CSharp_AutodetectedRules_Header { get; }
    public static string CSharp_AutodetectedRules_Text { get; }
    public static string CSharp_EditorConfigOverride_Text { get; }
    public static string CSharp_AutodetectOverride_Text { get; }
    public static string CSharp_Abbreviations_Text { get; }
    public static string CSharp_SupportMicrosoftEventsStyle_Text { get; }
    public static string CSharp_EventHandlersNamingStyle_Text { get; }
    public static string CSharp_EventOnFieldsStyle_Text { get; }
    public static string CSharp_EventsOnThisStyle_Text { get; }
    public static string CSharp_AddNamingRule_Header { get; }
    public static string CSharp_EditNamingRule_Header { get; }
    public static string CSharp_ApplyThisStyle_Header { get; }
    public static string CSharp_ToTheFollowingElements_Header { get; }
    public static string CSharp_AccessRights_Header { get; }
    public static string Add_Text { get; }
    public static string Edit_Text { get; }
    public static string View_Text { get; }
    public static string Remove_Text { get; }
    public static string RuleName_Text { get; }
    public static string Preview_Text { get; }
    public static string From_Text { get; }
    public static string MoveUp_Text { get; }
    public static string MoveDown_Text { get; }
    public static string Prefix_Text { get; }
    public static string Suffix_Text { get; }
    public static string Style_Text { get; }
    public static string RuleDescription_Text { get; }
    public static string SelectArgumentExpression_Text { get; }
    public static string SelectExpressionToCast_Text { get; }
    public static string SelectExpressionToInvert_Text { get; }
    public static string SelectExpressionToParenthesize_Text { get; }
    public static string UseSingleIterationVariable__Text { get; }
    public static string UseSingleIterationVariable_Text { get; }
    public static string DeconstructIterationVariableInto_TextPrefix { get; }
    public static string ElementOfCollection__Text { get; }
    public static string Parameter_Of__Text { get; }
    public static string ReturnValueOf__Text { get; }
    public static string Argument_Of__Text { get; }
    public static string InvocationResultOf__Text { get; }
    public static string EmptyParams_Text { get; }
    public static string DefaultValue__Text { get; }
    public static string PresentationFailed_Text { get; }
    public static string DefaultValueForType__Text { get; }
    public static string QualifierOfExpression__Text { get; }
    public static string ResultOf__Text { get; }
    public static string ReturnValueOfGetterOf__Text { get; }
    public static string ReceivedValueOf__Text { get; }
    public static string ValuesAssignedTo_Text { get; }
    public static string ReadUsagesOf__Text { get; }
    public static string InvalidPlaceholder__Text { get; }
    public static string PatternIsValid_Text { get; }
    public static string PatternIsEmpty_Text { get; }
    public static string SyntaxError_Text { get; }
    public static string AddNotNullCanBeNullByTypingAfterSymbol_Text { get; }
    public static string AnnotateYourCodeInJustOneKeystrokeAfter_Text { get; }
    public static string Configure_Text { get; }
    public static string CodeContract_Text { get; }
    public static string CodeContractGeneric_Text { get; }
    public static string CustomStatement_Text { get; }
    public static string CustomExpression_Text { get; }
    public static string DebugAssert_Text { get; }
    public static string ReferenceEquals_Text { get; }
    public static string Classic_Text { get; }
    public static string ThrowIfNull_Text { get; }
    public static string PatternMatchingC70_Text { get; }
    public static string ThrowExpressionC70_Text { get; }
    public static string Successful_Tests_Hint { get; }
    public static string Failed_Tests_Hint { get; }
    public static string Ignored_Tests_Hint { get; }
    public static string Aborted_Tests_Hint { get; }
    public static string Inconclusive_Tests_Hint { get; }
    public static string Unknown_Tests_Hint { get; }
    public static string Pending_Tests_Hint { get; }
    public static string Running_Tests_Hint { get; }
    public static string Broken_Tests_Hint { get; }
    public static string TraceAssert_Text { get; }
    public static string EvaluatesToNameofEntityIfPossibleOrEntityOtherwiseMacroDefinition_Description { get; }
    public static string EvaluatesToNameofEntityIfPossibleOrEntityOtherwiseMacroDefinition_LongDescription { get; }
    public static string NoTypeConversionHintsWillBeShownForOperatorPatter { get; }
    public static string TypeConversionHintsExclusionListValueNotValid { get; }
    public static string XUnitParameterNameHintsSettingsSettingDescription { get; }
    public static string NUnitParameterNameHintsSettingsSettingDescription { get; }
    public static string OverrideInlineAutoDataAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription { get; }
    public static string OverrideInlineDataAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription { get; }
    public static string OverrideTestCaseAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription { get; }
    public static string OverrideInlineDataArgumentNames_BoolOption_Text { get; }
    public static string OverrideInlineAutoDataArgumentNames_BoolOption_Text { get; }
    public static string OverrideTestCaseArgumentNames_BoolOption_Text { get; }
    public static string XUnitAttributesDescription { get; }
    public static string NUnitAttributesDescription { get; }
    public static string ReformatInactiveBranches_Name_Reformat_CS { get; }
    public static string CodeCleanupTask_CSReformatInactiveBranches { get; }
    public static string ReformatInactiveBranchesProgressText { get; }
    public static string UseNameofExressionToReferenceMemberNames_Text { get; }
    public static string Virtual_Text { get; }
    public static string CheckParametersForNull_Text { get; }
    public static string HandleNUllValue_Text { get; }
    public static string HandleAnyOtherValue_Text { get; }
    public static string GeneratePatternVariable_Text { get; }
    public static string MakeParametersOptional_Text { get; }
    public static string MakePropertiesMutable_Text { get; }
    public static string MakeTaskReturningMethodsAsync_Text { get; }
    public static string UseSystemHashCodeToImplementGetHashCode_Text { get; }
    public static string GenerateOption_ReadOnly_Text { get; }
    public static string GenerateOption_PropertiesAs_Text { get; }
    public static string GenerateOption_AccessRights_Text { get; }
    public static string GenerateOption_Automatic_Text { get; }
    public static string GenerateOption_Yes_Text { get; }
    public static string GenerateOption_No_Text { get; }
    public static string GenerateOption_NotifyOnPropertyChanges_Text { get; }
    public static string GenerateOption_UseMethod__Text { get; }
    public static string GenerateOption_ImplementAs_Text { get; }
    public static string GenerateOption_PublicMember_Text { get; }
    public static string GenerateOption_ExplicitImplementation_Text { get; }
    public static string GenerateOption_AbstractMember_Text { get; }
    public static string GenerateOption_VirtualMember_Text { get; }
    public static string GenerateOption_DefaultBodyFromOptions_Text { get; }
    public static string GenerateOption_AutomaticProperty_Text { get; }
    public static string GenerateOption_PropertyWithBackingField_Text { get; }
    public static string Is_Text { get; }
    public static string InAssembly__Text { get; }
    public static string InterceptorsHints_OptionsPage_Title { get; }
    public static string InterceptsLocationHint_Visibility_Text { get; }
    public static string InterceptedCallHint_Visibility_Text { get; }
    public static string CSharpInterceptorsInlayHints_OptionsPage_IgnoredGenerators_Description { get; }
    public static string CSharpInterceptorsInlayHints_OptionsPage_IgnoredGenerators_FQN { get; }
    public static string CsLanguageLevelDisplayName_Text { get; }
    public static string CsLanguageLevelDescription_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string get_AfterDotSettingDescription();
    public static string get_AfternewSettingDescription();
    public static string get_AnnotateNullabilityOnAfterEntityNameSettingDescription();
    public static string get_AnnotateNullabilityOnAfterTypeNameSettingDescription();
    public static string get_AnnotateNullabilityOnAtOtherPositionsSettingDescription();
    public static string get_CAnnotationTypingAssistOptionsSettingDescription();
    public static string get_CanUseCustomExpressionBasedPatternForAssertionSettingDescription();
    public static string get_CanUseCustomStatementBasedPatternForAssertionSettingDescription();
    public static string get_CAutoNamingNotificationStateSettingDescription();
    public static string get_CAutoNamingSettingsSettingDescription();
    public static string get_CCsFilesAndCCodeInSupportedServerPagesSettingDescription();
    public static string get_CIntelliSenseEnabledSettingDescription();
    public static string get_CodeCleanupTask_CSharpFormatDocComments();
    public static string get_CodeCleanupTask_CSReformatCode();
    public static string get_CodeCleanupTask_CSReorderTypeMembers();
    public static string get_CodeCleanupTask_CSUpdateFileHeader();
    public static string get_CompleteOnSpaceSettingDescription();
    public static string get_Component__Text();
    public static string get_ConfigureAwaitAnalysisModeSettingDescription();
    public static string get_COptionPageTitle();
    public static string get_COtherInlayHintsSettingsSettingDescription();
    public static string get_CParameterNameHintsSettingsSettingDescription();
    public static string get_CSettingDescription();
    public static string get_CTypingAssistOptionsSettingDescription();
    public static string get_DaemonProjectSettingsSettingDescription();
    public static string get_EnableInspections();
    public static string get_EnterActionSettingDescription();
    public static string get_ForeachStatementTemplate_Text();
    public static string get_FormattingMembers_Text();
    public static string get_ImplementMembers_Text();
    public static string get_InDocCommentsSettingDescription();
    public static string get_InsertDocumentationCommentStubOnTypingTheThirdSettingDescription();
    public static string get_InStringLiteralsSettingDescription();
    public static string get_InContainerKind_Text();
    public static string get_LetterAndDigitsSettingDescription();
    public static string get_MakeFormattingMethodsOverrideable_Text();
    public static string get_NamingStyleOptionPageTitle();
    public static string get_NewRegion_Text();
    public static string get_NonCompletingCharactersSettingDescription();
    public static string get_NullCheckPatternsSettingsSettingDescription();
    public static string get_PredictionFailed_Text();
    public static string get_PriorityOfNullCheckingPatternsSettingDescription();
    public static string get_ReformatCode_Name_Reformat_C_();
    public static string get_ReorderTypeMembers_Name_Apply_file_layout();
    public static string get_ReSharperCTypeConversionHintsSettingsSettingDescription();
    public static string get_ReSharperCTypeNameHintsSettingsSettingDescription();
    public static string get_ShowMissingConstructsAsEditorHintsSettingDescription();
    public static string get_ShowResourceDisposePointsAsEditorHintsSettingDescription();
    public static string get_ShowResourceDisposeRequiredAsEditorHintsSettingDescription();
    public static string get_ShowTupleComponentNameHintsSettingDescription();
    public static string get_ShowUnnamedTupleComponentTypeNamesHintsSettingDescription();
    public static string get_ShowDeconstructionPatternComponentNamesHints();
    public static string get_ShowImplicitJumpHintsBeforeLocalFunctionsDescription();
    public static string get_ShowDiscardTypeNameHints();
    public static string get_ShowPragmaDescriptionHints();
    public static string get_ShowInferredDiscardNames();
    public static string get_ShowInterceptedCallsDescription();
    public static string get_ShowInterceptsLocationNavigationHintDescription();
    public static string get_ShowCommentBeforeLocalFunctionsWhenThereIsCodeInOuterScope();
    public static string get_ShowCommentBeforeLocalFunctionsWhenThereIsCodeInOuterScope_Tooltip();
    public static string get_MinimumLinesToShowCommentBeforeLocalFunctions();
    public static string get_ShowBlockHeaderAfterItsClosingBraceDescription();
    public static string get_TabActionSettingDescription();
    public static string get_PredictionEnds_Text();
    public static string get_UpdateFileHeader_Name_Update_file_header();
    public static string get_UpgradedFromVSSettingsSettingDescription();
    public static string get_VisibilityModeOfTypeNameHintsForLambdaExpressionParametersSettingDescription();
    public static string get_VisibilityModeOfTypeNameHintsForPatternMatchingExpressionsSettingDescription();
    public static string get_VisibilityModeOfTypeNameHintsForQueryRangeVariablesInLINQQueriesSettingDescription();
    public static string get_VisibilityModeOfTypeNameHintsForTargetTypedNewExpressionsSettingDescription();
    public static string get_WhereValueIsExpectedSettingDescription();
    public static string get_WhetherOrNotLiveTemplatesShouldUsevarInsteadOfASpecificTypeNameSettingDescription();
    public static string get_WhetherToHideTypeNameHintsForLambdaExpressionParametersIfTheTypeIsEvidentSettingDescription();
    public static string get_WhetherToHideTypeNameHintsForTargetTypedNewExpressionsIfTheTypeIsEvidentSettingDescription();
    public static string get_WhetherToIncludePropertyFieldAndVariableAccessorsInTheInvocationChainSettingDescription();
    public static string get_WhetherToUseVarInsteadOfTypeSettingDescription();
    public static string get_NullCheckPatternsSettings_CustomStatementPatternText_Description();
    public static string get_NullCheckPatternsSettings_CustomExpressionPatternText_Description();
    public static string get_CSharpAutoNamingAction_Text();
    public static string get_CodeAnnotationsForParameterDeclarations_Header_Text();
    public static string get_TupleComponentNameUnnamedComponentTypeHints_Option_Text();
    public static string get_ShowBlockHeaderAfterItsClosingBrace_Header_Text();
    public static string get_General_Header_Text();
    public static string get_ShowTypeConversionHintsAsIcons_BoolOption_Text();
    public static string get_HideForSystemTypeConversions_BoolOption_Text();
    public static string get_General_Header_Text2();
    public static string get_UseCompactTypeNamePresentation_BoolOption_Text();
    public static string get_HideIfTypeNameIsEvidentFromVariable_BoolOption_Text();
    public static string get_MethodReturnType_Header_Text();
    public static string get_IncludePropertyFieldAndVariableAccessors_BoolOption_Text();
    public static string get_HideForSingleInvocationsAndOneLineMethod_BoolOption_Text();
    public static string get_HideForTheLastInvocationWhenHintIsIrrelevant_BoolOption_Text();
    public static string get_JoinHintsForSequencesOfMethodInvocations_BoolOption_Text();
    public static string get_ImplicitlyTypedVariables_Header_Text();
    public static string get_HideIfTypeOfVariableIsEvident_BoolOption_Text();
    public static string get_PatternMatchingExpressions_Header_Text();
    public static string get_LambdaExpressionParameters_Header_Text();
    public static string get_HideIfTypesOfParametersAreEvident_BoolOption_Text();
    public static string get_LINQRangeVariables_Header_Text();
    public static string get_TargetTypedNewExpressions_Header_Text();
    public static string get_HideIfTargetTypeIsEvident_BoolOption_Text();
    public static string get_Mode_ComboEnum_Caption();
    public static string get_Assembly__Text();
    public static string get_Assembly_Ellipsis_Text();
    public static string get_CreateTracepoint_Text();
    public static string get_ApplyingSyntaxStyle_Text();
    public static string get_GeneratingConstructor_Text();
    public static string get_GeneratingInitializations_Text();
    public static string get_GeneratingDelegatingMembers_Text();
    public static string get_GeneratingEventSubscriptions_Text();
    public static string get_GeneratingImplementations_Text();
    public static string get_GeneratingMemberBodies_Text();
    public static string get_GeneratingOverrides_Text();
    public static string get_GeneratingPartialMethods_Text();
    public static string get_GeneratingProperties_Text();
    public static string get_GeneratingXMLDocumentation_Text();
    public static string get_GeneratingTypePatterns_Text();
    public static string get_CPredefinedNamingPolicy_Text();
    public static string get_PredefinedCParameterNameHintsExclusion_Text();
    public static string get_CSharp_InconsistentNaming_Header();
    public static string get_CSharp_InconsistentNaming_Text();
    public static string get_CSharp_AutodetectedRules_Header();
    public static string get_CSharp_AutodetectedRules_Text();
    public static string get_CSharp_EditorConfigOverride_Text();
    public static string get_CSharp_AutodetectOverride_Text();
    public static string get_CSharp_Abbreviations_Text();
    public static string get_CSharp_SupportMicrosoftEventsStyle_Text();
    public static string get_CSharp_EventHandlersNamingStyle_Text();
    public static string get_CSharp_EventOnFieldsStyle_Text();
    public static string get_CSharp_EventsOnThisStyle_Text();
    public static string get_CSharp_AddNamingRule_Header();
    public static string get_CSharp_EditNamingRule_Header();
    public static string get_CSharp_ApplyThisStyle_Header();
    public static string get_CSharp_ToTheFollowingElements_Header();
    public static string get_CSharp_AccessRights_Header();
    public static string get_Add_Text();
    public static string get_Edit_Text();
    public static string get_View_Text();
    public static string get_Remove_Text();
    public static string get_RuleName_Text();
    public static string get_Preview_Text();
    public static string get_From_Text();
    public static string get_MoveUp_Text();
    public static string get_MoveDown_Text();
    public static string get_Prefix_Text();
    public static string get_Suffix_Text();
    public static string get_Style_Text();
    public static string get_RuleDescription_Text();
    public static string get_SelectArgumentExpression_Text();
    public static string get_SelectExpressionToCast_Text();
    public static string get_SelectExpressionToInvert_Text();
    public static string get_SelectExpressionToParenthesize_Text();
    public static string get_UseSingleIterationVariable__Text();
    public static string get_UseSingleIterationVariable_Text();
    public static string get_DeconstructIterationVariableInto_TextPrefix();
    public static string get_ElementOfCollection__Text();
    public static string get_Parameter_Of__Text();
    public static string get_ReturnValueOf__Text();
    public static string get_Argument_Of__Text();
    public static string get_InvocationResultOf__Text();
    public static string get_EmptyParams_Text();
    public static string get_DefaultValue__Text();
    public static string get_PresentationFailed_Text();
    public static string get_DefaultValueForType__Text();
    public static string get_QualifierOfExpression__Text();
    public static string get_ResultOf__Text();
    public static string get_ReturnValueOfGetterOf__Text();
    public static string get_ReceivedValueOf__Text();
    public static string get_ValuesAssignedTo_Text();
    public static string get_ReadUsagesOf__Text();
    public static string get_InvalidPlaceholder__Text();
    public static string get_PatternIsValid_Text();
    public static string get_PatternIsEmpty_Text();
    public static string get_SyntaxError_Text();
    public static string get_AddNotNullCanBeNullByTypingAfterSymbol_Text();
    public static string get_AnnotateYourCodeInJustOneKeystrokeAfter_Text();
    public static string get_Configure_Text();
    public static string get_CodeContract_Text();
    public static string get_CodeContractGeneric_Text();
    public static string get_CustomStatement_Text();
    public static string get_CustomExpression_Text();
    public static string get_DebugAssert_Text();
    public static string get_ReferenceEquals_Text();
    public static string get_Classic_Text();
    public static string get_ThrowIfNull_Text();
    public static string get_PatternMatchingC70_Text();
    public static string get_ThrowExpressionC70_Text();
    public static string get_Successful_Tests_Hint();
    public static string get_Failed_Tests_Hint();
    public static string get_Ignored_Tests_Hint();
    public static string get_Aborted_Tests_Hint();
    public static string get_Inconclusive_Tests_Hint();
    public static string get_Unknown_Tests_Hint();
    public static string get_Pending_Tests_Hint();
    public static string get_Running_Tests_Hint();
    public static string get_Broken_Tests_Hint();
    public static string get_TraceAssert_Text();
    public static string get_EvaluatesToNameofEntityIfPossibleOrEntityOtherwiseMacroDefinition_Description();
    public static string get_EvaluatesToNameofEntityIfPossibleOrEntityOtherwiseMacroDefinition_LongDescription();
    public static string get_NoTypeConversionHintsWillBeShownForOperatorPatter();
    public static string get_TypeConversionHintsExclusionListValueNotValid();
    public static string get_XUnitParameterNameHintsSettingsSettingDescription();
    public static string get_NUnitParameterNameHintsSettingsSettingDescription();
    public static string get_OverrideInlineAutoDataAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription();
    public static string get_OverrideInlineDataAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription();
    public static string get_OverrideTestCaseAttributeArgumentNamesWithTestMethodsParameterNamesSettingDescription();
    public static string get_OverrideInlineDataArgumentNames_BoolOption_Text();
    public static string get_OverrideInlineAutoDataArgumentNames_BoolOption_Text();
    public static string get_OverrideTestCaseArgumentNames_BoolOption_Text();
    public static string get_XUnitAttributesDescription();
    public static string get_NUnitAttributesDescription();
    public static string get_ReformatInactiveBranches_Name_Reformat_CS();
    public static string get_CodeCleanupTask_CSReformatInactiveBranches();
    public static string get_ReformatInactiveBranchesProgressText();
    public static string get_UseNameofExressionToReferenceMemberNames_Text();
    public static string get_Virtual_Text();
    public static string get_CheckParametersForNull_Text();
    public static string get_HandleNUllValue_Text();
    public static string get_HandleAnyOtherValue_Text();
    public static string get_GeneratePatternVariable_Text();
    public static string get_MakeParametersOptional_Text();
    public static string get_MakePropertiesMutable_Text();
    public static string get_MakeTaskReturningMethodsAsync_Text();
    public static string get_UseSystemHashCodeToImplementGetHashCode_Text();
    public static string get_GenerateOption_ReadOnly_Text();
    public static string get_GenerateOption_PropertiesAs_Text();
    public static string get_GenerateOption_AccessRights_Text();
    public static string get_GenerateOption_Automatic_Text();
    public static string get_GenerateOption_Yes_Text();
    public static string get_GenerateOption_No_Text();
    public static string get_GenerateOption_NotifyOnPropertyChanges_Text();
    public static string get_GenerateOption_UseMethod__Text();
    public static string get_GenerateOption_ImplementAs_Text();
    public static string get_GenerateOption_PublicMember_Text();
    public static string get_GenerateOption_ExplicitImplementation_Text();
    public static string get_GenerateOption_AbstractMember_Text();
    public static string get_GenerateOption_VirtualMember_Text();
    public static string get_GenerateOption_DefaultBodyFromOptions_Text();
    public static string get_GenerateOption_AutomaticProperty_Text();
    public static string get_GenerateOption_PropertyWithBackingField_Text();
    public static string get_Is_Text();
    public static string get_InAssembly__Text();
    public static string get_InterceptorsHints_OptionsPage_Title();
    public static string get_InterceptsLocationHint_Visibility_Text();
    public static string get_InterceptedCallHint_Visibility_Text();
    public static string get_CSharpInterceptorsInlayHints_OptionsPage_IgnoredGenerators_Description();
    public static string get_CSharpInterceptorsInlayHints_OptionsPage_IgnoredGenerators_FQN();
    public static string get_CsLanguageLevelDisplayName_Text();
    public static string get_CsLanguageLevelDescription_Text();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpDotSelection : DotSelection`1<ICSharpFile> {
    private TreeOffset myOffset;
    public TreeTextRange TreeRange { get; }
    public CSharpDotSelection(ICSharpFile fileNode, TreeOffset offset, bool selectBetterToken, bool useCamelHumps, bool appendInjectedPsi);
    protected virtual ISelectedRange GetParentInternal(ITokenNode tokenNode);
    public sealed virtual TreeTextRange get_TreeRange();
    private ISelectedRange TryCreateXmlDocSelection(ITokenNode tokenNode);
    protected virtual ISelectedRange CreateTokenPartSelection(ITokenNode tokenNode, TreeTextRange treeTextRange);
    protected virtual ISelectedRange CreateTreeNodeSelection(ITokenNode tokenNode);
    protected virtual bool IsWordToken(ITokenNode token);
    protected virtual bool IsPrevTokenBetter(ITokenNode prevToken, ITokenNode tokenNode);
    protected virtual bool IsLiteralToken(ITokenNode token);
    protected virtual bool IsSpaceToken(ITokenNode token);
    protected virtual bool IsNewLineToken(ITokenNode token);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpElementAccessExpressionPartSelection : SelectedRangeBase`1<ICSharpFile> {
    private IElementAccessExpression myElementAccessExpression;
    private IReferenceExpression myReferenceExpression;
    private ITreeNode myFirst;
    private ITreeNode myLast;
    public TreeTextRange TreeRange { get; }
    public ExtendToTheWholeLinePolicy ExtendToWholeLine { get; }
    public ISelectedRange Parent { get; }
    private CSharpElementAccessExpressionPartSelection(ICSharpFile fileNode, ITreeNode first, ITreeNode last, IElementAccessExpression elementAccessExpression, IReferenceExpression referenceExpression);
    public sealed virtual TreeTextRange get_TreeRange();
    public static ITreeNode GetNameNode(IInvocationExpression invocationExpression);
    public virtual ExtendToTheWholeLinePolicy get_ExtendToWholeLine();
    public virtual ISelectedRange get_Parent();
    public static CSharpElementAccessExpressionPartSelection TryCreate(ICSharpFile fileNode, ITreeNode first, ITreeNode last);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpElseBlockSelection : CSharpIfSelectionBase {
    public ISelectedRange Parent { get; }
    internal CSharpElseBlockSelection(IIfStatement ifStatement);
    public virtual ISelectedRange get_Parent();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpElseIfBlockSelection : CSharpIfSelectionBase {
    public ISelectedRange Parent { get; }
    internal CSharpElseIfBlockSelection(IIfStatement outerIfStatement, IIfStatement innerIfStatement);
    public virtual ISelectedRange get_Parent();
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpIfSelectionBase : SelectedRangeBase`1<ICSharpFile> {
    [CompilerGeneratedAttribute]
private IIfStatement <IfNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <FirstNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <LastNode>k__BackingField;
    protected IIfStatement IfNode { get; }
    public ITreeNode FirstNode { get; }
    public ITreeNode LastNode { get; }
    public ExtendToTheWholeLinePolicy ExtendToWholeLine { get; }
    public TreeTextRange TreeRange { get; }
    protected CSharpIfSelectionBase(IIfStatement ifStatement, ITreeNode first, ITreeNode last);
    [CompilerGeneratedAttribute]
protected IIfStatement get_IfNode();
    [CompilerGeneratedAttribute]
public ITreeNode get_FirstNode();
    [CompilerGeneratedAttribute]
public ITreeNode get_LastNode();
    public virtual ExtendToTheWholeLinePolicy get_ExtendToWholeLine();
    public sealed virtual TreeTextRange get_TreeRange();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpIfThenBlockSelection : CSharpIfSelectionBase {
    public ISelectedRange Parent { get; }
    public CSharpIfThenBlockSelection(IIfStatement ifStatement);
    public virtual ISelectedRange get_Parent();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpInterpolatedStringExpressionSelection : CSharpTreeRangeSelection {
    public CSharpInterpolatedStringExpressionSelection(ICSharpFile fileNode, IInterpolatedStringExpression node);
    private static TreeOffset LastOffsetFunc(ITreeNode node);
    private static TreeOffset FirstOffsetFunc(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpInterpolatedStringInsertSelection : CSharpTreeNodeSelection {
    private IInterpolatedStringExpression myInterpolatedStringExpression;
    private ITreeNode myPrevToken;
    private ITreeNode myNextToken;
    public ISelectedRange Parent { get; }
    public CSharpInterpolatedStringInsertSelection(ICSharpFile fileNode, IInterpolatedStringInsert node, ITreeNode prevToken, ITreeNode nextToken);
    public virtual ISelectedRange get_Parent();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpInterpolatedStringInsertSelectionWithTokens : CSharpTreeRangeSelection {
    private IInterpolatedStringExpression myInterpolatedStringExpression;
    public ISelectedRange Parent { get; }
    public CSharpInterpolatedStringInsertSelectionWithTokens(ICSharpFile fileNode, ITreeNode first, ITreeNode last, IInterpolatedStringExpression interpolatedStringExpression);
    public virtual ISelectedRange get_Parent();
    private static TreeOffset LastOffsetFunc(ITreeNode node);
    private static TreeOffset FirstOffsetFunc(ITreeNode node);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpInvocationExpressionPartSelection : SelectedRangeBase`1<ICSharpFile> {
    private IInvocationExpression myInvocationExpression;
    private IReferenceExpression myReferenceExpression;
    private ITreeNode myFirst;
    private ITreeNode myLast;
    public TreeTextRange TreeRange { get; }
    public ExtendToTheWholeLinePolicy ExtendToWholeLine { get; }
    public ISelectedRange Parent { get; }
    private CSharpInvocationExpressionPartSelection(ICSharpFile fileNode, ITreeNode first, ITreeNode last, IInvocationExpression invocationExpression, IReferenceExpression referenceExpression);
    public sealed virtual TreeTextRange get_TreeRange();
    public virtual ExtendToTheWholeLinePolicy get_ExtendToWholeLine();
    public virtual ITreeRange TryGetTreeRange();
    public virtual ISelectedRange get_Parent();
    [CanBeNullAttribute]
public static CSharpInvocationExpressionPartSelection TryCreate(ICSharpFile fileNode, ITreeNode first, ITreeNode last);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpSelectEmbracingConstructProvider : object {
    private ISettingsStore mySettingsStore;
    public CSharpSelectEmbracingConstructProvider(ISettingsStore settingsStore);
    public sealed virtual bool IsAvailable(IPsiSourceFile sourceFile);
    public sealed virtual ISelectedRange GetSelectedRange(IPsiSourceFile sourceFile, DocumentRange documentRange);
    public ISelectedRange GetSelectedRange(ICSharpFile file, DocumentRange documentRange);
    internal static ISelectedRange ExtendRangeSelection(ICSharpFile fileNode, ITreeNode first, ITreeNode last);
    [CanBeNullAttribute]
private static ISelectedRange CreateInterpolatedStringInsertSelection(ICSharpFile fileNode, ITreeNode first, ITreeNode last, ITreeNode parent);
    [CanBeNullAttribute]
private static ISelectedRange CreateSelection(ICSharpFile fileNode, ITreeNode first, ITreeNode last, ITreeNode newFirst, ITreeNode newLast, Nullable`1<ExtendToTheWholeLinePolicy> overridExtendToTheWholeLinePolicy);
    private static ISelectedRange TryExtendToSiblings(ICSharpFile fileNode, ITreeNode first, ITreeNode last, ITreeNode lStopper, ITreeNode rStopper);
    [CanBeNullAttribute]
private static ISelectedRange TryExtendFromInitializer(IInitializerOwnerDeclaration initializerOwner, ICSharpFile fileNode, ITreeNode first, ITreeNode last);
    private static ITreeNode ExtendToTheLeftWhitespace(ITreeNode node);
    [CanBeNullAttribute]
private static ISelectedRange TryExtendFromMember(IMemberOwnerBody body, ICSharpFile fileNode, ITreeNode first, ITreeNode last);
    [CanBeNullAttribute]
private static ISelectedRange GetChildRange(ITreeNode parent, ITreeNode lBrace, ITreeNode rbrace, ICSharpFile fileNode, ITreeNode first, ITreeNode last);
    private static ISelectedRange TryExtendFromSingleStatement(ICSharpFile fileNode, ICSharpStatement statement);
    internal static ISelectedRange BuildNodeSelection(ICSharpFile fileNode, ITreeNode node);
    private static bool IsStatement(ITreeNode treeNode);
    private static bool IsComma(ITreeNode treeNode);
    private static ISelectedRange TryFindPPConditionalBlockRange(ICSharpFile fileNode, ITreeNode first, ITreeNode last);
    private static ISelectedRange TryFindPPConditionalRange(ICSharpFile fileNode, ITreeNode first, ITreeNode last);
    private static ISelectedRange TryFindPragmaRange(ICSharpFile fileNode, ITreeNode first, ITreeNode last);
    private static ISelectedRange TryFindRegionRange(ICSharpFile fileNode, ITreeNode first, ITreeNode last);
    private static ISelectedRange BuildAllCatchesAndFinallyRange(ICSharpFile fileNode, ITryStatement tryStatement);
    private static bool IsWhitespace(ITreeNode node);
    private static bool IsNewLine(ITreeNode node);
    [CompilerGeneratedAttribute]
internal static ITreeNode <ExtendRangeSelection>g__TryGetClassKeyword|5_0(<>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static ITreeNode <ExtendRangeSelection>g__TryGetExtendsList|5_1(<>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static ISelectedRange <CreateInterpolatedStringInsertSelection>g__GetInsertSelectionRange|6_0(IInterpolatedStringInsert insert, <>c__DisplayClass6_0& );
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpTokenPartSelection : TokenPartSelection`1<ICSharpFile> {
    public ISelectedRange Parent { get; }
    public CSharpTokenPartSelection(ICSharpFile fileNode, TreeTextRange treeTextRange, ITokenNode token);
    public virtual ISelectedRange get_Parent();
    private ISelectedRange FindInterpolationInsertRange(TokenNodeType tokenType);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpTreeNodeSelection : TreeNodeSelection`1<ICSharpFile> {
    private static NodeTypeSet NotExtendableTokens;
    public ISelectedRange Parent { get; }
    public ExtendToTheWholeLinePolicy ExtendToWholeLine { get; }
    public CSharpTreeNodeSelection(ICSharpFile fileNode, ITreeNode node);
    private static CSharpTreeNodeSelection();
    public virtual ISelectedRange get_Parent();
    public static ISelectedRange GetParentRange(ICSharpFile fileNode, ITreeNode node);
    public virtual ExtendToTheWholeLinePolicy get_ExtendToWholeLine();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.SelectEmbracingConstruct.CSharpTreeRangeSelection : TreeRangeSelection`1<ICSharpFile> {
    private Nullable`1<ExtendToTheWholeLinePolicy> myOverridExtendToTheWholeLinePolicy;
    public ISelectedRange Parent { get; }
    public ExtendToTheWholeLinePolicy ExtendToWholeLine { get; }
    public CSharpTreeRangeSelection(ICSharpFile fileNode, ITreeNode first, ITreeNode last, Nullable`1<ExtendToTheWholeLinePolicy> overridExtendToTheWholeLinePolicy);
    protected CSharpTreeRangeSelection(ICSharpFile fileNode, ITreeNode first, ITreeNode last, Func`2<ITreeNode, TreeOffset> firstOffsetFunc, Func`2<ITreeNode, TreeOffset> lastOffsetFunc);
    public virtual ISelectedRange get_Parent();
    public virtual ExtendToTheWholeLinePolicy get_ExtendToWholeLine();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StackTraces.CSharpStackTraceResolver : object {
    private ISolution mySolution;
    private ISymbolScope mySymbolScope;
    public CSharpStackTraceResolver(IPsiServices psiServices, ISolution solution);
    public sealed virtual IReadOnlyList`1<StackTraceCandidateResolutionBase> GetNodeResolutions(IdentifierNode node);
    private IReadOnlyList`1<StackTraceCandidateResolutionBase> ResolveRecursively(IdentifierNode identifierNode, Func`2<IClrDeclaredElement, IClrDeclaredElement> leafResolver);
    private IReadOnlyList`1<StackTraceCandidateResolutionBase> ResolveRecursively(IdentifierNode identifierNode, IClrDeclaredElement qualifierCandidate, Func`2<IClrDeclaredElement, IClrDeclaredElement> isValidLeafCandidate);
    private IReadOnlyList`1<IClrDeclaredElement> FilterCandidates(IReadOnlyList`1<IClrDeclaredElement> identifierResolveCandidates, IdentifierNode identifierNode, IClrDeclaredElement qualifierCandidate);
    private IReadOnlyList`1<IClrDeclaredElement> FilterMethodLikeCandidates(IReadOnlyList`1<IClrDeclaredElement> identifierResolveCandidates, IdentifierNode identifierNode, IClrDeclaredElement qualifierCandidate);
    private IReadOnlyList`1<IClrDeclaredElement> FilterCandidates(IReadOnlyList`1<IClrDeclaredElement> identifierResolveCandidates, IdentifierNode identifierNode);
    private IReadOnlyList`1<StackTraceCandidateResolutionBase> ProcessContext(IdentifierNode identifierNode, Func`2<IClrDeclaredElement, IClrDeclaredElement> leafResolver, IReadOnlyList`1<IClrDeclaredElement> identifierResolveCandidates);
    private static bool AnonymousMethodAndCurrentMethodAreEqual(IAnonymousFunctionExpression anonymousFunctionExpression, IdentifierNode node);
    private IReadOnlyList`1<IClrDeclaredElement> ResolveLambda(IdentifierNode node, IClrDeclaredElement qualifierCandidate);
    private IReadOnlyList`1<IClrDeclaredElement> ResolveSpecificForm(IClrDeclaredElement qualifierCandidate);
    private IReadOnlyList`1<IClrDeclaredElement> ResolveIterator(IdentifierNode node, IClrDeclaredElement qualifierCandidate);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<IClrDeclaredElement> GetCandidatesWithSameTypeParameters(IReadOnlyList`1<IClrDeclaredElement> candidates, IdentifierNode node);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<IClrDeclaredElement> GetCandidatesWithSameParametersList(IReadOnlyList`1<IClrDeclaredElement> candidates, IdentifierNode node);
    private static string GetTypeShortName(StackTraceNode type);
    private static string GetTypeShortName(IType type, Boolean& isTypeParameter);
    private static string GetTypeShortName(IType type);
    public sealed virtual IReadOnlyList`1<ProjectFileTextRange> GetNavigationsToCodeWithElement(IDeclaredElement element, IdentifierNode node, CompositeNode rootNode);
    private IEnumerable`1<ProjectFileTextRange> GetUsagesOfMethodInMethod(IdentifierNode node, IDeclaredElement method, PathNode pathNode);
    private static IEnumerable`1<ProjectFileTextRange> GetUsagesOfMethodInTree(ITreeNode treeElement, IdentifierNode node, DocumentManager documentManager);
    private IEnumerable`1<ProjectFileTextRange> GetUsagesOfLambdaInMethod(IdentifierNode node, IDeclaredElement method, PathNode pathNode, IdentifierNode child);
    private static void SortBySelectedLine(List`1<ProjectFileTextRange> toSort, int lineToFound);
    private static IEnumerable`1<IAnonymousFunctionExpression> FindTopLevelAnonymousFunctionExpressions(IEnumerable`1<ITreeNode> rootNodes, IdentifierNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.AppendFormattedLinePart : object {
    private IInterpolatedStringInsert myInsert;
    private IStringInterpolationHelper myStringInterpolationHelper;
    public AppendFormattedLinePart(IInterpolatedStringInsert insert, IStringInterpolationHelper stringInterpolationHelper);
    public sealed virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public sealed virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.AppendFormattedPart : object {
    private bool myNeedToUseInterpolationSyntax;
    private IStringInterpolationHelper myStringInterpolationHelper;
    private IInterpolatedStringInsert myInsert;
    public AppendFormattedPart(IInterpolatedStringInsert insert, bool needToUseInterpolationSyntax, IStringInterpolationHelper stringInterpolationHelper);
    public static AppendFormattedPart Create(IInterpolatedStringInsert insert, IStringInterpolationHelper interpolationHelper);
    private static bool NeedToUseInterpolationSyntax(IInterpolatedStringInsert insert);
    private static bool IsAppendResolvedWithInterpolatedStringHandler(IInterpolatedStringInsert insert);
    public sealed virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public sealed virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.AppendJoinPart : object {
    private IArgumentList myArgumentList;
    public AppendJoinPart(IArgumentList argumentList);
    public static IStringBuilderPart TryCreateFromStringJoin(ICSharpExpression expression);
    public sealed virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public sealed virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.AppendLinePart : object {
    [NullableContextAttribute("1")]
public static IStringBuilderPart TryCreateFromEnvironmentNewLine(ICSharpExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public sealed virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.AppendLineWithContentPart : object {
    private ICSharpExpression myExpression;
    public AppendLineWithContentPart(ICSharpExpression expression);
    public sealed virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public sealed virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.AppendPart : object {
    private ICSharpExpression myExpression;
    public AppendPart(ICSharpExpression expression);
    public sealed virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public sealed virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.AppendSubstringPart : object {
    private ICSharpExpression myStringExpression;
    private ICSharpExpression myStartIndexExpression;
    [NullableAttribute("2")]
private ICSharpExpression myLengthExpression;
    public AppendSubstringPart(ICSharpExpression stringExpression, ICSharpExpression startIndexExpression, ICSharpExpression lengthExpression);
    public static IStringBuilderPart TryCreateFromSubstringInvocation(ICSharpExpression expression);
    public sealed virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public sealed virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.AppendWithArgumentsPart : object {
    private IArgumentList myArgumentList;
    public AppendWithArgumentsPart(IArgumentList argumentList);
    public static IStringBuilderPart TryCreateFromStringConstructor(ICSharpExpression expression);
    public sealed virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public sealed virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.InterpolatedStringInsertUtil : object {
    public static bool CanUseFormatSyntax(IInterpolatedStringInsert insert);
    public static ICSharpExpression CreateInterpolationExpression(IStringInterpolationHelper stringInterpolationHelper, IInterpolatedStringInsert interpolatedStringInsert);
    public static ICSharpExpression CreateFormatStringExpression(IStringInterpolationHelper stringInterpolationHelper, IInterpolatedStringInsert interpolatedStringInsert);
    private static IStringInterpolationBuilder CreateInitializedInterpolationBuilder(IStringInterpolationHelper stringInterpolationHelper, IInterpolatedStringInsert insertForVerbatimityProbing);
    [CompilerGeneratedAttribute]
internal static string <CreateFormatStringExpression>g__GetAlignment|2_0(<>c__DisplayClass2_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.InvocationTransformUtil : object {
    public static IArgumentList TryTransformInvocationArgumentsToMatchingOverload(IArgumentList argumentList, IMethod originalMethod, IEnumerable`1<IMethod> candidateMethods);
    public static IArgumentList TryTransformInvocationArgumentsToMatchingOverloadIgnoringGenerics(IArgumentList argumentList, IParametersOwner originalParametersOwner, IEnumerable`1<IMethod> candidates);
    private static IMethod FindMethodWithMatchingParametersList(IMethod originalMethod, IEnumerable`1<IMethod> candidateMethods, PredefinedType predefinedType, ICSharpTypeConversionRule conversionRule);
    private static IParametersOwner FindParametersOwnerWithMatchingParametersList(IParametersOwner originalParametersOwner, IEnumerable`1<IParametersOwner> candidates, ICSharpTypeConversionRule conversionRule);
    private static IArgumentList TransformInvocationArguments(IArgumentList argumentList, IParametersOwner target);
    private static bool AreParametersCompatible(IList`1<IParameter> originalParameters, IList`1<IParameter> candidateParameters, ISubstitution substitution, ICSharpTypeConversionRule conversionRule);
    [CompilerGeneratedAttribute]
internal static bool <AreParametersCompatible>g__IsMatchingParameter|5_0(IParameter originalParameter, IParameter candidateParameter, <>c__DisplayClass5_0& );
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.IStringBuilderPart {
    [PureAttribute]
public abstract virtual IStringBuilderPart TryMergeWithNext(IStringBuilderPart nextPart);
    public abstract virtual void AppendExpressionPartToBuilder(FactoryArgumentsBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.StringBuilderPartFactory : object {
    public static IStringBuilderPart TryCreateFromInterpolationNode(ITreeNode node);
    public static IStringBuilderPart CreateFromExpression(ICSharpExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringBuilderRewriting.StringBuilderStructure : object {
    private List`1<IStringBuilderPart> myParts;
    public void Append(IStringBuilderPart part);
    public void ApplyTo(FactoryArgumentsBuilder builder, bool mergeParts);
    public void FillFromExpression(ICSharpExpression expression);
    private void FillFromInterpolatedStringExpression(IInterpolatedStringExpression interpolatedExpression);
    private void FillFromConcatenation(IAdditiveExpression concatenation);
    [NullableContextAttribute("2")]
public static ICSharpExpression GetAllowedContainingAdditiveExpression(ICSharpExpression expression);
    private static bool IsStringConcatenation(IAdditiveExpression additiveExpression);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetAllowedContainingAdditiveExpression>g__MatchingExpression|6_0(ICSharpExpression candidate, <>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.SliceableStringExpressionToken : ValueType {
    private ICSharpLiteralWrapper myWrapper;
    public ITokenNode Node;
    public TreeTextRange ValueRange;
    public string CompiledValueString;
    private SliceableStringExpressionToken(ITokenNode tokenNode, ICSharpLiteralWrapper wrapper, TreeTextRange valueRange);
    [PureAttribute]
public static Nullable`1<SliceableStringExpressionToken> TryCreate(ITokenNode tokenNode);
    [PureAttribute]
public static Nullable`1<SliceableStringExpressionToken> TryCreate(IStringLiteralOwner literalOwner, TreeOffset offset);
    [PureAttribute]
public static SliceableStringExpressionToken Create(ITokenNode tokenNode);
    [NullableContextAttribute("0")]
[PureAttribute]
public StringExpressionTokenSlice`1<T> AsSlice();
    [PureAttribute]
public bool IsValueRangeValid(TreeTextRange treeRange);
    [PureAttribute]
public bool IsValueOffsetValid(TreeOffset offset);
    [PureAttribute]
private static TreeTextRange GetValueRange(ITokenNode token, CSharpLiteralType literalType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.StringComputationUtil : object {
    public static ICSharpExpression TryCreateConstantStringExpression(ICSharpExpression expression, bool interpolationIsRequired);
    private static bool TryFillBuilder(ICSharpExpression expression, IStringInterpolationBuilder builder);
    private static StringVerbatimity GetMaximumVerbatimity(ICSharpExpression expression);
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.StringCuttingStylePreference : Enum {
    public int value__;
    public static StringCuttingStylePreference Auto;
    public static StringCuttingStylePreference PreferInterpolation;
    public static StringCuttingStylePreference ForceConcatenation;
    public static StringCuttingStylePreference ForceInterpolation;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.StringExpressionSlice`1 : ValueType {
    public TreeTextRange TreeRange;
    public T LiteralOwner;
    private StringExpressionSlice`1(T literalOwner, TreeTextRange treeRange);
    [PureAttribute]
public static StringExpressionSlice`1<T> Create(T literalOwner, TreeTextRange treeRange);
    [PureAttribute]
public static StringExpressionSlice`1<T> Create(T literalOwner);
    [PureAttribute]
public static Nullable`1<StringExpressionSlice`1<T>> TryCreate(T literalOwner, TreeTextRange treeRange);
    [PureAttribute]
public T CreateExpression(IStringInterpolationHelper interpolationHelper, bool keepRedundantDollarSign);
    [PureAttribute]
public ValueTuple`2<IStringLiteralOwner, IStringLiteralOwner> SplitAt(TreeOffset offset, bool keepRedundantDollarSigns);
    [PureAttribute]
public Nullable`1<ValueTuple`2<IStringLiteralOwner, IStringLiteralOwner>> TrySplitAt(TreeOffset offset, bool keepRedundantDollarSigns);
    [CompilerGeneratedAttribute]
internal static bool <TryCreate>g__CanSliceAt|5_0(ITreeNode node, TreeOffset offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.StringExpressionSliceExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static StringExpressionTokenSlice`1<ICSharpLiteralExpression> AsTokenSlice(StringExpressionSlice`1<ICSharpLiteralExpression> slice);
    [ExtensionAttribute]
[PureAttribute]
public static StringExpressionSlice`1<IStringLiteralOwner> AsStringExpressionSlice(IStringLiteralOwner literalOwner);
    [ExtensionAttribute]
[PureAttribute]
public static StringExpressionSlice`1<ICSharpLiteralExpression> AsStringExpressionSlice(ICSharpLiteralExpression literalExpression);
    [ExtensionAttribute]
[PureAttribute]
public static StringExpressionSlice`1<IInterpolatedStringExpression> AsStringExpressionSlice(IInterpolatedStringExpression interpolatedString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.StringExpressionTokenSlice`1 : ValueType {
    public SliceableStringExpressionToken Token;
    public TreeTextRange TreeRange;
    public T LiteralOwner;
    private StringExpressionTokenSlice`1(SliceableStringExpressionToken token, TreeTextRange treeRange, T literalOwner);
    [PureAttribute]
public static Nullable`1<StringExpressionTokenSlice`1<T>> TryCreate(T literalOwner, TreeTextRange treeRange);
    [PureAttribute]
public static Nullable`1<StringExpressionTokenSlice`1<T>> TryCreate(SliceableStringExpressionToken sliceableToken, TreeTextRange treeRange);
    [PureAttribute]
public static StringExpressionTokenSlice`1<T> Create(T literalOwner, TreeTextRange treeRange);
    [PureAttribute]
public static StringExpressionTokenSlice`1<T> Create(SliceableStringExpressionToken sliceableToken, TreeTextRange treeRange);
    [PureAttribute]
public IStringLiteralOwner CreateExpression(bool keepRedundantDollarSign);
    [PureAttribute]
public IStringLiteralOwner CreateExpression(IStringInterpolationHelper interpolationHelper, bool keepRedundantDollarSign);
    public IStringLiteralOwner Cut(StringCuttingStylePreference cuttingStylePreference, bool keepEmptySubstrings, bool keepRedundantDollarSign);
    private IStringLiteralOwner CutUsingConcatenation(IStringInterpolationHelper interpolationHelper, bool keepEmptySubstrings, bool keepRedundantDollarSign);
    private IStringLiteralOwner CutUsingInterpolationHole(IStringInterpolationHelper interpolationHelper, bool keepRedundantDollarSign);
    [PureAttribute]
public Nullable`1<StringExpressionTokenSlice`1<ICSharpLiteralExpression>> AsLiteralExpressionTokenSlice();
    [PureAttribute]
public Nullable`1<StringExpressionTokenSlice`1<IInterpolatedStringExpression>> AsInterpolatedStringTokenSlice();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <CutUsingConcatenation>g__ShouldAdd|11_0(IStringLiteralOwner substring, <>c__DisplayClass11_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static IStringLiteralOwner <CutUsingConcatenation>g__Substring|11_1(TreeTextRange range, <>c__DisplayClass11_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.StringExpressionTokenSliceExtensions : object {
    [ExtensionAttribute]
public static ICSharpLiteralExpression ReplaceText(StringExpressionTokenSlice`1<ICSharpLiteralExpression> slice, string newText);
    [ExtensionAttribute]
public static ICSharpLiteralExpression FindReplace(StringExpressionTokenSlice`1<ICSharpLiteralExpression> slice, string oldValue, string newValue);
    [ExtensionAttribute]
[PureAttribute]
public static TextRange GetValueRange(StringExpressionTokenSlice`1<ICSharpLiteralExpression> slice);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.StringManipulationInternalUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static IStringInterpolationBuilder CreateBuilderFrom(IStringInterpolationHelper interpolationHelper, IStringLiteralOwner literalOwner);
    public static void AppendInterpolatedStringInsert(IStringInterpolationBuilder builder, IInterpolatedStringInsert insert);
    public static ICSharpExpression[] InsertConcatenationOperands(Polyadic`1<ICSharpExpression> polyadic, int startIndex, ICSharpExpression[] operands);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.StringManipulation.StringVerbatimityConversionUtil : object {
    [ExtensionAttribute]
public static void ChangeVerbatimity(IStringLiteralOwner stringLiteralOwner, StringVerbatimity verbatimity);
    [ExtensionAttribute]
public static void ChangeVerbatimity(ICSharpLiteralExpression expression, StringVerbatimity verbatimity);
    [ExtensionAttribute]
public static IInterpolatedStringExpression CreateStringWithVerbatimity(IInterpolatedStringExpression expression, StringVerbatimity verbatimity);
    [ExtensionAttribute]
public static void ChangeVerbatimity(IInterpolatedStringExpression expression, StringVerbatimity verbatimity);
    private static void ConvertRegularToVerbatimOrViceVersa(IInterpolatedStringExpression interpolatedString);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.CSharpBackwardStructuralNavigationVisitor : CSharpStructuralNavigationVisitorBase {
    public virtual void VisitNode(ITreeNode node, StructuralNavigationContextBase context);
    [ObsoleteAttribute]
public virtual void VisitCSharpStatement(ICSharpStatement statement, StructuralNavigationContextBase context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.CSharpStringLiteralStructuralNavigationItem : StructuralNavigationTreeNode`1<ITokenNode> {
    private TokenNodeType myLiteralTokenType;
    public CSharpStringLiteralStructuralNavigationItem(ITokenNode tokenNode);
    public virtual DocumentRange GetDocumentRange();
    public virtual ITreeRange TryGetTreeRange();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.CSharpStructuralNavigationDisabler : object {
    public sealed virtual bool IsForwardDisabled(ITreeNode treeNode, DocumentRange selectedRange, bool isSelectedByFallbackAction);
    public sealed virtual bool IsBackwardDisabled(ITreeNode treeNode, DocumentRange selectedRange, bool isSelectedByFallbackAction);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.CSharpStructuralNavigationManager : object {
    public sealed virtual IStructuralNavigationItem MoveToNext(StructuralNavigationContextBase context);
    public sealed virtual IStructuralNavigationItem MoveToPrev(StructuralNavigationContextBase context);
    [CanBeNullAttribute]
private static IStructuralNavigationItem GetNextSelection(CSharpStructuralNavigationVisitorBase visitor, StructuralNavigationContextBase context);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.CSharpStructuralNavigationStringTokenDisabler : CLikeLanguageStructuralNavigationStringTokenDisablerBase {
    protected virtual bool IsStringLiteralToken(TokenNodeType tokenNodeType);
    protected virtual bool IsEndOfLineComment(TokenNodeType tokenNodeType);
    protected virtual bool IsBlockComment(TokenNodeType tokenNodeType);
    protected virtual string GetStringLiteralStartBorder(TokenNodeType tokenNodeType, CachingLexer lexer);
    protected virtual string GetStringLiteralEndBorder(TokenNodeType tokenNodeType, CachingLexer lexer);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.CSharpStructuralNavigationVisitor : CSharpStructuralNavigationVisitorBase {
    public virtual void VisitNode(ITreeNode node, StructuralNavigationContextBase context);
    [ObsoleteAttribute]
public virtual void VisitCSharpStatement(ICSharpStatement statement, StructuralNavigationContextBase context);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.CSharpStructuralNavigationVisitorBase : TreeNodeVisitor`1<StructuralNavigationContextBase> {
    private static NodeTypeSet ourNonNavigateableKeywords;
    private static NodeTypeSet ourNavigateablePreprocessorTokens;
    private static NodeTypeSet ourNavigateableCompoundAssignmentTokens;
    private static NodeTypeSet ourSelectableStringTokens;
    private static CSharpStructuralNavigationVisitorBase();
    public void AcceptNode(ITreeNode treeNode, StructuralNavigationContextBase context);
    public virtual void VisitNode(ITreeNode node, StructuralNavigationContextBase context);
    private static void HandlePreprocessorToken(StructuralNavigationContextBase context, ITokenNode tokenNode, TokenNodeType tokenType);
    private static void HandleCommentNode(ICSharpCommentNode commentNode, StructuralNavigationContextBase context);
    [CanBeNullAttribute]
private static IStructuralNavigationItem GetAdjacentLineComments(ICSharpCommentNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.CSharpStructuralNavigationVisitorBase/<GetSiblings>d__9`1")]
private static IEnumerable`1<TNode> GetSiblings(int indentingLength, IEnumerable`1<ITreeNode> siblings);
    private static int GetIndentingLength(ITreeNode node);
    protected void TryAddInvocationRange(StructuralNavigationContextBase context, ICSharpIdentifier nameIdentifier);
    private void HandleIdentifier(StructuralNavigationContextBase context, ITokenNode tokenNode);
    private void HandleStringLiteral(StructuralNavigationContextBase context, ITokenNode tokenNode, TokenNodeType tokenType);
    private void HandleForStatement(StructuralNavigationContextBase context, IForStatement forStatement, ITokenNode tokenNode);
    public virtual void VisitPreprocessorConditionalSymbol(IPreprocessorConditionalSymbol preprocessorConditionalSymbolParam, StructuralNavigationContextBase context);
    public virtual void VisitInactivePreprocessorBranchNode(IInactivePreprocessorBranch inactivePreprocessorBranchNode, StructuralNavigationContextBase context);
    public virtual void VisitPreprocessorNegation(IPreprocessorNegation preprocessorNegationParam, StructuralNavigationContextBase context);
    public virtual void VisitPreprocessorDirective(IPreprocessorDirective preprocessorDirectiveParam, StructuralNavigationContextBase context);
    public virtual void VisitDefineDirective(IDefineDirective defineDirectiveParam, StructuralNavigationContextBase context);
    public virtual void VisitStartRegion(IStartRegion startRegionParam, StructuralNavigationContextBase context);
    public virtual void VisitEndRegion(IEndRegion endRegionParam, StructuralNavigationContextBase context);
    public virtual void VisitIfDirective(IIfDirective ifDirectiveParam, StructuralNavigationContextBase context);
    public virtual void VisitElifDirective(IElifDirective elifDirectiveParam, StructuralNavigationContextBase context);
    public virtual void VisitPragmaDirective(IPragmaDirective pragmaDirectiveParam, StructuralNavigationContextBase context);
    public virtual void VisitUndefDirective(IUndefDirective undefDirectiveParam, StructuralNavigationContextBase context);
    public virtual void VisitWarningDirective(IWarningDirective warningDirectiveParam, StructuralNavigationContextBase context);
    public virtual void VisitErrorDirective(IErrorDirective errorDirectiveParam, StructuralNavigationContextBase context);
    private static void TryAddPreprocessorWithToken(StructuralNavigationContextBase context, TNode directive, TTokenType token, bool trimLeadingSpace);
    public virtual void VisitWhileStatement(IWhileStatement whileStatementParam, StructuralNavigationContextBase context);
    public virtual void VisitIfStatement(IIfStatement ifStatementParam, StructuralNavigationContextBase context);
    public virtual void VisitForStatement(IForStatement forStatementParam, StructuralNavigationContextBase context);
    public virtual void VisitBlock(IBlock blockParam, StructuralNavigationContextBase context);
    public virtual void VisitUsingStatement(IUsingStatement usingStatementParam, StructuralNavigationContextBase context);
    public virtual void VisitSwitchCaseLabel(ISwitchCaseLabel switchCaseLabelParam, StructuralNavigationContextBase context);
    [CanBeNullAttribute]
protected static IStructuralNavigationItem GetElseWithBlockItem(ICSharpStatement statement);
    [CanBeNullAttribute]
private static IStructuralNavigationItem GetAllBlockStatementsItem(IBlock blockParam);
    [CanBeNullAttribute]
private static IStructuralNavigationItem GetFinallyWithBlockItem(IBlock blockParam);
    public virtual void VisitSwitchExpressionArm(ISwitchExpressionArm switchExpressionArm, StructuralNavigationContextBase context);
    public virtual void VisitThisExpression(IThisExpression thisExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitBaseExpression(IBaseExpression baseExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitCSharpLiteralExpression(ICSharpLiteralExpression cSharpLiteralExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitPredefinedTypeExpression(IPredefinedTypeExpression predefinedTypeExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeofExpression(ITypeofExpression typeofExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitQueryExpression(IQueryExpression queryExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitUnaryOperatorExpression(IUnaryOperatorExpression unaryOperatorExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitAssignmentExpression(IAssignmentExpression assignmentExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitAsExpression(IAsExpression asExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitIsExpression(IIsExpression isExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitDefaultExpression(IDefaultExpression defaultExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitLambdaExpression(ILambdaExpression lambdaExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitAwaitExpression(IAwaitExpression awaitExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitIndexFromEndExpression(IIndexFromEndExpression indexFromEndExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreationExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitUnsafeCodeFixedPointerInitializer(IUnsafeCodeFixedPointerInitializer unsafeCodeFixedPointerInitializerParam, StructuralNavigationContextBase context);
    public virtual void VisitUnsafeCodeAddressOfExpression(IUnsafeCodeAddressOfExpression unsafeCodeAddressOfExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitPrefixOperatorExpression(IPrefixOperatorExpression prefixOperatorExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitPostfixOperatorExpression(IPostfixOperatorExpression postfixOperatorExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitConditionalTernaryExpression(IConditionalTernaryExpression conditionalTernaryExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitAnonymousMemberDeclaration(IAnonymousMemberDeclaration anonymousMemberDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitTupleExpression(ITupleExpression tupleExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitThrowExpression(IThrowExpression throwExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitRefExpression(IRefExpression refExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitDeclarationExpression(IDeclarationExpression declarationExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitWithExpression(IWithExpression withExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitSwitchExpression(ISwitchExpression switchExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitAdditiveExpression(IAdditiveExpression additiveExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitMultiplicativeExpression(IMultiplicativeExpression multiplicativeExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitRelationalExpression(IRelationalExpression relationalExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitNullCoalescingExpression(INullCoalescingExpression nullCoalescingExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitEqualityExpression(IEqualityExpression equalityExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitShiftExpression(IShiftExpression shiftExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitConditionalOrExpression(IConditionalOrExpression conditionalOrExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitConditionalAndExpression(IConditionalAndExpression conditionalAndExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitBitwiseExclusiveOrExpression(IBitwiseExclusiveOrExpression bitwiseExclusiveOrExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitBitwiseInclusiveOrExpression(IBitwiseInclusiveOrExpression bitwiseInclusiveOrExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitBitwiseAndExpression(IBitwiseAndExpression bitwiseAndExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitRangeExpression(IRangeExpression rangeExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitReferenceExpression(IReferenceExpression referenceExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitInvocationExpression(IInvocationExpression invocationExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitElementAccessExpression(IElementAccessExpression elementAccessExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpression, StructuralNavigationContextBase context);
    public virtual void VisitCastExpression(ICastExpression castExpression, StructuralNavigationContextBase context);
    public virtual void VisitWithInitializerAssignment(IWithInitializerAssignment withInitializerAssignmentParam, StructuralNavigationContextBase context);
    public virtual void VisitPattern(IPattern pattern, StructuralNavigationContextBase context);
    public virtual void VisitAndPattern(IAndPattern andPattern, StructuralNavigationContextBase context);
    public virtual void VisitOrPattern(IOrPattern orPattern, StructuralNavigationContextBase context);
    [CanBeNullAttribute]
private static TBinaryPattern GetSimilarBinaryPatternParent(TBinaryPattern binaryPattern);
    public virtual void VisitSubpattern(ISubpattern subpatternParam, StructuralNavigationContextBase context);
    public virtual void VisitPatternGuardClause(IPatternGuardClause patternGuardClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitSwitchSection(ISwitchSection switchSectionParam, StructuralNavigationContextBase context);
    public virtual void VisitMultipleEventDeclaration(IMultipleEventDeclaration multipleEventDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitLocalFunctionDeclaration(ILocalFunctionDeclaration localFunctionDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitCSharpNamespaceDeclaration(ICSharpNamespaceDeclaration cSharpNamespaceDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitDocCommentBlockNode(IDocCommentBlock xmlDoc, StructuralNavigationContextBase context);
    public virtual void VisitQueryFirstFrom(IQueryFirstFrom queryFirstFromParam, StructuralNavigationContextBase context);
    public virtual void VisitQueryOrdering(IQueryOrdering queryOrderingParam, StructuralNavigationContextBase context);
    public virtual void VisitQueryClause(IQueryClause queryClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitRankSpecifier(IRankSpecifier rankSpecifierParam, StructuralNavigationContextBase context);
    public virtual void VisitLabelDeclaration(ILabelDeclaration labelDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitObjectInitializer(IObjectInitializer objectInitializerParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeArgumentList(ITypeArgumentList typeArgumentListParam, StructuralNavigationContextBase context);
    public virtual void VisitCatchClause(ICatchClause catchClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitExceptionFilterClause(IExceptionFilterClause exceptionFilterClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitArrayInitializer(IArrayInitializer arrayInitializerParam, StructuralNavigationContextBase context);
    public virtual void VisitUsingDirective(IUsingDirective usingDirectiveParam, StructuralNavigationContextBase context);
    public virtual void VisitAttributeSection(IAttributeSection attributeSectionParam, StructuralNavigationContextBase context);
    public virtual void VisitFormalParameterList(IFormalParameterList formalParameterListParam, StructuralNavigationContextBase context);
    public virtual void VisitLocalFormalParameterList(ILocalFormalParameterList localFunctionFormalParameterListParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeParameterOfLocalFunctionDeclaration(ITypeParameterOfLocalFunctionDeclaration typeParameterOfLocalFunctionDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeParameterConstraintsClause(ITypeParameterConstraintsClause typeParameterConstraintsClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitConstructorConstraint(IConstructorConstraint constructorConstraintParam, StructuralNavigationContextBase context);
    public virtual void VisitMultipleFieldDeclaration(IMultipleFieldDeclaration multipleFieldDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitFieldDeclaration(IFieldDeclaration fieldDeclaration, StructuralNavigationContextBase context);
    public virtual void VisitMultipleConstantDeclaration(IMultipleConstantDeclaration multipleConstantDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitConstantDeclaration(IConstantDeclaration constantDeclaration, StructuralNavigationContextBase context);
    public virtual void VisitMultipleLocalVariableDeclaration(IMultipleLocalVariableDeclaration multipleLocalVariableDeclaration, StructuralNavigationContextBase context);
    public virtual void VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclaration, StructuralNavigationContextBase context);
    public virtual void VisitMultipleLocalConstantDeclaration(IMultipleLocalConstantDeclaration multipleLocalConstantDeclaration, StructuralNavigationContextBase context);
    public virtual void VisitLocalConstantDeclaration(ILocalConstantDeclaration localConstantDeclaration, StructuralNavigationContextBase context);
    public virtual void VisitMethodDeclaration(IMethodDeclaration methodDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitOperatorDeclaration(IOperatorDeclaration operatorDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitClassDeclaration(IClassDeclaration classDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitRecordDeclaration(IRecordDeclaration recordDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitStructDeclaration(IStructDeclaration structDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitConstructorDeclaration(IConstructorDeclaration constructorDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitConstructorInitializer(IConstructorInitializer constructorInitializer, StructuralNavigationContextBase context);
    public virtual void VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitIndexerDeclaration(IIndexerDeclaration indexerDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitAccessorDeclaration(IAccessorDeclaration accessorDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitAttribute(IAttribute attributeParam, StructuralNavigationContextBase context);
    [ObsoleteAttribute]
public virtual void VisitTypeParameterDeclaration(ITypeParameterDeclaration typeParameterDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitTupleComponent(ITupleComponent tupleComponentParam, StructuralNavigationContextBase context);
    public virtual void VisitTupleTypeComponent(ITupleTypeComponent tupleTypeComponentParam, StructuralNavigationContextBase context);
    public virtual void VisitParenthesizedVariableDesignation(IParenthesizedVariableDesignation parenthesizedVariableDesignationParam, StructuralNavigationContextBase context);
    public virtual void VisitSingleVariableDesignation(ISingleVariableDesignation singleVariableDesignationParam, StructuralNavigationContextBase context);
    public virtual void VisitNullableTypeMark(INullableTypeMark nullableTypeMarkParam, StructuralNavigationContextBase context);
    [ObsoleteAttribute]
public virtual void VisitCSharpStatement(ICSharpStatement cSharpStatementParam, StructuralNavigationContextBase context);
    public virtual void VisitCSharpArgument(ICSharpArgument cSharpArgumentParam, StructuralNavigationContextBase context);
    public virtual void VisitPropertyPatternClause(IPropertyPatternClause propertyPatternClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitDeconstructionPatternClause(IDeconstructionPatternClause deconstructionPatternClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeParameterOfMethodList(ITypeParameterOfMethodList typeParameterOfMethodListParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeParameterOfLocalFunctionList(ITypeParameterOfLocalFunctionList typeParameterOfLocalFunctionListParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeParameterOfTypeList(ITypeParameterOfTypeList typeParameterOfTypeListParam, StructuralNavigationContextBase context);
    public virtual void VisitNamespaceBody(INamespaceBody namespaceBodyParam, StructuralNavigationContextBase context);
    public virtual void VisitClassBody(IClassBody classBodyParam, StructuralNavigationContextBase context);
    public virtual void VisitEnumBody(IEnumBody enumBodyParam, StructuralNavigationContextBase context);
    public virtual void VisitQueryGroupClause(IQueryGroupClause queryGroupClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeUsage(ITypeUsage typeUsageParam, StructuralNavigationContextBase context);
    public virtual void VisitArgumentList(IArgumentList argumentListParam, StructuralNavigationContextBase context);
    public virtual void VisitLambdaSignature(ILambdaSignature lambdaSignatureParam, StructuralNavigationContextBase context);
    public virtual void VisitAnonymousMethodExpression(IAnonymousMethodExpression anonymousMethodExpression, StructuralNavigationContextBase context);
    public virtual void VisitCollectionInitializer(ICollectionInitializer collectionInitializerParam, StructuralNavigationContextBase context);
    public virtual void VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam, StructuralNavigationContextBase context);
    public virtual void VisitEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitTypeMemberRegularParameterDeclaration(ITypeMemberRegularParameterDeclaration regularParameterDeclarationParam, StructuralNavigationContextBase context);
    public virtual void VisitLocalRegularParameterDeclaration(ILocalRegularParameterDeclaration localRegularParameterDeclaration, StructuralNavigationContextBase context);
    public virtual void VisitPropertyAssignment(IPropertyAssignment propertyAssignmentParam, StructuralNavigationContextBase context);
    public virtual void VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam, StructuralNavigationContextBase context);
    public virtual void VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam, StructuralNavigationContextBase context);
    public virtual void VisitCollectionExpression(ICollectionExpression collectionExpressionParam, StructuralNavigationContextBase context);
    public virtual void VisitCollectionExpressionElement(ICollectionExpressionElement collectionExpressionElementParam, StructuralNavigationContextBase context);
    public virtual void VisitExpressionInitializer(IExpressionInitializer expressionInitializerParam, StructuralNavigationContextBase context);
    public virtual void VisitArrowExpressionClause(IArrowExpressionClause arrowExpressionClauseParam, StructuralNavigationContextBase context);
    public virtual void VisitOwnerQualification(IOwnerQualification ownerQualificationParam, StructuralNavigationContextBase context);
    private static void VisitAnonymousFunctionSignature(TSignatureNode signatureNode, ITokenNode lPar, ITokenNode rPar, TreeNodeCollection`1<TParameterDeclaration> parameterDeclarations, StructuralNavigationContextBase context);
    public virtual void VisitExtendedType(IExtendedType extendedTypeParam, StructuralNavigationContextBase context);
    private static void TryAddResult(StructuralNavigationContextBase context, TNode treeNode);
    private static void TryAddNodeWithCollectionContent(StructuralNavigationContextBase context, TNode node, TreeNodeCollection`1<TChild> children);
    private void TryAddWithEmptyPosition(StructuralNavigationContextBase context, TNode node, ITreeNode condition, ITreeNode lPar);
    [CanBeNullAttribute]
private static TNode GetSimilarBinaryExpressionParent(TNode binaryExpression);
    protected static void HandleTypeParameterList(StructuralNavigationContextBase context, ICSharpIdentifier nameIdentifier);
    private static void TryAddBodyContentRange(ITokenNode lBrace, ITokenNode rBrace, StructuralNavigationContextBase context);
    private static bool IsStatementMainNode(ITreeNode treeNode);
    private static void AddTypeParameterList(TTypeParameterList typeParameterOfTypeListParam, TreeNodeCollection`1<TTypeParameterElement> typeParameterOfTypeDeclarations, StructuralNavigationContextBase context);
    [CanBeNullAttribute]
private static StructuralNavigationTreeRange GetAdjacentStatements(ICSharpStatement cSharpStatementParam);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralNavigation.ZoneMarker : object {
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralRemove.CSharpStructuralRemoveProvider : object {
    public sealed virtual StructuralRemoveRanges TryCreate(ITreeRange treeRange);
    [NotNullAttribute]
private static ITreeNode CoerceToMostContainingWrapperNode(ITreeNode treeNode);
    private static StructuralRemoveRanges TryCreateFromSingleNode(ITreeNode treeNode);
    [PureAttribute]
private static StructuralRemoveRanges FromWhitespaceFromRightNoNewline(ITreeNode node);
    [PureAttribute]
private static StructuralRemoveRanges FromWhitespaceFromLeftIncludeNewline(ITreeNode node);
    private static StructuralRemoveRanges TryCreateFromAttributeSection(IAttributeSection attributeSection);
    private static StructuralRemoveRanges TryCreateFromTypeUsage(ITypeUsage typeUsage);
    private static StructuralRemoveRanges TryCreateFromReferenceName(IReferenceName referenceName);
    private static StructuralRemoveRanges TryCreateFromReferenceNamePart(IReferenceName referenceName);
    private static StructuralRemoveRanges TryCreateFromReferenceExpressionPart(IReferenceExpression referenceExpression, ICSharpExpression containingExpression);
    private static StructuralRemoveRanges TryCreateFromInitializer(IVariableInitializer variableInitializer);
    private static StructuralRemoveRanges TryCreateFromExpression(ICSharpExpression expression);
    private static StructuralRemoveRanges TryCreateFromPattern(IPattern pattern);
    [PureAttribute]
private static StructuralRemoveRanges FromSignOnTheLeftSide(ITreeNode node, TokenNodeType signTokenType);
    [PureAttribute]
private static bool HasErrorSiblingsAround(ITreeNode node);
    [PureAttribute]
private static StructuralRemoveRanges FromSeparatedSiblings(ITreeNode node, TokenNodeType separatorTokenType);
    [CanBeNullAttribute]
[PureAttribute]
private static ITreeNode FindNextSiblingSeparatedByWhitespace(ITreeNode anchor);
    [CanBeNullAttribute]
[PureAttribute]
private static ITreeNode FindPrevSiblingSeparatedByWhitespace(ITreeNode anchor);
    [CanBeNullAttribute]
[PureAttribute]
private static ITokenNode FindNextSeparatorSibling(ITreeNode anchor, TokenNodeType separatorTokenType);
    [CanBeNullAttribute]
[PureAttribute]
private static ITokenNode FindPrevSeparatorSibling(ITreeNode anchor, TokenNodeType separatorTokenType);
    [PureAttribute]
private static DocumentOffset GetEndOffsetWithWhitespaceIncluded(ITreeNode node);
    [PureAttribute]
private static DocumentOffset GetStartOffsetWithWhitespaceIncluded(ITreeNode node);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralRemove.ZoneMarker : object {
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.ArrayTypeMatcher`1 : object {
    [NotNullAttribute]
private Func`2<TTreeNode, IType> myGetElementType;
    [NotNullAttribute]
private ITypeMatcher myElementTypeMatcher;
    private int myRank;
    public string ShortName { get; }
    private ArrayTypeMatcher`1(ITypeMatcher elementTypeMatcher, int rank, Func`2<TTreeNode, IType> getElementType);
    [NotNullAttribute]
public static ITypeMatcher Build(IArrayTypeUsage typeUsageNode, Func`2<TTreeNode, IType> getElementType, PatternMatcherBuilderParams params);
    public sealed virtual bool MatchType(ITreeNode element, IMatchingContext context);
    public sealed virtual bool MatchType(ITreeNode element, IType elementType, IMatchingContext context);
    public sealed virtual string get_ShortName();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpClassStructuralMatcher : CSharpStructuralMatcherBase {
    public CSharpClassStructuralMatcher(IElementMatcher matcher, StructuralSearchPatternParams patternParams);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpCommentPatternLexer : PatternLexer {
    protected LanguageService LanguageService { get; }
    protected bool MetaPlaceholderSupported { get; }
    protected virtual LanguageService get_LanguageService();
    protected virtual bool get_MetaPlaceholderSupported();
    protected virtual IMetaPlaceholder GetMetaPlaceholder(string name);
    public ReplacePatternLexerResult ParsePattern(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpDeclaredTypeMatcher`1 : TypeMatcherBase`1<TTreeNode> {
    [CanBeNullAttribute]
private Func`2<TTreeNode, ITypeUsage> myDeclaredTypeUsage;
    [CanBeNullAttribute]
private ITypeMatcher myDeclaredTypeMatcher;
    [CanBeNullAttribute]
private string myTypeName;
    protected string TypeName { get; }
    public CSharpDeclaredTypeMatcher`1(string typeName, Func`2<TTreeNode, ITypeUsage> declaredTypeUsage, List`1<ITypeMatcher> typeArgumentMatchers, ITypeMatcher declaredTypeMatcher);
    protected virtual string get_TypeName();
    protected virtual IType GetOriginalType(ITreeNode context);
    protected virtual IType GetElementType(TTreeNode element);
    protected virtual bool MatchTypeWithPlaceholder(ITreeNode element, IType elementType, IMatchingContext context);
    public sealed virtual void RegisterContainingTypePlaceholderMatches(Action`2<string, ITreeNode> register, ITreeNode element);
    public static ITypeMatcher Build(ITypeUsage typeUsageNode, Func`2<TypePlaceholder, ITypeMatcher> getTypeMatcherFromPlaceholder, Func`4<string, List`1<ITypeMatcher>, ITypeMatcher, ITypeMatcher> createDeclaredTypeMatcher, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpElementMatcherBuilder : TreeNodeVisitor`2<PatternMatcherBuilderParams, IElementMatcher> {
    public IElementMatcher Build(ICSharpTreeNode element, PatternMatcherBuilderParams params);
    public virtual IElementMatcher VisitNode(ITreeNode param, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAttribute(IAttribute attributeParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAttributeSectionList(IAttributeSectionList attributeSectionListParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCSharpArgument(ICSharpArgument cSharpArgumentParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitConstantDeclaration(IConstantDeclaration constantDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitConstructorDeclaration(IConstructorDeclaration constructorDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDestructorDeclaration(IDestructorDeclaration destructorDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitFieldDeclaration(IFieldDeclaration fieldDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitMethodDeclaration(IMethodDeclaration methodDeclaration, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitBlock(IBlock blockParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTopLevelCode(ITopLevelCode topLevelCode, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitBreakStatement(IBreakStatement breakStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCheckedStatement(ICheckedStatement checkedStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitContinueStatement(IContinueStatement continueStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDeclarationStatement(IDeclarationStatement declarationStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDoStatement(IDoStatement doStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDeclarationExpression(IDeclarationExpression declarationExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDiscardDesignation(IDiscardDesignation discardDesignationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitParenthesizedVariableDesignation(IParenthesizedVariableDesignation parenthesizedVariableDesignationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSingleVariableDesignation(ISingleVariableDesignation singleVariableDesignationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitEmptyStatement(IEmptyStatement emptyStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitExpressionStatement(IExpressionStatement expressionStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitForStatement(IForStatement forStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitForeachStatement(IForeachStatement foreachStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitGotoCaseStatement(IGotoCaseStatement gotoCaseStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitGotoStatement(IGotoStatement gotoStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitIfStatement(IIfStatement ifStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitLabelStatement(ILabelStatement labelStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitLockStatement(ILockStatement lockStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitReturnStatement(IReturnStatement returnStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSwitchCaseLabel(ISwitchCaseLabel switchCaseLabelParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitPatternGuardClause(IPatternGuardClause patternGuardClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSwitchStatement(ISwitchStatement switchStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSwitchSection(ISwitchSection switchSectionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitThrowStatement(IThrowStatement throwStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitThrowExpression(IThrowExpression throwExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitRefExpression(IRefExpression refExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTryStatement(ITryStatement tryStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUsingStatement(IUsingStatement usingStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUncheckedStatement(IUncheckedStatement uncheckedStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUnsafeCodeFixedStatement(IUnsafeCodeFixedStatement unsafeCodeFixedStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUnsafeCodeUnsafeStatement(IUnsafeCodeUnsafeStatement unsafeCodeUnsafeStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitWhileStatement(IWhileStatement whileStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitYieldStatement(IYieldStatement yieldStatementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDefaultExpression(IDefaultExpression defaultExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitElementAccessExpression(IElementAccessExpression elementAccessExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitEqualityExpression(IEqualityExpression equalityExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitInvocationExpression(IInvocationExpression invocationExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitIsExpression(IIsExpression isExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitConstantOrTypePattern(IConstantOrTypePattern constantOrTypePatternParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypePattern(ITypePattern typePattern, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitVarPattern(IVarPattern varPattern, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitVarDeconstructionPattern(IVarDeconstructionPattern varDeconstructionPattern, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitRecursivePattern(IRecursivePattern recursivePatternParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitListPattern(IListPattern listPatternParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSlicePattern(ISlicePattern slicePatternParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCollectionExpression(ICollectionExpression collectionExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitExpressionElement(IExpressionElement expressionElementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSpreadElement(ISpreadElement spreadElementParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDiscardPattern(IDiscardPattern discardPatternParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDeconstructionPatternClause(IDeconstructionPatternClause deconstructionPatternClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitPropertyPatternClause(IPropertyPatternClause propertyPatternClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSubpattern(ISubpattern subpatternParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitParenthesizedPattern(IParenthesizedPattern parenthesizedPattern, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitNegatedPattern(INegatedPattern negatedPattern, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAndPattern(IAndPattern andPattern, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitOrPattern(IOrPattern orPattern, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitRelationalPattern(IRelationalPattern relationalPattern, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitLambdaExpression(ILambdaExpression lambdaExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitLocalFunctionDeclaration(ILocalFunctionDeclaration localFunctionDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCSharpLiteralExpression(ICSharpLiteralExpression literalExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitMultiplicativeExpression(IMultiplicativeExpression multiplicativeExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitNullCoalescingExpression(INullCoalescingExpression nullCoalescingExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitPostfixOperatorExpression(IPostfixOperatorExpression postfixOperatorExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitPredefinedTypeExpression(IPredefinedTypeExpression predefinedTypeExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitPrefixOperatorExpression(IPrefixOperatorExpression prefixOperatorExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryExpression(IQueryExpression queryExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitReferenceExpression(IReferenceExpression referenceExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitRelationalExpression(IRelationalExpression relationalExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitShiftExpression(IShiftExpression shiftExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitThisExpression(IThisExpression thisExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypeofExpression(ITypeofExpression typeofExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUnaryOperatorExpression(IUnaryOperatorExpression unaryOperatorExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUncheckedExpression(IUncheckedExpression uncheckedExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUnsafeCodeAddressOfExpression(IUnsafeCodeAddressOfExpression unsafeCodeAddressOfExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUnsafeCodePointerAccessExpression(IUnsafeCodePointerAccessExpression unsafeCodePointerAccessExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUnsafeCodePointerIndirectionExpression(IUnsafeCodePointerIndirectionExpression unsafeCodePointerIndirectionExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUnsafeCodeSizeOfExpression(IUnsafeCodeSizeOfExpression unsafeCodeSizeOfExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAdditiveExpression(IAdditiveExpression additiveExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAnonymousMethodExpression(IAnonymousMethodExpression anonymousMethodExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreationExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAsExpression(IAsExpression asExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAssignmentExpression(IAssignmentExpression assignmentExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitBaseExpression(IBaseExpression baseExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitBitwiseAndExpression(IBitwiseAndExpression bitwiseAndExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitBitwiseExclusiveOrExpression(IBitwiseExclusiveOrExpression bitwiseExclusiveOrExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitBitwiseInclusiveOrExpression(IBitwiseInclusiveOrExpression bitwiseInclusiveOrExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCastExpression(ICastExpression castExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCheckedExpression(ICheckedExpression checkedExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitConditionalAndExpression(IConditionalAndExpression conditionalAndExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitConditionalOrExpression(IConditionalOrExpression conditionalOrExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitConditionalTernaryExpression(IConditionalTernaryExpression conditionalTernaryExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAccessorDeclaration(IAccessorDeclaration accessorDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCatchVariableDeclaration(ICatchVariableDeclaration catchVariableDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitLabelDeclaration(ILabelDeclaration labelDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitLocalConstantDeclaration(ILocalConstantDeclaration localConstantDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitUnsafeCodeFixedPointerDeclaration(IUnsafeCodeFixedPointerDeclaration unsafeCodeFixedPointerDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryRangeVariableDeclaration(IQueryRangeVariableDeclaration queryRangeVariableDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypeMemberRegularParameterDeclaration(ITypeMemberRegularParameterDeclaration regularParameterDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitLocalRegularParameterDeclaration(ILocalRegularParameterDeclaration localRegularParameterDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitArrayInitializer(IArrayInitializer arrayInitializerParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAnonymousMemberDeclaration(IAnonymousMemberDeclaration anonymousMemberDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCollectionInitializer(ICollectionInitializer collectionInitializerParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitExpressionInitializer(IExpressionInitializer expressionInitializerParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitIndexerInitializer(IIndexerInitializer indexerInitializerParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitStackAllocExpression(IStackAllocExpression unsafeCodeStackAllocExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitObjectInitializer(IObjectInitializer objectInitializerParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitWithExpression(IWithExpression withExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitWithInitializerAssignment(IWithInitializerAssignment withInitializerAssignmentParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryWhereClause(IQueryWhereClause queryWhereClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQuerySelectClause(IQuerySelectClause querySelectClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryOrderByClause(IQueryOrderByClause queryOrderByClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryLetClause(IQueryLetClause queryLetClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryJoinClause(IQueryJoinClause queryJoinClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryGroupClause(IQueryGroupClause queryGroupClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryFromClause(IQueryFromClause queryFromClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitGeneralCatchClause(IGeneralCatchClause catchClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSpecificCatchClause(ISpecificCatchClause specificCatchClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitQueryOrdering(IQueryOrdering queryOrderingParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitClassDeclaration(IClassDeclaration classDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitRecordDeclaration(IRecordDeclaration recordDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDelegateDeclaration(IDelegateDeclaration delegateDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitMultipleFieldDeclaration(IMultipleFieldDeclaration multipleFieldDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitAwaitExpression(IAwaitExpression awaitExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitIndexerDeclaration(IIndexerDeclaration indexerDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypeParameterOfLocalFunctionDeclaration(ITypeParameterOfLocalFunctionDeclaration typeParameterOfLocalFunctionDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypeParameterConstraintsClause(ITypeParameterConstraintsClause typeParameterConstraintsClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTupleExpression(ITupleExpression tupleExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTupleComponent(ITupleComponent tupleComponentParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypeConstraint(ITypeConstraint typeConstraintParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitConstructorConstraint(IConstructorConstraint constructorConstraintParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitReferenceTypeConstraint(IReferenceTypeConstraint referenceConstraintParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitValueTypeConstraint(IValueTypeConstraint valueConstraintParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitDefaultConstraint(IDefaultConstraint defaultConstraint, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitTypeParameterReference(ITypeParameterReference typeParameterReferenceParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitStructDeclaration(IStructDeclaration structDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration primaryConstructorDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitMultipleEventDeclaration(IMultipleEventDeclaration multipleEventDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitEventDeclaration(IEventDeclaration eventDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitMultipleConstantDeclaration(IMultipleConstantDeclaration multipleConstantDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitArrowExpressionClause(IArrowExpressionClause arrowExpressionClauseParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSignOperatorDeclaration(ISignOperatorDeclaration signOperatorDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitConversionOperatorDeclaration(IConversionOperatorDeclaration conversionOperatorDeclarationParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitMakerefExpression(IMakerefExpression makerefExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitReftypeExpression(IReftypeExpression reftypeExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitRefvalueExpression(IRefvalueExpression refvalueExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitIndexFromEndExpression(IIndexFromEndExpression indexFromEndExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSuppressNullableWarningExpression(ISuppressNullableWarningExpression suppressNullableWarningExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitRangeExpression(IRangeExpression rangeExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSwitchExpression(ISwitchExpression switchExpressionParam, PatternMatcherBuilderParams context);
    public virtual IElementMatcher VisitSwitchExpressionArm(ISwitchExpressionArm switchExpressionArmParam, PatternMatcherBuilderParams context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpExpressionStructuralMatcher : CSharpStructuralMatcherBase {
    public CSharpExpressionStructuralMatcher(IElementMatcher matcher, StructuralSearchPatternParams patternParams);
    public virtual IStructuralMatchResult Match(ITreeNode element, IMatchingContext context);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpMatcherBuilder : object {
    [NotNullAttribute]
public static IElementMatcher Build(ITreeNode element, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpPatternLexer : PatternLexer {
    protected LanguageService LanguageService { get; }
    protected bool MetaPlaceholderSupported { get; }
    protected virtual LanguageService get_LanguageService();
    protected virtual bool get_MetaPlaceholderSupported();
    protected virtual IMetaPlaceholder GetMetaPlaceholder(string name);
    protected virtual string GetPlaceHolderName(string name);
    protected virtual IPlaceholder TryParsePlaceholder(string name);
    protected virtual IUnknownPlaceholder CreateUnknownPlaceholder(string name);
    public virtual IPatternLexerResult TryParsePattern(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params, Func`2<IParser, ITreeNode> createElement, int realShift, bool createUnknownPlaceholders, bool deleteUnusedPlaceholders);
    [CompilerGeneratedAttribute]
internal static bool <TryParsePlaceholder>g__HasFirstArgumentTypeIdentifier|7_0(LocalList`1<PlaceholderArgument> placeholderArguments);
    [CompilerGeneratedAttribute]
internal static KnownPlaceholderType <TryParsePlaceholder>g__GetPlaceholderType|7_1(string placeholderNameString, LocalList`1<PlaceholderArgument> placeholderArguments);
    [CompilerGeneratedAttribute]
internal static KnownPlaceholderType <TryParsePlaceholder>g__TryGetPlaceholderTypeFromIdent|7_2(PlaceholderArgument argument);
    [CompilerGeneratedAttribute]
internal static KnownPlaceholderType <TryParsePlaceholder>g__TryGetPlaceholderTypeFromName|7_3(string placeholderNameString);
    [CompilerGeneratedAttribute]
internal static string <TryParsePlaceholder>g__TryGetStringArgument|7_4(LocalList`1<PlaceholderArgument> argsList, int index, string defaultValue);
    [CompilerGeneratedAttribute]
internal static bool <TryParsePlaceholder>g__TryGetExactArgument|7_5(LocalList`1<PlaceholderArgument> argsList, int index, bool defaultValue);
    [CompilerGeneratedAttribute]
internal static bool <TryParsePlaceholder>g__TryGetCaseSensitiveArgument|7_6(LocalList`1<PlaceholderArgument> argsList, int index, bool defaultValue);
    [CompilerGeneratedAttribute]
internal static bool <TryParsePlaceholder>g__TryGetBoolOrIdentArgument|7_7(LocalList`1<PlaceholderArgument> argsList, int index, String[] trueValues, String[] falseValues, bool defaultValue);
    [CompilerGeneratedAttribute]
internal static int <TryParsePlaceholder>g__TryGetIntArgument|7_8(LocalList`1<PlaceholderArgument> argsList, int index, int defaultValue);
    [CompilerGeneratedAttribute]
internal static T <TryParsePlaceholder>g__TryGetArgument|7_9(LocalList`1<PlaceholderArgument> argsList, PlaceholderArgumentType argumentType, int index, T defaultValue);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpPlaceholderGuesser : object {
    public sealed virtual IPlaceholder Guess(ITreeNode node, string name);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpPlaceholderStructuralMatcher : CSharpStructuralMatcherBase {
    public CSharpPlaceholderStructuralMatcher(IElementMatcher matcher, StructuralSearchPatternParams patternParams);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpReplacePatternLexer : ReplacePatternLexer {
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpSequenceMatcher`1 : SequenceMatcher`1<T> {
    public CSharpSequenceMatcher`1(IEnumerable`1<T> elements, PatternMatcherBuilderParams params);
    public CSharpSequenceMatcher`1(ITreeNode element, Func`2<ITreeNode, IEnumerable`1<T>> elementsGetter, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStatementSequenceMatcher : CSharpSequenceMatcher`1<ICSharpStatement> {
    private bool mySkipEmptyStatements;
    public CSharpStatementSequenceMatcher(IBlock block, PatternMatcherBuilderParams params);
    protected virtual bool MoveToNextElement(IEnumerator`1<ICSharpStatement> elementsEnumerator, ICSharpStatement& currentElement);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStructuralMatcherBase : StructuralMatcher {
    [CanBeNullAttribute]
private List`1<string> myExtendedWords;
    protected CSharpStructuralMatcherBase(IElementMatcher matcher, StructuralSearchPatternParams patternParams);
    public virtual IReadOnlyCollection`1<string> GetExtendedWords(ISolution solution);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStructuralMatcherBase/<GetTypePlaceholders>d__3")]
[PureAttribute]
private static IEnumerable`1<TypePlaceholder> GetTypePlaceholders(IElementMatcher matcher);
}
[StructuralSearcherFactoryAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStructuralSearcherFactory : object {
    private CSharpStructuralSearchPatternFromCodeCreator myPatternFromCodeCreator;
    public bool IsInternal { get; }
    public bool SupportsIgnoreUnmatched { get; }
    public bool SupportsShortenReferences { get; }
    public CSharpStructuralSearcherFactory(CSharpStructuralSearchPatternFromCodeCreator patternFromCodeCreator);
    public sealed virtual bool get_IsInternal();
    public sealed virtual bool get_SupportsIgnoreUnmatched();
    public sealed virtual bool get_SupportsShortenReferences();
    public sealed virtual IStructuralSearchPattern CreatePattern();
    public sealed virtual IStructuralSearchPattern CreatePattern(string pattern, IPlaceholder[] placeholders);
    public sealed virtual void Replace(IStructuralSearchPattern pattern, IStructuralMatchResult result);
    public sealed virtual void Replace(IEnumerable`1<IStructuralMatchResult> targets, IStructuralSearchPattern pattern);
    public sealed virtual IStructuralSearchPattern CreatePattern(ISolution solution, DocumentRange selection);
    public void Replace2(IStructuralSearchPattern pattern, IList`1<IStructuralMatchResult> results);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStructuralSearchPattern : StructuralSearchPatternBase {
    private CSharpStructuralSearchPatternPresenter myPresenter;
    private static IStructuralSearchPatternBuilder[] ourBuilders;
    private static IStructuralSearchPatternBuilder[] ourGuessBuilders;
    private static StructuralSearchPatternValidator ourPatternValidator;
    public IStructuralSearchPatternPresenter Presenter { get; }
    public PsiLanguageType Language { get; }
    public CSharpStructuralSearchPattern(string textPattern);
    public CSharpStructuralSearchPattern(string textPattern, IEnumerable`1<IPlaceholder> placeholders);
    public CSharpStructuralSearchPattern(string textPattern, IPlaceholder[] placeholders);
    public CSharpStructuralSearchPattern(string textPattern, StructuralSearchPatternParams params, IPlaceholder[] placeholders);
    public CSharpStructuralSearchPattern(string textPattern, StructuralSearchPatternParams params, IEnumerable`1<IPlaceholder> placeholders);
    public CSharpStructuralSearchPattern(string textPattern, StructuralSearchPatternParams params, IDictionary`2<string, IPlaceholder> placeholders);
    private static CSharpStructuralSearchPattern();
    public virtual IStructuralSearchPatternPresenter get_Presenter();
    public virtual IStructuralSearchPattern AddPatternPlaceholder(string name, string pattern, bool isShared);
    public virtual IStructuralSearchPattern AddOrPatternPlaceholder(string name, bool isShared, String[] patterns);
    public virtual IStructuralMatcher CreateMatcher();
    private void SetBackReferences();
    public virtual IStructuralMatcher CreateMatcher(IStructuralSearchPatternBuilder builder);
    public virtual PsiLanguageType get_Language();
    public virtual IStructuralSearchPatternValidator GetValidator();
    public virtual bool GuessPlaceholders();
    public virtual IStructuralSearchPattern Clone();
    public bool Equals(CSharpStructuralSearchPattern other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void ReadPlaceholders(IEnumerable`1<PlaceholderInfo> placeholderInfos);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStructuralSearchPatternFromCodeCreator : object {
    private IStructuralSearchPlaceholderGuesser myGuesser;
    public CSharpStructuralSearchPatternFromCodeCreator(IStructuralSearchPlaceholderGuesser guesser);
    public sealed virtual IStructuralSearchPattern CreatePattern(ISolution solution, DocumentRange selection);
    private static bool AppendTypePlaceholder(StringBuilder patternText, Dictionary`2<string, IPlaceholder> placeholders, IReferenceName node);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStructuralSearchPatternPresenter : StructuralSearchPatternPresenterBase {
    public CSharpStructuralSearchPatternPresenter(CSharpStructuralSearchPattern pattern);
    protected virtual string GetListReplacement(IEnumerable enumerable);
    protected virtual ReplacePatternLexerResult ParsePattern(string text, IDictionary`2<string, IPlaceholder> placeholders);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStructuralSearchReplacer : object {
    public static void Replace(IEnumerable`1<IStructuralMatchResult> results, string replacePattern, IDictionary`2<string, IPlaceholder> placeholders, bool formatAfterReplace, bool shortenReferences);
    private static void ReParseAndReFormat(OneToSetMap`2<ICSharpFile, TreeTextRange> rangesToFormatPerFile, bool formatAfterReplace, bool shortenReferences);
    private static TreeTextRange FindRangeToFormat(IFile file, TreeTextRange modifiedRange);
    [CanBeNullAttribute]
private static ITreeNode CreateModifiedNodeFromPattern(string replacePattern, IDictionary`2<string, IPlaceholder> placeholders, ITreeNode elementToReplace, IStructuralMatchResult result);
    private static bool NeedParenthesis(ITreeNode node, ITreeNode expr);
    [NotNullAttribute]
private static ITreeNode[] TrimWhitespaceAndCopyWithResolve(IEnumerable`1<ITreeNode> nodes);
    [NotNullAttribute]
private static IEnumerable`1<ICSharpCommentNode> FindComments(IEnumerable`1<ITreeNode> trimmed);
    private static ICSharpParser CreateParser(StringBuilder text, ITreeNode element);
    private static ITreeNode ParseReplaceNode(StringBuilder replaceText, ITreeNode elementToReplace);
    private static TreeTextRange ReplaceDiffNodes(ITreeNode original, ITreeNode modified, IStructuralMatchResult result, ITreeNode& replacementNode);
    private static TreeTextRange ReplaceDiffNodes(ITreeNode original, IEnumerable`1<ITreeNode> originalChildren, IEnumerable`1<ITreeNode> modifiedChildren, IStructuralMatchResult result);
    [CompilerGeneratedAttribute]
internal static TreeRange <Replace>g__BuildOriginalElementTreeRange|0_2(<>c__DisplayClass0_0& , <>c__DisplayClass0_1& );
    [CompilerGeneratedAttribute]
internal static bool <ReplaceDiffNodes>g__AdvanceOriginal|10_0(<>c__DisplayClass10_0& , <>c__DisplayClass10_1& );
    [CompilerGeneratedAttribute]
internal static bool <ReplaceDiffNodes>g__IsMatchedImplicitly|10_3(ITreeNode treeNode, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <ReplaceDiffNodes>g__AdvanceModified|10_1(<>c__DisplayClass10_2& );
    [CompilerGeneratedAttribute]
internal static TreeTextRange <ReplaceDiffNodes>g__JoinRangesToFormat|10_2(TreeTextRange first, TreeTextRange second);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpStructuralSearchReplacerOld : object {
    public static void Replace(ITreeNode replaceElement, string replacePattern, PlaceholderReplacement[] replacements);
    public static void Replace(IEnumerable`1<ITreeNode> elements, string replacePattern, PlaceholderReplacement[] replacements);
    private static void RemoveElementsAfterFirst(IEnumerable`1<ITreeNode> elements);
    private static string PrepareReplaceText(string replacePattern, IDictionary`2<string, IPlaceholder> placeholders, List`1& replacements, Func`2<string, object> getMatchedElement, Func`2<string, string> getMatchedText);
    private static void DoReplace(ITreeNode elementToReplace, string replacePattern, IDictionary`2<string, IPlaceholder> placeholders, Func`2<string, object> getMatchedElement, Func`2<string, string> getMatchedText, IEnumerable`1<ITreeNode> elementsToRemove, bool formatAfterReplace, bool shortenReferences);
    private static void ShortenReferences(ITreeNode result, int startOffset, int endOffset);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpTypeMatcher`1 : TypeMatcherBase`1<T> {
    [NotNullAttribute]
private string myTypeUsageText;
    [NotNullAttribute]
private Func`2<T, IType> myGetElementType;
    protected string TypeName { get; }
    private CSharpTypeMatcher`1(string typeUsageText, Func`2<T, IType> getElementType, List`1<ITypeMatcher> typeArgumentMatchers);
    protected virtual string get_TypeName();
    [NotNullAttribute]
protected virtual IType GetOriginalType(ITreeNode context);
    protected virtual IType GetElementType(T element);
    [NotNullAttribute]
public static ITypeMatcher Build(ITypeUsage typeUsage, Func`2<T, IType> func, PatternMatcherBuilderParams params);
    [NotNullAttribute]
public static ITypeMatcher Build(IReferenceExpression referenceExpression, Func`2<T, IType> func, PatternMatcherBuilderParams params);
    [NotNullAttribute]
public static ITypeMatcher Build(IAttribute attribute, Func`2<IAttribute, IType> func, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.CSharpTypeMemberStructuralMatcher : CSharpStructuralMatcherBase {
    public CSharpTypeMemberStructuralMatcher(IElementMatcher matcher, StructuralSearchPatternParams patternParams);
}
internal interface JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.IExpressionMatcher {
    public abstract virtual IStructuralMatchResult MatchExpression(ICSharpExpression expression, IMatchingContext context, StructuralSearchPatternParams params);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.ITypeMemberDeclarationMatcher {
    public abstract virtual bool Match(ICSharpTypeMemberDeclaration declaration, IMatchingContext context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AccessorDeclarationMatcher : CSharpElementMatcher`1<IAccessorDeclaration> {
    private IElementMatcher myExpressionMatcher;
    public AccessorDeclarationMatcher(IAccessorDeclaration declaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AndPatternMatcher : CSharpElementMatcher`1<IAndPattern> {
    public IEnumerable`1<string> Words { get; }
    public AndPatternMatcher(IAndPattern andPattern, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AnonymousMemberDeclarationMatcher : CSharpElementMatcher`1<IAnonymousMemberDeclaration> {
    public AnonymousMemberDeclarationMatcher(IAnonymousMemberDeclaration declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AnonymousMethodExpressionMatcher : CSharpElementMatcher`1<IAnonymousMethodExpression> {
    public AnonymousMethodExpressionMatcher(IAnonymousMethodExpression expression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AnonymousObjectCreationExpressionMatcher : CSharpElementMatcher`1<IAnonymousObjectCreationExpression> {
    public AnonymousObjectCreationExpressionMatcher(IAnonymousObjectCreationExpression expression, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ArgumentMatcher : CSharpElementMatcher`1<ICSharpArgument> {
    public ArgumentMatcher(ICSharpArgument argument, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ArrayCreationExpressionMatcher : CSharpElementMatcher`1<IArrayCreationExpression> {
    public ArrayCreationExpressionMatcher(IArrayCreationExpression expression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ArrayInitializerMatcher : CSharpElementMatcher`1<IArrayInitializer> {
    public ArrayInitializerMatcher(IArrayInitializer initializer, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ArrowExpressionClauseMatcher : CSharpElementMatcher`1<IArrowExpressionClause> {
    public ArrowExpressionClauseMatcher(IArrowExpressionClause clause, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AsExpressionMatcher : CSharpElementMatcher`1<IAsExpression> {
    public IEnumerable`1<string> Words { get; }
    public AsExpressionMatcher(IAsExpression element, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AsExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AssignmentExpressionMatcher : CSharpElementMatcher`1<IAssignmentExpression> {
    public AssignmentExpressionMatcher(IAssignmentExpression expression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AssociativeExpressionMatcher`1 : object {
    [NotNullAttribute]
private PatternMatcherBuilderParams myParams;
    [NotNullAttribute]
private List`1<IElementMatcher> myOperandMatchers;
    [NotNullAttribute]
private TokenNodeType myOperatorSign;
    public IEnumerable`1<IElementMatcher> Children { get; }
    public IEnumerable`1<string> Words { get; }
    public AssociativeExpressionMatcher`1(T expression, PatternMatcherBuilderParams params);
    public sealed virtual IEnumerable`1<IElementMatcher> get_Children();
    public sealed virtual IEnumerable`1<string> get_Words();
    public sealed virtual bool Match(ITreeNode element, IMatchingContext context);
    private static ICollection`1<ITreeNode> GetBinaryExpressionOperands(ITreeNode node);
    private void GetOperands(ICSharpExpression expression, List`1<ITreeNode> operands);
    public sealed virtual IStructuralMatchResult MatchExpression(ICSharpExpression expression, IMatchingContext context, StructuralSearchPatternParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AttributeMatcher : CSharpElementMatcher`1<IAttribute> {
    public IEnumerable`1<string> Words { get; }
    public AttributeMatcher(IAttribute attribute, PatternMatcherBuilderParams params);
    [CanBeNullAttribute]
public static IType CreateType(IAttribute attribute);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AttributeMatcher/<get_Words>d__3")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AttributeSectionListMatcher : CSharpElementMatcher`1<IAttributeSectionList> {
    public AttributeSectionListMatcher(IAttributeSectionList attributeSectionList, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AwaitExpressionMatcher : CSharpElementMatcher`1<IAwaitExpression> {
    public IEnumerable`1<string> Words { get; }
    public AwaitExpressionMatcher(IAwaitExpression awaitExpressionParam, PatternMatcherBuilderParams context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.AwaitExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.BaseExpressionMatcher : CSharpElementMatcher`1<IBaseExpression> {
    [NotNullAttribute]
public static BaseExpressionMatcher Instance;
    public IEnumerable`1<string> Words { get; }
    private static BaseExpressionMatcher();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.BaseExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.BinaryExpressionMatcher`1 : CSharpElementMatcher`1<TExpression> {
    [NotNullAttribute]
private IElementMatcher myLeftOperandMatcher;
    [NotNullAttribute]
private IElementMatcher myRightOperandMatcher;
    [NotNullAttribute]
private TokenNodeType myOperatorSign;
    private TreatBinaryExpressionsEquivalent myTreatReversedBinaryExpressionsEquivalent;
    public BinaryExpressionMatcher`1(TExpression expression, PatternMatcherBuilderParams params);
    public BinaryExpressionMatcher`1(TExpression expression, TokenNodeType operatorSign, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    private bool MatchNormal(ITreeNode element, IMatchingContext context);
    private bool MatchReverse(ITreeNode element, IMatchingContext context);
    private static bool CheckExpressionCanBeUsedInSmartComparison(ICSharpExpression expression);
    private static bool IsFieldCanBeUsedInSmartComparison(ITypeMember field, ICSharpExpression qualifierExpression);
    private static TokenNodeType GetReverseOperatorSign(TokenNodeType sign);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.BinaryExpressionMatcherUtil : object {
    [CanBeNullAttribute]
[PureAttribute]
public static IElementMatcher CreateNegativeMatcher(TExpression expression, PatternMatcherBuilderParams params);
    [CanBeNullAttribute]
[PureAttribute]
private static TokenNodeType GetNegativeOperatorSign(TokenNodeType sign);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.BlockMatcher : CSharpElementMatcher`1<IBlock> {
    [NotNullAttribute]
private CSharpSequenceMatcher`1<ICSharpStatement> myStatementsMatcher;
    public BlockMatcher(IBlock block, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.BreakStatementMatcher : CSharpElementMatcher`1<IBreakStatement> {
    [NotNullAttribute]
public static BreakStatementMatcher Instance;
    public IEnumerable`1<string> Words { get; }
    private static BreakStatementMatcher();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.BreakStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CastExpressionMatcher : CSharpElementMatcher`1<ICastExpression> {
    public CastExpressionMatcher(ICastExpression expression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CatchVariableDeclarationMatcher : CSharpElementMatcher`1<ICatchVariableDeclaration> {
    public CatchVariableDeclarationMatcher(ICatchVariableDeclaration declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CheckedExpressionMatcher : CSharpElementMatcher`1<ICheckedExpression> {
    public IEnumerable`1<string> Words { get; }
    public CheckedExpressionMatcher(ICheckedExpression expression, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CheckedExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CheckedStatementMatcher : CSharpElementMatcher`1<ICheckedStatement> {
    public IEnumerable`1<string> Words { get; }
    public CheckedStatementMatcher(ICheckedStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CheckedStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ClassDeclarationMatcher`1 : CSharpElementMatcher`1<TDeclaration> {
    [NotNullAttribute]
private IElementMatcher myNameMatcher;
    [NotNullAttribute]
private List`1<IElementMatcher> myClassMemberDeclarationMatchers;
    [CanBeNullAttribute]
private List`1<IElementMatcher> myAttributeMatchers;
    [NotNullAttribute]
private List`1<IElementMatcher> myTypeParameterMatchers;
    [CanBeNullAttribute]
private List`1<IElementMatcher> myTypeParameterConstraintMatchers;
    [NotNullAttribute]
private IElementMatcher myDecorationMatcher;
    [NotNullAttribute]
private List`1<ITypeMatcher> mySuperTypeMatchers;
    [NotNullAttribute]
private IElementMatcher myStructModifierMatcher;
    [NotNullAttribute]
private IElementMatcher myPrimaryConstructorMatcher;
    public ClassDeclarationMatcher`1(TDeclaration classDeclaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    private bool MatchList(IEnumerable`1<IElementMatcher> matchers, ICollection`1<TNode> treeNodes, IMatchingContext context);
    private static bool Match(List`1<ITreeNode> members, IEnumerable`1<IElementMatcher> matchers, IMatchingContext context);
    private static bool CheckVariant(BipartiteGraph`2<IElementMatcher, ITreeNode> graph, IMatchingContext context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CollectionElementInitializerMatcher : CSharpElementMatcher`1<ICollectionElementInitializer> {
    public CollectionElementInitializerMatcher(ICollectionElementInitializer initializer, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CollectionExpressionMatcher : CSharpElementMatcher`1<ICollectionExpression> {
    public CollectionExpressionMatcher(ICollectionExpression collectionExpression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CollectionInitializerMatcher : CSharpElementMatcher`1<ICollectionInitializer> {
    public CollectionInitializerMatcher(ICollectionInitializer initializer, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ConditionalTernaryExpressionMatcher : CSharpElementMatcher`1<IConditionalTernaryExpression> {
    [NotNullAttribute]
private IElementMatcher myThenMatcher;
    [NotNullAttribute]
private IElementMatcher myElseMatcher;
    [CanBeNullAttribute]
private IElementMatcher myNegativeExpressionMatcher;
    public ConditionalTernaryExpressionMatcher(IConditionalTernaryExpression expression, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    private bool MatchNormal(ITreeNode element, IMatchingContext context);
    private bool MatchReverse(ITreeNode element, IMatchingContext context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ConstantDeclarationMatcher : CSharpElementMatcher`1<IConstantDeclaration> {
    public ConstantDeclarationMatcher(IConstantDeclaration declaration, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ConstantOrTypePatternMatcher : CSharpElementMatcher`1<IConstantOrTypePattern> {
    public ConstantOrTypePatternMatcher(IConstantOrTypePattern constantPattern, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ConstructorDeclarationMatcher : CSharpElementMatcher`1<IConstructorDeclaration> {
    [CanBeNullAttribute]
private IElementMatcher myExpressionMatcher;
    public ConstructorDeclarationMatcher(IConstructorDeclaration declaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ContinueStatementMatcher : CSharpElementMatcher`1<IContinueStatement> {
    [NotNullAttribute]
public static ContinueStatementMatcher Instance;
    public IEnumerable`1<string> Words { get; }
    private static ContinueStatementMatcher();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ContinueStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ConversionOperatorDeclarationMatcher : OperatorDeclarationMatcherBase`1<IConversionOperatorDeclaration> {
    public ConversionOperatorDeclarationMatcher(IConversionOperatorDeclaration declaration, PatternMatcherBuilderParams params);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CSharpElementMatcher`1 : ElementMatcherBase`1<T> {
    [NotNullAttribute]
protected IElementMatcher AddMatcher(T expression, Func`2<T, ITreeNode> propertyGetter, PatternMatcherBuilderParams params);
    [NotNullAttribute]
protected CSharpSequenceMatcher`1<T2> AddMatcher(T expression, Func`2<T, IEnumerable`1<T2>> elementsGetter, PatternMatcherBuilderParams params);
    [NotNullAttribute]
protected ImplicitSequenceMatcher`2<T, T2> AddImplicitMatcher(T expression, Func`2<T, IEnumerable`1<T2>> elementsGetter, PatternMatcherBuilderParams params);
    [NotNullAttribute]
protected IElementMatcher AddMatcherAnyOrder(T element, Func`2<T, IEnumerable`1<T2>> elementsGetter, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CSharpIdentifierMatcher : CSharpElementMatcher`1<ITreeNode> {
    [CanBeNullAttribute]
private string myName;
    public IEnumerable`1<string> Words { get; }
    private CSharpIdentifierMatcher(ITreeNode element);
    [CanBeNullAttribute]
private static string GetName(ITreeNode element);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    public virtual IEnumerable`1<string> get_Words();
    [NotNullAttribute]
public static IElementMatcher Build(ITreeNode element, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.CSharpParameterDeclarationMatcher : CSharpElementMatcher`1<ICSharpParameterDeclaration> {
    public CSharpParameterDeclarationMatcher(ICSharpParameterDeclaration declaration, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DeclarationExpressionMatcher : CSharpElementMatcher`1<IDeclarationExpression> {
    public DeclarationExpressionMatcher(IDeclarationExpression declarationExpression, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DeclarationStatementMatcher : CSharpElementMatcher`1<IDeclarationStatement> {
    public DeclarationStatementMatcher(IDeclarationStatement declarationStatement, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DeconstructionPatternClauseMatcher : CSharpElementMatcher`1<IDeconstructionPatternClause> {
    public DeconstructionPatternClauseMatcher(IDeconstructionPatternClause deconstructionPatternClause, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DefaultExpressionMatcher : CSharpElementMatcher`1<IDefaultExpression> {
    public IEnumerable`1<string> Words { get; }
    public DefaultExpressionMatcher(IDefaultExpression expression, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DefaultExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DelegateDeclarationMatcher : CSharpElementMatcher`1<IDelegateDeclaration> {
    public DelegateDeclarationMatcher(IDelegateDeclaration declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DestructorDeclarationMatcher : CSharpElementMatcher`1<IDestructorDeclaration> {
    [CanBeNullAttribute]
private IElementMatcher myExpressionMatcher;
    public DestructorDeclarationMatcher(IDestructorDeclaration declaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DiscardDesignationMatcher : CSharpElementMatcher`1<ISingleVariableDesignation> {
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DiscardPatternMatcher : CSharpElementMatcher`1<IDiscardPattern> {
    public DiscardPatternMatcher(IDiscardPattern discardPattern);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DoStatementMatcher : CSharpElementMatcher`1<IDoStatement> {
    public IEnumerable`1<string> Words { get; }
    public DoStatementMatcher(IDoStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.DoStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ElementAccessExpressionMatcher : CSharpElementMatcher`1<IElementAccessExpression> {
    public ElementAccessExpressionMatcher(IElementAccessExpression expression, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.EmptyStatementMatcher : CSharpElementMatcher`1<IEmptyStatement> {
    [NotNullAttribute]
public static EmptyStatementMatcher Instance;
    private static EmptyStatementMatcher();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.EnumDeclarationMatcher : CSharpElementMatcher`1<IEnumDeclaration> {
    public EnumDeclarationMatcher(IEnumDeclaration enumDeclaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.EventDeclarationMatcher : CSharpElementMatcher`1<IEventDeclaration> {
    public EventDeclarationMatcher(IEventDeclaration declaration, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ExpressionElementMatcher : CSharpElementMatcher`1<IExpressionElement> {
    public ExpressionElementMatcher(IExpressionElement expressionElement, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ExpressionInitializerMatcher : CSharpElementMatcher`1<IExpressionInitializer> {
    public ExpressionInitializerMatcher(IExpressionInitializer initializer, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ExpressionStatementMatcher : CSharpElementMatcher`1<IExpressionStatement> {
    public ExpressionStatementMatcher(IExpressionStatement statement, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.FakeEmptyStatementMatcher : SequencePlaceholderMatcherBase {
    public virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    public virtual ISequenceMatcher`1<ITreeNode> CreatePlaceholderMatcher(ICollection`1<ITreeNode> enumerable);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.FieldDeclarationMatcher : CSharpElementMatcher`1<IFieldDeclaration> {
    public FieldDeclarationMatcher(IFieldDeclaration declaration, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ForeachStatementMatcher : CSharpElementMatcher`1<IForeachStatement> {
    public IEnumerable`1<string> Words { get; }
    public ForeachStatementMatcher(IForeachStatement foreachStatement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ForeachStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ForStatementMatcher : CSharpElementMatcher`1<IForStatement> {
    public IEnumerable`1<string> Words { get; }
    public ForStatementMatcher(IForStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ForStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.GeneralCatchClauseMatcher : CSharpElementMatcher`1<IGeneralCatchClause> {
    public IEnumerable`1<string> Words { get; }
    public GeneralCatchClauseMatcher(IGeneralCatchClause generalCatchClause, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.GotoCaseStatementMatcher : CSharpElementMatcher`1<IGotoCaseStatement> {
    public IEnumerable`1<string> Words { get; }
    public GotoCaseStatementMatcher(IGotoCaseStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.GotoCaseStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.GotoStatementMatcher : CSharpElementMatcher`1<IGotoStatement> {
    [NotNullAttribute]
private string myLabelName;
    public IEnumerable`1<string> Words { get; }
    public GotoStatementMatcher(IGotoStatement statement, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.IfStatementMatcher : CSharpElementMatcher`1<IIfStatement> {
    [NotNullAttribute]
private IElementMatcher myThenMatcher;
    [NotNullAttribute]
private IElementMatcher myElseMatcher;
    [CanBeNullAttribute]
private IElementMatcher myNegativeExpressionMatcher;
    public IEnumerable`1<string> Words { get; }
    public IfStatementMatcher(IIfStatement statement, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    private bool MatchNormal(ITreeNode element, IMatchingContext context);
    private bool MatchReverse(ITreeNode element, IMatchingContext context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.IfStatementMatcher/<get_Words>d__8")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ImplicitMatcher`1 : ElementMatcherBase`1<T> {
    [NotNullAttribute]
public static IElementMatcher Build(T treeNode);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ImplicitSequenceMatcher`2 : object {
    [NotNullAttribute]
private Func`2<T, IEnumerable`1<TProp>> myElementsGetter;
    public IEnumerable`1<IElementMatcher> Children { get; }
    public IEnumerable`1<string> Words { get; }
    public ImplicitSequenceMatcher`2(Func`2<T, IEnumerable`1<TProp>> elementsGetter);
    public sealed virtual bool Match(IEnumerable`1<T> elements, IMatchingContext context);
    public sealed virtual bool Match(ITreeNode element, IMatchingContext context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ImplicitSequenceMatcher`2/<get_Children>d__5")]
public sealed virtual IEnumerable`1<IElementMatcher> get_Children();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ImplicitSequenceMatcher`2/<get_Words>d__7")]
public sealed virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.IndexerDeclarationMatcher : CSharpElementMatcher`1<IIndexerDeclaration> {
    private IElementMatcher myExpressionMatcher;
    public IndexerDeclarationMatcher(IIndexerDeclaration declaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.IndexerInitializerMatcher : CSharpElementMatcher`1<IIndexerInitializer> {
    public IndexerInitializerMatcher(IIndexerInitializer indexerInitializer, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.IndexFromEndExpressionMatcher : CSharpElementMatcher`1<IIndexFromEndExpression> {
    public IndexFromEndExpressionMatcher(IIndexFromEndExpression expression, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.InterpolatedStringExpressionMatcher : CSharpElementMatcher`1<IInterpolatedStringExpression> {
    [CanBeNullAttribute]
private string myTrivialInterpolationValue;
    private bool myIgnoreLiteralForms;
    public InterpolatedStringExpressionMatcher(IInterpolatedStringExpression interpolatedStringExpression, PatternMatcherBuilderParams context);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    [PureAttribute]
internal static bool CompareLiterals(ITokenNode leftToken, ITokenNode rightToken, bool compareValue);
    [PureAttribute]
private static bool CompareLiteralValues(ITokenNode leftToken, ITokenNode rightToken);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__2_1(TreeNodeCollection`1<ITokenNode> xs, TreeNodeCollection`1<ITokenNode> ys);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.InterpolatedStringInsertMatcher : CSharpElementMatcher`1<IInterpolatedStringInsert> {
    private bool myIgnoreLiteralForms;
    public InterpolatedStringInsertMatcher(IInterpolatedStringInsert insert, PatternMatcherBuilderParams context);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__1_3(ITokenNode xFormat, ITokenNode yFormat);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.InvocationExpressionMatcher : CSharpElementMatcher`1<IInvocationExpression> {
    private IElementMatcher myInvokedExpressionMatcher;
    private CSharpSequenceMatcher`1<ICSharpArgument> myArgumentsMatcher;
    public InvocationExpressionMatcher(IInvocationExpression expression, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.IsExpressionMatcher : CSharpElementMatcher`1<IIsExpression> {
    public IEnumerable`1<string> Words { get; }
    public IsExpressionMatcher(IIsExpression isExpression, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
    [PureAttribute]
private static IsExpressionKind GetKindSyntactically(IIsExpression isExpression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LabelDeclarationMatcher : CSharpElementMatcher`1<ILabelDeclaration> {
    [NotNullAttribute]
private string myText;
    public IEnumerable`1<string> Words { get; }
    public LabelDeclarationMatcher(ILabelDeclaration declaration, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LabelDeclarationMatcher/<get_Words>d__3")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LabelStatementMatcher : CSharpElementMatcher`1<ILabelStatement> {
    public LabelStatementMatcher(ILabelStatement statement, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LambdaExpressionMatcher : CSharpElementMatcher`1<ILambdaExpression> {
    public LambdaExpressionMatcher(ILambdaExpression expression, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ListPatternMatcher : CSharpElementMatcher`1<IListPattern> {
    public ListPatternMatcher(IListPattern listPattern, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LiteralExpressionMatcher : CSharpElementMatcher`1<ICSharpLiteralExpression> {
    [NotNullAttribute]
private TokenNodeType myTokenType;
    [CanBeNullAttribute]
private string myLiteralText;
    [CanBeNullAttribute]
private object myConstantValue;
    [NotNullAttribute]
private static object ourLazyInitValue;
    public LiteralExpressionMatcher(ICSharpLiteralExpression literalExpression, PatternMatcherBuilderParams context);
    private static LiteralExpressionMatcher();
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    [PureAttribute]
private bool MatchWithOtherLiteral(ICSharpLiteralExpression otherLiteralExpression);
    [PureAttribute]
private static bool CompareLiteralValues(object leftValue, object rightValue);
    [PureAttribute]
private bool MatchStringWithTrivialInterpolation(IInterpolatedStringExpression interpolatedStringExpression);
    [CanBeNullAttribute]
[MustUseReturnValueAttribute]
private object GetLiteralValue(string literalText, ITreeNode context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LocalConstantDeclarationMatcher : CSharpElementMatcher`1<ILocalConstantDeclaration> {
    public LocalConstantDeclarationMatcher(ILocalConstantDeclaration declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LocalFunctionDeclarationMatcher : CSharpElementMatcher`1<ILocalFunctionDeclaration> {
    [CanBeNullAttribute]
private IElementMatcher myExpressionMatcher;
    public LocalFunctionDeclarationMatcher(ILocalFunctionDeclaration declaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LocalVariableDeclarationMatcher : CSharpElementMatcher`1<ILocalVariableDeclaration> {
    public LocalVariableDeclarationMatcher(ILocalVariableDeclaration declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LockStatementMatcher : CSharpElementMatcher`1<ILockStatement> {
    public IEnumerable`1<string> Words { get; }
    public LockStatementMatcher(ILockStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.LockStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.MakerefExpressionMatcher : CSharpElementMatcher`1<IMakerefExpression> {
    public IEnumerable`1<string> Words { get; }
    public MakerefExpressionMatcher(IMakerefExpression makerefExpression, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.MethodDeclarationMatcher : CSharpElementMatcher`1<IMethodDeclaration> {
    [CanBeNullAttribute]
private IElementMatcher myExpressionMatcher;
    public MethodDeclarationMatcher(IMethodDeclaration declaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    [CanBeNullAttribute]
internal static ICSharpExpression GetMatchSimilarBodiesExpression(IArrowExpressionClause arrowExpression, IBlock body, PatternMatcherBuilderParams params);
    [CanBeNullAttribute]
internal static ICSharpExpression GetMatchSimilarBodiesExpression(IArrowExpressionClause arrowExpression, IBlock body);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.MultipleConstantDeclarationMatcher : CSharpElementMatcher`1<IMultipleConstantDeclaration> {
    public MultipleConstantDeclarationMatcher(IMultipleConstantDeclaration declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.MultipleEventDeclarationMatcher : CSharpElementMatcher`1<IMultipleEventDeclaration> {
    public MultipleEventDeclarationMatcher(IMultipleEventDeclaration declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.MultipleFieldDeclarationMatcher : CSharpElementMatcher`1<IMultipleFieldDeclaration> {
    public MultipleFieldDeclarationMatcher(IMultipleFieldDeclaration declaration, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.NegatedPatternMatcher : CSharpElementMatcher`1<INegatedPattern> {
    public IEnumerable`1<string> Words { get; }
    public NegatedPatternMatcher(INegatedPattern negatedPattern, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ObjectCreationExpressionMatcher : CSharpElementMatcher`1<IObjectCreationExpression> {
    public IEnumerable`1<string> Words { get; }
    public ObjectCreationExpressionMatcher(IObjectCreationExpression expression, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ObjectCreationExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ObjectInitializerMatcher : CSharpElementMatcher`1<IObjectInitializer> {
    public ObjectInitializerMatcher(IObjectInitializer initializer, PatternMatcherBuilderParams params);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.OperatorDeclarationMatcherBase`1 : CSharpElementMatcher`1<TOperatorDeclaration> {
    private IElementMatcher myExpressionMatcher;
    protected OperatorDeclarationMatcherBase`1(TOperatorDeclaration declaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.OrPatternMatcher : CSharpElementMatcher`1<IOrPattern> {
    public IEnumerable`1<string> Words { get; }
    public OrPatternMatcher(IOrPattern orPattern, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ParenthesizedExpressionMatcher : CSharpElementMatcher`1<IParenthesizedExpression> {
    private bool myIgnoreParanthesisInExpressions;
    public ParenthesizedExpressionMatcher(IParenthesizedExpression expression, PatternMatcherBuilderParams params);
    private ICSharpExpression GetExpression(IParenthesizedExpression expression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ParenthesizedPatternMatcher : CSharpElementMatcher`1<IParenthesizedPattern> {
    public ParenthesizedPatternMatcher(IParenthesizedPattern parenthesizedPattern, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ParenthsizedVariableDesignationMatcher : CSharpElementMatcher`1<IParenthesizedVariableDesignation> {
    public ParenthsizedVariableDesignationMatcher(IParenthesizedVariableDesignation parenthesizedVariableDesignation, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.PatternGuardClauseMatcher : CSharpElementMatcher`1<IPatternGuardClause> {
    public IEnumerable`1<string> Words { get; }
    public PatternGuardClauseMatcher(IPatternGuardClause patternGuardClause, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.PostfixOperatorExpressionMatcher : CSharpElementMatcher`1<IPostfixOperatorExpression> {
    private bool myMatchPrefixExpression;
    [NotNullAttribute]
private IElementMatcher myOperandMatcher;
    private PostfixOperatorType myOperatorType;
    public PostfixOperatorExpressionMatcher(IPostfixOperatorExpression expression, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    public static bool CompareOperators(PrefixOperatorType prefix, PostfixOperatorType postfix);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.PredefinedTypeExpressionMatcher : CSharpElementMatcher`1<IPredefinedTypeExpression> {
    [NotNullAttribute]
private string myName;
    public PredefinedTypeExpressionMatcher(IPredefinedTypeExpression expression);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.PrefixOperatorExpressionMatcher : CSharpElementMatcher`1<IPrefixOperatorExpression> {
    private bool myMatchPostfixExpression;
    [NotNullAttribute]
private IElementMatcher myOperandMatcher;
    private PrefixOperatorType myOperatorType;
    public PrefixOperatorExpressionMatcher(IPrefixOperatorExpression expression, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.PrimaryConstructorDeclarationMatcher : CSharpElementMatcher`1<IPrimaryConstructorDeclaration> {
    public PrimaryConstructorDeclarationMatcher(IPrimaryConstructorDeclaration primaryConstructorDeclaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.PropertyDeclarationMatcher : CSharpElementMatcher`1<IPropertyDeclaration> {
    [CanBeNullAttribute]
private IElementMatcher myExpressionMatcher;
    public PropertyDeclarationMatcher(IPropertyDeclaration declaration, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    [CanBeNullAttribute]
internal static ICSharpExpression GetMatchSimilarBodiesExpression(IArrowExpressionClause arrowExpression, IAccessorDeclaration getterDeclaration, PatternMatcherBuilderParams params);
    [CanBeNullAttribute]
public static ICSharpExpression GetMatchSimilarBodiesExpression(IArrowExpressionClause arrowExpression, IAccessorDeclaration getterDeclaration);
    [CanBeNullAttribute]
internal static IAccessorDeclaration ExtractGetter(ICollection`1<IAccessorDeclaration> accessorDeclarations);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.PropertyInitializerMatcher : CSharpElementMatcher`1<IPropertyInitializer> {
    public PropertyInitializerMatcher(IPropertyInitializer propertyInitializer, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.PropertyPatternClauseMatcher : CSharpElementMatcher`1<IPropertyPatternClause> {
    public PropertyPatternClauseMatcher(IPropertyPatternClause propertyPatternClause, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryExpressionMatcher : CSharpElementMatcher`1<IQueryExpression> {
    public QueryExpressionMatcher(IQueryExpression expression, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryFromClauseMatcher : CSharpElementMatcher`1<IQueryFromClause> {
    public IEnumerable`1<string> Words { get; }
    public QueryFromClauseMatcher(IQueryFromClause clause, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryFromClauseMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryGroupClauseMatcher : CSharpElementMatcher`1<IQueryGroupClause> {
    public QueryGroupClauseMatcher(IQueryGroupClause clause, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryJoinMatcher : CSharpElementMatcher`1<IQueryJoinClause> {
    public IEnumerable`1<string> Words { get; }
    public QueryJoinMatcher(IQueryJoinClause clause, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryJoinMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryLetClauseMatcher : CSharpElementMatcher`1<IQueryLetClause> {
    public IEnumerable`1<string> Words { get; }
    public QueryLetClauseMatcher(IQueryLetClause clause, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryLetClauseMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryOrderByClauseMatcher : CSharpElementMatcher`1<IQueryOrderByClause> {
    public QueryOrderByClauseMatcher(IQueryOrderByClause clause, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryOrderingMatcher : CSharpElementMatcher`1<IQueryOrdering> {
    public QueryOrderingMatcher(IQueryOrdering ordering, PatternMatcherBuilderParams params);
    private static Ordering GetOrdering(IQueryOrdering ordering);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryRangeVariableDeclarationMatcher : CSharpElementMatcher`1<IQueryRangeVariableDeclaration> {
    public QueryRangeVariableDeclarationMatcher(IQueryRangeVariableDeclaration declaration, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QuerySelectClauseMatcher : CSharpElementMatcher`1<IQuerySelectClause> {
    public IEnumerable`1<string> Words { get; }
    public QuerySelectClauseMatcher(IQuerySelectClause clause, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QuerySelectClauseMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryWhereClauseMatcher : CSharpElementMatcher`1<IQueryWhereClause> {
    public IEnumerable`1<string> Words { get; }
    public QueryWhereClauseMatcher(IQueryWhereClause clause, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.QueryWhereClauseMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.RecursivePatternMatcher : TypeCheckPatternMatcher`1<IRecursivePattern> {
    public RecursivePatternMatcher(IRecursivePattern recursivePattern, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ReferenceExpressionMatcher : CSharpElementMatcher`1<IReferenceExpression> {
    [NotNullAttribute]
private IElementMatcher myIdentifierMatcher;
    [NotNullAttribute]
private IElementMatcher myQualifierExpression;
    public ReferenceExpressionMatcher(IReferenceExpression expression, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ReferenceExpressionTypeMatcher : object {
    private List`1<ITypeMatcher> myTypeArgumentsMatchers;
    public string ShortName { get; }
    public ReferenceExpressionTypeMatcher(IReferenceExpression expression, PatternMatcherBuilderParams params);
    public sealed virtual bool MatchType(ITreeNode element, IMatchingContext context);
    public sealed virtual bool MatchType(ITreeNode element, IType elementType, IMatchingContext context);
    public sealed virtual string get_ShortName();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.RefExpressionMatcher : CSharpElementMatcher`1<IRefExpression> {
    public IEnumerable`1<string> Words { get; }
    public RefExpressionMatcher(IRefExpression refExpression, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ReftypeExpressionMatcher : CSharpElementMatcher`1<IReftypeExpression> {
    public IEnumerable`1<string> Words { get; }
    public ReftypeExpressionMatcher(IReftypeExpression reftypeExpression, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.RefvalueExpressionMatcher : CSharpElementMatcher`1<IRefvalueExpression> {
    public IEnumerable`1<string> Words { get; }
    public RefvalueExpressionMatcher(IRefvalueExpression refvalueExpression, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.RegularParameterDeclarationMatcher : CSharpElementMatcher`1<ITypeMemberRegularParameterDeclaration> {
    public RegularParameterDeclarationMatcher(ITypeMemberRegularParameterDeclaration declaration, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.RelationalPatternMatcher : CSharpElementMatcher`1<IRelationalPattern> {
    private TokenNodeType mySign;
    public RelationalPatternMatcher(IRelationalPattern relationalPattern, PatternMatcherBuilderParams params);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ReturnStatementMatcher : CSharpElementMatcher`1<IReturnStatement> {
    public IEnumerable`1<string> Words { get; }
    public ReturnStatementMatcher(IReturnStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ReturnStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SignOperatorDeclarationMatcher : OperatorDeclarationMatcherBase`1<ISignOperatorDeclaration> {
    public SignOperatorDeclarationMatcher(ISignOperatorDeclaration declaration, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SingleVariableDesignationMatcher : CSharpElementMatcher`1<ISingleVariableDesignation> {
    public SingleVariableDesignationMatcher(ISingleVariableDesignation singleVariableDesignation, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SlicePatternMatcher : CSharpElementMatcher`1<ISlicePattern> {
    public SlicePatternMatcher(ISlicePattern listPattern, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SpecificCatchClauseMatcher : CSharpElementMatcher`1<ISpecificCatchClause> {
    public IEnumerable`1<string> Words { get; }
    public SpecificCatchClauseMatcher(ISpecificCatchClause specificCatchClause, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SpreadElementMatcher : CSharpElementMatcher`1<ISpreadElement> {
    public SpreadElementMatcher(ISpreadElement spreadElement, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.StatementOrBlockMatcher : object {
    [NotNullAttribute]
private IElementMatcher myMatcher;
    public IEnumerable`1<IElementMatcher> Children { get; }
    public IEnumerable`1<string> Words { get; }
    private StatementOrBlockMatcher(ICSharpStatement statement, PatternMatcherBuilderParams params);
    public static IElementMatcher Build(ICSharpStatement statement, PatternMatcherBuilderParams params);
    public sealed virtual bool Match(ITreeNode element, IMatchingContext context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.StatementOrBlockMatcher/<get_Children>d__5")]
public sealed virtual IEnumerable`1<IElementMatcher> get_Children();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.StatementOrBlockMatcher/<get_Words>d__7")]
public sealed virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SubpatternMatcher : CSharpElementMatcher`1<ISubpattern> {
    public SubpatternMatcher(ISubpattern subpattern, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SuppressNullableWarningExpressionMatcher : CSharpElementMatcher`1<ISuppressNullableWarningExpression> {
    public SuppressNullableWarningExpressionMatcher(ISuppressNullableWarningExpression expression, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SwitchCaseLabelMatcher : CSharpElementMatcher`1<ISwitchCaseLabel> {
    private bool myLabelIsDefault;
    public IEnumerable`1<string> Words { get; }
    public SwitchCaseLabelMatcher(ISwitchCaseLabel caseLabel, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SwitchExpressionArmMatcher : CSharpElementMatcher`1<ISwitchExpressionArm> {
    public SwitchExpressionArmMatcher(ISwitchExpressionArm switchExpressionArm, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SwitchExpressionMatcher : CSharpElementMatcher`1<ISwitchExpression> {
    public IEnumerable`1<string> Words { get; }
    public SwitchExpressionMatcher(ISwitchExpression expression, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SwitchExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SwitchSectionMatcher : CSharpElementMatcher`1<ISwitchSection> {
    public SwitchSectionMatcher(ISwitchSection switchSection, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SwitchStatementMatcher : CSharpElementMatcher`1<ISwitchStatement> {
    public IEnumerable`1<string> Words { get; }
    public SwitchStatementMatcher(ISwitchStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.SwitchStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ThisExpressionMatcher : CSharpElementMatcher`1<IThisExpression> {
    [NotNullAttribute]
public static ThisExpressionMatcher Instance;
    public IEnumerable`1<string> Words { get; }
    private static ThisExpressionMatcher();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ThisExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ThrowExpressionMatcher : CSharpElementMatcher`1<IThrowExpression> {
    public IEnumerable`1<string> Words { get; }
    public ThrowExpressionMatcher(IThrowExpression throwExpression, PatternMatcherBuilderParams params);
    public ThrowExpressionMatcher(PatternMatcherBuilderParams params, ICSharpExpression exceptionExpression);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.ThrowStatementMatcher : CSharpElementMatcher`1<IThrowStatement> {
    public IEnumerable`1<string> Words { get; }
    public ThrowStatementMatcher(IThrowStatement throwStatement, PatternMatcherBuilderParams params);
    public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TopLevelCodeMatcher : CSharpElementMatcher`1<ITopLevelCode> {
    public TopLevelCodeMatcher(ITopLevelCode topLevelCode, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TryStatementMatcher : CSharpElementMatcher`1<ITryStatement> {
    public IEnumerable`1<string> Words { get; }
    public TryStatementMatcher(ITryStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TryStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TupleComponentMatcher : CSharpElementMatcher`1<ITupleComponent> {
    public TupleComponentMatcher(ITupleComponent tupleComponent, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TupleExpressionMatcher : CSharpElementMatcher`1<ITupleExpression> {
    public TupleExpressionMatcher(ITupleExpression tupleExpression, PatternMatcherBuilderParams params);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TypeCheckPatternMatcher`1 : CSharpElementMatcher`1<TPattern> {
    [CanBeNullAttribute]
protected static IType GetPatternType(TPattern pattern);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TypeofExpressionMatcher : CSharpElementMatcher`1<ITypeofExpression> {
    public IEnumerable`1<string> Words { get; }
    public TypeofExpressionMatcher(ITypeofExpression expression, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TypeofExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TypeParameterConstraintMatcher`1 : CSharpElementMatcher`1<TConstraint> {
    public TypeParameterConstraintMatcher`1(TConstraint constraint, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TypeParameterConstraintsClauseMatcher : CSharpElementMatcher`1<ITypeParameterConstraintsClause> {
    public TypeParameterConstraintsClauseMatcher(ITypeParameterConstraintsClause clause, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TypeParameterDeclarationMatcher`1 : CSharpElementMatcher`1<TTypeParameter> {
    public TypeParameterDeclarationMatcher`1(TTypeParameter declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TypeParameterReferenceMatcher : CSharpElementMatcher`1<ITypeParameterReference> {
    public TypeParameterReferenceMatcher(ITypeParameterReference typeParameterReference, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.TypePatternMatcher : TypeCheckPatternMatcher`1<ITypePattern> {
    public TypePatternMatcher(ITypePattern typePattern, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnaryOperatorExpressionMatcher : CSharpElementMatcher`1<IUnaryOperatorExpression> {
    public UnaryOperatorExpressionMatcher(IUnaryOperatorExpression expression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UncheckedExpressionMatcher : CSharpElementMatcher`1<IUncheckedExpression> {
    public IEnumerable`1<string> Words { get; }
    public UncheckedExpressionMatcher(IUncheckedExpression expression, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UncheckedExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UncheckedStatementMatcher : CSharpElementMatcher`1<IUncheckedStatement> {
    public IEnumerable`1<string> Words { get; }
    public UncheckedStatementMatcher(IUncheckedStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UncheckedStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeAddressOfExpressionMatcher : CSharpElementMatcher`1<IUnsafeCodeAddressOfExpression> {
    public IEnumerable`1<string> Words { get; }
    public UnsafeCodeAddressOfExpressionMatcher(IUnsafeCodeAddressOfExpression expression, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeAddressOfExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeFixedPointerDeclarationMatcher : CSharpElementMatcher`1<IUnsafeCodeFixedPointerDeclaration> {
    public UnsafeCodeFixedPointerDeclarationMatcher(IUnsafeCodeFixedPointerDeclaration declaration, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeFixedStatementMatcher : CSharpElementMatcher`1<IUnsafeCodeFixedStatement> {
    public IEnumerable`1<string> Words { get; }
    public UnsafeCodeFixedStatementMatcher(IUnsafeCodeFixedStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeFixedStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodePointerAccessExpressionMatcher : CSharpElementMatcher`1<IUnsafeCodePointerAccessExpression> {
    public UnsafeCodePointerAccessExpressionMatcher(IUnsafeCodePointerAccessExpression expression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodePointerIndirectionExpressionMatcher : CSharpElementMatcher`1<IUnsafeCodePointerIndirectionExpression> {
    public UnsafeCodePointerIndirectionExpressionMatcher(IUnsafeCodePointerIndirectionExpression expression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeSizeOfExpressionMatcher : CSharpElementMatcher`1<IUnsafeCodeSizeOfExpression> {
    public IEnumerable`1<string> Words { get; }
    public UnsafeCodeSizeOfExpressionMatcher(IUnsafeCodeSizeOfExpression expression, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeSizeOfExpressionMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeStackAllocExpressionMatcher : CSharpElementMatcher`1<IStackAllocExpression> {
    public UnsafeCodeStackAllocExpressionMatcher(IStackAllocExpression initializer, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeUnsafeStatementMatcher : CSharpElementMatcher`1<IUnsafeCodeUnsafeStatement> {
    public IEnumerable`1<string> Words { get; }
    public UnsafeCodeUnsafeStatementMatcher(IUnsafeCodeUnsafeStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UnsafeCodeUnsafeStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UsingStatementMatcher : CSharpElementMatcher`1<IUsingStatement> {
    public IEnumerable`1<string> Words { get; }
    public UsingStatementMatcher(IUsingStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.UsingStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.VarDeconstructionPatternMatcher : CSharpElementMatcher`1<IVarDeconstructionPattern> {
    public VarDeconstructionPatternMatcher(IVarDeconstructionPattern varDeconstructionPattern, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.VarPatternMatcher : CSharpElementMatcher`1<IVarPattern> {
    public VarPatternMatcher(IVarPattern varPattern, PatternMatcherBuilderParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.WhileStatementMatcher : CSharpElementMatcher`1<IWhileStatement> {
    public IEnumerable`1<string> Words { get; }
    public WhileStatementMatcher(IWhileStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.WhileStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.WithExpressionMatcher : CSharpElementMatcher`1<IWithExpression> {
    public WithExpressionMatcher(IWithExpression withExpression, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.WithInitializerAssignmentMatcher : CSharpElementMatcher`1<IWithInitializerAssignment> {
    public WithInitializerAssignmentMatcher(IWithInitializerAssignment assignment, PatternMatcherBuilderParams params);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.YieldStatementMatcher : CSharpElementMatcher`1<IYieldStatement> {
    public IEnumerable`1<string> Words { get; }
    public YieldStatementMatcher(IYieldStatement statement, PatternMatcherBuilderParams params);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Matchers.YieldStatementMatcher/<get_Words>d__2")]
public virtual IEnumerable`1<string> get_Words();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.NullableTypeMatcher`1 : object {
    [NotNullAttribute]
private Func`2<TTreeNode, IType> myGetElementType;
    [NotNullAttribute]
private ITypeMatcher myElementTypeMatcher;
    public string ShortName { get; }
    public NullableTypeMatcher`1(INullableTypeUsage typeUsageNode, Func`2<TTreeNode, IType> getElementType, PatternMatcherBuilderParams params);
    public sealed virtual bool MatchType(ITreeNode element, IMatchingContext context);
    public sealed virtual bool MatchType(ITreeNode element, IType elementType, IMatchingContext context);
    public sealed virtual string get_ShortName();
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Parsers.CSharpPlaceholderArgumentsReader : object {
    private static char Comma;
    private static char SingleQuote;
    private static string True;
    private static string False;
    public static LocalList`1<PlaceholderArgument> Read(string arguments);
    [CanBeNullAttribute]
private static PlaceholderArgument TryCreateIntPlaceholderArgument(string value);
    [CanBeNullAttribute]
private static PlaceholderArgument TryCreateBoolPlaceholderArgument(string value);
    [CompilerGeneratedAttribute]
internal static void <Read>g__TryCreatePlaceholderArgumentFromCurrentValue|5_0(<>c__DisplayClass5_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Parsers.CSharpStructuralSearchAttributePatternBuilder : object {
    private bool myGuessPlaceholders;
    public CSharpStructuralSearchAttributePatternBuilder(bool guessPlaceholders);
    public sealed virtual IStructuralMatcher CreateMatcher(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
    public sealed virtual IPatternLexerResult ParsePattern(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Parsers.CSharpStructuralSearchClassPatternBuilder : object {
    private bool myGuessPlaceholders;
    public CSharpStructuralSearchClassPatternBuilder(bool guessPlaceholders);
    public sealed virtual IStructuralMatcher CreateMatcher(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
    public sealed virtual IPatternLexerResult ParsePattern(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Parsers.CSharpStructuralSearchExpressionPatternBuilder : object {
    public static CSharpStructuralSearchExpressionPatternBuilder Instance;
    private bool myGuessPlaceholders;
    public CSharpStructuralSearchExpressionPatternBuilder(bool guessPlaceholders);
    private static CSharpStructuralSearchExpressionPatternBuilder();
    public sealed virtual IStructuralMatcher CreateMatcher(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
    [CanBeNullAttribute]
public IElementMatcher CreateElementMatcher(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
    public sealed virtual IPatternLexerResult ParsePattern(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Parsers.CSharpStructuralSearchStatementsPatternBuilder : object {
    public static CSharpStructuralSearchStatementsPatternBuilder Instance;
    private bool myGuessPlaceholders;
    public CSharpStructuralSearchStatementsPatternBuilder(bool guessPlaceholders);
    private static CSharpStructuralSearchStatementsPatternBuilder();
    public sealed virtual IStructuralMatcher CreateMatcher(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
    public sealed virtual IPatternLexerResult ParsePattern(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Parsers.CSharpStructuralSearchTypeMemberPatternBuilder : object {
    private bool myGuessPlaceholders;
    public CSharpStructuralSearchTypeMemberPatternBuilder(bool guessPlaceholders);
    public sealed virtual IStructuralMatcher CreateMatcher(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
    public sealed virtual IPatternLexerResult ParsePattern(string pattern, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Parsers.PlaceholderArgument : object {
    [CompilerGeneratedAttribute]
private PlaceholderArgumentType <ArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public PlaceholderArgumentType ArgumentType { get; }
    public object Value { get; }
    public PlaceholderArgument(PlaceholderArgumentType argumentType, object value);
    [CompilerGeneratedAttribute]
public PlaceholderArgumentType get_ArgumentType();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Parsers.PlaceholderArgumentType : Enum {
    public int value__;
    public static PlaceholderArgumentType None;
    public static PlaceholderArgumentType Int;
    public static PlaceholderArgumentType String;
    public static PlaceholderArgumentType Identifier;
    public static PlaceholderArgumentType Boolean;
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.ArgumentPlaceholder : SequencePlaceholderBase {
    [NotNullAttribute]
private static String[] ourReplacingText;
    [NotNullAttribute]
public static string TAG_NAME;
    public String[] ReplacingText { get; }
    protected string TagName { get; }
    protected string EntityName { get; }
    public ArgumentPlaceholder(string name, int minimalOccurrences, int maximalOccurrences);
    public ArgumentPlaceholder(PlaceholderInfo placeholderInfo);
    private static ArgumentPlaceholder();
    public virtual String[] get_ReplacingText();
    public virtual IPlaceholder Clone();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    protected virtual string get_TagName();
    protected virtual string get_EntityName();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.ArgumentPlaceholderMatcher : SequencePlaceholderMatcherBase {
    private PatternMatcherBuilderParams myParams;
    public ArgumentPlaceholderMatcher(ArgumentPlaceholder placeholder, StructuralSearchPatternParams params);
    public virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
    public virtual ISequenceMatcher`1<ITreeNode> CreatePlaceholderMatcher(ICollection`1<ITreeNode> elements);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.CSharpUnknownPlaceholder : UnknownPlaceholder {
    private static String[] ourReplacingText;
    public String[] ReplacingText { get; }
    public CSharpUnknownPlaceholder(string name);
    private static CSharpUnknownPlaceholder();
    public virtual String[] get_ReplacingText();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.DeclaredTypePlaceholderMatcher : PlaceholderTypeMatcherBase {
    [CanBeNullAttribute]
private Func`2<ITreeNode, ITypeUsage> myGetDeclaredTypeUsage;
    public DeclaredTypePlaceholderMatcher(TypePlaceholder placeholder, Func`2<ITreeNode, ITypeUsage> getDeclaredTypeUsage);
    public virtual IType GetElementType(ITreeNode element);
    [CanBeNullAttribute]
internal ITypeUsage GetTypeUsage(ITreeNode element);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.ElementPlaceholder : PlaceholderBase {
    [CanBeNullAttribute]
private ITreeNode myElement;
    [NotNullAttribute]
private static String[] ourReplacingTextStatement;
    [NotNullAttribute]
private static String[] ourReplacingTextOther;
    public string Description { get; }
    public String[] ReplacingText { get; }
    public ElementPlaceholder(string name, ITreeNode element);
    private static ElementPlaceholder();
    public virtual string get_Description();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    public virtual String[] get_ReplacingText();
    public virtual PlaceholderInfo ToPlaceholderInfo();
    public virtual IPlaceholder Clone();
    public bool Equals(ElementPlaceholder other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.ElementPlaceholderMatcher : object {
    private IElementMatcher myElementMatcher;
    private string myPlaceholderName;
    public IEnumerable`1<IElementMatcher> Children { get; }
    public IEnumerable`1<string> Words { get; }
    public string PlaceholderName { get; }
    public ElementPlaceholderMatcher(string placeholderName, ITreeNode element, StructuralSearchPatternParams params);
    public sealed virtual bool Match(ITreeNode element, IMatchingContext context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.ElementPlaceholderMatcher/<get_Children>d__5")]
public sealed virtual IEnumerable`1<IElementMatcher> get_Children();
    public sealed virtual IEnumerable`1<string> get_Words();
    public sealed virtual string get_PlaceholderName();
    public sealed virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.ExpressionPlaceholder : PlaceholderBase {
    [NotNullAttribute]
private static String[] ourReplacingText;
    [CanBeNullAttribute]
private IDictionary`2<string, IPlaceholder> myPlaceholders;
    private string myExpressionType;
    private bool myExactType;
    public static string TAG_NAME;
    private static string EXPRESSION_TYPE_ATTRIBUTE;
    private static string EXACT_TYPE_ATTRIBUTE;
    public string ExpressionType { get; public set; }
    public bool ExactType { get; public set; }
    public String[] ReplacingText { get; }
    public string Description { get; }
    public ExpressionPlaceholder(string name, string expressionType, bool exactType);
    public ExpressionPlaceholder(PlaceholderInfo placeholderInfo);
    private static ExpressionPlaceholder();
    public string get_ExpressionType();
    public void set_ExpressionType(string value);
    public bool get_ExactType();
    public void set_ExactType(bool value);
    public virtual String[] get_ReplacingText();
    public virtual PlaceholderInfo ToPlaceholderInfo();
    public virtual IPlaceholder Clone();
    public virtual string get_Description();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    public bool Equals(ExpressionPlaceholder other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void UsePlaceholders(IDictionary`2<string, IPlaceholder> placeholders);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.ExpressionPlaceholderMatcher : PlaceholderMatcherBase {
    private ITypeMatcher myTypeMatcher;
    private PatternMatcherBuilderParams myParams;
    public ExpressionPlaceholderMatcher(ExpressionPlaceholder placeholder, IDictionary`2<string, IPlaceholder> placeholders, StructuralSearchPatternParams params);
    public virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    [CanBeNullAttribute]
[PureAttribute]
private static ICSharpExpression UnwrapExpression(ITreeNode element);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.IdentifierPlaceholder : PlaceholderBase {
    [NotNullAttribute]
private static String[] ourReplacingText;
    [CanBeNullAttribute]
private string myType;
    private bool myExactType;
    public static string TAG_NAME;
    private static string REGEX_ATTRIBUTE;
    private static string CASE_SENSITIVE_ATTRIBUTE;
    private static string TYPE_ATTRIBUTE;
    private static string EXACT_TYPE_ATTRIBUTE;
    [CompilerGeneratedAttribute]
private Regex <NameRegex>k__BackingField;
    [CanBeNullAttribute]
public Regex NameRegex { get; public set; }
    [CanBeNullAttribute]
public string Type { get; private set; }
    public bool ExactType { get; private set; }
    [NotNullAttribute]
public string NameRegexText { get; public set; }
    public bool NameRegexIsCaseSensitive { get; public set; }
    public String[] ReplacingText { get; }
    public string Description { get; }
    public IdentifierPlaceholder(string name, string nameRegex, bool nameRegexCaseSensitive, string type, bool exactType);
    public IdentifierPlaceholder(PlaceholderInfo placeholderInfo);
    private static IdentifierPlaceholder();
    [CompilerGeneratedAttribute]
public Regex get_NameRegex();
    [CompilerGeneratedAttribute]
public void set_NameRegex(Regex value);
    public string get_Type();
    private void set_Type(string value);
    public bool get_ExactType();
    private void set_ExactType(bool value);
    public string get_NameRegexText();
    public void set_NameRegexText(string value);
    public bool get_NameRegexIsCaseSensitive();
    public void set_NameRegexIsCaseSensitive(bool value);
    public virtual String[] get_ReplacingText();
    public virtual PlaceholderInfo ToPlaceholderInfo();
    public virtual IPlaceholder Clone();
    public virtual string get_Description();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    public bool Equals(IdentifierPlaceholder other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.IdentifierPlaceholderMatcher : PlaceholderMatcherBase {
    private PatternMatcherBuilderParams myParams;
    private Regex myNameRegex;
    private IdentifierPlaceholderTypeMatcher myTypeMatcher;
    public IdentifierPlaceholderMatcher(IdentifierPlaceholder placeholder, StructuralSearchPatternParams params);
    public virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    [CanBeNullAttribute]
private static string GetName(ITreeNode element);
}
public interface JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.IOtherPlaceholdersAwarePlaceholder {
    public abstract virtual void UsePlaceholders(IDictionary`2<string, IPlaceholder> placeholders);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.MemberPlaceholder : PlaceholderBase {
    [NotNullAttribute]
private static String[] ourReplacingText;
    [CanBeNullAttribute]
private string myDocId;
    private IDictionary`2<string, IPlaceholder> myPlaceholders;
    public static string TAG_NAME;
    private static string DOC_ID_ATTRIBUTE;
    [CanBeNullAttribute]
public string DocId { get; public set; }
    public String[] ReplacingText { get; }
    public string Description { get; }
    public MemberPlaceholder(string name, string docId);
    public MemberPlaceholder(PlaceholderInfo placeholderInfo);
    private static MemberPlaceholder();
    public string get_DocId();
    public void set_DocId(string value);
    public virtual String[] get_ReplacingText();
    public virtual PlaceholderInfo ToPlaceholderInfo();
    public virtual IPlaceholder Clone();
    public virtual string get_Description();
    private bool ContainsQualifierPlaceholder();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    private bool Equals(MemberPlaceholder other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void UsePlaceholders(IDictionary`2<string, IPlaceholder> placeholders);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.MemberPlaceholderMatcher : PlaceholderMatcherBase {
    private PatternMatcherBuilderParams myParams;
    private string myDocId;
    private bool myQualifiedOnly;
    public MemberPlaceholderMatcher(MemberPlaceholder placeholder, StructuralSearchPatternParams params, bool qualifiedOnly);
    public virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
    [CanBeNullAttribute]
private static ITreeNode GetPossibleMemberElement(ITreeNode element);
    [CanBeNullAttribute]
private static string GetXMLDocId(ITreeNode element);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.MemberQualifierPlaceholder : PlaceholderBase {
    public static string QualifierPlaceholderName;
    [NotNullAttribute]
private static String[] ourReplacingText;
    public String[] ReplacingText { get; }
    public string Description { get; }
    private MemberQualifierPlaceholder(string name);
    private static MemberQualifierPlaceholder();
    public virtual String[] get_ReplacingText();
    public virtual string get_Description();
    public virtual PlaceholderInfo ToPlaceholderInfo();
    public virtual IPlaceholder Clone();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.MemberQualifierPlaceholderMatcher : object {
    [CompilerGeneratedAttribute]
private string <PlaceholderName>k__BackingField;
    public IEnumerable`1<IElementMatcher> Children { get; }
    public IEnumerable`1<string> Words { get; }
    public string PlaceholderName { get; }
    public MemberQualifierPlaceholderMatcher(string name);
    public sealed virtual bool Match(ITreeNode element, IMatchingContext context);
    public sealed virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.MemberQualifierPlaceholderMatcher/<get_Children>d__4")]
public sealed virtual IEnumerable`1<IElementMatcher> get_Children();
    public sealed virtual IEnumerable`1<string> get_Words();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PlaceholderName();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.MetaPlaceholder : object {
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
private static String[] ourReplacingText;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public string Name { get; }
    public string Description { get; }
    public String[] ReplacingText { get; }
    public ICollection`1<string> Words { get; }
    public MetaPlaceholder(string name);
    private static MetaPlaceholder();
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    public sealed virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    public sealed virtual String[] get_ReplacingText();
    public sealed virtual ICollection`1<string> get_Words();
    public sealed virtual PlaceholderInfo ToPlaceholderInfo();
    public sealed virtual IPlaceholder Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public bool Equals(MetaPlaceholder other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.PatternPlaceholder : PlaceholderBase {
    private PatternPlaceholderMatcher myPatternPlaceholderMatcher;
    [CanBeNullAttribute]
private string myPattern;
    [NotNullAttribute]
private static String[] ourReplacingText;
    public string Description { get; }
    public String[] ReplacingText { get; }
    public PatternPlaceholder(string name, IElementMatcher elementMatcher, string pattern);
    private PatternPlaceholder(string name, PatternPlaceholderMatcher patternPlaceholderMatcher, string pattern);
    private static PatternPlaceholder();
    public virtual string get_Description();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    public virtual String[] get_ReplacingText();
    public virtual PlaceholderInfo ToPlaceholderInfo();
    public virtual IPlaceholder Clone();
    public bool Equals(PatternPlaceholder other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.PatternPlaceholderMatcher : object {
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
private IElementMatcher myElementMatcher;
    public IEnumerable`1<IElementMatcher> Children { get; }
    public IEnumerable`1<string> Words { get; }
    public string PlaceholderName { get; }
    public PatternPlaceholderMatcher(string name, IElementMatcher elementMatcher);
    public sealed virtual bool Match(ITreeNode element, IMatchingContext context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.PatternPlaceholderMatcher/<get_Children>d__5")]
public sealed virtual IEnumerable`1<IElementMatcher> get_Children();
    public sealed virtual IEnumerable`1<string> get_Words();
    public sealed virtual string get_PlaceholderName();
    public sealed virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.PlaceholderTypeMatcherBase : object {
    private string myPlaceholderName;
    [CanBeNullAttribute]
protected string myType;
    private bool myExactType;
    public string PlaceholderName { get; }
    public bool ExactType { get; }
    public string ShortName { get; }
    protected PlaceholderTypeMatcherBase(string placeholderName, string type, bool exactType);
    public sealed virtual string get_PlaceholderName();
    public sealed virtual IType GetPlaceholderType(ITreeNode element);
    public abstract virtual IType GetElementType(ITreeNode element);
    public sealed virtual bool get_ExactType();
    public sealed virtual bool MatchType(ITreeNode element, IMatchingContext context);
    public virtual bool MatchType(ITreeNode element, IType elementType, IMatchingContext context);
    public sealed virtual string get_ShortName();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.StatementPlaceholder : SequencePlaceholderBase {
    private static String[] ourReplacingText;
    public static string TAG_NAME;
    public String[] ReplacingText { get; }
    protected string TagName { get; }
    protected string EntityName { get; }
    public StatementPlaceholder(string name, int minimalOccurrences, int maximalOccurrences);
    public StatementPlaceholder(PlaceholderInfo placeholderInfo);
    private static StatementPlaceholder();
    public virtual String[] get_ReplacingText();
    public virtual IPlaceholder Clone();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    protected virtual string get_TagName();
    protected virtual string get_EntityName();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.StatementPlaceholderMatcher : SequencePlaceholderMatcherBase {
    [NotNullAttribute]
private PatternMatcherBuilderParams myParams;
    public StatementPlaceholderMatcher(StatementPlaceholder placeholder, StructuralSearchPatternParams params);
    public virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
    public virtual ISequenceMatcher`1<ITreeNode> CreatePlaceholderMatcher(ICollection`1<ITreeNode> elements);
    public virtual bool Match(ITreeNode element, IMatchingContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.TypeParameterDeclarationTypeMatcher : object {
    private string myName;
    public string ShortName { get; }
    public TypeParameterDeclarationTypeMatcher(ITypeParameterDeclaration typeParameter);
    public sealed virtual bool MatchType(ITreeNode element, IMatchingContext context);
    public sealed virtual bool MatchType(ITreeNode element, IType elementType, IMatchingContext context);
    public sealed virtual string get_ShortName();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.TypePlaceholder : PlaceholderBase {
    private static String[] ourReplacingText;
    private IDictionary`2<string, IPlaceholder> myPlaceholders;
    private string myType;
    private bool myExactType;
    public static string TAG_NAME;
    private static string TYPE_ATTRIBUTE;
    private static string EXACT_TYPE_ATTRIBUTE;
    public string Type { get; public set; }
    public bool ExactType { get; public set; }
    public string Description { get; }
    public String[] ReplacingText { get; }
    public TypePlaceholder(string name, string type, bool exactType);
    public TypePlaceholder(PlaceholderInfo placeholderInfo);
    private static TypePlaceholder();
    public string get_Type();
    public void set_Type(string value);
    public bool get_ExactType();
    public void set_ExactType(bool value);
    public sealed virtual void UsePlaceholders(IDictionary`2<string, IPlaceholder> placeholders);
    [NotNullAttribute]
public ITypeMatcher GetTypeMatcher(Func`2<ITreeNode, IType> getElementType, bool matchVoid);
    public ITypeMatcher GetDeclaredTypeMatcher(Func`2<ITreeNode, ITypeUsage> getDeclaredTypeUsage);
    public virtual string get_Description();
    public virtual IPlaceholderMatcher CreateMatcher(StructuralSearchPatternParams params);
    public virtual String[] get_ReplacingText();
    public virtual PlaceholderInfo ToPlaceholderInfo();
    public virtual IPlaceholder Clone();
    public bool Equals(TypePlaceholder other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.TypePlaceholderElementMatcher : object {
    [NotNullAttribute]
private TypePlaceholder myPlaceholder;
    private bool myMatchVoid;
    public IEnumerable`1<IElementMatcher> Children { get; }
    public IEnumerable`1<string> Words { get; }
    public string PlaceholderName { get; }
    internal TypePlaceholder Placeholder { get; }
    public TypePlaceholderElementMatcher(TypePlaceholder placeholder, bool matchVoid);
    public sealed virtual bool Match(ITreeNode element, IMatchingContext context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.TypePlaceholderElementMatcher/<get_Children>d__5")]
public sealed virtual IEnumerable`1<IElementMatcher> get_Children();
    public sealed virtual IEnumerable`1<string> get_Words();
    public sealed virtual string get_PlaceholderName();
    internal TypePlaceholder get_Placeholder();
    public sealed virtual IElementMatcher CreatePlaceholderMatcher(ITreeNode element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.TypePlaceholderMatcher : PlaceholderTypeMatcherBase {
    [CanBeNullAttribute]
private Func`2<ITreeNode, IType> myGetElementType;
    private bool myMatchVoid;
    public TypePlaceholderMatcher(TypePlaceholder placeholder, Func`2<ITreeNode, IType> getElementType, bool matchVoid);
    public virtual IType GetElementType(ITreeNode element);
    public virtual bool MatchType(ITreeNode element, IType elementType, IMatchingContext context);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.Placeholders.TypePlacholderHelper : object {
    public static Tuple`2<string, PlaceholderUsagesCollection> ParsePlaceholderType(string type, IDictionary`2<string, IPlaceholder> placeholders);
    [NotNullAttribute]
private static string ReplacePlaceholders(string type, SortedList`2<int, Pair`2<Match, IPlaceholder>> matches);
    public static ITypeUsage CreateDeclaredTypeUsageNode(string typeName);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.StructuralSearch.PointerTypeMatcher`1 : object {
    [NotNullAttribute]
private Func`2<TTreeNode, IType> myGetElementType;
    [NotNullAttribute]
private ITypeMatcher myElementTypeMatcher;
    public string ShortName { get; }
    public PointerTypeMatcher`1(IPointerTypeUsage typeUsageNode, Func`2<TTreeNode, IType> getElementType, PatternMatcherBuilderParams params);
    public sealed virtual bool MatchType(ITreeNode element, IMatchingContext context);
    public sealed virtual bool MatchType(ITreeNode element, IType elementType, IMatchingContext context);
    public sealed virtual string get_ShortName();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TodoItems.CSharpTodoContentsProvider : DefaultTodoContentsProvider {
    public virtual Nullable`1<TextRange> GetTokenContentsRange(string documentText, TextRange tokenRange, TokenNodeType tokenType);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeConversionHints.CSharpTypeConversionHintHighlightingContext : TypeConversionHintHighlightingContext`1<CSharpTypeConversionHintsOptions> {
    [CompilerGeneratedAttribute]
private ITypeConversionHintsExclusionListMatcher <ExclusionListMatcher>k__BackingField;
    public ITypeConversionHintsExclusionListMatcher ExclusionListMatcher { get; }
    public CSharpTypeConversionHintHighlightingContext(IContextBoundSettingsStore contextBoundSettingsStore, CSharpTypeConversionHintsExclusionListStore exclusionListStore);
    [CompilerGeneratedAttribute]
public ITypeConversionHintsExclusionListMatcher get_ExclusionListMatcher();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeConversionHints.CSharpTypeConversionHintsBulbActionsProvider : TypeConversionHintBulbActionsProvider`1<CSharpTypeConversionHintsOptions> {
    public virtual string GetOptionsPageId();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeConversionHints.CSharpTypeConversionHintsExclusionListMatcher : object {
    private IList`1<Predicate`1<string>> myMatchers;
    public CSharpTypeConversionHintsExclusionListMatcher(IEnumerable`1<string> initialPatterns);
    public sealed virtual bool Match(string operator);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeConversionHints.CSharpTypeConversionHintsExclusionListStore : TypeConversionHintsExclusionListStore {
    private Guid myExclusionListCacheKey;
    private InlayHintsExclusionListManager myExclusionListManager;
    public CSharpTypeConversionHintsExclusionListStore(InlayHintsExclusionListManager exclusionListManager);
    public virtual Guid GetExclusionListCacheKey();
    public virtual SettingsIndexedEntry GetIndexedEntry(IContextBoundSettingsStore settingsStore);
    public CSharpTypeConversionHintsExclusionListMatcher GetMatcher(IContextBoundSettingsStore settingsStore);
}
[SettingsKeyAttribute("JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.InlayHintsSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ReSharperCTypeConversionHintsSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeConversionHints.CSharpTypeConversionHintsOptions : TypeConversionHintsOptions {
}
[OptionsPageAttribute("CSharpTypeConversionHintsOptions", "Type Conversion Hints", "JetBrains.Application.UI.Icons.FeaturesIntellisenseThemedIcons.FeaturesIntellisenseThemedIcons/ParameterInfoPage")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeConversionHints.CSharpTypeConversionHintsOptionsPage : InlayHintsOptionPageBase {
    public static string PID;
    public CSharpTypeConversionHintsOptionsPage(Lifetime lifetime, OptionsPageContext optionsPageContext, OptionsSettingsSmartContext optionsSettingsSmartContext, IconHostBase iconHost, CSharpTypeConversionHintsExclusionListStore exclusionListStore);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeConversionHints.CSharpTypeConversionHintsOptionStore : object {
    public CSharpTypeConversionHintsOptionStore(InlayHintsOptionsStore inlayHintsOptionsStore, ISettingsStore settingsStore);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeConversionHints.ZoneMarker : object {
}
[SettingsKeyAttribute("JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.InlayHintsSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "ReSharperCTypeNameHintsSettingsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeNameHints.CSharpTypeNameHintsOptions : TypeNameHintsOptionsBase {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "VisibilityModeOfTypeNameHintsForTargetTypedNewExpressionsSettingDescription")]
public PushToHintMode ShowTypeNameHintsForTargetTypedNewExpression;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "WhetherToHideTypeNameHintsForTargetTypedNewExpressionsIfTheTypeIsEvidentSettingDescription")]
public bool HideTypeNameHintsForTargetTypedNewExpressionsWhenEvident;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "VisibilityModeOfTypeNameHintsForPatternMatchingExpressionsSettingDescription")]
public PushToHintMode ShowTypeNameHintsForPatternMatchingExpressions;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "VisibilityModeOfTypeNameHintsForLambdaExpressionParametersSettingDescription")]
public PushToHintMode ShowTypeNameHintsForLambdaExpressionParameters;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "WhetherToHideTypeNameHintsForLambdaExpressionParametersIfTheTypeIsEvidentSettingDescription")]
public bool HideTypeNameHintsForLambdaExpressionParametersWhenEvident;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "VisibilityModeOfTypeNameHintsForQueryRangeVariablesInLINQQueriesSettingDescription")]
public PushToHintMode ShowTypeNameHintsForLinqQueryRangeVariables;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "WhetherToIncludePropertyFieldAndVariableAccessorsInTheInvocationChainSettingDescription")]
public bool IncludePropertyFieldAndVariableAccessorsInChain;
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeNameHints.CSharpTypeNameHintsOptionsMigration : TypeNameHintsMigration`1<CSharpTypeNameHintsOptions> {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.TypeNameHints.CSharpTypeNameHintsOptionsMigration/<GetEntriesToMigrate>d__0")]
public virtual IEnumerable`1<SettingsEntry> GetEntriesToMigrate(ISettingsSchema schema);
    public virtual void Migrate(IContextBoundSettingsStoreImplementation store);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<SettingsEntry> <>n__0(ISettingsSchema schema);
}
[OptionsPageAttribute("CSharpTypeNameHintsOptions", "Type Name Hints", "JetBrains.Application.UI.Icons.FeaturesIntellisenseThemedIcons.FeaturesIntellisenseThemedIcons/ParameterInfoPage")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeNameHints.CSharpTypeNameHintsOptionsPage : InlayHintsOptionPageBase {
    public static string PID;
    public CSharpTypeNameHintsOptionsPage(Lifetime lifetime, OptionsPageContext optionsPageContext, OptionsSettingsSmartContext optionsSettingsSmartContext);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeNameHints.CSharpTypeNameHintsOptionStore : object {
    public CSharpTypeNameHintsOptionStore(InlayHintsOptionsStore inlayHintsOptionsStore, ISettingsStore settingsStore);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeNameHints.ZoneMarker : object {
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeSuggestion.CSharpExpressionTypeSuggestionService : ExpressionTypeSuggestionService {
    public virtual ImplicitTypingOption SuggestImplicitTypingOption(ITreeNode initializerNode);
    public virtual bool IsTargetTyped(ITreeNode initializerNode);
    public virtual bool SuggestImplicitTypingPrefference(ITreeNode initializerNode, IType defaultSuggestedType);
    public virtual IList`1<IType> SuggestPossibleTypes(ITreeNode initializerNode, IReadOnlyList`1<IExpression> expressions, ConstnessOption& constKind);
    public virtual IList`1<IType> SuggestITypeForExpressionType(IExpression expression);
    [NotNullAttribute]
public static IList`1<IType> SuggestITypeForExpressionType(IExpressionType expressionType, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
private static IType TryGetStringInterpolationType(IReadOnlyList`1<IExpression> expressions, ICSharpTypeConversionRule conversionRule);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.TypeSuggestion.CSharpTypeTemplateExpression : SuggestedNameTemplateExpression {
    private ConstnessOption myConstKind;
    private ImplicitTypingOption myImplicitTypingOption;
    private bool myImplicitIsPreferred;
    private bool myIsTargetTyped;
    [NotNullAttribute]
private IList`1<ITypePointer> myTypePointers;
    [NotNullAttribute]
private IModuleReferenceResolveContext myModuleReferenceResolveContext;
    public CSharpTypeTemplateExpression(ExpressionTypeSuggestion suggestion);
    public CSharpTypeTemplateExpression(ExpressionTypeSuggestion suggestion, ConstnessOption constKind);
    protected virtual IList`1<ILookupItem> GetLookupItemsImpl(IHotspotContext context);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpAngleBracketMatcher : BracketMatcher {
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.Options.TypingAssistSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CAnnotationTypingAssistOptionsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpAnnotationTypingAssistSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "AnnotateNullabilityOnAfterTypeNameSettingDescription")]
public bool IsEnabledAfterTypeName;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "AnnotateNullabilityOnAfterEntityNameSettingDescription")]
[ObsoleteAttribute]
public bool IsEnabledAfterEntityName;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Insert parameter null-check on '!' after type or name when already annotated")]
public bool IsInsertNullCheckWhenAlreadyAnnotated;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "AnnotateNullabilityOnAtOtherPositionsSettingDescription")]
public bool IsEnabledAtOtherPositions;
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpAnnotationTypingAssistSettingsAccessor : object {
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpAnnotationTypingAssistSettings, bool>> IsEnabledAfterTypeName;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpAnnotationTypingAssistSettings, bool>> IsEnabledAtOtherPositions;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpAnnotationTypingAssistSettings, bool>> IsInsertNullCheckWhenAlreadyAnnotated;
    private static CSharpAnnotationTypingAssistSettingsAccessor();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpBraceMatcher : BracketMatcher {
}
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpBracketMatcher : BracketMatcher {
}
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpInterpolatedRawLiteralMatcher : BracketMatcher {
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpTypingAssist : CSharpTypingAssistBase {
    public CSharpTypingAssist(Lifetime lifetime, TypingAssistDependencies dependencies, DocumentTransactionManager documentTransactionManager, IOptional`1<ICodeCompletionSessionManager> codeCompletionSessionManager);
    protected virtual bool IsSupported(ITextControl textControl);
    public virtual bool QuickCheckAvailability(ITextControl textControl, IPsiSourceFile projectFile);
    protected virtual void ApplyCodeStyleBeforeFormattingOnSemicolon(ITreeNode treeNode);
    [NotNullAttribute]
protected virtual string GetIndentBeforeToken(ITextControl textControl, CachingLexer lexer);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpTypingAssistBase : TypingAssistForCLikeLanguage`1<CSharpLanguage> {
    [NotNullAttribute]
private DocumentTransactionManager myDocumentTransactionManager;
    [CanBeNullAttribute]
private ICodeCompletionSessionManager myCodeCompletionSessionManager;
    private static NodeTypeSet ourTypeParamTokens;
    private NodeTypeSet myRawLiteralStart;
    private NodeTypeSet myRawLiterals;
    [CompilerGeneratedAttribute]
private NodeTypeSet <ACCESS_CHAIN_TOKENS>k__BackingField;
    private static NodeTypeSet ourAutoCloseBraceSet;
    private static NodeTypeSet ourSkipCloseBraceSet;
    private static NodeTypeSet ourStringLiterals;
    [NotNullAttribute]
private static NodeTypeSet ourFinishedStringInterpolationTokens;
    [NotNullAttribute]
private static NodeTypeSet ourUnfinishedStringInterpolationTokens;
    private static NodeTypeSet ourSkipDollarSet;
    private static NodeTypeSet ourSkipDollarExceptBorderSet;
    protected static string SmartDoubleQuotesAction;
    protected TokenNodeType LBRACKET { get; }
    protected TokenNodeType RBRACKET { get; }
    protected TokenNodeType LPARENTH { get; }
    protected TokenNodeType LBRACE { get; }
    protected TokenNodeType SEMICOLON { get; }
    protected TokenNodeType RBRACE { get; }
    protected TokenNodeType RPARENTH { get; }
    protected TokenNodeType WHITE_SPACE { get; }
    protected TokenNodeType NEW_LINE { get; }
    protected NodeTypeSet STRING_LITERALS { get; }
    protected NodeTypeSet ACCESS_CHAIN_TOKENS { get; }
    protected TokenNodeType END_OF_LINE_COMMENT { get; }
    protected TokenNodeType C_STYLE_COMMENT { get; }
    protected TokenNodeType PLUS { get; }
    protected TokenNodeType DOT { get; }
    protected CSharpTypingAssistBase(Lifetime lifetime, TypingAssistDependencies dependencies, DocumentTransactionManager documentTransactionManager, IOptional`1<ICodeCompletionSessionManager> codeCompletionSessionManager);
    private static CSharpTypingAssistBase();
    private bool HandleEqualsTyped(ITypingContext typingContext);
    protected virtual bool IsTypingDigitHandlerAvailable(ITypingContext context);
    private bool HandleDigitTyped(ITypingContext context);
    protected virtual void ExecuteAutoCompletion(ITextControl textControl, char typedChar);
    protected virtual bool RevertDotAccessTypoCorrectionActionIfNeeded(ITypingContext typingContext);
    protected virtual bool IsDelHandlerAvailable(IActionContext context);
    protected virtual bool IsCutHandlerAvailable(IActionContext context);
    protected virtual bool IsEnterHandlerAvailable(IActionContext context);
    protected virtual bool IsLeftParHandlerAvailable(ITypingContext context);
    protected virtual bool IsRightBraceHandlerAvailable(ITypingContext context);
    protected virtual bool IsLeftBraceHandlerAvailable(ITypingContext obj);
    protected virtual bool IsWordDeleteToStartHandlerAvailable(IActionContext context);
    protected virtual bool IsWordDeleteToEndHandlerAvailable(IActionContext context);
    public virtual bool HandleTabPressed(IActionContext context);
    private bool SkipCloseBracketOnTab(IActionContext context);
    protected virtual bool GetAutoInsertDataForRBrace(ITextControl textControl, ITokenNode rBraceToken, TreeTextRange treeLBraceRange, DocumentOffset lBracePos, int position, IDocument document, DocumentOffset& positionForRBrace, String& rBraceText, IFile& file);
    protected virtual TokenNodeType get_LBRACKET();
    protected virtual TokenNodeType get_RBRACKET();
    protected virtual TokenNodeType get_LPARENTH();
    protected virtual TokenNodeType get_LBRACE();
    protected virtual TokenNodeType get_SEMICOLON();
    protected virtual TokenNodeType get_RBRACE();
    protected virtual TokenNodeType get_RPARENTH();
    protected virtual TokenNodeType get_WHITE_SPACE();
    protected virtual TokenNodeType get_NEW_LINE();
    protected virtual NodeTypeSet get_STRING_LITERALS();
    [CompilerGeneratedAttribute]
protected virtual NodeTypeSet get_ACCESS_CHAIN_TOKENS();
    protected virtual TokenNodeType get_END_OF_LINE_COMMENT();
    protected virtual TokenNodeType get_C_STYLE_COMMENT();
    protected virtual TokenNodeType get_PLUS();
    protected virtual TokenNodeType get_DOT();
    protected virtual bool IsTokenSuitableForCloseBracket(TokenNodeType nextTokenType);
    protected virtual bool HandleLeftBraceTyped(ITypingContext typingContext);
    [PureAttribute]
private static bool ShouldPerformExpressionToStatementConversion(CachingLexer lexer, int caretOffset);
    protected virtual bool AutoInsertRBraceInString(ITextControl textControl, CachingLexer lexer, int charPos);
    protected virtual bool SkipRBraceInString(ITextControl textControl, CachingLexer lexer, int charPos);
    public virtual Pair`2<ITreeRange, ITreeRangePointer> GetRangeToFormatAfterRBrace(ITextControl textControl);
    protected virtual bool AreChainedMethodCallsAligned(ITextControl textControl);
    private ITreeRange GetRangeToFormatFromBrace(ITokenNode tokenNode);
    [CanBeNullAttribute]
private ITreeRange GetRangeToFormatFromBracedBody(ITreeNode body);
    protected virtual bool IsLBrace(ITextControl textControl, CachingLexer lexer);
    protected virtual bool IsRBrace(ITextControl textControl, CachingLexer lexer);
    protected virtual bool NeedSkipCloseBracket(ITextControl textControl, CachingLexer lexer, char charTyped);
    protected virtual bool IsNextCharDoesNotStartNewLiteral(ITypingContext typingContext, CachingLexer lexer, int charPos, IBuffer buffer);
    protected virtual NodeTypeSet GetQuoteCorrespondingTokenType(char c);
    protected virtual bool CheckThatLexerInInterpolatedString(CachingLexer lexer, int charPos);
    protected virtual bool CheckThatCLikeLineEndsInOpenStringLiteral(ITextControl textControl, CachingLexer lexer, int lineEndPos, char c, NodeTypeSet correspondingTokenType, bool isStringWithAt, Int32& charPos, bool defaultReturnValue);
    protected virtual bool IsStopperTokenForStringLiteral(TokenNodeType tokenType);
    protected virtual ITreeNode GetParentForFormatOnSemicolon(ITreeNode node);
    protected virtual bool IsNodeSuitableAsSemicolonFormatParent(ITreeNode node);
    protected bool HandleSemicolonTypedEx(ITypingContext typingContext);
    private bool SkipRightParOnSemicolon(ITypingContext typingContext);
    [PureAttribute]
private bool CheckParenthesesBalanceAndForStatement(CachingLexer lexer);
    private bool HandleDivideTyped(ITypingContext typingContext);
    protected bool HandleEnterPressed(IActionContext context);
    private bool DoHandleEnterInRawStringLiteralPressed(ITextControl textControl);
    private bool HandleEnterInRawLiteralInsert(ITextControl textControl, ITokenNode tokenNode, TreeOffset treeOffset, ICodeFormatter formatter, LineEnding lineEnding, TokenNodeType tokenNodeType, IDocument document, bool interpolatedInsertStart);
    private ITokenNode InsertRightBraceInRawStringInterpolation(ITokenNode tokenNode);
    protected virtual IndentTypingHelper`1<CSharpLanguage> GetIndentTypingHelper();
    private void DoIndentForCurrentLine(ITextControl textControl);
    protected virtual Nullable`1<StringVerbatimity> TryGetStringVerbatimity(CachingLexer lexer);
    protected virtual int VerbatimOffset(TokenNodeType tokenType);
    protected virtual ValueTuple`2<string, string> GetRegularStringLiteralOwnerBorders(CachingLexer lexer);
    protected virtual ValueTuple`2<string, string> GetCurrentStringLiteralBorders(CachingLexer lexer);
    protected virtual bool DoHandleDeletingPlus(ITextControl textControl, int charPos, bool backspace);
    private static CSharpLanguageLevel GetCSharpLanguageLevelOrLatest(IDocument document, ISolution solution);
    protected virtual int GetValidSplitOffset(IDocument document, string str, CachingLexer lexer, int offset);
    protected virtual bool DoReformatForSmartEnter(ITextControl textControl, TreeOffset lBraceTreePos, TreeOffset rBraceTreePos, int charPos, ITokenNode lBraceNode, ITokenNode rBraceNode, bool afterLBrace, IFile file, bool oneLine);
    protected virtual TreeOffset ReparseAndFormatOnEnter(ITextControl textControl, TreeOffset lBraceTreePos, TreeOffset rBraceTreePos, int charPos, ITokenNode lBraceNode, ITokenNode rBraceNode, bool afterLBrace, IFile& file, bool oneLine);
    [NotNullAttribute]
private string GetDummyTextForSmartEnterFormat(ITokenNode lBraceNode, ITokenNode rBraceNode, IFile file, TreeTextRange reparseTreeOffset);
    [NotNullAttribute]
public static IDisposable OverrideSettingsForFormattingOnEnter(ISolution solution);
    protected virtual bool IsLBrace(ITextControl textControl, ITreeNode node);
    protected virtual bool IsRBrace(ITextControl textControl, ITreeNode node);
    protected virtual bool IsSemicolon(ITextControl textControl, ITreeNode node);
    protected virtual IDisposable ModifyFormatterSettingsForAutoformatOnSemicolon();
    protected virtual string GetIndentBeforeToken(ITextControl textControl, CachingLexer lexer);
    protected virtual bool GetPreferWrapBeforeOpSignSetting(IContextBoundSettingsStore settingsStore);
    protected virtual bool HandlePatternColonReplacement(ITypingContext typingContext);
    [PureAttribute]
private bool ShouldRevertAccessChainTypoCorrection(ITypingContext typingContext, char nextChar);
    protected virtual bool HandleAtTyped(ITypingContext typingContext);
    protected virtual bool HandleDollarTyped(ITypingContext typingContext);
    private bool IsDollarQuotesAssistAvailable(ITypingContext typingContext, CachingLexer lexer, int charPos);
    private bool IsTypingSmartAnnotationAvailable(ITypingContext typingContext);
    protected virtual bool HandleBangTyped(ITypingContext typingContext);
    protected virtual bool HandleQuestionTyped(ITypingContext typingContext);
    protected virtual bool HandleColonTyped(ITypingContext typingContext);
    private bool HandleSmartNullabilityAnnotation(ITypingContext typingContext, bool isNotNull);
    private bool HandleStartNewLineBeforePressed(IActionContext context);
    private bool HandleStartNewLine(IActionContext context);
    private bool HandleBackspacePressed(IActionContext context);
    protected virtual bool IsStringLiteralToken(TokenNodeType tokenType);
    protected virtual BracketMatcher CreateBracketMatcher();
    protected virtual BracketMatcher CreateBraceMatcher();
    protected virtual DeleteNewLineInfo<CSharpLanguage> DeleteOrBackspaceNewLineChecker(CachingLexer lexer, TextRange range, int lineBreakPosition);
    private static Nullable`1<TextRange> CheckBlockWithMatcher(CachingLexer lexer, TextRange range, BracketMatcher interpolationMatcher, bool allowEmpty);
    protected bool HandleDelPressed(IActionContext context);
    protected bool HandleCutPressed(IActionContext context);
    protected bool HandleWordDeleteToStartPressed(IActionContext context);
    protected bool HandleWordDeleteToEndPressed(IActionContext context);
    private bool DoHandleBackspaceInInterpolatedString(ITextControl textControl);
    protected static string GetCodeBehindIndent(CSharpTypingAssistBase typingAssist, ITextControl textControl, int lexerOffset, string indent);
    public abstract virtual bool QuickCheckAvailability(ITextControl textControl, IPsiSourceFile projectFile);
    public CaretPlacementInRawLiteral CheckForRawLiteral(ITextControl textControl, Int32& modifiedCaretOffset, CachingLexer& lexer);
    public virtual bool ShouldDoCustomBackspaceSmartUnindent(TokenNodeType tokenNodeType);
    public virtual bool DoCustomBackspaceSmartUnindent(IActionContext context);
    [CompilerGeneratedAttribute]
internal static bool <ShouldPerformExpressionToStatementConversion>g__TryProceedToLambdaArrow|58_0(bool isToLeft, <>c__DisplayClass58_0& );
    [CompilerGeneratedAttribute]
private BracketMatcher <NeedSkipCloseBracket>b__69_1(TokenNodeType leftBracket);
    [CompilerGeneratedAttribute]
internal static bool <ShouldRevertAccessChainTypoCorrection>g__CanParameterTypeAcceptArgumentStartingWithDot|105_0(IType parameterType, <>c__DisplayClass105_0& );
    [CompilerGeneratedAttribute]
private CaretPlacementInRawLiteral <CheckForRawLiteral>g__CheckForInterpolatedInsertStart|134_0(Int32& modifiedCaretOffset1, CachingLexer lexer1);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.Options.TypingAssistSettings", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "CTypingAssistOptionsSettingDescription")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpTypingAssistSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Feature.Services.CSharp.Resources.Strings", "InsertDocumentationCommentStubOnTypingTheThirdSettingDescription")]
public bool InsertDocCommentStub;
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.CSharpTypingAssistSettingsAccessor : object {
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpTypingAssistSettings, bool>> InsertDocCommentStubEnabledExpression;
    private static CSharpTypingAssistSettingsAccessor();
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.ExpressionToStatementBodyAssist : object {
    public static bool TryConvert(ISolution solution, ITextControl textControl);
    private static bool TryConvert(ISolution solution, ITextControl textControl, ILambdaExpression lambdaExpression);
    private static bool TryConvert(ISolution solution, ITextControl textControl, IArrowExpressionClause arrowClause);
    private static void MoveCaretToStatementStart(ITextControl textControl, IBlock block);
    [CompilerGeneratedAttribute]
internal static ICSharpTreeNode <TryConvert>g__TryProceedToLambdaArrow|0_0(bool isToLeft, <>c__DisplayClass0_0& );
}
internal static class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.NullabilityAnnotationAssist : object {
    public static bool Annotate(bool isNotNull, ISolution solution, ITextControl textControl, CachingLexer lexer);
    [MustUseReturnValueAttribute]
private static bool CheckTokens(CachingLexer lexer, int caretOffset, Boolean& isPrepandParameter);
    private static Nullable`1<AnnotationTargetInfo> GetAnnotationTargetAndTypeUsage(NonCommittedPsiActionCookie`1& psiAction, DocumentOffset caretOffset);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
private static ITypeUsage GetTypeUsageByDeclaration(ICSharpDeclaration declaration);
    [CanBeNullAttribute]
private static IAttributesOwnerDeclaration GetAnnotationTargetByTypeUsage(ITypeUsage typeUsage);
    private static void UpdateIsPrepandParameterFlag(AnnotationTargetInfo& targetInfo, DocumentOffset caretOffset, Boolean& isPrepandParameter);
    [PureAttribute]
private static bool CheckTypeUsage(AnnotationTargetInfo& targetInfo, Boolean& isPrepandParameter, bool isNotNull, IDocument document);
    [CanBeNullAttribute]
[PureAttribute]
private static ITypeUsage CreateTypeUsageFromTypeText(AnnotationTargetInfo& targetInfo, string typeText);
    [PureAttribute]
private static bool CheckTypeForTypeUsage(AnnotationTargetInfo& targetInfo, bool isNotNull, ITypeUsage effectiveTypeUsage);
    [PureAttribute]
private static bool CheckSplitOfNextParameter(AnnotationTargetInfo& targetInfo);
    [PureAttribute]
private static bool CheckCaretUnderEndOfTypeUsage(ITypeUsage typeUsage, DocumentOffset caretOffset);
    private static void ExtractArrayRanks(ITypeUsage typeUsage, IRankSpecifier& lastRank, IRankSpecifier& lastButOneRank);
    [PureAttribute]
private static bool IsPredefinedReferenceTypeUsage(IPredefinedTypeUsage predefinedTypeUsage);
    [PureAttribute]
private static bool CheckContainingType(AnnotationTargetInfo& targetInfo);
    [PureAttribute]
private static bool IsUnfinishedDeclaration(IAttributesOwnerDeclaration declaration);
    private static void FormatAnnotation(ITextControl textControl, IContextBoundSettingsStore settingsStore, AnnotationTargetInfo targetInfo);
    private static void InsertParameterNullCheck(ICSharpRegularParameterDeclaration parameterDeclaration);
    private static void InsertParameterNullCheck(ICSharpRegularParameterDeclaration parameterDeclaration, ICSharpParametersOwnerDeclaration parametersOwnerDeclaration);
    private static void InsertCommaAndMoveCaret(ITextControl textControl, CaretPositionKind caretPositionKind, DocumentOffset caretOffset, int caretShift);
    [CompilerGeneratedAttribute]
internal static AnnotateResult <Annotate>g__DoAnnotate|3_0(AnnotationTargetInfo& targetInfo, bool areNullableReferenceTypesSupported, bool isUnfinishedDeclaration, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <CheckTokens>g__IsModifierToken|4_0(TokenNodeType tokenType);
    [CompilerGeneratedAttribute]
internal static bool <GetAnnotationTargetAndTypeUsage>g__HasLineBreakBetween|5_0(ITokenNode x, ITokenNode y);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.NullabilityAnnotationAssistSuggester : object {
    [NotNullAttribute]
private ISettingsStore mySettingsStore;
    [NotNullAttribute]
private IUsageStatisticsCounters myUsageStatisticsCounters;
    [NotNullAttribute]
private IThreading myThreading;
    [NotNullAttribute]
private IFeatureSuggestionNotificationProvider myNotificationProvider;
    [NotNullAttribute]
private OptionsManager myOptionsManager;
    [NotNullAttribute]
private Property`1<bool> myDisableMe;
    private int myContextActionCounter;
    public IFeatureSuggestionAspect[] Aspects { get; }
    public NullabilityAnnotationAssistSuggester(Lifetime lifetime, ISettingsStore settingsStore, IUsageStatisticsCounters usageStatisticsCounters, IThreading threading, IFeatureSuggestionNotificationProvider notificationProvider, OptionsManager optionsManager);
    public sealed virtual IFeatureSuggestionAspect[] get_Aspects();
    public sealed virtual IProperty`1<IFeatureSuggestion> Subscribe(Lifetime lifetime, FeatureSuggestionMode mode);
    private void DisableWhenAssistUsed(Lifetime lifetime);
    private void ShowNotificationWhenUsageThresholdReached(Lifetime lifetime, FeatureSuggestionMode mode, IProperty`1<IFeatureSuggestion> suggestion);
    private void GoToOptions();
    [CompilerGeneratedAttribute]
private void <GoToOptions>b__13_0();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.TypingAssist.ZoneMarker : object {
}
public class JetBrains.ReSharper.Feature.Services.CSharp.UsageChecking.GlobalUsingUsageChecker : object {
    public static IEnumerable`1<IUsingDirective> GetUnusedUsingDirectivesForInplaceUsageAnalysis(IReadOnlyList`1<IUsingDirective> globalUsingDirectives, IPsiModule psiModule, Func`1<bool> checkForInterrupt);
    private static bool TryGetUsingDirectivePossibleSymbolNames(IUsingDirective globalUsingDirective, IPsiModule psiModule, ISymbolTable& symbolTable, IEnumerable`1& symbolNames);
    private static IEnumerable`1<string> GetPossibleSymbolNamesInReferences(ISymbolTable symbolTable, IUsingDirective globalUsingDirective);
    private static SpecialSymbolType GetSpecialSymbolType(ISymbolTable symbolTable, string name);
    public static ISearchDomain GetSearchDomainForUsingDirective(IUsingDirective globalUsingDirective, IPsiModule psiModule);
    private static IEnumerable`1<IUsingDirective> GetUnusedGlobalUsingDirectives(IEnumerable`1<IUsingDirective> globalUsingDirectives, IPsiModule psiModule, Func`1<bool> checkForInterrupt, IEnumerable`1<string> possibleWordsInFiles);
    private static ISearchDomain CreateSearchDomain(IPsiModule psiModule, IEnumerable`1<string> possibleWordsInFiles);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.AssignmentConverter : SwitchStatementToExpressionConverterBase {
    private ITokenNode myOperatorSign;
    [CanBeNullAttribute]
private ICSharpExpression myExpectedDestinationExpression;
    public AssignmentConverter(ISwitchModel switchModel, bool doTransformation);
    private bool Accept(ICSharpStatement statement);
    public virtual bool TryConvertToArmExpression(ICSharpStatement statement, ICSharpExpression& armExpression);
    public virtual bool TryCreateResultStatement(ISwitchExpression switchExpression, ICSharpExpression defaultCaseExpression, bool isContextAction, ICSharpStatement& resultStatement, ICSharpStatement& obsoleteStatement);
    private static bool IsDeclaredElementUsedInsideTreeNode(IDeclaredElement declaredElement, ITreeNode rooTreeNode);
    private bool TryCreateLocalVariableDeclaration(ISwitchExpression switchExpression, ICSharpExpression defaultCaseExpression, ILocalVariableDeclaration localVariableDeclaration, bool isContextAction, ICSharpStatement& resultStatement);
    protected virtual IType GetForceCastType();
    private bool CheckUsedLocalsAreAccessible(ICSharpExpression assignmentDestination);
    public virtual ISwitchExpression GetSwitchExpression(ICSharpStatement cSharpStatement);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.BlockUtil : object {
    private static IStatementOwner[] ourStatementOwners;
    private static BlockUtil();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.BlockUtil/<GetNestedBlocks>d__1")]
[PureAttribute]
public static IEnumerable`1<NestedStatementsOwner> GetNestedBlocks(ICSharpStatement statement);
    [PureAttribute]
public static Nullable`1<NestedStatementsOwner> GetFirstNestedBlock(ICSharpStatement statement);
    [PureAttribute]
public static Nullable`1<NestedStatementsOwner> GetPreviousNestedBlock(ICSharpStatement statement);
    [PureAttribute]
public static Nullable`1<NestedStatementsOwner> GetNextNestedBlock(ICSharpStatement statement);
    [PureAttribute]
public static Nullable`1<NestedStatementsOwner> GetContainingNestedBlock(ICSharpStatement statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.ClosureRewriting.ClosureRewriteHelper : object {
    public static bool CheckClosureCapturesLocalContextOfTypeMember(ICSharpDeclaration closureDeclaration);
    public static HashSet`1<IDeclaredElement> CollectLocalContextClosures(ICSharpDeclaration closureDeclaration);
    public static bool HasCapturesOfLocalsDeclaredInsideContainingStatement(IAnonymousFunctionExpression functionExpression);
    public static bool HasCapturesOfLocalsDeclaredIn(IAnonymousFunctionExpression functionExpression, ITreeNode scope);
    public static void CopySignature(IAnonymousFunctionExpression source, TMethodLike target);
    public static void FixMultipleDiscardParameters(ICSharpParametersOwnerDeclaration parametersOwnerDeclaration);
    public static VariableReplaceInfo GetVariableToLocalFunctionReplacementInfo(IAnonymousFunctionExpression anonymousFunctionExpression, IProgressIndicator progress);
    private static ICSharpExpression GetFunctionWithExplicitSignature(ILocalVariableDeclaration localVariableDeclaration);
    [MustUseReturnValueAttribute]
public static IBulbActionCommand ReplaceExpressionWithLocalFunction(IAnonymousFunctionExpression source);
    [MustUseReturnValueAttribute]
public static IBulbActionCommand ReplaceVariableWithLocalFunction(VariableReplaceInfo replaceInfo, IProgressIndicator progressIndicator);
    public static IReadOnlyList`1<string> GetSuggestedNames(IAnonymousFunctionExpression source, ICSharpDeclaration declaration);
    public static IReadOnlyList`1<string> GetSuggestedNames(IAnonymousFunctionExpression source, ICSharpDeclaration declaration, SuggestionOptions suggestionOptions);
    public static IBulbActionCommand ExecuteRename(ITreeNodePointer`1<IReferenceExpression> replacementExpressionPointer, ITreeNodePointer`1<ICSharpIdentifier> nameIdentifierPointer, ICollection`1<IReference> references, IReadOnlyCollection`1<string> suggestedNames);
    public static bool ShouldMarkAsUnsafeExplicitly(ICSharpDeclaration source, IClassLikeDeclaration classDeclaration);
    public static void CopyCheckedUncheckedContext(ICSharpDeclaration source, ICSharpDeclaration target, CSharpElementFactory factory);
    [MustUseReturnValueAttribute]
private static IBulbActionCommand ReplaceExpressionWithLocalFunctionImpl(CSharpElementFactory factory, IDeclarationStatement declarationStatement, IAnonymousFunctionExpression newAnonymousFunctionExpression);
    private static Nullable`1<bool> IsContextChecked(ICSharpDeclaration source);
    private static void WrapWithChecked(ICSharpDeclaration target, CSharpElementFactory factory);
    private static void WrapWithUnchecked(ICSharpDeclaration target, CSharpElementFactory factory);
    private static CSharpCodeBody EnsureBodyCanBeWrappedWithCheckedUncheckedContext(ICSharpDeclaration targetDeclaration);
    private static IList`1<IReference> CastUsagesIfNecessary(IList`1<IReference> movedReferences, IType variableType, ITypeUsage typeUsage, IProgressIndicator progressIndicator);
    private static bool CastIsRedundant(IType variableType, ICastExpression castExpression);
    private static IDeclarationStatement CreateLocalFunctionStatementWithSignature(IAnonymousFunctionExpression source);
    private static IReadOnlyList`1<string> GetLocalFunctionNamesFromLocalVariableSource(IAnonymousFunctionExpression source, ILocalVariableDeclaration variableDeclaration, ILocalFunctionDeclaration localFunctionDeclaration);
    private static INamesCollection CreateNameSuggestion(IAnonymousFunctionExpression source);
    private static NameRoot OnRootPrepender(NameRoot root);
    private static DocumentRange GetRangeFromPointer(ITreeNodePointer`1<T> nodePointer);
    public static void Format(ITreeNode root, CodeFormatProfile profile);
    [CompilerGeneratedAttribute]
internal static void <ReplaceVariableWithLocalFunction>g__FixArgumentNames|9_0(VariableReplaceInfo replaceInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.ClosureRewriting.CSharpLocalFunctionConverter : object {
    public static bool CanLiftClosures(ILocalFunctionDeclaration sourceFunctionDeclaration, HashSet`1<IDeclaredElement> closures, IUsagesProvider usagesProvider);
    private static bool CanModifyCallSitesWithLiftedClosures(ILocalFunctionDeclaration sourceFunctionDeclaration, TreeOffset closuresDeclarationOffset, bool typeParametersCanBeInferred, IUsagesProvider usagesProvider);
    public static ValueTuple`2<IMethodDeclaration, IBulbActionCommand> ConvertLocalFunctionToRegularMethod(ILocalFunction localFunction);
    private static TreeNodeMarker MarkRecursiveReferences(IEnumerable`1<IReference> allReferences, ICSharpDeclaration sourceDeclaration);
    private static HashSet`1<IReference> BindReferences(IMethodDeclaration methodDeclaration, IEnumerable`1<IReference> references, TreeNodeMarker movedReferencesMarker);
    private static IMethodDeclaration CreateMethodDeclaration(ILocalFunctionDeclaration source, IClassLikeDeclaration classDeclaration, IReadOnlyList`1& suggestedNames);
    private static void LiftVariableClosures(ILocalFunction sourceFunction, IMethodDeclaration convertedDeclaration, ISubstitution substitution, HashSet`1<IDeclaredElement> closures);
    private static ValueTuple`2<JetHashSet`1<IClrDeclaredElement>, JetHashSet`1<IClrDeclaredElement>> AnalyzeClosureVariablesAccess(ILocalFunction sourceFunction);
    private static ICSharpArgument FindLiftedArgumentAnchor(IInvocationExpression invocationExpression, Nullable`1<int> anchorParameterIndex, Boolean& mustBeNamedArgument);
    private static ISubstitution LiftTypeParameterClosures(ILocalFunction sourceFunction, IMethodDeclaration convertedDeclaration, HashSet`1<IDeclaredElement> closures, ISubstitution substitution);
    private static IReadOnlySet`1<ITypeParameter> CollectTransitiveTypeParametersClosure(HashSet`1<IDeclaredElement> closures, Boolean& typeParametersCanBeInferred);
    private static IReadOnlyList`1<string> GetSuggestedNames(IClassLikeDeclaration parentDeclaration, IMethodDeclaration methodDeclaration);
    private static void CopyParameterDeclarations(ILocalFunctionDeclaration source, IMethodDeclaration target, ISubstitution substitution, CSharpElementFactory factory);
    private static ISubstitution CopyTypeParametersWithConstraints(ILocalFunctionDeclaration source, IMethodDeclaration target, CSharpElementFactory factory);
    [CompilerGeneratedAttribute]
internal static Nullable`1<int> <LiftVariableClosures>g__CreateLiftedParameterDeclarations|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static ParameterKind <LiftVariableClosures>g__GetClosureParameterKind|6_1(IDeclaredElement declaredElement, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static IClrDeclaredElement <AnalyzeClosureVariablesAccess>g__FindRootDeclaredElement|7_3(VariableInfo variableInfo);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <FindLiftedArgumentAnchor>g__NextArgumentMustBeNamed|8_0(ICSharpArgument previousArgument);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.ClosureRewriting.VariableReplaceInfo : ValueType {
    [CanBeNullAttribute]
private IAnonymousFunctionExpression mySourceExpression;
    [CanBeNullAttribute]
private IDeclarationStatement myDeclarationStatement;
    [CanBeNullAttribute]
private IExpressionStatement myRecursiveFunctionPattern;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReference[] myReferences;
    public bool CanReplaceVariable { get; }
    [NotNullAttribute]
public IDeclarationStatement DeclarationStatement { get; }
    [NotNullAttribute]
public IAnonymousFunctionExpression AnonymousFunctionExpression { get; }
    [CanBeNullAttribute]
public IExpressionStatement RecursiveFunctionPattern { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReference[] References { get; }
    public static VariableReplaceInfo DisabledInfo { get; }
    public VariableReplaceInfo(IAnonymousFunctionExpression sourceExpression, IDeclarationStatement declarationStatement, IExpressionStatement recursiveFunctionPattern, IReference[] references);
    public bool get_CanReplaceVariable();
    public IDeclarationStatement get_DeclarationStatement();
    public IAnonymousFunctionExpression get_AnonymousFunctionExpression();
    public IExpressionStatement get_RecursiveFunctionPattern();
    public IReference[] get_References();
    public static VariableReplaceInfo get_DisabledInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.ConditionalCompilationUtil : object {
    private static Key`1<ICollection`1<ICSharpDeclaration>> ourConditionallyCompiledMembers;
    private static ConditionalCompilationUtil();
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static bool SuppressWarningsInConditionallyCompiledMember(ElementProblemAnalyzerData data, ICSharpTreeNode context);
    [MustUseReturnValueAttribute]
public static bool SuppressWarningsInConditionallyCompiledMember(ICSharpDeclaration memberDeclaration, IContextBoundSettingsStore settingsStore);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpAddAccessorIntention : object {
    public static IBulbActionCommand AddAccessor(IAccessorOwnerDeclaration accessorOwnerDeclaration, CSharpAccessorKind missingAccessor);
    public IBulbActionCommand AddAccessor(ITypeMember typeMember, CSharpAccessorKind accessorKind);
    public sealed virtual IBulbActionCommand AddAccessor(ITypeMember typeMember, AccessorKind accessorKind);
    private static void ApplyAccessorBodyStyle(IAccessorOwnerDeclaration accessorOwnerDeclaration, IAccessorDeclaration accessorDeclaration);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpAnnotationsUtil : object {
    [NotNullAttribute]
private static String[] ourValueAttributes;
    [NotNullAttribute]
private static String[] ourContainerAttributes;
    [NotNullAttribute]
private static String[] ourValueAndContainerAttributes;
    private static CSharpAnnotationsUtil();
    public static AnnotateResult AnnotateNotNull(IAttributesOwnerDeclaration annotationTarget, bool wholeMultiDeclaration);
    public static AnnotateResult AnnotateCanBeNull(IAttributesOwnerDeclaration annotationTarget, bool wholeMultiDeclaration);
    public static AnnotateResult Annotate(IAttributesOwnerDeclaration annotationTarget, bool isNotNull, bool isContainer, bool wholeMultiDeclaration);
    public static Nullable`1<CodeAnnotationNullableValue> PropagateInferredNullability(IAttributesOwner from, IAttributesOwnerDeclaration to, ITreeNode context);
    public static Nullable`1<CodeAnnotationNullableValue> PropagateInferredContainerNullability(IAttributesOwner from, IAttributesOwnerDeclaration to, ITreeNode context);
    private static Nullable`1<CodeAnnotationNullableValue> PropagateInferredNullability(IAttributesOwner from, IAttributesOwnerDeclaration to, bool isContainer, ITreeNode context);
    private static void AddNullableReferenceTypeAnnotation(IAttributesOwnerDeclaration declaration, ITypeOwner element, bool isContainer);
    public static AnnotateResult Annotate(IAttributesOwnerDeclaration annotationTarget, ITypeElement annotationType, bool wholeMultiDeclaration);
    public static void RemoveNullabilityAnnotations(IAttributesOwnerDeclaration annotationTarget, bool wholeMultiDeclaration);
    public static void RemoveNotNullAnnotation(IAttributesOwnerDeclaration annotationTarget, bool wholeMultiDeclaration);
    public static void RemoveCanBeNullAnnotation(IAttributesOwnerDeclaration annotationTarget, bool wholeMultiDeclaration);
    private static void RemoveAnnotations(IAttributesOwnerDeclaration annotationTarget, ITypeElement annotationType, bool wholeMultiDeclaration);
    [NotNullAttribute]
private static IList`1<IAttribute> RemovePartialAndCollectAnnotationsToRemove(IAttributesOwnerDeclaration annotationTarget, ITypeElement annotationType);
    [NotNullAttribute]
[PureAttribute]
private static String[] GetMutuallyExclusiveAttributeShortNames(string annotationShortName);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpAnonymousFunctionUtil : object {
    [CanBeNullAttribute]
public static IDeclaredType GetAnonymousFunctionType(IAnonymousFunctionExpression functionExpression);
    [CanBeNullAttribute]
public static IDeclarationStatement TryGetInitializedVariableDeclaration(IAnonymousFunctionExpression anonymousFunctionExpression, IExpressionStatement& recursiveFunctionPattern);
    public static bool MatchSignatureExactly(IAnonymousFunctionExpression anonymousFunctionExpression, IType delegateType);
    public static bool CanUseSignatureTypesExplicitly(IDeclaredType expressionType, IDelegate delegateType, IAnonymousFunctionExpression functionExpression);
    public static bool HasExplicitSignature(IAnonymousFunctionExpression source);
    public static bool CanReplaceUsageWithLocalFunction(IType variableType, IReference reference, IExpressionStatement recursiveFunctionPattern, IExpressionType anonymousFunctionExpressionType, ICSharpExpression checkResolveEquivalenceWith);
    [CanBeNullAttribute]
private static IDeclarationStatement FindDeclarationByRecursiveFunctionPattern(IAssignmentExpression assignmentExpression, IExpressionStatement& recursiveFunctionPattern);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpAnonymousObjectsAnalyser : object {
    public sealed virtual bool IsCreationExpression(ITreeNode element);
    public sealed virtual IEnumerable`1<Pair`2<string, IManagedExpression>> GetMemberInitializers(ITreeNode element);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpAutoPropertyUtil : object {
    [NotNullAttribute]
private static ClrTypeName ourUnitySerializedFieldAttribute;
    [NotNullAttribute]
private static ClrTypeName ourUnityFormerlySerializedAsAttribute;
    private static CSharpAutoPropertyUtil();
    [PureAttribute]
public static ConversionKind CanConvertToAuto(IPropertyDeclaration propertyDeclaration, IField& backingField, IUsagesProvider usagesProvider);
    private static bool CheckAutoPropertyConversionContext(IPropertyDeclaration propertyDeclaration);
    [PureAttribute]
private static ConversionKind CanConvertAbstractProperty(IProperty property);
    private static ConversionKind CheckBackingFieldUsages(IPropertyDeclaration propertyDeclaration, IProperty property, IField backingField, IEnumerable`1<ITreeNode> backingFieldUsages, IAccessor setter, ConversionKind conversionKind);
    [PureAttribute]
private static ExpressionAccessType GetUsageAccessType(ITreeNode usage);
    [PureAttribute]
private static bool IsEmptyOrNotImplemented(IAccessor accessor);
    [PureAttribute]
public static bool IsEmptyOrNotImplemented(ICSharpTypeMemberDeclaration memberDeclaration);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression FindStaticExpressionReturn(IAccessor accessor);
    [PureAttribute]
private static bool IsStaticContextExpression(ICSharpExpression expression);
    [PureAttribute]
private static bool CheckBackingField(IProperty property, IField backingField);
    private static bool CheckBackingFieldIsGood(IProperty property, IField backingField, ITreeNode context);
    private static bool CheckBackingFieldInitializer(IField backingField);
    private static bool CheckBackingFieldAccessRights(IField backingField);
    [PureAttribute]
public static bool IsNameofUsageUnderMemberNotNullAttribute(IReference reference, IAttribute& memberNotNullAttribute);
    [PureAttribute]
public static bool IsDefaultInitializer(IDeclaredElement initializerOwner, IType variableType, ICSharpExpression expression);
    [PureAttribute]
public static bool IsTrivialInitializerWithoutSideEffects(ICSharpExpression expression);
    [PureAttribute]
public static bool IsGetOnlyAutoOrSemiAutoPropertyWriteable(IProperty property, ICSharpTreeNode writeUsage);
    [PureAttribute]
public static bool IsReadonlyMemberWriteable(ITypeMember typeMember, ICSharpTreeNode writeUsage);
    [NotNullAttribute]
public static IFieldDeclaration CreateBackingFieldFor(IPropertyDeclaration propertyDeclaration, bool removeSetterIfPossible);
    public static void CreateBackingFieldAccessors(IPropertyDeclaration propertyDeclaration, ICSharpExpression fieldAccessExpression);
    [NotNullAttribute]
public static IFieldDeclaration FieldKeywordToExlicitField(IPropertyDeclaration propertyDeclaration);
    [CanBeNullAttribute]
private static IFieldDeclaration FindAnchorFieldDeclaration(IClassLikeDeclaration typeDeclaration, IProperty property);
    [NotNullAttribute]
private static IFieldDeclaration CreateFieldDeclaration(IPropertyDeclaration propertyDeclaration, IProperty property, IClassLikeDeclaration typeDeclaration);
    private static void TransferFieldTargetedAttributeSections(IPropertyDeclaration sourceDeclaration, IFieldDeclaration targetDeclaration);
    [NotNullAttribute]
private static IList`1<IReference> FindPropertyWrites(IClassLikeDeclaration typeDeclaration, IProperty property);
    [PureAttribute]
public static bool IsPropertyHeaderSelected(IPropertyDeclaration propertyDeclaration, TreeTextRange selectedRange);
    [PureAttribute]
public static bool CanAddSecondAccessor(ITypeMember typeMember, CSharpAccessorKind accessorToAdd, bool avaliableForEmpty);
    [PureAttribute]
private static bool CheckDeclarationForSecondAccessor(ITypeMember typeMember);
    [PureAttribute]
private static bool PropertyCanHaveExtraAccessor(IProperty property, CSharpAccessorKind accessorToAdd);
    [NotNullAttribute]
public static IAccessorDeclaration AddAccessorDeclaration(IAccessorOwnerDeclaration accessorOwnerDeclaration, CSharpAccessorKind accessorKind);
    private static AccessRights GetPropertyAccessorAccessRights(IAccessorOwnerDeclaration ownerDeclaration, CSharpAccessorKind accessorKind);
    private static bool ShouldNewAccessorHaveCodeBody(IAccessorOwnerDeclaration accessorOwnerDeclaration);
    [PureAttribute]
private static bool CanBecameAutoProperty(IPropertyDeclaration propertyDeclaration);
    [CanBeNullAttribute]
private static ICSharpTreeNode TryCreateBodyFromExistingAccessor(IAccessorDeclaration existingAccessorDeclaration);
    [CanBeNullAttribute]
private static ICSharpTreeNode TryCreateBodyFromExistingGetter(CSharpCodeBody codeBody, CSharpElementFactory factory);
    [CanBeNullAttribute]
private static ICSharpTreeNode TryCreateBodyFromExistingSetter(CSharpCodeBody codeBody, CSharpElementFactory factory);
    [CanBeNullAttribute]
private static ICSharpTreeNode TryCreateBodyFromExistingAdder(CSharpCodeBody codeBody, CSharpElementFactory factory);
    [CanBeNullAttribute]
private static ICSharpTreeNode TryCreateBodyFromExistingRemover(CSharpCodeBody codeBody, CSharpElementFactory factory);
    [CanBeNullAttribute]
private static ICSharpExpression TryCreateEventAccessorInvocation(CSharpElementFactory factory, IInvocationExpression invocationExpression, string expectedMethodName, string dualMethodName);
    [CanBeNullAttribute]
public static ICSharpExpression MatchAssignmentOfValueVariable(ICSharpExpression expression, AssignmentType assignmentType);
    [PureAttribute]
private static bool MatchValueVariable(ICSharpExpression expression);
    [PureAttribute]
public static bool CanMakeFieldReadonly(IField field, ICSharpExpression usageExpression);
    [CompilerGeneratedAttribute]
internal static bool <CheckBackingFieldIsGood>g__IsNullnessAnnotations|13_0(IAttributeInstance instance, <>c__DisplayClass13_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpBaseClassUtil : object {
    public sealed virtual IEnumerable`1<IReference> GetBaseDeclarationsReferences(ITypeDeclaration declaration);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpChangeEnhancer : OneLanguageChangeEnhancer {
    public CSharpChangeEnhancer(ICodeFormatter formatter);
    protected virtual TreeTextRange GetEnhancedNodeRange(ITokenNode tokenNode);
    [CompilerGeneratedAttribute]
internal static bool <GetEnhancedNodeRange>g__ParentIsBigBlock|1_0(<>c__DisplayClass1_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpCodeInsightPsiUtil : object {
    public static bool IsAnonymousMethodVoid(IAnonymousMethodExpression anonymousMethod, IReturnStatement[] skipStatements);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICSharpStatement GetContainingStatementStoppingAtLambdas(ICSharpStatement statement);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpCodeInsightPsiUtil/<EnumerateStatementsRecursively>d__2")]
public static IEnumerable`1<ICSharpStatement> EnumerateStatementsRecursively(IBlock block);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpDeclarationHelper : object {
    [PureAttribute]
public static bool CanSplit(IAssignmentExpression assignmentExpression, ICSharpTreeNode statementAnchor);
    [PureAttribute]
public static bool CanSplitIfTypeIs(IType type, ICSharpTreeNode usageContext);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsValidDeclarationAnchorStatement(ITreeNode anchorStatementLike);
    public static IVariableInitializer SetInitial(ILocalVariableDeclaration variableDeclaration, IVariableInitializer initializer);
    public static void SplitDeclarationExpression(IDeclarationExpression declarationExpression, ICSharpTreeNode declarationAnchor, HashSet`1<IDeclaredElement> isSplitRequired);
    public static void SplitDeconstructingDeclaration(IAssignmentExpression assignmentExpression, ICSharpTreeNode declarationAnchor, HashSet`1<IDeclaredElement> isSplitRequired);
    public static void SplitDeconstructionComponent(ISingleVariableDesignation componentDesignation, ICSharpTreeNode declarationAnchor);
    public static ValueTuple`2<ILocalVariableDeclaration, IAssignmentExpression> SplitVariableDeclaration(ILocalVariableDeclaration variableDeclaration, IDeclarationStatement declarationStatement, ICSharpTreeNode declarationStatementAnchor);
    private static bool ShouldNullableAnnotationBeAddedAfterTypeSpecification(ILocalVariableDeclaration variableDeclaration);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpDeclarationHelper/<<CanSplit>g__Unfold|0_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<IVariableDesignation> <CanSplit>g__Unfold|0_0(ICSharpExpression destination);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpDefaultValueCreator : DefaultValueCreator {
    public virtual IExpression CreateDefaultValue(IType type, ITreeNode context, bool allowOmitTypeSpecifications);
    protected virtual IExpression CreateNull(ITreeNode context);
    protected virtual IExpression CreateConstantValue(ConstantValue value, ITreeNode context);
    [NotNullAttribute]
protected virtual IExpression CreateDefaultConstructorCall(IType valueType, ITreeNode context, bool allowOmitTypeSpecification);
    [NotNullAttribute]
public virtual IExpression CreateArrayConstructorCall(IType arrayType, ITreeNode context);
    protected virtual IExpression CreateTypeDefaultExpression(IType type, ITreeNode context, bool allowOmitTypeSpecification);
    private IExpression CreateTupleValue(DecoratedType`1<TupleTypeDecoration> tupleType, ITreeNode context, bool allowOmitTypeSpecifications);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpDefaultValueUtil : object {
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression GetCodeGenerationDefaultValue(IType type, ITreeNode context, bool allowUsingDefaultLiteral);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression GetClrDefaultValue(IType type, ITreeNode context, bool allowUsingDefaultLiteral);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression GetOptionalParameterDefaultValue(IType type, ITreeNode context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpExpressionPurityService : ExpressionPurityService {
    protected virtual bool IsPure(IReference reference);
    protected virtual bool IsPure(IDeclaredElement declaredElement);
    protected virtual bool CheckWriteAccess(IExpression expression, Func`2<IExpression, bool> isWriteAccessAllowed);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpFormatInvocationArgumentHelper : FormatInvocationArgumentHelperBase {
    protected virtual IExpression TryGetQualifierExpression(IArgumentsOwner argumentsOwner);
    protected virtual TreeTextRange GetToStringRange(IExpression expression);
    protected virtual bool CanBecomeStringLiteral(IExpression expression);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpInterpolationInsertInlineUtil : object {
    [ContractAnnotationAttribute("interpolationExpression:null=>false;inlineExpression:null=>false")]
public static bool CanInlineExpression(IInterpolatedStringExpression interpolationExpression, ICSharpExpression inlineExpression);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IList`1<ICSharpExpression> GetInlineableSubexpressions(IInterpolatedStringExpression interpolatedExpression, ICSharpExpression inlineExpression);
    [NotNullAttribute]
public static ICSharpExpression ReplaceWithInline(IInterpolatedStringExpression interpolationExpression, ICSharpExpression inlineExpression);
    [PureAttribute]
[NotNullAttribute]
private static ICSharpExpression CreateTrivialInterpolatedExpression(CSharpElementFactory factory, ICSharpLiteralExpression literalExpression, IInterpolatedStringExpression expressionToReplace);
    private static void AppendInterpolationExpression(ICSharpExpression inline, IStringInterpolationBuilder builder, IInterpolatedStringExpression interpolationExpression);
    private static void InsertArgument(IStringInterpolationBuilder builder, IInterpolatedStringInsert insertChild, ICSharpExpression insertExpression);
    private static void InlineExpression(ICSharpExpression inline, IStringInterpolationBuilder builder);
    private static bool ValidateInterpolationExpression(IInterpolatedStringExpression nestedExpression);
    private static bool ValidateLiteralToken(ITokenNode tokenNode);
    private static bool IsStringLiteralOrInterpolation(ICSharpExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpLambdaExpressionUtil : object {
    [NullableContextAttribute("2")]
public static StatementToExpressionConversion TryCreateConversionFromBlockBody(ICSharpExpression closureExpression, IBlock blockBody, ICSharpStatement& singleStatement);
    public static bool SpeculativeCheckCanUseExpressionBodyLambda(ICSharpExpression closureExpression, ICSharpExpression bodyExpression);
    private static void DoConvertToLambdaExpression(ICSharpExpression closureExpression, ICSharpExpression bodyExpression);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpLanguageReferenceSelector : object {
    public sealed virtual IConstructor GetBaseConstructor(IConstructor constructor);
    public sealed virtual IDeclaredElement TryGetNavigatableCorrespondingElementForImplicitElement(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
private static IEnumerable`1<DeclaredElementInstance> TryFindInterfaceImplementation(IReferenceExpressionReference reference);
    public sealed virtual IEnumerable`1<DeclaredElementInstance> GetCandidates(IReference reference, IDataContext dataContext, ReferencePreferenceKind preferenceKind);
    public sealed virtual IEnumerable`1<DeclaredElementInstance> GetDeclaredElementsCandidates(DeclaredElementInstance instance, IDataContext dataContext, ReferencePreferenceKind preferenceKind);
    private static IList`1<DeclaredElementInstance> GetFromObjectCreation(IObjectCreationExpression objectCreationExpression, ReferencePreferenceKind kind);
    [CanBeNullAttribute]
private static IList`1<DeclaredElementInstance> GetFromAttribute(IAttribute attribute, ReferencePreferenceKind kind);
    [CanBeNullAttribute]
private static IList`1<DeclaredElementInstance> CalculateCandidates(IReference reference);
    private static DeclaredElementInstance ProcessDeclaredElement(IDeclaredElement declaredElement, ISubstitution substitution);
    private static IEnumerable`1<DeclaredElementInstance> GetFromDeconstructionReference(IReference reference, IDataContext dataContext);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpLiftParameterUtil : object {
    public static bool CanLiftThisOrMemberClosureToParameter(ITreeNode closureNode, IParametersOwnerDeclaration functionLikeDeclaration);
    public static bool CanLiftVariableToParameter(IReference reference, IParametersOwnerDeclaration functionLikeDeclaration);
    public static bool CanLiftExpressionToParameter(IExpression expression, IParametersOwnerDeclaration functionLikeDeclaration, IDeclaredElement& declaredElement);
    private static bool CanLiftVariableToParameter(ITypeOwner typeOwner, IParametersOwnerDeclaration functionLikeDeclaration);
    public static ParameterKind CalculateParameterKind(IDeclaredElement referencedElement, IParametersOwnerDeclaration targetFunction);
    public static ParameterKind CalculateParameterKind(CSharpControlFlowGraphInspector inspector, ICSharpControlFlowGraph controlFlowGraph, IDeclaredElement closure, IEnumerable`1<ICSharpExpression> closureUsages);
    public static bool CanUseContainingTypeExplicitly(IParametersOwnerDeclaration usageContext);
    [CanBeNullAttribute]
public static IDeclaredType GetContainingType(IParametersOwnerDeclaration functionLikeDeclaration);
    [CompilerGeneratedAttribute]
internal static bool <CalculateParameterKind>g__IsAlwaysAssignedBeforeAccessed|5_0(IReferenceExpression referenceExpression, <>c__DisplayClass5_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpLiteralService : LiteralService {
    public virtual bool IsStringLiteral(ITreeNode element);
    public virtual bool IsConstantLiteral(ITreeNode element);
    public virtual Nullable`1<StringVerbatimity> TryGetStringVerbatimity(ILiteralExpression expression);
    public virtual TreeTextRange GetValueTextRange(ITreeNode element);
    public virtual string ParseStringLiteral(string literalText, RangeTranslator& translator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpParameterPassingUtil : object {
    [PureAttribute]
public static bool IsAcceptableTypeConversion(ITypeOwner argumentCandidate, IParameter candidateParameter, ISubstitution candidateParameterSubstitution, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
public static bool IsRefnessCompatible(ITypeOwner argumentCandidate, IParameter candidateParameter);
    public static IArgumentList TryPassExistingOwnParameters(IParametersOwner parametersOwner, ICSharpInvocationReference invocationReference);
    private static IReadOnlyList`1<IParameter> TryFindParametersToPassAsArguments(IList`1<IParameter> sourceParameters, ICSharpInvocationReference baseInvocationReference);
    [CompilerGeneratedAttribute]
internal static bool <TryFindParametersToPassAsArguments>g__TryMatch|3_2(IList`1<IParameter> baseArgumentsToSatisfy, ISubstitution baseCtorSubstitution, <>c__DisplayClass3_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpPassFormatStringHelper : PassFormatStringHelperBase {
    public virtual bool CanRewriteFormattingInvocation(FormattingFunctionInvocationInfo invocationInfo, ISolution solution, bool allowCustomFormattingMethods);
    public virtual IMethod GetNonFormattingMethod(FormattingFunctionInvocationInfo invocationInfo, ISolution solution, bool withoutCustomFormatProvider, bool allowInterpolatedStringHandlerOnly);
    public virtual bool IsResolvedWithNewMethod(FormattingFunctionInvocationInfo invocationInfo, IMethod suggestedMethod, IReadOnlyList`1<IArgument> removingArguments, bool allowInterpolatedStringHandlerOnly);
    protected virtual void RemoveArgument(IArgument argument);
    [PureAttribute]
private static bool FunctionInvocationResolveCheck(IInvocationExpression invocation, IMethod suggestedMethod, int formatStringArgumentIndex, bool strict);
    private static void FunctionInvocationMutator(FormattingFunctionInvocationInfo invocationInfo, IInvocationExpression invocation, IMethod suggestedMethod, IEnumerable`1<IArgument> removingArguments, int formatStringArgumentIndex, int formatStringArgumentIndexAfterMutation, bool strict);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpPropertyBodyHelper : object {
    public sealed virtual IField GetBackingField(IProperty property, bool checkSetter, bool allowSetterOnly);
    [CanBeNullAttribute]
[PureAttribute]
public static IField FindBackingFieldReturn(IAccessor getter, bool allowRefReturn);
    [CanBeNullAttribute]
[PureAttribute]
public static IField FindBackingFieldAssignment(IAccessor setter);
    [CanBeNullAttribute]
[PureAttribute]
private static IField FindBackingFieldAssignment(ICSharpExpression expression, IAccessorDeclaration setterDeclaration);
    [CanBeNullAttribute]
[PureAttribute]
private static IField ToThisClassField(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression FindReturnExpression(IAccessor getter);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression FindReturnExpression(IAccessorDeclaration accessorDeclaration);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression FindReturnExpression(IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclaration);
    public static void RemoveFieldDeclaration(IField backingField);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpPsiUtil : object {
    [PureAttribute]
public static bool CanTransformUnaryExpression(IOperatorExpression operatorExpression);
    [NotNullAttribute]
public static ICSharpExpression TransformPrefixExpression(IPrefixOperatorExpression prefixOperatorExpression, ICSharpExpression operand);
    [NotNullAttribute]
public static IBinaryExpression TransformPostfixExpression(IPostfixOperatorExpression postfixOperatorExpression, ICSharpExpression operand);
    [CanBeNullAttribute]
public static ICSharpExpression TransformComplexAssignment(IAssignmentExpression assignmentExpression, ICSharpExpression operand);
    private static void SetUsingStatementExpression(IUsingStatement usingStatement, ICSharpExpression expression);
    public static void RemoveDeclaration(ILocalVariableDeclaration variableDeclaration, ICSharpExpression referenceExpression);
    public static void RemoveDeclaration(ILocalConstantDeclaration declaration);
    [NotNullAttribute]
public static ICSharpNamespaceDeclaration CreateNamespaceDeclaration(ICSharpFile file, string name, ICSharpNamespaceDeclaration anchor);
    private static bool CheckNestedNamespacesExist(ICSharpTypeAndNamespaceHolderDeclaration file);
    [CanBeNullAttribute]
private static ICSharpNamespaceDeclaration GetExistingNamespaceDeclaration(ICSharpFile file, string namespaceName);
    [CanBeNullAttribute]
private static ICSharpNamespaceDeclaration GetRealAnchorInDeclaration(ICSharpTypeAndNamespaceHolderDeclaration declaration, ICSharpNamespaceDeclaration anchor);
    [CanBeNullAttribute]
private static ICSharpNamespaceDeclaration GetNamespaceDeclaration(ICSharpTypeAndNamespaceHolderDeclaration typeAndNamespaceHolder, string searchedName);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpStringInterpolationBuilder : object {
    [CanBeNullAttribute]
private IBuilderWithFixedVerbatimity myImplementation;
    [CanBeNullAttribute]
private StringBuilder myReservedTextWithoutEscaping;
    [CompilerGeneratedAttribute]
private bool <IsFinalized>k__BackingField;
    public bool IsFinalized { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFinalized();
    [CompilerGeneratedAttribute]
private void set_IsFinalized(bool value);
    public void InitializeVerbatimity(StringVerbatimity verbatimity, CSharpLanguageLevel languageLevel);
    public sealed virtual bool TryInitializeVerbatimity(StringVerbatimity verbatimity, ITreeNode context);
    public sealed virtual void InitializeVerbatimityFrom(IExpression literalOwner);
    [PureAttribute]
[NotNullAttribute]
private IBuilderWithFixedVerbatimity GetImplementationOrThrow();
    private void ThrowIfFinalized();
    public sealed virtual void AppendLiteral(ITokenNode literal);
    public sealed virtual void AppendLiteralPart(IExpression formatLiteral, DocumentRange range);
    private void AppendLiteralPart(ITokenNode literal, DocumentRange range, bool isFullRange);
    public sealed virtual void AppendLiteralText(string text);
    public sealed virtual void AppendTextNoEscaping(string text);
    public sealed virtual void BeginArgument();
    public sealed virtual void EndArgument(IExpression argument);
    public sealed virtual IExpression CreateExpression(ITreeNode context, bool forceInterpolation, bool produceEmptyLiterals);
    [PureAttribute]
private static ICSharpExpression CreateResult(ITreeNode context, string template, IReadOnlyList`1<ICSharpExpression> arguments);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpStringInterpolationHelper : object {
    public sealed virtual bool CanUseInterpolation(ITreeNode context);
    public sealed virtual bool CanUseInterpolatedStringHandlers(ITreeNode context);
    public sealed virtual bool CanReplaceWithInterpolationExpression(IExpression expression);
    public sealed virtual DocumentRange GetInvocationRange(IArgumentsOwner argumentsOwner);
    public sealed virtual IStringInterpolationBuilder CreateBuilder();
    public sealed virtual IExpression ReplaceWithConcatenation(IExpression toReplace, IReadOnlyList`1<IExpression> interpolations);
    public sealed virtual IExpression UnwrapFromInvocation(IExpression expression);
    public sealed virtual StringVerbatimity GetStringVerbatimity(IExpression expression);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpTypeAnchorSerializer : object {
    public sealed virtual string Serialize(TypeAnchor typeAnchor);
    public sealed virtual TypeAnchor Deserialize(string sFullyQualifiedName);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpTypeValidator : object {
    public virtual bool IsValidName(string name);
    public virtual bool IsValidReturnType(string type);
    public virtual bool IsValidParameterType(string type);
    public virtual bool IsValidExpression(string expr);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.CSharpUseConfigureAwaitUtil : object {
    private static string ConfiguredAsyncDisposableFqn;
    public static void SetTypeToVarOrIAsyncDisposable(ICSharpTreeNode awaitOwner);
    public static void AddConfigureAwaitFalse(IAwaitReferencesOwner awaitOwner);
    public static void AddConfigureAwaitFalseIfNeeded(ICSharpTreeNode context, ICSharpExpression awaitExpression);
    public static void AddConfigureAwaitFalseIfNeeded(ICSharpTreeNode context, IMultipleDeclaration awaitDeclaration, List`1<string> usedNames);
    private static bool IsLibraryAnalysisMode(ICSharpTreeNode context);
    [NotNullAttribute]
[PureAttribute]
private static string GetUniqueDiscardVariableName(IDeclaration declaration, List`1<string> usedNames);
    [CanBeNullAttribute]
private static IMultipleLocalVariableDeclaration TryGetMultipleLocalVariableDeclaration(ICSharpTreeNode awaitOwner);
    [PureAttribute]
private static bool HasMultipleAwaitableExpressions(ICSharpTreeNode awaitOwner);
    private static void SetAwaitOwnerTypeToVar(ICSharpTreeNode awaitOwner);
    private static void SetAwaitOwnerTypeToIAsyncDisposable(ICSharpTreeNode awaitOwner);
    private static void SetAwaitOwnerTypeToConfiguredAsyncDisposable(ICSharpTreeNode awaitOwner);
    private static void SetTypeToVarOrConfiguredAsyncDisposable(ICSharpTreeNode awaitOwner);
    private static void AddConfigureAwaitFalseToUsingStatementDeclaration(IUsingStatement usingStatement);
    private static void AddConfigureAwaitFalseToLocalMultipleDeclaration(IMultipleLocalVariableDeclaration declaration, List`1<string> usedNames);
    private static void AddConfigureAwaitFalseToExpressions(IAwaitReferencesOwner awaitOwner);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.DeconstructionPresenter : object {
    [NotNullAttribute]
[PureAttribute]
public static RichText Present(IDeconstruction deconstruction, string prefix, Nullable`1<TextStyle> prefixStyle);
    [CompilerGeneratedAttribute]
internal static void <Present>g__BuildText|0_0(IDeconstructionComponent component, <>c__DisplayClass0_0& );
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.Util.DeconstructionsLookupStrategy : Enum {
    public int value__;
    public static DeconstructionsLookupStrategy Basic;
    public static DeconstructionsLookupStrategy Deepest;
    public static DeconstructionsLookupStrategy Hybrid;
    public static DeconstructionsLookupStrategy All;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.DeconstructionUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IDeconstruction> GetAvailableDeconstructions(IType type, ITreeNode context, DeconstructionsLookupStrategy lookupStrategy, bool allowSingleElementDeconstruction, bool moreComponentsFirst);
    [NotNullAttribute]
[ItemNotNullAttribute]
[MustUseReturnValueAttribute]
private static IReadOnlyList`1<IDeconstruction> GetAvailableDeconstructionsSafe(IType type, ITreeNode context, DeconstructionsLookupStrategy lookupStrategy, HashSet`1<IType> typesInProcessing, int level, bool allowSingleElementDeconstruction, bool moreComponentsFirst);
    [NotNullAttribute]
[ItemNotNullAttribute]
[MustUseReturnValueAttribute]
private static IReadOnlyList`1<IDeconstruction> GetAvailableDeconstructionsImpl(IType type, ITreeNode context, DeconstructionsLookupStrategy lookupStrategy, HashSet`1<IType> typesInProcessing, int level, bool allowSingleElementDeconstruction, bool moreComponentsFirst);
    [NotNullAttribute]
[PureAttribute]
private static IReadOnlyList`1<IDeconstructionComponent> GetComponentsFromDeconstructMethodParameters(IMethod deconstructMethod, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
private static IReadOnlyList`1<IDeconstructionComponent> GetComponentsFromTupleType(DecoratedType`1<TupleTypeDecoration> tupleType);
    [NotNullAttribute]
[ItemNotNullAttribute]
[MustUseReturnValueAttribute]
private static IReadOnlyList`1<IDeconstruction> GetDeconstructionsFromBasicComponents(IType type, IReadOnlyList`1<IDeconstructionComponent> deconstructionComponents, IMethod deconstructMethod, ISubstitution methodSubstitution, ITreeNode context, DeconstructionsLookupStrategy lookupStrategy, HashSet`1<IType> typesInProcessing, int level, bool allowSingleElementDeconstruction);
    public static void ReplaceWithDeconstructingDeclaration(IExpressionStatement originalStatement, IDeconstruction deconstruction, IExpressionStatement& insertedStatement, HotspotsRegistry& hotspotsRegistry);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
private static IDeclarationExpression CreateDeclarationExpression(CSharpElementFactory factory, IDeconstruction deconstruction);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
private static IRecursivePattern CreateDeconstructionPattern(CSharpElementFactory factory, IDeconstruction deconstruction);
    [PureAttribute]
[NotNullAttribute]
private static string CreateDeconstructionTemplate(IDeconstruction deconstruction, bool inTupleForm);
    private static void BindDeconstructionReferences(IParenthesizedVariableDesignation parenthesizedVariableDesignation, IDeconstruction deconstruction);
    private static void BindDeconstructionReferences(IDeconstructionPatternClause deconstructionPatternClause, IDeconstruction deconstruction);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private static HotspotsRegistry RegisterVariableNamesHotspots(ITreeNode deconstructedDeclaration, IDeconstruction deconstruction, OneToListMap`2<int, IReferenceExpression> variableIndexToUsages, OneToListMap`2<int, string> componentIndexToAliasNames);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasOnlySingleVariableDeconstructionComponents(IDeconstruction deconstruction);
    [MustUseReturnValueAttribute]
public static bool CanDeconstructVariable(ITreeNode variableDeclaration, IReadOnlyList`1<ITreeNode> usages, IDeconstruction deconstruction, IUsagesProvider usagesProvider, bool ignoreUnresolvedMembers, bool applyStyleHeuristics, bool searchDeeperDeconstructions, bool allowSingleElementDeconstruction, bool canLeaveOriginalVariable, OneToListMap`2& componentIndexToUsagesMap, OneToListMap`2& componentIndexToAliasesMap, IReadOnlyList`1& deeperDeconstructions);
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
private static IReadOnlyList`1<DeconstructionTree> GenerateDeeperDeconstructions(IDeconstruction deconstruction, OneToListMap`2<int, DeconstructionTree> componentDeconstructionsMap);
    [PureAttribute]
[ContractAnnotationAttribute("=> false, componentReference: null; => true, componentReference: notnull")]
public static bool CanUpdateVariableUsage(ITreeNode variableUsage, IType deconstructType, ITreeNode declarationNode, bool allowToPossiblyIntroduceStructMutations, IReferenceExpression& componentReference);
    [CanBeNullAttribute]
[PureAttribute]
public static IDeconstruction CreateDeconstructionFromExisting(IDeconstructionReference deconstructionReference);
    [PureAttribute]
[CanBeNullAttribute]
[ItemCanBeNullAttribute]
public static IReadOnlyList`1<ISubpattern> CanDeconstructPropertyPatterns(ITreeNode usageContext, IDeconstruction deconstruction, IPropertyPatternClause propertyPatternClause, UInt32 disallowedComponentsMask);
    [PureAttribute]
public static bool IsPatternVariable(ITreeNode variableDeclaration);
    [PureAttribute]
public static bool IsTopLevelPatternVariable(ITreeNode variableDeclaration);
    [MustUseReturnValueAttribute]
private static bool CanDeconstructVariable(ITreeNode variableDeclaration, IReadOnlyList`1<ITreeNode> usages, IDeconstruction deconstruction, OneToListMap`2<int, IReferenceExpression> componentIndexToUsagesMapToFill, bool ignoreUnresolvedMembers, bool canLeaveOriginalVariable, Boolean& mustLeaveOriginalVariable);
    [MustUseReturnValueAttribute]
private static bool CanDeconstructTupleVariable(ITreeNode variableDeclaration, IReadOnlyList`1<ITreeNode> usages, DeconstructionFromTupleType deconstruction, OneToListMap`2<int, IReferenceExpression> componentIndexToUsagesMapToFill, bool ignoreUnresolvedMembers, bool canLeaveOriginalVariable, Boolean& mustLeaveOriginalVariable);
    [MustUseReturnValueAttribute]
private static bool CanDeconstructVariableByMethod(ITreeNode variableDeclaration, IReadOnlyList`1<ITreeNode> usages, DeconstructionByDeconstructMethod deconstruction, OneToListMap`2<int, IReferenceExpression> componentIndexToUsagesMapToFill, bool ignoreUnresolvedMembers, bool canLeaveOriginalVariable, Boolean& mustLeaveOriginalVariable);
    [CanBeNullAttribute]
[PureAttribute]
private static CorrespondingMemberOfParameter[] TryGetCorrespondingMembers(DeconstructionByDeconstructMethod deconstruction, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
private static CorrespondingMemberOfParameter[] TryGetCorrespondingMembers(IType deconstructionSourceType, IMethod deconstructMethod, ISubstitution methodSubstitution, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
private static CorrespondingMemberOfParameter[] TryGetCorrespondingMembersImpl(IType deconstructionSourceType, IMethod deconstructMethod, ISubstitution methodSubstitution, ITreeNode context);
    private static ComponentUsageKind AnalyzeComponentUsagesAndTryFindAliasVariables(IDeconstruction deconstruction, OneToListMap`2<int, IReferenceExpression> componentIndexToUsagesMap, IUsagesProvider usagesProvider, OneToListMap`2<int, ILocalVariableDeclaration> componentIndexToAliasesMap);
    [NotNullAttribute]
public static HotspotsRegistry DeconstructVariableDeclaration(ITreeNode variableDeclaration, IReadOnlyList`1<ITreeNode> usages, DeconstructionTree deconstructionTree);
    private static void RemoveAliasVariableDeclarations(IEnumerable`1<ILocalVariableDeclaration> declarations);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static HotspotsRegistry DeconstructVariableDeclaration(ITreeNode variableDeclaration, IReadOnlyList`1<ITreeNode> usages, IDeconstruction deconstruction);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private static HotspotsRegistry DeconstructVariableDeclaration(ITreeNode variableDeclaration, IReadOnlyList`1<ITreeNode> usages, IDeconstruction deconstruction, ITreeNode& deconstructedDeclaration, OneToListMap`2& componentIndexToUpdatedUsages, OneToListMap`2& componentIndexToAliasVariableDeclarations);
    [PureAttribute]
public static bool CanMergeDeconstructedDeclaration(IParenthesizedVariableDesignation parenthesizedDesignation);
    [PureAttribute]
private static bool CanMergeVariableDesignation(IVariableDesignation variableDesignation);
    [PureAttribute]
public static bool CanMergeDeconstructedDeclaration(ITupleExpression tupleExpression);
    [PureAttribute]
public static bool CanMergeDeconstructedDeclaration(IRecursivePattern recursivePattern);
    [PureAttribute]
public static bool CanBeReplacedWithMembers(IRecursivePattern recursivePattern);
    [PureAttribute]
[NotNullAttribute]
public static string CreateReplacementMemberName(ISubpattern deconstructionSubpattern);
    [PureAttribute]
public static bool HasCorrespondingMembers(IDeconstructionReference reference);
    [NotNullAttribute]
public static HotspotsRegistry MergeDeconstructedDeclaration(ITupleExpression tupleExpression);
    [NotNullAttribute]
public static HotspotsRegistry MergeDeconstructedDeclaration(IParenthesizedVariableDesignation parenthesizedDesignation);
    [CanBeNullAttribute]
public static HotspotsRegistry MergeDeconstructedDeclaration(IRecursivePattern recursivePattern);
    [CanBeNullAttribute]
private static HotspotsRegistry MergeDeconstructedDeclaration(ITreeNode deconstructedDeclaration);
    [PureAttribute]
public static bool CheckTypeConversionFromCollectionType(IVariableDesignation foreachVariableDesignation, IForeachStatement foreachStatement);
    [PureAttribute]
public static bool CanDeconstructLocalVariable(ILocalVariableDeclaration variableDeclaration);
    [PureAttribute]
private static bool CheckTypeConversionFromInitialValue(ICSharpExpression initialValue, IType localVariableType, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
private static bool CheckTypeConversion(IType variableType, IType sourceType, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
public static bool CanDeconstructPatternVariable(IVariableDesignation variableDesignation);
    [PureAttribute]
public static bool CanDeconstructPatternDiscard(IDiscardPattern discardPattern);
    [PureAttribute]
private static bool IsNotNullPatternDesignation(IVariableDesignation variableDesignation);
    [PureAttribute]
public static Nullable`1<UInt32> GetDiscardedDeconstructionsMask(IDeconstructionPatternClause deconstructionPatternClause);
    [NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<ISubpattern> GetLeastHolesSuggestion(IReadOnlyList`1<IReadOnlyList`1<ISubpattern>> suggestions);
    [CompilerGeneratedAttribute]
internal static bool <GetAvailableDeconstructionsImpl>g__ContainsSingleElementDeconstructions|2_3(IDeconstruction deconstruction);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
internal static IReadOnlyList`1<IDeconstruction> <GetDeconstructionsFromBasicComponents>g__BuildResult|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <GetDeconstructionsFromBasicComponents>g__AddDeconstructionComponent|6_1(IDeconstructionComponent component, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <GetDeconstructionsFromBasicComponents>g__AddDeconstructionComponentAlternatives|6_2(IReadOnlyList`1<IDeconstructionComponent> componentAlternatives, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <GetDeconstructionsFromBasicComponents>g__AddDeconstructionCopies|6_3(int copiesCount, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <CreateDeconstructionTemplate>g__BuildFormat|12_0(IDeconstructionComponent deconstructionComponent, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <GenerateDeeperDeconstructions>g__InitializeCountsAndIndicies|19_1(<>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
internal static bool <GenerateDeeperDeconstructions>g__MoveNext|19_2(<>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
internal static bool <GenerateDeeperDeconstructions>g__Increment|19_4(int index, <>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static DeconstructionTree <GenerateDeeperDeconstructions>g__CreateDeconstructionTree|19_3(<>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanUpdateVariableUsage>g__IsComponentVariableWillBeMutable|20_0(<>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanDeconstructPropertyPatterns>g__TryAdd|22_0(int index, ISubpattern subpattern, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static int <CanDeconstructPropertyPatterns>g__GetTupleComponentIndexByReference|22_1(ISubpattern subpattern, <>c__DisplayClass22_1& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static ValueTuple`2<IReferenceExpression, int> <CanDeconstructTupleVariable>g__GetTupleComponentIndexByReference|26_0(IReferenceExpression referenceExpression, <>c__DisplayClass26_0& );
    [CompilerGeneratedAttribute]
internal static int <CanDeconstructVariableByMethod>g__GetCorrespondingMemberIndex|27_0(<>c__DisplayClass27_0& , <>c__DisplayClass27_1& , <>c__DisplayClass27_2& );
    [CompilerGeneratedAttribute]
internal static void <TryGetCorrespondingMembersImpl>g__AddMembersDerivedFromParameter|31_0(NamedElementKinds kind, Predicate`1<TMember> memberFilter, <>c__DisplayClass31_0& , <>c__DisplayClass31_1& );
    [CompilerGeneratedAttribute]
internal static CorrespondingMemberOfParameter <TryGetCorrespondingMembersImpl>g__GetSingleOrDelegatingMember|31_1(<>c__DisplayClass31_1& );
    [CompilerGeneratedAttribute]
internal static ComponentUsageKind <AnalyzeComponentUsagesAndTryFindAliasVariables>g__AnalyzeUsage|34_4(IReferenceExpression componentUsage, ILocalVariableDeclaration& aliasVariableDeclaration, <>c__DisplayClass34_0& , <>c__DisplayClass34_1& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <AnalyzeComponentUsagesAndTryFindAliasVariables>g__IsComponentUsagesSafe|34_0(IList`1<IReferenceExpression> usages);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <AnalyzeComponentUsagesAndTryFindAliasVariables>g__CanInlineAliasVariable|34_1(ILocalVariable aliasVariable, <>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <AnalyzeComponentUsagesAndTryFindAliasVariables>g__CanInlineComponentUsage|34_2(IReferenceExpression componentUsage);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <AnalyzeComponentUsagesAndTryFindAliasVariables>g__CanInlineAliasVariableUsage|34_3(IReferenceExpression aliasVariableUsage, bool isSourceVariableMutable);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static HotspotsRegistry <DeconstructVariableDeclaration>g__DeconstructVariableDeclarationCore|35_0(ITreeNode currentVariableDeclaration, IReadOnlyList`1<ITreeNode> currentUsages, DeconstructionTree currentDeconstructionTree, <>c__DisplayClass35_0& );
    [CompilerGeneratedAttribute]
internal static ITreeNode <DeconstructVariableDeclaration>g__GetDeconstructedComponent|35_1(ITreeNode deconstructedDeclaration, int componentIndex);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
[MustUseReturnValueAttribute]
internal static OneToListMap`2<int, string> <DeconstructVariableDeclaration>g__RenameAliasDeclarations|38_0(OneToListMap`2<int, ILocalVariableDeclaration> aliasDeclarationsMap, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
internal static void <DeconstructVariableDeclaration>g__DiscardUnusedVariables|38_1(IParenthesizedVariableDesignation variableDesignation, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
[PureAttribute]
internal static IDiscardDesignation <DeconstructVariableDeclaration>g__CreateDiscardDesignation|38_12(<>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
internal static String[] <DeconstructVariableDeclaration>g__GetComponentNames|38_2(IParenthesizedVariableDesignation variableDesignation);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static OneToListMap`2<int, IReferenceExpression> <DeconstructVariableDeclaration>g__ReplaceUsagesWithComponentNames|38_3(String[] componentNames, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <DeconstructVariableDeclaration>g__IsForeachVariableDesignation|38_4(IVariableDesignation variableDesignation);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <DeconstructVariableDeclaration>g__IsNestedVariableDesignation|38_5(IVariableDesignation variableDesignation);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static ICSharpExpression <DeconstructVariableDeclaration>g__UpdateLocalVariableDeclaration|38_6(ILocalVariableDeclaration localVariableDeclaration, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static ICSharpExpression <DeconstructVariableDeclaration>g__UpdateForeachVariableDesignation|38_7(IVariableDesignation foreachVariableDesignation, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static ITreeNode <DeconstructVariableDeclaration>g__UpdatePatternVariableDesignation|38_8(IVariableDesignation patternVariableDesignation, bool leaveOriginalVariable, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static ITreeNode <DeconstructVariableDeclaration>g__UpdateNestedVariableDesignation|38_9(IVariableDesignation nestedVariableDesignation, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static ICSharpExpression <DeconstructVariableDeclaration>g__UpdateDiscardReferenceExpression|38_10(IReferenceExpression referenceExpression, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static ITreeNode <DeconstructVariableDeclaration>g__UpdateDiscardPattern|38_11(IDiscardPattern discardPattern, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static HotspotsRegistry <MergeDeconstructedDeclaration>g__MergeDeclarationExpression|49_0(IDeclarationExpression declarationExpression, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static HotspotsRegistry <MergeDeconstructedDeclaration>g__ReplaceExpressionStatement|49_1(IExpressionStatement expressionStatement, IAssignmentExpression assignmentExpression, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static HotspotsRegistry <MergeDeconstructedDeclaration>g__MergeParenthesizedDesignation|49_2(IParenthesizedVariableDesignation parenthesizedDesignation, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static HotspotsRegistry <MergeDeconstructedDeclaration>g__MergeTupleExpression|49_3(ITupleExpression tupleExpression, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static HotspotsRegistry <MergeDeconstructedDeclaration>g__MergeDeconstructionPattern|49_4(IRecursivePattern recursivePattern, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static HotspotsRegistry <MergeDeconstructedDeclaration>g__CreateHotspotsRegistry|49_5(ITreeNode insertedNode, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
[PureAttribute]
internal static IReferenceExpression <MergeDeconstructedDeclaration>g__CreateComponentAccess|49_6(IReferenceExpression qualifier, string componentName, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
internal static void <MergeDeconstructedDeclaration>g__ProcessVariableDesignation|49_7(IVariableDesignation variableDesignation, IReferenceExpression qualifiedName, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
internal static void <MergeDeconstructedDeclaration>g__ProcessTupleExpression|49_8(ITupleExpression tupleExpression, IReferenceExpression qualifiedName, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
internal static void <MergeDeconstructedDeclaration>g__ProcessDeconstructionPattern|49_9(IRecursivePattern recursivePattern, IReferenceExpression qualifiedName, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
internal static void <MergeDeconstructedDeclaration>g__ProcessSingleVariableDesignation|49_10(ISingleVariableDesignation singleVariableDesignation, IReferenceExpression qualifiedName, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static ValueTuple`2<IReferenceExpression, IReadOnlyList`1<string>> <MergeDeconstructedDeclaration>g__CreateReferenceExpressionWithNameSuggestions|49_11(IType sourceType, ITreeNode context, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
internal static void <MergeDeconstructedDeclaration>g__SaveMergedVariableUsage|49_12(IReferenceExpression insertedReferenceExpression, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
[PureAttribute]
internal static INamesSuggestion <MergeDeconstructedDeclaration>g__GetMergedVariableNameSuggestion|49_13(IType type, ITreeNode context);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
internal static String[] <MergeDeconstructedDeclaration>g__GetComponentNames|49_14(IDeconstructionReference reference, IType sourceType, int componentsCount);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.DefiniteAssignmentUtil : object {
    [PureAttribute]
public static bool IsDefinitelyAssignedForSure(ICSharpExpression expression);
    [PureAttribute]
public static bool CanAffectDefiniteAssignmentAnalysis(ITreeNode codeToCheck);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.ElementCopySource : ValueType {
    [NullableAttribute("2")]
public ICSharpExpression Expression;
    [NullableContextAttribute("2")]
public ElementCopySource(ICSharpExpression expression);
    [NullableContextAttribute("1")]
[PureAttribute]
public IType GetSourceType(ICSharpTreeNode context);
    public sealed virtual bool Equals(ElementCopySource other);
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.Util.ExpressionWriteAccessChecker : object {
    public bool CanCheckRelatedExpressions { get; }
    public abstract virtual bool get_CanCheckRelatedExpressions();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<ICSharpTreeNode> FindRelatedExpressions(ICSharpTreeNode scope);
    [PureAttribute]
public bool HasRelatedExpressionsInScope(ICSharpTreeNode scope);
    [NotNullAttribute]
public static ExpressionWriteAccessChecker CreateAccessCheckerForAccess(IAccess access);
    [NotNullAttribute]
public static ExpressionWriteAccessChecker CreateAccessCheckerForExpression(ICSharpExpression sourceExpression);
    [PureAttribute]
private static bool IsReadOnlyStateAccess(IReferenceExpression referenceExpression);
    [PureAttribute]
private static bool IsReadOnlyElement(IDeclaredElement declaredElement);
    [PureAttribute]
private static bool IsRootTypeOwnerReferenceExpression(IReferenceExpression referenceExpression);
    [NotNullAttribute]
public static ExpressionWriteAccessChecker CreateAccessCheckerForLocalVariable(ILocalVariable localVariable);
    public bool HasPossibleWritesBeforeExpression(ICSharpTreeNode rootNode, ICSharpExpression expression);
    [MustUseReturnValueAttribute]
public static bool HasPossibleWritesBeforeExpression(ICSharpTreeNode rootNode, ICSharpExpression expression, IEnumerable`1<ICSharpTreeNode> possibleWriteExpressions);
    private static bool MightBePartOfGotoCaseLoop(ISwitchSection switchSection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.ForeachLoopUtil : object {
    [NullableContextAttribute("2")]
public static bool CheckCanWrapInForeachLoop(ICSharpExpression collectionExpression, bool isAwaitForeach, IType& iteratorType);
    [MustUseReturnValueAttribute]
public static ForeachResult WrapInForeachStatement(ICSharpExpression collectionExpression, bool isAwaitForeach, bool replaceOriginalExpressionWithIterationVariableUsage, bool enforceBraces);
    [MustUseReturnValueAttribute]
public static ForeachResult GetResultFromExistingForeach(IForeachStatement foreachStatement, DocumentOffset caretEndOffset);
    [MustUseReturnValueAttribute]
public static IBulbActionCommand WrapInForeachStatementAndCreateDeconstructionAndTemplatingCommand(ICSharpExpression collectionExpression, bool isAwaitForeach, bool replaceOriginalExpressionWithIterationVariableUsage, bool enforceBraces, bool showDeconstructionOptions);
    [MustUseReturnValueAttribute]
public static IBulbActionCommand CreateDeconstructionAndTemplatingCommand(ForeachResult result, bool showDeconstructionOptions);
    [PureAttribute]
public static INamesSuggestion SuggestIterationVariableNames(IForeachStatement foreachStatement, ISingleVariableDesignation iteratorVariableDeclaration, bool includeExistingName);
    private static IBulbActionCommand CreateHotspotsForSingleIterationVariable(IForeachStatement foreachStatement, IReadOnlyCollection`1<string> namesCollection, IReferenceExpression iterationVariableUsage, DocumentOffset endCaretPosition);
    [CompilerGeneratedAttribute]
internal static bool <CreateDeconstructionAndTemplatingCommand>g__HasNoIterationVariableUsageOrCanRemoveIt|5_0(<>c__DisplayClass5_0& );
}
public enum JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.BodyKind : Enum {
    public int value__;
    public static BodyKind ReachableExit;
    public static BodyKind ReturnAtEnd;
    public static BodyKind HasBreakOrGotoCase;
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.IfToSwitchUtil : object {
    [ItemNotNullAttribute]
public static HashSet`1<IDeclaredElement> CollectVariablesFromCondition(IIfStatement ifStatement);
    public static bool HasIntroducedVariableUsagesOutOfNewScope(IIfStatement ifStatement, HashSet`1<IDeclaredElement> localVariables, ICSharpStatement associatedStatement, IUsagesProvider usagesProvider);
    public static BodyKind InspectStatement(ICSharpStatement rootStatement);
    private static BodyKind InspectStatement(ICSharpStatement statement, bool ignoreBreakStatements);
    public static void MoveCommentsToCaseLabel(ISwitchCaseLabel switchCaseLabel, IList`1<ICSharpCommentNode> comments);
    public static void MoveCommentsSwitchExpressionArm(ISwitchExpressionArm switchExpressionArm, IList`1<ICSharpCommentNode> comments);
    private static void MoveCommentsToAnchorNode(ITreeNode anchor, IList`1<ICSharpCommentNode> comments);
    [CompilerGeneratedAttribute]
internal static BodyKind <InspectStatement>g__InspectStatementsOwner|3_0(IStatementsOwner statementsOwner, Nullable`1<bool> ignoreNestedBreakStatements, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static BodyKind <InspectStatement>g__InspectStatementRecursive|3_1(ICSharpStatement nextStatement, <>c__DisplayClass3_0& );
}
public abstract class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchCaseCheck : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <VariableExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Polyadic`1<ICSharpExpression> <Guard>k__BackingField;
    [CanBeNullAttribute]
private WhitespaceAndCommentsAround myGuardWhitespace;
    [NotNullAttribute]
public ICSharpExpression VariableExpression { get; }
    [CanBeNullAttribute]
public Polyadic`1<ICSharpExpression> Guard { get; private set; }
    [CanBeNullAttribute]
public ICSharpStatement AssociatedStatement { get; }
    public bool MustBeTheOnlyCase { get; }
    public bool IsNullCheckCase { get; }
    public bool CanCaptureNull { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IReadOnlyList`1<ICSharpExpression> GuardExpressions { get; }
    protected SwitchCaseCheck(ICSharpExpression variableExpression);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_VariableExpression();
    [CompilerGeneratedAttribute]
public Polyadic`1<ICSharpExpression> get_Guard();
    [CompilerGeneratedAttribute]
private void set_Guard(Polyadic`1<ICSharpExpression> value);
    public virtual ICSharpStatement get_AssociatedStatement();
    public virtual bool get_MustBeTheOnlyCase();
    public virtual bool get_IsNullCheckCase();
    public virtual bool get_CanCaptureNull();
    [PureAttribute]
public abstract virtual bool CanBeRepresentedIn(CSharpLanguageLevel languageLevel);
    [PureAttribute]
[CanBeNullAttribute]
public virtual SwitchCaseCheck TryNegate(bool onlyReduceComplexity);
    [MustUseReturnValueAttribute]
public abstract virtual FactoryArgumentsBuilder AppendCasePattern(FactoryArgumentsBuilder argumentsBuilder, ITreeNode context);
    public IReadOnlyList`1<ICSharpExpression> get_GuardExpressions();
    [NotNullAttribute]
public virtual IEnumerable`1<ILocalVariable> GetIntroducedVariables();
    public abstract virtual ValueTuple`2<bool, bool> AreMutuallyExclusive(SwitchCaseCheck otherCheck, ICSharpTreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    [NotNullAttribute]
public abstract virtual StateForCase GetDecisionDagTests(int index, DecisionDagBuilder decisionDagBuilder, DagTempVariable rootIdentifier, DecisionDagConclusion decisionDagConclusion);
    [NotNullAttribute]
public abstract virtual SwitchCaseCheck Clone();
    public void AppendToGuard(ICSharpExpression expression, bool appendBeforeGuard);
    public void RemoveFromGuard(ICSharpExpression expression);
    public void SetGuard(Polyadic`1<ICSharpExpression> guard, WhitespaceAndCommentsAround aroundWhen);
    [PureAttribute]
public bool CanJoinViaAnd(SwitchCaseCheck otherCheck, bool isNullMatched);
    [NotNullAttribute]
public ISwitchCaseLabel CreateSwitchCaseLabel(CSharpElementFactory factory, ITreeNode context);
    protected bool AreMutuallyExclusiveWithConstantCheck(ConstantValue thisConstantValue, IValueSet thisValueSet, SwitchCaseCheck otherCheck, ICSharpTreeNode context);
    protected static ValueTuple`2<bool, bool> AreMutuallyExclusiveWithTypeCheck(IType type, SwitchCaseCheck otherCheck, ITreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    [CanBeNullAttribute]
protected static IValueSet ValueSetFromPattern(IPattern pattern);
    [PureAttribute]
private static ValueTuple`2<bool, bool> HaveCommonSubtype(IExpressionType type1, IExpressionType type2, Nullable`1& typeCompatibilityCheckLimit);
    [CanBeNullAttribute]
protected ICSharpExpression GetGuardSampleExpression();
    [PureAttribute]
private static bool AreConstantCheckMutuallyExclusiveWithTypeCheck(ConstantValue constantValue, IType typeCheckType, ITreeNode context);
    protected static FactoryArgumentsBuilder AppendIsExpressionToCasePattern(FactoryArgumentsBuilder argumentsBuilder, IIsExpression isExpression);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<bool, bool> <AreMutuallyExclusiveWithTypeCheck>g__MutuallyExclusive|32_0(IPattern pattern, Nullable`1& typeCompatibilityCheckLimit, <>c__DisplayClass32_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchCaseCombinedCheck : SwitchCaseCheck {
    [CompilerGeneratedAttribute]
private bool <IsOrCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SwitchCaseCheck> <Checks>k__BackingField;
    public bool IsOrCheck { get; }
    [NotNullAttribute]
public IReadOnlyList`1<SwitchCaseCheck> Checks { get; }
    public bool IsNullCheckCase { get; }
    public bool CanCaptureNull { get; }
    public SwitchCaseCombinedCheck(bool isOrCheck, IReadOnlyList`1<SwitchCaseCheck> checks, ICSharpExpression variableExpression);
    [CompilerGeneratedAttribute]
public bool get_IsOrCheck();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SwitchCaseCheck> get_Checks();
    private bool AnyOrAll(bool useAny, Func`2<SwitchCaseCheck, bool> func);
    public virtual bool get_IsNullCheckCase();
    public virtual bool get_CanCaptureNull();
    public virtual bool CanBeRepresentedIn(CSharpLanguageLevel languageLevel);
    public virtual IEnumerable`1<ILocalVariable> GetIntroducedVariables();
    public virtual ValueTuple`2<bool, bool> AreMutuallyExclusive(SwitchCaseCheck otherCheck, ICSharpTreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    public virtual StateForCase GetDecisionDagTests(int index, DecisionDagBuilder decisionDagBuilder, DagTempVariable rootIdentifier, DecisionDagConclusion decisionDagConclusion);
    public virtual SwitchCaseCheck Clone();
    public virtual FactoryArgumentsBuilder AppendCasePattern(FactoryArgumentsBuilder argumentsBuilder, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
public static SwitchCaseCheck TryCreateFromChecksList(bool isOrCheck, IReadOnlyList`1<SwitchCaseCheck> checks);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchCaseConstantCheck : SwitchCaseCheck {
    [CanBeNullAttribute]
private ICSharpExpression myConstantExpression;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNegated>k__BackingField;
    [NotNullAttribute]
public ConstantValue ConstantValue { get; }
    public bool IsNegated { get; }
    public bool IsNullCheckCase { get; }
    public bool CanCaptureNull { get; }
    private SwitchCaseConstantCheck(ICSharpExpression variableReference, ICSharpExpression constantExpression, ConstantValue constantValue, bool isNegated);
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValue();
    [CompilerGeneratedAttribute]
public bool get_IsNegated();
    public virtual bool get_IsNullCheckCase();
    public virtual bool get_CanCaptureNull();
    public virtual bool CanBeRepresentedIn(CSharpLanguageLevel languageLevel);
    public virtual SwitchCaseCheck TryNegate(bool onlyReduceComplexity);
    [CanBeNullAttribute]
[PureAttribute]
public static SwitchCaseConstantCheck TryCreateFromEqualityExpression(IEqualityExpression equalityExpression, bool allowNegatedChecks);
    [CanBeNullAttribute]
[PureAttribute]
public static SwitchCaseCheck TryCreateFromInvocationExpression(IInvocationExpression invocationExpression, bool allowNullableTypes);
    [CanBeNullAttribute]
[PureAttribute]
public static SwitchCaseConstantCheck TryCreateFromBooleanExpression(ICSharpExpression expression);
    [NotNullAttribute]
public static SwitchCaseCheck CreatePureNullCheck(ICSharpExpression checkedExpression, bool isNegated);
    [CanBeNullAttribute]
public static SwitchCaseCheck TryCreateFromIsEqualsNullCheck(ICSharpExpression checkedExpression, bool isNegated);
    public virtual ValueTuple`2<bool, bool> AreMutuallyExclusive(SwitchCaseCheck otherCheck, ICSharpTreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    [CanBeNullAttribute]
public IValueSet TryGetValueSet(ITreeNode context);
    public virtual StateForCase GetDecisionDagTests(int index, DecisionDagBuilder decisionDagBuilder, DagTempVariable rootIdentifier, DecisionDagConclusion decisionDagConclusion);
    public virtual FactoryArgumentsBuilder AppendCasePattern(FactoryArgumentsBuilder argumentsBuilder, ITreeNode context);
    public virtual SwitchCaseCheck Clone();
    [PureAttribute]
private static ConstantValueCheckInvocationKind IsEquivalentToConstantPattern(IInvocationExpression invocationExpression);
    [CanBeNullAttribute]
private static SwitchCaseConstantCheck TryCreateConstantCheck(ICSharpExpression variableExpression, ICSharpExpression constantExpression, bool useImplicitlyConvertedTo, bool isNullMatched);
    [CanBeNullAttribute]
private static SwitchCaseConstantCheck TryCreateFromStringEmpty(ICSharpExpression variableExpression, ICSharpExpression stringEmptyExpression);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static SwitchCaseCheck <TryCreateFromInvocationExpression>g__FromTwoArguments|15_2(ICSharpExpression firstExpression, ICSharpExpression secondExpression, <>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static SwitchCaseCheck <TryCreateFromInvocationExpression>g__FromNanCheck|15_3(Func`2<PredefinedType, IDeclaredType> type, <>c__DisplayClass15_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchCaseNullPropagationTypeCheck : SwitchCaseTypeCheck {
    private SwitchCaseNullPropagationTypeCheck(IType type, ICSharpExpression variableExpression, IDeclarationStatement declarationStatement);
    [CanBeNullAttribute]
public static SwitchCaseCheck TryCreateCheck(ICSharpExpression expression);
    [PureAttribute]
private static bool StartsWithNullCheck(ICSharpExpression expression, ICSharpLocalVariable nullCheckedVariable, IAccess& unliftedAccess);
    [CompilerGeneratedAttribute]
internal static IAccess <StartsWithNullCheck>g__UnwrapFromNullPropagating|2_2(IAccess access);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchCasePatternCheck : SwitchCaseCheck {
    [CompilerGeneratedAttribute]
private IPattern <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNegated>k__BackingField;
    [NotNullAttribute]
public IPattern Pattern { get; }
    public bool IsNegated { get; }
    public bool IsNullCheckCase { get; }
    public bool CanCaptureNull { get; }
    public SwitchCasePatternCheck(IPattern pattern, ICSharpExpression variableExpression, bool isNegated);
    [CompilerGeneratedAttribute]
public IPattern get_Pattern();
    [CompilerGeneratedAttribute]
public bool get_IsNegated();
    public virtual IEnumerable`1<ILocalVariable> GetIntroducedVariables();
    public virtual bool get_IsNullCheckCase();
    public virtual bool get_CanCaptureNull();
    public virtual bool CanBeRepresentedIn(CSharpLanguageLevel languageLevel);
    public virtual SwitchCaseCheck TryNegate(bool onlyReduceComplexity);
    public bool HasDesignationsUnderNegatedPattern();
    public virtual ValueTuple`2<bool, bool> AreMutuallyExclusive(SwitchCaseCheck otherCheck, ICSharpTreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    public virtual StateForCase GetDecisionDagTests(int index, DecisionDagBuilder decisionDagBuilder, DagTempVariable rootIdentifier, DecisionDagConclusion decisionDagConclusion);
    public virtual FactoryArgumentsBuilder AppendCasePattern(FactoryArgumentsBuilder argumentsBuilder, ITreeNode context);
    public virtual SwitchCaseCheck Clone();
    [CompilerGeneratedAttribute]
private ValueTuple`2<bool, bool> <AreMutuallyExclusive>g__MutuallyExclusive|15_0(IPattern pattern, Nullable`1& typeCompatibilityCheckLimit, <>c__DisplayClass15_0& );
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchCaseRelationalCheck : SwitchCaseCheck {
    [NotNullAttribute]
private ICSharpExpression myConstantExpression;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValue>k__BackingField;
    [CompilerGeneratedAttribute]
private RelationalPatternKind <RelationKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeNegated>k__BackingField;
    [NotNullAttribute]
public ConstantValue ConstantValue { get; }
    public RelationalPatternKind RelationKind { get; }
    public bool CanBeNegated { get; }
    public bool IsNullCheckCase { get; }
    public bool CanCaptureNull { get; }
    private SwitchCaseRelationalCheck(ICSharpExpression variableReference, ICSharpExpression constantExpression, ConstantValue constantValue, RelationalPatternKind relationKind, bool canBeNegated);
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValue();
    [CompilerGeneratedAttribute]
public RelationalPatternKind get_RelationKind();
    [CompilerGeneratedAttribute]
public bool get_CanBeNegated();
    public virtual bool get_IsNullCheckCase();
    public virtual bool get_CanCaptureNull();
    public virtual bool CanBeRepresentedIn(CSharpLanguageLevel languageLevel);
    public virtual SwitchCaseCheck TryNegate(bool onlyReduceComplexity);
    [CanBeNullAttribute]
[PureAttribute]
public static SwitchCaseRelationalCheck TryCreateFromRelationalExpression(IRelationalExpression relationalExpression);
    public virtual ValueTuple`2<bool, bool> AreMutuallyExclusive(SwitchCaseCheck otherCheck, ICSharpTreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    [CanBeNullAttribute]
public IValueSet TryGetValueSet();
    public virtual StateForCase GetDecisionDagTests(int index, DecisionDagBuilder decisionDagBuilder, DagTempVariable rootIdentifier, DecisionDagConclusion decisionDagConclusion);
    public virtual FactoryArgumentsBuilder AppendCasePattern(FactoryArgumentsBuilder argumentsBuilder, ITreeNode context);
    public virtual SwitchCaseCheck Clone();
    [CanBeNullAttribute]
private static SwitchCaseRelationalCheck TryCreateRelationalCheck(ICSharpExpression variableExpression, ICSharpExpression constantExpression, RelationalPatternKind kind, bool canBeNegated);
    [CompilerGeneratedAttribute]
internal static RelationalPatternKind <TryCreateFromRelationalExpression>g__Reverse|17_0(RelationalPatternKind kind);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchCaseTypeCheck : SwitchCaseCheck {
    [CanBeNullAttribute]
private IDeclarationStatement myDeclarationStatement;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [NotNullAttribute]
public IType Type { get; }
    public ICSharpStatement AssociatedStatement { get; }
    public bool MustBeTheOnlyCase { get; }
    public bool CanCaptureNull { get; }
    protected SwitchCaseTypeCheck(IType type, ICSharpExpression variableExpression, IDeclarationStatement declarationStatement);
    [CompilerGeneratedAttribute]
public IType get_Type();
    public virtual ICSharpStatement get_AssociatedStatement();
    public virtual bool get_MustBeTheOnlyCase();
    public virtual bool get_CanCaptureNull();
    public virtual bool CanBeRepresentedIn(CSharpLanguageLevel languageLevel);
    public virtual IEnumerable`1<ILocalVariable> GetIntroducedVariables();
    [CanBeNullAttribute]
public static SwitchCaseCheck CreateFromIsExpression(IIsExpression isExpression);
    [CanBeNullAttribute]
public static SwitchCaseCheck TryCreateTypeCheck(NullCheckData nullCheckData);
    public virtual ValueTuple`2<bool, bool> AreMutuallyExclusive(SwitchCaseCheck otherCheck, ICSharpTreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    public virtual StateForCase GetDecisionDagTests(int index, DecisionDagBuilder decisionDagBuilder, DagTempVariable rootIdentifier, DecisionDagConclusion decisionDagConclusion);
    public virtual FactoryArgumentsBuilder AppendCasePattern(FactoryArgumentsBuilder argumentsBuilder, ITreeNode context);
    public virtual SwitchCaseCheck Clone();
    [CanBeNullAttribute]
[ContractAnnotationAttribute("=> switchExpression:notnull, notnull; => switchExpression:null, null")]
protected static ILocalVariableDeclaration FindTypeCheckedVariableDeclaration(ICSharpExpression expression, ICSharpExpression& switchExpression);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchSection : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
private List`1<SwitchCaseCheck> myLabels;
    [NotNullAttribute]
[ItemNotNullAttribute]
private List`1<IIfStatement> mySecondaryIfStatements;
    [CompilerGeneratedAttribute]
private IIfStatement <IfStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpStatementsRange <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private BodyKind <BodyKind>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<SwitchCaseCheck> Labels { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IIfStatement> SecondaryIfStatements { get; }
    [NotNullAttribute]
public IIfStatement IfStatement { get; }
    [CanBeNullAttribute]
public ICSharpStatementsRange Body { get; }
    public BodyKind BodyKind { get; }
    public bool IsDefaultCase { get; }
    public SwitchSection(IIfStatement ifStatement, ICSharpStatementsRange body, BodyKind bodyKind, IReadOnlyList`1<SwitchCaseCheck> labels, List`1<IIfStatement> secondaryIfStatements);
    public IReadOnlyList`1<SwitchCaseCheck> get_Labels();
    public IReadOnlyList`1<IIfStatement> get_SecondaryIfStatements();
    [CompilerGeneratedAttribute]
public IIfStatement get_IfStatement();
    [CompilerGeneratedAttribute]
public ICSharpStatementsRange get_Body();
    [CompilerGeneratedAttribute]
public BodyKind get_BodyKind();
    public bool get_IsDefaultCase();
    public ValueTuple`2<bool, bool> AreMutuallyExclusive(SwitchSection otherSection, ICSharpTreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    public bool TryMergeSwitchSections(SwitchSection otherSection, IUsagesProvider usagesProvider);
    private static ValueTuple`2<bool, bool> AllChecksAreMutuallyExclusive(SwitchCaseCheck label, SwitchSection otherSection, ICSharpTreeNode context, Nullable`1& typeCompatibilityCheckLimit);
    private bool HasConflictingVariables(SwitchSection otherSection, IUsagesProvider usagesProvider);
    [ItemNotNullAttribute]
private HashSet`1<IDeclaredElement> GetAllIntroducedVariables();
    [CanBeNullAttribute]
private ICSharpStatement FindSingleBodyStatement();
    [ContractAnnotationAttribute("statement:null => false; otherStatement:null => false")]
private static bool StatementsAreEquivalent(ICSharpStatement statement, ICSharpStatement otherStatement);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertVariablesAreNotUsedInSectionBody(HashSet`1<IDeclaredElement> variables, IUsagesProvider usagesProvider);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.IfToSwitch.SwitchSectionsCollector : object {
    private static int ImplicitDefaultSectionAllowedStatementsCount;
    private static int AvailabilityCheckCommonSubtypeLookupsLimit;
    [CompilerGeneratedAttribute]
private ICSharpTreeNode <ConditionalNode>k__BackingField;
    [NotNullAttribute]
private List`1<SwitchSection> mySections;
    [NotNullAttribute]
private IUsagesProvider myUsagesProvider;
    private bool myIsSwitchExpressionAvailabilityCheck;
    private CSharpLanguageLevel myLanguageLevel;
    private Nullable`1<byte> mySectionsLimit;
    private bool myIsNullMatched;
    private Nullable`1<int> myCommonSubtypeCheckLimit;
    [CompilerGeneratedAttribute]
private IList`1<SwitchSection> <OpenWorldSections>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExpression <SwitchVariableExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <GoverningType>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccess <SwitchVariableAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionWriteAccessChecker <WriteAccessChecker>k__BackingField;
    [NotNullAttribute]
public ICSharpTreeNode ConditionalNode { get; }
    [NotNullAttribute]
public IList`1<SwitchSection> Sections { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<SwitchSection> OpenWorldSections { get; private set; }
    [CanBeNullAttribute]
public ICSharpExpression SwitchVariableExpression { get; private set; }
    [CanBeNullAttribute]
public IType GoverningType { get; private set; }
    [CanBeNullAttribute]
private IAccess SwitchVariableAccess { get; private set; }
    [CanBeNullAttribute]
private ExpressionWriteAccessChecker WriteAccessChecker { get; private set; }
    public bool IsOpenWorld { get; }
    public SwitchSectionsCollector(ICSharpTreeNode conditionalNode, IUsagesProvider usagesProvider, bool isSwitchExpressionAvailabilityCheck, Nullable`1<byte> sectionsLimit, bool batterySaverMode);
    [CompilerGeneratedAttribute]
public ICSharpTreeNode get_ConditionalNode();
    public IList`1<SwitchSection> get_Sections();
    [CompilerGeneratedAttribute]
public IList`1<SwitchSection> get_OpenWorldSections();
    [CompilerGeneratedAttribute]
private void set_OpenWorldSections(IList`1<SwitchSection> value);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_SwitchVariableExpression();
    [CompilerGeneratedAttribute]
private void set_SwitchVariableExpression(ICSharpExpression value);
    [CompilerGeneratedAttribute]
public IType get_GoverningType();
    [CompilerGeneratedAttribute]
private void set_GoverningType(IType value);
    [CompilerGeneratedAttribute]
private IAccess get_SwitchVariableAccess();
    [CompilerGeneratedAttribute]
private void set_SwitchVariableAccess(IAccess value);
    [CompilerGeneratedAttribute]
private ExpressionWriteAccessChecker get_WriteAccessChecker();
    [CompilerGeneratedAttribute]
private void set_WriteAccessChecker(ExpressionWriteAccessChecker value);
    public bool HasDefaultSection(bool openWorld);
    public bool get_IsOpenWorld();
    public bool CoerceToOpenWorldResultIfSettingEnabled(Expression`1<Func`2<TSettingsKey, bool>> assumeOpenTypeHierarchySetting);
    public void ToOpenWorldResult();
    public bool CollectSwitchSections(IIfStatement ifStatement);
    private static void TrimSectionsFrom(List`1<SwitchSection> currentSections, int trimStartIndex);
    public bool CollectSwitchSections(IConditionalTernaryExpression conditionalExpression);
    private Nullable`1<int> FindFirstSubsumedSection(DecisionDag decisionDag);
    private bool CollectSwitchSectionsInternal(IIfStatement ifStatement, Nullable`1& openWorldLimit);
    private bool CollectSwitchSections(IIfStatement ifStatement, ICSharpStatement expectedAssociatedStatement, Boolean& hasWritesToConditionOnFallthroughPath);
    [PureAttribute]
private bool HasIntroducedVariableUsagesOutOfNewScope(SwitchCaseCheck switchCaseCheck, IIfStatement ifStatement);
    private bool ProcessElseBranch(IIfStatement ifStatement, Boolean& hasWritesToConditionOnFallthroughPath);
    [CanBeNullAttribute]
[MustUseReturnValueAttribute]
private IReadOnlyList`1<SwitchCaseCheck> TryCreateAlternatingCaseChecks(ICSharpExpression condition, bool isNullMatched);
    private static bool IsNullMatched(IReadOnlyList`1<SwitchCaseCheck> checks);
    private bool AppendSwitchSections(IIfStatement ifStatement, IReadOnlyList`1<SwitchCaseCheck> checks, ICSharpStatement body, BodyKind bodyKind, Boolean& hasWritesToConditionOnFallthroughPath);
    [ContractAnnotationAttribute("null => false")]
[PureAttribute]
public bool CanAddSwitchCaseForExpression(ICSharpExpression variableExpression);
    [NotNullAttribute]
private static SwitchSection CreateDefaultSwitchSection(IIfStatement ifStatement, ICSharpStatement body, BodyKind bodyKind);
    public bool HasSectionsWithIfsThatCanBeRewrittenInGuards();
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<SwitchSection> GetOptimizedSwitchSections(OneToListMap`2& switchLabelComments, bool rewriteIfsToGuards);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<SwitchSection> MergeEquivalentSwitchSections(IReadOnlyList`1<SwitchSection> switchSections, OneToListMap`2& switchLabelComments);
    [CanBeNullAttribute]
private static SwitchSection TryCreateDefaultSectionFromRestStatements(IEnumerable`1<SwitchSection> switchSections);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IList`1<ICSharpCommentNode> CollectCommentsForDefaultSection(SwitchSection switchSection);
    private static void CollectCommentsForSwitchSection(SwitchSection switchSection, OneToListMap`2<SwitchCaseCheck, ICSharpCommentNode> switchLabelComments, bool isFirstSection);
    private static FrugalLocalList`1<SwitchSection> ProcessPossibleGuardConditions(SwitchSection switchSection, bool switchHasDefaultSection);
    private static FrugalLocalList`1<SwitchSection> SplitNestedIfStatementToGuardedSections(SwitchSection switchSection, bool switchHasDefaultSection);
    private static bool CanMoveIfToGuard(IIfStatement ifStatement, BodyKind bodyKind);
    [CanBeNullAttribute]
private static ICSharpStatementsRange GetBlockStatementsRangeFrom(ICSharpStatement firstRangeStatement);
    [NotNullAttribute]
private static SwitchSection MoveNestedIfStatementsToGuard(SwitchSection switchSection, ICSharpStatementsRange body);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
private static IIfStatement FindNestedGuard(IStatement statement);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<ICSharpCommentNode> CollectCommentsBeforeSwitchCase(SwitchSection switchCase, bool isFirstSection);
    [PureAttribute]
private static bool CanCreateDefaultSectionsFromRemainingStatements(IIfStatement lastIfStatement, ICSharpStatementsRange& restStatementsRange);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<ICSharpCommentNode> CollectCommentsFromCondition(SwitchSection switchCase);
    [CanBeNullAttribute]
private static ITreeNode FindLastNodeForComments(SwitchSection switchCase);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("notnull => notnull")]
private static ITreeNode FindPreviousMeaningfulNodeForComments(ITreeNode treeNode);
    [CompilerGeneratedAttribute]
private ValueTuple`2<bool, bool> <CollectSwitchSectionsInternal>g__HasNonMutuallyExclusiveExecutionPath|44_0(int unverifiedSectionsStartIndex);
    [CompilerGeneratedAttribute]
internal static void <SplitNestedIfStatementToGuardedSections>g__AddUnguardedFallbackSection|60_0(ICSharpStatementsRange sectionBody, <>c__DisplayClass60_0& );
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.ImplicitConversions.ImplicitConversionSearcherProvider : object {
    public sealed virtual IReadOnlyList`1<ImplicitConversionSourceInfo> GetImplicitConversions(ITreeNode treeNode, bool onlyUserDefinedConversions, bool processInnerTreeNodes);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.ImplicitConversions.ImplicitConversionTreeNodeProcessor : TreeNodeVisitor {
    private bool myOnlyUserDefinedConversions;
    public List`1<ImplicitConversionSourceInfo> ImplicitConversionInfos;
    public ImplicitConversionTreeNodeProcessor(bool onlyUserDefinedConversions);
    public virtual void VisitSwitchExpression(ISwitchExpression switchExpression);
    public virtual void VisitConditionalTernaryExpression(IConditionalTernaryExpression ternaryExpression);
    public virtual void VisitMultipleDeclaration(IMultipleDeclaration multipleDeclaration);
    public virtual void VisitCSharpArgument(ICSharpArgument argument);
    public virtual void VisitArrayInitializer(IArrayInitializer arrayInitializer);
    public virtual void VisitAssignmentExpression(IAssignmentExpression expression);
    private void ProcessCompoundAssignmentExpression(IAssignmentExpression expression);
    public virtual void VisitBinaryExpression(IBinaryExpression expression);
    public virtual void VisitPropertyDeclaration(IPropertyDeclaration propertyDeclaration);
    public virtual void VisitPropertyInitializer(IPropertyInitializer propertyInitializer);
    private void ProcessReturnValueHolder(IReturnValueHolder returnValueHolder);
    public virtual void VisitYieldStatement(IYieldStatement yieldStatementParam);
    public virtual void VisitReturnStatement(IReturnStatement returnStatement);
    public virtual void VisitArrowExpressionClause(IArrowExpressionClause arrowExpressionClause);
    public virtual void VisitLambdaExpression(ILambdaExpression lambdaExpression);
    public virtual void VisitForeachStatement(IForeachStatement foreachStatement);
    public virtual void VisitNullCoalescingExpression(INullCoalescingExpression nullCoalescingExpression);
    public virtual void VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpression);
    private void ProcessTupleExpression(ITupleExpression sourceExpression, Nullable`1<DecoratedType`1<TupleTypeDecoration>> typeExpected, ICSharpExpression targetExpression);
    private bool TupleTypesAreValid(IExpression sourceExpression, IType targetType, ITupleExpression& outTupleExpression, Nullable`1& outTupleType);
    private static ValueTuple`2<bool, HashSet`1<TypeConversionInfo>> CheckDeconstruction(ITupleExpression targetTupleExpression, TypeConversionInfo oldConversionInfo, ITreeNode node, ICSharpTypeConversionRule conversionRule);
    private static ConversionProcessingMode GetProcessingModeForConversion(IExpressionType fromExpressionType, IType toType, ICSharpTypeConversionRule conversionRule, Conversion& conversion);
    private void SaveConversionInfo(ICSharpExpression sourceExpression, IType expectedType, ITreeNode context, ICSharpTypeConversionRule conversionRule, ICSharpExpression targetExpression, IType realType);
    private static bool ConversionIsImplicitTuple(Conversion conversion);
    private static bool NestedConversionsContainImplicitConversion(Conversion conversion);
    private static bool IsImplicitUserDefined(Conversion conversion);
    private static void UpdateConversionInfo(IExpressionType fromType, IType toType, Conversion conversion, TypeConversionInfo& conversionInfo);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.InlineTemporaryVariableUtil : object {
    [NotNullAttribute]
private static TypeEqualityComparer ourTypeEqualityComparer;
    private static InlineTemporaryVariableUtil();
    [CanBeNullAttribute]
[PureAttribute]
public static ITypeOwner FindSourceVariable(IVariableDeclaration variableDeclaration);
    [CanBeNullAttribute]
private static ITypeOwner SourceFromInitializationExpression(ICSharpLocalVariable initializedVariable, ICSharpExpression expression, bool constantContext);
    [PureAttribute]
private static ReferenceKind GetReferenceKind(ITypeOwner typeOwner, ICSharpTreeNode context);
    [PureAttribute]
public static bool CheckUsages(IVariableDeclaration initializedVariableDeclaration, ITypeOwner sourceVariable, IUsagesProvider usagesProvider);
    [PureAttribute]
private static CheckResult CheckVariableUsageCanBeReplacedWithConstant(IReferenceExpression referenceExpression);
    [PureAttribute]
private static CheckResult CheckByRefVariableUsageCanBeReplaced(IReferenceExpression referenceExpression, ICSharpLocalVariable initializedVariable, ITypeOwner sourceVariable);
    [PureAttribute]
private static CheckResult CheckVariableUsageCanBeReplacedWithProperty(IReferenceExpression referenceExpression, ITypeOwner sourceVariable);
    [PureAttribute]
private static CheckResult CheckVariableUsageCanBeReplacedWithOtherVariableOrField(IReferenceExpression referenceExpression, ITypeOwner sourceVariable);
    [PureAttribute]
private static CheckResult CheckSourceVariableOrParameterCanBeUsedForRefVariableReplacement(IReferenceExpression referenceExpression);
    [PureAttribute]
private static CheckResult CheckSourceVariableOrParameterCanBeUsedForValueVariableReplacement(IReferenceExpression referenceExpression);
    [PureAttribute]
private static bool IsArrayElementAccess(IReferenceExpression referenceExpression, ITypeOwner sourceVariable);
    [PureAttribute]
private static bool AllowUsagesInClosures(IVariableDeclaration initializedVariableDeclaration, ITypeOwner sourceVariable);
    [CompilerGeneratedAttribute]
internal static bool <SourceFromInitializationExpression>g__HasCompatibleReferenceKind|2_0(ReferenceKind initializedVariable, ReferenceKind sourceVariable);
    [CompilerGeneratedAttribute]
internal static bool <CheckUsages>g__CanSkip|4_0(ITreeNode usageNode, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <CheckUsages>g__IsInsideClosure|4_1(IReferenceExpression variableUsage, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <CheckUsages>g__TryMerge|4_2(CheckResult next, <>c__DisplayClass4_0& );
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.InvertIfUtil : object {
    public static bool CanInvertIf(IIfStatement statement);
    public static void DoInvertIf(IIfStatement ifStatement, ICSharpControlFlowGraph graph);
    public static bool CanReduceNesting(IIfStatement ifStatement, InterruptibleLazy`1<ICSharpControlFlowGraph> graph);
    public static void Format(ITreeNode root);
    public static void ApplyCodeStyleAndFormat(ITreeNode root);
    private static bool InvertOrCheckReduceNesting(IIfStatement ifStatement, InterruptibleLazy`1<ICSharpControlFlowGraph> graphLazy, bool doInvert);
    private static bool NoStatementsAfterParentBlocks(ICSharpStatement ifStatement);
    private static bool IsLocalFunctionBody(ICSharpStatement stmt);
    [CanBeNullAttribute]
[PureAttribute]
public static ILoopStatement FindContainingLoop(ITreeNode element);
    [CanBeNullAttribute]
[PureAttribute]
public static ISwitchSection FindContainingSwitchSection(ITreeNode element);
    private static bool InvertReducesNesting(ICSharpStatementsRange thenStatementsRange);
    private static void InvertIfElse(IIfStatement ifStatement);
    private static void InvertEmptyIf(IIfStatement blockIfStatement);
    private static ICSharpStatementsRange GetAllStatementsRange(ICSharpStatement statement);
    private static void InvertWithThen(IIfStatement ifStatement, IStatementsOwner statementsOwner, ICSharpStatementsRange afterIfStatements);
    private static bool CanUseReturnStatement(ITreeNode ifStatement);
    private static bool IsLastExecutedInBlock(ICSharpStatement loopBody, ICSharpStatement isLast);
    private static ICSharpStatement GetExitStatementAfterFalseCondition(IIfStatement ifStatement, IControlFlowGraph graph);
    private static IReturnStatement EdgeTargetAsReturnStatement(IControlFlowEdge edge);
    private static IThrowStatement EdgeTargetAsThrowStatement(IControlFlowEdge edge);
    private static bool IsNullTarget(IControlFlowEdge edge);
    private static ICSharpStatementsRange GetStatementsAfterIfInTheSameBlock(ICSharpStatement ifStatement, IStatementsOwner statementsOwner);
    private static bool HasExitsExceptReturnAndThrow(ITreeNode from, IControlFlowGraph graph);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.InvertIfUtil/<GetControlFlowElements>d__23")]
private static IEnumerable`1<IControlFlowElement> GetControlFlowElements(ITreeNode treeNode, IControlFlowGraph graph);
    private static TStatementType AsSingleStatementOrNull(ICSharpStatement statement);
    [ContractAnnotationAttribute("loop:null => false")]
private static bool NavigatesToLoop(ICSharpStatementsRange checkedRange, ILoopStatement loop, InterruptibleLazy`1<ICSharpControlFlowGraph> graphLazy);
    private static bool OutsideOfRange(ITreeNode targetElement, ICSharpStatementsRange rangeToCheck);
    private static bool NavigatesToExit(ICSharpStatementsRange statementsRange, InterruptibleLazy`1<ICSharpControlFlowGraph> graphLazy, IStatement[] additionallyAllowedTargets);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.InvertIfUtil/<ExitsExceptReturnsAndThrows>d__28")]
private static IEnumerable`1<IControlFlowEdge> ExitsExceptReturnsAndThrows(ITreeNode statement, IControlFlowGraph graph);
    private static bool InsideLoopExceptFirstStatement(ILoopStatement loopStatement, ITreeNode targetElement);
    private static void InvertIgnoringThen(IIfStatement ifStatement, IStatementsOwner statementsOwner, ICSharpStatementsRange afterIfStatements);
    private static void MoveStatementsIntoIfBlock(IBlock targetBlock, IStatementsOwner sourceBlock, ICSharpStatementsRange statements);
    private static IDeclaration GetContainingMethod(ITreeNode node);
    private static bool IsInsideSub(ITreeNode statement);
    private static bool IsInsideIterator(ITreeNode statement);
    private static void InvertWithExit(IIfStatement ifStatement, IStatementsOwner statementsOwner, ICSharpStatement exitStatement, InterruptibleLazy`1<ICSharpControlFlowGraph> graph);
    private static bool HasNamingCollisions(IStatementsOwner block, ICSharpStatementsRange cSharpStatementsRange);
    [CompilerGeneratedAttribute]
internal static ICSharpStatementsRange <InvertIgnoringThen>g__SkipTailLocalFunctionsAndSwitchBreakStatements|30_0(ICSharpStatementsRange range);
}
internal interface JetBrains.ReSharper.Feature.Services.CSharp.Util.ISwitchModel {
    public ICSharpTreeNode ContextTreeNode { get; }
    public ICSharpStatement FirstStatementToReplace { get; }
    public ICSharpStatement LastStatementToReplace { get; }
    public ICSharpExpression GoverningExpression { get; }
    public abstract virtual ICSharpTreeNode get_ContextTreeNode();
    public abstract virtual ICSharpStatement get_FirstStatementToReplace();
    public abstract virtual ICSharpStatement get_LastStatementToReplace();
    public abstract virtual ICSharpExpression get_GoverningExpression();
    public abstract virtual IType GetGoverningType();
    [ItemCanBeNullAttribute]
public abstract virtual IEnumerable`1<ICSharpStatement> EnumerateSingleStatementPerSection();
    public abstract virtual bool RequireDefaultCaseForCompleteness();
    public abstract virtual void CopyInternalComments(ISwitchExpression switchExpression);
    public abstract virtual bool TryGenerateSwitchExpressionArms(ISwitchExpression switchExpression, ISwitchStatementToExpressionConverter converter, CSharpElementFactory factory, bool doTransformation, bool isContextAction, ICSharpExpression& defaultCaseExpression);
    public abstract virtual void RemoveReplacedNodes();
}
internal interface JetBrains.ReSharper.Feature.Services.CSharp.Util.ISwitchStatementToExpressionConverter {
    public abstract virtual bool TryConvertToArmExpression(ICSharpStatement statement, ICSharpExpression& armExpression);
    public abstract virtual bool TryCreateResultStatement(ISwitchExpression switchExpression, ICSharpExpression defaultCaseExpression, bool isContextAction, ICSharpStatement& resultStatement, ICSharpStatement& obsoleteStatement);
    public abstract virtual ISwitchExpression GetSwitchExpression(ICSharpStatement cSharpStatement);
    [CanBeNullAttribute]
public abstract virtual IType GetBestCommonType();
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.LocalFunctionPositionUtil : object {
    public static bool IsFollowedByLocalFunctionsOnly(IDeclarationStatement declarationStatement);
    public static Nullable`1<JumpKind> GetJumpKind(ICSharpStatement statement);
    public static Nullable`1<JumpKind> FindExpectedJumpKind(IStatementsOwner statementsOwner);
    public static Nullable`1<JumpKind> GetJumpKind(IStatementsOwner statementsOwner);
    public static bool IsTopLevelScope(IStatementsOwner statementsOwner);
    public static void EnsureLineBreaksAround(ILocalFunctionDeclaration localFunctionDeclaration);
    public static bool HasLineBreaksAround(ILocalFunctionDeclaration localFunctionDeclaration);
    public static bool HasLineBreaks(IDeclarationStatement declarationStatement, bool before);
    public static void AddJumpStatementBefore(IDeclarationStatement declarationStatement, JumpKind jumpKind);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.ModelFromSwitchSectionsCollector : object {
    [NotNullAttribute]
private SwitchSectionsCollector mySwitchSectionsCollector;
    private OneToListMap`2<SwitchCaseCheck, ICSharpCommentNode> mySwitchLabelComments;
    [CanBeNullAttribute]
private IReadOnlyList`1<SwitchSection> myOptimizedSwitchSections;
    [CanBeNullAttribute]
private ICSharpStatement myFirstStatementToReplace;
    [CanBeNullAttribute]
private ICSharpStatement myLastStatementToReplace;
    public ICSharpTreeNode ContextTreeNode { get; }
    public ICSharpStatement FirstStatementToReplace { get; }
    public ICSharpStatement LastStatementToReplace { get; }
    public ICSharpExpression GoverningExpression { get; }
    public ModelFromSwitchSectionsCollector(SwitchSectionsCollector switchSectionsCollector);
    public sealed virtual ICSharpTreeNode get_ContextTreeNode();
    public sealed virtual ICSharpStatement get_FirstStatementToReplace();
    public sealed virtual ICSharpStatement get_LastStatementToReplace();
    private void FindFirstAndLastStatementToReplace();
    public sealed virtual ICSharpExpression get_GoverningExpression();
    public sealed virtual IType GetGoverningType();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.ModelFromSwitchSectionsCollector/<EnumerateSingleStatementPerSection>d__16")]
public sealed virtual IEnumerable`1<ICSharpStatement> EnumerateSingleStatementPerSection();
    private static ICSharpStatement GetSingleStatementOrDefault(SwitchSection switchSection);
    public sealed virtual bool RequireDefaultCaseForCompleteness();
    public sealed virtual void CopyInternalComments(ISwitchExpression switchExpression);
    public sealed virtual bool TryGenerateSwitchExpressionArms(ISwitchExpression switchExpression, ISwitchStatementToExpressionConverter converter, CSharpElementFactory factory, bool doTransformation, bool isContextAction, ICSharpExpression& defaultCaseExpression);
    public sealed virtual void RemoveReplacedNodes();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.ModelFromSwitchStatement : object {
    [NotNullAttribute]
private ISwitchStatement mySwitchStatement;
    public ICSharpTreeNode ContextTreeNode { get; }
    public ICSharpStatement FirstStatementToReplace { get; }
    public ICSharpStatement LastStatementToReplace { get; }
    public ICSharpExpression GoverningExpression { get; }
    public ModelFromSwitchStatement(ISwitchStatement switchStatement);
    public sealed virtual ICSharpTreeNode get_ContextTreeNode();
    public sealed virtual ICSharpStatement get_FirstStatementToReplace();
    public sealed virtual ICSharpStatement get_LastStatementToReplace();
    public sealed virtual ICSharpExpression get_GoverningExpression();
    public sealed virtual IType GetGoverningType();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.ModelFromSwitchStatement/<EnumerateSingleStatementPerSection>d__11")]
public sealed virtual IEnumerable`1<ICSharpStatement> EnumerateSingleStatementPerSection();
    public sealed virtual bool RequireDefaultCaseForCompleteness();
    public sealed virtual void CopyInternalComments(ISwitchExpression newSwitchExpression);
    public sealed virtual bool TryGenerateSwitchExpressionArms(ISwitchExpression switchExpression, ISwitchStatementToExpressionConverter converter, CSharpElementFactory factory, bool doTransformation, bool isContextAction, ICSharpExpression& defaultCaseExpression);
    private static void ExtendArmCondition(ISwitchExpressionArm arm, ISwitchCaseLabel switchCaseLabel, CSharpElementFactory factory);
    private static ISwitchExpressionArm GenerateSwitchExpressionArm(ISwitchExpression switchExpression, ISwitchCaseLabel switchCaseLabel, CSharpElementFactory factory, ICSharpExpression armExpression, ICSharpStatement firstStatementInSection);
    public sealed virtual void RemoveReplacedNodes();
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.ObjectCreationExpressionInitializerUtil : object {
    [PureAttribute]
public static bool CanExtract(ICreationExpressionInitializer creationExpressionInitializer);
    [PureAttribute]
public static bool CanExtract(IReadOnlyList`1<IInitializerElement> initializerElements);
    [CanBeNullAttribute]
public static ICSharpStatement Extract(ICreationExpressionInitializer creationExpressionInitializer);
    [CanBeNullAttribute]
public static ICSharpStatement Extract(IEnumerable`1<IInitializerElement> initializers);
    [PureAttribute]
public static bool IsMandatory(IMemberInitializer memberInitializer);
    [NotNullAttribute]
private static ICSharpExpression CreateQualifier(CSharpElementFactory factory, IMemberInitializer memberInitializer, ICSharpExpression qualifierExpression);
    public static void RemoveInitializerIfEmpty(ICreationExpressionInitializer creationExpressionInitializer);
    [CanBeNullAttribute]
[PureAttribute]
private static Func`2<CSharpElementFactory, ExtractionResult> TryCreateExtractor(IObjectCreationExpression creationExpression);
    [PureAttribute]
private static bool IsSimpleAssignmentTargetWithTheSameType(IReferenceExpression referenceExpression, IObjectCreationExpression objectCreation);
    public static IObjectCreationExpression CreateObjectCreationExpressionWithCollectionInitializer(CSharpElementFactory factory, IDeclaredType typeToCreate, ITreeRange range, ITreeNode context);
    [CompilerGeneratedAttribute]
internal static bool <CanExtract>g__IsInsideNotMovedInitializer|1_1(ITreeNode usage, <>c__DisplayClass1_0& , <>c__DisplayClass1_1& );
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static ICollection`1<IDeclaredElement> <CanExtract>g__GetAllExpressionVariables|1_0(<>c__DisplayClass1_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.OutVariableUtil : object {
    [PureAttribute]
public static bool IsSuitableVariable(ILocalVariableDeclaration localVariableDeclaration);
    [PureAttribute]
public static bool IsSuitableOutArgumentAndUsages(ILocalVariableDeclaration localVariableDeclaration, ICSharpArgument outVarArgument, IReadOnlyList`1<ITreeNode> variableUsages);
    [PureAttribute]
public static ICSharpArgument GetFirstOutArgumentUsageByOffset(IEnumerable`1<ITreeNode> usages);
    [PureAttribute]
public static bool AllUsagesAreAfterOutArgument(ICSharpArgument initializer, IReadOnlyList`1<ITreeNode> variableUsages);
    [PureAttribute]
private static bool AllUsagesAreInScope(IScope proposedScope, IReadOnlyList`1<ITreeNode> variableUsages);
    [PureAttribute]
public static bool CheckVariableType(ILocalVariableDeclaration localVariableDeclaration, ICSharpArgument outArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.ParamArgumentsUtil : object {
    public static ICSharpExpression WrapParamsToCollectionExpressionOrArray(ICSharpArgumentsOwner argumentsOwner);
    public static bool CanWrapParamsToCollectionExpression(ICSharpArgumentsOwner argumentsOwner, Boolean& preferCreationExpression);
    public static ICollectionExpression WrapParamsToCollectionExpression(ICSharpArgumentsOwner argumentsOwner);
    public static IArrayCreationExpression WrapParamsToArray(ICSharpArgumentsOwner argumentsOwner);
    public static ICSharpExpression WrapParamsToCollectionCreation(ICSharpArgumentsOwner argumentsOwner);
    private static Nullable`1<ValueTuple`2<ICSharpArgument, ICSharpArgument>> GetParameterArrayArgumentsRange(ICSharpArgumentsOwner argumentsOwner, IParameter paramsParameter);
    public static void TryExpandCollectionToParams(ICSharpArgumentsOwner argumentsOwner);
    [CompilerGeneratedAttribute]
internal static bool <WrapParamsToCollectionExpression>g__IsArgumentNotExpanded|2_0(ICSharpArgument argument);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<ICSharpExpression> <TryExpandCollectionToParams>g__CreateExpressionsForValues|6_4(ICSharpExpression collectionExpressionLike, CSharpElementFactory factory);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryExpandCollectionToParams>g__HasCollectionBuilderAnnotation|6_5(IDeclaredElement declaredElement);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryExpandCollectionToParams>g__IsZeroConstant|6_6(ICSharpExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.PrimaryRewriting.ToPrimaryConstructorUtil : object {
    public static IConstructor TryChoosePrimaryCandidate(ITypeElement typeElement, Func`2<IConstructor, ClassInitializationInfo> tryGetInitializationInfo, IReadOnlyList`1& secondaryCandidates, Int32& instanceConstructorCount);
    public static TDeclaredElement PerformMiniRename(TDeclaredElement declaredElementToRename, string newNameToUse);
    [PureAttribute]
public static Dictionary`2<IParameterDeclaration, string> CollectParameterRenamesToMatchNamingStyle(ICSharpParametersOwnerDeclaration sourceParametersOwnerDeclaration, ICSharpParametersOwnerDeclaration targetParametersOwnerDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.PropertyPatternUtil : object {
    public static void TryMergeNestedPropertyPatterns(ISubpattern outerSubpattern);
    public static bool CanMergeWithInnerSubpattern(ISubpattern outerSubpattern, ISubpattern& innerSubpattern);
    [NullableContextAttribute("2")]
public static bool IsAccessExpressionFinished(ICSharpExpression accessExpression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.ReturnStatementConverter : ReturnStatementConverterBase`1<IReturnStatement> {
    public ReturnStatementConverter(ISwitchModel switchModel, bool doTransformation);
    public virtual bool TryCreateResultStatement(ISwitchExpression switchExpression, ICSharpExpression defaultCaseExpression, bool isContextAction, ICSharpStatement& resultStatement, ICSharpStatement& obsoleteStatement);
    protected virtual IType GetForceCastType();
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.Util.ReturnStatementConverterBase`1 : SwitchStatementToExpressionConverterBase {
    protected ReturnStatementConverterBase`1(ISwitchModel switchModel, bool doTransformation);
    private static bool Accept(ICSharpStatement statement);
    public virtual bool TryConvertToArmExpression(ICSharpStatement statement, ICSharpExpression& armExpression);
    public virtual ISwitchExpression GetSwitchExpression(ICSharpStatement cSharpStatement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.SeparateLocalFunctionWithJumpKindExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToText(JumpKind kind);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.SurroundWithBlockHelper : object {
    [NullableContextAttribute("1")]
public static ValueTuple`3<ICSharpStatementsRange, ICSharpStatementsRange, ICSharpStatementsRange> PrepareRange(ICSharpStatementsRange statementsRange);
    [NullableContextAttribute("2")]
public static ILocalFunctionDeclaration GetTopMostContainingFunctionUnder(ITreeNode currentNode, ITreeNode containingFunctionLike);
    [NullableContextAttribute("1")]
public static bool CanExtract(ILocalVariableDeclaration declaration);
    [NullableContextAttribute("1")]
public static bool CanExtract(ISingleVariableDesignation designation);
    [CompilerGeneratedAttribute]
internal static TreeOffset <PrepareRange>g__GetPairKey|0_0(KeyValuePair`2<ILocalFunctionDeclaration, FunctionUsageFlags> pair);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static CSharpStatementsRange <PrepareRange>g__CreateStatementsRangeStrictlyBetween|0_1(ICSharpStatement firstStatement, ICSharpStatement lastStatement, IStatementsOwner statementsOwner);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static CSharpStatementsRange <PrepareRange>g__CreateStatementsRangeOrEmpty|0_2(ICSharpStatement firstStatement, ICSharpStatement lastStatement);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <PrepareRange>g__CollectElements|0_3(ITreeNode rootNode, bool isNestedFunction, <>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <PrepareRange>g__TryCollectDeclaredElementAndCrossReferences|0_4(IDeclaredElement declaredElement, bool isInnerElement, <>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <PrepareRange>g__CollectCrossReferencesAndInnerElements|0_5(ILocalFunctionDeclaration localFunctionDeclaration, <>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <PrepareRange>g__FlagFunctionAndReferencingOnes|0_6(ILocalFunctionDeclaration functionDeclaration, bool referencingInnerElement, <>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <PrepareRange>g__FlagReferencingFunctionsAndCheckIsElementReferencedOutsideOfCurrentBlockRange|0_7(IDeclaredElement declaredElement, bool referencingInnerElement, <>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <PrepareRange>g__ExtractVariables|0_8(ICSharpTreeNode treeNode, HashSet`1<IDeclaredElement> toExtract, <>c__DisplayClass0_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <PrepareRange>g__UpdateIfNotValid|0_9(ICSharpStatement& oldStatement, ICSharpStatement newStatement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.SwitchExpressionUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<IField> GetMissingArmsForEnum(ISwitchExpression switchExpression, ISwitchExpressionArm& defaultUnguardedArm, Boolean& nullCaseIsMissing);
    public static bool CheckCanMergeGoverningExpressionCastsInSwitchArm(ISwitchExpressionArm switchExpressionArm, ICSharpTypeConversionRule typeConversionRule);
    public static bool CheckCanMergeCasts(IPattern typeCheckPattern, ICSharpExpression conditionExpression, IEnumerable`1<IPatternGuardClause> previousGuardClauses, IReadOnlyList`1<ICSharpTreeNode> caseBodyNodes, ICSharpTypeConversionRule typeConversionRule);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.SwitchExpressionUtil/<GetPreviousGuards>d__3")]
[PureAttribute]
private static IEnumerable`1<IPatternGuardClause> GetPreviousGuards(ISwitchExpression switchExpression, ISwitchExpressionArm targetArm);
    [PureAttribute]
private static bool IsRedundantCastInArmExpression(ISwitchExpressionArm switchExpressionArm);
    public static void TryRemoveRedundantCastsOfGoverningVariable(ISwitchExpression switchExpression, ICSharpTypeConversionRule typeConversionRule, CSharpElementFactory factory);
    public static void TryRemoveRedundantCastsInArms(ISwitchExpression switchExpression);
    [PureAttribute]
public static PatternMatchKind GetMatchKind(ISwitchExpression switchExpression, CaseLabelPatternMatchInfo& lastArmInfo, Boolean& areThereReachableCasesNotDiscard);
}
internal abstract class JetBrains.ReSharper.Feature.Services.CSharp.Util.SwitchStatementToExpressionConverterBase : object {
    [CompilerGeneratedAttribute]
private ISwitchModel <SwitchModel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoTransformation>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpElementFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IExpressionType> <ArmExpressionsTypes>k__BackingField;
    protected ISwitchModel SwitchModel { get; }
    protected bool DoTransformation { get; }
    protected CSharpElementFactory Factory { get; }
    [NotNullAttribute]
protected List`1<IExpressionType> ArmExpressionsTypes { get; }
    protected SwitchStatementToExpressionConverterBase(ISwitchModel switchModel, bool doTransformation);
    [CompilerGeneratedAttribute]
protected ISwitchModel get_SwitchModel();
    [CompilerGeneratedAttribute]
protected bool get_DoTransformation();
    [CompilerGeneratedAttribute]
protected CSharpElementFactory get_Factory();
    [CompilerGeneratedAttribute]
protected List`1<IExpressionType> get_ArmExpressionsTypes();
    protected void AddExplicitCastInFirstArmOnDemand(ISwitchExpression switchExpression);
    protected abstract virtual IType GetForceCastType();
    public abstract virtual bool TryConvertToArmExpression(ICSharpStatement statement, ICSharpExpression& armExpression);
    public abstract virtual bool TryCreateResultStatement(ISwitchExpression switchExpression, ICSharpExpression defaultCaseExpression, bool isContextAction, ICSharpStatement& resultStatement, ICSharpStatement& obsoleteStatement);
    public abstract virtual ISwitchExpression GetSwitchExpression(ICSharpStatement cSharpStatement);
    public sealed virtual IType GetBestCommonType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.Util.SwitchStatementToExpressionTransformation : object {
    [NotNullAttribute]
private ISwitchModel mySwitchModel;
    public SwitchStatementToExpressionTransformation(ISwitchStatement switchStatement);
    public SwitchStatementToExpressionTransformation(SwitchSectionsCollector switchSectionsCollector);
    public bool IsQuickFixAvailable();
    public bool IsContextActionAvailable();
    [CanBeNullAttribute]
public ITreeNode Execute();
    private bool ExecuteInternal(ICSharpStatement& newTreeNode, bool isContextAction, bool doTransformation);
    [CanBeNullAttribute]
private static ISwitchStatementToExpressionConverter TryCreateConverter(ISwitchModel switchModel, bool doTransformation);
    internal static void CopyBeforeComments(ITreeNode oldTreeNode, ITreeNode newTreeNode, bool removeCopiedComments);
    internal static void CopyBeforeAndAfterComments(ITreeNode oldTreeNode, ITreeNode newTreeNode, bool removeCopiedComments);
    internal static void CopyAfterComments(ITreeNode oldTreeNode, ITreeNode newTreeNode, bool removeCopiedComments);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.SwitchStatementToExpressionTransformation/<EnumerateStatements>d__11")]
[PureAttribute]
[NotNullAttribute]
internal static IEnumerable`1<ICSharpStatement> EnumerateStatements(IStatementsOwner statementsOwner);
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.TernaryExpressionToSwitchExpressionTransformation : object {
    public static bool IsAvailable(IConditionalTernaryExpression conditionalTernaryExpression);
    [CanBeNullAttribute]
public static ISwitchExpression Execute(IConditionalTernaryExpression conditionalTernaryExpression);
    [CanBeNullAttribute]
private static ToPatternConverter CreateConverter(ICSharpExpression cSharpExpression);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.ThrowStatementConverter : SwitchStatementToExpressionConverterBase {
    public ThrowStatementConverter(ISwitchModel switchModel, bool doTransformation);
    public virtual bool TryConvertToArmExpression(ICSharpStatement statement, ICSharpExpression& armExpression);
    public virtual bool TryCreateResultStatement(ISwitchExpression switchExpression, ICSharpExpression defaultCaseExpression, bool isContextAction, ICSharpStatement& resultStatement, ICSharpStatement& obsoleteStatement);
    protected virtual IType GetForceCastType();
    public virtual ISwitchExpression GetSwitchExpression(ICSharpStatement cSharpStatement);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.ToPatternConverter : object {
    [CanBeNullAttribute]
private IReferenceExpression myGoverningExpression;
    public ICSharpExpression GoverningExpression { get; }
    public ToPatternConverter(IReferenceExpression governingExpression);
    public bool CanBeConverted(ICSharpExpression expression);
    private bool CanBeConverted(IEqualityExpression equalityExpression);
    private bool CanBeConverted(IIsExpression isExpression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.Util.ToPatternConverter/<Convert>d__5")]
public IEnumerable`1<IPattern> Convert(ICSharpExpression expression, CSharpElementFactory factory);
    public ICSharpExpression get_GoverningExpression();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.TypeCheckRewriterHelper : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static IType TryGetTypeCheckType(IIsExpression isExpression, IPattern& checkPattern, Boolean& isNegatedCheck);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("isExpression: null => false")]
public static bool CanReplaceWithAsExpressionOrPatternMatching(IIsExpression isExpression, bool rewriteToAsExpressionOnly, bool forSuggestion, bool allowValueTypes);
    private static bool CheckCanRewriteUsingAsExpression(IIsExpression isExpression, bool isNegatedCheck);
    public static IReadOnlyList`1<string> SuggestVariableName(ITreeNode context, IType destinationType, IEnumerable`1<ICSharpExpression> expressions, ILocalVariableDeclaration variableToInline);
    [PureAttribute]
public static ICSharpExpression GetTopConditionExpression(ICSharpExpression isExpression, bool isNegated);
    [ObsoleteAttribute("To be removed")]
public static List`1<ICSharpExpression> FindExpressionsToReplace(IPattern typeCheckPattern, ICSharpExpression checkOperand, IType destinationType, bool isNegatedCheck, bool variableIsUnlifted, ICSharpExpression& stopExpression);
    [PureAttribute]
private static IReadOnlyList`1<IAccess> TryCreateAccessesFromPattern(IPatternWithDesignation mostInnerPattern, IPattern& topCheckedPattern, Boolean& isNegated);
    public static List`1<ICSharpExpression> FindExpressionsToReplace2(IPattern topCheckedPattern, IPattern mostInnerPattern, IReadOnlyList`1<IAccess> accesses, IType destinationType, bool isNegatedCheck, bool variableIsUnlifted, ICSharpExpression& stopExpression);
    public static IBulbActionCommand ReplaceWithPatternMatchingVariable(IPatternWithDesignation pattern, CSharpElementFactory factory);
    [NullableContextAttribute("2")]
private static HotspotInfo GetVariableTypeHotspotInfo(IDeclaration variableDeclaration);
    public static IBulbActionCommand CreateHotspots(IEnumerable`1<ICSharpTreeNode> variableReferences, IDeclaration variableDeclaration, IReadOnlyCollection`1<string> variableNames, ICSharpExpression stopExpression, DocumentOffset endCaretOffset);
    private static IReadOnlyList`1<ICSharpExpression> ReplaceExpressionsWithPatternVariable(ISingleVariableDesignation variableDesignation, IReadOnlyList`1<ICSharpExpression> expressionsToReplace);
    public static ILocalVariableDeclaration TryFindVariableWithCastedValue(IIsExpression isExpression, IReadOnlyCollection`1<ICSharpExpression> usages);
    private static ILocalVariableDeclaration TryFindVariableWithCastedValue(IType patternType, IPattern pattern, IReadOnlyCollection`1<ICSharpExpression> usages);
    public static IEnumerable`1<ICSharpExpression> FindVariableReferences(IDeclaredElement variable);
    public static INamesCollection CreateNamesCollection(IDeclaredElement replacedElement, ITreeNode context);
    private static bool CheckResolveEquivalence(ICSharpExpression expression, ICSharpExpression replacement);
    private static IEnumerable`1<ICSharpExpression> GetUsagesInScope(ICSharpExpression operandExpression, IPattern pattern, bool isNegatedCheck, ICSharpExpression& stopExpression);
    private static IEnumerable`1<ICSharpExpression> GetUsagesInScope2(IPattern topCheckedPattern, IPattern mostInnerPattern, IReadOnlyList`1<IAccess> accessesToFind, bool isNegatedCheck, ICSharpExpression& stopExpression);
    private static IReadOnlyList`1<ICSharpTreeNode> FindNodesWithCastsToMerge(IPattern topCheckedPattern, bool isNegated);
    public static IReadOnlyList`1<ICSharpTreeNode> FindNodesWithCastsToMerge(IIsExpression isExpression, bool isNegated, bool canOnlyIntroduceLocalWithStatement);
    private static ICSharpExpression CheckCastCanBeReplaced(ITypeUsage targetUsage, IType destinationType, ICSharpExpression cast, bool variableIsUnlifted);
    public static bool HasCastInThenBodies(ICSharpExpression sourceExpression, IType isType, IPattern typeCheckPattern, IReadOnlyList`1<ICSharpTreeNode> castBodies, ICSharpTypeConversionRule conversionRule);
    private static bool CastExpressionCanBeReplacedWithAsExpressionType(ICSharpExpression castExpression, ICSharpExpression castOperand, ITypeUsage castTypeUsage, IType targetType, IAccess asOperandAccess, ICSharpTypeConversionRule conversionRule);
    private static bool CanRemoveCastExpression(ICSharpTypeConversionRule conversionRule, ICSharpExpression castExpression, IType castType, IType operandType, bool variableIsUnlifted);
    public static HotspotInfo GetVariableNameHotspotInfo(IEnumerable`1<ICSharpTreeNode> variableReferences, IDeclaration variableDeclaration, IReadOnlyCollection`1<string> variableNames);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static IReadOnlyList`1<IAccess> <TryCreateAccessesFromPattern>g__TryCreate|6_1(IPatternWithDesignation pattern, IPattern& topCheckedPattern, Boolean& isNegated);
    [CompilerGeneratedAttribute]
internal static bool <TryFindVariableWithCastedValue>g__CheckUsages|13_0(ILocalVariable localVariable, bool allowMutations);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetUsagesInScope2>g__ProcessExpressionUsagesInScope|18_1(ICSharpTreeNode rootNode, ICSharpExpression& scopeStopExpression, <>c__DisplayClass18_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetUsagesInScope2>g__Scan|18_2(ITreeNode scanRoot, ICSharpExpression& scopeStopExpression, bool assignmentHack, <>c__DisplayClass18_0& , <>c__DisplayClass18_1& );
    [CompilerGeneratedAttribute]
internal static void <GetUsagesInScope2>g__ProcessExpression|18_3(ICSharpExpression expression, ICSharpExpression& scopeStopExpression, <>c__DisplayClass18_0& , <>c__DisplayClass18_1& );
    [CompilerGeneratedAttribute]
internal static void <FindNodesWithCastsToMerge>g__AddStatementsAfter|20_2(ICSharpStatement anchorStatement, <>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanRemoveCastExpression>g__CastAffectsUserDefinedConversions|24_0(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanRemoveCastExpression>g__CheckResolveEquivalence|24_1(<>c__DisplayClass24_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Feature.Services.CSharp.Util.WithExpressionSuggestionUtil : object {
    private static IEqualityComparer`1<IType> TypeComparer { get; }
    private static IEqualityComparer`1<IType> get_TypeComparer();
    public static Nullable`1<ElementCopySource> TryFindElementCopySource(DeclaredElementInstance elementInstance, ICSharpExpression expression);
    public static Nullable`1<ElementCopySource> TryFindElementCopySource(IReference elementReference, ICSharpExpression expression);
    public static Nullable`1<ElementCopySource> TryFindArgumentCopySource(ICSharpArgument argument);
    public static bool IsElementCopiedFromInstance(IReference elementReference, ICSharpExpression expression, ElementCopySource copySource);
    public static bool IsElementCopiedFromInstance(DeclaredElementInstance elementInstance, ICSharpExpression expression, ElementCopySource copySource);
    public static bool IsArgumentCopiedFromInstance(ICSharpArgument argument, ElementCopySource copySource);
    public static bool CanUseWithExpression(ITupleExpression tuple, ElementCopySource copySource);
    public static bool CanUseWithExpression(IAnonymousObjectCreationExpression anonymousObject, ElementCopySource copySource);
    public static bool CanUseWithExpression(IObjectCreationExpression creationExpression, ElementCopySource copySource, ITypeElement typeElement, ElementProblemAnalyzerData problemAnalyzerData);
    public static bool IsInitializableNonVirtualMember(IDeclaredElement member, IAccessContext accessContext, bool allowByRefFields);
    [NullableContextAttribute("2")]
private static ExpressionWriteAccessChecker CreateWriteAccessCheckerIfNecessary(ElementCopySource copySource);
    public static bool TypeHasNoInheritors(ITypeElement typeElement, ElementProblemAnalyzerData problemAnalyzerData);
    private static bool CanUseWithExpression(ICSharpExpression element, ICSharpExpression copySource, int copiedElementCount, int modifiedElementCount);
    public static IWithExpression CreateWithExpression(CSharpElementFactory elementFactory, ElementCopySource source, List`1<ValueTuple`2<string, ICSharpExpression>> modifiedElements);
    [CompilerGeneratedAttribute]
internal static bool <TryFindArgumentCopySource>g__MemberMatchesParameter|4_0(DeclaredElementInstance`1<ITypeMember> typeMemberInstance, CSharpParameterInstance parameterInstance);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.Util.YieldReturnStatementConverter : ReturnStatementConverterBase`1<IYieldStatement> {
    public YieldReturnStatementConverter(ISwitchModel switchModel, bool doTransformation);
    public virtual bool TryCreateResultStatement(ISwitchExpression switchExpression, ICSharpExpression defaultCaseExpression, bool isContextAction, ICSharpStatement& resultStatement, ICSharpStatement& obsoleteStatement);
    protected virtual IType GetForceCastType();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.CSharpValueTrackingLanguageService : ValueTrackingLanguageServiceBase {
    public virtual bool CanCreateNodeFromDeclaredElement(IDeclaredElement element);
    public virtual IValueTrackingNode NodeFromExpression(IExpression expression, ValueTrackingDirections direction, ValueTrackingSessionEnvinonment session);
    public virtual IValueTrackingNode NodeFromDeclaredElement(IDeclaredElement element, ValueTrackingDirections direction, ValueTrackingSessionEnvinonment envinonment, IType ownerType, String& text);
    public virtual IArgumentsOwner GetArgumentsOwner(IReference reference);
    public virtual IExpression GetArgumentValue(IArgument argument);
    public virtual IValueTrackingNodePresentation GetElementPresentation(ITreeNode element, IExpressionPresentationStyle style);
    public virtual IDeclaredElement GetElementFromExpression(IExpression expression);
    public virtual IType GetOwnerType(IDeclaredElement declaredElement, IDataContext dataContext);
    public static RichText PresentExpression(ITreeNode element, IExpressionPresentationStyle style);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.CollectionWrappers.CollectionInitializerExpressionNode : NodeBase {
    public IType SourceType { get; }
    public bool IsPassThrough { get; }
    public CollectionInitializerExpressionNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual IType get_SourceType();
    public virtual bool get_IsPassThrough();
    private void ProcessCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializer, IList`1<IValueTrackingNode> elementNodesCollector);
    private void ProcessIndexerInitializer(IIndexerInitializer indexerInitializer, IList`1<IValueTrackingNode> elementNodesCollector);
    private void ProcessArrayInitializer(IArrayInitializer arrayInitializer, IList`1<IValueTrackingNode> elementNodesCollector);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.CollectionWrappers.CollectionWrappersHelper : object {
    private static string ArrayIndexerXmlDocId;
    private static string GenericListIndexerXmlDocId;
    private static string ListIndexerXmlDocId;
    private static string GenericCurrentXmlDocId;
    private static string CurrentXmlDocId;
    private static string AddXmlDocId;
    private static string GenericAddXmlDocId;
    private static string InsertXmlDocId;
    private static string GenericInsertXmlDocId;
    private static string ListXmlDocId;
    private static string GenericCollectionXmlDocId;
    private static string AddRangeXmlDocId;
    private static string GenericAddRangeXmlDocId;
    private static string GenericListConstructorXml1DocId;
    public static void UnwrapCollection(ValueTrackingDirections innerNodeDirection, IValueTrackingNode ownerNode, ITreeNode sourceElement, IValueTrackingNode childNode, List`1<IValueTrackingNode> unWrappedChildren, List`1<IValueTrackingNode> newChildren, Boolean& unWrapped);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IList`1<IValueTrackingNode> UnwrapArrayInitializer(IArrayInitializer initializer, ValueTrackingDirections innerNodeDirection, IValueTrackingNode ownerNode, IValueTrackingNode childNode);
    private static bool HasRole(IValueTrackingNode childNode, ValueTrackingChildRoles role);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.CollectionWrappers.CollectionWrappersHelper/<ElementToCollection>d__17")]
public static IEnumerable`1<IPreExpandedNode> ElementToCollection(ICSharpExpression expression, TransitionalExpressionNode parent);
    private static TrivialPreExpandedNode WrapToCollectionNode(ICSharpExpression operand, IValueTrackingNode parent, ValueTrackingDirections innerNodeDirection, ValueTrackingDirections collectionDirection);
    private static bool IsResolvedTo(IOverridableMember element, string id);
    public static bool IsMutableCollectionType(IType type);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.CollectionWrappers.ElementOfCollection : WrapperNodeBase {
    private ValueTrackingDirections myDirectionForUnwrappedNode;
    public bool IsPassThrough { get; }
    public ElementOfCollection(IValueTrackingNode wrappedNode, IValueTrackingNode parent, ValueTrackingDirections directionForUnwrappedNode);
    public virtual bool get_IsPassThrough();
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style, RichText innerPresentation);
    public virtual IValueTrackingNode WrapChild(IValueTrackingNode childOfWrappedNode);
    [CompilerGeneratedAttribute]
private IValueTrackingNode <WrapChild>b__6_0(IValueTrackingNode x);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.CollectionWrappers.PreExpandedNodeUsagesOfIterator : PreExpandedNodeBase {
    private PreExpandedNodeMethodLikeUsage myPreExpandedNodeMethodUsage;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeUsagesOfIterator(PreExpandedNodeMethodLikeUsage preExpandedNodeMethodUsage);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private IValueTrackingNode <ExpandWithFindResults>b__5_0(IValueTrackingNode x);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.CollectionWrappers.YieldReturnedExpressionNode : NodeBase {
    [CompilerGeneratedAttribute]
private ICSharpExpression <SourceExpression>k__BackingField;
    public ICSharpExpression SourceExpression { get; public set; }
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public YieldReturnedExpressionNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ICSharpExpression element, IValueTrackingCallStack callStack);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_SourceExpression();
    [CompilerGeneratedAttribute]
public void set_SourceExpression(ICSharpExpression value);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ConstantNode : NodeBase {
    private ConstantValue myValue;
    public IType SourceType { get; }
    public bool IsPassThrough { get; }
    public ConstantNode(ConstantValue value, ValueTrackingDirections direction, ValueTrackingSessionEnvinonment session, IValueTrackingNode parent, IValueTrackingCallStack stack, ITreeNode element);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
    public virtual bool get_IsPassThrough();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DefaultValueNode : NodeBase {
    private DefaultValue myDefaultValue;
    public IType SourceType { get; }
    public bool IsPassThrough { get; }
    public DefaultValueNode(DefaultValue defaultValue, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.ArgumentToLambdaParameter : WrapperNodeBase {
    private int myDelegateParameterIndex;
    private ValueTrackingDirections myDirectionForUnwrappedNode;
    private string myParameterName;
    public ArgumentToLambdaParameter(IValueTrackingNode wrappedNode, IValueTrackingNode parent, int delegateParameterIndex, ValueTrackingDirections directionForUnwrappedNode, string parameterName);
    public virtual IValueTrackingNode WrapChild(IValueTrackingNode childOfWrappedNode);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style, RichText innerPresentation);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.CallToLambdaReturn : WrapperNodeBase {
    private ValueTrackingDirections myDirectionForUnwrappedNode;
    public CallToLambdaReturn(IValueTrackingNode wrappedNode, IValueTrackingNode parent, ValueTrackingDirections wrappedNodeDirection);
    public virtual IValueTrackingNode WrapChild(IValueTrackingNode childOfWrappedNode);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style, RichText innerPresentation);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.Events.DelegateToEventNode : NodeBase {
    private ITreeNodePointer`1<IInvocationExpression> myInvocationPointer;
    public IInvocationExpression InvocationExpression { get; }
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public DelegateToEventNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IInvocationExpression invocationExpression, IValueTrackingCallStack callStack);
    public IInvocationExpression get_InvocationExpression();
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.Events.DelegateToEventNodePreExpanded : PreExpandedNodeBase {
    private IEvent myEvent;
    private List`1<IInvocationExpression> myInvocations;
    private bool myIsCustom;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public DelegateToEventNodePreExpanded(ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, IEvent event);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private IValueTrackingNode <ExpandWithFindResults>b__7_0(IInvocationExpression x);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.Events.EventToDelegatePreExpandedNode : PreExpandedNodeBase {
    private IEvent myEvent;
    private List`1<ICSharpExpression> mySubscribedMethods;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public EventToDelegatePreExpandedNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, IEvent event);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private TransitionalExpressionNode <ExpandWithFindResults>b__6_0(ICSharpExpression e);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.Events.PreExpandedNodeEventVirtualCall : PreExpandedNodeBase {
    private IEvent myEvent;
    private bool myIsCallToBase;
    private ITypePointer myOwnerType;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeEventVirtualCall(ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, IEvent event, bool isCallToBase, IType ownerType);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual IFinderOperation InitNode(IProgressIndicator pi, CachingFinder cachingFinder);
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private NodeFromPreExpandedNode <ExpandWithFindResults>b__8_0(IEvent event);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.Events.VirtualEventToDelegatePreExpandedNode : PreExpandedNodeBase {
    private IEvent myEvent;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public VirtualEventToDelegatePreExpandedNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, IEvent event);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private NodeFromPreExpandedNode <ExpandWithFindResults>b__5_1(IEvent event);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.LambdaParameterToCall : WrapperNodeBase {
    private ValueTrackingDirections myDirectionForUnwrappedNode;
    private int myParameterIndex;
    public LambdaParameterToCall(IValueTrackingNode wrappedNode, IValueTrackingNode parent, int parameterIndex, ValueTrackingDirections directionForUnwrappedNode);
    public virtual IValueTrackingNode WrapChild(IValueTrackingNode childOfWrappedNode);
    private IValueTrackingNode WrapInvocation(IInvocationExpression invocation);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style, RichText innerPresentation);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.DelegateWrappers.LambdaReturnToCall : WrapperNodeBase {
    public LambdaReturnToCall(IValueTrackingNode wrappedNode, IValueTrackingNode parent);
    public virtual IValueTrackingNode WrapChild(IValueTrackingNode childOfWrappedNode);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style, RichText innerPresentation);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ExpandedParamArrayNode : NodeBase {
    private ITreeNodePointer`1<ICSharpArgumentsOwner> myOwnerPointer;
    private bool myHasNotExpanded;
    [CompilerGeneratedAttribute]
private IList`1<ITreeNodePointer`1<ICSharpArgument>> <Arguments>k__BackingField;
    public bool CanBeExpanded { get; }
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public IList`1<ITreeNodePointer`1<ICSharpArgument>> Arguments { get; }
    public ExpandedParamArrayNode(ICSharpArgumentsOwner owner, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IValueTrackingCallStack callStack);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual bool get_CanBeExpanded();
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
    [CompilerGeneratedAttribute]
public IList`1<ITreeNodePointer`1<ICSharpArgument>> get_Arguments();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.FieldLikeNode : NodeBase {
    [NotNullAttribute]
private IDeclaredElementPointer`1<ITypeOwner> myPointer;
    [CanBeNullAttribute]
private ITypePointer myOwnerTypePointer;
    public IDeclaredElementPointer`1<ITypeOwner> Pointer { get; }
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public FieldLikeNode(ITypeOwner typeOwner, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IValueTrackingCallStack callStack, ITreeNode element, IType ownerType);
    public IDeclaredElementPointer`1<ITypeOwner> get_Pointer();
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.InitializerExpressionNode : NodeBase {
    public IType SourceType { get; }
    public bool IsPassThrough { get; }
    public InitializerExpressionNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode initializer, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
    public virtual bool get_IsPassThrough();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.LocalDeclarationNode : NodeBase {
    private ITreeNodePointer`1<IVariableDeclaration> myPointer;
    public IType SourceType { get; }
    public bool IsPassThrough { get; }
    public bool CanBeExpanded { get; }
    public LocalDeclarationNode(IVariableDeclaration declaration, ValueTrackingDirections direction, ValueTrackingSessionEnvinonment session, IValueTrackingNode parent, IValueTrackingCallStack stack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
    public virtual bool get_IsPassThrough();
    public virtual bool get_CanBeExpanded();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.MethodCallWithDefaultValue : NodeBase {
    private IDeclaredElementPointer`1<IParameter> myParameterPointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public MethodCallWithDefaultValue(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IValueTrackingCallStack callStack, ICSharpArgumentsOwner argumentsOwner, IParameter parameter);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    private string GetDefaultValueText();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.MethodLikeUsageNode : NodeBase {
    private IDeclaredElementPointer`1<IParametersOwner> myPointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public MethodLikeUsageNode(IParametersOwner parametersOwner, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.MultipleElementsNode : NodeBase {
    [NotNullAttribute]
private IList`1<IValueTrackingNode> myChildren;
    public ITreeNode SourceElement { get; }
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public MultipleElementsNode(IList`1<IValueTrackingNode> children, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual ITreeNode get_SourceElement();
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ParameterInNode : NodeBase {
    [CanBeNullAttribute]
private IDeclaredElementPointer`1<IParameter> myParameterPointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public ParameterInNode(IParameterDeclaration parameterDeclaration, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ParameterInNodeWithOverrides : NodeBase {
    private IDeclaredElementPointer`1<IParameter> myParameterPointer;
    private ITypePointer myOwnerTypePointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public ParameterInNodeWithOverrides(IParameterDeclaration declaration, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingCallStack valueTrackingCallStack, ITypePointer ownerTypePointer);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ParameterNodeByRefWithOverrides : NodeBase {
    private ParameterInNodeWithOverrides myParameterInNodeWithOverrides;
    private ParameterOutNode myParameterOutNode;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public ParameterNodeByRefWithOverrides(IParameterDeclaration declaration, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack, ITypePointer ownerTypePointer);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ParameterOutNode : NodeBase {
    [CanBeNullAttribute]
private IDeclaredElementPointer`1<IParameter> myParameterPointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public ParameterOutNode(IParameterDeclaration parameterDeclaration, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IValueTrackingCallStack callStack);
    public ParameterOutNode(IParameter parameter, ITreeNode parameterDeclaration, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    private IPreExpandedNode GetWrappedNode(IAnonymousMethod anonymousMethod, IParameter parameter);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ParenthesizedDesignationNode : NodeBase {
    [NotNullAttribute]
private ITreeNodePointer`1<IParenthesizedVariableDesignation> myDesignationPointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public ParenthesizedDesignationNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IParenthesizedVariableDesignation parenthesizedDesignation, IValueTrackingNode parent, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.PropertyInitialNode : NodeBase {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IProperty> myPointer;
    [CanBeNullAttribute]
private ITypePointer myOwnerType;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public PropertyInitialNode(IProperty property, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack, IType ownerType);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.PropertySelfValueNode : NodeBase {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IProperty> myPointer;
    [CanBeNullAttribute]
private ITypePointer myOwnerType;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public PropertySelfValueNode(IProperty property, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack, IType ownerType);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.PropertyUsagesNode : NodeBase {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IProperty> myPointer;
    [CanBeNullAttribute]
private ITypePointer myOwnerTypePointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public PropertyUsagesNode(IProperty property, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack, ITypePointer ownerTypePointer);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ReturnFromMethodLikeNode : NodeBase {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IParametersOwner> myPointer;
    [CanBeNullAttribute]
private ITypePointer myOwnerType;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public ReturnFromMethodLikeNode(IParametersOwner methodLikeElement, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack, IType ownerType);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ThisWrapper.Impl.PreExpandedNodeThisWrappedNodeUsage : PreExpandedNodeBase {
    private IDeclaredElement myDeclaredElement;
    private List`1<IDeclaredElement> myAllMembers;
    private List`1<IReference> myReferences;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeThisWrappedNodeUsage(ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, IDeclaredElement declaredElement);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    public virtual IFinderOperation InitNode(IProgressIndicator pi, CachingFinder cachingFinder);
    public static PreExpandedNodeThisWrappedNodeUsage CreateFromContext(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IValueTrackingCallStack stack, ITreeNode element);
    [CompilerGeneratedAttribute]
private TransitionalExpressionNode <ExpandWithFindResults>b__7_1(IObjectCreationExpression e);
    [CompilerGeneratedAttribute]
private ThisUsageNode <ExpandWithFindResults>b__7_2(IConstructorInitializer e);
    [CompilerGeneratedAttribute]
private ThisToQualifierWrappedNode <ExpandWithFindResults>b__7_3(IReferenceExpression e);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ThisWrapper.Impl.PreExpandedNodeUsagesOfThis : PreExpandedNodeBase {
    private IDeclaredElementPointer`1<IDeclaredElement> myPointer;
    private bool myIsWrite;
    private ITypePointer myOwnerType;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeUsagesOfThis(IDeclaredElement element, bool isWrite, ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, ITypePointer ownerType);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    private void ConsumeNodesFrom(IDeclaration functionDeclaration, List`1<IValueTrackingNode> nodes);
    private void ConsumeNodesFromBlock(IBlock block, List`1<IValueTrackingNode> nodes);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ThisWrapper.Impl.QualifierNode : NodeBase {
    private IDeclaredElementPointer`1<IDeclaredElement> myPointer;
    private bool myIsWrite;
    private ITypePointer myOwnerTypePointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    private QualifierNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IDeclaredElement declaredElement, IValueTrackingCallStack callStack, IReferenceExpression expression, IType ownerType);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    [CanBeNullAttribute]
public static QualifierNode CreateOfElement(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IDeclaredElement element, IValueTrackingCallStack callStack, IReferenceExpression expression);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ThisWrapper.Impl.ThisToQualifierWrappedNode : NodeBase {
    private ITreeNodePointer`1<IReferenceExpression> myExpressionPointer;
    [CanBeNullAttribute]
public IReferenceExpression Expression { get; }
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public ThisToQualifierWrappedNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IReferenceExpression expression, IValueTrackingCallStack callStack);
    public IReferenceExpression get_Expression();
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ThisWrapper.Impl.ThisUsageNode : NodeBase {
    private ITreeNodePointer`1<ITreeNode> myExpressionPointer;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public ThisUsageNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode expression, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ThisWrapper.QualifierToThisWrapperNode : WrapperNodeBase {
    public QualifierToThisWrapperNode(IValueTrackingNode wrappedNode, IValueTrackingNode parent);
    public virtual IValueTrackingNode WrapChild(IValueTrackingNode childOfWrappedNode);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.ThisWrapper.ThisToQualifierWrapperNode : WrapperNodeBase {
    private ValueTrackingDirections myDirectionsOfWrappedNode;
    public ThisToQualifierWrapperNode(IValueTrackingNode wrappedNode, IValueTrackingNode parent, ValueTrackingDirections directionsOfWrappedNode);
    public virtual IValueTrackingNode WrapChild(IValueTrackingNode childOfWrappedNode);
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style, RichText innerPresentation);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode : NodeBase {
    [NotNullAttribute]
private ITreeNodePointer`1<ICSharpExpression> myExpressionPointer;
    private ValueTrackingChildRoles myValueTrackingChildRole;
    [NotNullAttribute]
public ITreeNodePointer`1<ICSharpExpression> ExpressionPointer { get; }
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public bool CanBeExpanded { get; }
    public TransitionalExpressionNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, ICSharpExpression expression, IValueTrackingNode parent, IValueTrackingCallStack callStack, ValueTrackingChildRoles valueTrackingChildRole);
    public ITreeNodePointer`1<ICSharpExpression> get_ExpressionPointer();
    public virtual bool get_IsPassThrough();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
    public virtual IType get_SourceType();
    public virtual bool get_CanBeExpanded();
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode DelegateToEvent(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode AssignmentToSource(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode SourceToAssignmentExpression(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessValueVariableToPropertyUsages(IReferenceExpression referenceExpression, IDeclaredElement element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<GetContainingRefExpression>d__17")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> GetContainingRefExpression(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<GetRefExpressionOperand>d__18")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> GetRefExpressionOperand(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<ProcessVariableDesignations>d__19")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> ProcessVariableDesignations(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<GetContainingParenthesizedExpression>d__20")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> GetContainingParenthesizedExpression(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<GetOperandThroughParentheses>d__21")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> GetOperandThroughParentheses(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<ProcessThisToQualifier>d__22")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> ProcessThisToQualifier(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<ProcessQualifierToThis>d__23")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> ProcessQualifierToThis(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessDelegateConstructor(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessCastToInner(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessCastToOuter(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<ProcessFromNullTernary>d__27")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> ProcessFromNullTernary(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalExpressionNode/<ProcessFromNullCoalescing>d__28")]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> ProcessFromNullCoalescing(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessToNullCoalescing(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessToTernary(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessReturnedValue(ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
private IEnumerable`1<IPreExpandedNode> ProcessLocalDfa(IReferenceExpression referenceExpression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessFromInitializer(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessObjectInitializer(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessWithAssignmentInitializer(ICSharpExpression expression);
    [CanBeNullAttribute]
private IPreExpandedNode FromPropertyOrFieldAssignment(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessUseField(IReferenceExpression referenceExpression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode CreateUseFieldNode(IField field);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessCallProperty(IReferenceExpression referenceExpression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessCallIndexer(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode CreatePropertyAccess(ICSharpExpression expression, IProperty property, ExpressionAccessType accessType);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessInvocation(IInvocationExpression invocationExpression);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessToDestFromSource(IAssignmentExpression statement);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessToSourceFromDest(IAssignmentExpression statement);
    [CanBeNullAttribute]
[PureAttribute]
private IPreExpandedNode ProcessArgument(ICSharpArgument argument);
    [MustUseReturnValueAttribute]
private bool CanMakeParameterIn(IParameter parameter, ValueTrackingDirections& directionForParameter);
    [PureAttribute]
public bool HasRole(ValueTrackingChildRoles valueTrackingChildRole);
    [CanBeNullAttribute]
[PureAttribute]
private static RichText PresentDownExpression(ICSharpExpression expression, IExpressionPresentationStyle style);
    [CompilerGeneratedAttribute]
private TransitionalExpressionNode <ProcessLocalDfa>b__32_0(IReferenceExpression usage);
    [CompilerGeneratedAttribute]
private TransitionalExpressionNode <ProcessLocalDfa>b__32_1(IReferenceExpression usage);
    [CompilerGeneratedAttribute]
private TransitionalExpressionNode <ProcessLocalDfa>b__32_2(IReferenceExpression usageBefore);
    [CompilerGeneratedAttribute]
private TransitionalExpressionNode <ProcessLocalDfa>b__32_4(IReferenceExpression usageAfter);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.TransitionalPatternNode : NodeBase {
    [NotNullAttribute]
private ITreeNodePointer`1<IPattern> myPatternPointer;
    [CompilerGeneratedAttribute]
private bool <IsPassThrough>k__BackingField;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public TransitionalPatternNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IPattern pattern, IValueTrackingNode parent, IValueTrackingCallStack callStack);
    [PureAttribute]
private static bool CalcIsPassThrough(IPattern pattern);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.UsagesOfContructorNode : NodeBase {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IConstructor> myConstructor;
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public UsagesOfContructorNode(ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, ITreeNode element, IValueTrackingCallStack callStack, IConstructor constructor);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Nodes.WithRelatedElementsNode : NodeBase {
    [NotNullAttribute]
private IList`1<IValueTrackingNode> myChildren;
    public ITreeNode SourceElement { get; }
    public bool IsPassThrough { get; }
    public IType SourceType { get; }
    public WithRelatedElementsNode(IList`1<IValueTrackingNode> children, ValueTrackingSessionEnvinonment session, ValueTrackingDirections direction, IValueTrackingNode parent, IValueTrackingCallStack callStack);
    public virtual IPreExpandedNode GetPreExpandedNode(IProgressIndicator pi);
    public virtual ITreeNode get_SourceElement();
    public virtual bool get_IsPassThrough();
    public virtual IType get_SourceType();
    public virtual void AfterInitNode();
    protected virtual IValueTrackingNodePresentation CreatePresentation(IExpressionPresentationStyle style);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.PreNodes.PreExpandedNodeCall : PreExpandedNodeBase {
    private IDeclaredElement myDeclaredElement;
    private bool myIsWriteAccess;
    private bool myNotVirtualCall;
    [CanBeNullAttribute]
private ITypePointer myOwnerTypePointer;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeCall(IDeclaredElement overridableMember, ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, IType ownerType, bool isWriteAccess, bool notVirtualCall);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    private void ProcessProperty(IProperty property, List`1<IValueTrackingNode> results);
    private void ProcessValueReturn(IDeclaredElement element, List`1<IValueTrackingNode> results);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.PreNodes.PreExpandedNodeFieldLikeMemberUsage : PreExpandedNodeBase {
    [NotNullAttribute]
private ITypeOwner myTypeOwner;
    [NotNullAttribute]
private List`1<IDeclaredElement> myAllMembers;
    [NotNullAttribute]
private List`1<IReference> myReferences;
    private bool mySearchUsagesOfInheritors;
    private ITypePointer myOwnerTypePointer;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeFieldLikeMemberUsage(ITypeOwner typeOwner, ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, bool searchUsagesOfInheritors, ITypePointer ownerTypePointer);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    public virtual IFinderOperation InitNode(IProgressIndicator pi, CachingFinder cachingFinder);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.PreNodes.PreExpandedNodeMethodLikeUsage : PreExpandedNodeBase {
    private IParametersOwner myDeclaredElement;
    private List`1<IDeclaredElement> myAllMembers;
    private List`1<IReference> myReferences;
    private ICSharpExpression myCaller;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeMethodLikeUsage(IParametersOwner declaredElement, ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    public virtual IFinderOperation InitNode(IProgressIndicator pi, CachingFinder finder);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.PreNodes.PreExpandedNodeParameterIn : PreExpandedNodeBase {
    [NotNullAttribute]
private IParameter myParameter;
    private bool myIsCallToBase;
    private bool myIsExpandedParameter;
    private IType myOwnerType;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeParameterIn(IParameter parameter, ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, bool isCallToBase, bool isExpandedParameter, IType ownerType);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.PreNodes.PreExpandedNodeParameterOut : PreExpandedNodeBase {
    private IParametersOwner myOwner;
    private IParameter myParameter;
    private List`1<IParametersOwner> myAllOwners;
    private List`1<Pair`2<IReference, IParametersOwner>> myReferences;
    private int myParameterIndex;
    [CanBeNullAttribute]
private ICSharpArgumentsOwner myCaller;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeParameterOut(ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack, IParametersOwner owner, IParameter parameter);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual IFinderOperation InitNode(IProgressIndicator pi, CachingFinder cachingFinder);
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
    [CanBeNullAttribute]
private IParameter GetParameterByIndex(IParametersOwner parametersOwner);
    [PureAttribute]
private static bool HasExpandedArguments(IParameter parameter, ICSharpArgumentsOwner argumentsOwner);
    [CanBeNullAttribute]
private static ICSharpExpression GetArgumentValue(ICSharpArgumentsOwner argumentsOwner, IParameter parameter);
    [CanBeNullAttribute]
private NodeBase TryFindDeconstructionNode(IParameter parameter, IDeconstructionReference deconstructionReference);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.PreNodes.PreExpandedNodeParameterUsages : PreExpandedNodeBase {
    [NotNullAttribute]
private IParameter myParameter;
    [NotNullAttribute]
private List`1<IReference> myReferences;
    public IList`1<IDeclaredElement> ElementsToSearch { get; }
    public PreExpandedNodeParameterUsages(IParameter parameter, ValueTrackingSessionEnvinonment session, ValueTrackingDirections directions, IValueTrackingNode parent, IValueTrackingCallStack stack);
    public virtual IList`1<IDeclaredElement> get_ElementsToSearch();
    public virtual void AddReference(IReference reference, IDeclaredElement element);
    public virtual IList`1<IValueTrackingNode> ExpandWithFindResults(IProgressIndicator pi);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Presentation.CSharpExpressionPresenter : ExpressionPresenterLanguageService {
    public virtual bool IsGrouppingNode(ITreeNode treeNode);
    public virtual bool CanReduce(ITreeNode node);
}
public class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Utils.LocalValueTrackingUtil : object {
    private ITypeOwner myVariable;
    [CanBeNullAttribute]
private IReferenceExpression myExpression;
    [CompilerGeneratedAttribute]
private List`1<IReferenceExpression> <UsagesBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IReferenceExpression> <UsagesAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExpression <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <InitializerElement>k__BackingField;
    public List`1<IReferenceExpression> UsagesBefore { get; private set; }
    public List`1<IReferenceExpression> UsagesAfter { get; private set; }
    [CanBeNullAttribute]
public ICSharpExpression Collection { get; private set; }
    [CanBeNullAttribute]
public ITreeNode InitializerElement { get; private set; }
    private LocalValueTrackingUtil(ITypeOwner variable, IReferenceExpression expression);
    [NotNullAttribute]
public static LocalValueTrackingUtil CreateInstance(ITypeOwner variable, IReferenceExpression expression);
    [CompilerGeneratedAttribute]
public List`1<IReferenceExpression> get_UsagesBefore();
    [CompilerGeneratedAttribute]
private void set_UsagesBefore(List`1<IReferenceExpression> value);
    [CompilerGeneratedAttribute]
public List`1<IReferenceExpression> get_UsagesAfter();
    [CompilerGeneratedAttribute]
private void set_UsagesAfter(List`1<IReferenceExpression> value);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_Collection();
    [CompilerGeneratedAttribute]
private void set_Collection(ICSharpExpression value);
    [CompilerGeneratedAttribute]
public ITreeNode get_InitializerElement();
    [CompilerGeneratedAttribute]
private void set_InitializerElement(ITreeNode value);
    private void RunAnalysis();
}
public static class JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.Utils.ValueTrackingUtil : object {
    public static void AddReturnFromBlock(IValueTrackingCallStack stack, IValueTrackingNode parent, ValueTrackingDirections directions, ValueTrackingSessionEnvinonment session, IBlock block, List`1<IValueTrackingNode> result);
    [PureAttribute]
public static bool IsCallToBase(ICSharpExpression expression);
    [PureAttribute]
public static string GetArgumentsOwnerText(ICSharpArgumentsOwner argumentOwner);
    public static void AddValueVariable(IValueTrackingCallStack stack, IValueTrackingNode parent, ValueTrackingSessionEnvinonment session, ITreeNode accessorBody, List`1<IValueTrackingNode> result);
    public static void RemoveRedundantOverrides(List`1<T> elements, IType ownerType);
    public static bool IsOverrideRedundant(IType ownerType, TDeclaredElement member);
    private static bool IsOverrideRedundantInternal(IType ownerType, TDeclaredElement member);
    [CanBeNullAttribute]
public static IType GetOwnerType(ICSharpExpression expression);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Feature.Services.CSharp.ValueTracking.ValueTrackingChildRoles : Enum {
    public int value__;
    public static ValueTrackingChildRoles NoRole;
    public static ValueTrackingChildRoles LocalDfaResult;
    public static ValueTrackingChildRoles DestFromSource;
    public static ValueTrackingChildRoles SourceFromDest;
    public static ValueTrackingChildRoles UsageOfElement;
    public static ValueTrackingChildRoles ArgumentFromParameter;
    public static ValueTrackingChildRoles ValueOfInitializer;
    public static ValueTrackingChildRoles ArgumentOfNullCoalescing;
    public static ValueTrackingChildRoles ArgumentOfTernary;
    public static ValueTrackingChildRoles CastOuter;
    public static ValueTrackingChildRoles CastInner;
    public static ValueTrackingChildRoles ArgumentOfDelegateConstructor;
    public static ValueTrackingChildRoles DelegateConstructorOfArgument;
    public static ValueTrackingChildRoles ThisOfQualifier;
    public static ValueTrackingChildRoles QualifierOfThis;
    public static ValueTrackingChildRoles ElementOfCollection;
    public static ValueTrackingChildRoles CollectionOfElement;
    public static ValueTrackingChildRoles ExpressionWithinParentheses;
    public static ValueTrackingChildRoles ContainingParenthesizedExpression;
    public static ValueTrackingChildRoles UsageOfElementWithObjectInitializer;
    public static ValueTrackingChildRoles SourceOfAssignmentExpression;
    public static ValueTrackingChildRoles AssignmentExpressionOfSource;
    public static ValueTrackingChildRoles ArgumentOfNewList;
    public static ValueTrackingChildRoles NewListOfArgument;
    public static ValueTrackingChildRoles ArgumentOfAddRange;
    public static ValueTrackingChildRoles AddRangeOfArgument;
    public static ValueTrackingChildRoles ArrowExpression;
    public static ValueTrackingChildRoles RefExpressionOperand;
    public static ValueTrackingChildRoles ContainingRefExpression;
    public static ValueTrackingChildRoles SingleVariableDesignation;
    public static ValueTrackingChildRoles WithInitializerAssignment;
    public static ValueTrackingChildRoles SubpatternMemberCheck;
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Feature.Services.CSharp.VisualElements.CSharpColorDeclaredElementSearcher : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Feature.Services.CSharp.VisualElements.CSharpColorDeclaredElementSearcher/<GetWords>d__0")]
public sealed virtual IEnumerable`1<string> GetWords(IColorDeclaredElement element);
}
internal class JetBrains.ReSharper.Feature.Services.CSharp.VisualElements.CSharpColorReference : object {
    private ITypeElement myQualifierType;
    private ICSharpExpression myOwner;
    private PredefinedColorTypes myPredefinedColorTypes;
    [CompilerGeneratedAttribute]
private Nullable`1<DocumentRange> <ColorConstantRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IColorElement <ColorElement>k__BackingField;
    public ITreeNode Owner { get; }
    public Nullable`1<DocumentRange> ColorConstantRange { get; }
    public IColorElement ColorElement { get; }
    public ColorBindOptions BindOptions { get; }
    public CSharpColorReference(IColorElement colorElement, ITypeElement qualifierType, IReferenceExpression owner);
    public CSharpColorReference(IColorElement colorElement, ITypeElement qualifierType, IInvocationExpression invocationExpression);
    public sealed virtual ITreeNode get_Owner();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DocumentRange> get_ColorConstantRange();
    [CompilerGeneratedAttribute]
public sealed virtual IColorElement get_ColorElement();
    public sealed virtual void Bind(IColorElement colorElement);
    [CanBeNullAttribute]
private ICSharpExpression TryReplaceAsNamed(IColorElement colorElement);
    [CanBeNullAttribute]
private ITreeNode ReplaceInvocation(IMethod fromArgb, string replaceAll, bool useHex, Pair`2[] args);
    [CanBeNullAttribute]
private static ICSharpExpression CreateConstantExpression(int value, bool hex, CSharpElementFactory factory, IPsiModule psiModule);
    [CanBeNullAttribute]
private static ICSharpArgument FindArgument(IInvocationExpression invocationExpression, string paramName);
    public sealed virtual IEnumerable`1<IColorElement> GetColorTable();
    public sealed virtual ColorBindOptions get_BindOptions();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Feature.Services.CSharp.VisualElements.VisualElementFactory : object {
    public sealed virtual IColorReference GetColorReference(ITreeNode element);
    [CanBeNullAttribute]
private static IColorReference ReferenceFromProperty(IReferenceExpression qualifier, IReferenceExpression colorQulifiedMemberExpression);
    [CanBeNullAttribute]
private static IColorReference ReferenceFromInvocation(IReferenceExpression qualifier, IReferenceExpression methodReferenceExpression);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Feature.Services.CSharp.ZoneMarker : object {
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Property : GroupBase {
    private static IGroupDescriptor[] ourGroupBy;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckName>k__BackingField;
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string DisplayName { get; public set; }
    [DefaultValueAttribute("True")]
public bool CheckName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public IList`1<IGroupDescriptor> GroupBy { get; }
    private static Property();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public bool get_CheckName();
    [CompilerGeneratedAttribute]
public void set_CheckName(bool value);
    public virtual IList`1<IGroupDescriptor> get_GroupBy();
    public virtual INodeGroup CreateNodeGroup();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.PropertyBase : object {
    protected internal string GetKey(ITreeNode node, bool checkName, PropPart& part);
    private IPropertyDeclaration TryFindRelatedProperty(IMultipleFieldDeclaration multiDeclaration, IMultipleDeclarationMember fieldDeclaration, bool checkName);
    [NotNullAttribute]
private static string GetPropertyName(IDeclaration declaration);
    private static string NotPart(PropPart& propPart);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.PropertyName : PropertyBase {
    [CompilerGeneratedAttribute]
private SortDirection <Direction>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SortDirection Direction { get; public set; }
    public string ParameterName { get; }
    [CompilerGeneratedAttribute]
public SortDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(SortDirection value);
    public sealed virtual string get_ParameterName();
    private sealed virtual override object JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor.GetKey(ITreeNode node);
    public sealed virtual IComparer`1<ITreeNode> GetComparer();
    public sealed virtual int Compare(ITreeNode x, ITreeNode y);
    private int GetSign();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.PropertyPart : PropertyBase {
    [CompilerGeneratedAttribute]
private PropPart <Match>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public PropPart Match { get; public set; }
    [CompilerGeneratedAttribute]
public PropPart get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(PropPart value);
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.PropPart : Enum {
    public int value__;
    [BrowsableAttribute("False")]
public static PropPart NotPart;
    public static PropPart Field;
    public static PropPart Property;
    [BrowsableAttribute("False")]
public static PropPart Any;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
