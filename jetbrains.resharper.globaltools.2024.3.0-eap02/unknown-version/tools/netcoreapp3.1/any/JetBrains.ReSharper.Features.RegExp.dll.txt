internal class JetBrains.ReSharper.Features.RegExp.Completion.ArgumentContext : GroupNameContext {
    [NotNullAttribute]
private TextLookupRanges myRanges;
    public ArgumentContext(CSharpCodeCompletionContext context, IReadOnlyCollection`1<string> groupNames);
    public virtual string GetText(string groupName);
    public virtual TextLookupRanges GetRanges();
}
internal class JetBrains.ReSharper.Features.RegExp.Completion.GroupNameAnalyzer : object {
    [CanBeNullAttribute]
private IPsiSourceFile mySourceFile;
    [NotNullAttribute]
private HashSet`1<string> myGroupNames;
    [CanBeNullAttribute]
private OneToListMap`2<ITreeNode, IFile> myValidNodes;
    [NotNullAttribute]
private OneToListMap`2<ITreeNode, IFile> ValidNodes { get; }
    public GroupNameAnalyzer(CSharpCodeCompletionContext context);
    private OneToListMap`2<ITreeNode, IFile> get_ValidNodes();
    private void AddAllLookupItems();
    private void AddLookupItems(IEnumerable`1<IFile> files);
    private bool ProcessPatternArgument(ICSharpArgument argument);
    private bool ProcessRegexCtor(IObjectCreationExpression expression);
    private bool ProcessRegexReference(IReferenceExpression expression);
    private bool ProcessMatchReference(IReferenceExpression expression);
    private bool ProcessMatchInvocation(IInvocationExpression expression);
    [CanBeNullAttribute]
public GroupNameContext CreateContext(CSharpCodeCompletionContext context);
    [CanBeNullAttribute]
private GroupNameContext CreateContextFromMember(CSharpCodeCompletionContext context);
    [CanBeNullAttribute]
private GroupNameContext CreateContextFromArgument(CSharpCodeCompletionContext context);
    [CanBeNullAttribute]
private IReadOnlyCollection`1<string> CollectNames(IReferenceExpression referenceExpression);
}
internal abstract class JetBrains.ReSharper.Features.RegExp.Completion.GroupNameContext : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <GroupNames>k__BackingField;
    [NotNullAttribute]
public IReadOnlyCollection`1<string> GroupNames { get; }
    protected GroupNameContext(IReadOnlyCollection`1<string> groupNames);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_GroupNames();
    [NotNullAttribute]
public abstract virtual string GetText(string groupName);
    [NotNullAttribute]
public abstract virtual TextLookupRanges GetRanges();
}
internal class JetBrains.ReSharper.Features.RegExp.Completion.MemberContext : GroupNameContext {
    private static string StartPrefix;
    private static string EndPostfix;
    private TextLookupRanges myRanges;
    public MemberContext(CSharpCodeCompletionContext context, IReadOnlyCollection`1<string> groupNames);
    public virtual string GetText(string groupName);
    public virtual TextLookupRanges GetRanges();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Features.RegExp.Completion.RegExpGroupNameItemsProvider : CSharpItemsProviderBase`1<CSharpCodeCompletionContext> {
    protected virtual bool IsAvailable(CSharpCodeCompletionContext context);
    protected virtual bool AddLookupItems(CSharpCodeCompletionContext context, IItemsCollector collector);
    private void AddLookupItems(CSharpCodeCompletionContext context, IItemsCollector collector, GroupNameContext groupNameContext);
}
public class JetBrains.ReSharper.Features.RegExp.Completion.RegExpGroupNameLookupItem : TextLookupItemBase {
    public IconId Image { get; }
    public RegExpGroupNameLookupItem(string text);
    public virtual IconId get_Image();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Completion.ZoneMarker : object {
}
[ContextActionAttribute]
public class JetBrains.ReSharper.Features.RegExp.ContextActions.FixRegularExpressionAction : ContextActionBase {
    private ICSharpContextActionDataProvider myProvider;
    private ICSharpLiteralExpression myLiteralExpression;
    private ICSharpLiteralWrapper myLiteralWrapper;
    public string Text { get; }
    public FixRegularExpressionAction(ICSharpContextActionDataProvider provider);
    public virtual string get_Text();
    public virtual IEnumerable`1<IntentionAction> CreateBulbItems();
    protected virtual Action`1<ITextControl> ExecutePsiTransaction(ISolution solution, IProgressIndicator progress);
    public virtual bool IsAvailable(IUserDataHolder cache);
    private static string TranslateEscapeCharactersToPresentationForm(string value);
}
[ShellComponentAttribute("16")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Features.RegExp.ContextActions.RegexpSplitStringTrigger : object {
    public sealed virtual bool IsAvailable(ICSharpContextActionDataProvider provider, ITokenNode literalToken);
}
[ContextActionAttribute]
public class JetBrains.ReSharper.Features.RegExp.ContextActions.ToPrecompileAction : ContextActionBase {
    private static string ReplaceMethodName;
    private ICSharpContextActionDataProvider myProvider;
    private IInvocationExpression myInvocationExpression;
    private ITypeElement myTypeElement;
    private IMethod myMethod;
    private TextRange myReplacementRange;
    private IReferenceExpression myQualifierExpression;
    public string Text { get; }
    public ToPrecompileAction(ICSharpContextActionDataProvider provider);
    public virtual string get_Text();
    protected virtual Action`1<ITextControl> ExecutePsiTransaction(ISolution solution, IProgressIndicator progress);
    private int OptionsArgumentDefaultPosition();
    private int TimeoutArgumentDefaultPosition();
    public virtual bool IsAvailable(IUserDataHolder cache);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Features.RegExp.ContextActions.ToPrecompileActionExtensions : object {
    public static JetHashSet`1<string> RegexMemberNames;
    private static ToPrecompileActionExtensions();
    [ExtensionAttribute]
public static ICSharpArgument RemoveExplictName(ICSharpArgument argument);
    [ExtensionAttribute]
public static bool Check(ICSharpArgument argument);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.ContextActions.ZoneMarker : object {
}
[ConfigurableSeverityHighlightingAttribute("RegExpInspections", "REGULAR_EXPRESSION")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.NestedQuantifierError : RegExpHighlightingBase {
    private string MESSAGE;
    public static string HIGHLIGHTING_ID;
    [CompilerGeneratedAttribute]
private IRegexTreeNode <Quantifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolTip>k__BackingField;
    public IRegexTreeNode Quantifier { get; }
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public NestedQuantifierError(IRegexTreeNode quantifier);
    [CompilerGeneratedAttribute]
public IRegexTreeNode get_Quantifier();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual DocumentRange CalculateRange();
    public virtual bool IsValid();
}
[ConfigurableSeverityHighlightingAttribute("RegExpInspections", "REGULAR_EXPRESSION")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.NumberQuantifierIllegalError : RegExpHighlightingBase {
    private string MESSAGE;
    public static string HIGHLIGHTING_ID;
    [CompilerGeneratedAttribute]
private IRegexTreeNode <Node>k__BackingField;
    public IRegexTreeNode Node { get; }
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public NumberQuantifierIllegalError(IRegexTreeNode node);
    [CompilerGeneratedAttribute]
public IRegexTreeNode get_Node();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual DocumentRange CalculateRange();
    public virtual bool IsValid();
}
[ConfigurableSeverityHighlightingAttribute("RegExpInspections", "REGULAR_EXPRESSION")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.NumberQuantifierTooLongError : RegExpHighlightingBase {
    private string MESSAGE;
    public static string HIGHLIGHTING_ID;
    [CompilerGeneratedAttribute]
private IRegexTreeNode <Node>k__BackingField;
    public IRegexTreeNode Node { get; }
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public NumberQuantifierTooLongError(IRegexTreeNode node);
    [CompilerGeneratedAttribute]
public IRegexTreeNode get_Node();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual DocumentRange CalculateRange();
    public virtual bool IsValid();
}
[ConfigurableSeverityHighlightingAttribute("RegExpInspections", "REGULAR_EXPRESSION")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.QuantifierAfterAnchorWarning : RegExpHighlightingBase {
    private string MESSAGE;
    public static string HIGHLIGHTING_ID;
    [CompilerGeneratedAttribute]
private IRegexTreeNode <Quantifier>k__BackingField;
    public IRegexTreeNode Quantifier { get; }
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public QuantifierAfterAnchorWarning(IRegexTreeNode quantifier);
    [CompilerGeneratedAttribute]
public IRegexTreeNode get_Quantifier();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual DocumentRange CalculateRange();
    public virtual bool IsValid();
}
[ConfigurableSeverityHighlightingAttribute("RegExpInspections", "REGULAR_EXPRESSION")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.QuantifierFollowingNothingError : RegExpHighlightingBase {
    private string MESSAGE;
    public static string HIGHLIGHTING_ID;
    [CompilerGeneratedAttribute]
private IRegexTreeNode <Quantifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolTip>k__BackingField;
    public IRegexTreeNode Quantifier { get; }
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public QuantifierFollowingNothingError(IRegexTreeNode quantifier);
    [CompilerGeneratedAttribute]
public IRegexTreeNode get_Quantifier();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual DocumentRange CalculateRange();
    public virtual bool IsValid();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.QuickFix.BestPracticesQuickFixRegistration : object {
    public IEnumerable`1<Type> Dependencies { get; }
    public sealed virtual IEnumerable`1<Type> get_Dependencies();
    public sealed virtual void Register(IQuickFixesRegistrar table);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.QuickFix.ZoneMarker : object {
}
[RegisterConfigurableSeverityAttribute("RegExpInspections", "", "", "", "LanguageUsage", "", "JetBrains.ReSharper.Features.RegExp.Resources.Strings", "RegularExpressionInspections", "", "JetBrains.ReSharper.Features.RegExp.Resources.Strings", "RegularExpressionLanguageInspections", "4")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.RegisterSeverityComponent46BAF43182AC44A16BC895871EFB9CEC204EB13A3D591AC4E209116436ACFD98 : object {
}
[ConfigurableSeverityHighlightingAttribute("RegExpInspections", "REGULAR_EXPRESSION")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.Definitions.SetRangeInReverseOrderError : RegExpHighlightingBase {
    private string MESSAGE;
    public static string HIGHLIGHTING_ID;
    [CompilerGeneratedAttribute]
private IRegexTreeNode <Node>k__BackingField;
    public IRegexTreeNode Node { get; }
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public SetRangeInReverseOrderError(IRegexTreeNode node);
    [CompilerGeneratedAttribute]
public IRegexTreeNode get_Node();
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual DocumentRange CalculateRange();
    public virtual bool IsValid();
}
public interface JetBrains.ReSharper.Features.RegExp.Daemon.IRegexDaemonProvider {
    public abstract virtual void Initialize(ElementProblemAnalyzerData data, IRegexContainer file);
}
public abstract class JetBrains.ReSharper.Features.RegExp.Daemon.RegExpDaemonStageBase`1 : object {
    public sealed virtual IEnumerable`1<IDaemonStageProcess> CreateProcess(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind);
    protected abstract virtual IDaemonStageProcess CreateProcess(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind, IRegexContainer file);
    protected virtual bool IsSupported(IPsiSourceFile sourceFile);
}
[HighlightingSourceAttribute]
public class JetBrains.ReSharper.Features.RegExp.Daemon.RegExpIdentifierHighlighterProcess : IdentifierHighlighter`1<IHighlightingConsumer> {
    private IElementAnalyzerDispatcher myElementAnalyzerDispatcher;
    private IDaemonProcess myDaemonProcess;
    [NotNullAttribute]
private IRegexContainer myFile;
    private IFile JetBrains.ReSharper.Feature.Services.Daemon.IDaemonStageProcessWithPsiFile.File { get; }
    public IDaemonProcess DaemonProcess { get; }
    public RegExpIdentifierHighlighterProcess(IDaemonProcess process, IContextBoundSettingsStore settingsStore, DaemonProcessKind processKind, IRegexContainer file, ElementProblemAnalyzerRegistrar problemAnalyzerRegistrar);
    private sealed virtual override IFile JetBrains.ReSharper.Feature.Services.Daemon.IDaemonStageProcessWithPsiFile.get_File();
    protected virtual void VisitNode(ITreeNode node, IHighlightingConsumer context);
    public sealed virtual void Execute(Action`1<DaemonStageResult> committer);
    public sealed virtual IDaemonProcess get_DaemonProcess();
    protected virtual TextRange GetTextRange(ITreeNode node);
    protected virtual void Highlight(ITreeNode node, IHighlightingConsumer consumer, string highlightingAttributeId);
    protected virtual void AddHighlighting(ITreeNode node, IHighlightingConsumer consumer, IHighlighting highlighting);
    protected virtual void HighlightError(ITreeNode node, string errorDescription, IHighlightingConsumer consumer);
    public virtual bool IsProcessingFinished(IHighlightingConsumer context);
    private static DocumentRange GetErrorRange(ITreeNode node);
}
[DaemonStageAttribute("0")]
public class JetBrains.ReSharper.Features.RegExp.Daemon.RegExpIdentifierHighlightingStage : RegExpDaemonStageBase`1<RegexBaseLanguage> {
    private ElementProblemAnalyzerRegistrar myElementProblemAnalyzerRegistrar;
    public RegExpIdentifierHighlightingStage(ElementProblemAnalyzerRegistrar elementProblemAnalyzerRegistrar);
    protected virtual IDaemonStageProcess CreateProcess(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind, IRegexContainer file);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.RegExp.BaseLanguage.RegexBaseLanguage", "16")]
internal class JetBrains.ReSharper.Features.RegExp.Daemon.RegExpLanguageSpecificDaemonBehavior : LanguageSpecificDaemonBehavior {
    public bool RunInSolutionAnalysis { get; }
    public bool RunInFindCodeIssues { get; }
    public virtual ErrorStripeRequestWithDescription InitialErrorStripe(IPsiSourceFile sourceFile);
    public virtual bool get_RunInSolutionAnalysis();
    public virtual bool get_RunInFindCodeIssues();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Daemon.ZoneMarker : object {
}
public interface JetBrains.ReSharper.Features.RegExp.Editor.IRegExpEditorSession {
    public IDocument InputDocument { get; }
    public IDocument PatternDocument { get; }
    public RegularExpressionEditorViewModel ViewModel { get; }
    public Lifetime Lifetime { get; }
    public abstract virtual IDocument get_InputDocument();
    public abstract virtual IDocument get_PatternDocument();
    public abstract virtual RegularExpressionEditorViewModel get_ViewModel();
    public abstract virtual Lifetime get_Lifetime();
    public abstract virtual void Apply();
    public abstract virtual bool CanApply();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(Action value);
}
[NonHighlightingSourceAttribute]
internal class JetBrains.ReSharper.Features.RegExp.Editor.PatternIdentifierHighlighter : IdentifierHighlighter`1<IDocumentMarkup> {
    [NotNullAttribute]
private IElementAnalyzerDispatcher myElementAnalyzerDispatcher;
    [CompilerGeneratedAttribute]
private OneToListMap`2<string, TextRange> <GroupMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasErrors>k__BackingField;
    public OneToListMap`2<string, TextRange> GroupMapping { get; }
    public bool HasErrors { get; private set; }
    public PatternIdentifierHighlighter(IRegexContainer file, IDocumentMarkup patternMarkup, ISolution solution, IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public OneToListMap`2<string, TextRange> get_GroupMapping();
    [CompilerGeneratedAttribute]
public bool get_HasErrors();
    [CompilerGeneratedAttribute]
private void set_HasErrors(bool value);
    protected virtual void VisitNode(ITreeNode node, IDocumentMarkup context);
    protected virtual void Highlight(ITreeNode node, IDocumentMarkup consumer, string highlightingAttributeId);
    protected virtual void AddHighlighting(ITreeNode node, IDocumentMarkup consumer, IHighlighting highlighting);
    protected virtual void HighlightError(ITreeNode node, string errorDescription, IDocumentMarkup consumer);
    protected virtual TextRange GetTextRange(ITreeNode node);
}
public class JetBrains.ReSharper.Features.RegExp.Editor.Sessions.Psi.RegExpEditorSessionPsi : RegExpEditorSession {
    private ITreeNodePointer`1<IStringLiteralOwner> myPointer;
    private ICSharpLiteralWrapper myWrapper;
    public RegExpEditorSessionPsi(Lifetime lifetime, IShellLocks locks, IStringLiteralOwner stringLiteralOwner);
    private static string GetOriginalPatternText(IStringLiteralOwner stringLiteralOwner);
    private static RegexOptions GetOriginalOptions(IStringLiteralOwner literalExpression);
    public virtual bool CanApply();
    public virtual void Apply();
    [CompilerGeneratedAttribute]
private void <Apply>b__6_0();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Editor.Sessions.Psi.ZoneMarker : object {
}
public abstract class JetBrains.ReSharper.Features.RegExp.Editor.Sessions.RegExpEditorSession : object {
    private IShellLocks myLocks;
    private IPsiSourceFile mySourceFile;
    private RegExpRunner myRunner;
    private OneToListMap`2<string, TextRange> myGroupMapping;
    private IHighlighter mySelectedHighlightingInput;
    private IHighlighter[] mySelectedHighlightingPatterns;
    private IDocument myInputDocument;
    private IDocumentMarkup myInputMarkup;
    private IDocument myPatternDocument;
    private IDocumentMarkup myPatternMarkup;
    private RegularExpressionEditorViewModel myViewModel;
    private LifetimeDefinition myLifetimeDefinition;
    private ISolution mySolution;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsPatternValid>k__BackingField;
    [CompilerGeneratedAttribute]
private Action Closed;
    [NotNullAttribute]
public IDocument InputDocument { get; }
    [NotNullAttribute]
public IDocument PatternDocument { get; }
    [NotNullAttribute]
public Lifetime Lifetime { get; }
    [NotNullAttribute]
public RegularExpressionEditorViewModel ViewModel { get; }
    [NotNullAttribute]
public LifetimeDefinition LifetimeDefinition { get; }
    [NotNullAttribute]
public IProperty`1<bool> IsPatternValid { get; }
    protected RegExpEditorSession(Lifetime lifetime, IShellLocks locks, string patternString, RegexOptions options, string inputString, ISolution solution, IPsiSourceFile sourceFile);
    public sealed virtual IDocument get_InputDocument();
    public sealed virtual IDocument get_PatternDocument();
    public sealed virtual Lifetime get_Lifetime();
    public sealed virtual RegularExpressionEditorViewModel get_ViewModel();
    public LifetimeDefinition get_LifetimeDefinition();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsPatternValid();
    private void InputDocumentChanged(object sender, EventArgs`1<DocumentChange> args);
    private void PatternDocumentChanged(object sender, EventArgs`1<DocumentChange> args);
    private bool CheckOption(RegexOptions option);
    public void UpdatePattern();
    public void UpdateInput();
    public void UpdateSelectedHighlighting();
    public void SetPatternTextWhenSolutionAvailable(Lifetime lifetime, string text, Action whenDone);
    private static IDocument CreateDocument(Lifetime lifetime, string text);
    public abstract virtual void Apply();
    public abstract virtual bool CanApply();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closed(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closed(Action value);
    public void Close();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_3();
    [CompilerGeneratedAttribute]
private void <UpdatePattern>b__30_0();
    [CompilerGeneratedAttribute]
private void <UpdateInput>b__31_0();
    [CompilerGeneratedAttribute]
private void <UpdateInput>b__31_4(Exception exception);
    [CompilerGeneratedAttribute]
private void <UpdateSelectedHighlighting>b__32_0();
}
public class JetBrains.ReSharper.Features.RegExp.Editor.Sessions.RegExpEditorSessionStandalone : RegExpEditorSession {
    public RegExpEditorSessionStandalone(Lifetime lifetime, IShellLocks locks, string pattern, string input, RegexOptions options);
    public virtual void Apply();
    public virtual bool CanApply();
}
internal class JetBrains.ReSharper.Features.RegExp.Editor.Sessions.RegExpRunner : object {
    private object myLocker;
    private Thread myCurrentThread;
    public RegExpRunner(Lifetime lifetime);
    public void Queue(string input, string pattern, RegexOptions options, bool checkLinesSeparately, Action`1<List`1<MatchViewModel>> resultProcessor, Action`1<Exception> errorProcessor);
    private static void Run(string input, string pattern, RegexOptions options, bool checkLinesSeparately, Action`1<List`1<MatchViewModel>> resultProcessor, Action`1<Exception> errorProcessor);
    private static void BuildViewModels(MatchCollection matches, Regex regex, List`1<MatchViewModel> matchesList, int offset);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0();
}
public class JetBrains.ReSharper.Features.RegExp.Editor.ViewModels.CaptureViewModel : CaptureViewModelBase {
    private string myGroupName;
    public string GroupName { get; }
    public CaptureViewModel(int num, Capture capture, int offset, string groupName);
    public virtual string get_GroupName();
}
public abstract class JetBrains.ReSharper.Features.RegExp.Editor.ViewModels.CaptureViewModelBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <ValueRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICaptureViewModel> <Children>k__BackingField;
    public string Name { get; }
    public string Value { get; }
    public TextRange ValueRange { get; }
    public IEnumerable`1<ICaptureViewModel> Children { get; }
    public string GroupName { get; }
    protected CaptureViewModelBase(string name, Capture capture, int offset, IEnumerable`1<ICaptureViewModel> children);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual TextRange get_ValueRange();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ICaptureViewModel> get_Children();
    public abstract virtual string get_GroupName();
}
public class JetBrains.ReSharper.Features.RegExp.Editor.ViewModels.GroupViewModel : CaptureViewModelBase {
    [CompilerGeneratedAttribute]
private string <GroupName>k__BackingField;
    public string GroupName { get; }
    public GroupViewModel(string groupName, Capture capture, int offset, IEnumerable`1<ICaptureViewModel> children);
    [CompilerGeneratedAttribute]
public virtual string get_GroupName();
}
public interface JetBrains.ReSharper.Features.RegExp.Editor.ViewModels.ICaptureViewModel {
    public string Name { get; }
    public string GroupName { get; }
    public string Value { get; }
    public TextRange ValueRange { get; }
    public IEnumerable`1<ICaptureViewModel> Children { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_GroupName();
    public abstract virtual string get_Value();
    public abstract virtual TextRange get_ValueRange();
    public abstract virtual IEnumerable`1<ICaptureViewModel> get_Children();
}
public class JetBrains.ReSharper.Features.RegExp.Editor.ViewModels.MatchViewModel : CaptureViewModelBase {
    public string GroupName { get; }
    public MatchViewModel(int num, Capture capture, int offset, IEnumerable`1<ICaptureViewModel> children);
    public virtual string get_GroupName();
}
public class JetBrains.ReSharper.Features.RegExp.Editor.ViewModels.OptionViewModel : ObservableObject {
    private bool myEnabled;
    private string myTitle;
    private RegexOptions myOption;
    private RegExpEditorSession mySession;
    private IconId myIcon;
    private DelegateCommand myInvertStateCommand;
    public IconId Icon { get; }
    public string Name { get; }
    public bool Enabled { get; public set; }
    public string Title { get; }
    public RegexOptions Option { get; }
    public DelegateCommand InvertStateCommand { get; }
    public OptionViewModel(RegExpEditorSession session, RegexOptions options, string title, IconId icon, RegexOptions option);
    public IconId get_Icon();
    public string get_Name();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public string get_Title();
    public RegexOptions get_Option();
    public DelegateCommand get_InvertStateCommand();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
}
public class JetBrains.ReSharper.Features.RegExp.Editor.ViewModels.RegularExpressionEditorViewModel : ObservableObject {
    private static IExpansionProvider ourExpansionProvider;
    private static IChildrenProvider ourChildrenProvider;
    private List`1<MatchViewModel> myMatches;
    private ICaptureViewModel mySelectedCapture;
    private string myState;
    private string myStateToolTip;
    private IEnumerable`1<OptionViewModel> myOptions;
    private RegExpEditorSession mySession;
    private bool myCheckLinesSeparately;
    private bool myCanCheckLinesSeparately;
    private DelegateCommand myApplyCommand;
    private DelegateCommand myCancelCommand;
    public DelegateCommand ApplyCommand { get; }
    public DelegateCommand CancelCommand { get; }
    public string CancelCommandText { get; }
    public List`1<MatchViewModel> Matches { get; public set; }
    public IExpansionProvider ExpansionProvider { get; }
    public IChildrenProvider ChildrenProvider { get; }
    public ICaptureViewModel SelectedCapture { get; public set; }
    public string State { get; public set; }
    public string StateToolTip { get; public set; }
    public bool IsStateToolTipVisible { get; }
    public IEnumerable`1<OptionViewModel> Options { get; }
    public bool CheckLinesSeparately { get; public set; }
    public bool CanCheckLinesSeparately { get; public set; }
    public RegularExpressionEditorViewModel(RegExpEditorSession session, RegexOptions options);
    private static RegularExpressionEditorViewModel();
    public DelegateCommand get_ApplyCommand();
    public DelegateCommand get_CancelCommand();
    public string get_CancelCommandText();
    public List`1<MatchViewModel> get_Matches();
    public void set_Matches(List`1<MatchViewModel> value);
    public IExpansionProvider get_ExpansionProvider();
    public IChildrenProvider get_ChildrenProvider();
    public ICaptureViewModel get_SelectedCapture();
    public void set_SelectedCapture(ICaptureViewModel value);
    public string get_State();
    public void set_State(string value);
    public string get_StateToolTip();
    public void set_StateToolTip(string value);
    public bool get_IsStateToolTipVisible();
    public IEnumerable`1<OptionViewModel> get_Options();
    public bool get_CheckLinesSeparately();
    public void set_CheckLinesSeparately(bool value);
    public bool get_CanCheckLinesSeparately();
    public void set_CanCheckLinesSeparately(bool value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__12_1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_2();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Editor.ZoneMarker : object {
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.Clr.ClrRegexQuantifierProblemAnalyzer : ElementProblemAnalyzer`1<IClrRegexQuantifier> {
    protected virtual void Run(IClrRegexQuantifier element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.Clr.RegexClrNumericQuantifierProblemAnalyzer : ElementProblemAnalyzer`1<IClrRegexNumericQuantifier> {
    protected virtual void Run(IClrRegexNumericQuantifier element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
    private static Nullable`1<int> ParseNumberQuantifierValue(IClrRegexNumber element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.Clr.RegexClrQuantifiableRegularExpressionProblemAnalyzer : ElementProblemAnalyzer`1<IClrQuantifiableRegularExpression> {
    protected virtual void Run(IClrQuantifiableRegularExpression element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.Clr.RegexClrSetRangeProblemAnalyzer : ElementProblemAnalyzer`1<IClrRegexSetRange> {
    protected virtual void Run(IClrRegexSetRange element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Highlightings.Clr.ZoneMarker : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Features.RegExp.Highlightings.CustomKeyHelper : object {
    private static Key`1<Action`3<ITreeNode, IHighlightingConsumer, string>> ourHighlightingActionKey;
    private static Key`1<Action`3<ITreeNode, IHighlightingConsumer, IHighlighting>> ourAddHighlightingActionKey;
    private static Key`1<Action`3<ITreeNode, string, IHighlightingConsumer>> ourErrorHighlightingActionKey;
    private static Key`1<HighlightingAttributeSelector> ourHighlightingAttributeSelectorActionKey;
    private static CustomKeyHelper();
    [ExtensionAttribute]
[NotNullAttribute]
public static Action`3<ITreeNode, IHighlightingConsumer, string> GetHighlightingAction(ElementProblemAnalyzerData data);
    [ExtensionAttribute]
[NotNullAttribute]
public static Action`3<ITreeNode, IHighlightingConsumer, IHighlighting> GetAddHighlightingAction(ElementProblemAnalyzerData data);
    [ExtensionAttribute]
[NotNullAttribute]
public static Action`3<ITreeNode, string, IHighlightingConsumer> GetErrorHighlightingAction(ElementProblemAnalyzerData data);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static HighlightingAttributeSelector GetHighlightingAttributeSelector(ElementProblemAnalyzerData data);
    [ExtensionAttribute]
public static void SetAddHighlightingAction(ElementProblemAnalyzerData data, Action`3<ITreeNode, IHighlightingConsumer, IHighlighting> ctx);
    [ExtensionAttribute]
public static void SetHighlightingAction(ElementProblemAnalyzerData data, Action`3<ITreeNode, IHighlightingConsumer, string> ctx);
    [ExtensionAttribute]
public static void SetErrorHighlightingAction(ElementProblemAnalyzerData data, Action`3<ITreeNode, string, IHighlightingConsumer> ctx);
    [ExtensionAttribute]
public static void SetHighlightingAttributeSelector(ElementProblemAnalyzerData data, HighlightingAttributeSelector ctx);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexClassChildWithDashProblemAnalyzer : ElementProblemAnalyzer`1<IRegexClassChildWithDash> {
    protected virtual void Run(IRegexClassChildWithDash element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexClassProblemAnalyzer : ElementProblemAnalyzer`1<IRegexClass> {
    protected virtual void Run(IRegexClass element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexCommentProblemAnalyzer : ElementProblemAnalyzer`1<IComment> {
    protected virtual void Run(IComment element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexDisjunctionOwnerProblemAnalyzer : ElementProblemAnalyzer`1<IRegexDisjunctionOwner> {
    protected virtual void Run(IRegexDisjunctionOwner element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexErrorNodeProblemAnalyzer : ElementProblemAnalyzer`1<IErrorElement> {
    protected virtual void Run(IErrorElement element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexEscapeCharacterProblemAnalyzer : ElementProblemAnalyzer`1<IRegexEscape> {
    protected virtual void Run(IRegexEscape element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexExtraQuestionProblemAnalyzer : ElementProblemAnalyzer`1<IRegexNodeWithQuestion> {
    protected virtual void Run(IRegexNodeWithQuestion element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexGroupNameProblemAnalyzer : ElementProblemAnalyzer`1<IRegexGroupName> {
    protected virtual void Run(IRegexGroupName element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexInvalidCharacterProblemAnalyzer : ElementProblemAnalyzer`1<IRegexInvalidCharacter> {
    protected virtual void Run(IRegexInvalidCharacter element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexParenthesizedGroupProblemAnalyzer : ElementProblemAnalyzer`1<IRegexParenthesesOwner> {
    protected virtual void Run(IRegexParenthesesOwner element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[RegisterStaticHighlightingsGroupAttribute("JetBrains.ReSharper.Features.RegExp.Resources.Strings", "RegularExpressionErrors_Text", "True")]
public static class JetBrains.ReSharper.Features.RegExp.Highlightings.RegExpErrors : object {
}
[RegisterHighlighterGroupAttribute("Regex", "Regexp", "6")]
[RegisterHighlighterAttribute("ReSharper Regex Invalid Character")]
[RegisterHighlighterAttribute("ReSharper Regex Set")]
[RegisterHighlighterAttribute("ReSharper Regex Group")]
[RegisterHighlighterAttribute("ReSharper Regex Identifier")]
[RegisterHighlighterAttribute("ReSharper Regex Quantifier")]
[RegisterHighlighterAttribute("ReSharper Regex Escape Character 1")]
[RegisterHighlighterAttribute("ReSharper Regex Escape Character 2")]
[RegisterHighlighterAttribute("ReSharper Regex Comment")]
[RegisterHighlighterAttribute("ReSharper Regex Matched Value")]
[RegisterHighlighterAttribute("ReSharper Regex Matched Selection")]
public static class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexpHighlightingAttributeIds : object {
    public static string INVALID_CHARACTER;
    public static string GROUP;
    public static string SET;
    public static string IDENTIFIER;
    public static string QUANTIFIER;
    public static string ESCAPE_CHARACTER_PRIMARY;
    public static string ESCAPE_CHARACTER_SECONDARY;
    public static string COMMENT;
    public static string MATCHED_VALUE;
    public static string MATCHED_SELECTION;
}
public abstract class JetBrains.ReSharper.Features.RegExp.Highlightings.RegExpHighlightingBase : object {
    private string JetBrains.ReSharper.Feature.Services.Daemon.IHighlighting.ToolTip { get; }
    private string JetBrains.ReSharper.Feature.Services.Daemon.IHighlighting.ErrorStripeToolTip { get; }
    private sealed virtual override string JetBrains.ReSharper.Feature.Services.Daemon.IHighlighting.get_ToolTip();
    private sealed virtual override string JetBrains.ReSharper.Feature.Services.Daemon.IHighlighting.get_ErrorStripeToolTip();
    public abstract virtual bool IsValid();
    private sealed virtual override DocumentRange JetBrains.ReSharper.Feature.Services.Daemon.IHighlighting.CalculateRange();
}
[ContainsContextConsumerAttribute]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Features.RegExp.Highlightings.RegExpMatchingBracesContextHighlighter : ContainingBracesContextHighlighterBase`1<RegexBaseLanguage> {
    [CanBeNullAttribute]
[AsyncContextConsumerAttribute]
public static Action ProcessDataContext(Lifetime lifetime, IPsiDocumentRangeView psiDocumentRangeView, InvisibleBraceHintManager invisibleBraceHintManager, MatchingBraceSuggester matchingBraceSuggester, MatchingBraceConsumerFactory consumerFactory, HighlightingProlongedLifetime prolongedLifetime);
    protected virtual void CollectHighlightings(IPsiView psiView, MatchingHighlightingsConsumer consumer);
}
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexpSettingsNamesProvider : PrefixBasedSettingsNamesProvider {
    public static string REGEXP_GROUP_PREFIX;
}
[StaticSeverityHighlightingAttribute("5", "JetBrains.ReSharper.Features.RegExp.Highlightings.RegExpErrors")]
public class JetBrains.ReSharper.Features.RegExp.Highlightings.RegExpSyntaxError : SyntaxErrorBase {
    public RegExpSyntaxError(string toolTip, DocumentRange range);
}
[StaticSeverityHighlightingAttribute("1", "JetBrains.ReSharper.Feature.Services.Daemon.HighlightingGroupIds/IdentifierHighlightings")]
[DaemonTooltipProviderAttribute("")]
public class JetBrains.ReSharper.Features.RegExp.Highlightings.RegExpSyntaxHighlighting : object {
    private DocumentRange myRange;
    [CompilerGeneratedAttribute]
private string <AttributeId>k__BackingField;
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public string AttributeId { get; }
    public RegExpSyntaxHighlighting(string attributeId, DocumentRange range);
    public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    [CompilerGeneratedAttribute]
public sealed virtual string get_AttributeId();
    public sealed virtual bool IsValid();
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual Nullable`1<int> GetStatisticsKey();
}
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Features.RegExp.Highlightings.RegexSpecialSymbolProblemAnalyzer : ElementProblemAnalyzer`1<IRegexSpecialSymbol> {
    protected virtual void Run(IRegexSpecialSymbol element, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Highlightings.ZoneMarker : object {
}
public abstract class JetBrains.ReSharper.Features.RegExp.IdentifierHighlighter`1 : object {
    [CompilerGeneratedAttribute]
private IRegexContainer <File>k__BackingField;
    [NotNullAttribute]
public IRegexContainer File { get; }
    protected IdentifierHighlighter`1(IRegexContainer file);
    [CompilerGeneratedAttribute]
public IRegexContainer get_File();
    protected abstract virtual TextRange GetTextRange(ITreeNode node);
    public void HighlightInFile(T consumer);
    protected abstract virtual void Highlight(ITreeNode node, T consumer, string highlightingAttributeId);
    protected abstract virtual void AddHighlighting(ITreeNode node, T consumer, IHighlighting highlighting);
    protected abstract virtual void HighlightError(ITreeNode node, string errorDescription, T consumer);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element, T context);
    public virtual bool IsProcessingFinished(T context);
    protected abstract virtual void VisitNode(ITreeNode node, T context);
    public virtual void ProcessBeforeInterior(ITreeNode element, T consumer);
    public virtual void ProcessAfterInterior(ITreeNode element, T consumer);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Features.RegExp.Injecting.ClrRegexInjectionProvider : LanguageInjectorProviderInLiteralsWithRangeMarkersBase`3<IClrRegularExpressionFile, IStringLiteralOwner, CSharpLiteralInjectionTarget> {
    public string ProvidedInjectionID { get; }
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public PsiLanguageType ProvidedLanguage { get; }
    public IconId Icon { get; }
    public ClrRegexInjectionProvider(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, InjectionNodeProvidersViewer providersViewer, CSharpLiteralInjectionTarget injectionTarget);
    public virtual string get_ProvidedInjectionID();
    public virtual PsiLanguageType get_SupportedOriginalLanguage();
    public virtual PsiLanguageType get_ProvidedLanguage();
    public virtual IconId get_Icon();
    protected virtual String[] GetCommentInjectionIDs();
    public virtual IBuffer CreateBuffer(ITreeNode originalNode, string text, object regexOptions);
    public virtual int GetStartOffset(ITreeNode originalNode);
    public virtual int GetEndOffset(ITreeNode originalNode);
}
public abstract class JetBrains.ReSharper.Features.RegExp.Injecting.NodeProviders.ClrRegexByAttributeNodeProvider : object {
    private string myAttributeShortNameTrimmed;
    private String[] myAttributes;
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public string ProvidedLanguageID { get; }
    public string Summary { get; }
    public string Description { get; }
    public string Guid { get; }
    public String[] Words { get; }
    public String[] Attributes { get; }
    protected string AttributeShortName { get; }
    protected string AttributeShortNameTrimmed { get; }
    public abstract virtual bool Check(ITreeNode node, ILiteralsInjectionDataProvider injectedContext, Object& data);
    public sealed virtual string GetPrefix(ITreeNode node, object data);
    public sealed virtual string GetSuffix(ITreeNode node, object data);
    public sealed virtual PsiLanguageType get_SupportedOriginalLanguage();
    public sealed virtual string get_ProvidedLanguageID();
    public sealed virtual string get_Summary();
    public virtual string get_Description();
    public abstract virtual string get_Guid();
    public sealed virtual String[] get_Words();
    public sealed virtual String[] get_Attributes();
    protected abstract virtual string get_AttributeShortName();
    protected string get_AttributeShortNameTrimmed();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Features.RegExp.Injecting.NodeProviders.ClrRegexByRegexPatternAttributeNodeProvider : ClrRegexByAttributeNodeProvider {
    [NotNullAttribute]
private RegexPatternAnnotationProvider myAnnotationProvider;
    public string Description { get; }
    public string Guid { get; }
    protected string AttributeShortName { get; }
    public ClrRegexByRegexPatternAttributeNodeProvider(CodeAnnotationsCache codeAnnotationsCache);
    public virtual bool Check(ITreeNode node, ILiteralsInjectionDataProvider injectedContext, Object& data);
    public virtual string get_Description();
    public virtual string get_Guid();
    protected virtual string get_AttributeShortName();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Features.RegExp.Injecting.NodeProviders.ClrRegexByStringSyntaxAttributeNodeProvider : ClrRegexByAttributeNodeProvider {
    [NotNullAttribute]
private StringSyntaxAnnotationProvider myStringSyntaxAnnotationProvider;
    public string Guid { get; }
    protected string AttributeShortName { get; }
    public ClrRegexByStringSyntaxAttributeNodeProvider(CodeAnnotationsCache codeAnnotationsCache);
    public virtual bool Check(ITreeNode node, ILiteralsInjectionDataProvider injectedContext, Object& data);
    public virtual string get_Guid();
    protected virtual string get_AttributeShortName();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Features.RegExp.Injecting.RegExpPsiProvider : LiteralsInjectionPsiProvider`2<CSharpLanguage, ClrRegexLanguage> {
    public bool ProvidedLanguageCanHaveNestedInjects { get; }
    public RegExpPsiProvider(ClrRegexInjectionProvider injectorProvider);
    public virtual bool get_ProvidedLanguageCanHaveNestedInjects();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Injecting.ZoneMarker : object {
}
[LanguageAttribute("JetBrains.ReSharper.Psi.RegExp.ClrRegex.ClrRegexLanguage", "16")]
public class JetBrains.ReSharper.Features.RegExp.Intellisense.ClrRegularExpressionCompletionProvider : object {
    public sealed virtual bool IsAtRegexStart(RegExpCodeCompletionContext context);
    public sealed virtual bool IsAtRegexEnd(RegExpCodeCompletionContext context);
    public sealed virtual bool IsInFlagsZone(RegExpCodeCompletionContext context);
    public sealed virtual bool InitializeContext(ITreeNode owner, ITreeNode file);
    public sealed virtual bool ValidateFinalNode(ITreeNode node);
    public sealed virtual bool ShouldPreserveRange(ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    public sealed virtual string GetReplacementText(ITreeNode owner, string text);
    public sealed virtual void AddStartStringAnchors(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddEndStringAnchors(ICollection`1<LookupItemContent> contents);
    public sealed virtual bool SkipFromCompletion(ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    public sealed virtual bool CanBeQuantifier(ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    public sealed virtual void AddAnchors(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddSets(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddGroups(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddComments(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddRegularCharacters(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddDotCharacters(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddEscapeCharacters(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddFlags(ICollection`1<LookupItemContent> contents);
    public sealed virtual void AddGroupParts(ICollection`1<LookupItemContent> contents);
    public sealed virtual bool IsLBracket(TokenNodeType t);
    public sealed virtual bool IsLParenth(TokenNodeType t);
    public sealed virtual bool IsTopLevelRegularExpression(ITreeNode containsNode);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.RegExp.BaseLanguage.RegexBaseLanguage", "16")]
public class JetBrains.ReSharper.Features.RegExp.Intellisense.Common.BasicDoubleItemsProvider : RegExpItemsProviderBase {
    public CompletionMode SupportedCompletionMode { get; }
    protected virtual bool IsAvailable(RegExpCodeCompletionContext specificContext);
    public virtual CompletionMode get_SupportedCompletionMode();
    protected virtual bool Process(ICollection`1<LookupItemContent> contents, ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    protected virtual TextLookupRanges FillContentCollection(RegExpCodeCompletionContext context, ICollection`1<LookupItemContent> contents, ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes, DocumentOffset caretOffset);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.RegExp.BaseLanguage.RegexBaseLanguage", "16")]
public class JetBrains.ReSharper.Features.RegExp.Intellisense.Common.BasicItemsProvider : RegExpItemsProviderBase {
    public CompletionMode SupportedCompletionMode { get; }
    protected virtual bool IsAvailable(RegExpCodeCompletionContext specificContext);
    public virtual CompletionMode get_SupportedCompletionMode();
    protected virtual bool Process(ICollection`1<LookupItemContent> contents, ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    protected virtual TextLookupRanges FillContentCollection(RegExpCodeCompletionContext context, ICollection`1<LookupItemContent> contents, ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes, DocumentOffset caretOffset);
}
public interface JetBrains.ReSharper.Features.RegExp.Intellisense.Common.IRegularExpressionCompletionProvider {
    public abstract virtual bool IsAtRegexStart(RegExpCodeCompletionContext context);
    public abstract virtual bool IsAtRegexEnd(RegExpCodeCompletionContext context);
    public abstract virtual bool IsInFlagsZone(RegExpCodeCompletionContext context);
    public abstract virtual bool InitializeContext(ITreeNode owner, ITreeNode file);
    public abstract virtual bool ValidateFinalNode(ITreeNode node);
    public abstract virtual bool ShouldPreserveRange(ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    public abstract virtual string GetReplacementText(ITreeNode owner, string text);
    public abstract virtual bool SkipFromCompletion(ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    public abstract virtual bool CanBeQuantifier(ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    public abstract virtual bool IsLBracket(TokenNodeType t);
    public abstract virtual bool IsLParenth(TokenNodeType t);
    public abstract virtual bool IsTopLevelRegularExpression(ITreeNode containsNode);
    public abstract virtual void AddStartStringAnchors(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddEndStringAnchors(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddAnchors(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddSets(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddGroups(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddGroupParts(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddComments(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddRegularCharacters(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddDotCharacters(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddEscapeCharacters(ICollection`1<LookupItemContent> contents);
    public abstract virtual void AddFlags(ICollection`1<LookupItemContent> contents);
}
public abstract class JetBrains.ReSharper.Features.RegExp.Intellisense.Common.RegExpItemsProviderBase : ItemsProviderOfSpecificContext`1<RegExpCodeCompletionContext> {
    protected IRegularExpressionCompletionProvider Service;
    protected abstract virtual bool Process(ICollection`1<LookupItemContent> contents, ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
    protected virtual bool AddLookupItems(RegExpCodeCompletionContext context, IItemsCollector collector);
    protected virtual TextLookupRanges FillContentCollection(RegExpCodeCompletionContext context, ICollection`1<LookupItemContent> contents, ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes, DocumentOffset caretOffset);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.RegExp.BaseLanguage.RegexBaseLanguage", "16")]
public class JetBrains.ReSharper.Features.RegExp.Intellisense.Common.SmartItemsProvider : RegExpItemsProviderBase {
    public CompletionMode SupportedCompletionMode { get; }
    protected virtual bool IsAvailable(RegExpCodeCompletionContext specificContext);
    public virtual CompletionMode get_SupportedCompletionMode();
    protected virtual bool Process(ICollection`1<LookupItemContent> contents, ITreeNode containsNode, ICollection`1<ITreeNode> leftNodes);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Features.RegExp.Intellisense.CSharpRegexCompletionProvider : object {
    public sealed virtual bool InitializeContext(ITreeNode owner, ITreeNode file);
    public sealed virtual string GetReplacementText(ITreeNode owner, string text);
}
public interface JetBrains.ReSharper.Features.RegExp.Intellisense.IRegexLanguageSpecificCompletionProvider {
    public abstract virtual bool InitializeContext(ITreeNode owner, ITreeNode file);
    public abstract virtual string GetReplacementText(ITreeNode owner, string text);
}
public class JetBrains.ReSharper.Features.RegExp.Intellisense.LookupItemContent : object {
    private RichText myCaption;
    private byte myPriority;
    private string myCaptionPattern;
    private string myText;
    private string myDescription;
    [CompilerGeneratedAttribute]
private int <CaretOffset>k__BackingField;
    public RichText Caption { get; }
    public string Text { get; }
    public int CaretOffset { get; }
    public byte Priority { get; }
    public LookupItemContent(string text, string description, byte priority, string captionPattern, int caretOffset);
    [NotNullAttribute]
public LookupItemContent ChangeCaretOffset(int offset);
    public RichText get_Caption();
    public string get_Text();
    [CompilerGeneratedAttribute]
public int get_CaretOffset();
    public byte get_Priority();
    private bool Equals(LookupItemContent other);
    public virtual int GetHashCode();
    [NotNullAttribute]
private static RichText PatternCaption(string pattern);
    public virtual bool Equals(object obj);
}
public static class JetBrains.ReSharper.Features.RegExp.Intellisense.LookupItemContentCollection : object {
    private static int MajorGroupPartPriority;
    private static int SecondaryGroupPartPriority;
    private static int SetPartPriority;
    private static int MajorStartAnchorPriority;
    private static int SecondaryStartAnchorPriority;
    private static int MajorEndAnchorPriority;
    private static int SecondaryEndAnchorPriority;
    private static int MajorQuantifierPriority;
    private static int MajorSetPriority;
    private static int MajorGroupPriority;
    private static int AlternationPriority;
    private static int WildcardPriority;
    private static int MajorRegularCharacterPriority;
    private static int SecondaryRegularCharacterPriority;
    private static int SecondaryAnchorPriority;
    private static int SecondarySetPriority;
    public static int SecondaryGroupPriority;
    private static int ConditionalGroupPriority;
    private static int SecondaryQuantifierPriority;
    public static int EscapeCharacterPriority;
    private static int CommentPriority;
    public static IEnumerable`1<LookupItemContent> CommonRegularCharacters;
    public static IEnumerable`1<LookupItemContent> RegularCharacters;
    public static IEnumerable`1<LookupItemContent> DotCharacters;
    public static IEnumerable`1<LookupItemContent> EscapeCharacters;
    public static IEnumerable`1<LookupItemContent> Comments;
    public static IEnumerable`1<LookupItemContent> CommonSets;
    public static IEnumerable`1<LookupItemContent> Sets;
    public static IEnumerable`1<LookupItemContent> CommonGroups;
    public static IEnumerable`1<LookupItemContent> Groups;
    public static IEnumerable`1<LookupItemContent> Quantifiers;
    public static IEnumerable`1<LookupItemContent> Anchors;
    public static LookupItemContent StartStringOrLineAnchor;
    public static IEnumerable`1<LookupItemContent> StartAnchors;
    public static LookupItemContent EndStringOrLineAnchor;
    public static IEnumerable`1<LookupItemContent> EndAnchors;
    public static LookupItemContent Alternation;
    public static IEnumerable`1<LookupItemContent> CommonGroupParts;
    public static IEnumerable`1<LookupItemContent> GroupParts;
    public static IEnumerable`1<LookupItemContent> SetParts;
    private static LookupItemContentCollection();
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Features.RegExp.Intellisense.RegExpAutomaticStrategy : object {
    private static JetHashSet`1<char> ourAccepterCharacters;
    public PsiLanguageType Language { get; }
    public bool ForceHideCompletion { get; }
    private static RegExpAutomaticStrategy();
    public sealed virtual AutopopupType IsEnabledInSettings(IContextBoundSettingsStore settingsStore, ITextControl textControl);
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual bool AcceptTyping(char c, ITextControl textControl, IContextBoundSettingsStore boundSettingsStore);
    public sealed virtual bool ProcessSubsequentTyping(char c, ITextControl textControl);
    public sealed virtual bool AcceptsFile(IFile file, ITextControl textControl);
    public sealed virtual bool get_ForceHideCompletion();
}
public class JetBrains.ReSharper.Features.RegExp.Intellisense.RegExpCodeCompletionContext : SpecificCodeCompletionContext {
    public string ContextId { get; }
    public RegExpCodeCompletionContext(CodeCompletionContext context);
    public virtual string get_ContextId();
}
[IntellisensePartAttribute("16")]
public class JetBrains.ReSharper.Features.RegExp.Intellisense.RegExpCodeCompletionContextProvider : CodeCompletionContextProviderBase {
    public virtual bool IsApplicable(CodeCompletionContext context);
    public virtual ISpecificCodeCompletionContext GetCompletionContext(CodeCompletionContext context);
}
[IntellisensePartAttribute("16")]
public class JetBrains.ReSharper.Features.RegExp.Intellisense.RegExpCompletingCharsProvider : CompletingCharsProviderBase`1<RegExpCodeCompletionContext> {
    private static JetHashSet`1<char> ourAcceptableCharacters;
    private static RegExpCompletingCharsProvider();
    protected virtual bool IsApplicable(RegExpCodeCompletionContext context);
    protected virtual CompletionAction IsCharacterAcceptable(char c, RegExpCodeCompletionContext context, IContextBoundSettingsStore settingsStore);
}
public class JetBrains.ReSharper.Features.RegExp.Intellisense.RegExpLookupItem : TextLookupItemBase {
    private LookupItemContent myLookupItemContent;
    private string myReplacementText;
    private int myMatchShift;
    public IconId Image { get; }
    public string Text { get; }
    public RegExpLookupItem(LookupItemContent lookupItemContent, string replacementText, int highlightMatchShift);
    public virtual IconId get_Image();
    public virtual string get_Text();
    public virtual MatchingResult Match(PrefixMatcher prefixMatcher);
    protected virtual RichText GetDisplayName();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.Intellisense.ZoneMarker : object {
}
public class JetBrains.ReSharper.Features.RegExp.QuickFixes.RemoveQuantifierFix : QuickFixBase {
    private IRegexTreeNode myQuantifier;
    public string Text { get; }
    public RemoveQuantifierFix(QuantifierFollowingNothingError error);
    public RemoveQuantifierFix(NestedQuantifierError error);
    public RemoveQuantifierFix(QuantifierAfterAnchorWarning warning);
    public virtual string get_Text();
    protected virtual Action`1<ITextControl> ExecutePsiTransaction(ISolution solution, IProgressIndicator progress);
    public virtual bool IsAvailable(IUserDataHolder cache);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.QuickFixes.ZoneMarker : object {
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Features.RegExp.RegexPatternSearcher : ValueType {
    private static String[] ourAttributeShortNames;
    [CanBeNullAttribute]
public ICSharpArgumentsOwner ContainingInvocation;
    [CanBeNullAttribute]
public ICSharpExpression OptionsArgumentExpression;
    public RegexOptions Options;
    private RegexPatternSearcher(ICSharpArgumentsOwner containingInvocation, ICSharpExpression optionsArgumentExpression, RegexOptions options);
    private static RegexPatternSearcher();
    public static Nullable`1<RegexPatternSearcher> TryCreate(IStringLiteralOwner stringLiteralOwner, RegexPatternAnnotationProvider annotationProvider);
    private static ValueTuple`2<ICSharpExpression, RegexOptions> TryFindOptionsArgument(ICSharpArgumentsOwner argumentsOwner);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Features.RegExp.RegExpExtensions : object {
    [ExtensionAttribute]
public static bool IsRegularExpressionPattern(IStringLiteralOwner stringLiteralOwner, RegexPatternAnnotationProvider annotationProvider);
    [ExtensionAttribute]
public static bool IsRegularExpressionPattern(IStringLiteralOwner stringLiteralOwner, RegexPatternAnnotationProvider annotationProvider, RegexOptions& options);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICSharpArgument GetArgument(TreeNodeCollection`1<ICSharpArgument> arguments, string name, int defaultPosition);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Features.RegExp.RegExpModificationUtil : object {
    [ExtensionAttribute]
public static void ReplaceUnderTransaction(IStringLiteralOwner stringLiteralOwner, string pattern, RegexOptions options);
    [ExtensionAttribute]
public static void Replace(IStringLiteralOwner stringLiteralOwner, string pattern, RegexOptions options);
    private static void ReplacePattern(IStringLiteralOwner stringLiteralOwner, CSharpElementFactory factory, string pattern);
    private static void ReplaceOptions(IStringLiteralOwner stringLiteralOwner, CSharpElementFactory factory, RegexOptions options);
    private static bool HasAnnotationInOverload(IFunction function, RegexPatternAnnotationProvider annotationProvider);
    private static ICSharpExpression CreateOptionsExpression(RegexOptions options, CSharpElementFactory factory, IDeclaredType type);
}
public static class JetBrains.ReSharper.Features.RegExp.RegExpPredefinedType : object {
    [NotNullAttribute]
public static IClrTypeName GROUP_COLLECTION_FQN;
    [NotNullAttribute]
public static IClrTypeName MATCH_FQN;
    [NotNullAttribute]
public static IClrTypeName REGEX_FQN;
    [NotNullAttribute]
public static IClrTypeName REGEX_OPTIONS_FQN;
    private static RegExpPredefinedType();
}
public class JetBrains.ReSharper.Features.RegExp.Resources.RegExpThemedIcons : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Features.RegExp.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string AnyCharacterExceptN_Text { get; }
    public static string ASCIICharacter_Text { get; }
    public static string BalancingGroupDefinition_Text { get; }
    public static string CharacterClassSubtraction_Text { get; }
    public static string ConditionalMatchingBasedOnACaptured_Text { get; }
    public static string ConditionalMatchingWithAnExpression_Text { get; }
    public static string ContiguousMatchesStartsOfPreviousMatch_Text { get; }
    public static string DecimalDigitCharacter_Text { get; }
    public static string EndOfStringOnly_Text { get; }
    public static string EndOfStringOrBeforeEndingNewline_Text { get; }
    public static string EndOfStringOrLine_Text { get; }
    public static string FixRegularExpression_Text { get; }
    public static string GroupName_Text { get; }
    public static string Group_Text { get; }
    public static string InlineComment_Text { get; }
    public static string MatchAtLeastNTimesAsFewTimesAsPossible_Text { get; }
    public static string MatchAtLeastNTimes_Text { get; }
    public static string MatchBetweenNAndMTimesAsFewTimesAsPossible_Text { get; }
    public static string MatchBetweenNAndMTimes_Text { get; }
    public static string MatchExactlyNTimesAsFewTimesAsPossible_Text { get; }
    public static string MatchExactlyNTimes_Text { get; }
    public static string MatchOneOrMoreTimesAsFewTimesAsPossible_Text { get; }
    public static string MatchOneOrMoreTimes_Text { get; }
    public static string MatchZeroOrMoreTimesAsFewTimesAsPossible_Text { get; }
    public static string MatchZeroOrMoreTimes_Text { get; }
    public static string MatchZeroOrOneTimeAsFewTimesAsPossible_Text { get; }
    public static string MatchZeroOrOneTime_Text { get; }
    public static string NamedBackreference_Text { get; }
    public static string NamedGroup_Text { get; }
    public static string NegativeCharacterGroup_Text { get; }
    public static string NegativeMarker_Text { get; }
    public static string NegativeUnicodeCategoryOrUnicodeBlock_Text { get; }
    public static string NewLine_Text { get; }
    public static string NonbacktrackingSubexpression_Text { get; }
    public static string NoncapturingGroup_Text { get; }
    public static string NonDigitCharacter_Text { get; }
    public static string NonWhiteSpaceCharacter_Text { get; }
    public static string NonWordBoundary_Text { get; }
    public static string NonWordCharacter_Text { get; }
    public static string Or_Text { get; }
    public static string PositiveCharacterGroup_Text { get; }
    public static string RangeOfCharacters_Text { get; }
    public static string RegularExpressionErrors_Text { get; }
    public static string RegexOption_EcmaScript_Description { get; }
    public static string RegexOption_IgnorePatternWhitespace_Description { get; }
    public static string RegexOption_Singleline_Description { get; }
    public static string RegexOption_CaseInsensitive_Description { get; }
    public static string RegexOption_ExplicitCapture_Description { get; }
    public static string RegexOption_RightToLeft_Description { get; }
    public static string RegexOption_CultureInvariant_Description { get; }
    public static string RegexOption_Compiled_Description { get; }
    public static string RegexOption_Multiline_Description { get; }
    public static string StartOfStringOnly_Text { get; }
    public static string StartOfStringOrLine_Text { get; }
    public static string Tab_Text { get; }
    public static string ToPrecompiledRegex_Text { get; }
    public static string CannotInsertRegularExpressionInTheDocument_Text { get; }
    public static string RemoveQuantifier_Text { get; }
    public static string SyntaxError_Text { get; }
    public static string CaptureGroupNumbersMustBeLessThanOrEqualToIntMaxValueMessage { get; }
    public static string IllegalxyWithXYMessage { get; }
    public static string MeaninglessQuantifierAfterAnAnchorMessage { get; }
    public static string NestedQuantifierMessage { get; }
    public static string QuantifierFollowingNothingMessage { get; }
    public static string RegularExpressionInspections { get; }
    public static string RegularExpressionLanguageInspections { get; }
    public static string UnicodeCategoryOrUnicodeBlock_Text { get; }
    public static string UTF16CodeUnit_Text { get; }
    public static string WhiteSpaceCharacter_Text { get; }
    public static string WordBoundary_Text { get; }
    public static string WordCharacter_Text { get; }
    public static string XYRangeInReverseOrderMessage { get; }
    public static string FixRegularExpressionContextAction_Description { get; }
    public static string FixRegularExpressionContextAction_Name { get; }
    public static string ToPrecompiledRegexObjectContextAction_Description { get; }
    public static string ToPrecompiledRegexObjectContextAction_Name { get; }
    public static string RegexpHighlighterGroup { get; }
    public static string ZeroWidthNegativeLookaheadAssertion_Text { get; }
    public static string ZeroWidthNegativeLookbehindAssertion_Text { get; }
    public static string ZeroWidthPositiveLookaheadAssertion_Text { get; }
    public static string ZeroWidthPositiveLookbehindAssertion_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_AnyCharacterExceptN_Text();
    public static string get_ASCIICharacter_Text();
    public static string get_BalancingGroupDefinition_Text();
    public static string get_CharacterClassSubtraction_Text();
    public static string get_ConditionalMatchingBasedOnACaptured_Text();
    public static string get_ConditionalMatchingWithAnExpression_Text();
    public static string get_ContiguousMatchesStartsOfPreviousMatch_Text();
    public static string get_DecimalDigitCharacter_Text();
    public static string get_EndOfStringOnly_Text();
    public static string get_EndOfStringOrBeforeEndingNewline_Text();
    public static string get_EndOfStringOrLine_Text();
    public static string get_FixRegularExpression_Text();
    public static string get_GroupName_Text();
    public static string get_Group_Text();
    public static string get_InlineComment_Text();
    public static string get_MatchAtLeastNTimesAsFewTimesAsPossible_Text();
    public static string get_MatchAtLeastNTimes_Text();
    public static string get_MatchBetweenNAndMTimesAsFewTimesAsPossible_Text();
    public static string get_MatchBetweenNAndMTimes_Text();
    public static string get_MatchExactlyNTimesAsFewTimesAsPossible_Text();
    public static string get_MatchExactlyNTimes_Text();
    public static string get_MatchOneOrMoreTimesAsFewTimesAsPossible_Text();
    public static string get_MatchOneOrMoreTimes_Text();
    public static string get_MatchZeroOrMoreTimesAsFewTimesAsPossible_Text();
    public static string get_MatchZeroOrMoreTimes_Text();
    public static string get_MatchZeroOrOneTimeAsFewTimesAsPossible_Text();
    public static string get_MatchZeroOrOneTime_Text();
    public static string get_NamedBackreference_Text();
    public static string get_NamedGroup_Text();
    public static string get_NegativeCharacterGroup_Text();
    public static string get_NegativeMarker_Text();
    public static string get_NegativeUnicodeCategoryOrUnicodeBlock_Text();
    public static string get_NewLine_Text();
    public static string get_NonbacktrackingSubexpression_Text();
    public static string get_NoncapturingGroup_Text();
    public static string get_NonDigitCharacter_Text();
    public static string get_NonWhiteSpaceCharacter_Text();
    public static string get_NonWordBoundary_Text();
    public static string get_NonWordCharacter_Text();
    public static string get_Or_Text();
    public static string get_PositiveCharacterGroup_Text();
    public static string get_RangeOfCharacters_Text();
    public static string get_RegularExpressionErrors_Text();
    public static string get_RegexOption_EcmaScript_Description();
    public static string get_RegexOption_IgnorePatternWhitespace_Description();
    public static string get_RegexOption_Singleline_Description();
    public static string get_RegexOption_CaseInsensitive_Description();
    public static string get_RegexOption_ExplicitCapture_Description();
    public static string get_RegexOption_RightToLeft_Description();
    public static string get_RegexOption_CultureInvariant_Description();
    public static string get_RegexOption_Compiled_Description();
    public static string get_RegexOption_Multiline_Description();
    public static string get_StartOfStringOnly_Text();
    public static string get_StartOfStringOrLine_Text();
    public static string get_Tab_Text();
    public static string get_ToPrecompiledRegex_Text();
    public static string get_CannotInsertRegularExpressionInTheDocument_Text();
    public static string get_RemoveQuantifier_Text();
    public static string get_SyntaxError_Text();
    public static string get_CaptureGroupNumbersMustBeLessThanOrEqualToIntMaxValueMessage();
    public static string get_IllegalxyWithXYMessage();
    public static string get_MeaninglessQuantifierAfterAnAnchorMessage();
    public static string get_NestedQuantifierMessage();
    public static string get_QuantifierFollowingNothingMessage();
    public static string get_RegularExpressionInspections();
    public static string get_RegularExpressionLanguageInspections();
    public static string get_UnicodeCategoryOrUnicodeBlock_Text();
    public static string get_UTF16CodeUnit_Text();
    public static string get_WhiteSpaceCharacter_Text();
    public static string get_WordBoundary_Text();
    public static string get_WordCharacter_Text();
    public static string get_XYRangeInReverseOrderMessage();
    public static string get_FixRegularExpressionContextAction_Description();
    public static string get_FixRegularExpressionContextAction_Name();
    public static string get_ToPrecompiledRegexObjectContextAction_Description();
    public static string get_ToPrecompiledRegexObjectContextAction_Name();
    public static string get_RegexpHighlighterGroup();
    public static string get_ZeroWidthNegativeLookaheadAssertion_Text();
    public static string get_ZeroWidthNegativeLookbehindAssertion_Text();
    public static string get_ZeroWidthPositiveLookaheadAssertion_Text();
    public static string get_ZeroWidthPositiveLookbehindAssertion_Text();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Features.RegExp.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
