[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Completion.CodeCompletionInsideStringItemsProvider : ItemsProviderOfSpecificContext`1<CSharpCodeCompletionContext> {
    protected virtual void TransformItems(CSharpCodeCompletionContext context, IItemsCollector collector);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.I18n.Services.CSharp.CSharpLocalizableManager : object {
    public sealed virtual Localizable IsLocalizable(IExpression expression);
    public sealed virtual bool ShouldAnalyzeVerbatimStrings(IContextBoundSettingsStore settingsStore);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.ComponentResourceManagerReferenceProvider : ResourceManagerReferenceProvider {
    public virtual bool HasReference(ICSharpArgument argument, IReferenceNameContainer names);
    protected virtual ReferenceCollection CreateArgumentReferences(ICSharpArgument argument, ICSharpExpression argumentValue, IInvocationInfo invocation, ParameterCandidateCheckResult parameterCandidateCheckResult);
    protected virtual bool OnTypeCandidate(string typeName);
    protected virtual bool OnMethodCandidate(string methodName);
    protected virtual ParameterCandidateCheckResult OnParameterCandidate(IInvocationInfo invocationInfo, ICSharpArgument argument);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpComponentReference : ComponentReference`2<ICSharpArgument, ICSharpExpression> {
    public bool CaseSensitive { get; }
    public CSharpComponentReference(ICSharpArgument owner, ICSharpExpression token, TreeTextRange withinRange);
    public virtual bool get_CaseSensitive();
    protected virtual string GetElementText();
    public virtual TreeTextRange GetTreeTextRange();
    protected virtual IReference BindToInternal(IDeclaredElement element, ISubstitution substitution);
    public virtual ISymbolTable GetCompletionSymbolTable();
    protected virtual IPsiSourceFile GetCodeFile();
}
public class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpComponentResourceReference : CSharpResourceReference {
    public CSharpComponentResourceReference(TreeTextRange withinRange, ICSharpArgument owner, ICSharpExpression token);
    protected virtual IReference BindToInternal(IDeclaredElement element, ISubstitution substitution);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpResourceReference : ResourceReference`2<ICSharpArgument, ICSharpExpression> {
    public CSharpResourceReference(TreeTextRange withinRange, ICSharpArgument owner, ICSharpExpression token);
    public virtual ICollection`1<IPsiSourceFile> FindResourceFiles();
    private static ICollection`1<IPsiSourceFile> PsiSourceFiles(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
private static ICSharpExpression GetInitializerExpression(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
private static ICSharpExpression GetInitializerFromField(IField field);
    [CanBeNullAttribute]
private static ICSharpExpression GetInitializerFromLocalVariable(ILocalVariable localVariable);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpWindowsResourceItemReference : CheckedReferenceBase`1<ICSharpArgument> {
    public bool HasMultipleNames { get; }
    public CSharpWindowsResourceItemReference(ICSharpArgument owner);
    public virtual bool get_HasMultipleNames();
    public virtual string GetName();
    public virtual HybridCollection`1<string> GetAllNames();
    public virtual TreeTextRange GetTreeTextRange();
    protected virtual string GetResourceFullName();
    public sealed virtual string GetDefaultName();
    public sealed virtual ICollection`1<IPsiSourceFile> FindResourceFiles();
    public virtual IAccessContext GetAccessContext();
    public virtual ISymbolFilter[] GetSymbolFilters();
    public sealed virtual ISymbolTable GetCompletionSymbolTable();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public static string GetResourceFullName(ICSharpArgument argument);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpWindowsResourceLoaderItemReference : CSharpWindowsResourceItemReference {
    public CSharpWindowsResourceLoaderItemReference(ICSharpArgument owner);
    protected virtual string GetResourceFullName();
    public virtual IReference BindTo(IDeclaredElement declaredElement, ISubstitution substitution);
    [CanBeNullAttribute]
public static IArgumentList GetConstructorArgumentList(ICSharpArgument argument);
    public static string GetResourceFullName(ICSharpArgument sharpArgument);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpWindowsResourceLoaderItemReferenceProvider : StringArgumentReferenceFactoryBase`2<ICSharpArgument, ICSharpExpression> {
    [LocalizableAttribute("False")]
private static String[] ourMethodNames;
    private static CSharpWindowsResourceLoaderItemReferenceProvider();
    protected virtual ReferenceCollection CreateArgumentReferences(ICSharpArgument argument, ICSharpExpression argumentValue, IInvocationInfo invocation, ParameterCandidateCheckResult parameterCandidateCheckResult);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpWindowsResourceLoaderItemReferenceProvider/<GetNamesFromArgumentValue>d__3")]
protected virtual IEnumerable`1<string> GetNamesFromArgumentValue(ICSharpArgument argument);
    protected virtual bool OnTypeCandidate(string typeName);
    protected virtual bool OnMethodCandidate(string methodName);
    protected virtual ParameterCandidateCheckResult OnParameterCandidate(IInvocationInfo invocationInfo, ICSharpArgument argument);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpWindowsResourceManagerReferenceProvider : StringArgumentReferenceFactoryBase`2<ICSharpArgument, ICSharpExpression> {
    private static IStructuralMatcher ourResourceManagerMatcher;
    [LocalizableAttribute("False")]
private static String[] ourMethodNames;
    private static CSharpWindowsResourceManagerReferenceProvider();
    protected virtual ReferenceCollection CreateArgumentReferences(ICSharpArgument argument, ICSharpExpression argumentValue, IInvocationInfo invocation, ParameterCandidateCheckResult parameterCandidateCheckResult);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.CSharpWindowsResourceManagerReferenceProvider/<GetNamesFromArgumentValue>d__4")]
protected virtual IEnumerable`1<string> GetNamesFromArgumentValue(ICSharpArgument argument);
    protected virtual bool OnTypeCandidate(string typeName);
    protected virtual bool OnMethodCandidate(string methodName);
    protected virtual ParameterCandidateCheckResult OnParameterCandidate(IInvocationInfo invocationInfo, ICSharpArgument argument);
    [NotNullAttribute]
private IStructuralMatcher GetResourceManagerMatcher(IExpression expression);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.DisplayNameAttributePropertyNameReferenceFactory : ResxAttributePropertyNameReferenceFactory {
    private static IClrTypeName AttributeClrName;
    private static HashSet`1<string> Names;
    private static DisplayNameAttributePropertyNameReferenceFactory();
    public virtual bool HasReference(ITreeNode element, IReferenceNameContainer names);
    protected virtual bool CheckPropertyNameIsApplicable(string name);
    protected virtual bool CanUseOldReferences(ITreeNode element, ReferenceCollection oldReferences);
    protected virtual ReferenceCollection CreateReferenceCollection(IProperty property, IPropertyAssignment propertyAssignment, ICSharpExpression expression);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.PropertyReference`1 : CheckedReferenceBase`1<ICSharpExpression> {
    private string myResourceTypePropertyName;
    protected I18nResolveErrorType ResoleErrorType { get; }
    public PropertyReference`1(ICSharpExpression expression, string resourceTypePropertyName);
    protected virtual I18nResolveErrorType get_ResoleErrorType();
    public virtual string GetName();
    public virtual TreeTextRange GetTreeTextRange();
    public sealed virtual string GetDefaultName();
    public sealed virtual ICollection`1<IPsiSourceFile> FindResourceFiles();
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public sealed virtual ISymbolTable GetCompletionSymbolTable();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual ResolveResultWithInfo GetResolveResult(ISymbolTable symbolTable, string referenceName);
    public virtual IAccessContext GetAccessContext();
    public virtual ISymbolFilter[] GetSymbolFilters();
    protected virtual bool IsValidAccessRights(AccessRights accessRights);
    [CanBeNullAttribute]
private IReference TryBindNameofExpression(CSharpElementFactory factory, string shortName);
    [CompilerGeneratedAttribute]
private bool <GetReferenceSymbolTable>b__10_0(Pair`2<string, AttributeValue> pair);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <GetReferenceSymbolTable>b__10_1(ISymbolInfo info);
    [CompilerGeneratedAttribute]
private bool <BindTo>b__11_0(Pair`2<string, AttributeValue> pair);
    [CompilerGeneratedAttribute]
private bool <BindTo>b__11_1(IPropertyAssignment node);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.PublicPropertyReference`1 : PropertyReference`1<T> {
    protected I18nResolveErrorType ResoleErrorType { get; }
    public PublicPropertyReference`1(ICSharpExpression expression, string resourceTypePropertyName);
    protected virtual I18nResolveErrorType get_ResoleErrorType();
    protected virtual bool IsValidAccessRights(AccessRights accessRights);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.ResourceFileFinder : object {
    private IStructuralMatcher myResourceManagerFromTypeMatcher;
    private IStructuralMatcher myResourceManagerFromBaseNameAndAssemblyMatcher;
    private IStructuralMatcher myResourceManagerFromBaseNameandExecutingAndAssemblyMatcher;
    public ResourceFileFinder(PsiLanguageType language);
    [CanBeNullAttribute]
public ICollection`1<IPsiSourceFile> FindResourceFiles(ICSharpExpression expression);
    private bool FindResourceFileFromType(ICSharpExpression expression, HashSet`1<IPsiSourceFile> files);
    private bool FindFromBaseNameAndAssembly(ICSharpExpression expression, HashSet`1<IPsiSourceFile> files);
    private static void FindResourceFiles(ICollection`1<IPsiSourceFile> files, string name, IProject project, TargetFrameworkId targetFrameworkId);
    private bool FindFromBaseNameAndExecutingAssembly(ICSharpExpression expression, HashSet`1<IPsiSourceFile> files);
    [NotNullAttribute]
private IStructuralMatcher GetResourceManagerFromTypeMatcher(IExpression expression);
    [NotNullAttribute]
private IStructuralMatcher GetResourceManagerFromBaseNameAndAssemblyMatcher(IExpression expression);
    [NotNullAttribute]
private IStructuralMatcher GetResourceManagerFromBaseNameAndExecutingAssemblyMatcher(IExpression expression);
    [CanBeNullAttribute]
private static IProject GetTypeModule(IDeclaredType type);
    [NotNullAttribute]
public static string GetEmbeddedResourceName(IPsiSourceFile sourceFile, IProjectFile projectFile);
    [NotNullAttribute]
public static string GetEmbeddedResourceName(IClassDeclaration classDeclaration);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.ResourceManagerReferenceProvider : StringArgumentReferenceFactoryBase`2<ICSharpArgument, ICSharpExpression> {
    [LocalizableAttribute("False")]
private static String[] ourMethodNames;
    private static ResourceManagerReferenceProvider();
    protected virtual ReferenceCollection CreateArgumentReferences(ICSharpArgument argument, ICSharpExpression argumentValue, IInvocationInfo invocation, ParameterCandidateCheckResult parameterCandidateCheckResult);
    protected virtual bool OnTypeCandidate(string typeName);
    protected virtual bool OnMethodCandidate(string methodName);
    protected virtual ParameterCandidateCheckResult OnParameterCandidate(IInvocationInfo invocationInfo, ICSharpArgument argument);
}
[ReferenceProviderFactoryAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.ResourceReferenceProviderFactory : object {
    private IShellLocks myShellLocks;
    [CompilerGeneratedAttribute]
private ISignal`1<IReferenceProviderFactory> <Changed>k__BackingField;
    public ISignal`1<IReferenceProviderFactory> Changed { get; }
    public ResourceReferenceProviderFactory(IShellLocks shellLocks);
    public sealed virtual IReferenceFactory CreateFactory(IPsiSourceFile sourceFile, IFile file, IWordIndex wordIndexForChecks);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<IReferenceProviderFactory> get_Changed();
}
public abstract class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.ResxAttributePropertyNameReferenceFactory : object {
    public sealed virtual ReferenceCollection GetReferences(ITreeNode element, ReferenceCollection oldReferences);
    public abstract virtual bool HasReference(ITreeNode element, IReferenceNameContainer names);
    protected abstract virtual bool CheckPropertyNameIsApplicable(string name);
    protected abstract virtual bool CanUseOldReferences(ITreeNode element, ReferenceCollection oldReferences);
    protected abstract virtual ReferenceCollection CreateReferenceCollection(IProperty property, IPropertyAssignment propertyAssignment, ICSharpExpression expression);
    protected virtual bool CheckExpressionIsApplicable(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.CustomReferences.ValidationAttributePropertyNameReferenceFactory : object {
    private static IClrTypeName ValidationAttribute;
    private static string ErrorMessageResourceName;
    private static ValidationAttributePropertyNameReferenceFactory();
    public sealed virtual ReferenceCollection GetReferences(ITreeNode element, ReferenceCollection oldReferences);
    private static ReferenceCollection CreateReferences(ITreeNode element);
    public sealed virtual bool HasReference(ITreeNode element, IReferenceNameContainer names);
}
[ConfigurableSeverityHighlightingAttribute("LocalizableElement", "CSHARP")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Daemon.Errors.LocalizableInterpolatedStringWarning : object {
    private string MESSAGE;
    public static string HIGHLIGHTING_ID;
    [CompilerGeneratedAttribute]
private IInterpolatedStringExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolTip>k__BackingField;
    public IInterpolatedStringExpression Expression { get; }
    public DocumentRange Range { get; }
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public LocalizableInterpolatedStringWarning(IInterpolatedStringExpression expression, DocumentRange range);
    [CompilerGeneratedAttribute]
public IInterpolatedStringExpression get_Expression();
    [CompilerGeneratedAttribute]
public DocumentRange get_Range();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual bool IsValid();
}
[ConfigurableSeverityHighlightingAttribute("LocalizableElement", "CSHARP")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Daemon.Errors.LocalizableStringWarning : object {
    private string MESSAGE;
    public static string HIGHLIGHTING_ID;
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolTip>k__BackingField;
    public ICSharpExpression Expression { get; }
    public DocumentRange Range { get; }
    public string ToolTip { get; }
    public string ErrorStripeToolTip { get; }
    public LocalizableStringWarning(ICSharpExpression expression, DocumentRange range);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public DocumentRange get_Range();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ToolTip();
    public sealed virtual string get_ErrorStripeToolTip();
    public sealed virtual DocumentRange CalculateRange();
    public sealed virtual bool IsValid();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.I18n.Services.CSharp.Daemon.ZoneMarker : object {
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.ElementFactoryService : ElementFactoryService {
    public virtual IExpression CreateByValue(ConstantValue value);
    public virtual IExpression CreateExpression(IPsiModule module, string format, Object[] args);
    public virtual object CreateAttribute(IPsiModule module, ITypeElement attributeType, AttributeValue[] values);
}
public static class JetBrains.ReSharper.I18n.Services.CSharp.InterpolatedStringExtractUtil : object {
    public static bool CanExtractInterpolation(IInterpolatedStringExpression interpolatedStringExpression);
    [NotNullAttribute]
public static string GetStringValue(IInterpolatedStringExpression interpolatedStringExpression);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.LocalizableManager : object {
    [NotNullAttribute]
public static IClrTypeName ComponentLocalizableAttribute;
    private static LocalizableManager();
    [PureAttribute]
public static Localizable IsLocalizable(ICSharpExpression expression);
    [PureAttribute]
public static Localizable IsLocalizable(ICSharpExpression expression, ICSharpExpression& localizableExpression);
    [PureAttribute]
public static Localizable IsLocalizable(ICSharpExpression expression, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems);
    [PureAttribute]
public static Localizable IsLocalizable(ICSharpExpression expression, ICSharpExpression& localizableExpression, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems);
    [PureAttribute]
public static Localizable IsLocalizable(ICSharpExpression expression, ICSharpExpression& localizableExpression, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems, LocalizationRequiredAnnotationProvider annotationProvider);
    [PureAttribute]
public static Localizable IsLocalizable(IDeclaredElement declaredElement);
    [PureAttribute]
public static Localizable IsLocalizable(IDeclaredElement declaredElement, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems);
    [PureAttribute]
public static Localizable IsLocalizable(IReference reference, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems, LocalizationRequiredAnnotationProvider annotationProvider);
    [PureAttribute]
public static Localizable IsLocalizable(IDeclaredElement declaredElement, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems, LocalizationRequiredAnnotationProvider annotationProvider);
    [PureAttribute]
private static Localizable IsLocalizableExpression(ICSharpExpression expression, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems, LocalizationRequiredAnnotationProvider annotationProvider);
    [PureAttribute]
private static Localizable GetLocalizableAttributeValue(IDeclaredElement element, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems, LocalizationRequiredAnnotationProvider annotationProvider);
    private static Localizable SaveResultToCache(IDeclaredElement owner, Localizable localizable, IDictionary`2<IDeclaredElement, Localizable> cacheLocalizableItems);
}
[SettingsKeyAttribute("JetBrains.ReSharper.I18n.Services.LocalizationProjectSettings", "JetBrains.ReSharper.I18n.Services.CSharp.Resources.Strings", "CLocalizationOptionsSettingDescription")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Options.CSharpLocalizationOptionsSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.I18n.Services.CSharp.Resources.Strings", "IgnoreVerbatimStringsSettingDescription")]
public bool DontAnalyseVerbatimStrings;
}
public static class JetBrains.ReSharper.I18n.Services.CSharp.Options.CSharpLocalizationOptionsSettingsAccessor : object {
    public static Expression`1<Func`2<CSharpLocalizationOptionsSettings, bool>> DontAnalyseVerbatimStrings;
    private static CSharpLocalizationOptionsSettingsAccessor();
}
[GlobalSettingsUpgraderAttribute("16")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Options.CSharpLocalizationOptionsUpgrader : SettingTablesUpgrader {
    public CSharpLocalizationOptionsUpgrader(ProductConfigurations productConfigurations);
    protected virtual void DoUpgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime, SettingsTableBase workspaceSettingsTable, SettingsTableBase globalSettingsTable);
}
[OptionsPageAttribute("CSharpLocalizationOptions", "Localization", "JetBrains.ReSharper.Feature.Services.Resx.Resources.Services118nThemedIcons/Localization")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Options.UI.CSharpLocallizationOptionPage : SimpleOptionsPage {
    public static string ID;
    public CSharpLocallizationOptionPage(Lifetime lifetime, OptionsSettingsSmartContext smartContext);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.I18n.Services.CSharp.Options.UI.ZoneMarker : object {
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.PsiService : PsiService {
    public PsiLanguageType LanguageType { get; }
    public virtual PsiLanguageType get_LanguageType();
    public virtual IExpression GetArgumentValue(IArgument argument);
    public virtual string GetRegionName(ITreeNode element);
    public virtual ITreeNode GetEndRegion(ITreeNode element);
    public virtual IType GetExpressionCompileType(IExpression expression);
    public virtual IInvocationInfo GetInvocationInfoByArgument(IArgument argument);
    public virtual IReference GetInvokedReference(IInvocationInfo invocationInfo);
    public virtual IArgument GetArgumentByValue(IExpression expression);
    public virtual IExpression GetAssignmentTarget(IExpression source);
    public virtual IExpression GetOperandThroughParenthesis(IExpression expression);
    public virtual ConstantValue GetStringLiteralConstantValue(IExpression expression);
    public virtual IExpression GetContainingParenthesizedExpression(IExpression expression);
    public virtual void SetAttribute(IDeclaration declaration, object attribute);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.ConvertArgumentToVerbatimStringFix : QuickFixBase {
    private ICSharpExpression myExpression;
    private IParameter myParameter;
    private string myText;
    private ICSharpLiteralWrapper myWrapper;
    public string Text { get; }
    public ConvertArgumentToVerbatimStringFix(LocalizableStringWarning error);
    public ConvertArgumentToVerbatimStringFix(LocalizableInterpolatedStringWarning error);
    private ConvertArgumentToVerbatimStringFix(ICSharpExpression expression);
    public virtual string get_Text();
    public virtual bool IsAvailable(IUserDataHolder cache);
    protected virtual Action`1<ITextControl> ExecutePsiTransaction(ISolution solution, IProgressIndicator progress);
    private void FixArgument(IEnumerable`1<ICSharpArgument> arguments, CSharpElementFactory factory);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.ConvertRegularInterpolationToVerbatimFix : QuickFixBase {
    [NotNullAttribute]
private IInterpolatedStringExpression myExpression;
    public string Text { get; }
    public ConvertRegularInterpolationToVerbatimFix(LocalizableInterpolatedStringWarning error);
    public virtual string get_Text();
    public virtual bool IsAvailable(IUserDataHolder cache);
    protected virtual Action`1<ITextControl> ExecutePsiTransaction(ISolution solution, IProgressIndicator progress);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.ConvertRegularStringToVerbatimFix : QuickFixBase {
    [CanBeNullAttribute]
private ICSharpLiteralExpression myExpression;
    [CanBeNullAttribute]
private ICSharpLiteralWrapper myWrapper;
    public string Text { get; }
    public ConvertRegularStringToVerbatimFix(LocalizableStringWarning error);
    public virtual string get_Text();
    protected virtual Action`1<ITextControl> ExecutePsiTransaction(ISolution solution, IProgressIndicator progress);
    public virtual bool IsAvailable(IUserDataHolder cache);
    private static bool DontAnalyseVerbatimStrings(ITreeNode context);
}
[CustomHighlightingActionProviderAttribute("JetBrains.ProjectModel.KnownProjectFileType")]
public class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.DisableProjectLocalizationActionProvider : DisableProjectLocalizationActionProviderBase {
    protected virtual ITreeNode GetContext(IHighlighting highlighting);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.errorsQuickFixRegistration : object {
    public IEnumerable`1<Type> Dependencies { get; }
    public sealed virtual IEnumerable`1<Type> get_Dependencies();
    public sealed virtual void Register(IQuickFixesRegistrar table);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.MarkDeclarationAsNonLocalizableFix : object {
    private ICSharpExpression myExpression;
    public MarkDeclarationAsNonLocalizableFix(LocalizableStringWarning error);
    public MarkDeclarationAsNonLocalizableFix(LocalizableInterpolatedStringWarning error);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.MarkDeclarationAsNonLocalizableFix/<CreateBulbItems>d__3")]
public sealed virtual IEnumerable`1<IntentionAction> CreateBulbItems();
    public sealed virtual bool IsAvailable(IUserDataHolder cache);
    [CanBeNullAttribute]
private static IBulbAction CreateBulbAction(IDeclaredElement declaredElement, string bulbText);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.MoveToResourceFix : QuickFixBase {
    [CanBeNullAttribute]
private ICSharpExpression myExpression;
    public string Text { get; }
    public bool IsReadOnly { get; }
    public MoveToResourceFix(LocalizableStringWarning error);
    public MoveToResourceFix(LocalizableInterpolatedStringWarning error);
    public virtual string get_Text();
    public sealed virtual bool get_IsReadOnly();
    public virtual bool IsAvailable(IUserDataHolder cache);
    protected virtual Action`1<ITextControl> ExecutePsiTransaction(ISolution solution, IProgressIndicator progress);
    public virtual void Execute(ISolution solution, ITextControl textControl);
    [NotNullAttribute]
private static ICollection`1<Pair`2<ISourceElement, IResourceExtractor>> GetSourceElements(IEnumerable`1<IResourceExtractor> extractors, ICSharpExpression expression);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.UseExistentResourceFix : object {
    private ICSharpExpression myExpression;
    [CompilerGeneratedAttribute]
private IBulbAction[] <Items>k__BackingField;
    public IBulbAction[] Items { get; }
    public UseExistentResourceFix(LocalizableStringWarning error);
    public UseExistentResourceFix(LocalizableInterpolatedStringWarning error);
    [CompilerGeneratedAttribute]
public IBulbAction[] get_Items();
    public sealed virtual IEnumerable`1<IntentionAction> CreateBulbItems();
    public sealed virtual bool IsAvailable(IUserDataHolder cache);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IBulbAction[] GetBulbItems(ITreeNode treeNode, string value);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.I18n.Services.CSharp.QuickFixes.ZoneMarker : object {
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.CSharpExpressionToResourceExtractor : ExpressionToResourceExtractor {
    public byte Priority { get; }
    public CSharpExpressionToResourceExtractor(ResourceAccessorFinder resourceAccessorFinder, ExpressionToResourceChecker expressionToResourceChecker);
    public virtual byte get_Priority();
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.CSharpResourceInliner : ResourceToExpressionInlinerBase`1<ICSharpExpression> {
    public byte Priority { get; }
    protected PsiLanguageType PsiLanguageType { get; }
    public virtual byte get_Priority();
    protected virtual PsiLanguageType get_PsiLanguageType();
    protected virtual ICSharpExpression CreateExpression(ConstantValue value, IPsiModule module);
    protected virtual ITreeNode GetElementToInline(IReference reference);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.DisplayNameAttributeResourceInliner : object {
    public byte Priority { get; }
    public sealed virtual byte get_Priority();
    public sealed virtual bool CanInline(IResourceItemDeclaredElement element);
    public sealed virtual bool CanInline(IReference reference, IResourceItemDeclaredElement element);
    public sealed virtual bool Inline(IReference reference, IResourceItemDeclaredElement element);
    private static void ResetCustomRererences(IAttribute attribute);
    public sealed virtual bool CanInline(ITreeNode sourceElement, IResourceItemDeclaredElement element);
    public sealed virtual bool Inline(ITreeNode sourceElement, IResourceItemDeclaredElement element);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.DisplayNameAttributeToResourceExtractor : ExpressionToResourceExtractorBase`1<ICSharpExpression> {
    private static IClrTypeName AttributeName;
    private static string ResourceType;
    public byte Priority { get; }
    public DisplayNameAttributeToResourceExtractor(ResourceAccessorFinder resourceAccessorFinder, ExpressionToResourceChecker expressionToResourceChecker);
    private static DisplayNameAttributeToResourceExtractor();
    public virtual byte get_Priority();
    public virtual bool IsAvailable(IDataContext context);
    public virtual ISourceElement GetSourceElement(ITreeNode node);
    public virtual string GetDefaultResourceName(ISourceElement sourceElement);
    public virtual bool CanExtractTo(ISourceElement sourceElement, IPsiSourceFile resourceFile);
    public virtual bool Extract(ISourceElement sourceElement, IResourceItem resourceItem, IRefactoringDriver driver);
    private bool FixResourceType(IAttribute oldAttribute, IAttribute attribute, SourceElement element);
    private static SourceElement GetParameterSourceElement(ExpressionSourceElement`1<ICSharpExpression> element, IClrTypeName attributeClrName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.DisplayNameAttributeToResourceExtractor/<GetNamedParameters>d__12")]
private static IEnumerable`1<Pair`2<string, AttributeValue>> GetNamedParameters(string propertyName, string resourceName, ITypeElement resourceClassType, IPsiModule psiModule);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.ErrorMessageFromValidationAttributeToResourceExtractor : ExpressionToResourceExtractorBase`1<ICSharpExpression> {
    private static string ValidationAttribute;
    private static string ErrorMessage;
    private static string ErrorMessageResourceType;
    private static string ErrorMessageResourceName;
    public byte Priority { get; }
    public ErrorMessageFromValidationAttributeToResourceExtractor(ResourceAccessorFinder resourceAccessorFinder, ExpressionToResourceChecker expressionToResourceChecker);
    public virtual byte get_Priority();
    public virtual bool IsAvailable(IDataContext context);
    public virtual ISourceElement GetSourceElement(ITreeNode node);
    public virtual string GetDefaultResourceName(ISourceElement sourceElement);
    public virtual bool CanExtractTo(ISourceElement sourceElement, IPsiSourceFile resourceFile);
    public virtual bool Extract(ISourceElement sourceElement, IResourceItem resourceItem, IRefactoringDriver driver);
    private static SourceElement GetParameterSourceElement(ExpressionSourceElement`1<ICSharpExpression> element, string attributeClrName, string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.ErrorMessageFromValidationAttributeToResourceExtractor/<GetNamedParameters>d__13")]
private static IEnumerable`1<Pair`2<string, AttributeValue>> GetNamedParameters(string propertyName, ITypeElement resourceClassType, IPsiModule psiModule);
}
public abstract class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.ExpressionToResourceExtractor : ExpressionToResourceExtractorBase`1<ICSharpExpression> {
    protected ExpressionToResourceExtractor(ResourceAccessorFinder resourceAccessorFinder, IResourceChecker resourceChecker);
    public virtual ISourceElement GetSourceElement(ITreeNode node);
    private static bool IsCustomAttributeValue(ICSharpExpression expression);
    protected virtual bool IsApplicable(IExpression expression);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.ExpressionToWindowsResourceExtractor : ExpressionToResourceExtractor {
    public byte Priority { get; }
    public ExpressionToWindowsResourceExtractor(ResourceAccessorFinder resourceAccessorFinder, ExpressionToWindowsResourceChecker expressionToWindowsResourceChecker);
    public virtual byte get_Priority();
    public virtual bool CanExtractTo(ISourceElement sourceElement, IPsiSourceFile resourceFile);
    public virtual bool Extract(ISourceElement sourceElement, IResourceItem resourceItem, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.InterpolatedStringSourceElement : ExpressionSourceElement`1<ICSharpExpression> {
    public InterpolatedStringSourceElement(IInterpolatedStringExpression expression);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.ValidationAttributeResourceInliner : object {
    public byte Priority { get; }
    public sealed virtual byte get_Priority();
    public sealed virtual bool CanInline(IResourceItemDeclaredElement element);
    public sealed virtual bool CanInline(IReference reference, IResourceItemDeclaredElement element);
    public sealed virtual bool Inline(IReference reference, IResourceItemDeclaredElement element);
    public sealed virtual bool CanInline(ITreeNode sourceElement, IResourceItemDeclaredElement element);
    public sealed virtual bool Inline(ITreeNode sourceElement, IResourceItemDeclaredElement element);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.I18n.Services.CSharp.Refactoring.ZoneMarker : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.I18n.Services.CSharp.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string CLocalizationOptionsSettingDescription { get; }
    public static string IgnoreVerbatimStringsSettingDescription { get; }
    public static string DonTAnalyseVerbatimStringsHelloWorld_Text { get; }
    public static string LocalizableInterpolatedStringMessage { get; }
    public static string LocalizableStringMessage { get; }
    public static string ConvertAllValuesOfParameterToVerbatim_Text { get; }
    public static string ConvertAllValuesOfParameter_ToVerbatim_Text { get; }
    public static string SearchingForUsagesOf__Text { get; }
    public static string UpdatingReferences_Text { get; }
    public static string Reference_Of__Text { get; }
    public static string ConvertToVerbatimInterpolation_Text { get; }
    public static string Annotate_WithLocalizableFalse_Text { get; }
    public static string MoveToResource_Text { get; }
    public static string Use__InsteadOfLiteral_Text { get; }
    public static string TheProperty_IsNotPublicResourceAccess_Text { get; }
    public static string ConvertToVerbatimString_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_CLocalizationOptionsSettingDescription();
    public static string get_IgnoreVerbatimStringsSettingDescription();
    public static string get_DonTAnalyseVerbatimStringsHelloWorld_Text();
    public static string get_LocalizableInterpolatedStringMessage();
    public static string get_LocalizableStringMessage();
    public static string get_ConvertAllValuesOfParameterToVerbatim_Text();
    public static string get_ConvertAllValuesOfParameter_ToVerbatim_Text();
    public static string get_SearchingForUsagesOf__Text();
    public static string get_UpdatingReferences_Text();
    public static string get_Reference_Of__Text();
    public static string get_ConvertToVerbatimInterpolation_Text();
    public static string get_Annotate_WithLocalizableFalse_Text();
    public static string get_MoveToResource_Text();
    public static string get_Use__InsteadOfLiteral_Text();
    public static string get_TheProperty_IsNotPublicResourceAccess_Text();
    public static string get_ConvertToVerbatimString_Text();
}
[ResourceAccessorsFinderAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Searching.CommonRessourceAccessorFinder : ResourceAccessorFinderBase`2<CSharpProjectFileType, CSharpLanguage> {
    public CommonRessourceAccessorFinder(GeneratedFileFinder generatedFileFinder, SearchDomainFactory searchDomainFactory);
    protected virtual IResourceAccessor CreateResourceAccessor(ITypeMember typeMember);
    protected virtual IArgument GetArgument(ITreeNode element);
    protected virtual IExpression GetArgumentValue(IArgument argument);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Searching.CSharpComponentReferenceSearcherSwitch : object {
}
[ResourceAccessorsFinderAttribute("16")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Searching.CSharpGeneratedResourceAccessorFinder : object {
    private GeneratedFileFinder myGeneratedFileFinder;
    [NotNullAttribute]
[LocalizableAttribute("False")]
private JetHashSet`1<string> mySupportedCustomTools;
    public CSharpGeneratedResourceAccessorFinder(GeneratedFileFinder generatedFileFinder);
    public sealed virtual IEnumerable`1<IResourceAccessor> FindAccessors(IResourceItemDeclaredElement element, IEnumerable`1<IResourceAccessor> accessors);
    public sealed virtual IEnumerable`1<ITypeElement> FindTypeElements(IPsiSourceFile resourceFile);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.Searching.CSharpResourceReferenceSearcher : object {
    private IDeclaredElementsSet myElements;
    private ICollection`1<string> myWordsInFiles;
    private ICollection`1<string> myNames;
    private ReferenceSearcherParameters myReferenceSearcherParameters;
    public CSharpResourceReferenceSearcher(IDeclaredElementsSet elements, ICollection`1<string> wordsInFiles, ICollection`1<string> names, ReferenceSearcherParameters referenceSearcherParameters);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
}
[PsiComponentAttribute("16")]
internal class JetBrains.ReSharper.I18n.Services.CSharp.Searching.CSharpResourceReferenceSearcherFactory : DomainSpecificSearcherFactoryBase {
    private SearchDomainFactory mySearchDomainFactory;
    public CSharpResourceReferenceSearcherFactory(SearchDomainFactory searchDomainFactory);
    public virtual bool IsCompatibleWithLanguage(PsiLanguageType languageType);
    public virtual ISearchDomain GetDeclaredElementSearchDomain(IDeclaredElement declaredElement);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.I18n.Services.CSharp.Searching.CSharpResourceReferenceSearcherFactory/<GetAllPossibleWordsInFile>d__4")]
public virtual IEnumerable`1<string> GetAllPossibleWordsInFile(IDeclaredElement element);
    public virtual IDomainSpecificSearcher CreateReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
}
internal class JetBrains.ReSharper.I18n.Services.CSharp.Searching.CSharpResourceUsagesByArgumentSearcher : object {
    private IWordIndex myWordIndex;
    private CSharpResourceUsagesByByArgumentSearcherFactory myFactory;
    private GeneratedFileFinder myGeneratedFileFinder;
    private IDeclaredElementsSet`1<IResourceItemDeclaredElement> myElements;
    private IReferenceNameContainer myNames;
    private bool mySearchLateBound;
    public CSharpResourceUsagesByArgumentSearcher(CSharpResourceUsagesByByArgumentSearcherFactory factory, GeneratedFileFinder generatedFileFinder, IDeclaredElementsSet`1<IResourceItemDeclaredElement> elements, bool searchLateBound);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    private FindExecution ProcessReference(IReference reference, IFindResultConsumer`1<TResult> consumer);
    private FindExecution CommitReference(IReference reference, IFindResultConsumer`1<TResult> consumer, Func`2<IDeclaredElement, FindResult> createFindResult);
    protected virtual bool CanContainReferencesTo(IPsiSourceFile sourceFile);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Searching.CSharpResourceUsagesByByArgumentSearcherFactory : DomainSpecificSearcherFactoryBase {
    private GeneratedFileFinder myGeneratedFileFinder;
    private SearchDomainFactory mySearchDomainFactory;
    [LocalizableAttribute("False")]
private JetHashSet`1<string> myMethods;
    public ICollection`1<string> Methods { get; }
    public CSharpResourceUsagesByByArgumentSearcherFactory(GeneratedFileFinder generatedFileFinder, SearchDomainFactory searchDomainFactory);
    public ICollection`1<string> get_Methods();
    public virtual bool IsCompatibleWithLanguage(PsiLanguageType languageType);
    public virtual ISearchDomain GetDeclaredElementSearchDomain(IDeclaredElement declaredElement);
    public virtual IEnumerable`1<string> GetAllPossibleWordsInFile(IDeclaredElement element);
    public virtual IDomainSpecificSearcher CreateReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    public virtual IDomainSpecificSearcher CreateLateBoundReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Services.ExpressionToResourceChecker : object {
    private GeneratedFileFinder myGeneratedFileFinder;
    public ExpressionToResourceChecker(GeneratedFileFinder generatedFileFinder);
    public sealed virtual bool CanUseResource(IPsiSourceFile resourceFile, IAccessContext context);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.I18n.Services.CSharp.Services.ExpressionToWindowsResourceChecker : object {
    public sealed virtual bool CanUseResource(IPsiSourceFile resourceFile, IAccessContext context);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.I18n.Services.CSharp.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
