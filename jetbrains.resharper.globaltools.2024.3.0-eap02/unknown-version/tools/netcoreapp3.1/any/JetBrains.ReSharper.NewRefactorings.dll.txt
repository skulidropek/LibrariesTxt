public class BlockerConstraint : ConstraintBase {
    private static BlockerConstraint myInstance;
    public bool IsBlocker { get; }
    public static BlockerConstraint Instance { get; }
    private static BlockerConstraint();
    public virtual bool get_IsBlocker();
    public static BlockerConstraint get_Instance();
}
public class DeclaredElementConstraint : ConstraintBase {
    private IDeclaredElement myElement;
    public bool IsBlocker { get; }
    public IEnumerable`1<IDeclaredElement> ConstraintElements { get; }
    public DeclaredElementConstraint(IDeclaredElement element);
    public virtual bool get_IsBlocker();
    public virtual IEnumerable`1<IDeclaredElement> get_ConstraintElements();
}
[ActionGroupAttribute("0", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.IntoRefactorContextMenuGroup : object {
    public IntoRefactorContextMenuGroup(IntoRefactorGroup refactorConvertActionGroup);
}
[ActionGroupAttribute("0", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.IntoRefactorContextualGroup : object {
    public IntoRefactorContextualGroup(RefactorThisAction refactorThisAction, RefactorContextMenu refactorContextMenu);
}
[ActionGroupAttribute("2", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.IntoRefactorFilesActionGroup : object {
    public IntoRefactorFilesActionGroup(MoveAction moveAction, SafeDeleteAction safeDeleteAction, MoveIntoMatchingFilesAction moveIntoMatchingFilesAction, AdjustNamespacesAction adjustNamespacesAction, RenameAction renameAction);
}
[ActionGroupAttribute("0", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.IntoRefactorGroup : object {
    public IntoRefactorGroup(RenameAction renameAction, SafeDeleteAction safeDeleteAction, MoveAction moveAction, ChangeSignatureAction changeSignatureAction, EncapsulateFieldAction encapsulateFieldAction, CopyTypeAction copyTypeAction, Separator sep1, IntroVariableAction introVariableAction, IntroduceFieldAction introFieldAction, IntroduceParameterAction introParameterAction, Separator sep2, RefactorExtractActionGroup refactorExtractActionGroup, RefactorInlineActionGroup refactorInlineActionGroup, Separator sep3, PullUpAction pullUpAction, PushDownAction pushDownAction, Type2PartialAction type2PartialAction, MakeStaticAction makeStaticAction, MakeNonStaticAction makeNonStaticAction, UseBaseTypeAction useBaseTypeAction, InvertBoolAction invertBoolAction, Separator sep4, MoveIntoMatchingFilesAction moveIntoMatchingFilesAction, AdjustNamespacesAction adjustNamespacesAction, Separator sep5, RefactorConvertActionGroup refactorConvertActionGroup);
}
[ActionGroupAttribute("0", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.IntoRefactorMemberActionGroup : object {
    public IntoRefactorMemberActionGroup(RenameAction renameAction, ChangeSignatureAction changeSignatureAction, SafeDeleteAction safeDeleteAction, MakeStaticAction makeStaticAction, MakeNonStaticAction makeNonStaticAction, ExtractInterfaceAction extractInterfaceAction, ExtractSuperclassAction extractSuperclassAction, PullUpAction pullUpAction, PushDownAction pushDownAction, Type2PartialAction type2Partial, Function2PropertyAction function2PropertyAction, Property2FunctionAction property2FunctionAction, Static2ExtensionAction static2ExtensionAction, Property2AutoAction property2AutoAction, TransformParametersAction transformOutParametersAction, InvertBoolAction invertBoolAction);
}
[ActionGroupAttribute("0", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.IntoRefactorMenuGroup : object {
    public IntoRefactorMenuGroup(RefactorThisAction refactorThisAction, IntoRefactorGroup refactorConvertActionGroup);
}
[ActionGroupAttribute("0", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.IntoRefactorTypeActionGroup : object {
    public IntoRefactorTypeActionGroup(RenameAction renameAction, MoveAction moveAction, CopyTypeAction copyTypeAction, SafeDeleteAction safeDeleteAction, ExtractInterfaceAction extractInterfaceAction, ExtractSuperclassAction extractSuperclassAction, UseBaseTypeAction useBaseTypeAction, PullUpAction pullUpAction, PushDownAction pushDownAction, Type2PartialAction type2PartialAction, Abstract2InterfaceAction abstract2InterfaceAction, Interface2AbstractAction interface2AbstractAction, Anonymous2DeclaredAction anonymous2DeclaredAction);
}
[ActionGroupAttribute("Refactor.Convert", "1", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.RefactorConvertActionGroup : object {
    public RefactorConvertActionGroup(Function2PropertyAction function2PropertyAction, Property2FunctionAction property2FunctionAction, Function2IndexerAction function2IndexerAction, Indexer2FunctionAction indexer2FunctionAction, Abstract2InterfaceAction abstract2InterfaceAction, Interface2AbstractAction interface2AbstractAction, Static2ExtensionAction static2ExtensionAction, Extension2StaticAction extension2StaticAction, SetParamsModifierAction collection2ParamsAction, RemoveParamsModifierAction params2CollectionAction, Constructor2FactoryAction constructor2FactoryAction, TransformParametersAction transformOutParametersAction, Property2AutoAction property2AutoAction, Anonymous2DeclaredAction anonymous2DeclaredAction);
}
[ActionGroupAttribute("Refactor.Extract", "1", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.RefactorExtractActionGroup : object {
    public RefactorExtractActionGroup(ExtractMethodAction extractMethodAction, ExtractInterfaceAction extractInterfaceAction, ExtractSuperclassAction extractSuperclassAction);
}
[ActionGroupAttribute("Refactor.Inline", "1", "10")]
public class JetBrains.ReSharper.Refactorings.Actions.RefactorInlineActionGroup : object {
    public RefactorInlineActionGroup(InlineAction inlineAction);
}
public abstract class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Anonymous2Declared : RefactoringExecBase`2<Anonymous2DeclaredWorkflow, Anonymous2DeclaredRefactoring> {
    protected Anonymous2Declared(Anonymous2DeclaredWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual IList`1<ITreeNode> SearchForAnonymousTypes(SubProgressIndicator pi);
    public abstract virtual ITypeElement CreateClassDeclaration(IList`1<ITypeParameter> usedTypeParameters, ISubstitution& substitution);
    public abstract virtual void ChangeReference(ITreeNode element, ITypeElement targetType, ISubstitution substitution);
    public abstract virtual IList`1<ITypeParameter> GetUsagedTypeParameters();
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "AnonymousToNamedTypeActionText")]
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Anonymous2DeclaredAction : ExtensibleRefactoringAction`1<IAnonymous2DeclaredWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Anonymous2DeclaredPage : SingleBeRefactoringPage {
    private BeGrid myContent;
    private Anonymous2DeclaredWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <PlaceTopLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <SearchInAllSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanGenerateRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <GenerateRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <GenerateMutableProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <GenerateHashcode>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <GenerateToString>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <ShowInFindresults>k__BackingField;
    public IProperty`1<string> Name { get; }
    public IProperty`1<bool> PlaceTopLevel { get; }
    public IProperty`1<bool> SearchInAllSolution { get; }
    public bool CanGenerateRecord { get; }
    public IProperty`1<bool> GenerateRecord { get; }
    public IProperty`1<bool> GenerateMutableProperties { get; }
    public IProperty`1<bool> GenerateHashcode { get; }
    public IProperty`1<bool> GenerateToString { get; }
    public IProperty`1<bool> ShowInFindresults { get; }
    public string Description { get; }
    public string Title { get; }
    public string PageDescription { get; }
    public Anonymous2DeclaredPage(Anonymous2DeclaredWorkflow workflow);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_Name();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_PlaceTopLevel();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_SearchInAllSolution();
    [CompilerGeneratedAttribute]
public bool get_CanGenerateRecord();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_GenerateRecord();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_GenerateMutableProperties();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_GenerateHashcode();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_GenerateToString();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_ShowInFindresults();
    public virtual string get_Description();
    public virtual string get_Title();
    public virtual string get_PageDescription();
    public virtual void Commit();
    public virtual BeControl GetPageContent();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Anonymous2DeclaredProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Anonymous2DeclaredRefactoring : DrivenRefactoring`2<Anonymous2DeclaredWorkflow, Anonymous2Declared> {
    public Anonymous2DeclaredRefactoring(Anonymous2DeclaredWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    protected virtual Anonymous2Declared CreateUnsupportedRefactoring();
    public virtual bool Execute(IProgressIndicator pi);
    private void ReplaceReferences(IList`1<ITreeNode> elements, ITypeElement namedType, ISubstitution substitution, IProgressIndicator pi);
    protected virtual Anonymous2Declared CreateRefactoringInternal(InternalRefactoringLanguageService service);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.Refactorings.RefactoringsMruSettings", "JetBrains.ReSharper.Refactorings.Resources.Strings", "AnonymousToDeclaredTypeRefactoringMRUSettingDescription")]
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Anonymous2DeclaredSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "PlaceTopLevelSettingDescription")]
public bool PlaceTopLevel;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "SearchInAllSolutionSettingDescription")]
public bool SearchInAllSolution;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "GenerateRecordTypeSettingDescription")]
public bool GenerateRecord;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "PropertiesKindSettingDescription")]
public bool GenerateMutableProperties;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "GenerateHashcodeSettingDescription")]
public bool GenerateHashcode;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "GenerateToStringSettingDescription")]
public bool GenerateToString;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "ShowInFindResultsSettingDescription")]
public bool ShowInFindResults;
}
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Anonymous2DeclaredWorkflow : DrivenRefactoringWorkflow {
    private ITreeNodePointer`1<ITreeNode> myCreationExpressionPointer;
    [CompilerGeneratedAttribute]
private Anonymous2DeclaredDataModel <DataModel>k__BackingField;
    [CompilerGeneratedAttribute]
private Anonymous2DeclaredDataProvider <DataProvider>k__BackingField;
    [CanBeNullAttribute]
public ITreeNode ObjectCreationElement { get; }
    public Anonymous2DeclaredDataModel DataModel { get; private set; }
    public Anonymous2DeclaredDataProvider DataProvider { get; public set; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public Anonymous2DeclaredWorkflow(ISolution solution, string actionId);
    public ITreeNode get_ObjectCreationElement();
    [CompilerGeneratedAttribute]
public Anonymous2DeclaredDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(Anonymous2DeclaredDataModel value);
    [CompilerGeneratedAttribute]
public sealed virtual Anonymous2DeclaredDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DataProvider(Anonymous2DeclaredDataProvider value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    private static bool IsAvailable(IDataContext context, ITreeNode& objectCreationElement);
    public virtual bool Initialize(IDataContext context);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
}
public interface JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.IAnonymous2DeclaredWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Model.Anonymous2DeclaredDataModel : object {
    [CompilerGeneratedAttribute]
private ITreeNode <ObjectCreationElement>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PlaceTopLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SearchInAllSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMutableProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateToString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateHashСode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IReferencePointer> <ChangedReferences>k__BackingField;
    public ITreeNode ObjectCreationElement { get; }
    public string TypeName { get; }
    public bool PlaceTopLevel { get; }
    public bool SearchInAllSolution { get; }
    public bool GenerateRecord { get; }
    public bool GenerateMutableProperties { get; }
    public bool GenerateToString { get; }
    public bool GenerateHashСode { get; }
    public List`1<IReferencePointer> ChangedReferences { get; }
    public Anonymous2DeclaredDataModel(Anonymous2DeclaredDataProvider provider, ITreeNode creationElement);
    [CompilerGeneratedAttribute]
public ITreeNode get_ObjectCreationElement();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public bool get_PlaceTopLevel();
    [CompilerGeneratedAttribute]
public bool get_SearchInAllSolution();
    [CompilerGeneratedAttribute]
public bool get_GenerateRecord();
    [CompilerGeneratedAttribute]
public bool get_GenerateMutableProperties();
    [CompilerGeneratedAttribute]
public bool get_GenerateToString();
    [CompilerGeneratedAttribute]
public bool get_GenerateHashСode();
    [CompilerGeneratedAttribute]
public List`1<IReferencePointer> get_ChangedReferences();
}
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Model.Anonymous2DeclaredDataProvider : object {
    [CompilerGeneratedAttribute]
private bool <PlaceTopLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SearchInAllSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanGenerateRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMutableProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateToString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowInFindResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    public bool PlaceTopLevel { get; }
    public bool SearchInAllSolution { get; }
    public bool CanGenerateRecord { get; }
    public bool GenerateRecord { get; }
    public bool GenerateMutableProperties { get; }
    public bool GenerateHashCode { get; }
    public bool GenerateToString { get; }
    public bool ShowInFindResults { get; }
    public string Name { get; }
    public bool NonInteractive { get; }
    public Anonymous2DeclaredDataProvider(ITreeNode creationExpression, bool hasUI);
    public Anonymous2DeclaredDataProvider(bool placeTopLevel, bool searchInAllSolution, bool generateRecord, bool generateMutableProperties, bool generateHashCode, bool generateToString, bool showInFindResults, string name, bool hasUI);
    [CompilerGeneratedAttribute]
public bool get_PlaceTopLevel();
    [CompilerGeneratedAttribute]
public bool get_SearchInAllSolution();
    [CompilerGeneratedAttribute]
public bool get_CanGenerateRecord();
    [CompilerGeneratedAttribute]
public bool get_GenerateRecord();
    [CompilerGeneratedAttribute]
public bool get_GenerateMutableProperties();
    [CompilerGeneratedAttribute]
public bool get_GenerateHashCode();
    [CompilerGeneratedAttribute]
public bool get_GenerateToString();
    [CompilerGeneratedAttribute]
public bool get_ShowInFindResults();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NonInteractive();
}
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Search.AnotypeUsageSearchDescriptor : SearchDescriptor {
    public AnotypeUsageSearchDescriptor(SearchRequest request);
    public virtual string GetResultsTitle(OccurrenceSection section);
    protected virtual Func`2<SearchRequest, IOccurrenceBrowserDescriptor> GetDescriptorFactory();
}
public class JetBrains.ReSharper.Refactorings.Anotype2DeclaredType.Search.AnotypeUsageSearchRequest : SearchRequest {
    private List`1<IOccurrence> myOccurrences;
    private IReference myReference;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    public string Title { get; }
    public ISolution Solution { get; }
    public ICollection SearchTargets { get; }
    public AnotypeUsageSearchRequest(ISolution solution);
    public void AddOccurrence(IReference reference, ISolution solution);
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public virtual ISolution get_Solution();
    public virtual ICollection get_SearchTargets();
    public virtual ICollection`1<IOccurrence> Search(IProgressIndicator progressIndicator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Refactorings.ChangeSignature.AddParameterFixBase : object {
    [NullableAttribute("2")]
protected IReference Reference;
    [NullableContextAttribute("2")]
protected AddParameterFixBase(IReference reference);
    public sealed virtual bool IsAvailable(IUserDataHolder cache);
    public sealed virtual IEnumerable`1<IntentionAction> CreateBulbItems();
    protected abstract virtual IInvocationInfo MakeArgumentsOwnerCopy(IInvocationInfo argumentsOwner);
    [NullableContextAttribute("2")]
protected abstract virtual IInvocationInfo GetInvocation();
    protected abstract virtual bool RemoveArgument(IInvocationInfo argumentsOwnerCopy, IArgumentInfo argumentInfo);
    protected abstract virtual ParameterKind ParameterKindFromArgument(IArgumentInfo argument);
    protected abstract virtual ITreeNode GetArgumentNode(IArgumentInfo argumentInfo);
    protected abstract virtual IParameter FindMatchingParameter(IArgumentInfo argumentInfo, IArgumentInfo removedArgumentInfo, IParametersOwner targetParametersOwner);
    protected virtual string GetNamedArgumentName(IArgumentInfo argumentInfo);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ChangeSignature.AddParameterFixBase/<FindPossibleTargets>d__11")]
private IEnumerable`1<TargetInfo> FindPossibleTargets();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ChangeSignature.AddParameterFixBase/<ResolveWithArgumentRemoved>d__12")]
private IEnumerable`1<ValueTuple`2<IParametersOwner, IInvocationInfo>> ResolveWithArgumentRemoved(IInvocationInfo argumentsOwner, int index);
    protected virtual bool IsSingleMatching(ResolveResultWithInfo resolveResultWithInfo);
    protected virtual ITypeConversionRule GetTypeConversionRule(ITreeNode node);
    protected virtual bool ParametersOwnerIsSuitableToAddParameter(IParametersOwner parametersOwner, IInvocationInfo argumentsOwner);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private AddParameterAction <CreateBulbItems>b__3_0(TargetInfo targetInfo);
}
public abstract class JetBrains.ReSharper.Refactorings.ChangeSignature.ChangeSignature : object {
    public abstract virtual bool IsAvailable(IParametersOwner owner);
    public abstract virtual ClrChangeSignatureModel CreateModel(IParametersOwner owner, IProgressIndicator progressIndicator);
    public abstract virtual ClrChangeSignatureModel CreateModel(IParametersOwner parametersOwner, ChangeSignatureFixNode fix, IProgressIndicator progressIndicator);
    public abstract virtual void ChangeDeclaration(IDeclaration declaration, IList`1<IDeclaration> parameterDeclarations, ClrChangeSignatureModel changeSignatureModel, ISubstitution substitution, List`1<ArgumentLikeInfo> postActionsList);
    public abstract virtual void CreateProxy(ClrChangeSignatureModel changeSignatureModel, List`1<ArgumentLikeInfo> postActionsList);
    public abstract virtual IParametersOwner AddDefaultConstructorDeclaration(IConstructor defaultConstructor);
    public abstract virtual IParameterDeclaration CreateParameterDeclaration(IPsiModule module, string name, IType type, ParameterKind parameterKind, bool isParams, bool isVarArg, IDeclaration originalDeclaration, bool isThis, IParameterValue defaultValue, ClrChangeSignatureModel changeSignatureModel);
    public abstract virtual bool IsExtensionCallReference(IReference reference);
    [CanBeNullAttribute]
public abstract virtual Dictionary`2<int, int> GetArgumentToParameterMapping(IReference reference, bool isExtensionCall, IArgumentsOwner owner);
    public abstract virtual IExpression CreateExpression(string text, ITreeNode context);
    public abstract virtual IExpression CreateReferenceExpression(string name, ITreeNode context);
    public abstract virtual IExpression CreateThisExpression(ITreeNode context);
    [CanBeNullAttribute]
public virtual IExpression TryCreateDiscardExpression(ITreeNode context);
    public abstract virtual void BindReferenceExpression(IExpression expression, IDeclaredElement element);
    public abstract virtual bool IsLocalEqualToFieldOrAutoProperty(ITypeMember fieldOrProperty, IDeclaredElement local, ITreeNode place);
    [CanBeNullAttribute]
public abstract virtual ILocalVariable DeclareLocalOutVariable(string variableName, IType variableType, IExpression& beforeExpression, IElementsSet elementsToKeep);
    public virtual bool IsIgnoredInternal(ITreeNode element);
    public void ProcessDefaultConstructor(IConstructor constructor, ClrChangeSignatureModel model, List`1<ArgumentLikeInfo> postActions);
    protected abstract virtual void ChangeDefaultConstructor(IConstructor inheritorConstructor, ClrChangeSignatureModel model, List`1<ArgumentLikeInfo> postActions);
    public virtual void ChangeReference(ClrChangeSignatureModel changeSignatureModel, RebindableReference rebindableReference, List`1<ArgumentLikeInfo> postActionsList);
    [CanBeNullAttribute]
public abstract virtual ISignatureUsage CreateSignatureUsage(ClrChangeSignatureModel changeSignatureModel, RebindableReference rebindableReference);
    public virtual void ProcessImplicitReferences(IDeclaration declaration, Action`1<IReference> referenceHandler);
    public virtual void MaterializeReferenceIfNeeded(RebindableReference rebindableReference, ClrChangeSignatureModel model);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "ChangeSignatureActionText")]
[VsOverrideActionAttribute("({1496A755-94DE-11D0-8C3F-00C04FC2AAE2}:1556)")]
public class JetBrains.ReSharper.Refactorings.ChangeSignature.ChangeSignatureAction : ExtensibleRefactoringAction`1<IChangeSignatureWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
    public sealed virtual bool ShouldFallBack(IDataContext context);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.ChangeSignatureHierarchyConflictTextProvider : HierarchyConflictTextProviderBase {
    public virtual string WillAlsoOverride();
    public virtual string WillAlsoImplement();
    public virtual string QuasiImplements();
}
public abstract class JetBrains.ReSharper.Refactorings.ChangeSignature.ChangeSignatureModel`1 : object {
    protected List`1<TParameter> myAddedSignatureParameters;
    protected List`1<TParameter> myChangeSignatureParameters;
    [CompilerGeneratedAttribute]
private bool <HasRemovedSignatureParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReturnTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreateProxyMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasRecursiveCalls>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredElementType <Type>k__BackingField;
    public TParameter[] ChangeSignatureParameters { get; }
    public IEnumerable`1<TParameter> AddedSignatureParameters { get; }
    public bool HasRemovedSignatureParameters { get; protected set; }
    public string ReturnTypeName { get; public set; }
    public string CreateProxyMessage { get; protected set; }
    public bool CreateProxy { get; public set; }
    public string Name { get; public set; }
    public PsiLanguageType Language { get; }
    public IDeclaredElement ParametersOwner { get; }
    public IModuleReferenceResolveContext ResolveContext { get; }
    public bool HasRecursiveCalls { get; public set; }
    public DeclaredElementType Type { get; protected set; }
    public TParameter[] get_ChangeSignatureParameters();
    public IEnumerable`1<TParameter> get_AddedSignatureParameters();
    [CompilerGeneratedAttribute]
public bool get_HasRemovedSignatureParameters();
    [CompilerGeneratedAttribute]
protected void set_HasRemovedSignatureParameters(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_ReturnTypeName();
    [CompilerGeneratedAttribute]
public virtual void set_ReturnTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_CreateProxyMessage();
    [CompilerGeneratedAttribute]
protected void set_CreateProxyMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_CreateProxy();
    [CompilerGeneratedAttribute]
public void set_CreateProxy(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual IDeclaredElement get_ParametersOwner();
    public virtual IModuleReferenceResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasRecursiveCalls();
    [CompilerGeneratedAttribute]
public void set_HasRecursiveCalls(bool value);
    [CompilerGeneratedAttribute]
public DeclaredElementType get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(DeclaredElementType value);
    public int GetNewIndex(int parameterIndex);
    public int GetIndex(TParameter changeSignatureParameter);
    [CanBeNullAttribute]
public virtual string GetParameterKindDescription(ParameterKind kind, bool nullIfNotSupported, bool isParams, bool isVarArg, bool isThis, bool isOptional);
    [CanBeNullAttribute]
public virtual string GetParameterModifierString(ParameterKind kind, bool isParams, bool isVarArg, bool isThis);
    public abstract virtual string GetPreview();
    public virtual bool CanChangeSignature();
    public virtual bool CanHaveParameters();
    public abstract virtual string GetDefaultValue(ChangeSignatureParameter parameter);
    public abstract virtual bool IsDefaultValueApplicable(DefaultParameterChoice defaultParameterChoice, ChangeSignatureParameter parameter);
    public virtual bool IsDefaultValueRequired(ChangeSignatureParameter parameter);
    public virtual bool CanChangeType();
    public virtual bool CanChangeName();
    public virtual bool IsValidExpression(string expr);
    public sealed virtual int Add(int index);
    protected abstract virtual TParameter CreateNewInstance(int index);
    public sealed virtual bool CanBeAddedAt(int index);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void MoveTo(int oldParameterIndex, int newParameterIndex);
    public sealed virtual void MoveUp(int parameterIndex);
    public sealed virtual void MoveDown(int parameterIndex);
    public virtual bool CanMoveUp(int index);
    public virtual bool CanMoveDown(int index);
    public virtual ValueTuple`2<string, ValidationStates> ValidateTypeName(string text, bool isParameter);
}
public abstract class JetBrains.ReSharper.Refactorings.ChangeSignature.ChangeSignatureParameter : object {
    [CompilerGeneratedAttribute]
private int <OriginalParameterIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OriginalIsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PassNonDefaultRecursively>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateParameterDefaultValue>k__BackingField;
    public int OriginalParameterIndex { get; protected set; }
    public string OriginalParameterName { get; protected set; }
    public bool OriginalIsParams { get; protected set; }
    public string TypeName { get; public set; }
    public int ParameterIndex { get; }
    public string ParameterName { get; public set; }
    public bool PassNonDefaultRecursively { get; public set; }
    public bool GenerateParameterDefaultValue { get; public set; }
    public Nullable`1<bool> ShouldUseParameterDefault { get; }
    protected ChangeSignatureParameter(int index);
    protected ChangeSignatureParameter(IParameter parameter);
    [CompilerGeneratedAttribute]
public int get_OriginalParameterIndex();
    [CompilerGeneratedAttribute]
protected void set_OriginalParameterIndex(int value);
    [CompilerGeneratedAttribute]
public string get_OriginalParameterName();
    [CompilerGeneratedAttribute]
protected void set_OriginalParameterName(string value);
    [CompilerGeneratedAttribute]
public bool get_OriginalIsParams();
    [CompilerGeneratedAttribute]
protected void set_OriginalIsParams(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_TypeName();
    [CompilerGeneratedAttribute]
public virtual void set_TypeName(string value);
    public abstract virtual int get_ParameterIndex();
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public bool get_PassNonDefaultRecursively();
    [CompilerGeneratedAttribute]
public void set_PassNonDefaultRecursively(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateParameterDefaultValue();
    [CompilerGeneratedAttribute]
public void set_GenerateParameterDefaultValue(bool value);
    public virtual Nullable`1<bool> get_ShouldUseParameterDefault();
    public abstract virtual void SetDefault(DefaultParameterChoice choice, string value);
    public abstract virtual IArgumentsOwner GetCallPreview(IArgumentsOwner node, object argumentValue, bool addFake);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ChangeSignature.ChangeSignatureProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.ChangeSignatureRefactoring : object {
    [CompilerGeneratedAttribute]
private ClrChangeSignatureModel <model>P;
    private CompositeConflictSearcher myChangeSignatureConflictSearcher;
    private List`1<ArgumentLikeInfo> myPostActions;
    public ChangeSignatureRefactoring(ClrChangeSignatureModel model);
    public static bool IsAvailable(IParametersOwner parametersOwner);
    public IConflictSearcher GetConflictSearcher();
    public void Execute(IProgressIndicator pi);
    private void ChangeParametersOwner(IParametersOwner parametersOwner, ISubstitution substitution, IList`1<IDeclaration> parameterDeclarations, List`1<ArgumentLikeInfo> postActions);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.ChangeSignatureRefactoringWorkflow : RefactoringWorkflowBase {
    private ChangeSignatureRefactoring myRefactoring;
    private ClrChangeSignatureModel myChangeSignatureModel;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IChangeSignatureTestData <Data>k__BackingField;
    public PsiLanguageType LanguageType { get; private set; }
    public string ActionId { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public IconId Icon { get; }
    public string Title { get; }
    public IConflictSearcher ConflictSearcher { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public bool HasUI { get; }
    public HelpId HelpKeyword { get; }
    public IChangeSignatureTestData Data { get; public set; }
    public ChangeSignatureRefactoringWorkflow(ISolution solution);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    public virtual string get_ActionId();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IconId get_Icon();
    public virtual string get_Title();
    public virtual IConflictSearcher get_ConflictSearcher();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    private IRefactoringPage BuildDefaultValuePagesSequence(IProgressIndicator pi);
    public virtual bool get_MightModifyManyDocuments();
    public virtual bool IsAvailable(IDataContext context);
    [CanBeNullAttribute]
private static IParametersOwner GetParametersOwner(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual bool get_HasUI();
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public IChangeSignatureTestData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(IChangeSignatureTestData value);
    public virtual bool PreExecute(IProgressIndicator taskExecutorCreator);
    public virtual bool Execute(IProgressIndicator progressIndicator);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
}
public abstract class JetBrains.ReSharper.Refactorings.ChangeSignature.ClrChangeSignatureModel : ChangeSignatureModel`1<ClrChangeSignatureParameter> {
    private IDeclaredElementPointer`1<IParametersOwner> myParametersOwner;
    private List`1<IElementInstancePointer`1<IParametersOwner>> myAllParametersOwners;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    private ITypePointer myReturnType;
    private string myReturnTypeName;
    private IDeclaration myTypeResolutionPoint;
    [CompilerGeneratedAttribute]
private ITypeValidator <TypeValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<OriginalParameter> <OriginalParameters>k__BackingField;
    private List`1<RebindableReference> mySignatureReferences;
    private List`1<RebindableReference> myDynamicSignatureReferences;
    protected List`1<ChangeSignatureFixNode> myFixes;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PullParameterSession> <Sessions>k__BackingField;
    [CanBeNullAttribute]
public IPsiSourceFile SourceFile { get; }
    protected ITypeValidator TypeValidator { get; }
    public List`1<OriginalParameter> OriginalParameters { get; }
    public IEnumerable`1<RebindableReference> SignatureReferences { get; }
    public IEnumerable`1<RebindableReference> DynamicSignatureReferences { get; }
    public ICollection`1<ChangeSignatureFixNode> Fixes { get; }
    public PsiLanguageType Language { get; }
    public string ReturnTypeName { get; public set; }
    public ICollection`1<KeyValuePair`2<IParametersOwner, ISubstitution>> AllParametersOwners { get; }
    public bool IsValid { get; }
    public List`1<PullParameterSession> Sessions { get; }
    public IDeclaredElement ParametersOwner { get; }
    public IModuleReferenceResolveContext ResolveContext { get; }
    public ITreeNode TypeResolutionPoint { get; }
    protected ClrChangeSignatureModel(IParametersOwner parametersOwner, bool isClone, IProgressIndicator progressIndicator, ITypeValidator typeValidator);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
protected ITypeValidator get_TypeValidator();
    [CompilerGeneratedAttribute]
public List`1<OriginalParameter> get_OriginalParameters();
    public IEnumerable`1<RebindableReference> get_SignatureReferences();
    public IEnumerable`1<RebindableReference> get_DynamicSignatureReferences();
    public ICollection`1<ChangeSignatureFixNode> get_Fixes();
    [CompilerGeneratedAttribute]
public virtual PsiLanguageType get_Language();
    public virtual string get_ReturnTypeName();
    public virtual void set_ReturnTypeName(string value);
    public ICollection`1<KeyValuePair`2<IParametersOwner, ISubstitution>> get_AllParametersOwners();
    public bool get_IsValid();
    [CompilerGeneratedAttribute]
public List`1<PullParameterSession> get_Sessions();
    public virtual IDeclaredElement get_ParametersOwner();
    public virtual IModuleReferenceResolveContext get_ResolveContext();
    public ITreeNode get_TypeResolutionPoint();
    public bool NeedsToRearrangeArgumentsOnCallSite(bool allowToRemoveParameters, bool allowToOmitNewOptionalParameters);
    public virtual string PresentType(IType value, PsiLanguageType psiLanguageType, ITreeNode treeNode);
    public virtual bool CanMoveUp(int index);
    public virtual bool CanMoveDown(int index);
    public void UpdateIndices(List`1<int> modelParameterToDesiredIndex);
    private void FindDeclarations(IProgressIndicator progressIndicator);
    public virtual string GetDefaultValue(ChangeSignatureParameter parameter);
    public virtual bool IsDefaultValueApplicable(DefaultParameterChoice defaultParameterChoice, ChangeSignatureParameter clrParameter);
    public virtual bool CanChangeType();
    public virtual bool CanChangeName();
    public bool CanHaveOutOrRefParameters();
    public virtual bool IsValidExpression(string expr);
    private void AddOverrider(FindResultOverridableMember found);
    private static IDeclaration GetTypeResolutionPoint(IParametersOwner parametersOwner);
    public void SetBaseReturnType(IType value);
    public IType GetReturnType(ISubstitution substitution);
    [CanBeNullAttribute]
public static ClrChangeSignatureModel CreateModel(IParametersOwner parametersOwner, ChangeSignatureFixNode fix, IProgressIndicator progressIndicator);
    [CanBeNullAttribute]
public static ClrChangeSignatureModel CreateModel(IParametersOwner parametersOwner, IProgressIndicator progressIndicator);
    public abstract virtual bool ConflictsWithOtherInstance(TypeMemberInstance typeMemberInstance);
    [CanBeNullAttribute]
public abstract virtual IList`1<IDeclaration> BuildParameters(IParametersOwner parametersOwner, ISubstitution substitution);
    public sealed virtual string ToString();
    public bool HasUnsafeTypes();
    protected virtual bool IsUnsafeType(IType type);
    public virtual bool HasHandler(IMethod method);
    public virtual string PresentDefaultValue(IParameter value);
    public void ChangeReference(RebindableReference rebindableReference, List`1<ArgumentLikeInfo> postActionsList);
    public void ChangeRecursiveReference(IReference reference, List`1<ArgumentLikeInfo> postActionsList);
    public bool CheckNeedsDefaultValuesForNewParameters(IProgressIndicator progressIndicator);
    private void FindReferences(IProgressIndicator progressIndicator, Action`1<IReference> referenceHandler);
    protected virtual bool Contains(IDeclaration declaration, ITreeNode refElement);
    public void FindReferences(IProgressIndicator progressIndicator);
    public void InitializeFixes();
    public void ReloadFixes();
    public static IEnumerable`1<DeclaredElementInstance`1<ITypeOwner>> GetSuitableVariables(ITreeNode context, IType type);
    private static void FilterOutUninitializedLocals(List`1<DeclaredElementInstance`1<ITypeOwner>> suitableVariables);
    private static void FilterOutPropertyWithBackingField(List`1<DeclaredElementInstance`1<ITypeOwner>> variables);
    private static void FilterOutFieldOrAutoPropertyInitializedFromLocalOrParameter(List`1<DeclaredElementInstance`1<ITypeOwner>> variables, ITreeNode context);
    protected virtual ClrChangeSignatureParameter CreateNewInstance(int index);
    public void ShowToolWindow(ISolution solution);
    public virtual ValueTuple`2<string, ValidationStates> ValidateTypeName(string text, bool isParameter);
    [CompilerGeneratedAttribute]
private bool <NeedsToRearrangeArgumentsOnCallSite>g__CanOmitRemainingParameters|43_0(int index, <>c__DisplayClass43_0& );
    [CompilerGeneratedAttribute]
private FindExecution <FindDeclarations>b__48_0(FindResult result);
    [CompilerGeneratedAttribute]
private bool <HasUnsafeTypes>b__64_0(ClrChangeSignatureParameter changeSignatureParameter);
    [CompilerGeneratedAttribute]
private void <FindReferences>b__73_0(IReference reference);
    [CompilerGeneratedAttribute]
private bool <FindReferences>g__IsInternalTo|73_1(IDeclaredElement element, ITreeNode refElement);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.ClrChangeSignatureParameter : ChangeSignatureParameter {
    private ClrChangeSignatureModel myModel;
    private ITypePointer myOriginalType;
    private ITypePointer myParameterType;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    private string myTypeName;
    [CompilerGeneratedAttribute]
private bool <IsVarArg>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsThis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaration <ParameterDeclarationCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterValue <SelectedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterKind <ParameterKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaration <ParameterDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private Property`1<string> <ParameterModifierString>k__BackingField;
    public bool IsParams { get; public set; }
    public string TypeName { get; public set; }
    public int ParameterIndex { get; }
    public bool IsVarArg { get; public set; }
    public bool IsThis { get; public set; }
    public bool IsOptional { get; public set; }
    public IDeclaration ParameterDeclarationCopy { get; }
    public bool RequireToSelectValue { get; }
    public IParameterValue SelectedValue { get; public set; }
    public ParameterKind ParameterKind { get; public set; }
    public IDeclaration ParameterDeclaration { get; public set; }
    public Property`1<string> ParameterModifierString { get; }
    public ClrChangeSignatureModel Model { get; }
    public IType ParameterType { get; public set; }
    [CanBeNullAttribute]
public IType OriginalParameterType { get; }
    public ClrChangeSignatureParameter(ClrChangeSignatureModel model, int index);
    public ClrChangeSignatureParameter(ClrChangeSignatureModel model, IParameter parameter);
    [CompilerGeneratedAttribute]
public bool get_IsParams();
    [CompilerGeneratedAttribute]
public void set_IsParams(bool value);
    public virtual string get_TypeName();
    public virtual void set_TypeName(string value);
    public virtual int get_ParameterIndex();
    [CompilerGeneratedAttribute]
public bool get_IsVarArg();
    [CompilerGeneratedAttribute]
public void set_IsVarArg(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsThis();
    [CompilerGeneratedAttribute]
public void set_IsThis(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
    [CompilerGeneratedAttribute]
public IDeclaration get_ParameterDeclarationCopy();
    public bool get_RequireToSelectValue();
    [CompilerGeneratedAttribute]
public IParameterValue get_SelectedValue();
    [CompilerGeneratedAttribute]
public void set_SelectedValue(IParameterValue value);
    [CompilerGeneratedAttribute]
public ParameterKind get_ParameterKind();
    [CompilerGeneratedAttribute]
public void set_ParameterKind(ParameterKind value);
    [CompilerGeneratedAttribute]
public IDeclaration get_ParameterDeclaration();
    [CompilerGeneratedAttribute]
public void set_ParameterDeclaration(IDeclaration value);
    [CompilerGeneratedAttribute]
public Property`1<string> get_ParameterModifierString();
    public ClrChangeSignatureModel get_Model();
    public IType get_ParameterType();
    public void set_ParameterType(IType value);
    public IType get_OriginalParameterType();
    public string CheckIsValid();
    public bool Equals(ClrChangeSignatureParameter changeSignatureParameter);
    public virtual void SetDefault(DefaultParameterChoice choice, string value);
    public virtual IArgumentsOwner GetCallPreview(IArgumentsOwner call, object argumentValue, bool addFake);
    public string GetParameterKindDescription();
    public string GetParameterModifierString();
    public List`1<string> GetKindDescriptions(String& currentValue);
    public static ClrChangeSignatureParameter CreateNonCompilable();
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.CreateNewLocalParameterValue : object {
    [NotNullAttribute]
private IType myType;
    [NotNullAttribute]
private INamesCollection myNameSuggestion;
    public CreateNewLocalParameterValue(IType type, string parameterName, PsiLanguageType language, IPsiSourceFile sourceFile);
    public sealed virtual IExpression CreateExpression(ITreeNode context, ExpressionAction& postAction);
    public string PickVariableName(ITreeNode context, HashSet`1<string> pickedNames);
}
public abstract class JetBrains.ReSharper.Refactorings.ChangeSignature.DeclareLocalVariableHelper`2 : object {
    private static Key`1<ITreeNode> KEY1;
    private static Key`1<ITreeNode> KEY2;
    private static DeclareLocalVariableHelper`2();
    public virtual ILocalVariable DeclareLocalVariable(string variableName, IType variableType, IExpression& beforeExpression, IElementsSet elementsToKeep);
    protected abstract virtual TDeclarationStatement CreateDeclarationStatement(ITreeNode context, IType variableType, string variableName);
    protected abstract virtual TDeclarationStatement InsertDeclarationStatement(TDeclarationStatement statement, TStatement& beforeStatement);
    protected abstract virtual ILocalVariable GetDeclaredVariable(TDeclarationStatement statement);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.DefaultValueOfType : object {
    private IType myType;
    public DefaultValueOfType(IType type);
    public sealed virtual IExpression CreateExpression(ITreeNode context, ExpressionAction& postAction);
    public IExpression CreateExpression(ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.DiscardOutParameterValue : CreateNewLocalParameterValue {
    public DiscardOutParameterValue(IType type, string parameterName, PsiLanguageType language, IPsiSourceFile sourceFile);
    public sealed virtual IExpression CreateExpression(ITreeNode context, ExpressionAction& postAction);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.ExpressionAction : MulticastDelegate {
    public ExpressionAction(object object, IntPtr method);
    public virtual void Invoke(IExpression expression, IElementsSet elementsToKeep);
    public virtual IAsyncResult BeginInvoke(IExpression expression, IElementsSet elementsToKeep, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface JetBrains.ReSharper.Refactorings.ChangeSignature.ICallPreviewProvider {
    public abstract virtual IArgumentsOwner GetCallPreview(IArgumentsOwner call, ClrChangeSignatureParameter parameter, object argumentValue, bool addFake);
}
public interface JetBrains.ReSharper.Refactorings.ChangeSignature.IChangeSignatureCommonTestData`2 {
    public bool HasPostExecute { get; }
    public abstract virtual void UpdateModel(TModel model);
    public abstract virtual void Execute(TModel model);
    public abstract virtual bool get_HasPostExecute();
}
public interface JetBrains.ReSharper.Refactorings.ChangeSignature.IChangeSignatureModel {
    public string ReturnTypeName { get; public set; }
    public string Name { get; public set; }
    public PsiLanguageType Language { get; }
    public IDeclaredElement ParametersOwner { get; }
    public IModuleReferenceResolveContext ResolveContext { get; }
    public bool HasRecursiveCalls { get; }
    public abstract virtual string get_ReturnTypeName();
    public abstract virtual void set_ReturnTypeName(string value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual IDeclaredElement get_ParametersOwner();
    public abstract virtual IModuleReferenceResolveContext get_ResolveContext();
    public abstract virtual bool get_HasRecursiveCalls();
    public abstract virtual string GetPreview();
    public abstract virtual bool CanChangeSignature();
    public abstract virtual bool CanHaveParameters();
    public abstract virtual string GetDefaultValue(ChangeSignatureParameter parameter);
    public abstract virtual bool IsDefaultValueApplicable(DefaultParameterChoice defaultParameterChoice, ChangeSignatureParameter parameter);
    public abstract virtual bool IsDefaultValueRequired(ChangeSignatureParameter parameter);
    public abstract virtual bool CanChangeType();
    public abstract virtual bool CanChangeName();
    public abstract virtual bool IsValidExpression(string expr);
    public abstract virtual int Add(int index);
    public abstract virtual bool CanBeAddedAt(int index);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual void MoveTo(int oldParameterIndex, int newParameterIndex);
    public abstract virtual void MoveUp(int parameterIndex);
    public abstract virtual void MoveDown(int parameterIndex);
    public abstract virtual bool CanMoveUp(int index);
    public abstract virtual bool CanMoveDown(int index);
}
public interface JetBrains.ReSharper.Refactorings.ChangeSignature.IChangeSignatureTestData {
}
public interface JetBrains.ReSharper.Refactorings.ChangeSignature.IElementsSet {
    public abstract virtual bool Contains(ITreeNode element);
    public abstract virtual void Replace(ITreeNode oldElement, ITreeNode newElement);
}
[DerivedComponentsInstantiationRequirementAttribute("0")]
public interface JetBrains.ReSharper.Refactorings.ChangeSignature.IInplaceChangeSignatureHelper {
    public abstract virtual TreeTextRange GetSignatureRange(IDeclaration declaration);
    public abstract virtual TreeTextRange GetParameterListRange(IDeclaration declaration);
    public abstract virtual bool IsValidConstructorName(ITypeMemberDeclaration constructorDeclaration, ITypeElement containingType);
    public abstract virtual string IsValidParametersOwner(IDeclaration initialDeclaration, string text);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.Impl.ArgumentLikeInfo : object {
    [CanBeNullAttribute]
public ITreeNode ArgumentLikeNode;
    [CanBeNullAttribute]
public ArgumentAction PostAction;
    public int OldIndex;
    public ArgumentLikeInfo(ITreeNode argumentLikeNode, ArgumentAction postAction);
    public ArgumentLikeInfo(ITreeNode argumentLikeNode, int oldIndex);
}
internal class JetBrains.ReSharper.Refactorings.ChangeSignature.Impl.ChangeSignatureConflictSearcher : object {
    [CompilerGeneratedAttribute]
private ClrChangeSignatureModel <model>P;
    [CompilerGeneratedAttribute]
private ConflictSearchResult <LastResult>k__BackingField;
    public ConflictSearchResult LastResult { get; private set; }
    public ChangeSignatureConflictSearcher(ClrChangeSignatureModel model);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator progressIndicator, bool canPerformRefactoring);
    [CompilerGeneratedAttribute]
public sealed virtual ConflictSearchResult get_LastResult();
    [CompilerGeneratedAttribute]
private void set_LastResult(ConflictSearchResult value);
    [CompilerGeneratedAttribute]
internal static bool <SearchConflicts>g__RequiresCallSiteChange|2_0(ClrChangeSignatureParameter parameter);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.Impl.ChangeSignatureIds : object {
    public static string TreeGridId;
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.Impl.ChangeSignaturePage`2 : SingleBeRefactoringPage {
    [NotNullAttribute]
protected ListEvents`1<TParameter> myChangeSignatureParameters;
    protected SimpleSignal RevalidateParameters;
    protected TChangeSignatureModel myModel;
    private ISolution mySolution;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <ReturnTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Preview>k__BackingField;
    public IProperty`1<string> ReturnTypeName { get; protected set; }
    public IProperty`1<string> Name { get; public set; }
    public IProperty`1<string> Preview { get; }
    public string Description { get; }
    public IListEvents`1<TParameter> ChangeSignatureParameters { get; }
    public string Title { get; }
    public bool CanCompleteType { get; }
    public ChangeSignaturePage`2(TChangeSignatureModel model, Lifetime lifetime, ISolution solution);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_ReturnTypeName();
    [CompilerGeneratedAttribute]
protected void set_ReturnTypeName(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_Preview();
    public virtual string get_Description();
    public IListEvents`1<TParameter> get_ChangeSignatureParameters();
    public virtual string get_Title();
    protected virtual IList`1<BeControl> PresentParameter(Lifetime lifetime, ISolution solution, TParameter parameter);
    protected void UpdatePreview();
    public virtual void Commit();
    public virtual BeControl GetPageContent();
    public virtual bool get_CanCompleteType();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    [CanBeNullAttribute]
public virtual BeControl GetSpecificPresentation(Lifetime lifetime);
    public virtual ValueTuple`2<string, ValidationStates> Validate();
    public virtual String[] GetColumns();
    [CompilerGeneratedAttribute]
private void <UpdatePreview>b__23_0();
    [CompilerGeneratedAttribute]
private string <UpdatePreview>b__23_1();
}
internal class JetBrains.ReSharper.Refactorings.ChangeSignature.Impl.ClrChangeSignaturePage : ChangeSignaturePage`2<ClrChangeSignatureModel, ClrChangeSignatureParameter> {
    public ClrChangeSignaturePage(ClrChangeSignatureModel model, Lifetime lifetime, ISolution solution);
    protected virtual IList`1<BeControl> PresentParameter(Lifetime lifetime, ISolution solution, ClrChangeSignatureParameter parameter);
    private void ApplyKindDescriptions(string text, ClrChangeSignatureParameter parameter);
    public virtual BeControl GetSpecificPresentation(Lifetime lifetime);
    public virtual ValueTuple`2<string, ValidationStates> Validate();
    public virtual String[] GetColumns();
    [CompilerGeneratedAttribute]
private void <GetSpecificPresentation>b__3_0(PropertyChangedEventArgs`1<bool> b);
}
public enum JetBrains.ReSharper.Refactorings.ChangeSignature.Impl.DefaultParameterChoice : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Leave code non-compilable, I'll correct calls _myself")]
public static DefaultParameterChoice NonCompilable;
    [LocalizedDescriptionAttribute("U_se '{0}'")]
public static DefaultParameterChoice DefaultValue;
    [LocalizedDescriptionAttribute("Use unique _value of type '{0}' at the point of call (if exists)")]
public static DefaultParameterChoice UniqueValue;
    [LocalizedDescriptionAttribute("_Discard out parameter value")]
public static DefaultParameterChoice Discard;
    [LocalizedDescriptionAttribute("Create a new _local variable and use it")]
public static DefaultParameterChoice CreateLocal;
    [LocalizedDescriptionAttribute("Resolve with call _tree")]
public static DefaultParameterChoice ResolveByTool;
    [LocalizedDescriptionAttribute("Use the _following value:")]
public static DefaultParameterChoice SpecifyValue;
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.Impl.DefaultParameterValuePage : SingleBeRefactoringPage {
    private IChangeSignatureModel myModel;
    private ChangeSignatureParameter myParameter;
    [CompilerGeneratedAttribute]
private static DefaultParameterChoice <DefaultChoice>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <DefaultRecursiveCallsKeep>k__BackingField;
    private BeGrid myContent;
    private Property`1<DefaultParameterChoice> myChoiceProperty;
    private Property`1<bool> myRecursiveParameterProperty;
    private BeTextBox myRdEditableTextViewModel;
    public static DefaultParameterChoice DefaultChoice { get; public set; }
    public static bool DefaultRecursiveCallsKeep { get; public set; }
    public DefaultParameterValuePage(IChangeSignatureModel model, Lifetime lifetime, ChangeSignatureParameter parameter);
    private static DefaultParameterValuePage();
    [CompilerGeneratedAttribute]
public static DefaultParameterChoice get_DefaultChoice();
    [CompilerGeneratedAttribute]
public static void set_DefaultChoice(DefaultParameterChoice value);
    [CompilerGeneratedAttribute]
public static bool get_DefaultRecursiveCallsKeep();
    [CompilerGeneratedAttribute]
public static void set_DefaultRecursiveCallsKeep(bool value);
    public virtual void Commit();
    public virtual BeControl GetPageContent();
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.Impl.UnresolvedTypeFactory : object {
    private Dictionary`2<string, UnresolvedDeclaredType> myUnresolvedTypes;
    private IUnresolvedTypesChooser myLanguageSpecificChooser;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    public ISolution Solution { get; }
    public IEnumerable`1<UnresolvedDeclaredType> UnresolvedTypes { get; }
    public UnresolvedTypeFactory(ITreeNode context);
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    public IEnumerable`1<UnresolvedDeclaredType> get_UnresolvedTypes();
    [CanBeNullAttribute]
public IType GetResolvedType(string typeText, bool allowNotResolved);
    public void CollectUnresolvedTypes(string typeText);
}
public interface JetBrains.ReSharper.Refactorings.ChangeSignature.IParameterValue {
    public abstract virtual IExpression CreateExpression(ITreeNode context, ExpressionAction& postAction);
}
public interface JetBrains.ReSharper.Refactorings.ChangeSignature.ISignatureUsage {
    public abstract virtual IEnumerable`1<IConflict> GetUpdateReferenceConflicts();
    public abstract virtual bool TryUpdateSignatureUsage(List`1<ArgumentLikeInfo> postActionsList);
    [CanBeNullAttribute]
public abstract virtual ISignatureUsage TryConvertToSimplerUsage();
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.NonCompilableParameterValue : object {
    [NotNullAttribute]
public static NonCompilableParameterValue INSTANCE;
    private static NonCompilableParameterValue();
    public sealed virtual IExpression CreateExpression(ITreeNode context, ExpressionAction& postAction);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.CallProblemNode : ProblemNode {
    private RichText myLastPresentationText;
    [CompilerGeneratedAttribute]
private ChangeSignatureParameter <ChangeSignatureParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private PullParameterSession <PullParameterSession>k__BackingField;
    [CompilerGeneratedAttribute]
private RichText <Caller>k__BackingField;
    [CompilerGeneratedAttribute]
private IconModel <Icon>k__BackingField;
    public bool IsValid { get; }
    public IArgumentsOwner ArgumentsOwner { get; }
    public ChangeSignatureParameter ChangeSignatureParameter { get; }
    public ITypeMember TypeMember { get; }
    public ITypeElement TypeElement { get; }
    public PullParameterSession PullParameterSession { get; }
    public RichText Caller { get; public set; }
    public IconModel Icon { get; public set; }
    public CallProblemNode(IReference callReference, IDeclaredElement owner, ChangeSignatureParameter parameter, Lifetime lifetime, PullParameterSession pullParameterSession);
    public bool get_IsValid();
    public IArgumentsOwner get_ArgumentsOwner();
    [CompilerGeneratedAttribute]
public ChangeSignatureParameter get_ChangeSignatureParameter();
    public ITypeMember get_TypeMember();
    public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
public PullParameterSession get_PullParameterSession();
    [CompilerGeneratedAttribute]
public RichText get_Caller();
    [CompilerGeneratedAttribute]
public void set_Caller(RichText value);
    [CompilerGeneratedAttribute]
public IconModel get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(IconModel value);
    protected virtual DocumentRange GetRange(IDeclaration declaration);
    protected virtual bool Started();
    public virtual void SetFixedPresentation(RichText mainText, RichText descriptionText);
    public sealed virtual void SetUnresolvedPresentation();
    public virtual void Navigate();
    private void LoadPresentation(RichText parameterName, RichText descriptionText);
    public virtual void SetErrorPresentation(string descriptionText);
    private void InitCaller();
    [CompilerGeneratedAttribute]
private void <Navigate>b__28_0();
    [CompilerGeneratedAttribute]
private void <Navigate>b__28_1();
}
public abstract class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.ChangeSignatureFixNode : FixNode {
    protected ChangeSignatureFixNode(ProblemNode ancestorProblemNode, Lifetime lifetime);
    protected ISubstitution GetAllMemberSubstitutions(ITypeMember typeMember);
    private ISubstitution GetAllTypeMemberSubstitutions();
    private ISubstitution GetAllBaseClassesSubstitution(ITypeElement typeElement);
    protected IArgumentsOwner FixCall(ChangeSignatureParameter parameter, object argumentValue, bool addFake);
    public virtual void CreateDescendantNodes(IDeclaredElement declaredElement, IEnumerable`1<IReference> references);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.CustomFixEditNode : ChangeSignatureFixNode {
    private TextStyle myBoldStyle;
    private string myCustomValue;
    public CustomFixEditNode(ProblemNode node, Lifetime lifetime);
    public virtual BeControl GetPresentation();
    public virtual BeAbstractText GetPresentationText();
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.CustomFixNode : ChangeSignatureFixNode {
    private RichText myKindName;
    private RichText myParameterName;
    private TextStyle myBoldStyle;
    private static List`1<string> CurrentCustomValues;
    private string myCustomValue;
    private CustomFixNode(ProblemNode node, string customValue, Lifetime lifetime);
    private static CustomFixNode();
    public static void AddCustomValue(string customValue);
    public static void ClearCustomValues();
    public virtual BeAbstractText GetPresentationText();
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    [NotNullAttribute]
public static IEnumerable`1<FixNode> GetFixes(CallProblemNode node);
    public virtual string ToString();
}
[FixFactoryAttribute("16")]
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.CustomValueFixFactory : FixFactory {
    public int Priority { get; }
    public virtual int get_Priority();
    public virtual IEnumerable`1<FixNode> GetDependentFixes(ProblemNode problemNode);
    public virtual void Reset(string modelSessionId);
    public virtual IEnumerable`1<FixNode> GetIndependentFixes(ProblemNode node);
}
internal class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.EmptyFix : ChangeSignatureFixNode {
    public EmptyFix(ProblemNode problemNode, Lifetime lifetime);
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    public virtual BeAbstractText GetPresentationText();
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    public virtual string ToString();
}
[FixFactoryAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.EmptyFixFactory : FixFactory {
    public int Priority { get; }
    public virtual int get_Priority();
    public virtual IEnumerable`1<FixNode> GetIndependentFixes(ProblemNode problemNode);
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Refactorings.PushPullTool.FixFactory")]
[MeansImplicitUseAttribute]
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.FixFactoryAttribute : ShellComponentAttribute {
    public FixFactoryAttribute(Instantiation instantiation);
}
[FixFactoryAttribute("16")]
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.LocalFixFactory : FixFactory {
    public int Priority { get; }
    public virtual int get_Priority();
    public virtual IEnumerable`1<FixNode> GetDependentFixes(ProblemNode problemNode);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.LocalFixNode : ChangeSignatureFixNode {
    private IDeclaredElementPointer`1<IDeclaredElement> myDeclaredElement;
    private RichText myKindName;
    private RichText myParameterName;
    private TextStyle myBoldStyle;
    public IDeclaredElement DeclaredElement { get; }
    private LocalFixNode(ProblemNode node, IDeclaredElement declaredElement, Lifetime lifetime);
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual BeAbstractText GetPresentationText();
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    [NotNullAttribute]
public static IEnumerable`1<FixNode> GetFixes(CallProblemNode node);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.ParameterFixNode : ChangeSignatureFixNode {
    private TextStyle myBoldStyle;
    private IDeclaredElementPointer`1<IParametersOwner> myCallOwner;
    private RichText myCallOwnerText;
    private TextStyle myRegularStyle;
    private RichText myKindText;
    private BeRichText myPresentation;
    private ITreeNode myUniqueNameContext;
    protected string myParameterName;
    private IDeclaredElementPointer`1<IDeclaredElement> myParentPointer;
    protected ClrChangeSignatureParameter myParameter;
    protected ClrChangeSignatureModel myParentSignatureModel;
    protected string Text { get; }
    public IDeclaredElement DeclaredElement { get; }
    public ParameterFixNode(CallProblemNode node, IParametersOwner callOwner, Lifetime lifetime);
    protected virtual string get_Text();
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    public virtual BeAbstractText GetPresentationText();
    private void LoadPresentation(BeRichText beAbstractText);
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    protected virtual void Init();
    protected virtual int GetNewArgumentIndex();
    public virtual void CreateDescendantNodes(IDeclaredElement parametersOwner, IEnumerable`1<IReference> references);
    public virtual string ToString();
    private void ProcessOverloads();
    [CompilerGeneratedAttribute]
private void <.ctor>b__15_0(bool b);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.PullParameterSession : FixToolSession {
    private ClrChangeSignatureParameter myParameter;
    protected OneToListMap`2<ITypeElement, CallProblemNode> myAllItems;
    private IDeclaredElement myStartingElement;
    [CompilerGeneratedAttribute]
private bool <RefactoringIsInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    public bool RefactoringIsInProgress { get; public set; }
    public Lifetime Lifetime { get; }
    public PullParameterSession(IDeclaredElement startingElement, ClrChangeSignatureParameter parameter, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual bool get_RefactoringIsInProgress();
    [CompilerGeneratedAttribute]
public virtual void set_RefactoringIsInProgress(bool value);
    public virtual void ReloadFixes(ProblemNode node);
    public void AddRootItems(IEnumerable`1<IReference> allReferences);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    public void AddItem(CallProblemNode pullParameter);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.SmartCompletionFix : ChangeSignatureFixNode {
    private ITreeNodePointer`1<IArgument> myArgument;
    private int myCaretOffset;
    private DocumentRange myDocumentRange;
    private int myUndoStartOffset;
    private int myUndoEndOffset;
    public SmartCompletionFix(CallProblemNode ancestorCallProblem);
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    public virtual void ExecuteWithoutTransaction();
    public virtual void PostExecute();
    public virtual BeAbstractText GetPresentationText();
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    public virtual bool Rollback();
    public virtual string ToString();
}
[FixFactoryAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.SmartCompletionFixFactory : FixFactory {
    public int Priority { get; }
    public virtual int get_Priority();
    public virtual IEnumerable`1<FixNode> GetIndependentFixes(ProblemNode problemNode);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.PushPullTool.StartingFixNode : ChangeSignatureFixNode {
    private PullParameterSession mySession;
    public StartingFixNode(IDeclaredElement owner, ClrChangeSignatureParameter parameter, PullParameterSession session);
    public virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    public virtual BeAbstractText GetPresentationText();
    public virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    public virtual void CreateDescendantNodes(IDeclaredElement declaredElement, IEnumerable`1<IReference> references);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.RebindableReference : object {
    private IDeclaredElement myDeclaredElement;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, int> <ArgumentsToParameterMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private IReference <Reference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRecursivePass>k__BackingField;
    [CanBeNullAttribute]
public Dictionary`2<int, int> ArgumentsToParameterMapping { get; public set; }
    public IReference Reference { get; public set; }
    public bool IsRecursivePass { get; public set; }
    public RebindableReference(IReference reference);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, int> get_ArgumentsToParameterMapping();
    [CompilerGeneratedAttribute]
public void set_ArgumentsToParameterMapping(Dictionary`2<int, int> value);
    [CompilerGeneratedAttribute]
public IReference get_Reference();
    [CompilerGeneratedAttribute]
public void set_Reference(IReference value);
    [CompilerGeneratedAttribute]
public bool get_IsRecursivePass();
    [CompilerGeneratedAttribute]
public void set_IsRecursivePass(bool value);
    public void TryRebind(IReference reference);
}
public abstract class JetBrains.ReSharper.Refactorings.ChangeSignature.SignatureUsage`1 : object {
    protected RebindableReference myRebindableReference;
    protected ClrChangeSignatureModel ClrChangeSignatureModel;
    protected SignatureUsage`1(ITreeNode context, ClrChangeSignatureModel clrChangeSignatureModel, RebindableReference rebindableReference);
    public virtual IEnumerable`1<IConflict> GetUpdateReferenceConflicts();
    public virtual bool TryUpdateSignatureUsage(List`1<ArgumentLikeInfo> postActionsList);
    private OneToListMap`2<int, ArgumentLikeInfo> GetNewParamIndexToOldArgument(ClrChangeSignatureModel changeSignatureModel);
    private void ReplaceAllItems(OneToListMap`2<int, ArgumentLikeInfo> newItems, IList`1<ClrChangeSignatureParameter> parameters, List`1<ArgumentLikeInfo> postActionsList);
    [CanBeNullAttribute]
protected abstract virtual ArgumentLikeInfo CreateItemForParameter(ClrChangeSignatureParameter parameter, bool isRecursivePass);
    protected virtual ITreeNode CopyItemForParameter(ITreeNode item, ClrChangeSignatureParameter parameter);
    protected abstract virtual bool TryGetItem(int index, TItem& item);
    protected abstract virtual TItem AddItemAfter(TItem item, TItem anchor, ClrChangeSignatureParameter parameter);
    protected abstract virtual void RemoveItem(TItem item);
    protected virtual TItem ReplaceItemBy(TItem item, TItem newItem, ClrChangeSignatureParameter parameter);
    public virtual ISignatureUsage TryConvertToSimplerUsage();
    protected static string SuggestName(IDeclaredElement declaredElement, ITreeNode context, HashSet`1<string> usedNamesFilter);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.TextParameterValue : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public TextParameterValue(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    public sealed virtual IExpression CreateExpression(ITreeNode context, ExpressionAction& postAction);
}
public class JetBrains.ReSharper.Refactorings.ChangeSignature.UniqueValueOfTypeParameterValue : object {
    private IType myType;
    private string myTypeClrName;
    public UniqueValueOfTypeParameterValue(IType type);
    public UniqueValueOfTypeParameterValue(string typeClrName);
    public sealed virtual IExpression CreateExpression(ITreeNode context, ExpressionAction& postAction);
    private static List`1<DeclaredElementInstance`1<ITypeOwner>> FilterOutPropertyWithBackingField(List`1<DeclaredElementInstance`1<ITypeOwner>> variables);
    private static List`1<DeclaredElementInstance`1<ITypeOwner>> FilterOutFieldOrAutoPropertyInitializedFromLocalOrParameter(List`1<DeclaredElementInstance`1<ITypeOwner>> variables, ITreeNode context);
}
public interface JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.IMakeMethodNonStatic {
    public abstract virtual IDeclaredElement PatchDeclaration(IDeclaration declaration, int thisParameterIndex, bool createVar, ITypeElement newMethodOwner, IList`1<ITypeParameter> typeParams, IInterface interface, AccessRights accessRights, Dictionary`2<ITypeParameter, ITypeParameter> newToOldTypeParameters);
    public abstract virtual void RemoveDeclaration(IDeclaration methodDeclaration);
    public abstract virtual IDeclaration AddDeclaration(IDeclaration declaration, IDeclaration methodOwnerDeclaration, IRefactoringDriver driver);
    public abstract virtual bool Suitable(IDeclaration declaration);
    public abstract virtual void BindToThis(IReference reference);
    public abstract virtual void PatchRecursiveCall(ITreeNode referenceElement, int thisParameter, IRefactoringDriver driver);
    public abstract virtual void PatchMethodReference(IReference reference, ISubstitution substitution, Dictionary`2<ITypeParameter, ITypeParameter> newToOldTypeParametersMap, IList`1<ITypeParameter> methodTypeParams, IRefactoringDriver driver, int parameterIndex);
}
public interface JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.IMakeNonStaticWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.LanguageSpecificUtil : object {
    public static Key`1<object> RECURSIVE_CALL;
    private static LanguageSpecificUtil();
    public static IMakeMethodNonStatic GetImplementation(PsiLanguageType language);
    public static IMakeMethodNonStatic GetImplementation(IReference reference);
    public static IMakeMethodNonStatic GetImplementation(ITypeElement typeElement);
    public static bool IsDefault(IMakeMethodNonStatic implementation);
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.MakeMethodNonStatic : RefactoringExecBase`2<MakeNonStaticWorkflow, MakeNonStaticRefactoring> {
    public MakeMethodNonStatic(MakeNonStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "MakeMethodNonStaticActionText")]
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.MakeNonStaticAction : ExtensibleRefactoringAction`1<IMakeNonStaticWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.MakeNonStaticPage : SingleBeRefactoringPage {
    private MakeNonStaticWorkflow myWorkflow;
    private BeControl myContent;
    [CompilerGeneratedAttribute]
private IProperty`1<ParameterElement> <SelectedParameter>k__BackingField;
    public string Title { get; }
    public string Description { get; }
    public string PageDescription { get; }
    public IProperty`1<ParameterElement> SelectedParameter { get; }
    public MakeNonStaticPage(MakeNonStaticWorkflow workflow);
    public virtual string get_Title();
    public virtual string get_Description();
    public virtual string get_PageDescription();
    [CompilerGeneratedAttribute]
public IProperty`1<ParameterElement> get_SelectedParameter();
    private bool IsApplicable(IParameter parameter);
    public virtual void Commit();
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private ParameterElement <.ctor>b__8_0(IParameter p);
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.MakeNonStaticRefactoring : DrivenRefactoring`2<MakeNonStaticWorkflow, MakeMethodNonStatic> {
    private bool myCreateVar;
    private IFinder myFinder;
    private ITypeElement[] myImmediateImplementations;
    private List`1<ITypeParameter> myMethodTypeParams;
    private Dictionary`2<IReference, ISubstitution> myMethodUsages;
    private IParametersOwner myParametersOwner;
    private int mySelectedParameterIndex;
    public MakeNonStaticRefactoring(MakeNonStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    private bool RequiresTemporaryVariable(IReference reference, ITypeElement newMethodOwner);
    private static void FindImmediateInterfaceImplementations(JetHashSet`1<ITypeElement> visited, ArrayList implementations, IInterface iface, IProgressIndicator pi, IFinder finder);
    public virtual bool Execute(IProgressIndicator pi);
    private void CollectTypeParameters(ITypeElement oldMethodOwner, ITypeElement newMethodOwner);
    private static ITypeDeclaration FindMostSuitableDeclaration(IDeclaredElement newMethodOwner, IDeclaration methodDeclaration);
    public static bool SuitsBetter(IDeclaration newOwnerDeclaration, IDeclaration methodDeclaration, IDeclaration mostSuitableDeclaration);
    private Dictionary`2<ITypeParameter, ITypeParameter> ProcessMethodDeclaration(ITypeMemberDeclaration templateDeclaration, IDeclaration mostSuitableOwnerDeclaration, ITypeElement newMethodOwner, IProgressIndicator progressIndicator, bool memberConflict, ITypeElement methodOwner);
    private void PatchRecursiveCalls(ITreeNode declaration);
    private bool CheckMemberExists(ITypeElement newMethodOwner, bool initialIsInterface, string parametersOwnerName, IList`1<IParameter> parameters);
    private void ProcessMethodUsages(Dictionary`2<ITypeParameter, ITypeParameter> newToOldTypeParametersMap, string thisParameterName);
    [CompilerGeneratedAttribute]
private bool <CollectTypeParameters>b__11_0(ITypeParameter typeParameter);
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.MakeNonStaticWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    private IDeclaredElementPointer`1<IParametersOwner> myParametersOwnerPointer;
    [CompilerGeneratedAttribute]
private MakeNonStaticDataProvider <DataProvider>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public PsiLanguageType Language { get; public set; }
    public bool HasUI { get; }
    public HelpId HelpKeyword { get; }
    public IParametersOwner ParametersOwner { get; public set; }
    public int SelectedParameterIndex { get; }
    public MakeNonStaticDataProvider DataProvider { get; public set; }
    public MakeNonStaticWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(PsiLanguageType value);
    public virtual bool get_HasUI();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public IParametersOwner get_ParametersOwner();
    public void set_ParametersOwner(IParametersOwner value);
    public int get_SelectedParameterIndex();
    public virtual bool IsAvailable(IDataContext context);
    private bool IsApplicable(IParameter parameter);
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator taskExecutorCreator);
    [CompilerGeneratedAttribute]
public sealed virtual void set_DataProvider(MakeNonStaticDataProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual MakeNonStaticDataProvider get_DataProvider();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.MakeNonStaticWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToNonStatic.Model.MakeNonStaticDataProvider : object {
    [CompilerGeneratedAttribute]
private int <ThisParameterIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    public int ThisParameterIndex { get; }
    public bool NonInteractive { get; }
    public MakeNonStaticDataProvider(int thisParameterIndex, bool hasUI);
    [CompilerGeneratedAttribute]
public int get_ThisParameterIndex();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NonInteractive();
}
public interface JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.IMakeMethodStaticWorkflowProvider {
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.IMakeStaticHelper {
    public abstract virtual bool CheckElement(IDeclaredElement declaredElement, ITypeElement& containingTypeElement);
    public abstract virtual void CollectUsages(ThisUsagesCollector collector, IParametersOwnerDeclaration parametersOwnerDeclaration, IPsiServices psiServices);
    public abstract virtual string GetTitle();
}
public abstract class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStatic : RefactoringExecBase`2<MakeStaticWorkflow, MakeStaticRefactoring> {
    public InlineHelper InlineHelper { get; }
    protected MakeStatic(MakeStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual void BindTo(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution);
    public abstract virtual void Qualify(ITreeNode node, IParameter parameter);
    public abstract virtual void AddArgumentAndBind(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution, DisposableMarker marker);
    public abstract virtual void SetStatic(IDeclaration declaration);
    [CanBeNullAttribute]
public abstract virtual IParameter AddParameter(IDeclaration declaration, IType type, string name);
    public abstract virtual int ReferencesToThis(IExpression expression);
    public abstract virtual InlineHelper get_InlineHelper();
    public abstract virtual void Replace(ITreeNode node, string name);
    public abstract virtual void CallInline(IReference reference, CallSiteContext context, IntroduceParameterInlineCallInfo info, IList`1<string> lambdaParameterNames);
    public abstract virtual void FixOtherArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    [CanBeNullAttribute]
public abstract virtual IReference ConvertMethodGroupToLambda(IReference reference, IList`1<IParameter> parameters);
    public abstract virtual void AddArgument(IReference reference, string marker);
    public virtual bool CallSiteCanBeModifiedWithParametersIntroduction(IReference reference);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "MakeMethodStaticActionText")]
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStaticAction : ExtensibleRefactoringAction`1<IMakeMethodStaticWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStaticIds : object {
    public static string TreeGridId;
    public static String[] Radios { get; }
    public static String[] get_Radios();
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStaticModel : object {
    private IDeclaredElementPointer`1<IDeclaredElement> myMemberPointer;
    private IDeclaredElementPointer`1<ITypeElement> myTypeElementPointer;
    [CompilerGeneratedAttribute]
private ThisUsagesCollector <Collector>k__BackingField;
    [CanBeNullAttribute]
public IDeclaredElement Member { get; private set; }
    public ITypeElement TypeElement { get; private set; }
    public ThisUsagesCollector Collector { get; public set; }
    public MakeStaticModel(ITypeElement typeElement, IDeclaredElement declaredElement, ThisUsagesCollector thisUsagesCollector);
    public IDeclaredElement get_Member();
    private void set_Member(IDeclaredElement value);
    public ITypeElement get_TypeElement();
    private void set_TypeElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public void set_Collector(ThisUsagesCollector value);
    [CompilerGeneratedAttribute]
public ThisUsagesCollector get_Collector();
    public bool IsValid();
}
public enum JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStaticOption : Enum {
    public int value__;
    public static MakeStaticOption NoParameters;
    public static MakeStaticOption AddThis;
    public static MakeStaticOption AddParameters;
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStaticPage : SingleBeRefactoringPage {
    private MakeStaticWorkflow myWorkflow;
    private BeGrid myContent;
    [CompilerGeneratedAttribute]
private bool <CanHaveParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<MakeStaticOption> <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <ThisParameterName>k__BackingField;
    public bool CanHaveParameters { get; }
    public IProperty`1<MakeStaticOption> Policy { get; }
    public IProperty`1<string> ThisParameterName { get; public set; }
    public string Description { get; }
    public string Title { get; }
    public string PageDescription { get; }
    public MakeStaticPage(MakeStaticWorkflow workflow);
    [CompilerGeneratedAttribute]
public bool get_CanHaveParameters();
    [CompilerGeneratedAttribute]
public IProperty`1<MakeStaticOption> get_Policy();
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_ThisParameterName();
    [CompilerGeneratedAttribute]
public void set_ThisParameterName(IProperty`1<string> value);
    public virtual string get_Description();
    public virtual string get_Title();
    public virtual string get_PageDescription();
    public virtual void Commit();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_1(bool b);
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStaticRefactoring : DrivenRefactoring`2<MakeStaticWorkflow, MakeStatic> {
    private List`1<PrecountedReference> myPrecountedReferences;
    private List`1<IntroducedParameter> myParameters;
    private Dictionary`2<IReference, ISubstitution> myReferences;
    private IDeclaration myDeclaration;
    private MakeStaticDataModel myDataModel;
    [CompilerGeneratedAttribute]
private JetHashSet`1<IParameter> <UsedParameters>k__BackingField;
    public JetHashSet`1<IParameter> UsedParameters { get; public set; }
    public MakeStaticRefactoring(MakeStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public sealed virtual JetHashSet`1<IParameter> get_UsedParameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UsedParameters(JetHashSet`1<IParameter> value);
    public sealed virtual Dictionary`2<int, IParameter> GetInlinedMethodParameterInfos(IParametersOwner owner);
    public sealed virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public virtual bool Execute(IProgressIndicator pi);
    private void ProcessWithIntroduceParameter(IProgressIndicator pi);
    private void AddParameters(IPsiSourceFile sourceFile);
    private Dictionary`2<IReference, LocalContextResolveResultImage> InitResolveImages();
    private static void ConsumeInitialReference(IReference reference, IDictionary`2<IReference, LocalContextResolveResultImage> images);
    private void ProcessOriginalWay(IProgressIndicator pi, IPsiSourceFile sourceFile);
    private void ProcessThisOnly(IProgressIndicator pi, IPsiSourceFile sourceFile);
    private void ProcessOriginal(IProgressIndicator pi);
    private void FindReferences(IProgressIndicator subPi);
    protected virtual MakeStatic CreateUnsupportedRefactoring();
    protected virtual MakeStatic CreateRefactoringInternal(InternalRefactoringLanguageService service);
    private void PreProcessReferences(IProgressIndicator pi);
    private void PreProcessReference(IReference reference, ISubstitution substitution);
    private PrecountedReference PreProcessReferenceWithContext(IReference reference, ITreeNode containingElement, ISubstitution substitution);
    private void ProcessReferences(IProgressIndicator pi);
    private void ProcessReferenceWithContext(PrecountedReference precountedReference);
    [CompilerGeneratedAttribute]
private int <ProcessWithIntroduceParameter>b__13_1(Pair`2<DisposableMarker, IExpression> pair);
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStaticWorkflow : DrivenRefactoringWorkflow2`1<IMakeStaticHelper> {
    [CompilerGeneratedAttribute]
private Predicate`1<IDeclaration> <declarationValidator>P;
    private ThisUsagesCollector myThisUsagesCollector;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private MakeStaticModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private MakeStaticDataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private MakeStaticDataModel <DataModel>k__BackingField;
    public PsiLanguageType LanguageType { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public MakeStaticModel Model { get; private set; }
    public MakeStaticDataProvider DataProvider { get; public set; }
    public MakeStaticDataModel DataModel { get; private set; }
    public MakeStaticWorkflow(ISolution solution, string actionId, Predicate`1<IDeclaration> declarationValidator);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public MakeStaticModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(MakeStaticModel value);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    public bool IsAvailableEx(IDataContext context, ITypeElement& typeElement, IDeclaredElement& declaredElement, IDeclaration& declaration);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual IMakeStaticHelper CreateUnsupportedHelper();
    protected virtual IMakeStaticHelper CreateHelper(IRefactoringLanguageService service);
    [CompilerGeneratedAttribute]
public sealed virtual MakeStaticDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DataProvider(MakeStaticDataProvider value);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    [CompilerGeneratedAttribute]
public MakeStaticDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(MakeStaticDataModel value);
    [CompilerGeneratedAttribute]
internal static bool <IsAvailableEx>g__DefaultDeclarationValidator|23_0(IDeclaration declaration);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.MakeStaticWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.Model.ThisUsageElement : TreeNodeNode {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public ThisUsageElement(ITreeNode treeNode);
    [CompilerGeneratedAttribute]
public string get_Text();
}
public interface JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.Models.IMakeStaticDataProvider {
    public MakeStaticOption Policy { get; }
    [CanBeNullAttribute]
public string ThisParameterName { get; }
    public abstract virtual MakeStaticOption get_Policy();
    public abstract virtual string get_ThisParameterName();
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.Models.MakeStaticDataModel : object {
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ThisUsagesCollector <Collector>k__BackingField;
    [CompilerGeneratedAttribute]
private MakeStaticOption <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IDeclaredElement DeclaredElement { get; }
    public ITypeElement TypeElement { get; }
    public ThisUsagesCollector Collector { get; }
    public MakeStaticOption Policy { get; }
    public string Name { get; }
    public MakeStaticDataModel(MakeStaticModel model, string name, MakeStaticOption policy);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
public ThisUsagesCollector get_Collector();
    [CompilerGeneratedAttribute]
public MakeStaticOption get_Policy();
    [CompilerGeneratedAttribute]
public string get_Name();
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.Models.MakeStaticDataProvider : object {
    [CompilerGeneratedAttribute]
private MakeStaticOption <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ThisParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    public MakeStaticOption Policy { get; }
    public string ThisParameterName { get; }
    public bool NonInteractive { get; }
    public MakeStaticDataProvider(MakeStaticOption policy, string thisParameterName, bool hasUI);
    public MakeStaticDataProvider(bool hasUI);
    public MakeStaticDataProvider(IDeclaredElement declaredElement, ITypeElement typeElement, IDeclaration declaration, bool hasUI);
    [CompilerGeneratedAttribute]
public sealed virtual MakeStaticOption get_Policy();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ThisParameterName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NonInteractive();
    private static string GetName(ITypeElement typeElement, IDeclaredElement declaredElement, ITreeNode context);
}
public class JetBrains.ReSharper.Refactorings.ChangeStaticness.ToStatic.Models.ThisUsagesCollector : object {
    [CompilerGeneratedAttribute]
private IList`1<ThisUsageElement> <Expressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ITreeNodePointer`1<ITreeNode>> <ThisUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ITreeNodePointer`1<ITreeNode>> <ReadUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ITreeNodePointer`1<ITreeNode>> <WriteUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesThis>k__BackingField;
    private IDeclaredElement myDeclaredElement;
    private MakeStaticWorkflow myWorkflow;
    public IList`1<ThisUsageElement> Expressions { get; private set; }
    public IList`1<ITreeNodePointer`1<ITreeNode>> ThisUsages { get; }
    public IList`1<ITreeNodePointer`1<ITreeNode>> ReadUsages { get; }
    public IList`1<ITreeNodePointer`1<ITreeNode>> WriteUsages { get; }
    public bool UsesMembers { get; public set; }
    public bool UsesCaptures { get; public set; }
    public bool UsesThis { get; public set; }
    public bool EffectivelyStatic { get; }
    private ThisUsagesCollector(IDeclaredElement declaredElement, MakeStaticWorkflow workflow);
    [CompilerGeneratedAttribute]
public IList`1<ThisUsageElement> get_Expressions();
    [CompilerGeneratedAttribute]
private void set_Expressions(IList`1<ThisUsageElement> value);
    [CompilerGeneratedAttribute]
public IList`1<ITreeNodePointer`1<ITreeNode>> get_ThisUsages();
    [CompilerGeneratedAttribute]
public IList`1<ITreeNodePointer`1<ITreeNode>> get_ReadUsages();
    [CompilerGeneratedAttribute]
public IList`1<ITreeNodePointer`1<ITreeNode>> get_WriteUsages();
    [CompilerGeneratedAttribute]
public bool get_UsesMembers();
    [CompilerGeneratedAttribute]
public void set_UsesMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsesCaptures();
    [CompilerGeneratedAttribute]
public void set_UsesCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsesThis();
    [CompilerGeneratedAttribute]
public void set_UsesThis(bool value);
    public bool get_EffectivelyStatic();
    public void Process();
    public IEnumerable`1<ITreeNode> GetUsagesTopNodes(IEnumerable`1<ITreeNodePointer`1<ITreeNode>> usages);
    public static ThisUsagesCollector CreateCollector(IDeclaredElement declaredElement, MakeStaticWorkflow workflow);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.ChangeType.ChangeContextExtensions : object {
    [ExtensionAttribute]
public static void ApplyChangesAndFixBrokenUsages(IChangeContext context, ITreeNode scope, IReadOnlyList`1<Action> changeActions, IProgressIndicator progress);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.ChangeType.ChangeNodeExtensions : object {
    [ExtensionAttribute]
public static void ApplyRecursively(IChangeNode`1<TContext> changeNode, TContext context, IProgressIndicator progress);
    [ExtensionAttribute]
public static void ApplyRecursively(IReadOnlyList`1<IChangeNode`1<TContext>> changeNodes, TContext context, IProgressIndicator progress);
}
public class JetBrains.ReSharper.Refactorings.ChangeType.ChangeNodesCollector`1 : object {
    [NotNullAttribute]
private HashSet`1<IDeclaredElement> myDeclaredElements;
    [NotNullAttribute]
private List`1<IChangeNode`1<TContext>> myChangeNodes;
    public void Add(ChangeTypeNode`1<TContext> changeTypeNode);
    public void Add(IChangeNode`1<TContext> changeNode);
    [PureAttribute]
public bool ContainsTypeChangeOf(IDeclaredElement declaredElement);
    [NotNullAttribute]
public IReadOnlyList`1<IChangeNode`1<TContext>> GetResult();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.ChangeType.ChangeNodesCollectorExtensions : object {
    [ExtensionAttribute]
public static void CollectChangeTypeNodes(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.ChangeType.ChangeScopeHelper : object {
    [NotNullAttribute]
[DebuggerStepThroughAttribute]
public static ChangeScopeHelper GetInstance(PsiLanguageType language);
    [CanBeNullAttribute]
[PureAttribute]
public virtual ITreeNode GetContainingMemberDeclarationOrTopLevelCodeOrFile(ITreeNode node);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.ChangeType.ChangeTypeHelper : object {
    [NotNullAttribute]
private static ChangeTypeHelper ourInstance;
    private static ChangeTypeHelper();
    [NotNullAttribute]
[DebuggerStepThroughAttribute]
public static ChangeTypeHelper GetInstance(PsiLanguageType language);
    [PureAttribute]
public virtual bool CanChangeElement(IDeclaredElement declaredElement);
    public virtual void ChangeType(IDeclaration declaration, IType newType, TContext context);
    [PureAttribute]
[NotNullAttribute]
[DebuggerStepThroughAttribute]
public virtual IType GetTypeWithActualNullability(ILocalVariable localVariable);
    [NotNullAttribute]
public static IReadOnlyList`1<IChangeNode`1<TContext>> GetChangeTypeNodes(IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
}
public class JetBrains.ReSharper.Refactorings.ChangeType.ChangeTypeNode`1 : object {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IDeclaredElement> myDeclaredElementPointer;
    [NotNullAttribute]
private ITypePointer myNewTypePointer;
    [NotNullAttribute]
private object myStateBeforeChange;
    [CanBeNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    private ChangeTypeNode`1(IDeclaredElement declaredElement, IType newType, object stateBeforeChange);
    public static void Add(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
    private static void AddCore(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
    public IDeclaredElement get_DeclaredElement();
    public sealed virtual bool IsAvailable(TContext context);
    public sealed virtual IReadOnlyList`1<IChangeNode`1<TContext>> Apply(TContext context, IProgressIndicator progress);
    [NotNullAttribute]
private static IList`1<IDeclaration> GetTypeOwnerDeclarations(IDeclaredElement declaredElement);
    private static void CollectScopesFromUsages(HashSet`1<ITreeNode> affectedScopes, IEnumerable`1<IReference> references);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Refactorings.ChangeType.ChangeTypePropagationService : object {
    [NotNullAttribute]
private IImmutableList`1<IChangeTypePropagationsProvider> myProviders;
    public ChangeTypePropagationService(IImmutableList`1<IChangeTypePropagationsProvider> providers);
    public void CollectParameterTypeChangePropagations(ChangeNodesCollector`1<TContext> collector, IParameter parameter, IType oldType, IType newType, IReadOnlyList`1<IReference> parametersOwnerReferences, TContext context, IProgressIndicator progress);
    public void CollectTypeChangePropagations(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, IReadOnlyList`1<IReference> references, TContext context, IProgressIndicator progress);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.ChangeType.DeclaredElementsContextExtensions : object {
    private static Key`1<Data> ourDataKey;
    private static DeclaredElementsContextExtensions();
    [ExtensionAttribute]
public static ChangeCookie OnChange(IChangeContext context);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static bool AddProcessedElement(IChangeContext context, IDeclaredElement declaredElement);
    [ExtensionAttribute]
public static void AddExclusions(IChangeContext context, IEnumerable`1<IDeclaredElement> exclusions);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static bool AddInProcessElement(IChangeContext context, IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsProcessed(IChangeContext context, IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExcluded(IChangeContext context, IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInProcess(IChangeContext context, IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Refactorings.ChangeType.DeclaredElementTypeChangeInfo : DeclaredElementNode {
    [CompilerGeneratedAttribute]
private IType <OldType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <NewType>k__BackingField;
    [NotNullAttribute]
public IType OldType { get; }
    [NotNullAttribute]
public IType NewType { get; }
    public DeclaredElementTypeChangeInfo(IDeclaredElement element, IType oldType, IType newType);
    [CompilerGeneratedAttribute]
public IType get_OldType();
    [CompilerGeneratedAttribute]
public IType get_NewType();
    public void AddRelatedChange(DeclaredElementTypeChangeInfo change);
}
[SolutionFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.ChangeType.DefaultChangeTypeNodesProvider : object {
    public virtual bool IsApplicable(IDeclaredElement declaredElement, IChangeContext context);
    public virtual void AddChangeNodes(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
    private static void AddChangeNodesCore(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
    private static void AddTypeChangesInHierarchy(IType newType, TTypeOwner typeOwner, TTypeMember overridableMember, Func`2<TTypeMember, TTypeOwner> memberToTypeOwner, Action`3<TTypeOwner, IType, IProgressIndicator> adder, HashSet`1<TTypeMember> processedMembers, IProgressIndicator progress);
}
public class JetBrains.ReSharper.Refactorings.ChangeType.DummyChangeTypePropagationsProvider : object {
    public virtual void AddFromDeclaredElement(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, TContext context, IProgressIndicator progress);
    public virtual void AddFromUsage(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, IReference reference, TContext context, IProgressIndicator progress);
    public virtual void AddFromParameterUsage(ChangeNodesCollector`1<TContext> collector, IParameter parameter, IType oldType, IType newType, IReference parametersOwnerReference, TContext context, IProgressIndicator progress);
}
public interface JetBrains.ReSharper.Refactorings.ChangeType.IChangeContext {
    [NotNullAttribute]
public IPsiServices PsiServices { get; }
    [NotNullAttribute]
public IRefactoringDriver Driver { get; }
    public TypeChangePropagationMode TypeChangePropagationMode { get; }
    [CanBeNullAttribute]
public TypeChangesTree EstimatedTypeChanges { get; }
    [NotNullAttribute]
public PostActionsRegistry PostActions { get; }
    public abstract virtual IPsiServices get_PsiServices();
    public abstract virtual IRefactoringDriver get_Driver();
    public abstract virtual TypeChangePropagationMode get_TypeChangePropagationMode();
    public abstract virtual TypeChangesTree get_EstimatedTypeChanges();
    public abstract virtual PostActionsRegistry get_PostActions();
    [NotNullAttribute]
public abstract virtual object GetStateBeforeChange(IEnumerable`1<ITreeNode> scopes);
    public abstract virtual void FixStateAfterChange(object stateBeforeChange, IProgressIndicator progress);
}
public interface JetBrains.ReSharper.Refactorings.ChangeType.IChangeNode`1 {
    [PureAttribute]
public abstract virtual bool IsAvailable(TContext context);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<IChangeNode`1<TContext>> Apply(TContext context, IProgressIndicator progress);
}
public interface JetBrains.ReSharper.Refactorings.ChangeType.IChangeTypeNodesProvider {
    [PureAttribute]
public abstract virtual bool IsApplicable(IDeclaredElement declaredElement, IChangeContext context);
    public abstract virtual void AddChangeNodes(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType newType, TContext context, IProgressIndicator progress);
}
public interface JetBrains.ReSharper.Refactorings.ChangeType.IChangeTypePropagationsProvider {
    public abstract virtual void AddFromDeclaredElement(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, TContext context, IProgressIndicator progress);
    public abstract virtual void AddFromUsage(ChangeNodesCollector`1<TContext> collector, IDeclaredElement declaredElement, IType oldType, IType newType, IReference reference, TContext context, IProgressIndicator progress);
    public abstract virtual void AddFromParameterUsage(ChangeNodesCollector`1<TContext> collector, IParameter parameter, IType oldType, IType newType, IReference parametersOwnerReference, TContext context, IProgressIndicator progress);
}
public static class JetBrains.ReSharper.Refactorings.ChangeType.IgnoreMinorOnlyTypeEqualityComparer : object {
    [NotNullAttribute]
public static TypeEqualityComparer Instance;
    private static IgnoreMinorOnlyTypeEqualityComparer();
}
public class JetBrains.ReSharper.Refactorings.ChangeType.PostActionsRegistry : object {
    [NotNullAttribute]
private List`1<Action> myPostActions;
    public void Add(Action action);
    public void ExecuteAll();
}
public class JetBrains.ReSharper.Refactorings.ChangeType.ReviewTypeChangesPage : SingleBeRefactoringPage {
    public static string ReviewTypeChangesGridId;
    public static string EnableDerivedChangesCheckboxId;
    [NotNullAttribute]
private BeGrid myContent;
    [NotNullAttribute]
private HashSet`1<ITreeGridNode> myRootChanges;
    [NotNullAttribute]
private Property`1<bool> myEnableDerivedChanges;
    [NotNullAttribute]
private IconHostBase myIconHost;
    private static DeclaredElementPresenterStyle ourDeclaredElementPresenterStyle;
    public string Title { get; }
    public string Description { get; }
    public string PageDescription { get; }
    public ReviewTypeChangesPage(IPsiServices psiServices, TypeChangesTree typeChangesTree, Lifetime lifetime);
    private static ReviewTypeChangesPage();
    public virtual string get_Title();
    public virtual string get_Description();
    public virtual string get_PageDescription();
    public virtual BeControl GetPageContent();
    private List`1<BeControl> GetLinePresentation(Lifetime lifetime, ITreeGridNode change, CheckBoxTreeNodeProperties checkBoxTreeNodeProperties, TreeNodeProperties treeNodeProperties);
    private BeControl GetElementWithCheckBox(Lifetime lifetime, DeclaredElementTypeChangeInfo change, CheckBoxTreeNodeProperties checkBoxTreeNodeProperties);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Refactorings.ChangeType.TypeChangePropagationMode : Enum {
    public int value__;
    public static TypeChangePropagationMode None;
    public static TypeChangePropagationMode Origin;
    public static TypeChangePropagationMode Destination;
    public static TypeChangePropagationMode All;
}
public class JetBrains.ReSharper.Refactorings.ChangeType.TypeChangesTree : object {
    [NotNullAttribute]
private Stack`1<DeclaredElementTypeChangeInfo> myChangesStack;
    [NotNullAttribute]
private Dictionary`2<IDeclaredElement, DeclaredElementTypeChangeInfo> myElementToChangeMap;
    [NotNullAttribute]
private List`1<DeclaredElementTypeChangeInfo> myRootChanges;
    [NotNullAttribute]
public IEnumerable`1<DeclaredElementTypeChangeInfo> GetRootChanges();
    public TypeChangesSubtreeCookie StartSubtreeFor(IDeclaredElement declaredElement, IType oldType, IType newType);
    public IEnumerable`1<IDeclaredElement> GetExclusions();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ChangeType.TypeChangesTree/<<GetExclusions>g__HasExlusionsCore|5_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<IDeclaredElement> <GetExclusions>g__HasExlusionsCore|5_0(IEnumerable`1<ITreeGridNode> nodes);
}
public static class JetBrains.ReSharper.Refactorings.ChangeType.TypeModificationUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static IArrayType CreateArrayType(IArrayType arrayType, IType newElementType);
    [NotNullAttribute]
[PureAttribute]
public static Dictionary`2<ITypeParameter, IType> InferSubstitution(IType genericType, IType specificType);
    [CanBeNullAttribute]
[PureAttribute]
public static IType TryApplyNewSubstitution(IType originalType, Dictionary`2<ITypeParameter, IType> newSubstitution);
    [CanBeNullAttribute]
[PureAttribute]
public static IType TryConstructContainerType(IType containerType, IType newTypeArgument);
    [NotNullAttribute]
[PureAttribute]
public static IType DeepRetarget(IType type, IPsiModule psiModule);
    [CompilerGeneratedAttribute]
internal static ITypeParameter <DeepRetarget>g__RetargetTypeParameter|4_0(ITypeParameter typeParameter, IPsiModule targetModule);
}
public abstract class JetBrains.ReSharper.Refactorings.Common.UIUtils.AddOrCreateData`1 : object {
    public static string TargetComboId;
    public static string TargetTextId;
    [CompilerGeneratedAttribute]
private string <TextDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <NewTextProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComboDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<T> <ComboProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<T> <ComboItems>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreateTextInCombo>k__BackingField;
    public string TextDescription { get; public set; }
    public IProperty`1<string> NewTextProperty { get; protected set; }
    public string ComboDescription { get; public set; }
    public IProperty`1<T> ComboProperty { get; protected set; }
    public List`1<T> ComboItems { get; }
    public string CreateTextInCombo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TextDescription();
    [CompilerGeneratedAttribute]
public void set_TextDescription(string value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_NewTextProperty();
    [CompilerGeneratedAttribute]
protected void set_NewTextProperty(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ComboDescription();
    [CompilerGeneratedAttribute]
public void set_ComboDescription(string value);
    [CompilerGeneratedAttribute]
public IProperty`1<T> get_ComboProperty();
    [CompilerGeneratedAttribute]
protected void set_ComboProperty(IProperty`1<T> value);
    [CompilerGeneratedAttribute]
public List`1<T> get_ComboItems();
    [CompilerGeneratedAttribute]
public string get_CreateTextInCombo();
    [CompilerGeneratedAttribute]
public void set_CreateTextInCombo(string value);
    public abstract virtual void Navigate();
    [CanBeNullAttribute]
public abstract virtual BeControl InitText(BeTextBox textBox);
    public abstract virtual BeControl Present(T element, IconHostBase iconHostBase);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.Common.UIUtils.BeRefactoringControlsEx : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static BeControl GetUseOrCreateControl(AddOrCreateData`1<T> data, Lifetime lifetime, IconHostBase iconHostBase, IShellLocks locks);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.Common.UIUtils.BeTreeGridRefactoringPresenters : object {
    [ExtensionAttribute]
public static BeTreeGrid GetRefactoringsTreeWithCheckBoxes(IEnumerable`1<ITreeGridNode> elements, Lifetime lifetime, string id, Action update);
    [ExtensionAttribute]
public static BeTreeGrid GetRefactoringsTree(IEnumerable`1<ITreeGridNode> elements, Lifetime lifetime, string id);
    [ExtensionAttribute]
public static BeTreeGrid GetRefactoringListWithCheckBoxes(IEnumerable`1<ITreeGridNode> elements, Lifetime lifetime, string id, Action update);
    [ExtensionAttribute]
public static BeTreeGrid GetSingleSelectionRefactoringsList(IProperty`1<ITreeGridNode> node, IEnumerable`1<ITreeGridNode> elements, Lifetime lifetime);
    [ExtensionAttribute]
public static BeTreeGrid GetSingleSelectionRefactoringsTree(IProperty`1<ITreeGridNode> node, IEnumerable`1<ITreeGridNode> elements, Lifetime lifetime);
    public static List`1<BeControl> PresentRefactoringsTreeNodeWithCheckBoxes(Lifetime lifetime, ITreeGridNode element, CheckBoxTreeNodeProperties nodeProperties, Action update);
    public static List`1<BeControl> PresentRefactoringsListNodeWithCheckBoxes(Lifetime lifetime, ITreeGridNode element, CheckBoxListNodeProperties nodeProperties, Action update);
    public static List`1<BeControl> PresentRefactoringsNode(Lifetime lifetime, ITreeGridNode element, ListNodeProperties nodeProperties);
    [ExtensionAttribute]
public static List`1<BeControl> ToSimpleRefactoringLine(BeControl content);
    [ExtensionAttribute]
public static List`1<BeControl> ToSimpleRefactoringLine(List`1<BeControl> content);
}
public static class JetBrains.ReSharper.Refactorings.Common.UIUtils.DeclaredElementPresentationUtil : object {
    public static string GetTypePresentation(PsiLanguageType language, IType infoType);
}
public class JetBrains.ReSharper.Refactorings.Conflicts.CompositeConflictSearcher : object {
    private IList`1<IConflictSearcher> myConflictSearchers;
    [CompilerGeneratedAttribute]
private ConflictSearchResult <LastResult>k__BackingField;
    public ConflictSearchResult LastResult { get; private set; }
    public CompositeConflictSearcher(IList`1<IConflictSearcher> conflictSearchers);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    [CompilerGeneratedAttribute]
public sealed virtual ConflictSearchResult get_LastResult();
    [CompilerGeneratedAttribute]
private void set_LastResult(ConflictSearchResult value);
}
[ProtocolHandlerAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Conflicts.New.ConflictProtocolHandler : ProtocolHandler {
    protected virtual void NavigateNakedLink(string link, object host);
}
[ProtocolHandlerAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Conflicts.New.ElementProtocolHandler : ProtocolHandler {
    protected virtual void NavigateNakedLink(string link, object host);
}
[ProtocolHandlerAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Conflicts.New.ReferenceProtocolHandler : ProtocolHandler {
    protected virtual void NavigateNakedLink(string link, object host);
}
public class JetBrains.ReSharper.Refactorings.Conflicts.New.TaggedReference : object {
    private string myTag;
    private IReference myReference;
    public string Tag { get; }
    public IReference Reference { get; }
    public TaggedReference(string tag, IReference reference);
    public string get_Tag();
    public IReference get_Reference();
}
public class JetBrains.ReSharper.Refactorings.Conflicts.NewLocalElementConflictSearcher : object {
    private LocalElementConflictSearcher mySearcher;
    private ITreeNode myScope;
    [CompilerGeneratedAttribute]
private ConflictSearchResult <LastResult>k__BackingField;
    public ConflictSearchResult LastResult { get; private set; }
    public NewLocalElementConflictSearcher(ITreeNode container, string name);
    public NewLocalElementConflictSearcher(ITreeNode container, string name, IDeclaredElement[] elementsToIgnore);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    [CompilerGeneratedAttribute]
public sealed virtual ConflictSearchResult get_LastResult();
    [CompilerGeneratedAttribute]
private void set_LastResult(ConflictSearchResult value);
}
public class JetBrains.ReSharper.Refactorings.Conflicts.NewTypeElementConflictSearcher : object {
    private string myNewName;
    private ISolution mySolution;
    public ConflictSearchResult LastResult { get; }
    public NewTypeElementConflictSearcher(string newName, ISolution solution);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    public sealed virtual ConflictSearchResult get_LastResult();
}
public class JetBrains.ReSharper.Refactorings.Conflicts.NewTypeMemberConflictSearcher : object {
    private List`1<IConflict> myConflicts;
    private ITypeElement myTypeElement;
    private IEnumerable`1<ITypeMember> myTypeMembers;
    [CompilerGeneratedAttribute]
private ConflictSearchResult <LastResult>k__BackingField;
    public ConflictSearchResult LastResult { get; private set; }
    public NewTypeMemberConflictSearcher(IEnumerable`1<ITypeMember> typeMembers, ITypeElement typeElement);
    public NewTypeMemberConflictSearcher(ITypeMember typeMember, ITypeElement typeElement);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    [CompilerGeneratedAttribute]
public sealed virtual ConflictSearchResult get_LastResult();
    [CompilerGeneratedAttribute]
private void set_LastResult(ConflictSearchResult value);
    private void SerachConflictsDown(IProgressIndicator pi);
    private static void SearchOverridesConflictsDown(IProgressIndicator superPi, ICollection`1<IOverridableMember> overridableMembers, ICollection`1<IConflict> conflicts);
    private void SerachConflictsUp(IProgressIndicator pi);
    private void SerachConflictsCold(IProgressIndicator pi);
    private static bool TestSameName(ITypeElement element, ITypeMember member);
}
public class JetBrains.ReSharper.Refactorings.Conflicts.TypeMemberQualifier : object {
    private ITreeNode myScope;
    private ArrayList myPointers;
    public TypeMemberQualifier(ITreeNode scope);
    public void Collect();
    public void FixConflicts();
}
public class JetBrains.ReSharper.Refactorings.Conflicts.UnsupportedLanguageConflictSearcher`1 : object {
    [NotNullAttribute]
private IList`1<ILanguageSpecificEntity<T>> myEntries;
    [CompilerGeneratedAttribute]
private ConflictSearchResult <LastResult>k__BackingField;
    public ConflictSearchResult LastResult { get; private set; }
    public void AddEntries(IEnumerable`1<TEntity> ts, ElementEvaluator<T, TEntity> elementEvaluator, Presenter<T, TEntity> presenter);
    public void AddReferences(IEnumerable`1<IReference> references, Presenter<T, IReference> presenter);
    public void AddReferences(IEnumerable`1<IReference> references);
    public void AddDeclarations(IEnumerable`1<IDeclaration> declarations);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    [CompilerGeneratedAttribute]
public sealed virtual ConflictSearchResult get_LastResult();
    [CompilerGeneratedAttribute]
private void set_LastResult(ConflictSearchResult value);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "AbstractClassToInterfaceActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Abstract2Interface.Abstract2InterfaceAction : ExtensibleRefactoringAction`1<IAbstract2InterfaceWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Abstract2Interface.Abstract2InterfaceProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Convert.Abstract2Interface.Abstract2InterfaceRefactoring : object {
    private JetHashSet`1<ITypeMember> myTypeMembersToRemove;
    private PsiLanguageType myLanguage;
    private List`1<ITypeElement> myInheritors;
    [CompilerGeneratedAttribute]
private IClass <SourceClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private Abstract2InterfaceWorkflow <Workflow>k__BackingField;
    [CompilerGeneratedAttribute]
private LanguageMapOfRefactoring`1<IConvert> <Exec>k__BackingField;
    public IClass SourceClass { get; }
    public IRefactoringDriver Driver { get; }
    public ISolution Solution { get; }
    public Abstract2InterfaceWorkflow Workflow { get; }
    public LanguageMapOfRefactoring`1<IConvert> Exec { get; }
    public Abstract2InterfaceRefactoring(Abstract2InterfaceWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public IClass get_SourceClass();
    [CompilerGeneratedAttribute]
public IRefactoringDriver get_Driver();
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    [CompilerGeneratedAttribute]
public Abstract2InterfaceWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
public LanguageMapOfRefactoring`1<IConvert> get_Exec();
    public sealed virtual bool Execute(IProgressIndicator pi);
    private void RemoveInherits();
    private void AddImplements();
    private void StoreInheritors(IProgressIndicator pi);
    private void AddImplementsSpecifications();
    private void ReplaceMembers(IProgressIndicator pi);
    private void ProcessMembers(IProgressIndicator pi);
    private void ProcessMember(ITypeMember member, IProgressIndicator pi);
    private void ProcessOthers(ITypeMember member);
    private bool ProcessOverridableMember(IOverridableMember overridable, IProgressIndicator pi);
    private IConvert CreateRefactoring(InternalRefactoringLanguageService service);
    public sealed virtual void MakeOverridePublic(IOverridableMember member);
    public sealed virtual bool MakeVirtual(IOverridableMember member);
    public sealed virtual bool Ignore(IDeclaredElement element);
    public sealed virtual void AddInterfaceSpecificationToOverrides(IOverridableMember member, IProgressIndicator pi);
    public sealed virtual void MakeOverridesPublic(IOverridableMember overridable, IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private IConvert <.ctor>b__18_0(IRefactoringLanguageService service);
    [CompilerGeneratedAttribute]
private bool <StoreInheritors>b__22_1(OverridableMemberInstance sm);
}
public class JetBrains.ReSharper.Refactorings.Convert.Abstract2Interface.Abstract2InterfaceWorkflow : DrivenRefactoringWorkflow {
    private IDeclaredElementPointer`1<IClass> myClassPointer;
    private List`1<Action> myPostActions;
    public IDeclaredElementPointer`1<IClass> ClassPointer { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public Abstract2InterfaceWorkflow(ISolution solution, string actionId);
    public IDeclaredElementPointer`1<IClass> get_ClassPointer();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    public virtual HelpId get_HelpKeyword();
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual bool Validate();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
}
public interface JetBrains.ReSharper.Refactorings.Convert.Abstract2Interface.IAbstract2InterfaceExecuter {
    public abstract virtual void MakeOverridePublic(IOverridableMember member);
    public abstract virtual bool MakeVirtual(IOverridableMember member);
    public abstract virtual bool Ignore(IDeclaredElement element);
    public abstract virtual void AddInterfaceSpecificationToOverrides(IOverridableMember member, IProgressIndicator pi);
    public abstract virtual void MakeOverridesPublic(IOverridableMember overridable, IProgressIndicator pi);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Abstract2Interface.IAbstract2InterfaceWorkflowProvider {
}
[ActionAttribute("Constructor2FactoryMethodAction", "JetBrains.ReSharper.Refactorings.Resources.Strings", "ConstructorToFactoryMethodActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.Constructor2FactoryAction : ExtensibleRefactoringAction`1<IConstructor2FactoryWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.Constructor2FactoryMethodPage : SingleBeRefactoringPage {
    private Constructor2FactoryMethodWorkflow myWorkflow;
    private BeSpanGrid myContent;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <FactoryMethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <TargetClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <UseSingleInstance>k__BackingField;
    public string Title { get; }
    public string Description { get; }
    public IProperty`1<string> FactoryMethodName { get; }
    public IProperty`1<string> TargetClassName { get; }
    public IProperty`1<bool> UseSingleInstance { get; }
    public Constructor2FactoryMethodPage(Constructor2FactoryMethodWorkflow workflow, Lifetime lifetime);
    public virtual string get_Title();
    public virtual string get_Description();
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_FactoryMethodName();
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_TargetClassName();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_UseSingleInstance();
    private void ChangeTargetName(PropertyChangedEventArgs`1<bool> args);
    public virtual void Commit();
    public virtual BeControl GetPageContent();
}
public class JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.Constructor2FactoryMethodRefactoring : DrivenRefactoring`2<Constructor2FactoryMethodWorkflow, ConstructorToFactoryMethodBase> {
    [NotNullAttribute]
private IConstructor myConstructor;
    [NotNullAttribute]
private Constructor2FactoryMethodDataProvider myDataProvider;
    [NotNullAttribute]
private List`1<IReferencePointer> myReferencePointers;
    [NotNullAttribute]
private List`1<ITypeParameter> myTypeParameters;
    [NotNullAttribute]
private Dictionary`2<ITypeElement, ITypeElement> myTypeParametersMap;
    private AccessRights myAccessRightsOfMethod;
    private ITypeMember myFactoryMember;
    private ITypeElement myFactoryTargetTypeElement;
    private bool myUsedAsBaseInitializer;
    public Constructor2FactoryMethodRefactoring(Constructor2FactoryMethodWorkflow workflow, Constructor2FactoryMethodDataProvider dataProvider, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    private void ProcessUsages();
    private void ApplyCodeStyle();
    private void CreateFactoryMember();
    [PureAttribute]
private static bool HasInternalContext(IClrDeclaredElement element);
    private void CollectTypeParameters();
    private void SetConstructorAccessRights();
    [PureAttribute]
private AccessRights ConstructAccessRights();
    private void FindUsages(IProgressIndicator pi);
    private void AnalyzeReference(IReference reference);
    protected virtual ConstructorToFactoryMethodBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    public void CreateTypeParameters(IDeclaration declaration);
    public IType GetReturnType();
    public IType GetTypeOfImage(IType type);
    [CanBeNullAttribute]
private ITypeElement GetTypeImage(ITypeElement oldTypeElement);
    public IType GetTypeOfImageNoRight(IType type);
    [NotNullAttribute]
public string GetAllParameters();
    [NotNullAttribute]
private string GetModifierString(IParameter parameter);
    public void SetAccessRights(IDeclaration declaration);
    [NotNullAttribute]
public ISubstitution MakeSubstitution(ISubstitution substitution);
    public IDeclaration AddClassMember(IDeclaration declaration, IConstructor constructor);
    public void ProcessResolveResult(IReference reference, ResolveErrorType result, ISolution solution);
    public void ProcessResolveResultOfParameter(IParameter parameter, ResolveErrorType result);
    [CompilerGeneratedAttribute]
private StringBuilder <GetAllParameters>b__26_0(StringBuilder b, IParameter x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.Constructor2FactoryMethodWorkflow : DrivenRefactoringWorkflow {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDeclaredElementPointer`1<IConstructor> myConstructorPointer;
    [CompilerGeneratedAttribute]
private IDeclaredElement <FactoryMember>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Constructor2FactoryMethodDataProvider <DataProvider>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public bool HasUI { get; }
    [NullableAttribute("2")]
public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    [NullableAttribute("2")]
public IConstructor Constructor { get; }
    public IDeclaredElement FactoryMember { get; public set; }
    [NullableAttribute("2")]
public Constructor2FactoryMethodDataProvider DataProvider { get; public set; }
    public Constructor2FactoryMethodWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual bool get_HasUI();
    [NullableContextAttribute("2")]
public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    [NullableContextAttribute("2")]
public IConstructor get_Constructor();
    [CompilerGeneratedAttribute]
public IDeclaredElement get_FactoryMember();
    [CompilerGeneratedAttribute]
public void set_FactoryMember(IDeclaredElement value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Constructor2FactoryMethodDataProvider get_DataProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_DataProvider(Constructor2FactoryMethodDataProvider value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    private static bool IsAvailable(IDataContext context, IConstructor& constructor);
    public virtual bool Initialize(IDataContext context);
    public virtual bool Validate();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.Constructor2FactoryProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.ConstructorToFactoryMethodBase : RefactoringExecBase`2<Constructor2FactoryMethodWorkflow, Constructor2FactoryMethodRefactoring> {
    protected ConstructorToFactoryMethodBase(Constructor2FactoryMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool IsBaseConstructorInitializer(ITreeNode constructorUsageNode);
    public abstract virtual ITypeMember CreateFactoryMethodDeclaration(ITypeElement targetTypeElement, IConstructor constructorToCall, string factoryMethodName);
    public abstract virtual ITypeMember CreateSingleInstanceMemberDeclaration(ITypeElement targetTypeElement, IConstructor constructorToCall, string instancePropertyName);
    public abstract virtual void ConvertUsage(ITypeMember factoryMember, IReference reference);
    public virtual void ApplyCodeStyle(ITypeMember factoryMember);
    public virtual void TryAbstractMemberWithoutUsages(ITypeMember factoryMember);
    public abstract virtual string GetModifiersString(IParameter parameter);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.IConstructor2FactoryMethodExecuter {
}
public interface JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.IConstructor2FactoryWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.Convert.Constructor2FactoryMethod.Model.Constructor2FactoryMethodDataProvider : object {
    [CompilerGeneratedAttribute]
private string <FactoryMethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstancePropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeSingleInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSingleInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [NotNullAttribute]
public string FactoryMethodName { get; }
    [NotNullAttribute]
public string InstancePropertyName { get; }
    [CanBeNullAttribute]
public string TargetClassName { get; }
    public bool CanBeSingleInstance { get; }
    public bool UseSingleInstance { get; }
    public bool NonInteractive { get; }
    public Constructor2FactoryMethodDataProvider(string factoryMethodName, string targetClassName, bool useSingleInstance, bool hasUI);
    public Constructor2FactoryMethodDataProvider(IConstructor constructor, bool useSingleInstance, bool hasUI);
    [CompilerGeneratedAttribute]
public string get_FactoryMethodName();
    [CompilerGeneratedAttribute]
public string get_InstancePropertyName();
    [CompilerGeneratedAttribute]
public string get_TargetClassName();
    [CompilerGeneratedAttribute]
public bool get_CanBeSingleInstance();
    [CompilerGeneratedAttribute]
public bool get_UseSingleInstance();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NonInteractive();
    public static bool CanConstructorBeReplacedWithSingleInstance(IConstructor constructor);
    [NotNullAttribute]
[PureAttribute]
private static string SuggestFactoryName(ITypeElement containingClass, String[] words);
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.ConvertBase`3 : RefactoringExecBase`2<TWorkflow, TExecuter> {
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    protected IPsiServices PsiServices { get; }
    protected ConvertBase`3(TWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
protected IPsiServices get_PsiServices();
    public virtual String[] GetAllNames();
    public virtual void ExecuteReferencesRebinding(IReference reference);
    public virtual void SearchConflicts(IDeclaredElement convertedDeclaredElement, IProgressIndicator pi);
    protected virtual void AutoPropertyConflicts(IDeclaredElement element);
    public virtual void CheckConflictWithMethod(IMethod method, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    protected virtual bool AreEquals(string name1, string name2);
    public virtual void CheckConflictWithDecaredElement(IDeclaredElement declaration, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public virtual void CheckConflictWithProperty(IProperty property, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public abstract virtual bool InitialValidate();
    public virtual bool TryNewTypeDeclaration(IndexersSearchData data, IReference reference);
    public virtual void TryMakeConflictForNotExpression(IReference reference);
    public abstract virtual void ExecuteReferencesRefactoring(IReference reference);
    public abstract virtual void ExecuteDeclarationRefactoring(IDeclaredElement propertyOrMethod, IProgressIndicator progressIndicator);
    private void CheckConflitsWithTypeParameters(ITypeElement element);
    private void CheckConflictsWithTypeElement(IDeclaredElement convertedDeclaredElement, ITypeElement typeElement, bool isBase, bool isInheritor);
    protected virtual void CheckConflictWithClassName(ITypeElement element);
    protected bool CheckExistingPropertyConflicts(IProperty property, bool fromBase, bool isSuperClass, bool isGetter);
    protected bool TryAddConflicts(ITypeElement type, IProperty property, bool fromBase, bool isSuperClass, bool isGetter);
    protected virtual PropertySearchResultBase TestPropertyParameters(IProperty property);
    protected void FireRefactoringDetails(string name, object data);
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.ConvertBindingSearcher : object {
    private List`1<ReferenceBinding> myBindings;
    private JetHashSet`1<IDeclaredElement> myDeclaredElements;
    private String[] myNames;
    [CompilerGeneratedAttribute]
private bool <IsCaseSensitive>k__BackingField;
    public List`1<ReferenceBinding> Bindings { get; }
    public bool IsCaseSensitive { get; public set; }
    public bool ProcessingIsFinished { get; }
    public ConvertBindingSearcher(String[] names);
    public List`1<ReferenceBinding> get_Bindings();
    [CompilerGeneratedAttribute]
public bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public void set_IsCaseSensitive(bool value);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.ConvertHierarchyConflictTextProvider : HierarchyConflictTextProviderBase {
    public virtual string WillAlsoOverride();
    public virtual string WillAlsoImplement();
    public virtual string QuasiImplements();
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.ConvertMemberRefactoring`3 : ConvertRefactoring`3<TDeclaredElement, TWorkflow, TConvert> {
    private List`1<TDeclaredElement> myOverrides;
    public IEnumerable`1<TDeclaredElement> AllElements { get; }
    protected ConvertMemberRefactoring`3(TDeclaredElement declaredElement, TWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IEnumerable`1<TDeclaredElement> get_AllElements();
    protected virtual void CollectElements(IProgressIndicator pi);
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.ConvertRefactoring`3 : DrivenRefactoring`2<TWorkflow, TConvert> {
    protected TDeclaredElement myDeclaredElement;
    [CompilerGeneratedAttribute]
private IReference[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ReferenceBinding> <Bindings>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindDynamics>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<ITypeElement> <AllProcessedTypes>k__BackingField;
    protected IReference[] References { get; protected set; }
    private ICollection`1<ReferenceBinding> Bindings { get; private set; }
    protected IPsiServices PsiServices { get; }
    protected string Caption { get; }
    protected bool FindDynamics { get; protected set; }
    public JetHashSet`1<ITypeElement> AllProcessedTypes { get; }
    public IEnumerable`1<TDeclaredElement> AllElements { get; }
    protected ConvertRefactoring`3(TDeclaredElement declaredElement, TWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
protected IReference[] get_References();
    [CompilerGeneratedAttribute]
protected void set_References(IReference[] value);
    [CompilerGeneratedAttribute]
private ICollection`1<ReferenceBinding> get_Bindings();
    [CompilerGeneratedAttribute]
private void set_Bindings(ICollection`1<ReferenceBinding> value);
    [CompilerGeneratedAttribute]
protected IPsiServices get_PsiServices();
    protected abstract virtual string get_Caption();
    [CompilerGeneratedAttribute]
protected bool get_FindDynamics();
    [CompilerGeneratedAttribute]
protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FindDynamics(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual JetHashSet`1<ITypeElement> get_AllProcessedTypes();
    public sealed virtual void CheckConflictWithDecaredElement(IDeclaredElement element, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public sealed virtual void CheckConflictWithMethod(IMethod method, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public sealed virtual void CheckConflictWithProperty(IProperty property, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public virtual IEnumerable`1<TDeclaredElement> get_AllElements();
    public sealed virtual void TryMakeConflictForNotExpression(IReference reference);
    public virtual bool Execute(IProgressIndicator pi);
    public void IterateDeclarations(IProgressIndicator pi, Action`3<IConvertRefactoring, TDeclaredElement, IProgressIndicator> action);
    private static void ExecuteDeclarationRefactoring(IConvertRefactoring exec, TDeclaredElement member, IProgressIndicator pi);
    private static void SearchConflictInDeclaration(IConvertRefactoring exec, TDeclaredElement member, IProgressIndicator pi);
    public virtual void SearchReferences(IProgressIndicator pi);
    private void BindSuspeciousReferences(IProgressIndicator pi);
    private void BindReferencesFromType(IDeclaredElement element);
    public virtual void AddAdditionalElements(List`1<IDeclaredElement> declaredElementsToSearch, IProperty property);
    public void Rebind(SubProgressIndicator subPi);
    private void ExecuteReferencesRefactoring(IProgressIndicator pi);
    private void RebindReferences(IProgressIndicator pi);
    protected virtual void CollectElements(IProgressIndicator pi);
}
public static class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.ConvertRefactoringUtil : object {
    public static List`1<ElementOverride> FindOverrides(IOverridableMember member, ISolution solution, IProgressIndicator pi);
    public static string TryName(string name, String[] names, bool isCaseSensitive);
    public static OverridesAskResult CheckOverrides(string caption, string entetyName, NoAskModes askMode, IOverridableMember overridableDeclaredElement);
    private static bool AnalyzeCompiledOverrides(IEnumerable`1<OverridableMemberInstance> rootsOfOverrides);
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.ConvertSortSearcher : object {
    private OneToListMap`2<ITreeNode, IReference> myReferences;
    private ITreeNode myElement;
    private IReference myReferenceToSearch;
    private bool myElementWasFound;
    private bool myReferenceFound;
    public bool ReferenceFound { get; }
    public bool ProcessingIsFinished { get; }
    public ConvertSortSearcher(OneToListMap`2<ITreeNode, IReference> references, ITreeNode element, IReference referenceToSearch);
    public bool get_ReferenceFound();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.CreateAccessorDelegate`1 : MulticastDelegate {
    public CreateAccessorDelegate`1(object object, IntPtr method);
    public virtual TMethodDeclaration Invoke(bool hasBody, IProperty baseProperty, IAccessor accessor, string name, string pattern);
    public virtual IAsyncResult BeginInvoke(bool hasBody, IProperty baseProperty, IAccessor accessor, string name, string pattern, AsyncCallback callback, object object);
    public virtual TMethodDeclaration EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.ElementOverride : object {
    private bool isRoot;
    private IOverridableMember myMember;
    public IOverridableMember Member { get; }
    public bool IsRoot { get; }
    public ElementOverride(IOverridableMember member, bool isRoot);
    public IOverridableMember get_Member();
    public bool get_IsRoot();
    public sealed virtual bool Equals(ElementOverride elementOverride);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.IConvertConflictChecker {
    public abstract virtual void CheckConflictWithMethod(IMethod method, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public abstract virtual void CheckConflictWithDecaredElement(IDeclaredElement declaration, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public abstract virtual void CheckConflictWithProperty(IProperty property, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
}
public interface JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.IConvertRefactoring {
    public abstract virtual String[] GetAllNames();
    public abstract virtual void ExecuteReferencesRefactoring(IReference reference);
    public abstract virtual void ExecuteDeclarationRefactoring(IDeclaredElement element, IProgressIndicator progressIndicator);
    public abstract virtual void ExecuteReferencesRebinding(IReference reference);
    public abstract virtual void SearchConflicts(IDeclaredElement element, IProgressIndicator progressIndicator);
    public abstract virtual bool InitialValidate();
    public abstract virtual bool TryNewTypeDeclaration(IndexersSearchData data, IReference reference);
    public abstract virtual void TryMakeConflictForNotExpression(IReference reference);
}
public interface JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.IConvertRefactoringExecuter`1 {
    public JetHashSet`1<ITypeElement> AllProcessedTypes { get; }
    public IEnumerable`1<TDeclaredElement> AllElements { get; }
    public abstract virtual JetHashSet`1<ITypeElement> get_AllProcessedTypes();
    public abstract virtual IEnumerable`1<TDeclaredElement> get_AllElements();
    public abstract virtual void TryMakeConflictForNotExpression(IReference reference);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.NoAskModes : Enum {
    public int value__;
    public static NoAskModes NoAsk;
    public static NoAskModes Ask;
    public static NoAskModes YFromBase;
}
public enum JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.OverridesAskResult : Enum {
    public int value__;
    public static OverridesAskResult All;
    public static OverridesAskResult Stop;
    public static OverridesAskResult This;
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.Property2FunctionDeclarationProcessor`1 : object {
    private Property2FunctionDataModel myModel;
    [CompilerGeneratedAttribute]
private IList`1<IConflict> <Conflicts>k__BackingField;
    public IList`1<IConflict> Conflicts { get; }
    protected Property2FunctionDeclarationProcessor`1(Property2FunctionDataModel property2FunctionDataModel);
    [CompilerGeneratedAttribute]
public IList`1<IConflict> get_Conflicts();
    public void ConvertProperty(IProperty property, Property2FunctionWorkflow workflow, CreateAccessorDelegate`1<TMethodDeclaration> getterCreator, CreateAccessorDelegate`1<TMethodDeclaration> setterCreator);
    [NotNullAttribute]
protected virtual IProperty PreProcessProperty(IProperty property);
    [CanBeNullAttribute]
protected abstract virtual IProperty CreateFieldForAutoProperty(IProperty property);
    private void CopyDocComments(TMethodDeclaration getterDeclaration, TMethodDeclaration setterDeclaration, IDocCommentBlock docCommentBlock);
    protected virtual void FixCommentToGetter(IDocCommentBlockOwner owner);
    protected virtual void FixCommentToSetter(IDocCommentBlockOwner owner);
    protected abstract virtual void RemoveBaseDeclaration(IProperty property);
    protected abstract virtual TMethodDeclaration AddAccessor(TMethodDeclaration declaration, IProperty property);
    protected abstract virtual void RemoveSetter(IProperty property);
    protected abstract virtual void RemoveGetter(IProperty property);
    protected abstract virtual string GetterPattern(bool isAbstract, bool isInterface);
    protected abstract virtual string SetterPattern(bool isAbstract, bool isInterface, IProperty property);
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.Property2FunctionReferencesProcessor : object {
    protected Property2FunctionBase myRefactoring;
    protected Property2FunctionDataModel myModel;
    protected Property2FunctionReferencesProcessor(Property2FunctionBase refactoring, Property2FunctionWorkflow workflow);
    public abstract virtual void ReplaceReadOccurrence(IExpression expression);
    public abstract virtual bool ReplaceWriteProperty(IExpression expression, IReference reference);
    public abstract virtual bool ReplaceReadWriteOccurrence(IReference reference, IExpression expression);
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertMemberCommon.UnableToContinueConvertException : Exception {
    public UnableToContinueConvertException(string message);
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.ConvertedMemberInfo : object {
    [CompilerGeneratedAttribute]
private MemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeMember <Member>k__BackingField;
    public MemberTypes MemberTypes { get; public set; }
    public ITypeMember Member { get; }
    public ConvertedMemberInfo(MemberTypes memberTypes, ITypeMember memebr);
    [CompilerGeneratedAttribute]
public MemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public void set_MemberTypes(MemberTypes value);
    [CompilerGeneratedAttribute]
public ITypeMember get_Member();
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.ConvertTypeBase`2 : object {
    private IConvertTypeRefactoring myExecuter;
    private IRefactoringDriver myDriver;
    protected IConvertTypeRefactoring Executer { get; }
    protected IRefactoringDriver Driver { get; }
    public bool AllImplementationsAreExplicit { get; }
    unknown IRefactoringDriver RefactoringDriver {public set; }
    protected ConvertTypeBase`2(IRefactoringDriver driver);
    protected IConvertTypeRefactoring get_Executer();
    protected IRefactoringDriver get_Driver();
    public sealed virtual void SetExecuter(IConvertTypeRefactoring refactoring);
    public abstract virtual void CreateClassDeclaration(IInterface interfccc);
    public abstract virtual void RemoveDeclaration(IOverridableMember memebr);
    public abstract virtual void MakePublicOverride(IOverridableMember memebr, IDeclaredType declTypeToRemove);
    public abstract virtual void RemoveInterface(ITypeElement implementor, IInterface interfaceToRemove);
    public abstract virtual void AddInterface(ITypeElement typeElement, IExplicitImplementation interfaceToAdd);
    public abstract virtual void ImplementsMembersAbstract();
    public virtual bool get_AllImplementationsAreExplicit();
    public virtual void FixSignature(ITypeElement implementor, IInterface interface);
    public sealed virtual void set_RefactoringDriver(IRefactoringDriver value);
    protected void CollectImplementationsGroups(TClassDecl clsss, IList`1<ElementInstancePointer> elementPointers);
    private static IEnumerable`1<IType> GetInterfaces(IList`1<ElementInstancePointer> list);
    protected abstract virtual void MakePrivateImplementation(ElementInstancePointer pointer, TClassMemberDecl newDecl);
    protected abstract virtual IEnumerable`1<TClassMemberDecl> MakeAbstractDeclaration(TClassDecl clsss, ElementInstancePointer pointer, int indexForVB, IEnumerable`1<IType> lsitOfTypes, bool makePrivate);
    protected abstract virtual void MakeCallMoreGeneric(TClassDecl clsss, ElementInstancePointer memberCaller, ElementInstancePointer memberCallee, IType type);
    protected abstract virtual bool CanCallMoreGeneric(OverridableMemberInstance moreGenericInstance, OverridableMemberInstance lessGenericInstance, TClassDecl clsss);
    protected abstract virtual void Privatizate(TClassMemberDecl newDecl);
    public abstract virtual bool ProcessOverridableMember(IOverridableMember overridable, IProgressIndicator pi);
    public abstract virtual void MakePublic(IOverridableMember member);
    public abstract virtual bool MakeVirtual(IOverridableMember member);
    public abstract virtual void ProcessOtherMember(ITypeMember member);
    public abstract virtual void ReplaceMembers(IClass clsss);
    public virtual void AddInterfaceSpecificationToOverride(IOverridableMember over, IClass class);
    public virtual void AddImplementsSpecifications();
    public virtual void RemoveInherits(IClass clsss, IClass source);
    public virtual void AddImplements(IClass inheritor);
    public virtual bool IsSupported();
    protected static ISubstitution GetMatchedSubstitutionBack(IList`1<ITypeParameter> oldParameters, IList`1<ITypeParameter> newParameters);
    protected void AddSuperTypes(ITypeDeclaration to, ITypeElement toElement, ITypeDeclaration from);
    protected abstract virtual void AddSuperInterface(ITypeDeclaration to, IDeclaredType newSuprtType);
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.ConvertUnsupported : ConvertTypeBase`2<ITypeMemberDeclaration, ITypeDeclaration> {
    public ConvertUnsupported(IConvertTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void CreateClassDeclaration(IInterface interfccc);
    public virtual void RemoveDeclaration(IOverridableMember memebr);
    public virtual void MakePublicOverride(IOverridableMember memebr, IDeclaredType declTypeToRemove);
    public virtual void RemoveInterface(ITypeElement implementor, IInterface interfaceToRemove);
    public virtual void AddInterface(ITypeElement typeElement, IExplicitImplementation interfaceToAdd);
    public virtual void ImplementsMembersAbstract();
    protected virtual void MakePrivateImplementation(ElementInstancePointer pointer, ITypeMemberDeclaration newDecl);
    protected virtual IEnumerable`1<ITypeMemberDeclaration> MakeAbstractDeclaration(ITypeDeclaration clsss, ElementInstancePointer pointer, int indexForVB, IEnumerable`1<IType> lsitOfTypes, bool makePrivate);
    protected virtual void MakeCallMoreGeneric(ITypeDeclaration clsss, ElementInstancePointer memberCaller, ElementInstancePointer memberCallee, IType type);
    protected virtual bool CanCallMoreGeneric(OverridableMemberInstance moreGenericInstance, OverridableMemberInstance lessGenericInstance, ITypeDeclaration clsss);
    protected virtual void Privatizate(ITypeMemberDeclaration newDecl);
    public virtual bool ProcessOverridableMember(IOverridableMember overridable, IProgressIndicator pi);
    public virtual void MakePublic(IOverridableMember member);
    public virtual bool MakeVirtual(IOverridableMember member);
    public virtual void ProcessOtherMember(ITypeMember member);
    public virtual void ReplaceMembers(IClass clsss);
    public virtual bool IsSupported();
    protected virtual void AddSuperInterface(ITypeDeclaration to, IDeclaredType newSuprtType);
}
[ObsoleteAttribute("Use IElementInstancePointer instead, but fix GetHashCode & Equals in it")]
public class JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.ElementInstancePointer : object {
    private IDeclaredElementPointer`1<IDeclaredElement> myPointer;
    private ISubstitution mySubstitution;
    private int myHashCode;
    public ISubstitution Substitution { get; }
    public IDeclaredElement DeclaredElement { get; }
    public ElementInstancePointer(IDeclaredElement declaredElement, ISubstitution substitution);
    public ISubstitution get_Substitution();
    public IDeclaredElement get_DeclaredElement();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.GenericSignature : object {
    private string myName;
    private InvocableSignature mySignature;
    public GenericSignature(string name);
    public GenericSignature(InvocableSignature signature);
    public static GenericSignature Create(ITypeMember member, ISubstitution subst);
    public sealed virtual bool Equals(GenericSignature genericSignature);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.IConvert {
    public bool AllImplementationsAreExplicit { get; }
    public abstract virtual void SetExecuter(IConvertTypeRefactoring refactoring);
    public abstract virtual void CreateClassDeclaration(IInterface interfccc);
    public abstract virtual void RemoveDeclaration(IOverridableMember memebr);
    public abstract virtual void MakePublicOverride(IOverridableMember memebr, IDeclaredType declTypeToRemove);
    public abstract virtual void RemoveInterface(ITypeElement implementor, IInterface interfaceToRemove);
    public abstract virtual void AddInterface(ITypeElement typeElement, IExplicitImplementation interfaceToAdd);
    public abstract virtual void ImplementsMembersAbstract();
    public abstract virtual bool get_AllImplementationsAreExplicit();
    public abstract virtual void FixSignature(ITypeElement implementor, IInterface interface);
    public abstract virtual bool ProcessOverridableMember(IOverridableMember overridable, IProgressIndicator pi);
    public abstract virtual void MakePublic(IOverridableMember member);
    public abstract virtual bool MakeVirtual(IOverridableMember member);
    public abstract virtual void ProcessOtherMember(ITypeMember member);
    public abstract virtual void ReplaceMembers(IClass clsss);
    public abstract virtual void AddInterfaceSpecificationToOverride(IOverridableMember over, IClass class);
    public abstract virtual void AddImplementsSpecifications();
    public abstract virtual void RemoveInherits(IClass clsss, IClass source);
    public abstract virtual void AddImplements(IClass inheritor);
    public abstract virtual bool IsSupported();
}
public interface JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.IConvertTypeRefactoring {
}
public interface JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.IConvertTypeWorkflow {
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.InterfaceMembersCollectorBase : object {
    private bool myKeepAllExplicitlyImplemented;
    private JetHashSet`1<IDeclaredType> myVisitedInterfaceTypes;
    private JetHashSet`1<ITypeElement> myTypesChain;
    protected OneToListMap`2<OverridableMemberInfo, ElementInstancePointer> myResultWorkingSet;
    protected JetHashSet`1<OverridableMemberInfo> myNonMergableSignatures;
    protected List`1<ElementInstancePointer> myResult;
    private Dictionary`2<ElementInstancePointer, ITypeMember> myImplMap;
    protected InterfaceMembersCollectorBase(bool keepAllExplicitlyImplemented);
    private void CollectInterfaces(IDeclaredType declaredType, ISubstitution parentSubstitution, HashSet`1<OverridableMemberInstance> explImplemented);
    private void ProcessExplicitInterfaceImplementation(IOverridableMember overridableMember, HashSet`1& explImplemented);
    private void AddResult(IOverridableMember overridableMember, ISubstitution substitution);
    protected abstract virtual bool IsPrimaryTypeMember(ITypeMember overridableMember);
    private void SearchForImplementations(IEnumerable`1<ITypeMember> members, ISubstitution substitution, bool processingInheritedMembers);
    protected abstract virtual void ProcessPrivateImplementations(IOverridableMember overridableMember, ISubstitution substitution, OverridableMemberInfo overridableMemberInfo, bool processingInheritedMembers);
    protected bool OverridableMemberImplementsMemberInstance(ElementInstancePointer interfaceMemberInstance, IOverridableMember overridableMember, IType overridingCandidateType, IDeclaredType candidateQualifierType);
    private static bool MethodImplementsGenericMethod(IType expectedType, IList`1<ITypeParameter> implementingTypeParameters, IList`1<ITypeParameter> interfaceTypeParameters, IType candidateType);
    public IList`1<ElementInstancePointer> GetInterfaceMembers(ITypeDeclaration typeDeclaration);
    private void MergeImplementations();
    protected ITypeMember GetImplementation(ElementInstancePointer implementedMemberInstance);
    protected void AddImplementation(ElementInstancePointer implementedMemberInstance, ITypeMember implementation);
    public static IDeclaredType FindSuperClass(IDeclaredType type);
    public static IDeclaredType GetSuperClass(ITypeDeclaration typeDeclaration);
}
public enum JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.MemberTypes : Enum {
    public int value__;
    public static MemberTypes AbstractWithPrivate;
    public static MemberTypes AbstractAlone;
    public static MemberTypes PublicWithPrivate;
    public static MemberTypes PublicAlone;
    public static MemberTypes PrivateWithPublic;
    public static MemberTypes PrivateAlone;
}
public class JetBrains.ReSharper.Refactorings.Convert.ConvertTypeCommon.ProcessOverridableMemberDelegate : MulticastDelegate {
    public ProcessOverridableMemberDelegate(object object, IntPtr method);
    public virtual void Invoke(ITypeMember member);
    public virtual IAsyncResult BeginInvoke(ITypeMember member, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "MethodToIndexerActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Function2Indexer.Function2IndexerAction : ExtensibleRefactoringAction`1<IFunction2IndexerWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.Convert.Function2Indexer.Function2IndexerRefactoring : Function2PropertyRefactoring {
    protected string Caption { get; }
    public Function2IndexerRefactoring(Function2PropertyWorkflow workFlow, FunctionToPropertyDataProvider dataProvider, ISolution solution, IRefactoringDriver driver);
    protected virtual string get_Caption();
    protected virtual Function2PropertyBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
}
public class JetBrains.ReSharper.Refactorings.Convert.Function2Indexer.Function2IndexerWorkflow : Function2PropertyWorkflow {
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public Function2IndexerWorkflow(ISolution solution, string actionId);
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailableEx(IDataContext context, IMethod& method);
    protected bool CheckLanguage(IMethod method);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Function2Indexer.Function2IndexerWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Function2Indexer.IFunction2IndexerWorkflowProvider {
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "MethodToPropertyActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Function2Property.Function2PropertyAction : ExtensibleRefactoringAction`1<IFunction2PropertyWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.Function2Property.Function2PropertyBase : ConvertBase`3<IOverridableMember, Function2PropertyWorkflow, Function2PropertyRefactoring> {
    [NotNullAttribute]
protected IMethod Method;
    protected IType myPropertyType;
    protected IType myScalarType;
    protected Function2PropertyBase(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual String[] GetAllNames();
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement element, IProgressIndicator pi);
    protected abstract virtual void ProcessMethod(IDeclaredElement element);
    protected TPropertyDeclaration TryFindPropertyToComplete(IMethod method, ITypeElement containingType, Boolean& hasOverloads);
    protected virtual void MultiplePropertiesFound(IProperty property);
    protected virtual IEnumerable`1<ITypeMember> GetMembers(ITypeElement containingType, IMethod method);
    protected virtual PropertySearchResultBase TestPropertyParameters(IProperty property);
    private bool CompareProperties(IOverridableMember accessor, IMethod method);
    protected void RenameParameters(IMethod method, IProperty existingProperty);
    protected virtual void RenameParameter(IMethod method, IProperty existingProperty);
    protected abstract virtual bool CheckExplicitImplementationList(IOverridableMember accessor, IMethod method);
}
public class JetBrains.ReSharper.Refactorings.Convert.Function2Property.Function2PropertyRefactoring : ConvertMemberRefactoring`3<IOverridableMember, Function2PropertyWorkflow, Function2PropertyBase> {
    protected string Caption { get; }
    public Function2PropertyRefactoring(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual string get_Caption();
    protected virtual Function2PropertyBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    protected virtual Function2PropertyBase CreateUnsupportedRefactoring();
}
public class JetBrains.ReSharper.Refactorings.Convert.Function2Property.Function2PropertyWorkflow : DrivenRefactoringWorkflow {
    private IDeclaredElementPointer`1<IMethod> myMemberPointer;
    [CompilerGeneratedAttribute]
private FunctionToPropertyDataProvider <DataProvider>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public HelpId HelpKeyword { get; }
    public IMethod Method { get; protected set; }
    public FunctionToPropertyDataProvider DataProvider { get; private set; }
    public Function2PropertyWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual HelpId get_HelpKeyword();
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailable(IDataContext context, IMethod& method);
    public static bool IsAvailable(IMethod method);
    public virtual bool Initialize(IDataContext context);
    public IMethod get_Method();
    protected void set_Method(IMethod value);
    [CompilerGeneratedAttribute]
public FunctionToPropertyDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
private void set_DataProvider(FunctionToPropertyDataProvider value);
    public virtual bool Validate();
    public virtual void SetDataProvider(FunctionToPropertyDataProvider dataProvider);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Function2Property.Function2PropertyWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Convert.Function2Property.FunctionToPropertyPage : SingleBeRefactoringPage {
    private Function2PropertyWorkflow myWorkflow;
    private BeGrid myContent;
    [CompilerGeneratedAttribute]
private Property`1<string> <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <MakeDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeDefault>k__BackingField;
    public string Description { get; }
    public string Title { get; }
    public Property`1<string> PropertyName { get; }
    public IProperty`1<bool> MakeDefault { get; }
    public bool CanBeDefault { get; public set; }
    public FunctionToPropertyPage(Function2PropertyWorkflow workflow, Lifetime lifetime);
    public virtual string get_Description();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public Property`1<string> get_PropertyName();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_MakeDefault();
    [CompilerGeneratedAttribute]
public bool get_CanBeDefault();
    [CompilerGeneratedAttribute]
public void set_CanBeDefault(bool value);
    public virtual void Commit();
    public virtual BeControl GetPageContent();
}
public interface JetBrains.ReSharper.Refactorings.Convert.Function2Property.IFunction2PropertyWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.Convert.Function2Property.MethodReferencesBinder : object {
    private List`1<ReferenceBinding> myBindings;
    public bool ProcessingIsFinished { get; }
    public static List`1<ReferenceBinding> GetBindingsOfMethod(IMethod method);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.Convert.Function2Property.Model.FunctionToPropertyDataProvider : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeDefault>k__BackingField;
    public string PropertyName { get; }
    public bool MakeDefault { get; }
    public bool CanBeDefault { get; }
    public FunctionToPropertyDataProvider(IMethod method);
    public FunctionToPropertyDataProvider(string propertyNameValue, bool makeDefault);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public bool get_MakeDefault();
    [CompilerGeneratedAttribute]
public bool get_CanBeDefault();
    private string CreateNewInitialName(IMethod method, bool isGetter);
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.Function2Property.PropertySearchResultBase : object {
    public static PropertySearchResultBase Matched;
    public static PropertySearchResultBase MatchedWithParamsDiff;
    public static PropertySearchResultBase NotMatched;
    public static PropertySearchResultBase NotMatchedOverload;
    public static PropertySearchResultBase NotMatchedWrongDefault;
    public static PropertySearchResultBase NotMatchedOtherType;
    public static PropertySearchResultBase NotMatchedHasSetter;
    public static PropertySearchResultBase NotMatchedHasGetter;
    public static PropertySearchResultBase NotMatchedOfDefaultName;
    public bool IsMatched { get; }
    public bool IsDiffParamsModifiers { get; }
    public NotMatchedReasons NotMatchedReason { get; }
    private static PropertySearchResultBase();
    public abstract virtual bool get_IsMatched();
    public virtual bool get_IsDiffParamsModifiers();
    public virtual NotMatchedReasons get_NotMatchedReason();
}
public interface JetBrains.ReSharper.Refactorings.Convert.Indexer2Function.IIndexer2FunctionWorkflowProvider {
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "IndexerToMethodActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Indexer2Function.Indexer2FunctionAction : ExtensibleRefactoringAction`1<IIndexer2FunctionWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.Indexer2Function.Indexer2FunctionBase : Property2FunctionBase {
    protected Indexer2FunctionBase(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool TryTransformMethodCall(IExpression expression);
    public virtual void ProcessProperty(IDeclaredElement propertyOrMethod);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Indexer2Function.Indexer2FunctionProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Convert.Indexer2Function.Indexer2FunctionRefactoring : Property2FunctionRefactoring {
    protected string Caption { get; }
    public Indexer2FunctionRefactoring(Indexer2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual string get_Caption();
    private IndexersSearchData Search(IndexersSearchData data, IProgressIndicator pi);
    private void TryNewTypeDeclaration(IndexersSearchData data, IReference reference);
    private bool TryTypeMemberDeclaration(IndexersSearchData data, ITypeMemberDeclaration decl);
    private bool TryTypeMemberDeclaration(IndexersSearchData data, IReference reference);
    private bool TryFieldDeclaration(IndexersSearchData data, IReference reference);
    private static bool TryMemberReturnType(IType type, IndexersSearchData data);
    public IReference[] FindIndexers(IReadOnlyList`1<IOverridableMember> overrides, IProgressIndicator pi);
    public virtual void SearchReferences(IProgressIndicator pi);
    protected virtual Property2FunctionBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
}
public class JetBrains.ReSharper.Refactorings.Convert.Indexer2Function.Indexer2FunctionWorkflow : Property2FunctionWorkflow {
    public HelpId HelpKeyword { get; }
    public string Title { get; }
    public Indexer2FunctionWorkflow(ISolution solution, string actionId);
    public virtual HelpId get_HelpKeyword();
    public virtual string get_Title();
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailableEx(IDataContext context, IProperty& declaredElement);
    protected virtual bool CheckLanguage(IDeclaredElement element);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Convert.Indexer2Function.IndexersSearchData : object {
    private List`1<ITypeElement> myNewTypeElements;
    private JetHashSet`1<ITypeMemberDeclaration> myNewDeclarations;
    private JetHashSet`1<ISearchDomain> myAllDomains;
    private JetHashSet`1<IType> myAllTypeElements;
    public JetHashSet`1<ISearchDomain> AllDomains { get; }
    public List`1<IDeclaredElement> NewDeclarations { get; }
    public List`1<IDeclaredElement> NewIndexerDeclarations { get; }
    public bool HasNewTypes { get; }
    public List`1<ITypeElement> NewTypeElements { get; }
    public JetHashSet`1<IType> AllTypes { get; }
    public IndexersSearchData(List`1<ITypeElement> newTypeElements);
    public JetHashSet`1<ISearchDomain> get_AllDomains();
    public List`1<IDeclaredElement> get_NewDeclarations();
    public List`1<IDeclaredElement> get_NewIndexerDeclarations();
    public void AddDomain(ISearchDomain domain);
    public void AddDeclaration(ITypeMemberDeclaration decl);
    public bool get_HasNewTypes();
    public List`1<ITypeElement> get_NewTypeElements();
    public JetHashSet`1<IType> get_AllTypes();
    public void ClearTypeElements();
    public void ClearDeclaredElements();
    public void AddType(ITypeElement element);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Interface2Abstract.IInterface2AbstractExecuter {
}
public interface JetBrains.ReSharper.Refactorings.Convert.Interface2Abstract.IInterface2AbstractWorkflowProvider {
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "InterfaceToAbstractClassActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Interface2Abstract.Interface2AbstractAction : ExtensibleRefactoringAction`1<IInterface2AbstractWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Interface2Abstract.Interface2AbstractProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Convert.Interface2Abstract.Interface2AbstractRefactoring : object {
    private List`1<IReference> myStoredReferences;
    private List`1<ITypeElement> myImplementors;
    private JetHashSet`1<ITypeElement> myRootImplementors;
    private List`1<ConvertedMemberInfo> myMembers;
    private Dictionary`2<ITypeElement, JetHashSet`1<IExplicitImplementation>> myInheritor2SetOfInterfaces;
    private PsiLanguageType myLanguage;
    private List`1<Action> myPostActions;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private Interface2AbstractWorkflow <Workflow>k__BackingField;
    [CompilerGeneratedAttribute]
private LanguageMapOfRefactoring`1<IConvert> <Exec>k__BackingField;
    [CompilerGeneratedAttribute]
private IInterface <Interface>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    public IList`1<Action> PostActions { get; }
    public IRefactoringDriver Driver { get; }
    public ISolution Solution { get; }
    public Interface2AbstractWorkflow Workflow { get; }
    public LanguageMapOfRefactoring`1<IConvert> Exec { get; }
    public IInterface Interface { get; }
    public IPsiServices PsiServices { get; }
    public IEnumerable`1<ITypeElement> NotRootImplementors { get; }
    public Interface2AbstractRefactoring(Interface2AbstractWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    public IList`1<Action> get_PostActions();
    [CompilerGeneratedAttribute]
public IRefactoringDriver get_Driver();
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    [CompilerGeneratedAttribute]
public Interface2AbstractWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
public LanguageMapOfRefactoring`1<IConvert> get_Exec();
    [CompilerGeneratedAttribute]
public IInterface get_Interface();
    [CompilerGeneratedAttribute]
public IPsiServices get_PsiServices();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Convert.Interface2Abstract.Interface2AbstractRefactoring/<get_NotRootImplementors>d__28")]
public IEnumerable`1<ITypeElement> get_NotRootImplementors();
    public sealed virtual bool Execute(IProgressIndicator pi);
    private void FixImplementsToInherits();
    private void ImplementsMembersAbstract();
    private void FixInheritorsImplementedInterfaces();
    private void AnalyseBaseInterfaces(IProgressIndicator pi);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Convert.Interface2Abstract.Interface2AbstractRefactoring/<GetAllSuperInterfaces>d__36")]
private static IEnumerable`1<IInterface> GetAllSuperInterfaces(IInterface current, ICollection`1<IInterface> fixerSet);
    private void RemoveInterfaceFromNotRoots();
    private void ProcessOverrides();
    private void ReplaceInterfaceDeclarations();
    private void ProcessInterfaceMembers(IProgressIndicator pi);
    private void ProcessInterfaceMember(IOverridableMember overridableMember, IProgressIndicator pi, ICollection`1<ConvertedMemberInfo> memberList, bool checkForQuazi, bool makeVirtual);
    private void SelectRootImplementors();
    private void FindInheritors(IProgressIndicator pi);
    private void FindUsages(IProgressIndicator pi);
    private IConvert CreateRefactoring(InternalRefactoringLanguageService service);
}
public class JetBrains.ReSharper.Refactorings.Convert.Interface2Abstract.Interface2AbstractWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<IInterface> <InterfacePointer>k__BackingField;
    public IDeclaredElementPointer`1<IInterface> InterfacePointer { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public Interface2AbstractWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<IInterface> get_InterfacePointer();
    [CompilerGeneratedAttribute]
private void set_InterfacePointer(IDeclaredElementPointer`1<IInterface> value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual bool Validate();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
}
public static class JetBrains.ReSharper.Refactorings.Convert.Property2Auto.AccessCompareUtil : object {
    [PureAttribute]
private static int Rating(AccessRights accessRights);
    [PureAttribute]
public static AccessRights Max(AccessRights rights1, AccessRights rights2);
    [PureAttribute]
public static AccessRights Min(AccessRights rights1, AccessRights rights2);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Property2Auto.IProperty2AutoChecker {
    public abstract virtual bool IsPropertyWithBackingField(IProperty property, IField& backingField);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Property2Auto.IProperty2AutoWorkflowProvider {
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "PropertyToAutoPropertyActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Property2Auto.Property2AutoAction : ExtensibleRefactoringAction`1<IProperty2AutoWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.Property2Auto.Property2AutoBase : RefactoringExecBase`2<Property2AutoWorkflow, Property2AutoRefactoring> {
    protected Property2AutoBase(Property2AutoWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual void TransformDeclaration();
    public abstract virtual void RemoveFieldDeclaration();
    public abstract virtual void BindUsage(IReference reference);
    public virtual void FinishBindingUsages();
    public abstract virtual void ExpandInitializerToAssignments();
    public abstract virtual void CheckAccessInStructConstructorDeclaration(IReference reference);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Property2Auto.Property2AutoProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Convert.Property2Auto.Property2AutoRefactoring : DrivenRefactoring`2<Property2AutoWorkflow, Property2AutoBase> {
    [CompilerGeneratedAttribute]
private IField <BackingField>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MayBeMutableStruct>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPolymorphicProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRights <PropertyAccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRights <SetterAccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRights <GetterAccessRights>k__BackingField;
    [CanBeNullAttribute]
public IField BackingField { get; private set; }
    public IProperty Property { get; private set; }
    public ITypeElement ContainingType { get; private set; }
    public bool MayBeMutableStruct { get; private set; }
    public bool IsPolymorphicProperty { get; private set; }
    public AccessRights PropertyAccessRights { get; private set; }
    public AccessRights SetterAccessRights { get; private set; }
    public AccessRights GetterAccessRights { get; private set; }
    public Property2AutoRefactoring(Property2AutoWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public IField get_BackingField();
    [CompilerGeneratedAttribute]
private void set_BackingField(IField value);
    [CompilerGeneratedAttribute]
public IProperty get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(IProperty value);
    [CompilerGeneratedAttribute]
public ITypeElement get_ContainingType();
    [CompilerGeneratedAttribute]
private void set_ContainingType(ITypeElement value);
    [CompilerGeneratedAttribute]
public bool get_MayBeMutableStruct();
    [CompilerGeneratedAttribute]
private void set_MayBeMutableStruct(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPolymorphicProperty();
    [CompilerGeneratedAttribute]
private void set_IsPolymorphicProperty(bool value);
    [CompilerGeneratedAttribute]
public AccessRights get_PropertyAccessRights();
    [CompilerGeneratedAttribute]
private void set_PropertyAccessRights(AccessRights value);
    [CompilerGeneratedAttribute]
public AccessRights get_SetterAccessRights();
    [CompilerGeneratedAttribute]
private void set_SetterAccessRights(AccessRights value);
    [CompilerGeneratedAttribute]
public AccessRights get_GetterAccessRights();
    [CompilerGeneratedAttribute]
private void set_GetterAccessRights(AccessRights value);
    public virtual bool Execute(IProgressIndicator pi);
    private bool Initialize();
    private void AnalyzeAccessibility();
    private void InheritAccessRightsFromOverridden(IProperty overriddenProperty);
    private void ExpandInitializerToAssignment();
    private void TransformPropertyDeclaration();
    private void RemoveFieldDeclaration();
    [NotNullAttribute]
private IReference[] FindBackingFieldUsages(IProgressIndicator pi);
    private void UpdateBackingFieldUsages(IReference[] references, IProgressIndicator pi);
    protected virtual Property2AutoBase CreateUnsupportedRefactoring();
    protected virtual Property2AutoBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
}
public class JetBrains.ReSharper.Refactorings.Convert.Property2Auto.Property2AutoUnsupported : Property2AutoBase {
    public Property2AutoUnsupported(Property2AutoWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void TransformDeclaration();
    public virtual void RemoveFieldDeclaration();
    public virtual void ExpandInitializerToAssignments();
    public virtual void BindUsage(IReference reference);
    public virtual void CheckAccessInStructConstructorDeclaration(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.Convert.Property2Auto.Property2AutoWorkflow : DrivenRefactoringWorkflow {
    [CanBeNullAttribute]
private IDeclaredElementPointer`1<IProperty> myProperty;
    [CanBeNullAttribute]
private IDeclaredElementPointer`1<IField> myBackingField;
    public string Title { get; }
    [CanBeNullAttribute]
public IProperty Property { get; }
    [CanBeNullAttribute]
public IField BackingField { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public Property2AutoWorkflow(ISolution solution, string actionId);
    public virtual string get_Title();
    public IProperty get_Property();
    public IField get_BackingField();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual HelpId get_HelpKeyword();
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    private bool IsAvailable(IDataContext context, bool initialize);
    public virtual bool PostExecute(IProgressIndicator pi);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Property2Function.IProperty2Function {
    public abstract virtual void ExecuteReferencesRefactoring(IReference reference);
    public abstract virtual void ExecuteDeclarationRefactoring(IDeclaredElement propertyOrMethod, IProgressIndicator pi, bool ifConflict);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Property2Function.IProperty2FunctionWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.Convert.Property2Function.Model.Property2FunctionDataModel : object {
    [CompilerGeneratedAttribute]
private string <GetterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SetterName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConvertGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConvertSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty <Member>k__BackingField;
    public string GetterName { get; }
    public string SetterName { get; }
    public bool ConvertGetter { get; }
    public bool ConvertSetter { get; }
    public IProperty Member { get; }
    public Property2FunctionDataModel(IProperty member, PropertyToFunctionDataProvider dataProvider);
    [CompilerGeneratedAttribute]
public string get_GetterName();
    [CompilerGeneratedAttribute]
public string get_SetterName();
    [CompilerGeneratedAttribute]
public bool get_ConvertGetter();
    [CompilerGeneratedAttribute]
public bool get_ConvertSetter();
    [CompilerGeneratedAttribute]
public IProperty get_Member();
}
public class JetBrains.ReSharper.Refactorings.Convert.Property2Function.Model.PropertyToFunctionDataProvider : object {
    [CompilerGeneratedAttribute]
private string <GetterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SetterName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConvertGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConvertSetter>k__BackingField;
    public string GetterName { get; }
    public string SetterName { get; }
    public bool ConvertGetter { get; }
    public bool ConvertSetter { get; }
    public PropertyToFunctionDataProvider(string getterName, string setterName, bool convertGetter, bool convertSetter);
    public PropertyToFunctionDataProvider(IProperty property);
    [CompilerGeneratedAttribute]
public string get_GetterName();
    [CompilerGeneratedAttribute]
public string get_SetterName();
    [CompilerGeneratedAttribute]
public bool get_ConvertGetter();
    [CompilerGeneratedAttribute]
public bool get_ConvertSetter();
}
[ActionAttribute("Property2Function", "JetBrains.ReSharper.Refactorings.Resources.Strings", "PropertyToMethodSActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Property2Function.Property2FunctionAction : ExtensibleRefactoringAction`1<IProperty2FunctionWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.Property2Function.Property2FunctionBase : ConvertBase`3<IOverridableMember, Property2FunctionWorkflow, Property2FunctionRefactoring> {
    protected Property2FunctionDataModel myModel;
    protected Property2FunctionReferencesProcessor myReferencesProcessor;
    protected Property2FunctionBase(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual String[] GetAllNames();
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement propertyOrMethod, IProgressIndicator pi);
    public virtual bool InitialValidate();
    public virtual void ExecuteReferencesRefactoring(IReference reference);
    protected virtual bool SkipIndexerReference(IReference reference);
    public virtual bool TryTransformReadWriteProperty(IReference reference, IExpression expression);
    public virtual void CheckConflictWithMethod(IMethod method, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    private bool TryTransformReadProperty(IExpression expression);
    private bool TryTransformWriteProperty(IReference reference);
    public virtual bool TryTransformMethodCall(IExpression expression);
    public abstract virtual void ProcessProperty(IDeclaredElement propertyOrMethod);
    public virtual void ReplaceReadOccurrence(IExpression expression);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Property2Function.Property2FunctionProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Convert.Property2Function.Property2FunctionRefactoring : ConvertMemberRefactoring`3<IOverridableMember, Property2FunctionWorkflow, Property2FunctionBase> {
    private Property2FunctionDataModel myDataModel;
    protected string Caption { get; }
    public Property2FunctionRefactoring(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual string get_Caption();
    public virtual void AddAdditionalElements(List`1<IDeclaredElement> declaredElementsToSearch, IProperty property);
    protected virtual Property2FunctionBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    protected virtual Property2FunctionBase CreateUnsupportedRefactoring();
}
public class JetBrains.ReSharper.Refactorings.Convert.Property2Function.Property2FunctionWorkflow : DrivenRefactoringWorkflow {
    private IDeclaredElementPointer`1<IProperty> myPointer;
    [CompilerGeneratedAttribute]
private PropertyToFunctionDataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Property2FunctionDataModel <Model>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public HelpId HelpKeyword { get; }
    public PropertyToFunctionDataProvider DataProvider { get; public set; }
    [CanBeNullAttribute]
public IProperty Member { get; public set; }
    public Property2FunctionDataModel Model { get; private set; }
    public Property2FunctionWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public PropertyToFunctionDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
public void set_DataProvider(PropertyToFunctionDataProvider value);
    public IProperty get_Member();
    public void set_Member(IProperty value);
    public virtual bool IsAvailable(IDataContext context);
    private static bool IsAvailable(IDataContext context, IProperty& property);
    public static bool IsAvailable(IProperty property);
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    [CompilerGeneratedAttribute]
public Property2FunctionDataModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(Property2FunctionDataModel value);
    public virtual bool Validate();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Convert.Property2Function.PropertyToFunctionPage : SingleBeRefactoringPage {
    private Property2FunctionWorkflow myWorkflow;
    private BeSpanGrid myContent;
    [CompilerGeneratedAttribute]
private Property`1<string> <GetterName>k__BackingField;
    [CompilerGeneratedAttribute]
private Property`1<string> <SetterName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <ConvertGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <ConvertSetter>k__BackingField;
    public string Title { get; }
    public string Description { get; }
    public Property`1<string> GetterName { get; public set; }
    public Property`1<string> SetterName { get; public set; }
    public IProperty`1<bool> ConvertGetter { get; public set; }
    public IProperty`1<bool> ConvertSetter { get; public set; }
    public PropertyToFunctionPage(Property2FunctionWorkflow workflow, Lifetime lifetime);
    public virtual string get_Title();
    public virtual string get_Description();
    [CompilerGeneratedAttribute]
public Property`1<string> get_GetterName();
    [CompilerGeneratedAttribute]
public void set_GetterName(Property`1<string> value);
    [CompilerGeneratedAttribute]
public Property`1<string> get_SetterName();
    [CompilerGeneratedAttribute]
public void set_SetterName(Property`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_ConvertGetter();
    [CompilerGeneratedAttribute]
public void set_ConvertGetter(IProperty`1<bool> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_ConvertSetter();
    [CompilerGeneratedAttribute]
public void set_ConvertSetter(IProperty`1<bool> value);
    public virtual BeControl GetPageContent();
    public virtual void Commit();
}
[ActionAttribute("Extension2StaticAction", "JetBrains.ReSharper.Refactorings.Resources.Strings", "ExtensionMethodToPlainStaticActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Static2Extension.Extension2StaticAction : ExtensibleRefactoringAction`1<IExtension2StaticWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Static2Extension.Extension2StaticProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Static2Extension.IExtension2StaticWorkflowProvider {
}
public interface JetBrains.ReSharper.Refactorings.Convert.Static2Extension.IStatic2ExtensionWorkflowProvider {
}
[ActionAttribute("Static2ExtensionAction", "JetBrains.ReSharper.Refactorings.Resources.Strings", "StaticToExtensionMethodActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Static2Extension.Static2ExtensionAction : ExtensibleRefactoringAction`1<IStatic2ExtensionWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.Static2Extension.Static2ExtensionBase : RefactoringExecBase`2<Static2ExtensionWorkflow, Static2ExtensionRefactoring> {
    protected Static2ExtensionBase(Static2ExtensionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual void MakeCallExtension(IReference reference);
    public abstract virtual void MakeCallPlainStatic(IReference reference);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Static2Extension.Static2ExtensionProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Convert.Static2Extension.Static2ExtensionRefactoring : DrivenRefactoring`2<Static2ExtensionWorkflow, Static2ExtensionBase> {
    private List`1<IReferencePointer> myReferencePointers;
    private Direction myDirection;
    [CompilerGeneratedAttribute]
private IMethod <Method>k__BackingField;
    public IMethod Method { get; private set; }
    public Static2ExtensionRefactoring(Static2ExtensionWorkflow workflow, ISolution solution, IRefactoringDriver driver, Direction direction);
    [CompilerGeneratedAttribute]
public IMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(IMethod value);
    public virtual bool Execute(IProgressIndicator pi);
    private void MakeCallPlainStatic();
    private void MakeCallExtension();
    private void Transform2Extention();
    private void Transform2Static();
    private void FindUsages(IProgressIndicator pi);
    protected virtual Static2ExtensionBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    protected virtual Static2ExtensionBase CreateUnsupportedRefactoring();
}
public class JetBrains.ReSharper.Refactorings.Convert.Static2Extension.Static2ExtensionWorkflow : DrivenRefactoringWorkflow {
    private Direction myDirection;
    private IDeclaredElementPointer`1<IMethod> myMethod;
    public IMethod Method { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public Static2ExtensionWorkflow(ISolution solution, Direction direction, string actionId);
    public IMethod get_Method();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual string get_Title();
    public virtual bool IsAvailable(IDataContext context);
    [ContractAnnotationAttribute("=> false, method: null; => true, method: notnull")]
private bool IsAvailable(IDataContext context, IMethod& method);
    [CanBeNullAttribute]
public static IMethod IsAvailable(IDeclaredElement declaredElement, Direction direction);
    public virtual HelpId get_HelpKeyword();
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool Validate();
    public virtual bool get_MightModifyManyDocuments();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
}
public abstract class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.ContextProviders.Type2PartialContextProviderBase`1 : object {
    [CompilerGeneratedAttribute]
private ILanguageMapOfWorkflow`1<THelper> <Helper>k__BackingField;
    protected ILanguageMapOfWorkflow`1<THelper> Helper { get; }
    protected Type2PartialContextProviderBase`1(ILanguageMapOfWorkflow`1<THelper> helper);
    [CompilerGeneratedAttribute]
protected ILanguageMapOfWorkflow`1<THelper> get_Helper();
    protected bool ValidateOwnerType(ITypeElement ownerType, IPsiSourceFile psiSourceFile);
}
internal class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.ContextProviders.Type2PartialFileStructureContextProvider : Type2PartialContextProviderBase`1<IType2PartialHelper> {
    public Type2PartialFileStructureContextProvider(ILanguageMapOfWorkflow`1<IType2PartialHelper> helper);
    [CanBeNullAttribute]
public Type2PartialContext GetWorkflowContext(IList`1<TreeModelNode> treeModelNodes);
    [CanBeNullAttribute]
private static IList`1<Pair`2<IDeclaration, IDeclaredElement>> FilterSelectedFileStructureNodes(ITypeElement ownerType, IList`1<Pair`2<IDeclaration, IDeclaredElement>> selectedElementPairs);
    [CanBeNullAttribute]
private static Type2PartialFileLayoutInfo GetFileLayoutInfo(IList`1<TreeModelNode> treeModelNodes);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IList`1<TreeModelNode> CollectTreeModelNodesInRegion(TreeModelNode singleNode);
}
internal abstract class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.ContextProviders.Type2PartialProjectModelContextProviderBase : Type2PartialContextProviderBase`1<IType2PartialHelper> {
    protected Type2PartialProjectModelContextProviderBase(ILanguageMapOfWorkflow`1<IType2PartialHelper> helper);
    [CanBeNullAttribute]
public Type2PartialContext GetWorkflowContext(ITextControl textControl, IDataContext context);
    [NotNullAttribute]
protected abstract virtual Type2PartialSelectionInfo GetSelectionInfo(IDataContext context);
    [CanBeNullAttribute]
protected abstract virtual IDeclaration GetOwnerTypeDeclaration(ITypeElement ownerType, IPsiSourceFile psiSourceFile);
    protected abstract virtual bool IsValidDeclaration(ITypeElement ownerType, IDeclaration declaration);
    protected abstract virtual bool ProcessAdditionalChecks(IPsiSourceFile psiSourceFile, IReadOnlyList`1<IDeclaration> selectedDeclarations);
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<IDeclaredElement> FilterDeclaredElements(ITypeElement ownerType, IReadOnlyList`1<IDeclaredElement> elements);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<IDeclaration> FilterDeclarations(IReadOnlyList`1<IDeclaredElement> elements, IPsiSourceFile psiSourceFile, ITypeElement ownerType);
}
internal class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.ContextProviders.Type2PartialSelectionContextProvider : Type2PartialProjectModelContextProviderBase {
    [CompilerGeneratedAttribute]
private DocumentRange <documentSelection>P;
    public Type2PartialSelectionContextProvider(ILanguageMapOfWorkflow`1<IType2PartialHelper> helper, DocumentRange documentSelection);
    protected virtual Type2PartialSelectionInfo GetSelectionInfo(IDataContext context);
    [NotNullAttribute]
private IEnumerable`1<IFile> GetPsiFilesFromDocument(ISolution solution);
    protected virtual IDeclaration GetOwnerTypeDeclaration(ITypeElement ownerType, IPsiSourceFile psiSourceFile);
    protected virtual bool ProcessAdditionalChecks(IPsiSourceFile psiSourceFile, IReadOnlyList`1<IDeclaration> selectedDeclarations);
    protected virtual bool IsValidDeclaration(ITypeElement ownerType, IDeclaration declaration);
    [CompilerGeneratedAttribute]
private bool <GetOwnerTypeDeclaration>b__4_0(IDeclaration declaration);
}
internal class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.ContextProviders.Type2PartialSolutionExplorerContextProvider : Type2PartialProjectModelContextProviderBase {
    public Type2PartialSolutionExplorerContextProvider(ILanguageMapOfWorkflow`1<IType2PartialHelper> helper);
    protected virtual Type2PartialSelectionInfo GetSelectionInfo(IDataContext context);
    protected virtual IDeclaration GetOwnerTypeDeclaration(ITypeElement ownerType, IPsiSourceFile psiSourceFile);
    protected virtual bool ProcessAdditionalChecks(IPsiSourceFile psiSourceFile, IReadOnlyList`1<IDeclaration> selectedDeclarations);
    protected virtual bool IsValidDeclaration(ITypeElement ownerType, IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Data.Type2PartialContext : object {
    [CompilerGeneratedAttribute]
private ITypeElement <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedPartName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaration <SelectedTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextControl <TextControl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IDeclaration> <SelectedDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <PsiSourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <ProjectFolder>k__BackingField;
    [NotNullAttribute]
public ITypeElement OwnerType { get; }
    [NotNullAttribute]
public string SelectedPartName { get; }
    [NotNullAttribute]
public IDeclaration SelectedTypeDeclaration { get; }
    [CanBeNullAttribute]
public ITextControl TextControl { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IDeclaration> SelectedDeclarations { get; }
    [NotNullAttribute]
public IPsiSourceFile PsiSourceFile { get; }
    [NotNullAttribute]
public IProjectFile ProjectFile { get; }
    [NotNullAttribute]
public IProjectFolder ProjectFolder { get; }
    public Type2PartialContext(ITypeElement ownerType, IDeclaration selectedTypeDeclaration, ITextControl textControl, IReadOnlyList`1<IDeclaration> selectedDeclarations, IPsiSourceFile psiSourceFile, IProjectFile projectFile, IProjectFolder projectFolder, string selectedPartName);
    [CompilerGeneratedAttribute]
public ITypeElement get_OwnerType();
    [CompilerGeneratedAttribute]
public string get_SelectedPartName();
    [CompilerGeneratedAttribute]
public IDeclaration get_SelectedTypeDeclaration();
    [CompilerGeneratedAttribute]
public ITextControl get_TextControl();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IDeclaration> get_SelectedDeclarations();
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_PsiSourceFile();
    [CompilerGeneratedAttribute]
public IProjectFile get_ProjectFile();
    [CompilerGeneratedAttribute]
public IProjectFolder get_ProjectFolder();
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Data.Type2PartialDataModel : object {
    [CompilerGeneratedAttribute]
private IDeclaration <TypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaration <SelectedExistingPart>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <CreatedFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDeclaration> <SelectedTypeMembers>k__BackingField;
    [CanBeNullAttribute]
private ITreeNodePointer`1<ITypeDeclaration> myCreatedDeclaration;
    public IDeclaration TypeDeclaration { get; }
    [CanBeNullAttribute]
public ITypeDeclaration CreatedDeclaration { get; public set; }
    [CanBeNullAttribute]
public IDeclaration SelectedExistingPart { get; }
    [CanBeNullAttribute]
public IProjectFile CreatedFile { get; public set; }
    public IList`1<IDeclaration> SelectedTypeMembers { get; }
    public Type2PartialDataModel(IDeclaration typeDeclaration, IDeclaration selectedExistingPart, IList`1<IDeclaration> selectedTypeMembers, IProjectFile createdFile);
    [CompilerGeneratedAttribute]
public IDeclaration get_TypeDeclaration();
    public ITypeDeclaration get_CreatedDeclaration();
    public void set_CreatedDeclaration(ITypeDeclaration value);
    [CompilerGeneratedAttribute]
public IDeclaration get_SelectedExistingPart();
    [CompilerGeneratedAttribute]
public IProjectFile get_CreatedFile();
    [CompilerGeneratedAttribute]
public void set_CreatedFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public IList`1<IDeclaration> get_SelectedTypeMembers();
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Data.Type2PartialFileLayoutInfo : object {
    [CompilerGeneratedAttribute]
private IList`1<Pair`2<IDeclaration, IDeclaredElement>> <SelectedElements>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedPartName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRegionSelected>k__BackingField;
    [NotNullAttribute]
public IList`1<Pair`2<IDeclaration, IDeclaredElement>> SelectedElements { get; }
    [NotNullAttribute]
public string SelectedPartName { get; }
    public bool IsRegionSelected { get; }
    public Type2PartialFileLayoutInfo(IList`1<Pair`2<IDeclaration, IDeclaredElement>> selectedElements, string selectedPartName, bool isRegionSelected);
    [CompilerGeneratedAttribute]
public IList`1<Pair`2<IDeclaration, IDeclaredElement>> get_SelectedElements();
    [CompilerGeneratedAttribute]
public string get_SelectedPartName();
    [CompilerGeneratedAttribute]
public bool get_IsRegionSelected();
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Data.Type2PartialMemberElement : DeclaredElementNode {
    private ITreeNodePointer`1<IDeclaration> myDeclarationPointer;
    private IDeclaration myDeclaration;
    private bool myIsMember;
    [CompilerGeneratedAttribute]
private Nullable`1<DocumentCoords> <DocumentCoords>k__BackingField;
    public IDeclaration Declaration { get; }
    public Nullable`1<DocumentCoords> DocumentCoords { get; }
    public Type2PartialMemberElement(IDeclaration declaration, Nullable`1<DocumentCoords> documentCoords, bool isMember);
    public IDeclaration get_Declaration();
    [CompilerGeneratedAttribute]
public Nullable`1<DocumentCoords> get_DocumentCoords();
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Data.Type2PartialModel : object {
    [CompilerGeneratedAttribute]
private IProjectFile <OriginalFile>k__BackingField;
    [NotNullAttribute]
private ITreeNodePointer`1<IDeclaration> myTypeDeclarationPointer;
    [NotNullAttribute]
private ITreeNodePointer`1<IDeclaration> myExistingPart;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<IDeclaration> <ExistingPart>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IProjectModelElement> <SelectionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IProjectFile, bool> <SuggestionFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <DefaultSourceFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type2PartialMemberElement> <TypeMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ITreeNodePointer`1<IDeclaration>> <AvailableExistingDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <CreatedFile>k__BackingField;
    [NotNullAttribute]
public IProjectFile OriginalFile { get; }
    public string FilePath { get; public set; }
    public ITreeNodePointer`1<IDeclaration> ExistingPart { get; public set; }
    public IList`1<IDeclaration> Elements { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<IProjectModelElement> SelectionScope { get; }
    [NotNullAttribute]
public Func`2<IProjectFile, bool> SuggestionFilter { get; }
    [NotNullAttribute]
public IProjectFolder DefaultSourceFolder { get; }
    public string DefaultFilePath { get; public set; }
    [CanBeNullAttribute]
public IDeclaration TypeDeclaration { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<Type2PartialMemberElement> TypeMembers { get; }
    [NotNullAttribute]
public List`1<ITreeNodePointer`1<IDeclaration>> AvailableExistingDeclarations { get; }
    [CanBeNullAttribute]
public IProjectFile CreatedFile { get; public set; }
    public Type2PartialModel(Type2PartialContext workflowContext, Func`2<IProjectFile, bool> suggestionFilter, Lifetime lifetime, string extension);
    [CompilerGeneratedAttribute]
public IProjectFile get_OriginalFile();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public ITreeNodePointer`1<IDeclaration> get_ExistingPart();
    [CompilerGeneratedAttribute]
public void set_ExistingPart(ITreeNodePointer`1<IDeclaration> value);
    public IList`1<IDeclaration> get_Elements();
    [CompilerGeneratedAttribute]
public IList`1<IProjectModelElement> get_SelectionScope();
    [CompilerGeneratedAttribute]
public Func`2<IProjectFile, bool> get_SuggestionFilter();
    [CompilerGeneratedAttribute]
public IProjectFolder get_DefaultSourceFolder();
    [CompilerGeneratedAttribute]
public string get_DefaultFilePath();
    [CompilerGeneratedAttribute]
public void set_DefaultFilePath(string value);
    public IDeclaration get_TypeDeclaration();
    [CompilerGeneratedAttribute]
public IList`1<Type2PartialMemberElement> get_TypeMembers();
    [CompilerGeneratedAttribute]
public List`1<ITreeNodePointer`1<IDeclaration>> get_AvailableExistingDeclarations();
    [CompilerGeneratedAttribute]
public IProjectFile get_CreatedFile();
    [CompilerGeneratedAttribute]
public void set_CreatedFile(IProjectFile value);
    private string GetDefaultFilePath(Type2PartialContext workflowContext, ICollection`1<ITreeNodePointer`1<IDeclaration>> selectedTypeMembers, IProjectFolder projectFolder, string extension);
    [NotNullAttribute]
public static string PresentProjectFolder(IProjectFolder projectFolder);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<ITreeNodePointer`1<IDeclaration>> CollectAvailableTypeDeclarations(Type2PartialContext workflowContext);
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Data.Type2PartialSelectionInfo : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IDeclaredElement> <SelectedElements>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedPartName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRegionSelected>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IDeclaredElement> SelectedElements { get; }
    [NotNullAttribute]
public string SelectedPartName { get; }
    public bool IsRegionSelected { get; }
    public Type2PartialSelectionInfo(IReadOnlyList`1<IDeclaredElement> selectedElements, string selectedPartName, bool isRegionSelected);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IDeclaredElement> get_SelectedElements();
    [CompilerGeneratedAttribute]
public string get_SelectedPartName();
    [CompilerGeneratedAttribute]
public bool get_IsRegionSelected();
}
public interface JetBrains.ReSharper.Refactorings.Convert.Type2Partial.IType2PartialHelper {
    public abstract virtual bool IsAvailableForTypeElement(ITypeElement typeElement, IPsiSourceFile psiSourceFile);
    public abstract virtual bool CanSuggestProjectFile(IProjectFile projectFile);
    [NotNullAttribute]
public abstract virtual ITypeDeclaration AddNewTypePart(Type2PartialDataModel model, ITreeNode& formatRoot);
    [NotNullAttribute]
public abstract virtual string GetExtension();
    public abstract virtual TreeTextRange AdjustSelectedRange(IFile psiFile, TreeTextRange treeTextRange, String& partName);
}
public interface JetBrains.ReSharper.Refactorings.Convert.Type2Partial.IType2PartialWorkflowProvider {
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "ExtractMembersToPartialActionText")]
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Type2PartialAction : ExtensibleRefactoringAction`1<IType2PartialWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Type2PartialManager : object {
    [NotNullAttribute]
private IShellLocks myShellLocks;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private IProjectModelEditor myProjectModelEditor;
    public Type2PartialManager(IShellLocks shellLocks, ISolution solution, IProjectModelEditor projectModelEditor);
    [CanBeNullAttribute]
public IProjectFile GetSelectedFile(Type2PartialModel model, string newFilePath);
    public bool CanCreateProjectFile(Type2PartialModel model, string filePath);
    public bool CanCreateProjectFile(Type2PartialModel model, String& rejectReason, string newFilePath);
    [ContractAnnotationAttribute("null => false")]
public bool IsPathValid(string path);
    [CanBeNullAttribute]
public IProjectFolder GetExistingFolder(Type2PartialModel model, String& actualFolderPath, string filePath);
    public IProjectFile CreateProjectFile(Type2PartialModel model, string filePath, string extensions);
    [NotNullAttribute]
private static IProjectFile CreateFile(IProjectFolder folder, VirtualFileSystemPath path, IProjectFile prototypeFile, string extension);
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Type2PartialPage : SingleBeRefactoringPage {
    private static string TreeId;
    private BeGrid myContent;
    public string Title { get; }
    public string PageDescription { get; }
    public Type2PartialPage(Type2PartialModel model, Type2PartialWorkflow workflow);
    public virtual string get_Title();
    public virtual string get_PageDescription();
    public virtual BeControl GetPageContent();
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Type2PartialRefactoring : DrivenRefactoringBase`1<Type2PartialWorkflow> {
    private Type2PartialDataModel myDataModel;
    public Type2PartialRefactoring(Type2PartialWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Type2PartialUseOrCreateData : AddOrCreateData`1<ITreeNodePointer`1<IDeclaration>> {
    public static string Type2PartialTargetNameId;
    public static string Type2PartialTargetComboId;
    private Type2PartialModel myModel;
    private Lifetime myLifetime;
    public Type2PartialUseOrCreateData(Type2PartialModel model, Lifetime lifetime);
    public virtual void Navigate();
    public virtual BeControl InitText(BeTextBox textBox);
    public virtual BeControl Present(ITreeNodePointer`1<IDeclaration> elementPointer, IconHostBase iconHostBase);
}
public class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Type2PartialWorkflow : DrivenRefactoringWorkflow2`1<IType2PartialHelper> {
    [CompilerGeneratedAttribute]
private Type2PartialDataModel <DataModel>k__BackingField;
    [CompilerGeneratedAttribute]
private Type2PartialModel <Model>k__BackingField;
    public Type2PartialDataModel DataModel { get; private set; }
    public IConflictSearcher ConflictSearcher { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    [NotNullAttribute]
private Type2PartialManager Type2PartialManager { get; }
    public Type2PartialModel Model { get; private set; }
    public Type2PartialWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public Type2PartialDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(Type2PartialDataModel value);
    public virtual IConflictSearcher get_ConflictSearcher();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    private Type2PartialManager get_Type2PartialManager();
    [CompilerGeneratedAttribute]
public Type2PartialModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(Type2PartialModel value);
    public virtual bool IsAvailable(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool PreExecute(IProgressIndicator pi);
    public virtual bool Initialize(IDataContext context);
    protected virtual void OnSuccessfullyFinished();
    protected virtual IType2PartialHelper CreateUnsupportedHelper();
    protected virtual IType2PartialHelper CreateHelper(IRefactoringLanguageService service);
    [CanBeNullAttribute]
private Type2PartialContext GetWorkflowContext(IDataContext context);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Convert.Type2Partial.Type2PartialWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public abstract class JetBrains.ReSharper.Refactorings.ConvertRefsToBase.ComponentsBuilder`2 : object {
    private OneToSetMap`2<TVertex, TVertex> myComponents;
    private IDictionary`2<TVertex, TVertex> myReverseComponents;
    private OneToListMap`2<TVertex, TEdge> myIncomingEdges;
    private OneToListMap`2<TVertex, TEdge> myOutgoingEdges;
    private IList`1<TVertex> myNodes;
    public ComponentsBuilder`2(OneToListMap`2<TVertex, TEdge> incomingEdges, OneToListMap`2<TVertex, TEdge> outgoingEdges, IList`1<TVertex> nodes);
    protected abstract virtual TVertex Start(TEdge edge);
    protected abstract virtual TVertex End(TEdge edge);
    public void Build(List`1<TVertex> componentTopologicalOrder, OneToSetMap`2<TVertex, TVertex> components, IDictionary`2<TVertex, TVertex> reverseComponents, IProgressIndicator progressIndicator);
    private bool BuildComponent(TVertex node, Dictionary`2<TVertex, int> fu, JetHashSet`1<TVertex> visited, int cur);
    private void ComputeFu(TVertex node, Dictionary`2<TVertex, int> fu, Dictionary`2<int, TVertex> reverseFu, Int32& cur, JetHashSet`1<TVertex> visited);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Refactorings.CopyType.CLRLanguageSpecificCopyTypeBase : object {
    public string TextForNamespaceTitle { get; }
    public sealed virtual bool IsAvailable(IDeclaredElement declaredElement);
    public abstract virtual bool IsAvailable(IDeclaration typeDeclaration);
    public sealed virtual bool CanSetNamespace(IDeclaredElement declaredElement);
    public abstract virtual IDeclaration CreateCopy(IDeclaration typeDeclaration, IFile file, string qualifiedName, ITreeNode& alreadyCreatedScope);
    public abstract virtual string GenerateFileName(IDeclaration typeDeclaration, string name);
    public abstract virtual IConflictSearcher GetConflictSearcher(IDeclaredElement typeElement, string qualifiedName);
    public sealed virtual string get_TextForNamespaceTitle();
    public sealed virtual int GetTypeParametersCount(IDeclaredElement typeElement);
    public sealed virtual IDeclaredElement GetContainingTypeElement(IDeclaredElement typeElement);
    public sealed virtual string GetContainingNamespaceQualifiedName(IDeclaredElement typeElement);
    public sealed virtual IDeclaration GetTypeDeclaration(IDataContext dataContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "CopyTypeActionText")]
public class JetBrains.ReSharper.Refactorings.CopyType.CopyTypeAction : ExtensibleRefactoringAction`1<ICopyTypeWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.CopyType.CopyTypeExec : RefactoringExecBase`2<CopyTypeWorkflow, CopyTypeRefactoring> {
    public CopyTypeExec(CopyTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CopyType.CopyTypePage : SingleBeRefactoringPage {
    private CopyTypeWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Property`1<string> <TargetNamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Property`1<string> <TargetElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceDescription>k__BackingField;
    private BeSpanGrid myContent;
    public string Description { get; protected set; }
    public Property`1<string> TargetNamespaceName { get; }
    public Property`1<string> TargetElementName { get; }
    public string NamespaceDescription { get; }
    public string Title { get; }
    public CopyTypePage(CopyTypeWorkflow workflow, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
protected sealed virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public Property`1<string> get_TargetNamespaceName();
    [CompilerGeneratedAttribute]
public Property`1<string> get_TargetElementName();
    [CompilerGeneratedAttribute]
public string get_NamespaceDescription();
    public virtual string get_Title();
    public virtual BeControl GetPageContent();
    public virtual void Commit();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <.ctor>b__17_0(string className);
}
public class JetBrains.ReSharper.Refactorings.CopyType.CopyTypeRefactoring : DrivenRefactoring`2<CopyTypeWorkflow, CopyTypeExec> {
    private CopyTypeDataModel myModel;
    public CopyTypeRefactoring(CopyTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
private static ICopyType GetLanguageSpecificCopyType(ITreeNode typeDeclaration);
    public virtual bool Execute(IProgressIndicator pi);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CopyType.CopyTypeWorkflow : DrivenRefactoringWorkflow {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDeclaredElementPointer`1<IDeclaredElement> myPointer;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CopyTypeDataModel <DataModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyTypeDataProvider <DataProvider>k__BackingField;
    [NullableAttribute("2")]
public CopyTypeDataModel DataModel { get; private set; }
    public CopyTypeDataProvider DataProvider { get; public set; }
    [NullableAttribute("2")]
public IDeclaredElement InitialTypeElement { get; public set; }
    public string ActionId { get; }
    [NullableAttribute("2")]
public IconId Icon { get; }
    public string Title { get; }
    public IConflictSearcher ConflictSearcher { get; }
    [NullableAttribute("2")]
public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public bool HasUI { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public CopyTypeWorkflow(ISolution solution, string actionId);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CopyTypeDataModel get_DataModel();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_DataModel(CopyTypeDataModel value);
    [CompilerGeneratedAttribute]
public sealed virtual CopyTypeDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DataProvider(CopyTypeDataProvider value);
    [NullableContextAttribute("2")]
public IDeclaredElement get_InitialTypeElement();
    [NullableContextAttribute("2")]
public void set_InitialTypeElement(IDeclaredElement value);
    public virtual string get_ActionId();
    [NullableContextAttribute("2")]
public virtual IconId get_Icon();
    public virtual string get_Title();
    public virtual IConflictSearcher get_ConflictSearcher();
    [NullableContextAttribute("2")]
public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual bool get_HasUI();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual bool IsAvailable(IDataContext context);
    public static bool IsAvailable(IDataContext dataContext, IDeclaredElement& declaredElement);
    public static bool IsAvailable(IDeclaredElement declaredElement);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public IConflictSearcher GetConflictSearcher();
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator taskExecutorCreator);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.CopyType.CopyTypeWorkflowProvider : object {
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Refactorings.CopyType.ICopyType {
    public string TextForNamespaceTitle { get; }
    public abstract virtual bool IsAvailable(IDeclaredElement declaredElement);
    public abstract virtual bool IsAvailable(IDeclaration typeDeclaration);
    public abstract virtual bool CanSetNamespace(IDeclaredElement declaredElement);
    public abstract virtual IDeclaration CreateCopy(IDeclaration typeDeclaration, IFile file, string qualifiedName, ITreeNode& alreadyCreatedScope);
    public abstract virtual string GenerateFileName(IDeclaration typeDeclaration, string name);
    public abstract virtual IConflictSearcher GetConflictSearcher(IDeclaredElement typeElement, string qualifiedName);
    public abstract virtual int GetTypeParametersCount(IDeclaredElement typeElement);
    public abstract virtual IDeclaredElement GetContainingTypeElement(IDeclaredElement typeElement);
    public abstract virtual string GetContainingNamespaceQualifiedName(IDeclaredElement typeElement);
    public abstract virtual IDeclaration GetTypeDeclaration(IDataContext dataContext);
    public abstract virtual string get_TextForNamespaceTitle();
}
public interface JetBrains.ReSharper.Refactorings.CopyType.ICopyTypeWorkflowProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CopyType.Model.CopyTypeDataModel : object {
    [CompilerGeneratedAttribute]
private IDeclaredElement <InitialTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IDeclaration, IFile> <NewFiles>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<IDeclaredElement> <NewTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFQNName>k__BackingField;
    public IDeclaredElement InitialTypeElement { get; }
    public IDictionary`2<IDeclaration, IFile> NewFiles { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDeclaredElementPointer`1<IDeclaredElement> NewTypeElement { get; public set; }
    public string TargetFQNName { get; }
    public CopyTypeDataModel(CopyTypeDataProvider dataProvider, IDeclaredElement initialTypeElement);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_InitialTypeElement();
    [CompilerGeneratedAttribute]
public IDictionary`2<IDeclaration, IFile> get_NewFiles();
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<IDeclaredElement> get_NewTypeElement();
    [CompilerGeneratedAttribute]
public void set_NewTypeElement(IDeclaredElementPointer`1<IDeclaredElement> value);
    [CompilerGeneratedAttribute]
public string get_TargetFQNName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.CopyType.Model.CopyTypeDataProvider : object {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSetNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    public string ShortName { get; }
    public string NamespaceName { get; }
    public bool CanSetNamespace { get; public set; }
    public bool NonInteractive { get; public set; }
    public CopyTypeDataProvider(string namespaceName, string shortName);
    public CopyTypeDataProvider(IDeclaredElement typeElement);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public bool get_CanSetNamespace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanSetNamespace(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NonInteractive(bool value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.DataContextsExtensions : object {
    [ExtensionAttribute]
[MustDisposeResourceAttribute]
public static LifetimeDefinition CreateElementsDataContext(IRefactoringWorkflow refactoringWorkflow, string name, IDataContext& dataContext, IDeclaredElement[] declaredElements);
}
public class JetBrains.ReSharper.Refactorings.DefaultRefactoringsHelper : RefactoringsHelper {
}
public class JetBrains.ReSharper.Refactorings.EncapsulateField.ClrEncapsulateFieldUtilBase : object {
    public bool LanguageSupportsAutoProperties { get; }
    public bool LanguageSupportsInternalModifier { get; }
    public sealed virtual bool IsUnderTypeDeclaration(ITreeNode treeNode, IDeclaredElement containingType);
    public sealed virtual IDeclaredElement GetContainingTypeForField(IDeclaredElement field);
    public sealed virtual bool IsStaticField(IDeclaredElement declaredElement);
    public sealed virtual bool IsField(IDeclaredElement declaredElement);
    public sealed virtual bool IsConstant(IDeclaredElement declaredElement);
    public sealed virtual AccessRights GetAccessRights(IDeclaredElement fieldOrProperty);
    public sealed virtual bool IsReadOnly(IDeclaredElement field);
    public sealed virtual bool IsReadableProperty(IDeclaredElement targetProperty);
    public sealed virtual bool IsWriteableProperty(IDeclaredElement targetProperty);
    public virtual bool CanEncapsulateToAutoProperty(IDeclaredElement field);
    public sealed virtual IReadOnlyCollection`1<IDeclaredElement> FindEncapsulatingProperties(IDeclaredElement fieldElement, IReadOnlyCollection`1<AccessRights> possibleAccessRights);
    [NotNullAttribute]
public sealed virtual INamesSuggestion SuggestPropertyName(IDeclaredElement field, IPsiSourceFile sourceFile, PsiLanguageType languageType);
    public sealed virtual string GetTypePresentableName(IDeclaredElement property, PsiLanguageType language);
    public sealed virtual bool get_LanguageSupportsAutoProperties();
    public sealed virtual bool get_LanguageSupportsInternalModifier();
    public virtual bool LanguageSupportsPrivateProtectedModifier(IDeclaredElement field);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "EncapsulateFieldActionText")]
[VsOverrideActionAttribute("({1496A755-94DE-11D0-8C3F-00C04FC2AAE2}:1552)")]
public class JetBrains.ReSharper.Refactorings.EncapsulateField.EncapsulateFieldAction : ExtensibleRefactoringAction`1<IEncapsulateFieldWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
    public sealed virtual bool ShouldFallBack(IDataContext context);
}
public abstract class JetBrains.ReSharper.Refactorings.EncapsulateField.EncapsulateFieldBase : RefactoringExecBase`2<EncapsulateFieldWorkflow, EncapsulateFieldRefactoring> {
    [NotNullAttribute]
protected EncapsulateFieldDataModel Model;
    [CompilerGeneratedAttribute]
private IEncapsulateFieldUtil <LanguageSpecific>k__BackingField;
    [NotNullAttribute]
public IEncapsulateFieldUtil LanguageSpecific { get; }
    protected EncapsulateFieldBase(EncapsulateFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement CreatePropertyDeclaration(IDeclaredElement field);
    public abstract virtual void RemoveFieldDeclaration(IDeclaredElement field);
    public virtual void EncapsulateReference(IReference reference, ReferenceAccessType accessType, IDeclaredElement field, IDeclaredElement property, EncapsulateFieldBase targetEncapsulateField, bool isExternal);
    protected virtual void ProcessReference(IReference reference, ReferenceAccessType accessType, IDeclaredElement property);
    public virtual void FinishProcessingReferences(IDeclaredElement property, IDeclaredElement declaredElement);
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement EnsureReadable(IDeclaredElement property, IDeclaredElement field);
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement EnsureWriteable(IDeclaredElement property, IDeclaredElement field);
    [CompilerGeneratedAttribute]
public IEncapsulateFieldUtil get_LanguageSpecific();
    [NotNullAttribute]
public virtual IDeclaredElement RenameFieldDeclaration(IDeclaredElement field, NameSuggestionManager suggestionManager, SuggestionOptions suggestionOptions, IPsiSourceFile sourceFile, bool willMakeFieldPrivate);
    public virtual void SetAccessRights(ConstructionUtil constructionUtil, IDeclaredElement field, AccessRights rights);
}
public class JetBrains.ReSharper.Refactorings.EncapsulateField.EncapsulateFieldDataModel : object {
    [CompilerGeneratedAttribute]
private bool <FieldShouldHaveNoWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRights <AccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncapsulateReads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncapsulateWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncapsulateNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAutoProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExternalUsagesOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeFieldPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredElementNode <TargetProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<AccessRights> <PossibleAccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoPropertiesSupportedByLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanUseAutoProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanUseGetOnlyProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanMakeFieldPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DeclaredElementNode> <PossibleTargetProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IReference> <AdditionalReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredElementNode <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <PsiSourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanEncapsulateReads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanEncapsulateNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    public bool FieldShouldHaveNoWrites { get; private set; }
    public string PropertyName { get; public set; }
    public AccessRights AccessRights { get; public set; }
    public bool EncapsulateReads { get; public set; }
    public bool EncapsulateWrites { get; public set; }
    public bool EncapsulateNames { get; public set; }
    public bool UseAutoProperty { get; public set; }
    public bool ExternalUsagesOnly { get; public set; }
    public bool MakeFieldPrivate { get; public set; }
    public DeclaredElementNode TargetProperty { get; public set; }
    public IReadOnlyCollection`1<AccessRights> PossibleAccessRights { get; private set; }
    public bool AutoPropertiesSupportedByLanguage { get; private set; }
    public bool CanUseAutoProperty { get; private set; }
    public bool CanUseGetOnlyProperty { get; private set; }
    public bool CanMakeFieldPrivate { get; private set; }
    public IList`1<DeclaredElementNode> PossibleTargetProperties { get; private set; }
    [CanBeNullAttribute]
public IList`1<IReference> AdditionalReferences { get; public set; }
    [CanBeNullAttribute]
public DeclaredElementNode Field { get; private set; }
    [CanBeNullAttribute]
public IPsiSourceFile PsiSourceFile { get; public set; }
    public bool CanEncapsulateReads { get; private set; }
    public bool CanEncapsulateNames { get; private set; }
    public bool NonInteractive { get; public set; }
    public EncapsulateFieldDataModel(IList`1<IReference> additionalReferences, bool hasUI);
    public EncapsulateFieldDataModel(IDeclaredElement field, Lifetime lifetime, bool hasUI);
    [CompilerGeneratedAttribute]
public bool get_FieldShouldHaveNoWrites();
    [CompilerGeneratedAttribute]
private void set_FieldShouldHaveNoWrites(bool value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public AccessRights get_AccessRights();
    [CompilerGeneratedAttribute]
public void set_AccessRights(AccessRights value);
    [CompilerGeneratedAttribute]
public bool get_EncapsulateReads();
    [CompilerGeneratedAttribute]
public void set_EncapsulateReads(bool value);
    [CompilerGeneratedAttribute]
public bool get_EncapsulateWrites();
    [CompilerGeneratedAttribute]
public void set_EncapsulateWrites(bool value);
    [CompilerGeneratedAttribute]
public bool get_EncapsulateNames();
    [CompilerGeneratedAttribute]
public void set_EncapsulateNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseAutoProperty();
    [CompilerGeneratedAttribute]
public void set_UseAutoProperty(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExternalUsagesOnly();
    [CompilerGeneratedAttribute]
public void set_ExternalUsagesOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_MakeFieldPrivate();
    [CompilerGeneratedAttribute]
public void set_MakeFieldPrivate(bool value);
    [CompilerGeneratedAttribute]
public DeclaredElementNode get_TargetProperty();
    [CompilerGeneratedAttribute]
public void set_TargetProperty(DeclaredElementNode value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<AccessRights> get_PossibleAccessRights();
    [CompilerGeneratedAttribute]
private void set_PossibleAccessRights(IReadOnlyCollection`1<AccessRights> value);
    [CompilerGeneratedAttribute]
public bool get_AutoPropertiesSupportedByLanguage();
    [CompilerGeneratedAttribute]
private void set_AutoPropertiesSupportedByLanguage(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanUseAutoProperty();
    [CompilerGeneratedAttribute]
private void set_CanUseAutoProperty(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanUseGetOnlyProperty();
    [CompilerGeneratedAttribute]
private void set_CanUseGetOnlyProperty(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanMakeFieldPrivate();
    [CompilerGeneratedAttribute]
private void set_CanMakeFieldPrivate(bool value);
    [CompilerGeneratedAttribute]
public IList`1<DeclaredElementNode> get_PossibleTargetProperties();
    [CompilerGeneratedAttribute]
private void set_PossibleTargetProperties(IList`1<DeclaredElementNode> value);
    [CompilerGeneratedAttribute]
public IList`1<IReference> get_AdditionalReferences();
    [CompilerGeneratedAttribute]
public void set_AdditionalReferences(IList`1<IReference> value);
    [CompilerGeneratedAttribute]
public DeclaredElementNode get_Field();
    [CompilerGeneratedAttribute]
private void set_Field(DeclaredElementNode value);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_PsiSourceFile();
    [CompilerGeneratedAttribute]
public void set_PsiSourceFile(IPsiSourceFile value);
    [CompilerGeneratedAttribute]
public bool get_CanEncapsulateReads();
    [CompilerGeneratedAttribute]
private void set_CanEncapsulateReads(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanEncapsulateNames();
    [CompilerGeneratedAttribute]
private void set_CanEncapsulateNames(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_NonInteractive(bool value);
    public void Initialize(IDeclaredElement field, Lifetime lifetime);
    [NotNullAttribute]
[PureAttribute]
private static IReadOnlyCollection`1<AccessRights> GetPossiblePropertyAccessRights(IDeclaredElement field, IEncapsulateFieldUtil encapsulateFieldUtil);
}
public class JetBrains.ReSharper.Refactorings.EncapsulateField.EncapsulateFieldPage : SingleBeRefactoringPage {
    public static string EncapsulateField_UseAuto;
    public static string EncapsulateField_ExternalUsages;
    public static string EncapsulateField_AccessRights;
    public static string EncapsulateField_NewName;
    public static string EncapsulateField_EncapsulateReads;
    public static string EncapsulateField_EncapsulateWrites;
    public static string EncapsulateField_EncapsulateNames;
    public static string EncapsulateField_MakePrivate;
    public static string EncapsulateField_TargetProperty;
    private BeSpanGrid myContent;
    private EncapsulateFieldWorkflow myWorkflow;
    private ISolution mySolution;
    [CompilerGeneratedAttribute]
private EncapsulateFieldDataModel <DataModel>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<AccessRights> <AccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <EncapsulateReads>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <EncapsulateWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <EncapsulateNames>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <UseAutoProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <ExternalUsagesOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <MakeFieldPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <CreateNewProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<DeclaredElementNode> <TargetProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanEncapsulateReads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanEncapsulateWrites>k__BackingField;
    public string PageDescription { get; }
    public EncapsulateFieldDataModel DataModel { get; }
    public IProperty`1<string> PropertyName { get; public set; }
    public IProperty`1<AccessRights> AccessRights { get; public set; }
    public IProperty`1<bool> EncapsulateReads { get; public set; }
    public IProperty`1<bool> EncapsulateWrites { get; public set; }
    public IProperty`1<bool> EncapsulateNames { get; public set; }
    public IProperty`1<bool> UseAutoProperty { get; public set; }
    public IProperty`1<bool> ExternalUsagesOnly { get; public set; }
    public IProperty`1<bool> MakeFieldPrivate { get; public set; }
    public IProperty`1<bool> CreateNewProperty { get; }
    public IProperty`1<DeclaredElementNode> TargetProperty { get; public set; }
    public string Description { get; }
    public string Title { get; }
    public PsiLanguageType LanguageType { get; }
    public bool CanEncapsulateReads { get; private set; }
    public bool CanEncapsulateWrites { get; private set; }
    public EncapsulateFieldPage(EncapsulateFieldWorkflow workflow);
    public virtual string get_PageDescription();
    [CompilerGeneratedAttribute]
public EncapsulateFieldDataModel get_DataModel();
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<AccessRights> get_AccessRights();
    [CompilerGeneratedAttribute]
public void set_AccessRights(IProperty`1<AccessRights> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_EncapsulateReads();
    [CompilerGeneratedAttribute]
public void set_EncapsulateReads(IProperty`1<bool> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_EncapsulateWrites();
    [CompilerGeneratedAttribute]
public void set_EncapsulateWrites(IProperty`1<bool> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_EncapsulateNames();
    [CompilerGeneratedAttribute]
public void set_EncapsulateNames(IProperty`1<bool> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_UseAutoProperty();
    [CompilerGeneratedAttribute]
public void set_UseAutoProperty(IProperty`1<bool> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_ExternalUsagesOnly();
    [CompilerGeneratedAttribute]
public void set_ExternalUsagesOnly(IProperty`1<bool> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_MakeFieldPrivate();
    [CompilerGeneratedAttribute]
public void set_MakeFieldPrivate(IProperty`1<bool> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_CreateNewProperty();
    [CompilerGeneratedAttribute]
public IProperty`1<DeclaredElementNode> get_TargetProperty();
    [CompilerGeneratedAttribute]
public void set_TargetProperty(IProperty`1<DeclaredElementNode> value);
    public virtual string get_Description();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
public bool get_CanEncapsulateReads();
    [CompilerGeneratedAttribute]
private void set_CanEncapsulateReads(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanEncapsulateWrites();
    [CompilerGeneratedAttribute]
private void set_CanEncapsulateWrites(bool value);
    private void TryAddExistingPropertiesCombo(ISolution solution, BeCheckbox encapsulateReads, BeCheckbox encapsulateWrites, BeCheckbox encapsulateNames, PsiLanguageType language);
    public virtual bool RefreshContents(IProgressIndicator pi);
    public virtual void Commit();
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__71_0(DeclaredElementNode v);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.EncapsulateField.EncapsulateFieldProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.EncapsulateField.EncapsulateFieldRefactoring : DrivenRefactoring`2<EncapsulateFieldWorkflow, EncapsulateFieldBase> {
    [NotNullAttribute]
private List`1<IReference> myReferencesToEncapsulate;
    [NotNullAttribute]
private List`1<IReference> myInternalFieldReferences;
    [NotNullAttribute]
private JetHashSet`1<IReference> myExternalReferences;
    private IDeclaredElement myContainingType;
    [NotNullAttribute]
private EncapsulateFieldDataModel myModel;
    public EncapsulateFieldRefactoring(EncapsulateFieldWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    [NotNullAttribute]
private static IDeclaredElement RenameField(IDeclaredElement field, EncapsulateFieldBase helper, bool willMakeFieldPrivate);
    private void ConsumeReference(IReference reference, EncapsulateFieldBase helper);
    private void CheckNewMemberConflicts(IDeclaredElement field);
    private void ProcessReference(IReference reference, IDeclaredElement property, IDeclaredElement field);
    protected virtual EncapsulateFieldBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    protected virtual EncapsulateFieldBase CreateUnsupportedRefactoring();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Refactorings.Resources.Strings", "PersistentSettingsForEncapsulateFieldRefactoringSettingDescription")]
public class JetBrains.ReSharper.Refactorings.EncapsulateField.EncapsulateFieldSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "EncapsulateFieldToAutoPropertySettingDescription")]
public bool UseAutoProperty;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "UpdateExternalFieldUsagesOnlySettingDescription")]
public bool UpdateExternalUsagesOnly;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "MakeEncapsulatingFieldPrivateSettingDescription")]
public bool MakeFieldPrivate;
}
public class JetBrains.ReSharper.Refactorings.EncapsulateField.EncapsulateFieldWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private EncapsulateFieldDataModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private EncapsulateFieldDataModel <DataProvider>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public HelpId HelpKeyword { get; }
    public PsiLanguageType LanguageType { get; private set; }
    public EncapsulateFieldDataModel Model { get; private set; }
    public EncapsulateFieldDataModel DataProvider { get; public set; }
    public EncapsulateFieldWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    [CompilerGeneratedAttribute]
public EncapsulateFieldDataModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(EncapsulateFieldDataModel value);
    [CompilerGeneratedAttribute]
public sealed virtual EncapsulateFieldDataModel get_DataProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DataProvider(EncapsulateFieldDataModel value);
    public virtual bool IsAvailable(IDataContext context);
    [ContractAnnotationAttribute("null => false")]
public static bool IsAvailable(IDeclaredElement field);
    public virtual bool Initialize(IDataContext context);
    public virtual bool Validate();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
public interface JetBrains.ReSharper.Refactorings.EncapsulateField.IEncapsulateFieldUtil {
    public bool LanguageSupportsAutoProperties { get; }
    public bool LanguageSupportsInternalModifier { get; }
    [PureAttribute]
public abstract virtual bool IsField(IDeclaredElement declaredElement);
    [PureAttribute]
public abstract virtual bool IsConstant(IDeclaredElement declaredElement);
    [PureAttribute]
public abstract virtual AccessRights GetAccessRights(IDeclaredElement fieldOrProperty);
    [PureAttribute]
public abstract virtual bool IsReadOnly(IDeclaredElement field);
    [PureAttribute]
public abstract virtual bool IsReadableProperty(IDeclaredElement targetProperty);
    [PureAttribute]
public abstract virtual bool IsWriteableProperty(IDeclaredElement targetProperty);
    [PureAttribute]
public abstract virtual bool CanEncapsulateToAutoProperty(IDeclaredElement field);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyCollection`1<IDeclaredElement> FindEncapsulatingProperties(IDeclaredElement field, IReadOnlyCollection`1<AccessRights> possibleAccessRights);
    [PureAttribute]
public abstract virtual INamesSuggestion SuggestPropertyName(IDeclaredElement field, IPsiSourceFile sourceFile, PsiLanguageType languageType);
    [PureAttribute]
public abstract virtual bool IsStaticField(IDeclaredElement declaredElement);
    public abstract virtual IDeclaredElement GetContainingTypeForField(IDeclaredElement field);
    [PureAttribute]
public abstract virtual bool IsUnderTypeDeclaration(ITreeNode treeNode, IDeclaredElement containingType);
    [NotNullAttribute]
public abstract virtual string GetTypePresentableName(IDeclaredElement property, PsiLanguageType language);
    public abstract virtual bool get_LanguageSupportsAutoProperties();
    public abstract virtual bool get_LanguageSupportsInternalModifier();
    public abstract virtual bool LanguageSupportsPrivateProtectedModifier(IDeclaredElement field);
}
public interface JetBrains.ReSharper.Refactorings.EncapsulateField.IEncapsulateFieldWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.Analysis.ExtractClassAnalyzer : object {
    public virtual void LoadGraph(List`1<ExtractClassMemberNode> members);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "ExtractClassActionText")]
public class JetBrains.ReSharper.Refactorings.ExtractClass.ExtractClassAction : ExtensibleRefactoringAction`1<IExtractClassWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.ExtractClassDataModel : object {
    private int myUsages;
    public OneToSetMap`2<IDeclaredElement, IReference> References;
    private bool myUseTargetInSource;
    [CompilerGeneratedAttribute]
private List`1<ExtractClassMemberNode> <AllMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAutoProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoResolveConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <CreatedFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <TargetTypeMember>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TargetTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <SourceTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <BackSubstitution>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ConstructorNode> <Constructors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSourceInTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    public List`1<ExtractClassMemberNode> AllMembers { get; public set; }
    public List`1<ExtractClassMemberNode> Members { get; }
    public List`1<FieldNode> DataMembers { get; }
    public List`1<ExtractClassMemberNode> MovableMembers { get; }
    public string SourceParameterName { get; public set; }
    public string SourceFieldName { get; public set; }
    public string TargetFieldName { get; public set; }
    public string TargetClassName { get; public set; }
    public string SourceClassName { get; }
    public bool UseAutoProperties { get; public set; }
    public bool AutoResolveConflicts { get; public set; }
    public IProjectFile CreatedFile { get; public set; }
    public bool IsSibling { get; public set; }
    public IProperty Property { get; public set; }
    public IDeclaredElement TargetTypeMember { get; public set; }
    public ITypeElement TargetTypeElement { get; public set; }
    public ITypeElement SourceTypeElement { get; public set; }
    public ISubstitution Substitution { get; public set; }
    public ISubstitution BackSubstitution { get; public set; }
    public IList`1<ConstructorNode> Constructors { get; public set; }
    public bool SourceNotStatic { get; }
    public bool UseSourceInTarget { get; public set; }
    public bool UseTargetInSource { get; public set; }
    public int ThisUsages { get; public set; }
    public VirtualFileSystemPath DirectoryPath { get; protected set; }
    public Lifetime Lifetime { get; }
    public ExtractClassDataModel(ITypeElement sourceTypeElement, ICollection`1<IDeclaredElement> elements, Lifetime lifetime, ExtractClassHelper helper);
    [CompilerGeneratedAttribute]
public List`1<ExtractClassMemberNode> get_AllMembers();
    [CompilerGeneratedAttribute]
public void set_AllMembers(List`1<ExtractClassMemberNode> value);
    public List`1<ExtractClassMemberNode> get_Members();
    public List`1<FieldNode> get_DataMembers();
    public List`1<ExtractClassMemberNode> get_MovableMembers();
    [CompilerGeneratedAttribute]
public string get_SourceParameterName();
    [CompilerGeneratedAttribute]
public void set_SourceParameterName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceFieldName();
    [CompilerGeneratedAttribute]
public void set_SourceFieldName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFieldName();
    [CompilerGeneratedAttribute]
public void set_TargetFieldName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetClassName();
    [CompilerGeneratedAttribute]
public void set_TargetClassName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceClassName();
    [CompilerGeneratedAttribute]
public bool get_UseAutoProperties();
    [CompilerGeneratedAttribute]
public void set_UseAutoProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoResolveConflicts();
    [CompilerGeneratedAttribute]
public void set_AutoResolveConflicts(bool value);
    [CompilerGeneratedAttribute]
public IProjectFile get_CreatedFile();
    [CompilerGeneratedAttribute]
public void set_CreatedFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public bool get_IsSibling();
    [CompilerGeneratedAttribute]
public void set_IsSibling(bool value);
    [CompilerGeneratedAttribute]
public IProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(IProperty value);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_TargetTypeMember();
    [CompilerGeneratedAttribute]
public void set_TargetTypeMember(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public ITypeElement get_TargetTypeElement();
    [CompilerGeneratedAttribute]
public void set_TargetTypeElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public ITypeElement get_SourceTypeElement();
    [CompilerGeneratedAttribute]
public void set_SourceTypeElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    [CompilerGeneratedAttribute]
public void set_Substitution(ISubstitution value);
    [CompilerGeneratedAttribute]
public ISubstitution get_BackSubstitution();
    [CompilerGeneratedAttribute]
public void set_BackSubstitution(ISubstitution value);
    [CompilerGeneratedAttribute]
public IList`1<ConstructorNode> get_Constructors();
    [CompilerGeneratedAttribute]
public void set_Constructors(IList`1<ConstructorNode> value);
    public bool get_SourceNotStatic();
    [CompilerGeneratedAttribute]
public bool get_UseSourceInTarget();
    [CompilerGeneratedAttribute]
public void set_UseSourceInTarget(bool value);
    public bool get_UseTargetInSource();
    public void set_UseTargetInSource(bool value);
    public int get_ThisUsages();
    public void set_ThisUsages(int value);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_DirectoryPath();
    [CompilerGeneratedAttribute]
protected void set_DirectoryPath(VirtualFileSystemPath value);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    public string GetDerivedName(string name, NamedElementKinds kind);
    public void ApplyData(ExtractClassDataProvider extractClassDataProvider);
    public IList`1<RelativeInfo> ProcessConstructors(bool addConflicts);
    private static void ResolveConflict(ExtractClassMemberNode member);
    internal void FillDelegate();
    public ITypeDeclaration GetTargetTypeDeclaration();
    private static ITypeDeclaration GetDeclaration(ITypeElement sourceType);
    public ISubstitution GetSubstitution();
    public void FillTarget(ITypeElement targetTypeElement);
    public ITypeDeclaration GetSourceTypeDeclaration();
    public void UpdateUsingSource();
    private void AddMemberInfo(TypeMemberInstance memberInstance, bool isSupertypeMember);
    public void GetReferencesToRebind(IProgressIndicator pi);
    private static bool MemberIsValid(IDeclaredElement member, bool isSupertypeMember);
    [CompilerGeneratedAttribute]
private ExtractClassMemberNode <ApplyData>b__97_0(string element);
    [CompilerGeneratedAttribute]
private FindExecution <GetReferencesToRebind>b__108_0(FindResult result);
    [CompilerGeneratedAttribute]
private FindExecution <GetReferencesToRebind>b__108_1(FindResult result);
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.ExtractClassDataProvider : object {
    [CompilerGeneratedAttribute]
private bool <IsSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SelectedElements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseThis>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <MakeDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <MakeCopy>k__BackingField;
    public bool IsSibling { get; }
    public string ClassName { get; }
    public string FieldName { get; }
    public String[] SelectedElements { get; }
    public bool UseThis { get; }
    public String[] MakeDelegate { get; }
    public String[] MakeCopy { get; }
    public ExtractClassDataProvider(bool isSibling, string className, string fieldName, String[] selectedElements, bool useThis, String[] makeCopy, String[] makeDelegate);
    [CompilerGeneratedAttribute]
public bool get_IsSibling();
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public String[] get_SelectedElements();
    [CompilerGeneratedAttribute]
public bool get_UseThis();
    [CompilerGeneratedAttribute]
public String[] get_MakeDelegate();
    [CompilerGeneratedAttribute]
public String[] get_MakeCopy();
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.ExtractClassHelper : object {
    public bool IsLanguageSupported { get; }
    public virtual ITypeDeclaration CreateTargetTypeElement(Dictionary`2& typeParams, ExtractClassWorkflow extractClassWorkflow);
    public virtual ITypeDeclaration InsertSibling(ITypeDeclaration newClassDeclaration, ITypeDeclaration tagDeclaration);
    public virtual ITypeDeclaration InsertToNewFile(ITypeDeclaration newClassDeclaration, ITypeDeclaration tagDeclaration, string targetNamespace, IProjectFile createdFile);
    public virtual ExtractClassAnalyzer GetAnalyzer(ITypeElement owner, string name, VirtualFileSystemPath fileSystemPath, Lifetime lifetime);
    public virtual bool TryProcessMultyFieldForResolve(IRecursiveElementProcessor collector, IDeclaration declaration);
    public sealed virtual bool IsFromExtendsList(ITreeNode element);
    public sealed virtual bool IsReferenceName(ITreeNode element);
    public sealed virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public sealed virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public sealed virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual bool get_IsLanguageSupported();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ExtractClass.ExtractClassProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.ExtractClassRefactoring : DrivenRefactoring`2<ExtractClassWorkflow, ExtractClassRefactoringExec> {
    private LanguageMapOfRefactoring`1<ExtractClassRefactoringExec> myExec;
    private ExtractClassWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private ResolveImagesRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ITypeParameter, ITypeParameter> <TypeParameters>k__BackingField;
    public ResolveImagesRepository Repository { get; }
    public Dictionary`2<ITypeParameter, ITypeParameter> TypeParameters { get; public set; }
    public ExtractClassRefactoring(ExtractClassWorkflow workflow, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public ResolveImagesRepository get_Repository();
    [CompilerGeneratedAttribute]
public Dictionary`2<ITypeParameter, ITypeParameter> get_TypeParameters();
    [CompilerGeneratedAttribute]
public void set_TypeParameters(Dictionary`2<ITypeParameter, ITypeParameter> value);
    public ITypeDeclaration GetSourceDeclaration();
    public virtual bool Execute(IProgressIndicator pi);
    private void CreateConstructors(SubProgressIndicator subPi);
    private void Encapsulate(IProgressIndicator subPi);
    private bool Rebind(IProgressIndicator subPi);
    private bool CollectInfo(IProgressIndicator pi);
    private ITypeElement CreateExtractedClassDeclaration(SubProgressIndicator subPi);
    private bool CutAndPaste(IProgressIndicator pi);
    private void CreateNewClassField(ITypeElement targetType, SubProgressIndicator subPi);
    private ITypeElement CreateTargetTypeElement();
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractClass.ExtractClassRefactoringExec : RefactoringExecBase`2<ExtractClassWorkflow, ExtractClassRefactoring> {
    protected ExtractClassRefactoringExec(ExtractClassWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual void AddProperties();
    public abstract virtual void Rebind(IReference reference, ExtractClassMemberNode extractClassMemberNode, IDeclaredElement propertyMember);
    public abstract virtual void AddField(ITypeElement sourceTypeElement, ITypeElement targetType);
    public abstract virtual void CreateConstructors();
    public abstract virtual bool CutAndPaste(ResolveImagesRepository repository, Dictionary`2<ITypeParameter, ITypeParameter> createdTypeParametersMap, IProgressIndicator pi);
    public abstract virtual void ResolveConflicts(IProgressIndicator subPi);
    public virtual void CreateConstructors(ExtractClassDataModel dataModel);
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.ExtractClassWorkflow : DrivenRefactoringWorkflow2`1<ExtractClassHelper> {
    private ExtractClassDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private ExtractClassDataModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    public ExtractClassDataModel Model { get; private set; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public PsiLanguageType Language { get; private set; }
    public ExtractClassWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public ExtractClassDataModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(ExtractClassDataModel value);
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(PsiLanguageType value);
    public virtual bool IsAvailable(IDataContext context);
    public static IEnumerable`1<IFile> GetPsiFilesFromDocument(ISolution solution, DocumentRange range);
    protected bool IsAvailableEx(IDataContext context, ICollection`1& elements, ITypeElement& ownerType);
    public virtual bool Validate();
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    protected virtual ExtractClassHelper CreateUnsupportedHelper();
    protected virtual ExtractClassHelper CreateHelper(IRefactoringLanguageService service);
    public void SetData(ExtractClassDataProvider extractClassDataProvider);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private void <PreExecute>b__26_0();
}
public interface JetBrains.ReSharper.Refactorings.ExtractClass.IExtractClassWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.Info.ConstructorCall : object {
    [CompilerGeneratedAttribute]
private bool <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IExpression> <ParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IStatement <PlaceStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <PlaceBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IStatement, IStatement> <StatementsToRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBlock>k__BackingField;
    public bool Before { get; public set; }
    public List`1<IExpression> ParameterValues { get; public set; }
    public IStatement PlaceStatement { get; public set; }
    public ITreeNode PlaceBlock { get; public set; }
    public Dictionary`2<IStatement, IStatement> StatementsToRemove { get; public set; }
    public bool IsBlock { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(bool value);
    [CompilerGeneratedAttribute]
public List`1<IExpression> get_ParameterValues();
    [CompilerGeneratedAttribute]
public void set_ParameterValues(List`1<IExpression> value);
    [CompilerGeneratedAttribute]
public IStatement get_PlaceStatement();
    [CompilerGeneratedAttribute]
public void set_PlaceStatement(IStatement value);
    [CompilerGeneratedAttribute]
public ITreeNode get_PlaceBlock();
    [CompilerGeneratedAttribute]
public void set_PlaceBlock(ITreeNode value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IStatement, IStatement> get_StatementsToRemove();
    [CompilerGeneratedAttribute]
public void set_StatementsToRemove(Dictionary`2<IStatement, IStatement> value);
    [CompilerGeneratedAttribute]
public bool get_IsBlock();
    [CompilerGeneratedAttribute]
public void set_IsBlock(bool value);
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.Info.ConstructorNode : ExtractClassMemberNode {
    [CompilerGeneratedAttribute]
private List`1<IStatement> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IDeclaredElement> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ConstructorCall> <ConstructorCalls>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RelativeInfo> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstructor <SourceConstructor>k__BackingField;
    public List`1<IStatement> Body { get; public set; }
    public List`1<IDeclaredElement> Parameters { get; public set; }
    public List`1<ConstructorCall> ConstructorCalls { get; public set; }
    public List`1<RelativeInfo> Order { get; public set; }
    public IConstructor SourceConstructor { get; public set; }
    public ConstructorNode(IDeclaredElement constructor);
    [CompilerGeneratedAttribute]
public List`1<IStatement> get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(List`1<IStatement> value);
    [CompilerGeneratedAttribute]
public List`1<IDeclaredElement> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(List`1<IDeclaredElement> value);
    [CompilerGeneratedAttribute]
public List`1<ConstructorCall> get_ConstructorCalls();
    [CompilerGeneratedAttribute]
public void set_ConstructorCalls(List`1<ConstructorCall> value);
    [CompilerGeneratedAttribute]
public List`1<RelativeInfo> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(List`1<RelativeInfo> value);
    [CompilerGeneratedAttribute]
public IConstructor get_SourceConstructor();
    [CompilerGeneratedAttribute]
public void set_SourceConstructor(IConstructor value);
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.Info.ExtractClassMemberNode : MemberNode {
    [CompilerGeneratedAttribute]
private DependencyDirectionEnum <DependencyDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private StatusEnum <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNotAbstract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAccessible>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRights <AccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsThis>k__BackingField;
    [CompilerGeneratedAttribute]
private GhostStateEnum <GhostMember>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DependOnThis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChangeAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignore>k__BackingField;
    public DependencyDirectionEnum DependencyDirection { get; public set; }
    public StatusEnum Status { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsNotAbstract { get; public set; }
    public bool IsAccessible { get; public set; }
    public AccessRights AccessRights { get; public set; }
    public bool ContainsThis { get; public set; }
    public GhostStateEnum GhostMember { get; public set; }
    public bool DependOnThis { get; private set; }
    public bool IsReadOnly { get; protected set; }
    public bool ChangeAccess { get; public set; }
    public bool Ignore { get; }
    public ExtractClassMemberNode(IDeclaredElement element);
    [CompilerGeneratedAttribute]
public DependencyDirectionEnum get_DependencyDirection();
    [CompilerGeneratedAttribute]
public void set_DependencyDirection(DependencyDirectionEnum value);
    [CompilerGeneratedAttribute]
public StatusEnum get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(StatusEnum value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNotAbstract();
    [CompilerGeneratedAttribute]
public void set_IsNotAbstract(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAccessible();
    [CompilerGeneratedAttribute]
public void set_IsAccessible(bool value);
    [CompilerGeneratedAttribute]
public AccessRights get_AccessRights();
    [CompilerGeneratedAttribute]
public void set_AccessRights(AccessRights value);
    [CompilerGeneratedAttribute]
public bool get_ContainsThis();
    [CompilerGeneratedAttribute]
public void set_ContainsThis(bool value);
    [CompilerGeneratedAttribute]
public GhostStateEnum get_GhostMember();
    [CompilerGeneratedAttribute]
public void set_GhostMember(GhostStateEnum value);
    [CompilerGeneratedAttribute]
public bool get_DependOnThis();
    [CompilerGeneratedAttribute]
private void set_DependOnThis(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
protected void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_ChangeAccess();
    [CompilerGeneratedAttribute]
public void set_ChangeAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_Ignore();
    protected bool GetAccessible(AccessRights accessRights);
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.Info.FieldNode : ExtractClassMemberNode {
    private IDeclaredElementPointer`1<IDeclaredElement> myFieldPointer;
    [CompilerGeneratedAttribute]
private bool <CreateAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateProperty>k__BackingField;
    public IField Field { get; public set; }
    public IProperty Property { get; }
    public bool CreateAccessor { get; public set; }
    public bool CreateProperty { get; public set; }
    public FieldNode(IDeclaredElement element, Lifetime lifetime, IField field);
    public IField get_Field();
    public void set_Field(IField value);
    public IProperty get_Property();
    [CompilerGeneratedAttribute]
public bool get_CreateAccessor();
    [CompilerGeneratedAttribute]
public void set_CreateAccessor(bool value);
    public virtual bool HasSameDeclaredElement(IDeclaredElement element);
    [CompilerGeneratedAttribute]
public bool get_CreateProperty();
    [CompilerGeneratedAttribute]
public void set_CreateProperty(bool value);
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractClass.Info.MemberNode : DeclaredElementNode {
    protected IDeclaredElementPointer`1<IDeclaredElement> BindToPointer;
    private IDeclaredElementPointer`1<IDeclaredElement> myPointer;
    [CompilerGeneratedAttribute]
private bool <HasConflict>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RelativeInfo> <Parents>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RelativeInfo> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstanceUsage>k__BackingField;
    public bool HasConflict { get; public set; }
    public List`1<RelativeInfo> Parents { get; }
    public List`1<RelativeInfo> Children { get; }
    public IDeclaredElement BindTo { get; public set; }
    public bool InstanceUsage { get; public set; }
    protected MemberNode(IDeclaredElement element, bool initialIncluded);
    [CompilerGeneratedAttribute]
public bool get_HasConflict();
    [CompilerGeneratedAttribute]
public void set_HasConflict(bool value);
    [CompilerGeneratedAttribute]
public List`1<RelativeInfo> get_Parents();
    [CompilerGeneratedAttribute]
public List`1<RelativeInfo> get_Children();
    public virtual IDeclaredElement get_BindTo();
    public virtual void set_BindTo(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public bool get_InstanceUsage();
    [CompilerGeneratedAttribute]
public void set_InstanceUsage(bool value);
    public virtual bool HasSameDeclaredElement(IDeclaredElement element);
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.Info.RelativeInfo : object {
    [CompilerGeneratedAttribute]
private ExtractClassMemberNode <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAccessType <Usage>k__BackingField;
    public ExtractClassMemberNode Member { get; }
    public ExpressionAccessType Usage { get; public set; }
    public RelativeInfo(ExtractClassMemberNode typeMember, ExpressionAccessType accessType);
    [CompilerGeneratedAttribute]
public ExtractClassMemberNode get_Member();
    [CompilerGeneratedAttribute]
public ExpressionAccessType get_Usage();
    [CompilerGeneratedAttribute]
public void set_Usage(ExpressionAccessType value);
    public void Escalate(ExpressionAccessType accessType);
}
public enum JetBrains.ReSharper.Refactorings.ExtractClass.UI.ConflictStateEnum : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Do not apply fix")]
public static ConflictStateEnum Ignore;
    [LocalizedDescriptionAttribute("Create accessor")]
public static ConflictStateEnum CreateAccessor;
    [LocalizedDescriptionAttribute("Make public")]
public static ConflictStateEnum MakePublic;
    [LocalizedDescriptionAttribute("Create property")]
public static ConflictStateEnum CreateProperty;
}
public enum JetBrains.ReSharper.Refactorings.ExtractClass.UI.DependencyDirectionEnum : Enum {
    public int value__;
    public static DependencyDirectionEnum Parent;
    public static DependencyDirectionEnum Child;
    public static DependencyDirectionEnum None;
}
public enum JetBrains.ReSharper.Refactorings.ExtractClass.UI.DependencyEnum : Enum {
    public int value__;
    public static DependencyEnum None;
    public static DependencyEnum Weak;
    public static DependencyEnum Strong;
}
public class JetBrains.ReSharper.Refactorings.ExtractClass.UI.ExtractClassPage : SingleBeRefactoringPage {
    public static string SourceClassName;
    public static string SourceFieldName;
    public static string TargetClassName;
    public static string TargetFieldName;
    public static string IsSibling;
    public static string AllMembersGrid;
    private ExtractClassDataModel myDataModel;
    private string myLastDerivedName;
    private BeMargin myMargin;
    [CompilerGeneratedAttribute]
private bool <TargetFieldEnabled>k__BackingField;
    public string Title { get; }
    public string Description { get; }
    public bool TargetFieldEnabled { get; private set; }
    private BeMargin LineMargin { get; }
    public ExtractClassPage(ExtractClassDataModel dataModel, Lifetime lifetime);
    public virtual string get_Title();
    public virtual string get_Description();
    [CompilerGeneratedAttribute]
public bool get_TargetFieldEnabled();
    [CompilerGeneratedAttribute]
private void set_TargetFieldEnabled(bool value);
    private BeMargin get_LineMargin();
    public virtual BeControl GetPageContent();
    private bool GetCurrentUseTargetInSource(BeTextBox sourceFieldName);
}
public enum JetBrains.ReSharper.Refactorings.ExtractClass.UI.GhostStateEnum : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("None")]
public static GhostStateEnum None;
    [LocalizedDescriptionAttribute("Create Copy")]
public static GhostStateEnum Copy;
    [LocalizedDescriptionAttribute("Create Delegating Wrapper")]
public static GhostStateEnum Delegate;
}
public enum JetBrains.ReSharper.Refactorings.ExtractClass.UI.StatusEnum : Enum {
    public int value__;
    public static StatusEnum Member;
    public static StatusEnum Data;
    public static StatusEnum Constructor;
    public static StatusEnum Supertype;
    public static StatusEnum Type;
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractMethod.ControlFlowAnalyzer : object {
    private IControlFlowGraph myGraph;
    private ITreeRange myRange;
    private JetHashSet`1<IControlFlowElement> myLeafElements;
    private Dictionary`2<IControlFlowElement, bool> myInsideCache;
    private OneToSetMap`2<IControlFlowElement, ITypeOwner> myReadVariables;
    private OneToSetMap`2<IControlFlowElement, ITypeOwner> myWrittenVariables;
    private JetHashSet`1<IType> myInsideUsedAnotypes;
    private JetHashSet`1<IType> myOutsideUsedAnotypes;
    private JetHashSet`1<IType> myInsideHardUsedAnotypes;
    private JetHashSet`1<IType> myOutsideHardUsedAnotypes;
    public IEnumerable`1<IControlFlowElement> Entries { get; }
    public IEnumerable`1<IControlFlowElement> InsideElements { get; }
    public IEnumerable`1<IControlFlowElement> OutsideElements { get; }
    public IEnumerable`1<IControlFlowElement> EntryDoorways { get; }
    public IEnumerable`1<IControlFlowEdge> ExitEdges { get; }
    public IEnumerable`1<IControlFlowEdge> EntryEdges { get; }
    protected ControlFlowAnalyzer(IControlFlowGraph graph, ITreeRange range);
    public ICollection`1<LocalVariable> AnalyzeVariables();
    protected virtual IDeclaredElement GetImplicitlyDeclaredElement(ITreeNode treeNode);
    protected virtual IDeclaredElement GetPrimaryElement(IDeclaredElement variable);
    protected virtual IType GetAnotypeUsed(ITreeNode element);
    protected virtual IType GetAnotypeHardUsed(ITreeNode element);
    protected virtual bool IsAnotyped(ITypeOwner v);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.ControlFlowAnalyzer/<get_Entries>d__18")]
public IEnumerable`1<IControlFlowElement> get_Entries();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.ControlFlowAnalyzer/<get_InsideElements>d__20")]
public IEnumerable`1<IControlFlowElement> get_InsideElements();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.ControlFlowAnalyzer/<get_OutsideElements>d__22")]
public IEnumerable`1<IControlFlowElement> get_OutsideElements();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.ControlFlowAnalyzer/<get_EntryDoorways>d__24")]
public IEnumerable`1<IControlFlowElement> get_EntryDoorways();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.ControlFlowAnalyzer/<get_ExitEdges>d__26")]
public IEnumerable`1<IControlFlowEdge> get_ExitEdges();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.ControlFlowAnalyzer/<get_EntryEdges>d__28")]
public IEnumerable`1<IControlFlowEdge> get_EntryEdges();
    protected bool IsInside(IControlFlowElement element);
    protected abstract virtual void EvaluateReadAndWrittenVariables(IControlFlowElement element, ICollection`1<ITypeOwner> readVariables, ICollection`1<ITypeOwner> writtenVariables);
    protected virtual bool IsVariable(IDeclaredElement typeOwner);
    protected virtual bool PreviewRequiredOutside(ITypeOwner variable, bool value, bool modifiedInside);
    protected virtual bool PreviewPassedInside(ITypeOwner variable, bool value);
    protected virtual bool PreviewMightBeDeclaredForOutside(ITypeOwner variable, bool value);
    private static bool TrueForAll(IEnumerable`1<T> e, Predicate`1<T> p);
    public ExtractMethodAvailabilityCheckResult CheckEntriesAndExits(IEnumerable`1<IControlFlowEdge> returnEdgesEnumerable);
    public virtual bool IsThrow(IControlFlowEdge exitEdge);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.ControlFlowAnalyzer/<UsedAnotypes>d__39")]
private IEnumerable`1<IType> UsedAnotypes();
    public bool HasAnotypes();
    protected static IType AnotypeUsed(ITreeNode element);
    public static IType GetUsedAnotype(IType type);
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractMethod.ExpressionExtractMethodBase : ExtractMethodBase {
    [NotNullAttribute]
private IExpression myExpression;
    private static string RETURN_VALUE;
    [CompilerGeneratedAttribute]
private ICollection`1<LocalVariable> <LocalVariables>k__BackingField;
    [NotNullAttribute]
public IExpression Expression { get; }
    [NotNullAttribute]
public ICollection`1<LocalVariable> LocalVariables { get; }
    public bool IsValid { get; }
    public IEnumerable`1<string> ReturnValueChoices { get; }
    public string ReturnValue { get; public set; }
    protected ExpressionExtractMethodBase(bool canBeStatic, bool canBeInstance, IExpression expression, ICollection`1<LocalVariable> localVariables);
    public IExpression get_Expression();
    [CompilerGeneratedAttribute]
public virtual ICollection`1<LocalVariable> get_LocalVariables();
    public virtual bool get_IsValid();
    public virtual IEnumerable`1<IType> UsedAnotypes();
    private string GetMethodName(IExpression expression);
    public virtual IEnumerable`1<string> get_ReturnValueChoices();
    public virtual string get_ReturnValue();
    public virtual void set_ReturnValue(string value);
    protected abstract virtual ExtractMethodParameter CreateParameter(LocalVariable variable);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "ExtractMethodActionText")]
[VsOverrideActionAttribute("({1496A755-94DE-11D0-8C3F-00C04FC2AAE2}:1551)")]
public class JetBrains.ReSharper.Refactorings.ExtractMethod.ExtractMethodAction : ExtensibleRefactoringAction`1<IExtractMethodWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
    public sealed virtual bool ShouldFallBack(IDataContext context);
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod.ExtractMethodAvailabilityCheckResult : EnumPattern {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BlocksRefactoring>k__BackingField;
    public static ExtractMethodAvailabilityCheckResult Success;
    public static ExtractMethodAvailabilityCheckResult UnsupportedLanguage;
    public static ExtractMethodAvailabilityCheckResult Disabled;
    public static ExtractMethodAvailabilityCheckResult ExpressionHasUnknownType;
    public static ExtractMethodAvailabilityCheckResult ExpressionHasVoidType;
    public static ExtractMethodAvailabilityCheckResult ExpressionHasAnonymousType;
    public static ExtractMethodAvailabilityCheckResult BlockHasMultipleEntries;
    public static ExtractMethodAvailabilityCheckResult BlockHasExitsToVariousPoints;
    [NotNullAttribute]
public string Message { get; }
    public bool BlocksRefactoring { get; }
    public ExtractMethodAvailabilityCheckResult(string name, string message, bool blocksRefactoring);
    private static ExtractMethodAvailabilityCheckResult();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public bool get_BlocksRefactoring();
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractMethod.ExtractMethodBase : object {
    private AccessRights myAccessRights;
    private bool myAllowPrivate;
    private bool myMakeStatic;
    private string myName;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeMemberDeclaration <ExtractedDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private PartialSorter`1<ExtractMethodParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeInstance>k__BackingField;
    public PsiLanguageType LanguageType { get; }
    public ICollection`1<LocalVariable> LocalVariables { get; }
    public PsiLanguageType Language { get; }
    protected bool AllowPrivate { get; protected set; }
    [NotNullAttribute]
public ISolution Solution { get; }
    [NotNullAttribute]
public IPsiModule Module { get; }
    public IEnumerable`1<string> ReturnValueChoices { get; }
    public string ReturnValue { get; public set; }
    public ITypeMemberDeclaration ExtractedDeclaration { get; public set; }
    [NotNullAttribute]
public PartialSorter`1<ExtractMethodParameter> Parameters { get; }
    public AccessRights AccessRights { get; public set; }
    public bool CanBeStatic { get; }
    public bool CanBeInstance { get; }
    public bool MakeStatic { get; public set; }
    [NotNullAttribute]
public string Name { get; public set; }
    public bool IsValid { get; }
    protected ExtractMethodBase(bool canBeStatic, bool canBeInstance, IPsiModule module);
    public abstract virtual PsiLanguageType get_LanguageType();
    public abstract virtual ICollection`1<LocalVariable> get_LocalVariables();
    public abstract virtual PsiLanguageType get_Language();
    protected bool get_AllowPrivate();
    protected void set_AllowPrivate(bool value);
    public ISolution get_Solution();
    [CompilerGeneratedAttribute]
public IPsiModule get_Module();
    public abstract virtual IEnumerable`1<string> get_ReturnValueChoices();
    public abstract virtual string get_ReturnValue();
    public abstract virtual void set_ReturnValue(string value);
    public abstract virtual string PreviewDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeMemberDeclaration get_ExtractedDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtractedDeclaration(ITypeMemberDeclaration value);
    [CompilerGeneratedAttribute]
public sealed virtual PartialSorter`1<ExtractMethodParameter> get_Parameters();
    public sealed virtual AccessRights get_AccessRights();
    public sealed virtual void set_AccessRights(AccessRights value);
    public virtual bool IsSupportedAccessRights(AccessRights accessRights);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanBeStatic();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanBeInstance();
    public sealed virtual bool get_MakeStatic();
    public sealed virtual void set_MakeStatic(bool value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public sealed virtual bool IsValidName(string name);
    public abstract virtual bool Execute(IProgressIndicator pi);
    public virtual void PostExecute(IProgressIndicator progressIndicator);
    public virtual ExtractMethodAvailabilityCheckResult Check();
    public virtual bool get_IsValid();
    protected void SetSupportedAccessRights(ITreeRange treeRange);
    public ExtractMethodParameter FindParameter(LocalVariable localVariable);
    public virtual IEnumerable`1<IType> UsedAnotypes();
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod.ExtractMethodParameter : object {
    [CanBeNullAttribute]
private string myName;
    [CompilerGeneratedAttribute]
private string <TypePresented>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalVariable <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pass>k__BackingField;
    public string TypePresented { get; }
    [NotNullAttribute]
public LocalVariable Variable { get; }
    public ParameterKind Kind { get; public set; }
    [NotNullAttribute]
public string Name { get; public set; }
    public bool Pass { get; public set; }
    public ExtractMethodParameter(LocalVariable variable);
    [CompilerGeneratedAttribute]
public string get_TypePresented();
    [CompilerGeneratedAttribute]
public LocalVariable get_Variable();
    [CompilerGeneratedAttribute]
public ParameterKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(ParameterKind value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Pass();
    [CompilerGeneratedAttribute]
public void set_Pass(bool value);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ExtractMethod.ExtractMethodProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod.ExtractMethodUtil : object {
    public static ExtractMethodAvailabilityCheckResult CheckExpression(IExpression expression);
    public static bool CanBeInstance(ITreeRange treeRange);
    [PublicAPIAttribute]
public static bool CanBeStatic(ITreeRange treeRange);
    public static bool CanBeStatic(ITreeRange treeRange, Func`2<ITreeNode, bool> instanceStateUsagePredicate);
    public static void ReplaceUninitializedParametersNodes(ManuallyRemappedTreeNodePointer unpassedParametersMarker);
    public static bool MightBeRequiredOutside(LocalVariable localVariable);
    public static string ReplaceNodesForPreview(ManuallyRemappedTreeNodePointer nodePointer, IDeclaration declaration);
    [NotNullAttribute]
public static ICollection`1<ITypeParameter> GetTypeParameters(ExtractMethodBase extractMethodBase);
    public static ICollection`1<ITypeParameter> GetTypeParameters(ITreeRange treeRange);
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod.ExtractMethodWorkflow : DrivenRefactoringWorkflow {
    private IExtractMethod myExtractMethod;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    public PsiLanguageType LanguageType { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public HelpId HelpKeyword { get; }
    public ExtractMethodWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual bool IsAvailable(IDataContext context);
    [CanBeNullAttribute]
private static IExtractMethodFactory GetExtractMethodFactory(IDataContext context);
    public virtual HelpId get_HelpKeyword();
    public virtual bool Initialize(IDataContext context);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
public interface JetBrains.ReSharper.Refactorings.ExtractMethod.IExtractMethod {
    public IEnumerable`1<string> ReturnValueChoices { get; }
    public string ReturnValue { get; public set; }
    public PartialSorter`1<ExtractMethodParameter> Parameters { get; }
    public bool CanBeStatic { get; }
    public bool CanBeInstance { get; }
    public bool MakeStatic { get; public set; }
    public AccessRights AccessRights { get; public set; }
    public string Name { get; public set; }
    public bool IsValid { get; }
    public PsiLanguageType LanguageType { get; }
    public ITypeMemberDeclaration ExtractedDeclaration { get; public set; }
    public abstract virtual IEnumerable`1<string> get_ReturnValueChoices();
    public abstract virtual string get_ReturnValue();
    public abstract virtual void set_ReturnValue(string value);
    public abstract virtual PartialSorter`1<ExtractMethodParameter> get_Parameters();
    public abstract virtual string PreviewDeclaration();
    public abstract virtual bool get_CanBeStatic();
    public abstract virtual bool get_CanBeInstance();
    public abstract virtual bool get_MakeStatic();
    public abstract virtual void set_MakeStatic(bool value);
    public abstract virtual AccessRights get_AccessRights();
    public abstract virtual void set_AccessRights(AccessRights value);
    public abstract virtual bool IsSupportedAccessRights(AccessRights accessRights);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual bool IsValidName(string name);
    public abstract virtual void PostExecute(IProgressIndicator pi);
    public abstract virtual ExtractMethodAvailabilityCheckResult Check();
    public abstract virtual bool get_IsValid();
    public abstract virtual PsiLanguageType get_LanguageType();
    public abstract virtual ITypeMemberDeclaration get_ExtractedDeclaration();
    public abstract virtual void set_ExtractedDeclaration(ITypeMemberDeclaration value);
}
public interface JetBrains.ReSharper.Refactorings.ExtractMethod.IExtractMethodFactory {
    [NotNullAttribute]
public abstract virtual ExtractMethodAvailabilityCheckResult CheckAvailability(ISolution solution, ITextControl textControl);
    [CanBeNullAttribute]
public abstract virtual IExtractMethod CreateExtractMethod(ISolution solution, ITextControl textControl);
}
public interface JetBrains.ReSharper.Refactorings.ExtractMethod.IExtractMethodWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod.LocalVariable : object {
    [NotNullAttribute]
private IDeclaredElementPointer`1<ITypeOwner> myVariablePointer;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeclaredInside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValuePassedInside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueRequiredOutside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencedOutside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencedInside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueNotUsedInside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MyHardUsedAnotypeInside>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MyHardUsedAnotypeOutside>k__BackingField;
    [CanBeNullAttribute]
public ITypeOwner Variable { get; }
    [NotNullAttribute]
public string Name { get; public set; }
    public bool Pass { get; public set; }
    public bool DeclaredInside { get; }
    public bool ValuePassedInside { get; }
    public bool ValueRequiredOutside { get; }
    public bool ReferencedOutside { get; }
    public bool ReferencedInside { get; }
    public bool ValueNotUsedInside { get; }
    public bool MyHardUsedAnotypeInside { get; }
    public bool MyHardUsedAnotypeOutside { get; }
    public LocalVariable(ITypeOwner variable, bool declaredInside, bool valuePassedInside, bool valueRequiredOutside, bool referencedOutside, bool referencedInside, bool valueNotUsedInside, bool hardUsedAnotypeInside, bool hardUsedAnotypeOutside);
    public ITypeOwner get_Variable();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Pass();
    [CompilerGeneratedAttribute]
public void set_Pass(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeclaredInside();
    [CompilerGeneratedAttribute]
public bool get_ValuePassedInside();
    [CompilerGeneratedAttribute]
public bool get_ValueRequiredOutside();
    [CompilerGeneratedAttribute]
public bool get_ReferencedOutside();
    [CompilerGeneratedAttribute]
public bool get_ReferencedInside();
    [CompilerGeneratedAttribute]
public bool get_ValueNotUsedInside();
    [CompilerGeneratedAttribute]
public bool get_MyHardUsedAnotypeInside();
    [CompilerGeneratedAttribute]
public bool get_MyHardUsedAnotypeOutside();
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractMethod.StatementExtractMethodBase : ExtractMethodBase {
    protected static string METHOD_RETURN_VALUE;
    public static string NO_RETURN_VALUE;
    private IParametersOwner myContainingParametersOwner;
    private IPsiSourceFile mySourceFile;
    private Dictionary`2<LocalVariable, ExtractMethodParameter> myParametersCache;
    protected ManuallyRemappedTreeNodePointer myUnpassedParametersMarker;
    private bool myNameChanged;
    private string myReturnValue;
    public string Name { get; public set; }
    protected IEnumerable`1<IControlFlowEdge> ExitEdges { get; }
    [NotNullAttribute]
public IEnumerable`1<string> ReturnValueChoices { get; }
    public string ReturnValue { get; public set; }
    protected IParametersOwner ContainingParametersOwner { get; }
    protected LocalVariable ReturnedVariable { get; }
    protected IType ReturnType { get; }
    public bool IsValid { get; }
    protected StatementExtractMethodBase(IParametersOwner containingParametersOwner, bool canBeStatic, bool canBeInstance, IPsiModule project, IPsiSourceFile sourceFile);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    protected abstract virtual IEnumerable`1<IControlFlowEdge> get_ExitEdges();
    protected abstract virtual ExtractMethodParameter CreateParameter(LocalVariable localVariable, bool isReturned);
    protected abstract virtual ExtractMethodParameter UpdateParameter(ExtractMethodParameter parameter, bool isReturned);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.StatementExtractMethodBase/<get_ReturnValueChoices>d__17")]
public virtual IEnumerable`1<string> get_ReturnValueChoices();
    public virtual string get_ReturnValue();
    public virtual void set_ReturnValue(string value);
    protected IParametersOwner get_ContainingParametersOwner();
    protected LocalVariable get_ReturnedVariable();
    protected IType get_ReturnType();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ExtractMethod.StatementExtractMethodBase/<GetExitsOfType>d__27")]
protected IEnumerable`1<IControlFlowEdge> GetExitsOfType(ControlFlowEdgeType edgeType);
    public virtual void PostExecute(IProgressIndicator progressIndicator);
    protected void InitializeReturnValue();
    public virtual bool get_IsValid();
    public virtual IEnumerable`1<IType> UsedAnotypes();
    [CompilerGeneratedAttribute]
private bool <get_ReturnedVariable>b__24_0(LocalVariable obj);
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod.VbExtractMethodPage : SingleBeRefactoringPage {
    private BeSplitControl myGrid;
    private static string myParametersGridId;
    public static string TreeGridId;
    public static string MakeStatic;
    private ISolution mySolution;
    private IShellLocks myLocks;
    private SequentialLifetimes myParametersLifetime;
    private IListEvents`1<ExtractMethodParameter> myParametersListEvents;
    protected IProperty`1<ExtractMethodParameter> mySelectedParameter;
    private bool myInitializationInProgress;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <ReturnParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <MethodName>k__BackingField;
    public string Title { get; }
    public string Description { get; }
    public IProperty`1<string> ReturnParameter { get; public set; }
    public IProperty`1<string> MethodName { get; public set; }
    public VbExtractMethodPage(IExtractMethod extractMethod, ExtractMethodWorkflow workflow);
    public virtual string get_Title();
    public virtual string get_Description();
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_ReturnParameter();
    [CompilerGeneratedAttribute]
public void set_ReturnParameter(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(IProperty`1<string> value);
    private BeGrid GetLowerPanel(IExtractMethod extractMethod, PsiLanguageType language, BeTextControlWithLanguage preview);
    private void UpdateParameters(IExtractMethod extractMethod, BeTextControlWithLanguage preview, BeButton moveUp, BeButton moveDown);
    private void UpdatePreview(IExtractMethod extractMethod, BeTextControlWithLanguage preview);
    public virtual BeControl GetPageContent();
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod2.ConstructorParameterWrapper : object {
    private BeGrid myLastColumnContent;
    [CompilerGeneratedAttribute]
private ParameterElement <ParameterElement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAsProperty>k__BackingField;
    public ParameterElement ParameterElement { get; }
    public bool UseAsProperty { get; private set; }
    public ConstructorParameterWrapper(ParameterElement parameterElement, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public ParameterElement get_ParameterElement();
    [CompilerGeneratedAttribute]
public bool get_UseAsProperty();
    [CompilerGeneratedAttribute]
private void set_UseAsProperty(bool value);
    public List`1<BeControl> GetLine(Lifetime lifetime, IPsiSourceFile dataSourceFile, Action action);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(bool v);
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod2.ExtractClassMethodObjectModel : object {
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ConstructorParameterWrapper> <Parameters>k__BackingField;
    public string ClassName { get; public set; }
    public List`1<ConstructorParameterWrapper> Parameters { get; }
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public List`1<ConstructorParameterWrapper> get_Parameters();
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractMethod2.ExtractMethodControlFlowInspectorBase`2 : ControlFlowGraphInspector`1<TExtractMethodInspectionContext> {
    [NotNullAttribute]
private ITreeRange myTreeRange;
    [NotNullAttribute]
private ITreeNode myGraphOwner;
    [NotNullAttribute]
protected OneToSetMap`2<ITreeNode, TTypeOwner> ReadUsagesInside;
    [NotNullAttribute]
protected OneToSetMap`2<ITreeNode, TTypeOwner> ReadUsagesOutside;
    [NotNullAttribute]
protected OneToSetMap`2<ITreeNode, TTypeOwner> WriteUsagesInside;
    [NotNullAttribute]
protected OneToSetMap`2<ITreeNode, TTypeOwner> WriteUsagesOutside;
    [NotNullAttribute]
protected HashSet`1<TTypeOwner> VariablesReadInLambdaInside;
    [NotNullAttribute]
protected HashSet`1<TTypeOwner> VariablesWriteInLambdaInside;
    [NotNullAttribute]
protected OneToSetMap`2<ITreeNode, TTypeOwner> VariablesReadInLambdaOutside;
    [NotNullAttribute]
protected OneToSetMap`2<ITreeNode, TTypeOwner> VariablesWriteInLambdaOutside;
    [NotNullAttribute]
protected List`1<IControlFlowEdge> OutcomingEdges;
    [NotNullAttribute]
protected List`1<IControlFlowEdge> IncomingEdges;
    protected ExtractMethodControlFlowInspectorBase`2(ITreeRange treeRange, ITreeNode graphOwner, IControlFlowGraph graph, IControlFlowContextFactory`1<TExtractMethodInspectionContext> contextFactory);
    protected virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement element, TExtractMethodInspectionContext context);
    protected abstract virtual void InspectLeafNode(IControlFlowElement element, ITreeNode sourceElement, TExtractMethodInspectionContext context);
    [ContractAnnotationAttribute("null => false")]
protected bool IsInside(IControlFlowElement element);
    [ContractAnnotationAttribute("null => false")]
protected bool IsOutside(IControlFlowElement element);
    [ContractAnnotationAttribute("null => false")]
protected bool IsInside(ITreeNode sourceElement);
    protected void BuildIncomingOutcomingEdges();
    protected void AddUsage(ITreeNode node, TTypeOwner typeOwner, bool isReadUsage);
    [ContractAnnotationAttribute("null => false")]
protected virtual bool IsUsageFromDelegateClosure(ITreeNode controlFlowOwner);
    [CanBeNullAttribute]
protected abstract virtual ITreeNode FindControlFlowOwner(ITreeNode context);
    protected bool IsAssignedInside(ITreeNode treeNode, TTypeOwner typeOwner);
    protected bool IsAssignedOutside(ITreeNode treeNode, TTypeOwner typeOwner);
    protected bool ValueIsAssignedInside(IControlFlowEdge edge, IDeclaredElement typeOwner);
    protected bool DefaultValueIsOverridden(IControlFlowEdge edge, IDeclaredElement typeOwner);
    protected bool DefaultValueIsOverriddenInside(IControlFlowEdge edge, IDeclaredElement typeOwner);
    [CanBeNullAttribute]
protected abstract virtual ITreeNode GetDeclaration(TTypeOwner typeOwner);
    public ExtractMethodParameterValueInfo InspectValueFlow(TTypeOwner typeOwner, bool isFieldLikeParameter);
    protected virtual bool CanReturnOutside(TTypeOwner typeOwner);
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractMethod2.ExtractMethodInspectionContextBase : object {
    [CompilerGeneratedAttribute]
private OneToSetMap`2<IDeclaredElement, ITreeNode> <ReachingWriteUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<IDeclaredElement> <DefaultIsOverridden>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<IDeclaredElement> <DefaultIsOverriddenInside>k__BackingField;
    [NotNullAttribute]
public OneToSetMap`2<IDeclaredElement, ITreeNode> ReachingWriteUsages { get; }
    [NotNullAttribute]
public HashSet`1<IDeclaredElement> DefaultIsOverridden { get; }
    [NotNullAttribute]
public HashSet`1<IDeclaredElement> DefaultIsOverriddenInside { get; }
    protected ExtractMethodInspectionContextBase(ExtractMethodInspectionContextBase other);
    [CompilerGeneratedAttribute]
public OneToSetMap`2<IDeclaredElement, ITreeNode> get_ReachingWriteUsages();
    [CompilerGeneratedAttribute]
public HashSet`1<IDeclaredElement> get_DefaultIsOverridden();
    [CompilerGeneratedAttribute]
public HashSet`1<IDeclaredElement> get_DefaultIsOverriddenInside();
    [NotNullAttribute]
protected abstract virtual ExtractMethodInspectionContextBase CloneSelf();
    protected void Merge(IList`1<TContexts> contexts);
    [NotNullAttribute]
public ExtractMethodInspectionContextBase Write(IDeclaredElement typeOwner, ITreeNode treeNode, bool writeOnly);
    public virtual bool Equals(ExtractMethodInspectionContextBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.ReSharper.Refactorings.ExtractMethod2.ExtractMethodModel : object {
    [CompilerGeneratedAttribute]
private IReturnParameter <ReturnParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultName>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectFileType <FileType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NameRoot> <Roots>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractMethodNameSuggestionContext <NameSuggestionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasErrorsInName>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredElementType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractClassMethodObjectModel <TargetModel>k__BackingField;
    public string Title { get; }
    public string Description { get; }
    public IReturnParameter ReturnParameter { get; public set; }
    public string MethodName { get; public set; }
    public string DefaultName { get; protected set; }
    public PsiLanguageType Language { get; }
    public ProjectFileType FileType { get; }
    public IEnumerable`1<NameRoot> Roots { get; protected set; }
    public NamingPolicy NamingPolicy { get; }
    public ExtractMethodNameSuggestionContext NameSuggestionContext { get; protected set; }
    public bool CanChangeReturn { get; }
    public bool CanChangeName { get; }
    public bool CanHaveParameters { get; }
    public bool HasErrorsInName { get; public set; }
    public DeclaredElementType Type { get; protected set; }
    public IPsiSourceFile SourceFile { get; }
    public ExtractClassMethodObjectModel TargetModel { get; public set; }
    protected ExtractMethodModel(IPsiSourceFile psiSourceFile);
    public abstract virtual string get_Title();
    public abstract virtual string get_Description();
    [CompilerGeneratedAttribute]
public virtual IReturnParameter get_ReturnParameter();
    [CompilerGeneratedAttribute]
public virtual void set_ReturnParameter(IReturnParameter value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultName();
    [CompilerGeneratedAttribute]
protected void set_DefaultName(string value);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
public ProjectFileType get_FileType();
    [CompilerGeneratedAttribute]
public IEnumerable`1<NameRoot> get_Roots();
    [CompilerGeneratedAttribute]
protected void set_Roots(IEnumerable`1<NameRoot> value);
    public abstract virtual NamingPolicy get_NamingPolicy();
    [CompilerGeneratedAttribute]
public ExtractMethodNameSuggestionContext get_NameSuggestionContext();
    [CompilerGeneratedAttribute]
protected void set_NameSuggestionContext(ExtractMethodNameSuggestionContext value);
    public virtual bool get_CanChangeReturn();
    public virtual bool get_CanChangeName();
    public virtual bool get_CanHaveParameters();
    [CompilerGeneratedAttribute]
public bool get_HasErrorsInName();
    [CompilerGeneratedAttribute]
public void set_HasErrorsInName(bool value);
    [CompilerGeneratedAttribute]
public DeclaredElementType get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(DeclaredElementType value);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
public ExtractClassMethodObjectModel get_TargetModel();
    [CompilerGeneratedAttribute]
public void set_TargetModel(ExtractClassMethodObjectModel value);
    public abstract virtual string GetPreviewElement();
    public abstract virtual IEnumerable`1<ParameterElement> GetPossibleParameters();
    public abstract virtual IEnumerable`1<IReturnParameter> GetPossibleReturnParameters();
    public virtual BeGrid GetSpecificPresentation(Lifetime lifetime, Action update);
    public abstract virtual String[] GetColumns();
    public abstract virtual void InitializeNaming();
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod2.ExtractMethodObjectPage : ExtractMethodPage {
    private ExtractClassMethodObjectModel myEcmoModel;
    public static string CtorSelectedTreeGridId;
    public static string ClassNameId;
    public static string ClassVisibilityId;
    private static string myCtorParametersGridId;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <ClassName>k__BackingField;
    private static string myParametersGridId;
    public static string TreeGridId;
    public static string MakeStatic;
    public static string MakeVirtual;
    protected ExtractMethodModel myData;
    private ISolution mySolution;
    private IShellLocks myLocks;
    private SequentialLifetimes myParametersLifetime;
    public ListEvents`1<object> myParametersListEvents;
    protected IProperty`1<object> mySelectedParameter;
    private bool myInitializationInProgress;
    private int methodHeaderIndex;
    public IProperty`1<string> ClassName { get; public set; }
    public string Description { get; }
    public string Title { get; }
    public ExtractMethodObjectPage(ExtractMethodModel model, ISolution solution, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(IProperty`1<string> value);
    public virtual string get_Description();
    public virtual string get_Title();
    public virtual void UpdatePreview(Lifetime lifetime, BeTextControlWithLanguage preview);
    private void UpdateParameters(Lifetime lifetime, BeTextControlWithLanguage preview, BeButton moveUp, BeButton moveDown);
    public virtual BeControl GetPageContent();
    private BeSpanGrid GetUpperPanel(IconModel errorIcon, PsiLanguageType language, BeTextControlWithLanguage preview);
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod2.ExtractMethodPage : SingleBeRefactoringPage {
    private static string myParametersGridId;
    public static string TreeGridId;
    public static string MakeStatic;
    public static string MakeVirtual;
    protected ExtractMethodModel myData;
    private ISolution mySolution;
    private IShellLocks myLocks;
    private SequentialLifetimes myParametersLifetime;
    public ListEvents`1<ParameterElement> myParametersListEvents;
    protected IProperty`1<ParameterElement> mySelectedParameter;
    private bool myInitializationInProgress;
    [NotNullAttribute]
private FreeThreadedGroupingEvent myUpdatePreviewOnTextBoxChangeGroupingEvent;
    [NotNullAttribute]
private SynchronizedSet`1<RenameSuggestion> myProvidedSuggestions;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<IReturnParameter> <ReturnParameter>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public IProperty`1<string> MethodName { get; public set; }
    public IProperty`1<IReturnParameter> ReturnParameter { get; protected set; }
    public ExtractMethodPage(ExtractMethodModel model, ISolution solution, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_MethodName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MethodName(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<IReturnParameter> get_ReturnParameter();
    [CompilerGeneratedAttribute]
protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReturnParameter(IProperty`1<IReturnParameter> value);
    public void UpdatePreview(Lifetime lifetime, BeTextControlWithLanguage preview);
    private void UpdateParameters(Lifetime lifetime, BeTextControlWithLanguage preview, BeButton moveUp, BeButton moveDown);
    public virtual BeControl GetPageContent();
    public virtual bool RefreshContents(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod2.ExtractMethodParameterValueInfo : ValueType {
    public bool MustPassValueIn;
    public bool MustPassValueOut;
    public bool HasWriteUsagesInside;
    public bool CanReturnOutside;
}
public class JetBrains.ReSharper.Refactorings.ExtractMethod2.HeaderSection : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public HeaderSection(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
public interface JetBrains.ReSharper.Refactorings.ExtractMethod2.IReturnParameter {
}
public interface JetBrains.ReSharper.Refactorings.Helpers.INamespaceRedundancyProblemFixer {
    public bool IsEmpty { get; }
    public IProjectFile ProjectFile { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual IProjectFile get_ProjectFile();
    public abstract virtual void FixUsages();
}
public class JetBrains.ReSharper.Refactorings.Helpers.NamespaceRedundancyProblemsFixer : object {
    private ISolution mySolution;
    private INamespace myNamespace;
    private IClrDeclaredElement[] myElementsThatWillDisappear;
    private IList`1<INamespaceRedundancyProblemFixer> myFixers;
    public NamespaceRedundancyProblemsFixer(INamespace namespace, IClrDeclaredElement[] elementsThatWillDisappear);
    public void CollectProblems(IProgressIndicator progressIndicator);
    public IList`1<INamespaceRedundancyProblemFixer> GetFixers();
    public void FixProblems(IProgressIndicator progressIndicator);
    public static IList`1<ProjectsPerNamespace> EvaluateAffectedProjects(INamespace ns, JetHashSet`1<IClrDeclaredElement> elementsThatWillDisappear);
    private IList`1<INamespaceRedundancyProblemFixer> CreateFileFixers(IProgressIndicator progressIndicator, IList`1<ProjectsPerNamespace> projectsPerNamespaces);
}
public interface JetBrains.ReSharper.Refactorings.ILanguageSpecificRefactoringService {
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.ArgUtil.ArgumentFromParameter : object {
    public int First { get; }
    public int Last { get; }
    public bool IsEmpty { get; }
    public bool IsQualifier { get; }
    public bool IsExpandedParameterArray { get; }
    public abstract virtual int get_First();
    public abstract virtual int get_Last();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsQualifier();
    public virtual bool get_IsExpandedParameterArray();
}
public class JetBrains.ReSharper.Refactorings.Inline.ArgUtil.ArgumentFromParameterArray : ArgumentFromParameter {
    private int myFirst;
    private int myLast;
    public int First { get; }
    public int Last { get; }
    public bool IsExpandedParameterArray { get; }
    public ArgumentFromParameterArray(int first, int last);
    public virtual int get_First();
    public virtual int get_Last();
    public virtual bool get_IsExpandedParameterArray();
}
public class JetBrains.ReSharper.Refactorings.Inline.ArgUtil.ArgumentFromParameterQualifier : ArgumentFromParameter {
    public int First { get; }
    public int Last { get; }
    public bool IsQualifier { get; }
    public virtual int get_First();
    public virtual int get_Last();
    public virtual bool get_IsQualifier();
}
public class JetBrains.ReSharper.Refactorings.Inline.ArgUtil.ArgumentFromParameterSimple : ArgumentFromParameter {
    private int myIndex;
    public int First { get; }
    public int Last { get; }
    public ArgumentFromParameterSimple(int index);
    public virtual int get_First();
    public virtual int get_Last();
}
public class JetBrains.ReSharper.Refactorings.Inline.ArgUtil.EmptyArgumentFromParameter : ArgumentFromParameter {
    public int First { get; }
    public int Last { get; }
    public bool IsEmpty { get; }
    public virtual int get_First();
    public virtual int get_Last();
    public virtual bool get_IsEmpty();
}
public class JetBrains.ReSharper.Refactorings.Inline.AssignmentInfo : object {
    [CompilerGeneratedAttribute]
private ITokenNode <AssignmentOperatorSign>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <DestinationOfAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <AssignedExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDestinationOfAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAssignmentStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <InitializedVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private static AssignmentInfo <NoAssignment>k__BackingField;
    public ITokenNode AssignmentOperatorSign { get; public set; }
    public IExpression DestinationOfAssignment { get; public set; }
    public IExpression AssignedExpression { get; public set; }
    public bool IsDestinationOfAssignment { get; public set; }
    public bool IsSourceOfAssignment { get; }
    public bool IsAssignmentStatement { get; public set; }
    public IDeclaredElement InitializedVariable { get; public set; }
    public static AssignmentInfo NoAssignment { get; }
    private static AssignmentInfo();
    [CompilerGeneratedAttribute]
public ITokenNode get_AssignmentOperatorSign();
    [CompilerGeneratedAttribute]
public void set_AssignmentOperatorSign(ITokenNode value);
    [CompilerGeneratedAttribute]
public IExpression get_DestinationOfAssignment();
    [CompilerGeneratedAttribute]
public void set_DestinationOfAssignment(IExpression value);
    [CompilerGeneratedAttribute]
public IExpression get_AssignedExpression();
    [CompilerGeneratedAttribute]
public void set_AssignedExpression(IExpression value);
    [CompilerGeneratedAttribute]
public bool get_IsDestinationOfAssignment();
    [CompilerGeneratedAttribute]
public void set_IsDestinationOfAssignment(bool value);
    public bool get_IsSourceOfAssignment();
    [CompilerGeneratedAttribute]
public bool get_IsAssignmentStatement();
    [CompilerGeneratedAttribute]
public void set_IsAssignmentStatement(bool value);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_InitializedVariable();
    [CompilerGeneratedAttribute]
public void set_InitializedVariable(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public static AssignmentInfo get_NoAssignment();
}
public class JetBrains.ReSharper.Refactorings.Inline.CallSiteContext : object {
    private ISubstitution mySubstitution;
    [CompilerGeneratedAttribute]
private ICallSiteContextOwner <CallSiteContextOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <CastSearchContext>k__BackingField;
    public ISubstitution Substitution { get; }
    public ICallSiteContextOwner CallSiteContextOwner { get; }
    public ITreeNode CastSearchContext { get; }
    public CallSiteContext(ICallSiteContextOwner refactoring, ISubstitution substitution, ITreeNode containingElement);
    public ISubstitution get_Substitution();
    [CompilerGeneratedAttribute]
public ICallSiteContextOwner get_CallSiteContextOwner();
    [CompilerGeneratedAttribute]
public ITreeNode get_CastSearchContext();
    public void RemapAndBind(ReferenceIdentitySaver saver, PsiLanguageType language);
    private void FixReferences(IReference reference, LocalContextResolveResultImage resultImage);
}
public class JetBrains.ReSharper.Refactorings.Inline.CheckTypeKey : object {
    [CompilerGeneratedAttribute]
private IParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public IParameter Parameter { get; public set; }
    public IType Type { get; public set; }
    public CheckTypeKey(IParameter parameter, IType type);
    [CompilerGeneratedAttribute]
public IParameter get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(IParameter value);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IType value);
}
public interface JetBrains.ReSharper.Refactorings.Inline.CodeTransformers.IInlinedCodeTransformHelper`1 {
    public ITreeNode TargetContext { get; public set; }
    public abstract virtual ITreeNode get_TargetContext();
    public abstract virtual void set_TargetContext(ITreeNode value);
    public abstract virtual ITreeNode ChangeName(ITreeNode element, string name);
    public abstract virtual ITreeNode AddActionReplaceWithDefaultParamValue(TReferenceExpression expression, IParameter parameter);
    public abstract virtual ITreeNode AddActionReplaceParameterWithArgumentExpression(TReferenceExpression expression, IParameter parameter, InlinedArgumentInfo info, ArgumentFromParameter argumentFromParameter);
    public abstract virtual ITreeNode AddActionReplaceExpressionWithTemp(IExpression expression, string newTempName);
    public abstract virtual ITreeNode AddActionSetQualifier(TReferenceExpression expression, IQualifierOwnerCallInfo info);
    public abstract virtual ITreeNode ReplaceByQualifier(TReferenceExpression expression, IQualifierOwnerCallInfo info);
    public abstract virtual bool IsExtensionMethod(TReferenceExpression expression);
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.CodeTransformers.InlinedCodeTransformerBase`1 : object {
    [NotNullAttribute]
private ITreeNode myExpression;
    [CompilerGeneratedAttribute]
private CallSiteContext <CallSiteContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IInlinedCodeTransformHelper`1<TReferenceExpression> <Helper>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
protected List`1<Func`1<ITreeNode>> TransformActions;
    [NotNullAttribute]
protected CallSiteContext CallSiteContext { get; }
    protected IInlinedCodeTransformHelper`1<TReferenceExpression> Helper { get; }
    public bool ProcessingIsFinished { get; }
    protected InlinedCodeTransformerBase`1(ITreeNode expression, CallSiteContext callSiteContext, IInlinedCodeTransformHelper`1<TReferenceExpression> helper);
    [CompilerGeneratedAttribute]
protected CallSiteContext get_CallSiteContext();
    [CompilerGeneratedAttribute]
protected IInlinedCodeTransformHelper`1<TReferenceExpression> get_Helper();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    [NotNullAttribute]
public ITreeNode Transform(ITreeNode namingContext, LocalDeclarationIdentity identity);
    private ITreeNode TransformInternal();
    protected abstract virtual void TransformElement(ITreeNode element);
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.CodeTransformers.InlinedPropertyCodeTransformerBase`1 : ParametersInlineCodeTransformerBase`1<TReferenceExpression> {
    [NotNullAttribute]
protected InlinedParameterCallSiteInfo myInlinedCallInfo;
    protected InlinedPropertyCodeTransformerBase`1(ITreeNode expression, InlinedParameterCallSiteInfo inlinedCallInfo, CallSiteContext context, IInlinedCodeTransformHelper`1<TReferenceExpression> helper);
    protected void TransformNQReferenceExpression(TReferenceExpression expression, IReference reference);
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.CodeTransformers.InlinedTypeOwnerInitializerTransformerBase`1 : InlinedCodeTransformerBase`1<TReferenceExpression> {
    [NotNullAttribute]
protected InlineTypeOwnerInitializerCallInfo myInlinedCallInfo;
    protected InlinedTypeOwnerInitializerTransformerBase`1(ITreeNode expression, InlineTypeOwnerInitializerCallInfo inlinedCallInfo, CallSiteContext context, IInlinedCodeTransformHelper`1<TReferenceExpression> helper);
    protected void TransformNQReferenceExpression(TReferenceExpression expression, IReference reference);
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.CodeTransformers.InlineMethodCodeTransformerBase`2 : ParametersInlineCodeTransformerBase`1<TReferenceExpression> {
    [NotNullAttribute]
protected InlineMethodCallInfo myInlinedCallInfo;
    protected InlineMethodCodeTransformerBase`2(ITreeNode expression, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context, IInlinedCodeTransformHelper`1<TReferenceExpression> helper);
    protected void TransformReturnStatement(TReturnStatement returnStatement);
    protected abstract virtual ITreeNode AddActionReplaceReturnWithAssignmentToTemp(TReturnStatement returnStatement);
    protected abstract virtual ITreeNode AddActionRemoveReturn(TReturnStatement returnStatement);
    protected abstract virtual ITreeNode ReplaceReturnWithAssignment(TReturnStatement returnStatement);
    protected virtual ITreeNode FixReturnReferenceKindForCallSite(TReturnStatement returnStatement);
    protected void TransformNQReferenceExpression(TReferenceExpression expression, IReference reference);
    protected virtual bool IsExtensionMethod(TReferenceExpression expression);
    protected abstract virtual ITreeNode ReplaceByQualifier(TReferenceExpression expression, InlineMethodCallInfo info);
    protected abstract virtual bool IsSetterParameter(IParameter parameter);
    protected abstract virtual ITreeNode AddActionReplaceExpressionWithAssignedExpression(TReferenceExpression expression);
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.CodeTransformers.IntroduceParameterCodeTransformerBase`1 : ParametersInlineCodeTransformerBase`1<TReferenceExpression> {
    [NotNullAttribute]
protected IntroduceParameterInlineCallInfo myInlinedCallInfo;
    protected IntroduceParameterCodeTransformerBase`1(ITreeNode expression, IntroduceParameterInlineCallInfo inlinedCallInfo, CallSiteContext context, IInlinedCodeTransformHelper`1<TReferenceExpression> helper);
    protected void TransformNQReferenceExpression(TReferenceExpression expression, IReference reference);
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.CodeTransformers.ParametersInlineCodeTransformerBase`1 : InlinedCodeTransformerBase`1<TReferenceExpression> {
    protected ParametersInlineCodeTransformerBase`1(ITreeNode expression, CallSiteContext callSiteContext, IInlinedCodeTransformHelper`1<TReferenceExpression> helper);
    protected void ReplaceInlinedParameter(TReferenceExpression expression, InlinedArgumentInfo argumentInfo, IParameter parameter, ArgumentFromParameter argumentFromParameter);
}
public class JetBrains.ReSharper.Refactorings.Inline.ForcedCast : object {
}
public interface JetBrains.ReSharper.Refactorings.Inline.ICallSiteContextOwner {
    public Dictionary`2<IReference, LocalContextResolveResultImage> ResolveImages { get; }
    public IRefactoringDriver Driver { get; }
    public abstract virtual Dictionary`2<IReference, LocalContextResolveResultImage> get_ResolveImages();
    public abstract virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public abstract virtual IRefactoringDriver get_Driver();
    public abstract virtual void AddContext(ITreeNode context);
}
public interface JetBrains.ReSharper.Refactorings.Inline.IInlineMethodDataProvider {
    public bool ReplaceAllOccurrences { get; }
    public bool Remove { get; public set; }
    public bool ForceUseDelegate { get; public set; }
    public abstract virtual bool get_ReplaceAllOccurrences();
    public abstract virtual bool get_Remove();
    public abstract virtual void set_Remove(bool value);
    public abstract virtual bool get_ForceUseDelegate();
    public abstract virtual void set_ForceUseDelegate(bool value);
}
public class JetBrains.ReSharper.Refactorings.Inline.Impl.LocalContextResolveResultImage : object {
    [CompilerGeneratedAttribute]
private IReference <InitialReference>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WithError>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IReference, bool> <IsBoundSuccessfully>k__BackingField;
    public IReference InitialReference { get; private set; }
    public IDeclaredElement DeclaredElement { get; private set; }
    public ISubstitution Substitution { get; private set; }
    public bool WithError { get; private set; }
    public bool IsValid { get; }
    public Func`2<IReference, bool> IsBoundSuccessfully { get; public set; }
    [CompilerGeneratedAttribute]
public IReference get_InitialReference();
    [CompilerGeneratedAttribute]
private void set_InitialReference(IReference value);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
private void set_DeclaredElement(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    [CompilerGeneratedAttribute]
private void set_Substitution(ISubstitution value);
    [CompilerGeneratedAttribute]
public bool get_WithError();
    [CompilerGeneratedAttribute]
private void set_WithError(bool value);
    public bool get_IsValid();
    [CompilerGeneratedAttribute]
public Func`2<IReference, bool> get_IsBoundSuccessfully();
    [CompilerGeneratedAttribute]
public void set_IsBoundSuccessfully(Func`2<IReference, bool> value);
    public static bool IsBoundSuccessfullyDefaultPredicate(IReference newReference);
    [CanBeNullAttribute]
public static LocalContextResolveResultImage CreateImage(IReference reference);
    public static void TryBindContextReferences(IEnumerable`1<KeyValuePair`2<IReference, LocalContextResolveResultImage>> references);
    public static Dictionary`2<IReference, LocalContextResolveResultImage> SaveContextReferences(ITreeNode element);
}
[ActionAttribute("InlineVariable", "JetBrains.ReSharper.Refactorings.Resources.Strings", "InlineActionText")]
public class JetBrains.ReSharper.Refactorings.Inline.InlineAction : ExtensibleRefactoringAction`1<InlineWorkflowProvider> {
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.Inline.InlinedArgumentInfo : object {
    [CompilerGeneratedAttribute]
private bool <CanHaveSideEffects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IArgument> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempVariableName>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <Kind>k__BackingField;
    public bool CanHaveSideEffects { get; private set; }
    public bool ShouldCreateLocals { get; public set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public List`1<IArgument> Arguments { get; private set; }
    public IParameter Parameter { get; private set; }
    public string TempVariableName { get; public set; }
    public ReferenceKind Kind { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CanHaveSideEffects();
    [CompilerGeneratedAttribute]
private void set_CanHaveSideEffects(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldCreateLocals();
    [CompilerGeneratedAttribute]
public void set_ShouldCreateLocals(bool value);
    [CompilerGeneratedAttribute]
public List`1<IArgument> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(List`1<IArgument> value);
    [CompilerGeneratedAttribute]
public IParameter get_Parameter();
    [CompilerGeneratedAttribute]
private void set_Parameter(IParameter value);
    [CompilerGeneratedAttribute]
public string get_TempVariableName();
    [CompilerGeneratedAttribute]
public void set_TempVariableName(string value);
    [CompilerGeneratedAttribute]
public ReferenceKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(ReferenceKind value);
    public static InlinedArgumentInfo CreateInfo(IArgument argument, InlineHelper helper, IParameter parameter, IArgumentsOwner argumentsOwner);
    public static InlinedArgumentInfo CreateInfoOfParams(List`1<IArgument> arguments, InlineHelper helper, IParameter parameter);
    public static InlinedArgumentInfo CreateInfoOfOptional(IParameter parameter);
}
public enum JetBrains.ReSharper.Refactorings.Inline.InlinedElementKinds : Enum {
    public int value__;
    public static InlinedElementKinds Method;
    public static InlinedElementKinds Setter;
    public static InlinedElementKinds Getter;
}
public class JetBrains.ReSharper.Refactorings.Inline.InlinedMethodInfo : object {
    [CompilerGeneratedAttribute]
private InlinedElementKinds <InlinedElementKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSingleLineReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTopLevelUsingDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllReturnsAreLast>k__BackingField;
    [CompilerGeneratedAttribute]
private InlinedReferenceContext <ReturnExpressionContextFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <SingleReturnedExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <BlockOfStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private IParametersOwner <Element>k__BackingField;
    [NotNullAttribute]
public Dictionary`2<int, IParameter> InlinedMethodParameterInfos;
    [CompilerGeneratedAttribute]
private IList`1<IReference> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalDeclarationIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IExpression> <ThisAccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IExpression> <SetterValueAccesses>k__BackingField;
    public InlinedElementKinds InlinedElementKind { get; private set; }
    public bool IsSingleLineReturn { get; private set; }
    public bool IsVoid { get; }
    public bool IsAsync { get; private set; }
    public IType ReturnType { get; private set; }
    public bool HasTopLevelUsingDeclarations { get; private set; }
    public bool AllReturnsAreLast { get; private set; }
    public InlinedReferenceContext ReturnExpressionContextFlags { get; private set; }
    [CanBeNullAttribute]
public ITreeNode SingleReturnedExpression { get; private set; }
    [CanBeNullAttribute]
public ITreeNode BlockOfStatements { get; private set; }
    [NotNullAttribute]
public IParametersOwner Element { get; private set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<IReference> References { get; private set; }
    [NotNullAttribute]
public LocalDeclarationIdentity Identity { get; private set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IExpression> ThisAccesses { get; private set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IExpression> SetterValueAccesses { get; private set; }
    [CompilerGeneratedAttribute]
public InlinedElementKinds get_InlinedElementKind();
    [CompilerGeneratedAttribute]
private void set_InlinedElementKind(InlinedElementKinds value);
    [CompilerGeneratedAttribute]
public bool get_IsSingleLineReturn();
    [CompilerGeneratedAttribute]
private void set_IsSingleLineReturn(bool value);
    public bool get_IsVoid();
    [CompilerGeneratedAttribute]
public bool get_IsAsync();
    [CompilerGeneratedAttribute]
private void set_IsAsync(bool value);
    [CompilerGeneratedAttribute]
public IType get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(IType value);
    [CompilerGeneratedAttribute]
public bool get_HasTopLevelUsingDeclarations();
    [CompilerGeneratedAttribute]
private void set_HasTopLevelUsingDeclarations(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllReturnsAreLast();
    [CompilerGeneratedAttribute]
private void set_AllReturnsAreLast(bool value);
    [CompilerGeneratedAttribute]
public InlinedReferenceContext get_ReturnExpressionContextFlags();
    [CompilerGeneratedAttribute]
private void set_ReturnExpressionContextFlags(InlinedReferenceContext value);
    [CompilerGeneratedAttribute]
public ITreeNode get_SingleReturnedExpression();
    [CompilerGeneratedAttribute]
private void set_SingleReturnedExpression(ITreeNode value);
    [CompilerGeneratedAttribute]
public ITreeNode get_BlockOfStatements();
    [CompilerGeneratedAttribute]
private void set_BlockOfStatements(ITreeNode value);
    [CompilerGeneratedAttribute]
public IParametersOwner get_Element();
    [CompilerGeneratedAttribute]
private void set_Element(IParametersOwner value);
    [CompilerGeneratedAttribute]
public IList`1<IReference> get_References();
    [CompilerGeneratedAttribute]
private void set_References(IList`1<IReference> value);
    [CompilerGeneratedAttribute]
public LocalDeclarationIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(LocalDeclarationIdentity value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IExpression> get_ThisAccesses();
    [CompilerGeneratedAttribute]
private void set_ThisAccesses(IReadOnlyList`1<IExpression> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IExpression> get_SetterValueAccesses();
    [CompilerGeneratedAttribute]
private void set_SetterValueAccesses(IReadOnlyList`1<IExpression> value);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IReadOnlyList`1<InlinedMethodInfo> CreateInfo(InlineMethodRefactoring refactoring, SubProgressIndicator pi);
    [NotNullAttribute]
private static InlinedMethodInfo CreateInfo(InlineMethodRefactoring refactoring, IParametersOwner declaredElement, InlinedElementKinds elementKind, SubProgressIndicator pi);
    [CompilerGeneratedAttribute]
internal static InlinedMethodInfo <CreateInfo>g__CreateAccessorInfo|60_0(IAccessor accessor, InlinedElementKinds elementKind, <>c__DisplayClass60_0& );
}
public class JetBrains.ReSharper.Refactorings.Inline.InlinedParameterCallSiteInfo : object {
    [CompilerGeneratedAttribute]
private InlinedParameterInfo <InlinedMethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, InlinedArgumentInfo> <Argument2Infos>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IParameter, InlinedArgumentInfo> <DefaultParameterArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IParameter, ArgumentFromParameter> <Parameter2Argument>k__BackingField;
    public InlinedParameterInfo InlinedMethodInfo { get; private set; }
    public Dictionary`2<int, InlinedArgumentInfo> Argument2Infos { get; private set; }
    public Dictionary`2<IParameter, InlinedArgumentInfo> DefaultParameterArguments { get; private set; }
    public Dictionary`2<IParameter, ArgumentFromParameter> Parameter2Argument { get; private set; }
    [CompilerGeneratedAttribute]
public InlinedParameterInfo get_InlinedMethodInfo();
    [CompilerGeneratedAttribute]
private void set_InlinedMethodInfo(InlinedParameterInfo value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, InlinedArgumentInfo> get_Argument2Infos();
    [CompilerGeneratedAttribute]
private void set_Argument2Infos(Dictionary`2<int, InlinedArgumentInfo> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IParameter, InlinedArgumentInfo> get_DefaultParameterArguments();
    [CompilerGeneratedAttribute]
private void set_DefaultParameterArguments(Dictionary`2<IParameter, InlinedArgumentInfo> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IParameter, ArgumentFromParameter> get_Parameter2Argument();
    [CompilerGeneratedAttribute]
private void set_Parameter2Argument(Dictionary`2<IParameter, ArgumentFromParameter> value);
    [NotNullAttribute]
public static InlinedParameterCallSiteInfo CreateInfoForInlineParameter(InlinedParameterInfo inlinedMethodInfo, InlineParameterRefactoring refactoring, IReference reference, IParametersOwner owner);
}
public class JetBrains.ReSharper.Refactorings.Inline.InlinedParameterInfo : object {
    [CompilerGeneratedAttribute]
private ITreeNode <BlockOfStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, IParameter> <InlinedMethodParameterInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalDeclarationIdentity <Identity>k__BackingField;
    public ITreeNode BlockOfStatements { get; private set; }
    public Dictionary`2<int, IParameter> InlinedMethodParameterInfos { get; public set; }
    public LocalDeclarationIdentity Identity { get; private set; }
    [CompilerGeneratedAttribute]
public ITreeNode get_BlockOfStatements();
    [CompilerGeneratedAttribute]
private void set_BlockOfStatements(ITreeNode value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, IParameter> get_InlinedMethodParameterInfos();
    [CompilerGeneratedAttribute]
public void set_InlinedMethodParameterInfos(Dictionary`2<int, IParameter> value);
    [CompilerGeneratedAttribute]
public LocalDeclarationIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(LocalDeclarationIdentity value);
    [NotNullAttribute]
public static InlinedParameterInfo CreateForInlineParameter(IParametersOwner parametersOwner, InlineParameterRefactoring refactoring);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Refactorings.Inline.InlinedReferenceContext : Enum {
    public int value__;
    public static InlinedReferenceContext Regular;
    public static InlinedReferenceContext Async;
    public static InlinedReferenceContext Iterator;
    public static InlinedReferenceContext Unsafe;
    public static InlinedReferenceContext Checked;
    public static InlinedReferenceContext Unchecked;
    public static InlinedReferenceContext TryFinally;
}
public enum JetBrains.ReSharper.Refactorings.Inline.InlinedReferenceKind : Enum {
    public int value__;
    public static InlinedReferenceKind Regular;
    public static InlinedReferenceKind Delegate;
    public static InlinedReferenceKind PropertyInitializer;
    public static InlinedReferenceKind CollectionInitializer;
    public static InlinedReferenceKind Deconstruction;
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Inline.InlineFieldProvider : InlineWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.InlineHelper : object {
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    public IRefactoringDriver Driver { get; }
    protected InlineHelper(IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public IRefactoringDriver get_Driver();
    public virtual bool CanReplaceUsageWithDeclaration(IParameter parameter, IDictionary`2<ArgumentFromParameter, InlinedArgumentInfo> argument2Info);
    public virtual bool CanIntroduceVariables(IExpression expression);
    public abstract virtual void ReplaceTypeParameter(IReference reference, ITypeParameter parameter, ISubstitution substitution);
    public abstract virtual Dictionary`2<IParameter, ArgumentFromParameter> GetParameter2Argument(IReference reference, IParametersOwner param);
    public abstract virtual Dictionary`2<ArgumentFromParameter, InlinedArgumentInfo> GetArgument2Infos(IReference reference, Dictionary`2<IParameter, ArgumentFromParameter> parameter2argument, Dictionary`2<int, IParameter> inlinedMethodParameterInfos);
    public abstract virtual bool CanHaveSideEffects(IArgument argument);
    public abstract virtual bool CanHaveSideEffects(IExpression expression);
    [CanBeNullAttribute]
public abstract virtual IExpression GetQualifierExpression(IReference reference);
    [CanBeNullAttribute]
public virtual IExpression GetConditionalAccessQualifier(IReference reference);
    public virtual bool CanIntroduceRefTempVariable(IParameter parameter, IExpression expression);
    public virtual bool ContainsRefAssignmentDestinations(IReadOnlyList`1<IExpression> expressions);
    [NotNullAttribute]
public abstract virtual IDeclaredElement SplitDeclarationAndInitializer(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement InsertReturnValueTempVariable(InlineMethodCallInfo inlineMethodCallInfo, IType returnType, IReference reference, CallSiteContext context);
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement InsertTempForQualifier(IExpression qualifierExpression, IReference reference, CallSiteContext context, ReferenceIdentitySaver saver, ReferenceKind referenceKind);
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement InsertTempVariableForAssignedValue(IExpression assignedExpression, IReference reference, CallSiteContext context, ReferenceIdentitySaver referenceIdentitySaver);
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement InsertTempForArgument(IParameter parameterInfo, InlinedArgumentInfo argumentInfo, IReference reference, CallSiteContext context, ReferenceIdentitySaver saver, ArgumentFromParameter argumentFromParameter);
    public abstract virtual void RemoveCastFromElement(ITreeNode element);
    [CanBeNullAttribute]
public abstract virtual IArgumentsOwner GetArgumentOwner(IReference& reference, bool replaceMethodGroup);
    public abstract virtual IEnumerable`1<IReference> AllNotQualifiableReferences(IReference reference);
    [NotNullAttribute]
public abstract virtual ITreeNode GetContainingStatement(ITreeNode element);
    [CanBeNullAttribute]
public virtual ITreeNode GetContainingFunctionLikeElement(ITreeNode treeNode);
    public virtual bool ShouldIntroduceVariableForExpression(IExpression expression, ITreeNode body, IDeclaredElement inlinedBodyOwner, IReadOnlyList`1<IExpression> references);
    public virtual bool IsUsingVariable(IReference reference, String& message);
}
public abstract class JetBrains.ReSharper.Refactorings.Inline.InlineMethod : RefactoringExecBase`2<InlineMethodWorkflow, InlineMethodRefactoring> {
    public InlineHelper InlineHelper { get; }
    protected InlineMethod(InlineMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual InlineHelper get_InlineHelper();
    public bool HasUsages(IParameter parameter);
    public bool HasWriteUsages(IParameter parameter);
    public abstract virtual bool IsReturnStatementOnly(IDeclaredElement element, IExpression& returnedExpression, ITreeNode& blockOfStatements);
    public abstract virtual bool CanIntroduceStatementsBefore(IReference reference);
    public abstract virtual bool IsFromExpressionBody(IReference reference);
    public abstract virtual bool ReplaceCall(IReference reference, ITreeNode returnedExpression, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    public abstract virtual bool ReplaceStatement(IReference& reference, ITreeNode statements, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context, bool replaceOriginal);
    public abstract virtual void ReplaceConditionalAccess(IReference& reference, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    public abstract virtual bool IsReturned(IReference reference, InlinedElementKinds inlinedElementKind);
    public abstract virtual bool IsLastStatement(IReference reference);
    public abstract virtual bool IsLastStatementInScope(IReference reference);
    [NotNullAttribute]
public abstract virtual AssignmentInfo FindContainingAssignment(InlinedElementKinds inlinedElementKind, IReference reference);
    public abstract virtual IReadOnlyList`1<IExpression> GetExpressionsReferencingThis(ITreeNode methodBody);
    public abstract virtual bool AllReturnsAreLast(IDeclaredElement element);
    public abstract virtual bool GetIsDestinationOfAssignment(IReference reference, IExpression& assignmentSource);
    public abstract virtual bool GetUsedAsDelegate(InlinedMethodInfo info, IReference reference);
    public virtual bool HasTopLevelUsingDeclarations(ITreeNode body);
    public virtual bool IsPartOfConditionalAccessChain(IReference reference);
    [NotNullAttribute]
[ItemNotNullAttribute]
public virtual IReadOnlyList`1<IExpression> CollectSetterValueParameterAccesses(ITreeNode methodBody);
    public virtual bool IsSetterParameter(IParameter parameter);
    public virtual bool Ignore(IReference reference);
    public virtual ITreeNode GetBody(IDeclaredElement element);
    public virtual ITreeNode GetContainingStatement(ITreeNode element);
    public virtual void ReplaceMethodGroup(IReference reference, CallSiteContext context, InlineMethodCallInfo inlinedCallInfo);
    [NotNullAttribute]
public virtual ITreeNode GetContextForNaming(IReference reference);
    public virtual bool GetIsPropertyInitializer(IReference reference);
    [NotNullAttribute]
public virtual IList`1<IReference> TransformReference(IReference reference);
    public virtual void ConvertExpressionToStatement(IReference& reference);
    public abstract virtual bool IsCollectionInitializer(IReference reference);
    public abstract virtual bool IsDeconstruction(IReference reference);
    public virtual bool CanInlineAsExpression(IReference reference, InlineMethodCallInfo callInfo);
    [NotNullAttribute]
public abstract virtual IType FindRealReturnType(IParametersOwner parametersOwner, ITreeNode context);
    public abstract virtual InlinedReferenceContext InspectReferenceContext(ITreeNode treeNode);
    public virtual bool FindIsAsync(IParametersOwner parametersOwner);
    public virtual bool EnsureContextRequirements(IReference reference, InlineMethodCallInfo inlinedCallInfo);
}
public class JetBrains.ReSharper.Refactorings.Inline.InlineMethodCallInfo : object {
    [CompilerGeneratedAttribute]
private InlinedReferenceContext <ReferenceContextFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanIntroduceStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReturned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastStatementInScope>k__BackingField;
    [CompilerGeneratedAttribute]
private InlinedMethodInfo <InlinedMethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConditionalQualifierCanHaveSideEffects>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Qualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private AssignmentInfo <ContainingAssignmentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPartOfConditionalAccessChain>k__BackingField;
    [CompilerGeneratedAttribute]
private InlinedReferenceKind <ReferenceKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ArgumentFromParameter, InlinedArgumentInfo> <Argument2Infos>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IParameter, ArgumentFromParameter> <Parameter2Argument>k__BackingField;
    public Dictionary`2<ITypeOwner, string> VarToLambdaParameterName;
    [CompilerGeneratedAttribute]
private IDeclaredElement <QualifierTempVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <ReturnValueTemp>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <AssignedExpressionTemp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateTempForQualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateTempForAssignedExpression>k__BackingField;
    public InlinedReferenceContext ReferenceContextFlags { get; private set; }
    public bool CanIntroduceStatements { get; private set; }
    public bool IsReturned { get; private set; }
    public bool IsLastStatement { get; private set; }
    public bool IsLastStatementInScope { get; private set; }
    public InlinedMethodInfo InlinedMethodInfo { get; private set; }
    public bool ConditionalQualifierCanHaveSideEffects { get; private set; }
    public IExpression Qualifier { get; public set; }
    public AssignmentInfo ContainingAssignmentInfo { get; private set; }
    public bool IsPartOfConditionalAccessChain { get; private set; }
    public InlinedReferenceKind ReferenceKind { get; private set; }
    public Dictionary`2<ArgumentFromParameter, InlinedArgumentInfo> Argument2Infos { get; private set; }
    public Dictionary`2<IParameter, ArgumentFromParameter> Parameter2Argument { get; private set; }
    public IDeclaredElement QualifierTempVariable { get; public set; }
    public IDeclaredElement ReturnValueTemp { get; public set; }
    public IDeclaredElement AssignedExpressionTemp { get; public set; }
    public bool ShouldCreateLocals { get; }
    public bool ShouldCreateTempForQualifier { get; private set; }
    public bool ShouldCreateTempForAssignedExpression { get; private set; }
    public bool ShouldCreateTempForReturnValue { get; }
    [CompilerGeneratedAttribute]
public InlinedReferenceContext get_ReferenceContextFlags();
    [CompilerGeneratedAttribute]
private void set_ReferenceContextFlags(InlinedReferenceContext value);
    [CompilerGeneratedAttribute]
public bool get_CanIntroduceStatements();
    [CompilerGeneratedAttribute]
private void set_CanIntroduceStatements(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReturned();
    [CompilerGeneratedAttribute]
private void set_IsReturned(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastStatement();
    [CompilerGeneratedAttribute]
private void set_IsLastStatement(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastStatementInScope();
    [CompilerGeneratedAttribute]
private void set_IsLastStatementInScope(bool value);
    [CompilerGeneratedAttribute]
public InlinedMethodInfo get_InlinedMethodInfo();
    [CompilerGeneratedAttribute]
private void set_InlinedMethodInfo(InlinedMethodInfo value);
    [CompilerGeneratedAttribute]
public bool get_ConditionalQualifierCanHaveSideEffects();
    [CompilerGeneratedAttribute]
private void set_ConditionalQualifierCanHaveSideEffects(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_Qualifier();
    [CompilerGeneratedAttribute]
public void set_Qualifier(IExpression value);
    [CompilerGeneratedAttribute]
public AssignmentInfo get_ContainingAssignmentInfo();
    [CompilerGeneratedAttribute]
private void set_ContainingAssignmentInfo(AssignmentInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsPartOfConditionalAccessChain();
    [CompilerGeneratedAttribute]
private void set_IsPartOfConditionalAccessChain(bool value);
    [CompilerGeneratedAttribute]
public InlinedReferenceKind get_ReferenceKind();
    [CompilerGeneratedAttribute]
private void set_ReferenceKind(InlinedReferenceKind value);
    [CompilerGeneratedAttribute]
public Dictionary`2<ArgumentFromParameter, InlinedArgumentInfo> get_Argument2Infos();
    [CompilerGeneratedAttribute]
private void set_Argument2Infos(Dictionary`2<ArgumentFromParameter, InlinedArgumentInfo> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IParameter, ArgumentFromParameter> get_Parameter2Argument();
    [CompilerGeneratedAttribute]
private void set_Parameter2Argument(Dictionary`2<IParameter, ArgumentFromParameter> value);
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredElement get_QualifierTempVariable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_QualifierTempVariable(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_ReturnValueTemp();
    [CompilerGeneratedAttribute]
public void set_ReturnValueTemp(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_AssignedExpressionTemp();
    [CompilerGeneratedAttribute]
public void set_AssignedExpressionTemp(IDeclaredElement value);
    public bool get_ShouldCreateLocals();
    [CompilerGeneratedAttribute]
public bool get_ShouldCreateTempForQualifier();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateTempForQualifier(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldCreateTempForAssignedExpression();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateTempForAssignedExpression(bool value);
    public bool get_ShouldCreateTempForReturnValue();
    [NotNullAttribute]
public static InlineMethodCallInfo CreateInfo(InlineMethodRefactoring refactoring, IReference reference, InlinedMethodInfo inlineMethodInfo);
    private static void InspectInlinedArguments(InlineMethod inlineMethod, InlineMethodCallInfo inlinedCallInfo);
    private static bool ShouldIntroduceTempVariableFromParameter(InlineMethod inlineMethod, InlinedMethodInfo inlineMethodInfo, IParameter parameter, IReadOnlyList`1<IExpression> argumentExpressions, bool canHaveSideEffects);
}
public class JetBrains.ReSharper.Refactorings.Inline.InlineMethodDataModel : object {
    private IDeclaredElementPointer`1<IDeclaredElement> myElementPointer;
    private IReferencePointer myReferencePointer;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private IInlineMethodDataProvider <InlineMethodDataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplaceAllUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveInitialDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvokedOnReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceUseDelegate>k__BackingField;
    public bool NonInteractive { get; }
    public IInlineMethodDataProvider InlineMethodDataProvider { get; public set; }
    public bool ReplaceAllUsages { get; public set; }
    public bool RemoveInitialDeclaration { get; public set; }
    [CanBeNullAttribute]
public IDeclaredElement Element { get; }
    [CanBeNullAttribute]
public IReference Reference { get; }
    public bool InvokedOnReference { get; }
    public bool ForceUseDelegate { get; public set; }
    public InlineMethodDataModel(IDeclaredElement element, IReference reference, IInlineMethodDataProvider dataProvider);
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_InlineMethodDataProvider(IInlineMethodDataProvider value);
    [CompilerGeneratedAttribute]
public IInlineMethodDataProvider get_InlineMethodDataProvider();
    [CompilerGeneratedAttribute]
public bool get_ReplaceAllUsages();
    [CompilerGeneratedAttribute]
public void set_ReplaceAllUsages(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveInitialDeclaration();
    [CompilerGeneratedAttribute]
public void set_RemoveInitialDeclaration(bool value);
    public IDeclaredElement get_Element();
    public IReference get_Reference();
    [CompilerGeneratedAttribute]
public bool get_InvokedOnReference();
    [CompilerGeneratedAttribute]
public bool get_ForceUseDelegate();
    [CompilerGeneratedAttribute]
public void set_ForceUseDelegate(bool value);
    public bool Validate();
}
public class JetBrains.ReSharper.Refactorings.Inline.InlineMethodDataProvider : object {
    [CompilerGeneratedAttribute]
private bool <Remove>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceUseDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplaceAllOccurrences>k__BackingField;
    public bool Remove { get; public set; }
    public bool ForceUseDelegate { get; public set; }
    public bool ReplaceAllOccurrences { get; }
    public InlineMethodDataProvider(bool replaceAllOccurrences, bool remove);
    public InlineMethodDataProvider(bool replaceAllOccurrences, bool remove, bool forceUseDelegate);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Remove();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Remove(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ForceUseDelegate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ForceUseDelegate(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReplaceAllOccurrences();
}
public class JetBrains.ReSharper.Refactorings.Inline.InlineMethodPage : SingleBeRefactoringPage {
    private InlineMethodDataModel myDataModel;
    [CompilerGeneratedAttribute]
private bool <RemoveAllReferences>k__BackingField;
    public static string ReplaceAll;
    public static string Remove;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public bool RemoveAllReferences { get; private set; }
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public string PageDescription { get; }
    public InlineMethodPage(Lifetime lifetime, InlineMethodDataModel dataModel);
    [CompilerGeneratedAttribute]
public bool get_RemoveAllReferences();
    [CompilerGeneratedAttribute]
private void set_RemoveAllReferences(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual string get_PageDescription();
    public virtual BeControl GetPageContent();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__18_0(bool v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__18_1(bool v);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Inline.InlineMethodProvider : InlineWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Inline.InlineMethodRefactoring : DrivenRefactoring`2<InlineMethodWorkflow, InlineMethod> {
    private IReadOnlyList`1<InlinedMethodInfo> myInlinedMethodInfos;
    private Dictionary`2<IReference, LocalContextResolveResultImage> myResolveImages;
    private bool myCanRemove;
    private ICollection`1<IDeclaredElement> myAllOverrides;
    private JetHashSet`1<ITreeNode> myCastContexts;
    public Dictionary`2<IReference, LocalContextResolveResultImage> ResolveImages { get; }
    public InlineMethodRefactoring(InlineMethodWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    public sealed virtual Dictionary`2<IReference, LocalContextResolveResultImage> get_ResolveImages();
    public sealed virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public virtual bool Execute(IProgressIndicator pi);
    private void RemoveOldDeclaration(IProgressIndicator pi);
    private void Remove(IDeclaredElement element);
    [NotNullAttribute]
[ItemNotNullAttribute]
private ICollection`1<IDeclaredElement> AnalyseOverrrides(IDeclaredElement element, IProgressIndicator pi);
    private void ConsumeInitialReference(IReference reference);
    private void ProcessReferences(IProgressIndicator pi);
    private void ProcessReference(InlinedMethodInfo info, IReference reference);
    [NotNullAttribute]
private ITreeNode GetContainingStatement(ITreeNode treeNode);
    private void TryBindContextReferences(Dictionary`2<IReference, LocalContextResolveResultImage> references);
    public Dictionary`2<IReference, LocalContextResolveResultImage> SaveContextReferences(ITreeNode element);
    private void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlinedMethodInfo inlinedMethodInfo);
    [CanBeNullAttribute]
private static Conflict GetInliningErrorConflict(IReference reference, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context, bool needStatementBody, bool replaceConditionalAccessWithStatement);
    private void InlineMethodReference(IReference reference, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context, bool needStatementBody, bool canInlineAsExpression, bool replaceConditionalAccessWithStatement);
    [NotNullAttribute]
public IList`1<IReference> GetAllReferences(IParametersOwner parametersOwner, InlinedElementKinds elementKind, SubProgressIndicator pi);
    private IList`1<IReference> TransformReferences(List`1<IReference> sortedReferences);
    protected virtual InlineMethod CreateUnsupportedRefactoring();
    protected virtual InlineMethod CreateRefactoringInternal(InternalRefactoringLanguageService service);
    public sealed virtual void AddContext(ITreeNode context);
    public Dictionary`2<int, IParameter> GetInlinedMethodParameterInfos(IDeclaredElement element);
    private sealed virtual override IRefactoringDriver JetBrains.ReSharper.Refactorings.Inline.ICallSiteContextOwner.get_Driver();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.Refactorings.RefactoringsMruSettings", "JetBrains.ReSharper.Refactorings.Resources.Strings", "InlineMethodRefactoringSettingsSettingDescription")]
public class JetBrains.ReSharper.Refactorings.Inline.InlineMethodSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "WhetherToRemoveTheMethodDeclarationAfterItsBeenInlinedIntoAllOfItsUsagesSettingDescription")]
public bool RemoveInitialDeclaration;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "WhetherToInlineAllUsagesOrJustTheCurrentUsageIfAvailableSettingDescription")]
public bool ReplaceAllUsages;
}
public class JetBrains.ReSharper.Refactorings.Inline.InlineMethodWorkflow : DrivenRefactoringWorkflow {
    private IInlineMethodDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineMethodDataModel <DataModel>k__BackingField;
    public PsiLanguageType LanguageType { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public InlineMethodDataModel DataModel { get; private set; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public InlineMethodWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public InlineMethodDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(InlineMethodDataModel value);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public void SetInlineMethodDataProvider(IInlineMethodDataProvider value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    private bool IsAvailable(IDataContext context, IDeclaredElement& element, IReference& reference);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Inline.InlineParameterProvider : InlineWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Inline.InlineTypeOwnerInitializerCallInfo : object {
    [CompilerGeneratedAttribute]
private InlineTypeOwnerInitializerInfo <InlinedMethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QualifierCanHaveSideEffects>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Qualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <QualifierTempVariable>k__BackingField;
    [NotNullAttribute]
public InlineTypeOwnerInitializerInfo InlinedMethodInfo { get; private set; }
    public bool QualifierCanHaveSideEffects { get; private set; }
    public IExpression Qualifier { get; private set; }
    public IDeclaredElement QualifierTempVariable { get; public set; }
    [CompilerGeneratedAttribute]
public InlineTypeOwnerInitializerInfo get_InlinedMethodInfo();
    [CompilerGeneratedAttribute]
private void set_InlinedMethodInfo(InlineTypeOwnerInitializerInfo value);
    [CompilerGeneratedAttribute]
public bool get_QualifierCanHaveSideEffects();
    [CompilerGeneratedAttribute]
private void set_QualifierCanHaveSideEffects(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_Qualifier();
    [CompilerGeneratedAttribute]
private void set_Qualifier(IExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredElement get_QualifierTempVariable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_QualifierTempVariable(IDeclaredElement value);
    [NotNullAttribute]
public static InlineTypeOwnerInitializerCallInfo CreateInfoForInlineField(IReference reference, InlineTypeOwnerInitializerInfo inlinedMethodInfo, InlineFieldRefactoring executer);
    [NotNullAttribute]
public static InlineTypeOwnerInitializerCallInfo CreateInfoForInlineVar(InlineTypeOwnerInitializerInfo info);
}
public class JetBrains.ReSharper.Refactorings.Inline.InlineTypeOwnerInitializerInfo : object {
    [CompilerGeneratedAttribute]
private LocalDeclarationIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasReferencesToThis>k__BackingField;
    [NotNullAttribute]
public LocalDeclarationIdentity Identity { get; private set; }
    [NotNullAttribute]
public ITreeNode Expression { get; private set; }
    public bool HasReferencesToThis { get; private set; }
    [CompilerGeneratedAttribute]
public LocalDeclarationIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(LocalDeclarationIdentity value);
    [CompilerGeneratedAttribute]
public ITreeNode get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(ITreeNode value);
    [CompilerGeneratedAttribute]
public bool get_HasReferencesToThis();
    [CompilerGeneratedAttribute]
private void set_HasReferencesToThis(bool value);
    [NotNullAttribute]
public static InlineTypeOwnerInitializerInfo CreateInfoForInlineField(IExpression expression, InlineFieldRefactoring executer);
    public static InlineTypeOwnerInitializerInfo CreateInfoForInlineVar(ITreeNode expression);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Inline.InlineVariableProvider : InlineWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Inline.IntroduceParameterInfo : object {
    [CompilerGeneratedAttribute]
private IExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, IParameter> <InlinedMethodParameterInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalDeclarationIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMultipleReferencesToQualifier>k__BackingField;
    public IExpression Expression { get; private set; }
    [NotNullAttribute]
public Dictionary`2<int, IParameter> InlinedMethodParameterInfos { get; private set; }
    [NotNullAttribute]
public LocalDeclarationIdentity Identity { get; private set; }
    public bool HasMultipleReferencesToQualifier { get; private set; }
    [CompilerGeneratedAttribute]
public IExpression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(IExpression value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, IParameter> get_InlinedMethodParameterInfos();
    [CompilerGeneratedAttribute]
private void set_InlinedMethodParameterInfos(Dictionary`2<int, IParameter> value);
    [CompilerGeneratedAttribute]
public LocalDeclarationIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(LocalDeclarationIdentity value);
    [CompilerGeneratedAttribute]
public bool get_HasMultipleReferencesToQualifier();
    [CompilerGeneratedAttribute]
private void set_HasMultipleReferencesToQualifier(bool value);
    [NotNullAttribute]
public static IntroduceParameterInfo CreateInfoForIntroduceParameter(IExpression expression, IParametersOwner parameterOwner, IntroduceParameterRefactoring executer);
    [NotNullAttribute]
public static IntroduceParameterInfo CreateInfoForMakeStatic(IExpression expression, IParametersOwner parameterOwner, IIntroduceParameterDriver executer, bool thisIsUsedOnce);
}
public class JetBrains.ReSharper.Refactorings.Inline.IntroduceParameterInlineCallInfo : object {
    [CompilerGeneratedAttribute]
private IntroduceParameterInfo <InlinedMethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QualifierCanHaveSideEffects>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Qualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <QualifierTempVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, InlinedArgumentInfo> <Argument2Infos>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IParameter, InlinedArgumentInfo> <DefaultParameterArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IParameter, ArgumentFromParameter> <Parameter2Argument>k__BackingField;
    public Dictionary`2<ITypeOwner, string> VarToLambdaParameterName;
    [NotNullAttribute]
public IntroduceParameterInfo InlinedMethodInfo { get; private set; }
    public bool QualifierCanHaveSideEffects { get; private set; }
    public IExpression Qualifier { get; private set; }
    public IDeclaredElement QualifierTempVariable { get; public set; }
    public Dictionary`2<int, InlinedArgumentInfo> Argument2Infos { get; private set; }
    public Dictionary`2<IParameter, InlinedArgumentInfo> DefaultParameterArguments { get; private set; }
    public Dictionary`2<IParameter, ArgumentFromParameter> Parameter2Argument { get; private set; }
    [CompilerGeneratedAttribute]
public IntroduceParameterInfo get_InlinedMethodInfo();
    [CompilerGeneratedAttribute]
private void set_InlinedMethodInfo(IntroduceParameterInfo value);
    [CompilerGeneratedAttribute]
public bool get_QualifierCanHaveSideEffects();
    [CompilerGeneratedAttribute]
private void set_QualifierCanHaveSideEffects(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_Qualifier();
    [CompilerGeneratedAttribute]
private void set_Qualifier(IExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredElement get_QualifierTempVariable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_QualifierTempVariable(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, InlinedArgumentInfo> get_Argument2Infos();
    [CompilerGeneratedAttribute]
private void set_Argument2Infos(Dictionary`2<int, InlinedArgumentInfo> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IParameter, InlinedArgumentInfo> get_DefaultParameterArguments();
    [CompilerGeneratedAttribute]
private void set_DefaultParameterArguments(Dictionary`2<IParameter, InlinedArgumentInfo> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IParameter, ArgumentFromParameter> get_Parameter2Argument();
    [CompilerGeneratedAttribute]
private void set_Parameter2Argument(Dictionary`2<IParameter, ArgumentFromParameter> value);
    public static IntroduceParameterInlineCallInfo CreateInfoForIntroduceParameter(IReference reference, IntroduceParameterInfo inlinedMethodInfo, IIntroduceParameterDriver executer, IParametersOwner parameterOwner);
}
public interface JetBrains.ReSharper.Refactorings.Inline.IQualifierOwnerCallInfo {
    [CanBeNullAttribute]
public IExpression Qualifier { get; }
    [CanBeNullAttribute]
public IDeclaredElement QualifierTempVariable { get; public set; }
    public abstract virtual IExpression get_Qualifier();
    public abstract virtual IDeclaredElement get_QualifierTempVariable();
    public abstract virtual void set_QualifierTempVariable(IDeclaredElement value);
}
public class JetBrains.ReSharper.Refactorings.Inline.Util.InlineRefactoringEngine : object {
    protected IInlineRefactoring myInlineRefactoring;
    protected Dictionary`2<IReference, LocalContextResolveResultImage> myResolveImages;
    protected JetHashSet`1<ITreeNode> myCastContexts;
    public Dictionary`2<IReference, LocalContextResolveResultImage> ResolveImages { get; }
    public IRefactoringDriver Driver { get; }
    public InlineRefactoringEngine(IInlineRefactoring inlineRefactoring);
    public InlineTypeOwnerInitializerInfo CreateInlinedMethodInfo(ITreeNode expression);
    public void InitReferences(ITreeNode element);
    public void InlineUsages(InlineTypeOwnerInitializerInfo inlinedMethodInfo, ICollection`1<IReference> references, IProgressIndicator pi);
    private void ConsumeInitialReference(IReference reference);
    public void ProcessReferences(ICollection`1<IReference> references, InlineTypeOwnerInitializerInfo inlinedMethodInfo, IProgressIndicator pi);
    private void InlineUsage(IReference reference, InlineTypeOwnerInitializerInfo inlinedMethodInfo);
    protected void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public sealed virtual void AddContext(ITreeNode context);
    public sealed virtual Dictionary`2<IReference, LocalContextResolveResultImage> get_ResolveImages();
    public sealed virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public sealed virtual IRefactoringDriver get_Driver();
    public static Dictionary`2<IReference, LocalContextResolveResultImage> InitialRemap(Dictionary`2<IReference, LocalContextResolveResultImage> images, ReferenceIdentitySaver saver);
}
public class JetBrains.ReSharper.Refactorings.Inline.Util.LocalDeclarationIdentity : object {
    public static Key`1<LocalDeclarationRename> RefKey;
    public static Key`1<LocalDeclarationRename> DeclKey;
    private ITreeNode myRootElement;
    private Dictionary`2<IDeclaredElement, LocalDeclarationRename> myLocalRenames;
    public bool ProcessingIsFinished { get; }
    private LocalDeclarationIdentity(ITreeNode rootElement);
    private static LocalDeclarationIdentity();
    public static LocalDeclarationIdentity CreateLocalDeclarationsIdentity(ITreeNode rootElement);
    private void ProcessDeclaration(IDeclaration declaration);
    private void ProcessReference(IReference reference);
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public ITreeNode Fix(ITreeNode element, Func`3<ITreeNode, string, ITreeNode> renameAction);
    public void PrepareNames(ITreeNode namingContext, bool initialElementWillBeRemoved);
}
public class JetBrains.ReSharper.Refactorings.Inline.Util.LocalDeclarationRename : object {
    private string myOriginalName;
    private bool myIsRenamed;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NameRoot <NameRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingRule <NamingRule>k__BackingField;
    public string Name { get; private set; }
    public NameRoot NameRoot { get; public set; }
    public NamingRule NamingRule { get; public set; }
    public LocalDeclarationRename(string name, NameRoot nameRoot, NamingRule namingRule);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public NameRoot get_NameRoot();
    [CompilerGeneratedAttribute]
public void set_NameRoot(NameRoot value);
    [CompilerGeneratedAttribute]
public NamingRule get_NamingRule();
    [CompilerGeneratedAttribute]
public void set_NamingRule(NamingRule value);
    public void Rename(string name);
    public void UndoChanges();
}
public static class JetBrains.ReSharper.Refactorings.Inline.Util.RedundantCastUtil : object {
    public static Key`1<ForcedCast> CastKey;
    public static Key`1<CheckTypeKey> CheckTypeKey;
    private static RedundantCastUtil();
    public static void PostProcessMarkedElements(IProgressIndicator pi, JetHashSet`1<ITreeNode> castContexts, ICallSiteContextOwner owner);
    private static void CheckCastConflicts(ITreeNode element, ICallSiteContextOwner owner);
}
public static class JetBrains.ReSharper.Refactorings.Inline.Util.TempVariableUtil : object {
    public static IReference InsertTempVariablesMulti(IReference reference, IntroduceParameterInlineCallInfo inlinedCallInfo, CallSiteContext context, ICallSiteContextOwner contextOwner);
    [NotNullAttribute]
public static IReference InsertTempVariablesForInlinedMethod(InlineMethod inlineMethod, IReference reference, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    public static IReference InsertTempVariablesForIntroduceParameter(IReference reference, IntroduceParameterInlineCallInfo inlinedCallInfo, CallSiteContext context, ICallSiteContextOwner contextOwner);
    public static IReference InsertTempVariablesForTypeOwnerInitializerInline(IReference reference, InlineTypeOwnerInitializerCallInfo inlinedCallInfo, CallSiteContext context, ICallSiteContextOwner contextOwner);
    public static IReference InsertTempVariablesForInlinedProperty(IReference reference, InlinedParameterCallSiteInfo inlinedCallInfo, CallSiteContext context, ICallSiteContextOwner contextOwner);
}
public interface JetBrains.ReSharper.Refactorings.InlineClass.IInlineClassRefactoringExec {
    public abstract virtual void CutAndPaste(IProgressIndicator subPi);
    public abstract virtual void Rebind(IProgressIndicator subPi);
}
public class JetBrains.ReSharper.Refactorings.InlineClass.InlineClassAnalyzer : object {
    [CompilerGeneratedAttribute]
private TypesInfo <TypesInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineClassWorkflow <Workflow>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MemberInfo> <Members>k__BackingField;
    public OneToSetMap`2<MemberInfo, IReference> SourceReferences;
    public List`1<IReference> TargetReferences;
    public PsiLanguageType Language;
    [CompilerGeneratedAttribute]
private List`1<IReference> <FieldReferences>k__BackingField;
    public TypesInfo TypesInfo { get; public set; }
    protected InlineClassWorkflow Workflow { get; protected set; }
    public List`1<MemberInfo> Members { get; public set; }
    public List`1<IReference> FieldReferences { get; public set; }
    public InlineClassAnalyzer(InlineClassWorkflow inlineClassWorkflow, ITypeOwner element, ITypeElement owner);
    [CompilerGeneratedAttribute]
public TypesInfo get_TypesInfo();
    [CompilerGeneratedAttribute]
public void set_TypesInfo(TypesInfo value);
    [CompilerGeneratedAttribute]
protected InlineClassWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
protected void set_Workflow(InlineClassWorkflow value);
    [CompilerGeneratedAttribute]
public List`1<MemberInfo> get_Members();
    [CompilerGeneratedAttribute]
public void set_Members(List`1<MemberInfo> value);
    protected virtual void InitializeMembers(ITypeOwner element, ITypeElement owner);
    protected virtual void AddMemberInfo(ITypeMember member);
    public void GetReferencesToRebind(IProgressIndicator pi);
    private void FillSourceMembersReferences(IProgressIndicator pi);
    private static void AddReferences(IProgressIndicator pi, IDeclaredElement element, List`1<IReference> references, ISearchDomain domain);
    [CompilerGeneratedAttribute]
public List`1<IReference> get_FieldReferences();
    [CompilerGeneratedAttribute]
public void set_FieldReferences(List`1<IReference> value);
    public virtual void Analyze();
    protected virtual void FillTargetTypeElements();
    public bool CheckNameUniqueness();
}
public class JetBrains.ReSharper.Refactorings.InlineClass.InlineClassHelper : object {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual InlineClassAnalyzer GetAnalyzer(InlineClassWorkflow inlineClassWorkflow, ITypeOwner element, ITypeElement owner);
    public sealed virtual bool IsFromExtendsList(ITreeNode element);
    public sealed virtual bool IsReferenceName(ITreeNode element);
    public sealed virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public sealed virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public sealed virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.InlineClass.InlineClassProvider : InlineWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.InlineClass.InlineClassRefactoring : object {
    private LanguageMapOfRefactoring`1<IInlineClassRefactoringExec> myExec;
    [CompilerGeneratedAttribute]
private ResolveImagesRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineClassWorkflow <Workflow>k__BackingField;
    public ResolveImagesRepository Repository { get; }
    protected IRefactoringDriver Driver { get; protected set; }
    protected InlineClassWorkflow Workflow { get; protected set; }
    public InlineClassRefactoring(InlineClassWorkflow inlineClassWorkflow, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public ResolveImagesRepository get_Repository();
    [CompilerGeneratedAttribute]
protected IRefactoringDriver get_Driver();
    [CompilerGeneratedAttribute]
protected void set_Driver(IRefactoringDriver value);
    [CompilerGeneratedAttribute]
protected InlineClassWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
protected void set_Workflow(InlineClassWorkflow value);
    public sealed virtual bool Execute(IProgressIndicator pi);
    private void RemoveFile();
    private void CutAndPaste(IProgressIndicator subPi);
    private void Rebind(IProgressIndicator subPi);
    private void CollectInfo(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.InlineClass.InlineClassWorkflow : DrivenRefactoringWorkflow2`1<InlineClassHelper> {
    private bool myInitialized;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ITypeParameter, ITypeParameter> <TypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiTransactions <PsiTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocument <DocumentToSave>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineClassAnalyzer <Analyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public IRefactoringDriver Driver { get; private set; }
    public Dictionary`2<ITypeParameter, ITypeParameter> TypeParameters { get; public set; }
    public IPsiTransactions PsiTransactions { get; }
    public IDocument DocumentToSave { get; public set; }
    public InlineClassAnalyzer Analyzer { get; public set; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public IPsiSourceFile SourceFile { get; public set; }
    public InlineClassWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public IRefactoringDriver get_Driver();
    [CompilerGeneratedAttribute]
private void set_Driver(IRefactoringDriver value);
    [CompilerGeneratedAttribute]
public Dictionary`2<ITypeParameter, ITypeParameter> get_TypeParameters();
    [CompilerGeneratedAttribute]
public void set_TypeParameters(Dictionary`2<ITypeParameter, ITypeParameter> value);
    [CompilerGeneratedAttribute]
public IPsiTransactions get_PsiTransactions();
    [CompilerGeneratedAttribute]
public IDocument get_DocumentToSave();
    [CompilerGeneratedAttribute]
public void set_DocumentToSave(IDocument value);
    [CompilerGeneratedAttribute]
public InlineClassAnalyzer get_Analyzer();
    [CompilerGeneratedAttribute]
public void set_Analyzer(InlineClassAnalyzer value);
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    protected virtual InlineClassHelper CreateUnsupportedHelper();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual bool IsAvailable(IDataContext context);
    protected bool IsAvailableEx(IDataContext context, ITypeOwner& typeOwner, ITypeElement& ownerType);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    protected virtual InlineClassHelper CreateHelper(IRefactoringLanguageService service);
    public void SetData();
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
public void set_SourceFile(IPsiSourceFile value);
    public void RemoveFile();
    public virtual bool PostExecute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.InlineClass.MemberInfo : object {
    protected IDeclaredElementPointer`1<IDeclaredElement> Pointer;
    protected IDeclaredElementPointer`1<IDeclaredElement> RemovePointer;
    [CompilerGeneratedAttribute]
private bool <Remove>k__BackingField;
    public IDeclaredElement MemberToRemove { get; public set; }
    public bool Remove { get; public set; }
    public IDeclaredElement DeclaredElement { get; public set; }
    public bool HasDelegation { get; }
    public MemberInfo(ITypeMember member);
    public IDeclaredElement get_MemberToRemove();
    public void set_MemberToRemove(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public bool get_Remove();
    [CompilerGeneratedAttribute]
public void set_Remove(bool value);
    public IDeclaredElement get_DeclaredElement();
    public void set_DeclaredElement(IDeclaredElement value);
    public bool get_HasDelegation();
}
public class JetBrains.ReSharper.Refactorings.InlineClass.TypesInfo : object {
    [CompilerGeneratedAttribute]
private ITypeOwner <TargetTypeMember>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty <TargetProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeOwner <SourceTypeMember>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty <SourceProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TargetTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <SourceTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ITypeParameter, ITypeParameter> <SourceToTargetTypes>k__BackingField;
    private ISubstitution mySubstitution;
    private ISubstitution myBackSubstitution;
    public ITypeOwner TargetTypeMember { get; public set; }
    public IProperty TargetProperty { get; public set; }
    public ITypeOwner SourceTypeMember { get; public set; }
    public IProperty SourceProperty { get; public set; }
    public ITypeElement TargetTypeElement { get; public set; }
    public ITypeElement SourceTypeElement { get; public set; }
    public Dictionary`2<ITypeParameter, ITypeParameter> SourceToTargetTypes { get; public set; }
    public ISubstitution Substitution { get; public set; }
    public ISubstitution BackSubstitution { get; public set; }
    public TypesInfo(ITypeOwner element, ITypeElement owner);
    [CompilerGeneratedAttribute]
public ITypeOwner get_TargetTypeMember();
    [CompilerGeneratedAttribute]
public void set_TargetTypeMember(ITypeOwner value);
    [CompilerGeneratedAttribute]
public IProperty get_TargetProperty();
    [CompilerGeneratedAttribute]
public void set_TargetProperty(IProperty value);
    [CompilerGeneratedAttribute]
public ITypeOwner get_SourceTypeMember();
    [CompilerGeneratedAttribute]
public void set_SourceTypeMember(ITypeOwner value);
    [CompilerGeneratedAttribute]
public IProperty get_SourceProperty();
    [CompilerGeneratedAttribute]
public void set_SourceProperty(IProperty value);
    [CompilerGeneratedAttribute]
public ITypeElement get_TargetTypeElement();
    [CompilerGeneratedAttribute]
public void set_TargetTypeElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public ITypeElement get_SourceTypeElement();
    [CompilerGeneratedAttribute]
public void set_SourceTypeElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public Dictionary`2<ITypeParameter, ITypeParameter> get_SourceToTargetTypes();
    [CompilerGeneratedAttribute]
public void set_SourceToTargetTypes(Dictionary`2<ITypeParameter, ITypeParameter> value);
    public ISubstitution get_Substitution();
    public void set_Substitution(ISubstitution value);
    public ISubstitution get_BackSubstitution();
    public void set_BackSubstitution(ISubstitution value);
    public ITypeDeclaration GetTargetTypeDeclaration();
    public ITypeDeclaration GetSourceTypeDeclaration();
    private static ITypeDeclaration GetDeclaration(ITypeElement sourceType);
    private IProperty GetTypeOwnerProperty();
    public void GetSubstitution(ITypeOwner member, ITypeElement typeElement, ISubstitution& substitution);
    protected static JetHashSet`1<ITypeParameter> CollectParameters(JetHashSet`1<ITypeParameter> typeParameters, ITypeElement typeElement);
    protected static List`1<ITypeParameter> GetUsedTypeParameters(ITypeElement typeElement);
    private void FillTypeParameters();
}
public abstract class JetBrains.ReSharper.Refactorings.InlineField.InlineFieldBase : RefactoringExecBase`2<InlineFieldWorkflow, InlineFieldRefactoring> {
    public InlineHelper InlineHelper { get; }
    protected InlineFieldBase(InlineFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual InlineHelper get_InlineHelper();
    [CanBeNullAttribute]
public abstract virtual IExpression GetInitializerExpression(IReference reference);
    public abstract virtual bool ThisIsUsed(IExpression expression);
    public virtual bool Ignore(IReference reference);
    public abstract virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public abstract virtual void RemoveAssignment(IReference reference);
    public abstract virtual void RemoveField(IDeclaration declaration);
    [CanBeNullAttribute]
public abstract virtual IExpression GetInitializerExpression(IField field);
    public abstract virtual bool GetCanUseRefOut(IExpression expression);
    public abstract virtual bool CanInlineReference(IReference reference);
    protected bool ReportWriteUsageConflict(IReference reference, ExpressionAccessType accessType);
    protected bool ReportArgumentConflict(IReference reference);
    public virtual bool HasSideEffects(IExpression expression);
    [CanBeNullAttribute]
public virtual string InsertTempVariable(ITreeNode tag, string name, IExpression expression);
    public virtual void ReplaceExpression(IReference reference, string localName);
    protected static IList`1<IReference> GetReachableReferences(IEnumerable`1<IReference> references, IControlFlowGraph graph, ControlFlowGraphInspector`1<InlineFieldInspectionContext> inspector);
}
public class JetBrains.ReSharper.Refactorings.InlineField.InlineFieldInspectionContext : object {
    private State myState;
    public bool InlineThis { get; }
    public InlineFieldInspectionContext Clone();
    public bool get_InlineThis();
    public void MergeWith(InlineFieldInspectionContext context);
    public sealed virtual void Write();
    public sealed virtual void Read();
    public void TrueAssigned();
    public bool Equals(InlineFieldInspectionContext obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Refactorings.InlineField.InlineFieldRefactoring : DrivenRefactoring`2<InlineFieldWorkflow, InlineFieldBase> {
    private InlineRefactoringEngine myEngine;
    [CompilerGeneratedAttribute]
private bool <CanUseForRefOut>k__BackingField;
    [CompilerGeneratedAttribute]
private IField <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private IReference <Reference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanHaveSideEffects>k__BackingField;
    public bool CanUseForRefOut { get; private set; }
    public IField Field { get; private set; }
    [NotNullAttribute]
public IExpression Expression { get; private set; }
    public IReference Reference { get; private set; }
    public bool CanHaveSideEffects { get; public set; }
    public PsiLanguageType InvocationLanguage { get; }
    public InlineFieldRefactoring(InlineFieldWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public bool get_CanUseForRefOut();
    [CompilerGeneratedAttribute]
private void set_CanUseForRefOut(bool value);
    [CompilerGeneratedAttribute]
public IField get_Field();
    [CompilerGeneratedAttribute]
private void set_Field(IField value);
    [CompilerGeneratedAttribute]
public IExpression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(IExpression value);
    [CompilerGeneratedAttribute]
public IReference get_Reference();
    [CompilerGeneratedAttribute]
private void set_Reference(IReference value);
    [CompilerGeneratedAttribute]
public bool get_CanHaveSideEffects();
    [CompilerGeneratedAttribute]
public void set_CanHaveSideEffects(bool value);
    public virtual bool Execute(IProgressIndicator pi);
    [NotNullAttribute]
private IList`1<Pair`2<IFunctionDeclaration, IList`1<IReference>>> GroupReferences(IEnumerable`1<IReference> references);
    private bool GetCanUseRefOut(IExpression expression);
    private bool GetCanHasSideEffects(IExpression expression);
    private void RemoveField();
    [CanBeNullAttribute]
private IList`1<IReference> GetReferences(IProgressIndicator pi);
    [CanBeNullAttribute]
private IExpression GetExpression(IList`1<IReference> references);
    protected virtual InlineFieldBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    public sealed virtual InlineTypeOwnerInitializerInfo CreateInlinedMethodInfo();
    public sealed virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public sealed virtual InlineTypeOwnerInitializerCallInfo CreateInlineCallInfo(InlineTypeOwnerInitializerInfo info, IReference reference);
    public sealed virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public sealed virtual void ReportLanguageConflict(PsiLanguageType language, PsiLanguageType invocationLanguage, IReference reference);
    protected virtual InlineFieldBase CreateUnsupportedRefactoring();
    public sealed virtual PsiLanguageType get_InvocationLanguage();
    private sealed virtual override IRefactoringDriver JetBrains.ReSharper.Refactorings.InlineVar.IInlineRefactoring.get_Driver();
    [CompilerGeneratedAttribute]
private bool <GetExpression>b__28_1(IReference x);
}
public class JetBrains.ReSharper.Refactorings.InlineField.InlineFieldWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private IReferencePointer <ReferencePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<IField> <FieldPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    public IReferencePointer ReferencePointer { get; private set; }
    public IDeclaredElementPointer`1<IField> FieldPointer { get; private set; }
    public PsiLanguageType LanguageType { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public InlineFieldWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public IReferencePointer get_ReferencePointer();
    [CompilerGeneratedAttribute]
private void set_ReferencePointer(IReferencePointer value);
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<IField> get_FieldPointer();
    [CompilerGeneratedAttribute]
private void set_FieldPointer(IDeclaredElementPointer`1<IField> value);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    public virtual RefactoringActionGroup get_ActionGroup();
    private bool IsAvailableEx(IDataContext context, IReference& reference, IField& field);
    public virtual bool IsAvailable(IDataContext context);
    public virtual HelpId get_HelpKeyword();
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.ArgumentExpressionSubstitution : ExpressionSubstitution {
    private DefaultValue myDefaultValue;
    private IInlinedExpressionNode myInlinedExpressionNode;
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<IExpression> <ExpressionPointer>k__BackingField;
    public bool IsIncluded { get; }
    public IInlinedExpressionNode InlinedExpressionNode { get; }
    [NotNullAttribute]
public ITreeNodePointer`1<IExpression> ExpressionPointer { get; }
    public ArgumentExpressionSubstitution(IExpression expression, IInlinedExpressionNode inlinedExpressionNode);
    public ArgumentExpressionSubstitution(DefaultValue defaultValue, InlineParameterDefaultValueNode inlinedExpressionNode);
    public virtual bool get_IsIncluded();
    public IInlinedExpressionNode get_InlinedExpressionNode();
    [CompilerGeneratedAttribute]
public virtual ITreeNodePointer`1<IExpression> get_ExpressionPointer();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.ArgumentsOwnerInfo : TreeNodeNode {
    private ITreeNodePointer`1<IArgumentsOwner> myArgumentsOwner;
    [CompilerGeneratedAttribute]
private IList`1<InlineArgumentNode> <ArgumentInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<SuggestedParameterNode, IExpression> <SuggestionToExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStillMatched>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArgumentOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private IArgumentsOwner <ArgumentsOwnerCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private OverrideDataModel <Override>k__BackingField;
    public IList`1<InlineArgumentNode> ArgumentInfos { get; }
    public IArgumentsOwner ArgumentsOwner { get; }
    public Dictionary`2<SuggestedParameterNode, IExpression> SuggestionToExpression { get; }
    public bool IsStillMatched { get; public set; }
    public bool IsArgumentOwner { get; }
    public IArgumentsOwner ArgumentsOwnerCopy { get; private set; }
    [CanBeNullAttribute]
public OverrideDataModel Override { get; public set; }
    public ArgumentsOwnerInfo(IArgumentsOwner argumentsOwner, bool isArgsOwner);
    [CompilerGeneratedAttribute]
public IList`1<InlineArgumentNode> get_ArgumentInfos();
    public IArgumentsOwner get_ArgumentsOwner();
    [CompilerGeneratedAttribute]
public Dictionary`2<SuggestedParameterNode, IExpression> get_SuggestionToExpression();
    [CompilerGeneratedAttribute]
public bool get_IsStillMatched();
    [CompilerGeneratedAttribute]
public void set_IsStillMatched(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsArgumentOwner();
    [CompilerGeneratedAttribute]
public IArgumentsOwner get_ArgumentsOwnerCopy();
    [CompilerGeneratedAttribute]
private void set_ArgumentsOwnerCopy(IArgumentsOwner value);
    [CompilerGeneratedAttribute]
public OverrideDataModel get_Override();
    [CompilerGeneratedAttribute]
public void set_Override(OverrideDataModel value);
    [CanBeNullAttribute]
public ParameterOwnerUsageUpdater GetUpdater(InlineParameterNode parameterNode, Func`2<ITreeNode, InlineParameterHelper> getHelper);
    public IArgument GetArgumentOfParameter(int index);
    private static IParameter GetParameterFromArgument(IArgument argument);
    public void Mismatch();
    public void Reset();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.DefaultValueUsage : DeclaredElementNode {
    [CompilerGeneratedAttribute]
private IList`1<InlineParameterDefaultValueNode> <DefaultValues>k__BackingField;
    public IList`1<InlineParameterDefaultValueNode> DefaultValues { get; public set; }
    public DefaultValueUsage(IParametersOwner element, IList`1<InlineParameterNode> parameterInfos);
    [CompilerGeneratedAttribute]
public IList`1<InlineParameterDefaultValueNode> get_DefaultValues();
    [CompilerGeneratedAttribute]
public void set_DefaultValues(IList`1<InlineParameterDefaultValueNode> value);
}
public abstract class JetBrains.ReSharper.Refactorings.InlineParameter.Data.ExpressionSubstitution : object {
    public bool IsIncluded { get; }
    [CanBeNullAttribute]
public ITreeNodePointer`1<IExpression> ExpressionPointer { get; }
    public abstract virtual bool get_IsIncluded();
    public abstract virtual ITreeNodePointer`1<IExpression> get_ExpressionPointer();
}
public interface JetBrains.ReSharper.Refactorings.InlineParameter.Data.IInlinedExpressionNode {
    public InlineParameterNode ParameterNode { get; }
    public ArgumentExpressionSubstitution ExpressionSubstitution { get; public set; }
    public List`1<SuggestedParameterNode> Suggestions { get; public set; }
    public ProjectFileType LanguageType { get; }
    public abstract virtual InlineParameterNode get_ParameterNode();
    public abstract virtual ArgumentExpressionSubstitution get_ExpressionSubstitution();
    public abstract virtual void set_ExpressionSubstitution(ArgumentExpressionSubstitution value);
    public abstract virtual List`1<SuggestedParameterNode> get_Suggestions();
    public abstract virtual void set_Suggestions(List`1<SuggestedParameterNode> value);
    public abstract virtual ProjectFileType get_LanguageType();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.InlineArgumentNode : TreeNodeNode {
    [CompilerGeneratedAttribute]
private ProjectFileType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineParameterNode <ParameterNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgumentExpressionSubstitution <ExpressionSubstitution>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SuggestedParameterNode> <Suggestions>k__BackingField;
    public ProjectFileType LanguageType { get; }
    public InlineParameterNode ParameterNode { get; }
    public ArgumentExpressionSubstitution ExpressionSubstitution { get; public set; }
    public List`1<SuggestedParameterNode> Suggestions { get; public set; }
    public InlineArgumentNode(IArgument argument, InlineParameterNode node);
    [CompilerGeneratedAttribute]
public sealed virtual ProjectFileType get_LanguageType();
    [CompilerGeneratedAttribute]
public sealed virtual InlineParameterNode get_ParameterNode();
    [CompilerGeneratedAttribute]
public sealed virtual ArgumentExpressionSubstitution get_ExpressionSubstitution();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpressionSubstitution(ArgumentExpressionSubstitution value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<SuggestedParameterNode> get_Suggestions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Suggestions(List`1<SuggestedParameterNode> value);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.InlineParameterDefaultValueNode : DeclaredElementNode {
    [CompilerGeneratedAttribute]
private ProjectFileType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineParameterNode <ParameterNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgumentExpressionSubstitution <ExpressionSubstitution>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SuggestedParameterNode> <Suggestions>k__BackingField;
    public ProjectFileType LanguageType { get; }
    public InlineParameterNode ParameterNode { get; }
    public ArgumentExpressionSubstitution ExpressionSubstitution { get; public set; }
    public List`1<SuggestedParameterNode> Suggestions { get; public set; }
    public InlineParameterDefaultValueNode(IParameter parameter, InlineParameterNode inlineParameterNode);
    [CompilerGeneratedAttribute]
public sealed virtual ProjectFileType get_LanguageType();
    [CompilerGeneratedAttribute]
public sealed virtual InlineParameterNode get_ParameterNode();
    [CompilerGeneratedAttribute]
public sealed virtual ArgumentExpressionSubstitution get_ExpressionSubstitution();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpressionSubstitution(ArgumentExpressionSubstitution value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<SuggestedParameterNode> get_Suggestions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Suggestions(List`1<SuggestedParameterNode> value);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.InlineParameterNode : ParameterElement {
    private List`1<IDeclaredElementPointer`1<IParameter>> myParameters;
    [CompilerGeneratedAttribute]
private bool <HasUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<InlineParameterDefaultValueNode> <DefaultValueInfos>k__BackingField;
    public bool HasUsages { get; }
    public IList`1<InlineParameterDefaultValueNode> DefaultValueInfos { get; }
    public IEnumerable`1<IParameter> Parameters { get; }
    public InlineParameterNode(ICollection`1<IParameter> parameters);
    [CompilerGeneratedAttribute]
public bool get_HasUsages();
    [CompilerGeneratedAttribute]
public IList`1<InlineParameterDefaultValueNode> get_DefaultValueInfos();
    public IEnumerable`1<IParameter> get_Parameters();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.InlineParameterViewModel : object {
    private IDeclaredElementPointer`1<IParametersOwner> myParametersOwnerPointer;
    private IFinder myAsyncFinder;
    [CompilerGeneratedAttribute]
private bool <HasError>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ArgumentsOwnerInfo> <Usages>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineArgumentNode <ThisArgumentNode>k__BackingField;
    [CompilerGeneratedAttribute]
private SuggestedParameterNode <ThisSuggestion>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<InlineParameterNode> <ParameterInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<OverrideDataModel> <OverrideModels>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgumentsOwnerInfo <SelectedUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    public IList`1<SuggestedParameterNode> Suggestions { get; }
    public bool HasError { get; }
    public IEnumerable`1<ArgumentsOwnerInfo> Usages { get; }
    [CanBeNullAttribute]
public InlineArgumentNode ThisArgumentNode { get; private set; }
    [CanBeNullAttribute]
public SuggestedParameterNode ThisSuggestion { get; private set; }
    public IList`1<InlineParameterNode> ParameterInfos { get; public set; }
    public IParametersOwner ParametersOwner { get; private set; }
    public IList`1<OverrideDataModel> OverrideModels { get; public set; }
    [CanBeNullAttribute]
public ArgumentsOwnerInfo SelectedUsage { get; public set; }
    public Lifetime Lifetime { get; }
    public InlineParameterViewModel(IParametersOwner typeMember, IExpression expression, IArgumentsOwner argumentsOwner, IParameter parameter, InlineParameterWorkflow inlineParameterWorkflow);
    public IList`1<SuggestedParameterNode> get_Suggestions();
    [CompilerGeneratedAttribute]
public bool get_HasError();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ArgumentsOwnerInfo> get_Usages();
    [CompilerGeneratedAttribute]
public InlineArgumentNode get_ThisArgumentNode();
    [CompilerGeneratedAttribute]
private void set_ThisArgumentNode(InlineArgumentNode value);
    [CompilerGeneratedAttribute]
public SuggestedParameterNode get_ThisSuggestion();
    [CompilerGeneratedAttribute]
private void set_ThisSuggestion(SuggestedParameterNode value);
    [CompilerGeneratedAttribute]
public IList`1<InlineParameterNode> get_ParameterInfos();
    [CompilerGeneratedAttribute]
public void set_ParameterInfos(IList`1<InlineParameterNode> value);
    public IParametersOwner get_ParametersOwner();
    private void set_ParametersOwner(IParametersOwner value);
    [CompilerGeneratedAttribute]
public IList`1<OverrideDataModel> get_OverrideModels();
    [CompilerGeneratedAttribute]
public void set_OverrideModels(IList`1<OverrideDataModel> value);
    [CompilerGeneratedAttribute]
public ArgumentsOwnerInfo get_SelectedUsage();
    [CompilerGeneratedAttribute]
public void set_SelectedUsage(ArgumentsOwnerInfo value);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    private bool InitOverrides(IParametersOwner typeMember, IProgressIndicator pi);
    private List`1<ArgumentsOwnerInfo> InitUsages(IParametersOwner initial);
    public bool InitSuggestions(InlineParameterWorkflow workflow, IArgumentsOwner thisContext);
    public void LoadUsages(IEnumerable`1<ArgumentsOwnerInfo> usages, InlineParameterWorkflow workflow);
    public IList`1<SuggestedParameterNode> UpdateSuggestions(ArgumentsOwnerInfo selectedCall);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.OverrideDataModel : object {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IParametersOwner> myParameterOwnerPointer;
    [CompilerGeneratedAttribute]
private List`1<ExpressionSubstitution> <ExpressionsForSubstitution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    public IParametersOwner ParametersOwner { get; }
    public List`1<ExpressionSubstitution> ExpressionsForSubstitution { get; }
    public bool IsDefault { get; public set; }
    public OverrideDataModel(IParametersOwner parameterOwnerPointer, bool isDefault);
    public IParametersOwner get_ParametersOwner();
    [CompilerGeneratedAttribute]
public List`1<ExpressionSubstitution> get_ExpressionsForSubstitution();
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public void set_IsDefault(bool value);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.ParameterOwnerUsageUpdater : object {
    private IExpression myValue;
    private IExpression myQualifier;
    private bool myHasThisQualifier;
    private Stack`1<ITreeNode> myStack;
    [CompilerGeneratedAttribute]
private ArgumentsOwnerInfo <ArgumentsOwnerInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IArgumentsOwner <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private IArgumentsOwner <Copy>k__BackingField;
    [CompilerGeneratedAttribute]
private IArgument <FoundArgument>k__BackingField;
    public ArgumentsOwnerInfo ArgumentsOwnerInfo { get; }
    public IArgumentsOwner Owner { get; }
    public IArgumentsOwner Copy { get; }
    public IArgument FoundArgument { get; }
    public ParameterOwnerUsageUpdater(IArgumentsOwner owner, IArgumentsOwner copy, IArgument foundArgument, ArgumentsOwnerInfo argumentsOwnerInfo, IExpression value, IExpression qualifier, bool hasThisQualifier);
    [CompilerGeneratedAttribute]
public ArgumentsOwnerInfo get_ArgumentsOwnerInfo();
    [CompilerGeneratedAttribute]
public IArgumentsOwner get_Owner();
    [CompilerGeneratedAttribute]
public IArgumentsOwner get_Copy();
    [CompilerGeneratedAttribute]
public IArgument get_FoundArgument();
    public void MatchExistingParameter(InlineParameterNode parameterNode);
    public void MatchSuggestion(SuggestedParameterNode suggestion);
    public void MatchQualifierSuggestion(QualifierExpressionSubstitution qualifierSubstitution);
    public void MatchThisSuggestion(SuggestedParameterNode suggestedParameterNode, Func`3<IExpression, Action`1<IExpression>, bool> matchQualifier);
    public void Match(ITreeNode element);
    private void MatchQualifierExpression(IExpression qualifierExpression, SuggestedParameterNode suggestion);
    public void MoveToChild();
    private static ITreeNode Meaning(ITreeNode child);
    public void MoveToNext();
    public void GoParent();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.QualifierExpressionSubstitution : ExpressionSubstitution {
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<IExpression> <ExpressionPointer>k__BackingField;
    public bool IsIncluded { get; }
    public ITreeNodePointer`1<IExpression> ExpressionPointer { get; }
    public QualifierExpressionSubstitution(IExpression qualifier);
    public virtual bool get_IsIncluded();
    [CompilerGeneratedAttribute]
public virtual ITreeNodePointer`1<IExpression> get_ExpressionPointer();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Data.SuggestedParameterNode : TreeNodeNode {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreatedParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TreeNodeText>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ExpressionSubstitution> <ExpressionsForSubstitution>k__BackingField;
    public string TypeName { get; }
    public string CreatedParameterName { get; public set; }
    public string TreeNodeText { get; }
    public List`1<ExpressionSubstitution> ExpressionsForSubstitution { get; }
    public SuggestedParameterNode(ITreeNode treeNode);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_CreatedParameterName();
    [CompilerGeneratedAttribute]
public void set_CreatedParameterName(string value);
    [CompilerGeneratedAttribute]
public string get_TreeNodeText();
    [CompilerGeneratedAttribute]
public List`1<ExpressionSubstitution> get_ExpressionsForSubstitution();
    private static string GetName(ITreeNode treeNode);
    private string GetTypeName();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Impl.InlineParameterEngine : InlineRefactoringEngine {
    public InlineParameterEngine(IInlineRefactoring inlineRefactoring);
    public InlinedParameterInfo CreateInlinedMethodInfo(ITreeNode body, IParametersOwner owner, InlineParameterRefactoring refactoring);
    public void TransformBody(InlinedParameterInfo inlinedMethodInfo, SubProgressIndicator pi, ITreeNode context, InlineParameterRefactoring refactoring, IReference reference, IParametersOwner owner, ITreeNode body);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Impl.InlineParameterHierarchyConflictTextProvider : HierarchyConflictTextProviderBase {
    public virtual string WillAlsoOverride();
    public virtual string WillAlsoImplement();
    public virtual string QuasiImplements();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Impl.SubExpressionSearcher : object {
    public Key`1<string> Key;
    private IExpression myQualifier;
    private bool myHasThisQualifier;
    private ITreeNode myContext;
    private IExpression myExpression;
    private IExpression myCopyExpression;
    private InlineParameterWorkflow myInlineParameterWorkflow;
    [CompilerGeneratedAttribute]
private List`1<IExpression> <UnresolvedExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnresolvedThis>k__BackingField;
    public List`1<IExpression> UnresolvedExpressions { get; private set; }
    public bool HasUnresolvedThis { get; private set; }
    public SubExpressionSearcher(ITreeNode context, IExpression expression, bool hasThisQualifier, InlineParameterWorkflow inlineParameterWorkflow);
    [CompilerGeneratedAttribute]
public List`1<IExpression> get_UnresolvedExpressions();
    [CompilerGeneratedAttribute]
private void set_UnresolvedExpressions(List`1<IExpression> value);
    [CompilerGeneratedAttribute]
public bool get_HasUnresolvedThis();
    [CompilerGeneratedAttribute]
private void set_HasUnresolvedThis(bool value);
    public void Process();
    private List`1<IExpression> ScanOriginalExpression(ITreeNode element, ReferenceIdentitySaver saver);
    private ITreeNode ReplaceThisReferences(ITreeNode element, IDeclaredType type, ReferenceIdentitySaver saver);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.Impl.SubExpressionsReplacer : object {
    private InlineParameterWorkflow myWorkflow;
    private InlineParameterRefactoring myRefactoring;
    private IEnumerable`1<SuggestedParameterNode> mySelectedSuggestions;
    public SubExpressionsReplacer(InlineParameterWorkflow workflow, InlineParameterRefactoring refactoring);
    public T ReplaceSubexpressions(T element, OverrideDataModel overrideModel, IList`1<ParameterOwnerUsageUpdater> updaters);
    private static IInlinedExpressionNode MatchesExistingParameter(ITreeNode expression, OverrideDataModel overrideModel);
    private SuggestedParameterNode MatchesParameterSuggestion(IExpression expression);
    private static QualifierExpressionSubstitution MatchesQualifierSuggestion(ITreeNode expression, OverrideDataModel overrideModel);
}
public abstract class JetBrains.ReSharper.Refactorings.InlineParameter.InlineParameterBase : RefactoringExecBase`2<InlineParameterWorkflow, InlineParameterRefactoring> {
    public InlineHelper InlineHelper { get; }
    protected InlineParameterBase(InlineParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual InlineHelper get_InlineHelper();
    public virtual void ReplaceBody(CallSiteContext context, InlinedParameterCallSiteInfo info, IParametersOwner owner, ITreeNode body, InlineParameterEngine engine);
    [CanBeNullAttribute]
public virtual IParametersOwnerDeclaration CreateNewDeclaration(IParametersOwner owner);
    [CanBeNullAttribute]
public virtual IParameter AddParameter(IDeclaration newParametersOwnerDeclaration, IParameter parameter);
    [CanBeNullAttribute]
public virtual IArgumentsOwner CreateArgumentsOwner(IParametersOwner parametersOwner);
    public virtual void AddArgumentFromParameter(IArgumentsOwner argumentsOwner, IParameter parameter, ParameterKind kind);
    [CanBeNullAttribute]
public virtual IExpression ReplaceExpression(T expression, string name);
    public virtual void AddArgumentFromExpression(IArgumentsOwner owner, IExpression expression);
    public virtual IParametersOwnerDeclaration AddDeclarationToFile(IParametersOwnerDeclaration newParametersOwnerDeclaration, IParametersOwner parametersOwner);
    [CanBeNullAttribute]
public virtual IArgument CreateArgument(ITreeNode expression);
    public virtual void ReplaceArguments(IArgumentsOwner owner, List`1<IArgument> arguments);
    public virtual void AddArgument(IArgumentsOwner owner, IArgument copy);
    public virtual void ReplaceDeclarations(IParametersOwner parametersOwner);
    public virtual IExpression ReplaceWithThis(IExpression expression);
    public bool IsUsedOnce(IParameter parameter);
    public bool HasWriteUsages(IParameter parameter);
    public virtual void RemoveArguments(IArgumentsOwner argumentsOwner, List`1<IArgument> arguments);
    [CanBeNullAttribute]
protected virtual IArgumentsOwner CreateCallToMethod(IMethod method);
    [CanBeNullAttribute]
protected virtual IArgumentsOwner CreateCallToConstructor(IConstructor constructor);
}
public abstract class JetBrains.ReSharper.Refactorings.InlineParameter.InlineParameterDataProviderBase : object {
    public abstract virtual void CheckParameters(InlineParameterViewModel model);
}
public abstract class JetBrains.ReSharper.Refactorings.InlineParameter.InlineParameterHelper : object {
    public bool IsLanguageSupported { get; }
    public abstract virtual bool get_IsLanguageSupported();
    [CanBeNullAttribute]
public virtual IParametersOwner GetCalledMember(IArgumentsOwner owner);
    public virtual bool IsAnonymousMethod(IParametersOwner parametersOwner);
    [CanBeNullAttribute]
public virtual IExpression GetQualifier(IArgumentsOwner owner, Boolean& hasThisQualifier);
    [CanBeNullAttribute]
public virtual ITreeNode GetContextOfParameterOwner(IParametersOwner owner);
    [CanBeNullAttribute]
public virtual IExpression GetArgumentValue(IArgument argument);
    [CanBeNullAttribute]
public virtual IReference GetReference(IArgumentsOwner argumentsOwner);
    [NotNullAttribute]
public virtual ITreeNode ReplaceThisReferences(ITreeNode element, IDeclaredType type, ReferenceIdentitySaver saver, Key`1<string> key, Boolean& hasUnresolvedThis, bool hasThisQualifier);
    [CanBeNullAttribute]
public virtual IExpression CreateThisExpression(IPsiModule project);
    [CanBeNullAttribute]
public virtual IExpression GetInvocation(ITreeNode element);
    [NotNullAttribute]
public virtual ITreeNode Qualify(ITreeNode element, string name, IEnumerable`1<ParameterOwnerUsageUpdater> updaters, SuggestedParameterNode thisSuggestion);
    public virtual bool IsThisExpression(IArgument argument);
    [CanBeNullAttribute]
public virtual IArgumentsOwner CopyArgumentsOwner(IArgumentsOwner owner);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.InlineParameterRefactoring : DrivenRefactoring`2<InlineParameterWorkflow, InlineParameterBase> {
    private InlineParameterEngine myEngine;
    private InlineParameterViewModel myModel;
    private IList`1<ArgumentsOwnerInfo> myUsages;
    [CompilerGeneratedAttribute]
private IDeclaration <NewParametersOwnerDecl>k__BackingField;
    public IDeclaration NewParametersOwnerDecl { get; private set; }
    public PsiLanguageType InvocationLanguage { get; }
    public InlineParameterRefactoring(InlineParameterWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public IDeclaration get_NewParametersOwnerDecl();
    [CompilerGeneratedAttribute]
private void set_NewParametersOwnerDecl(IDeclaration value);
    public virtual bool Execute(IProgressIndicator pi);
    private void CheckForNameConflicts();
    private bool UpdateInvocation();
    private IArgumentsOwner ConstructFakeInvocation(IParametersOwner parametersOwner, OverrideDataModel overrideModel, IEnumerable`1<InlineParameterNode> parameterInfos);
    [CanBeNullAttribute]
private IDeclaration ConstructNewDeclaration(IParametersOwner parametersOwner, IEnumerable`1<InlineParameterNode> parameterInfos);
    protected virtual InlineParameterBase CreateUnsupportedRefactoring();
    protected virtual InlineParameterBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    public sealed virtual InlineTypeOwnerInitializerInfo CreateInlinedMethodInfo();
    public sealed virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public sealed virtual InlineTypeOwnerInitializerCallInfo CreateInlineCallInfo(InlineTypeOwnerInitializerInfo info, IReference reference);
    public sealed virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public sealed virtual PsiLanguageType get_InvocationLanguage();
    public sealed virtual void ReportLanguageConflict(PsiLanguageType language, PsiLanguageType invocationLanguage, IReference reference);
    public Dictionary`2<int, IParameter> GetInlinedMethodParameterInfos(IParametersOwner parametersOwner);
    private sealed virtual override IRefactoringDriver JetBrains.ReSharper.Refactorings.InlineVar.IInlineRefactoring.get_Driver();
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.InlineParameterWorkflow : DrivenRefactoringWorkflow2`1<InlineParameterHelper> {
    private InlineParameterDataProviderBase myDataProvider;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineParameterViewModel <Model>k__BackingField;
    public PsiLanguageType LanguageType { get; private set; }
    public InlineParameterViewModel Model { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public InlineParameterWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    [CompilerGeneratedAttribute]
public InlineParameterViewModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(InlineParameterViewModel value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    public void SetDataProvider(InlineParameterDataProviderBase dataProvider);
    private bool IsAvailableInternal(IDataContext context, IParameter& parameter, IParametersOwner& parametersOwner, IExpression& expression, IArgumentsOwner& argumentsOwner);
    private static bool CheckParametersOwner(IDeclaredElement parametersOwner);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    [NotNullAttribute]
protected virtual InlineParameterHelper CreateUnsupportedHelper();
    protected virtual InlineParameterHelper CreateHelper(IRefactoringLanguageService service);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.InlineParameter.UI.InlineParameterPage : SingleBeRefactoringPage {
    private ISolution mySolution;
    private InlineParameterViewModel myModel;
    public static string SuggestionsGrid;
    public static string ParametersGrid;
    public static string UsagesGrid;
    private Property`1<string> myPreviewProperty;
    private Property`1<string> myErrorSuggestions;
    public string Title { get; }
    public InlineParameterPage(ISolution solution, InlineParameterViewModel model);
    private static InlineParameterPage();
    public virtual string get_Title();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    public virtual BeControl GetPageContent();
    private static string GetDefaultValueText(InlineParameterNode e);
    private void UpdatePreviewAndValidation(IShellLocks locks, IModuleReferenceResolveContext moduleReferenceResolveContext);
}
public interface JetBrains.ReSharper.Refactorings.InlineVar.IInlineRefactoring {
    public IRefactoringDriver Driver { get; }
    public PsiLanguageType InvocationLanguage { get; }
    public abstract virtual InlineTypeOwnerInitializerInfo CreateInlinedMethodInfo();
    public abstract virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public abstract virtual InlineTypeOwnerInitializerCallInfo CreateInlineCallInfo(InlineTypeOwnerInitializerInfo info, IReference reference);
    public abstract virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public abstract virtual IRefactoringDriver get_Driver();
    public abstract virtual PsiLanguageType get_InvocationLanguage();
    public abstract virtual void ReportLanguageConflict(PsiLanguageType language, PsiLanguageType invocationLanguage, IReference reference);
}
public abstract class JetBrains.ReSharper.Refactorings.InlineVar.InlineVarBase : RefactoringExecBase`2<InlineVarWorkflow, InlineVarRefactoring> {
    public InlineHelper InlineHelper { get; }
    protected InlineVarBase(InlineVarWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public abstract virtual InlineHelper get_InlineHelper();
    public virtual bool Ignore(IReference reference);
    public abstract virtual void RemoveVariableDeclaration(IDeclaration declaration);
    public abstract virtual void RemoveAssignment(ITreeNode expression);
}
public class JetBrains.ReSharper.Refactorings.InlineVar.InlineVarRefactoring : DrivenRefactoring`2<InlineVarWorkflow, InlineVarBase> {
    private InlineRefactoringEngine myEngine;
    private ITreeNode myExpression;
    private List`1<IReference> myReferences;
    private IDeclaredElement myVariable;
    private ITreeNode myAssignmentExpression;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public IType Type { get; public set; }
    public PsiLanguageType InvocationLanguage { get; }
    public InlineVarRefactoring(InlineVarWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    public sealed virtual InlineTypeOwnerInitializerInfo CreateInlinedMethodInfo();
    protected virtual InlineVarBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IType value);
    public sealed virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public sealed virtual InlineTypeOwnerInitializerCallInfo CreateInlineCallInfo(InlineTypeOwnerInitializerInfo info, IReference reference);
    public sealed virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public sealed virtual PsiLanguageType get_InvocationLanguage();
    public sealed virtual void ReportLanguageConflict(PsiLanguageType language, PsiLanguageType invocationLanguage, IReference reference);
    protected virtual InlineVarBase CreateUnsupportedRefactoring();
    private sealed virtual override IRefactoringDriver JetBrains.ReSharper.Refactorings.InlineVar.IInlineRefactoring.get_Driver();
}
public class JetBrains.ReSharper.Refactorings.InlineVar.InlineVarWorkflow : DrivenRefactoringWorkflow {
    private ITreeNodePointer`1<ITreeNode> myExpressionPointer;
    private ITreeNodePointer`1<ITreeNode> myAssignmentExpressionPointer;
    private List`1<IReferencePointer> myReferencePointers;
    private IDeclaredElementPointer`1<IDeclaredElement> myVariablePointer;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InlineAll>k__BackingField;
    public PsiLanguageType LanguageType { get; private set; }
    public ITreeNodePointer`1<ITreeNode> ExpressionPointer { get; }
    public List`1<IReferencePointer> ReferencePointers { get; }
    public ITreeNodePointer`1<ITreeNode> AssignmentExpressionPointer { get; }
    public bool InlineAll { get; private set; }
    public IDeclaredElementPointer`1<IDeclaredElement> VariablePointer { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public InlineVarWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    public ITreeNodePointer`1<ITreeNode> get_ExpressionPointer();
    public List`1<IReferencePointer> get_ReferencePointers();
    public ITreeNodePointer`1<ITreeNode> get_AssignmentExpressionPointer();
    [CompilerGeneratedAttribute]
public bool get_InlineAll();
    [CompilerGeneratedAttribute]
private void set_InlineAll(bool value);
    public IDeclaredElementPointer`1<IDeclaredElement> get_VariablePointer();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    public virtual bool Initialize(IDataContext context);
    private Pair`2<bool, string> Analyse(IList`1<IReference> references, IDataContext context, IDeclaredElement variable);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    private bool IsAvailableLocal(IDataContext context, IDeclaredElement& declaredElement);
}
public abstract class JetBrains.ReSharper.Refactorings.InlineVar.RDAnalysis.InlineVarAnalyserBase : object {
    [CompilerGeneratedAttribute]
private InlineVarWorkflow <Workflow>k__BackingField;
    public InlineVarWorkflow Workflow { get; }
    public bool InlineAll { get; public set; }
    public List`1<IReference> References { get; }
    public ITreeNode Expression { get; }
    public ITreeNode AssignmentExpression { get; }
    protected InlineVarAnalyserBase(InlineVarWorkflow workflow);
    [CompilerGeneratedAttribute]
public InlineVarWorkflow get_Workflow();
    public abstract virtual bool get_InlineAll();
    public abstract virtual void set_InlineAll(bool value);
    public abstract virtual List`1<IReference> get_References();
    public abstract virtual ITreeNode get_Expression();
    public abstract virtual ITreeNode get_AssignmentExpression();
    public abstract virtual Pair`2<bool, string> Run(IDeclaredElement variable, ITreeNode element, IList`1<IReference> references);
}
public class JetBrains.ReSharper.Refactorings.InlineVar.RDAnalysis.InlineVarContext : object {
    private InlineVarContextStates myState;
    public InlineVarContextStates State { get; }
    public InlineVarContextStates get_State();
    public InlineVarContext Clone();
    public void MergeWith(InlineVarContext context);
    public sealed virtual void Write();
    public sealed virtual void Read();
    public void TrueAssigned();
    public bool Equals(InlineVarContext obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum JetBrains.ReSharper.Refactorings.InlineVar.RDAnalysis.InlineVarContextStates : Enum {
    public int value__;
    public static InlineVarContextStates NotAssigned;
    public static InlineVarContextStates InlinedValueAssigned;
    public static InlineVarContextStates OtherValueAssigned;
}
public interface JetBrains.ReSharper.Refactorings.InlineVar.RDAnalysis.IRDInspectorOfVariableContext {
    public abstract virtual void Write();
    public abstract virtual void Read();
}
public class JetBrains.ReSharper.Refactorings.IntroduceField.ClrIntroduceFieldPage : IntroduceFieldPage {
    private IntroduceFieldWorkflow myWorkflow;
    public bool CanBeReadOnly;
    [CompilerGeneratedAttribute]
private IProperty`1<AccessRights> <AccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <Readonly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoConst>k__BackingField;
    public IProperty`1<AccessRights> AccessRights { get; public set; }
    public IProperty`1<bool> Readonly { get; }
    public bool NoConst { get; }
    public ClrIntroduceFieldPage(Lifetime lifetime, IntroduceFieldWorkflow workflow);
    [CompilerGeneratedAttribute]
public IProperty`1<AccessRights> get_AccessRights();
    [CompilerGeneratedAttribute]
public void set_AccessRights(IProperty`1<AccessRights> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_Readonly();
    [CompilerGeneratedAttribute]
public virtual bool get_NoConst();
    public virtual void Commit();
    protected virtual BeControl GetSpecific();
    protected virtual void ProcessInitializationValue(InitializationPlace place, RadioButtonProperties radioButtonProperties);
    protected virtual NamedElementKinds GetKind();
    public virtual IEnumerable`1<string> SuggestNames(string prefix);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0(PropertyChangedEventArgs`1<AccessRights> v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_1(PropertyChangedEventArgs`1<bool> v);
}
public class JetBrains.ReSharper.Refactorings.IntroduceField.ClrIntroduceFieldViewModel : IntroduceFieldViewModel {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ILocalVariable <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeDeclaration <TypeDeclaration>k__BackingField;
    public IType Type { get; }
    public IParameter Parameter { get; }
    public ILocalVariable Variable { get; }
    public ITypeDeclaration TypeDeclaration { get; }
    private ClrIntroduceFieldViewModel(IType type, ITypeDeclaration typeDeclaration);
    public ClrIntroduceFieldViewModel(IParameter parameter, IType type, ITypeDeclaration typeDeclaration);
    public ClrIntroduceFieldViewModel(ILocalVariable variable, IType type, ITypeDeclaration typeDeclaration);
    public ClrIntroduceFieldViewModel(IExpression expression, ITypeDeclaration typeDeclaration, IntroduceFieldOptions options, IEnumerable`1<ITreeNode> selectedExpressions);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public IParameter get_Parameter();
    [CompilerGeneratedAttribute]
public ILocalVariable get_Variable();
    [CompilerGeneratedAttribute]
public ITypeDeclaration get_TypeDeclaration();
    private void InitNaming(IDeclaredElement element);
}
public interface JetBrains.ReSharper.Refactorings.IntroduceField.IIntroduceFieldWorkflowProvider {
}
public enum JetBrains.ReSharper.Refactorings.IntroduceField.InitializationPlace : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Current _member")]
public static InitializationPlace Current;
    [LocalizedDescriptionAttribute("_Field initializer")]
public static InitializationPlace Field;
    [LocalizedDescriptionAttribute("_Constructor(s)")]
public static InitializationPlace Constructors;
    [LocalizedDescriptionAttribute("_Introduce constant")]
public static InitializationPlace Constant;
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "IntroduceFieldActionText")]
public class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldAction : ExtensibleRefactoringAction`1<IIntroduceFieldWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldAnalyser : object {
    public bool CanInitCurrentMember(ILocalVariable variable);
    [CanBeNullAttribute]
public virtual ITreeNode GetInitializer(ILocalVariable variable);
    public virtual bool CanBeConstant(ILocalVariable variable);
    public virtual bool IsFromConstructor(ILocalVariable variable, bool isStatic);
    public virtual bool IsFromConstructor(ITreeNode element, bool isStatic);
    [CanBeNullAttribute]
public virtual ITreeNode GetBody(IDeclaration declaration);
    public virtual bool CanInitializeInlineFromPrimaryConstructor(IParameter parameter);
    public virtual bool HasInstanceConstructorsThatCantHaveBodies(ITypeElement typeElement);
}
public abstract class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldBase : RefactoringExecBase`2<IntroduceFieldWorkflow, IntroduceFieldRefactoring> {
    protected IntroduceFieldBase(IntroduceFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IExpression GetInitializer(ILocalVariable variable);
    [CanBeNullAttribute]
public virtual IExpression CreateInitializer(ITypeOwner typeOwner, ITreeNode context);
    [CanBeNullAttribute]
public abstract virtual ITypeMember AddField(ITypeDeclaration typeDeclaration, IExpression initExpression, IList`1<ITreeNode> tags, object type);
    public abstract virtual bool ReplaceVariableDeclaration(ILocalVariable variable, ITypeMember field, IExpression initializer);
    public abstract virtual bool ReplaceUsages(IList`1<ITreeNode> expressions, ITypeMember field, ITreeNode initializer);
    public abstract virtual void AddAssignment(IParameter variable, ITypeMember member, IExpression expression);
}
public class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldOptions : object {
    [CompilerGeneratedAttribute]
private bool <CanInitCurrentMember>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanInitFieldDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanInitConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBeStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBeStaticInClassContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeConstant>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBeConstant>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBeConstantInClassContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustBeConstantInMemberContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeReadonly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanInitReadonlyInCurrentMember>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanInitStaticReadonlyInCurrentMember>k__BackingField;
    public bool CanInitCurrentMember { get; public set; }
    public bool CanInitFieldDeclaration { get; public set; }
    public bool CanInitConstructor { get; public set; }
    public bool CanBeStatic { get; public set; }
    public bool MustBeStatic { get; public set; }
    public bool MustBeStaticInClassContext { get; public set; }
    public bool CanBeConstant { get; public set; }
    public bool MustBeConstant { get; public set; }
    public bool MustBeConstantInClassContext { get; public set; }
    public bool MustBeConstantInMemberContext { get; public set; }
    public bool CanBeReadonly { get; public set; }
    public bool CanInitReadonlyInCurrentMember { get; public set; }
    public bool CanInitStaticReadonlyInCurrentMember { get; public set; }
    public bool CanIntroduce { get; }
    [CompilerGeneratedAttribute]
public bool get_CanInitCurrentMember();
    [CompilerGeneratedAttribute]
public void set_CanInitCurrentMember(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanInitFieldDeclaration();
    [CompilerGeneratedAttribute]
public void set_CanInitFieldDeclaration(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanInitConstructor();
    [CompilerGeneratedAttribute]
public void set_CanInitConstructor(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanBeStatic();
    [CompilerGeneratedAttribute]
public void set_CanBeStatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBeStatic();
    [CompilerGeneratedAttribute]
public void set_MustBeStatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBeStaticInClassContext();
    [CompilerGeneratedAttribute]
public void set_MustBeStaticInClassContext(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanBeConstant();
    [CompilerGeneratedAttribute]
public void set_CanBeConstant(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBeConstant();
    [CompilerGeneratedAttribute]
public void set_MustBeConstant(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBeConstantInClassContext();
    [CompilerGeneratedAttribute]
public void set_MustBeConstantInClassContext(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustBeConstantInMemberContext();
    [CompilerGeneratedAttribute]
public void set_MustBeConstantInMemberContext(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanBeReadonly();
    [CompilerGeneratedAttribute]
public void set_CanBeReadonly(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanInitReadonlyInCurrentMember();
    [CompilerGeneratedAttribute]
public void set_CanInitReadonlyInCurrentMember(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanInitStaticReadonlyInCurrentMember();
    [CompilerGeneratedAttribute]
public void set_CanInitStaticReadonlyInCurrentMember(bool value);
    public bool get_CanIntroduce();
}
public abstract class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldPage : SingleBeRefactoringPage {
    private BeGrid myContent;
    [CompilerGeneratedAttribute]
private IProperty`1<InitializationPlace> <Initialization>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <Static>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeStatic>k__BackingField;
    protected bool NameWasChangedByUser;
    protected IntroduceFieldViewModel myViewModel;
    protected bool myInitializationInProgress;
    protected string myInitiaName;
    public string Description { get; }
    public string Title { get; }
    public IProperty`1<InitializationPlace> Initialization { get; public set; }
    public IProperty`1<string> Name { get; public set; }
    public IProperty`1<bool> Static { get; }
    public bool NoConst { get; }
    public bool CanBeStatic { get; protected set; }
    protected IntroduceFieldPage(Lifetime lifetime, IntroduceFieldViewModel viewModel);
    public virtual string get_Description();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public IProperty`1<InitializationPlace> get_Initialization();
    [CompilerGeneratedAttribute]
public void set_Initialization(IProperty`1<InitializationPlace> value);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(IProperty`1<string> value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_Static();
    public virtual bool get_NoConst();
    [CompilerGeneratedAttribute]
public bool get_CanBeStatic();
    [CompilerGeneratedAttribute]
protected void set_CanBeStatic(bool value);
    protected virtual NamedElementKinds GetKind();
    public virtual IEnumerable`1<string> SuggestNames(string prefix);
    public virtual string GetDerivedName(string name);
    public virtual BeControl GetPageContent();
    protected void RecalculateName();
    protected virtual BeControl GetSpecific();
    protected virtual void ProcessInitializationValue(InitializationPlace place, RadioButtonProperties radioButtonProperties);
    protected virtual bool GetDefaultValue(InitializationPlace place);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__30_0(PropertyChangedEventArgs`1<InitializationPlace> v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__30_1(PropertyChangedEventArgs`1<bool> v);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__30_2(InitializationPlace place);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__30_3(PropertyChangedEventArgs`1<string> v);
    [CompilerGeneratedAttribute]
private void <RecalculateName>b__31_0();
}
public class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldRefactoring : DrivenRefactoring`2<IntroduceFieldWorkflow, IntroduceFieldBase> {
    public IntroduceFieldRefactoring(IntroduceFieldWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    private ITypeMember CreateFieldDeclaration(ITypeDeclaration typeDeclaration, IExpression initExpression, IDeclaredElement variable, IList`1<ITreeNode> expressions);
    [CanBeNullAttribute]
private IExpression GetInitExpression(ILocalVariable variable, IParameter parameter, ITreeNode expression, ITreeNode context);
    protected virtual IntroduceFieldBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    protected virtual IntroduceFieldBase CreateUnsupportedRefactoring();
    [CompilerGeneratedAttribute]
private bool <Execute>b__1_0(ITypeMemberDeclaration md);
}
public class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldViewModel : object {
    protected ITreeNodePointer`1<ITreeNode> myExpressionPointer;
    protected IList`1<ITreeNode> myUsages;
    [CompilerGeneratedAttribute]
private InitializationPlace <Initialization>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NameRoot> <Roots>k__BackingField;
    [CompilerGeneratedAttribute]
private IntroduceFieldOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Static>k__BackingField;
    public ITreeNode Expression { get; }
    public IList`1<ITreeNode> Usages { get; }
    public InitializationPlace Initialization { get; public set; }
    public string Name { get; public set; }
    public IList`1<NameRoot> Roots { get; protected set; }
    public IntroduceFieldOptions Options { get; protected set; }
    public IPsiSourceFile SourceFile { get; protected set; }
    public bool Static { get; public set; }
    public virtual ITreeNode get_Expression();
    public virtual IList`1<ITreeNode> get_Usages();
    [CompilerGeneratedAttribute]
public InitializationPlace get_Initialization();
    [CompilerGeneratedAttribute]
public void set_Initialization(InitializationPlace value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<NameRoot> get_Roots();
    [CompilerGeneratedAttribute]
protected void set_Roots(IList`1<NameRoot> value);
    [CompilerGeneratedAttribute]
public IntroduceFieldOptions get_Options();
    [CompilerGeneratedAttribute]
protected void set_Options(IntroduceFieldOptions value);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
protected void set_SourceFile(IPsiSourceFile value);
    [CompilerGeneratedAttribute]
public bool get_Static();
    [CompilerGeneratedAttribute]
public void set_Static(bool value);
}
public class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IntroduceFieldViewModel <ViewModel>k__BackingField;
    [CompilerGeneratedAttribute]
private IntroFieldData <DataProvider>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public PsiLanguageType LanguageType { get; protected set; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public IntroduceFieldViewModel ViewModel { get; protected set; }
    public IntroFieldData DataProvider { get; public set; }
    public IntroduceFieldWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
protected void set_LanguageType(PsiLanguageType value);
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public IntroduceFieldViewModel get_ViewModel();
    [CompilerGeneratedAttribute]
protected void set_ViewModel(IntroduceFieldViewModel value);
    [CompilerGeneratedAttribute]
public IntroFieldData get_DataProvider();
    [CompilerGeneratedAttribute]
public void set_DataProvider(IntroFieldData value);
    public virtual bool Initialize(IDataContext context);
    private void FillModel();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    private bool IsAvailableLocal(IDataContext context, ILocalVariable& variable, IParameter& parameter, ITypeDeclaration& typeDeclaration, IEnumerable`1& expressions);
    public virtual bool IsAvailable(IDataContext context);
    private bool AnalyseContext(ILocalVariable variable, IParameter parameter, IExpression expression, ITypeDeclaration& typeDeclaration);
    public void SetDataProvider(IntroFieldData introFieldData);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.IntroduceField.IntroduceFieldWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.IntroduceField.IntroFieldHelper : object {
    private IntroduceFieldAnalyser myAnalyser;
    [CanBeNullAttribute]
public static IntroduceFieldOptions CreateFromParameter(IParameter parameter);
    [CanBeNullAttribute]
public static IntroduceFieldOptions CreateFromLocalVariable(ILocalVariable variable, ITypeDeclaration typeDeclaration);
    private static bool GetCanInitLocal(IEnumerable`1<ITreeNode> expressions);
    public static IntroduceFieldOptions CreateFromExpression(IExpression expression, IEnumerable`1<ITreeNode> classContextOccurrences, IEnumerable`1<ITreeNode> memberContextOccurrences, bool canHaveConstructor, IEnumerable`1<ITreeNode> selected);
    private static bool HasWriteUsages(IDeclaredElement variable);
    [CanBeNullAttribute]
private static DependencyResult GetUsesLocalContext(ILocalVariable variable, IntroduceFieldAnalyser options);
}
public interface JetBrains.ReSharper.Refactorings.IntroduceParameter.IIntroduceParameterDataProvider {
    public bool ReplaceAllOccurrences { get; public set; }
    public string NewName { get; public set; }
    public abstract virtual bool get_ReplaceAllOccurrences();
    public abstract virtual void set_ReplaceAllOccurrences(bool value);
    public abstract virtual string get_NewName();
    public abstract virtual void set_NewName(string value);
    public abstract virtual void ProvideLambdas(IEnumerable`1<DeclaredElementNode> memberInfos);
}
public interface JetBrains.ReSharper.Refactorings.IntroduceParameter.IIntroduceParameterDriver {
    public JetHashSet`1<IParameter> UsedParameters { get; public set; }
    public abstract virtual Dictionary`2<int, IParameter> GetInlinedMethodParameterInfos(IParametersOwner owner);
    public abstract virtual JetHashSet`1<IParameter> get_UsedParameters();
    public abstract virtual void set_UsedParameters(JetHashSet`1<IParameter> value);
    public abstract virtual InlineHelper GetInlineHelper(PsiLanguageType language);
}
public interface JetBrains.ReSharper.Refactorings.IntroduceParameter.IIntroduceParameterWorkflowProvider {
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "IntroduceParameterActionText")]
[VsOverrideActionAttribute("({1496A755-94DE-11D0-8C3F-00C04FC2AAE2}:1554)")]
public class JetBrains.ReSharper.Refactorings.IntroduceParameter.IntroduceParameterAction : ExtensibleRefactoringAction`1<IIntroduceParameterWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
    public sealed virtual bool ShouldFallBack(IDataContext context);
}
public abstract class JetBrains.ReSharper.Refactorings.IntroduceParameter.IntroduceParameterBase : RefactoringExecBase`2<IntroduceParameterWorkflow, IntroduceParameterRefactoring> {
    public InlineHelper InlineHelper { get; }
    protected IntroduceParameterBase(IntroduceParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual InlineHelper get_InlineHelper();
    public virtual bool ThisIsUsed(ITreeNode expression);
    public abstract virtual void CallInline(IReference reference, CallSiteContext context, IntroduceParameterInlineCallInfo info, IList`1<string> lambdaParameterNames, int lastArgIndex);
    public abstract virtual void FixOtherArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public abstract virtual void AddParameter(IType type, string name, IDeclaration declaration, ISubstitution substitution, ITreeNode defaultValue);
    public abstract virtual void ReplaceExpression(ITreeNode element);
    [CanBeNullAttribute]
public abstract virtual IReference AddBaseClause(IDeclaredElement constructor);
    public abstract virtual void RemoveLocalVariable(ILocalVariable variable);
    public void RemoveParameter(IDeclaration declaration, IDeclaredElement declaredElement);
    public abstract virtual void RemoveArguments(IReference reference, IList`1<DeclaredElementNode> declaredElementInfos);
}
public class JetBrains.ReSharper.Refactorings.IntroduceParameter.IntroduceParameterDataModel : object {
    [NotNullAttribute]
public IList`1<string> Names;
    private ISolution mySolution;
    private ITreeNodePointer`1<IExpression> myMainExpressionPointer;
    private IDeclaredElementPointer`1<ILocalVariable> myLocalVariablePointer;
    private IDeclaredElementPointer`1<IParametersOwner> myParametersOwnerPointer;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionTypeSuggestion <TypeSuggestion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ITreeNode> <Expressions>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DeclaredElementNode> <LocalInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private IIntroduceParameterDataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DeclaredElementNode> <ParametersToRemove>k__BackingField;
    [NotNullAttribute]
public IType Type { get; public set; }
    public ExpressionTypeSuggestion TypeSuggestion { get; public set; }
    public bool CanBeDefault { get; public set; }
    public Lifetime Lifetime { get; }
    public List`1<ITreeNode> Expressions { get; public set; }
    public PsiLanguageType LanguageType { get; public set; }
    public bool MakeDefault { get; public set; }
    public List`1<DeclaredElementNode> LocalInfos { get; public set; }
    public string ParameterName { get; public set; }
    [CanBeNullAttribute]
public IIntroduceParameterDataProvider DataProvider { get; private set; }
    public List`1<DeclaredElementNode> ParametersToRemove { get; }
    [CanBeNullAttribute]
public IExpression Expression { get; }
    [CanBeNullAttribute]
public ILocalVariable LocalVariable { get; }
    [CanBeNullAttribute]
public IParametersOwner ParametersOwner { get; }
    public IntroduceParameterDataModel(ISolution solution, IExpression expression, IEnumerable`1<ITreeNode> selectedUsages, ILocalVariable localVariable, IParametersOwner parametersOwner, Lifetime lifetime, IIntroduceParameterDataProvider dataProvider);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IType value);
    [CompilerGeneratedAttribute]
public ExpressionTypeSuggestion get_TypeSuggestion();
    [CompilerGeneratedAttribute]
public void set_TypeSuggestion(ExpressionTypeSuggestion value);
    [CompilerGeneratedAttribute]
public bool get_CanBeDefault();
    [CompilerGeneratedAttribute]
public void set_CanBeDefault(bool value);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public List`1<ITreeNode> get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(List`1<ITreeNode> value);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
public void set_LanguageType(PsiLanguageType value);
    [CompilerGeneratedAttribute]
public bool get_MakeDefault();
    [CompilerGeneratedAttribute]
public void set_MakeDefault(bool value);
    [CompilerGeneratedAttribute]
public List`1<DeclaredElementNode> get_LocalInfos();
    [CompilerGeneratedAttribute]
public void set_LocalInfos(List`1<DeclaredElementNode> value);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public IIntroduceParameterDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
private void set_DataProvider(IIntroduceParameterDataProvider value);
    [CompilerGeneratedAttribute]
public List`1<DeclaredElementNode> get_ParametersToRemove();
    public IExpression get_Expression();
    public ILocalVariable get_LocalVariable();
    public IParametersOwner get_ParametersOwner();
    public void SetDataProvider(IIntroduceParameterDataProvider dataProvider);
    public IList`1<string> SuggestNames(IEnumerable`1<ITreeNode> expressions, ILocalVariable localVariable, IExpression expression);
    public JetHashSet`1<ITypeOwner> GetLocalForLambda();
    public bool NameIsUnique(string name);
    private static void AddNameFromElement(ITreeNode e, ICollection`1<string> set);
    private void LoadParametersToRemove(IParametersOwner parametersOwner);
    [CompilerGeneratedAttribute]
private bool <LoadParametersToRemove>b__59_2(IReference r);
}
public class JetBrains.ReSharper.Refactorings.IntroduceParameter.IntroduceParameterHierarchyConflictTextProvider : HierarchyConflictTextProviderBase {
    public virtual string WillAlsoOverride();
    public virtual string WillAlsoImplement();
    public virtual string QuasiImplements();
}
public class JetBrains.ReSharper.Refactorings.IntroduceParameter.IntroduceParameterRefactoring : DrivenRefactoring`2<IntroduceParameterWorkflow, IntroduceParameterBase> {
    private Dictionary`2<IReference, LocalContextResolveResultImage> myResolveImages;
    [CompilerGeneratedAttribute]
private JetHashSet`1<IParameter> <UsedParameters>k__BackingField;
    private JetHashSet`1<ITreeNode> myCastContexts;
    private IParametersOwner myParameterOwner;
    private Dictionary`2<IParametersOwner, ISubstitution> myOverridesSubstitutions;
    [CompilerGeneratedAttribute]
private JetHashSet`1<ITypeOwner> <LocalsForLambda>k__BackingField;
    private JetHashSet`1<IDeclaredElement> myImplicitConstructors;
    private List`1<PrecountedReference> myPrecountedReferences;
    [CompilerGeneratedAttribute]
private int <LastNotOptionalParameterIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HasParamarray>k__BackingField;
    public JetHashSet`1<IParameter> UsedParameters { get; public set; }
    public JetHashSet`1<ITypeOwner> LocalsForLambda { get; private set; }
    public int LastNotOptionalParameterIndex { get; private set; }
    public Dictionary`2<IReference, LocalContextResolveResultImage> ResolveImages { get; }
    public int HasParamarray { get; public set; }
    public IntroduceParameterRefactoring(IntroduceParameterWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public sealed virtual JetHashSet`1<IParameter> get_UsedParameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UsedParameters(JetHashSet`1<IParameter> value);
    [CompilerGeneratedAttribute]
public JetHashSet`1<ITypeOwner> get_LocalsForLambda();
    [CompilerGeneratedAttribute]
private void set_LocalsForLambda(JetHashSet`1<ITypeOwner> value);
    [CompilerGeneratedAttribute]
public int get_LastNotOptionalParameterIndex();
    [CompilerGeneratedAttribute]
private void set_LastNotOptionalParameterIndex(int value);
    public sealed virtual Dictionary`2<IReference, LocalContextResolveResultImage> get_ResolveImages();
    [CompilerGeneratedAttribute]
public int get_HasParamarray();
    [CompilerGeneratedAttribute]
public void set_HasParamarray(int value);
    public sealed virtual InlineHelper GetInlineHelper(PsiLanguageType language);
    public sealed virtual void AddContext(ITreeNode context);
    public virtual bool Execute(IProgressIndicator pi);
    private void RemoveParameters(List`1<DeclaredElementNode> parametersToRemove, IList`1<IParametersOwner> allDeclarations);
    private IList`1<IParametersOwner> GetAllDeclarations(IOverridableMember overridableMember, IProgressIndicator subPi);
    private void ProcessReferences(IProgressIndicator pi);
    private void AddHierarchyConflicts(IEnumerable`1<HierarchyConflict> conflicts);
    private void ReplaceExpressions(IProgressIndicator pi);
    private void ReplaceExpression(ITreeNode expression);
    private void AddOverridersSubstitutions(IParametersOwner initialOwner, IEnumerable`1<IParametersOwner> allDeclarations);
    private void AddParameters(IType type, string newName, IEnumerable`1<IParametersOwner> allDeclarations);
    private void InitResolveImages(IDeclaredElement element);
    private void ConsumeInitialReference(IReference reference);
    private void PreProcessReferences(IEnumerable`1<IReference> references, IntroduceParameterInfo info, IProgressIndicator pi);
    private void PreProcessAllReferences(ICollection`1<IReference> allReferences, IProgressIndicator pi, IntroduceParameterInfo info);
    private void PreProcessReference(IReference reference, IntroduceParameterInfo info);
    private PrecountedReference PreProcessReferenceWithContext(IReference reference, CallSiteContext context, IntroduceParameterInfo info);
    private void ProcessReferenceWithContext(PrecountedReference precountedReference);
    private IList`1<string> GetLambdaParametersNames(IntroduceParameterInlineCallInfo info, ITreeNode context);
    public static JetHashSet`1<IParameter> GetUsedParameters(IList`1<ITreeNode> expression, IParametersOwner parameterOwner);
    private IList`1<IReference> FindReferences(IList`1<IParametersOwner> element, IProgressIndicator pi);
    public sealed virtual Dictionary`2<int, IParameter> GetInlinedMethodParameterInfos(IParametersOwner owner);
    protected virtual IntroduceParameterBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    protected virtual IntroduceParameterBase CreateUnsupportedRefactoring();
    public bool ThisIsUsed(ITreeNode expression);
    private sealed virtual override IRefactoringDriver JetBrains.ReSharper.Refactorings.Inline.ICallSiteContextOwner.get_Driver();
    [CompilerGeneratedAttribute]
private <>f__AnonymousType1`2<IDeclaredElement, IReference> <PreProcessReferences>b__38_0(IDeclaredElement x);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.IntroduceParameter.IntroduceParametersProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.IntroduceParameter.IntroduceParameterWorkflow : DrivenRefactoringWorkflow {
    private IIntroduceParameterDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IntroduceParameterDataModel <Model>k__BackingField;
    public PsiLanguageType LanguageType { get; public set; }
    public IntroduceParameterDataModel Model { get; private set; }
    public HelpId HelpKeyword { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public IntroduceParameterWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
public void set_LanguageType(PsiLanguageType value);
    [CompilerGeneratedAttribute]
public IntroduceParameterDataModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(IntroduceParameterDataModel value);
    public virtual HelpId get_HelpKeyword();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    private IEnumerable`1<ITreeNode> SelectOccurrences(IDataContext context, ITreeNode expression, IParametersOwner selectedParametersOwner);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual bool PostExecute(IProgressIndicator pi);
    [ContractAnnotationAttribute("=> true, expression: notnull, localVariable: canbenull; => false")]
private bool IsAvailable(IDataContext context, IExpression& expression, ILocalVariable& localVariable);
    private bool IsApplicable(IExpression expression, IType type);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    [CanBeNullAttribute]
private IParametersOwner SelectTargetParametersOwner(IDataContext context, IReadOnlyList`1<IParametersOwnerDeclaration> parametersOwnerCandidates);
    public virtual bool Validate();
    public void SetDataProvider(IIntroduceParameterDataProvider testDataProvider);
}
public class JetBrains.ReSharper.Refactorings.IntroduceParameter.UI.IntroduceParameterPage : SingleBeRefactoringPage {
    public static string LambdaGrid;
    public static string UnusedGrid;
    public static string TargetName;
    public static string TargetType;
    public static string MakeDefault;
    private IntroduceParameterDataModel myDataModel;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Title { get; protected set; }
    public string Description { get; protected set; }
    public bool CanMakeDefault { get; }
    public bool HasLambdas { get; }
    public bool HasParametersToRemove { get; }
    public IntroduceParameterPage(IntroduceParameterWorkflow workflow);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    public string GetParameterTypeText(IType returnType);
    [CanBeNullAttribute]
private IType GetTypeOfParameter(ICollection`1<ITypeOwner> localForLambda, IType returnType, ITreeNode context);
    public virtual BeControl GetPageContent();
    public bool get_CanMakeDefault();
    public bool get_HasLambdas();
    public bool get_HasParametersToRemove();
}
public interface JetBrains.ReSharper.Refactorings.IntroduceVariable.Impl.IIntroduceVariableWorkflowProvider {
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.IntroduceVariable.Impl.IntroduceVariableWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "IntroduceVariableActionText")]
public class JetBrains.ReSharper.Refactorings.IntroduceVariable.Impl.IntroVariableAction : ExtensibleRefactoringAction`1<IIntroduceVariableWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public abstract class JetBrains.ReSharper.Refactorings.IntroduceVariable.IntroduceLocalRefactoring : DrivenRefactoring`2<IntroduceLocalWorkflowBase, IntroduceVariableBase> {
    [NotNullAttribute]
protected string CanNotPerformActionText { get; }
    protected IntroduceLocalRefactoring(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    [CanBeNullAttribute]
protected abstract virtual IntroduceVariableResult Execute();
    private void OnWorkflowSuccessfullyFinished(object sender, EventArgs eventArgs);
    private void OnHotspotSessionClosed(HotspotSessionClosedEventArgs args);
    protected virtual IntroduceVariableBase CreateUnsupportedRefactoring();
    protected virtual IntroduceVariableBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    private void ShowCanNotApplyTooltip();
    protected abstract virtual string get_CanNotPerformActionText();
}
public abstract class JetBrains.ReSharper.Refactorings.IntroduceVariable.IntroduceLocalWorkflowBase : DrivenRefactoringWorkflow2`1<IntroduceVariableHelper> {
    [CompilerGeneratedAttribute]
private IRangeMarker <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextControl <TextControl>k__BackingField;
    [CompilerGeneratedAttribute]
private IntroduceVariableResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<ITreeNode> <ContainingLambdaPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <CustomLifetime>k__BackingField;
    public IRangeMarker Marker { get; protected set; }
    public ITextControl TextControl { get; private set; }
    [CanBeNullAttribute]
public IntroduceVariableResult Result { get; public set; }
    [ObsoleteAttribute("To be removed")]
public ITreeNodePointer`1<ITreeNode> ContainingLambdaPointer { get; protected set; }
    public RefactoringActionGroup ActionGroup { get; }
    public bool HasUI { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public Lifetime CustomLifetime { get; public set; }
    protected IntroduceLocalWorkflowBase(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public IRangeMarker get_Marker();
    [CompilerGeneratedAttribute]
protected void set_Marker(IRangeMarker value);
    [CompilerGeneratedAttribute]
public ITextControl get_TextControl();
    [CompilerGeneratedAttribute]
private void set_TextControl(ITextControl value);
    [CompilerGeneratedAttribute]
public IntroduceVariableResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(IntroduceVariableResult value);
    [CompilerGeneratedAttribute]
public ITreeNodePointer`1<ITreeNode> get_ContainingLambdaPointer();
    [CompilerGeneratedAttribute]
protected void set_ContainingLambdaPointer(ITreeNodePointer`1<ITreeNode> value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual bool get_HasUI();
    public virtual bool IsAvailable(IDataContext context);
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    protected virtual IntroduceVariableHelper CreateUnsupportedHelper();
    protected virtual IntroduceVariableHelper CreateHelper(IRefactoringLanguageService service);
    [CompilerGeneratedAttribute]
public sealed virtual Lifetime get_CustomLifetime();
    [CompilerGeneratedAttribute]
public void set_CustomLifetime(Lifetime value);
}
public abstract class JetBrains.ReSharper.Refactorings.IntroduceVariable.IntroduceVariableBase : RefactoringExecBase`2<IntroduceLocalWorkflowBase, IntroduceLocalRefactoring> {
    protected IntroduceVariableBase(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public abstract virtual IntroduceVariableResult Process(IntroduceVariableData introduceVariableData);
}
public class JetBrains.ReSharper.Refactorings.IntroduceVariable.IntroduceVariableDataProvider : object {
    [CompilerGeneratedAttribute]
private bool <UseInitialExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SelectedOccurrencesNumberPosition>k__BackingField;
    public bool UseInitialExpression { get; public set; }
    public int SelectedOccurrencesNumberPosition { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UseInitialExpression();
    [CompilerGeneratedAttribute]
public void set_UseInitialExpression(bool value);
    [CompilerGeneratedAttribute]
public int get_SelectedOccurrencesNumberPosition();
    [CompilerGeneratedAttribute]
public void set_SelectedOccurrencesNumberPosition(int value);
}
public class JetBrains.ReSharper.Refactorings.IntroduceVariable.IntroduceVariableHelper : object {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool CheckAvailability(ITreeNode element);
    [CanBeNullAttribute]
public virtual ITreeNode GetScope(ITreeNode element);
    [CanBeNullAttribute]
public virtual ITreeNode GetInnerScope(ITreeNode element);
    public virtual bool CheckOccurrence(ITreeNode masterExpression, ITreeNode occurrence);
    public virtual IntroduceVariableData CreateData(ITreeNode sourceExpression, List`1<ITreeNode> usages);
    public virtual bool AdditionalInitialization(IntroduceVariableWorkflow workflow, ITreeNode expression, IDataContext context);
    public virtual ITreeNode SelectExpressionFromInnerExpressions(ITreeNode initialTreeNode, IDataContext context, Lifetime lifetime);
    [CompilerGeneratedAttribute]
private bool <SelectExpressionFromInnerExpressions>g__IsApplicable|8_0(IExpression e, IType type);
}
public class JetBrains.ReSharper.Refactorings.IntroduceVariable.IntroduceVariableRefactoring : IntroduceLocalRefactoring {
    private IntroduceVariableWorkflow Workflow { get; }
    protected string CanNotPerformActionText { get; }
    public IntroduceVariableRefactoring(IntroduceVariableWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    private IntroduceVariableWorkflow get_Workflow();
    protected virtual string get_CanNotPerformActionText();
    protected virtual IntroduceVariableResult Execute();
}
internal class JetBrains.ReSharper.Refactorings.IntroduceVariable.IntroduceVariableUnsupported : IntroduceVariableBase {
    public IntroduceVariableUnsupported(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IntroduceVariableResult Process(IntroduceVariableData introduceVariableData);
}
public class JetBrains.ReSharper.Refactorings.IntroduceVariable.IntroduceVariableWorkflow : IntroduceLocalWorkflowBase {
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IntroduceVariableDataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IntroduceVariableData <DataModel>k__BackingField;
    public PsiLanguageType LanguageType { get; private set; }
    public IntroduceVariableDataProvider DataProvider { get; public set; }
    public IntroduceVariableData DataModel { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public IntroduceVariableWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    [CompilerGeneratedAttribute]
public IntroduceVariableDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
public void set_DataProvider(IntroduceVariableDataProvider value);
    [CompilerGeneratedAttribute]
public IntroduceVariableData get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(IntroduceVariableData value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual string get_Title();
    public virtual bool Initialize(IDataContext context);
    [CanBeNullAttribute]
protected ITreeNode FindMasterNode(IDataContext context);
    [CanBeNullAttribute]
protected ITreeNode FindInitialTreeNode(IDataContext context);
    protected virtual ITreeNode SelectExpressionToExtract(IDataContext context, ITreeNode initialTreeNode);
    [CanBeNullAttribute]
protected IList`1<IntroducePopupOccurrence> GetAllOccurrences(IDataContext context, ITreeNode masterExpression);
    [CanBeNullAttribute]
private IList`1<ITreeNode> SelectOccurrences(IDataContext context, IList`1<IntroducePopupOccurrence> occurrences);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailable(IDataContext context, ITreeNode& expression);
}
public interface JetBrains.ReSharper.Refactorings.InvertBool.IInvertBoolWorkflowProvider {
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "InvertBooleanActionText")]
public class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolAction : ExtensibleRefactoringAction`1<IInvertBoolWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolDataModel : object {
    [CompilerGeneratedAttribute]
private bool <InvertOuter>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDeclaredElement> <DeclaredElements>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <InitialDeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvertInner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IReferencePointer> <References>k__BackingField;
    public bool InvertOuter { get; }
    public IList`1<IDeclaredElement> DeclaredElements { get; public set; }
    public IDeclaredElement InitialDeclaredElement { get; public set; }
    public bool InvertInner { get; public set; }
    public string Name { get; public set; }
    public List`1<IReferencePointer> References { get; public set; }
    public InvertBoolDataModel(IList`1<IDeclaredElement> declaredElements, IDeclaredElement initialDeclaredElement, bool invertInner, bool invertOuter, string name);
    [CompilerGeneratedAttribute]
public bool get_InvertOuter();
    [CompilerGeneratedAttribute]
public void set_DeclaredElements(IList`1<IDeclaredElement> value);
    [CompilerGeneratedAttribute]
public IList`1<IDeclaredElement> get_DeclaredElements();
    [CompilerGeneratedAttribute]
public void set_InitialDeclaredElement(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_InitialDeclaredElement();
    [CompilerGeneratedAttribute]
public void set_InvertInner(bool value);
    [CompilerGeneratedAttribute]
public bool get_InvertInner();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_References(List`1<IReferencePointer> value);
    [CompilerGeneratedAttribute]
public List`1<IReferencePointer> get_References();
}
public class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolHelper : object {
    [CompilerGeneratedAttribute]
private bool <IsLanguageSupported>k__BackingField;
    public bool IsLanguageSupported { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLanguageSupported();
    [CompilerGeneratedAttribute]
private void set_IsLanguageSupported(bool value);
    public virtual void ProcessDeclaration(IDeclaration declaration, InvertBoolDataModel model);
    public virtual bool ProcessReference(IReference reference);
    public virtual bool IsAvailable(IDeclaration declaration);
}
internal class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolHelperUnsupported : InvertBoolHelper {
}
public class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolPage : SingleBeRefactoringPage {
    private InvertBoolViewModel myViewModel;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public InvertBoolPage(InvertBoolViewModel model, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__10_0(bool v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__10_1(string v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__10_2(bool v);
}
internal class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolRefactoring : object {
    private IRefactoringDriver myDriver;
    private InvertBoolWorkflow myWorkflow;
    private InvertBoolDataModel myDataModel;
    public InvertBoolRefactoring(InvertBoolWorkflow workflow, InvertBoolViewModel model, IRefactoringDriver driver);
    public sealed virtual bool Execute(IProgressIndicator pi);
    private void ProcessDeclaration();
    private void ProcessReferences();
    private FindExecution Consume(FindResult arg);
}
public class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolViewModel : object {
    [NotNullAttribute]
private IDeclaredElement myDeclaredElement;
    [NotNullAttribute]
private IDeclaredElementPointer`1<IDeclaredElement> myDeclaredElementPointer;
    [NotNullAttribute]
private List`1<IDeclaredElementPointer`1<IDeclaredElement>> myExtraElementPointers;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvertInner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvertOuter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInvertInner>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    public string Name { get; public set; }
    public bool InvertInner { get; public set; }
    public bool InvertOuter { get; public set; }
    public bool HasInvertInner { get; public set; }
    [CanBeNullAttribute]
public IDeclaredElement InitialDeclaredElement { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IList`1<IDeclaredElement> DeclaredElements { get; }
    [NotNullAttribute]
public IPsiServices PsiServices { get; }
    public InvertBoolViewModel(IDeclaredElement declaredElement);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_InvertInner();
    [CompilerGeneratedAttribute]
public void set_InvertInner(bool value);
    [CompilerGeneratedAttribute]
public bool get_InvertOuter();
    [CompilerGeneratedAttribute]
public void set_InvertOuter(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasInvertInner();
    [CompilerGeneratedAttribute]
public void set_HasInvertInner(bool value);
    public IDeclaredElement get_InitialDeclaredElement();
    public IList`1<IDeclaredElement> get_DeclaredElements();
    [CompilerGeneratedAttribute]
public IPsiServices get_PsiServices();
    public InvertBoolDataModel GetData();
}
public class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolWorkflow : DrivenRefactoringWorkflow2`1<InvertBoolHelper> {
    private InvertBoolViewModel myModel;
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public InvertBoolWorkflow(ISolution solution, string actionId);
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual bool IsAvailable(IDataContext context);
    [ContractAnnotationAttribute("=> false, owner:null; => true, owner:notnull")]
private bool IsAvailable(IDataContext context, IDeclaredElement& owner);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual InvertBoolHelper CreateUnsupportedHelper();
    protected virtual InvertBoolHelper CreateHelper(IRefactoringLanguageService service);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.InvertBool.InvertBoolWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[ActionAttribute("Refactorings.AdjustNamespaces", "JetBrains.ReSharper.Refactorings.Resources.Strings", "AdjustNamespacesActionText")]
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.AdjustNamespacesAction : ExtensibleRefactoringAction`1<IAdjustNamespacesWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.AdjustNamespacesBase : RefactoringExecBase`2<AdjustNamespacesWorkflow, AdjustNamespacesRefactoring> {
    public AdjustNamespacesBase(AdjustNamespacesWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.AdjustNamespacesDataModel : object {
    private List`1<ProjectItemInfo> myProjectItems;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<string> <AffectedNamespaceNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IProjectFile, List`1<IDeclaredElement>> <NotAffectedImportedSymbols>k__BackingField;
    public bool NonInteractive { get; }
    public IList`1<ProjectItemInfo> ProjectFilesWithProblems { get; }
    public JetHashSet`1<string> AffectedNamespaceNames { get; }
    public Dictionary`2<IProjectFile, List`1<IDeclaredElement>> NotAffectedImportedSymbols { get; public set; }
    public AdjustNamespacesDataModel(IProjectModelElement[] projectModelElements, AdjustNamespacesDataProvider dataProvider, AdjustNamespacesWorkflow workflow);
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    public IList`1<ProjectItemInfo> get_ProjectFilesWithProblems();
    [CompilerGeneratedAttribute]
public JetHashSet`1<string> get_AffectedNamespaceNames();
    [CompilerGeneratedAttribute]
public Dictionary`2<IProjectFile, List`1<IDeclaredElement>> get_NotAffectedImportedSymbols();
    [CompilerGeneratedAttribute]
public void set_NotAffectedImportedSymbols(Dictionary`2<IProjectFile, List`1<IDeclaredElement>> value);
    public bool IsNotAffectedNamespace(IDeclaredElement element);
    public bool IsInMoveScope(IPsiSourceFile sourceFile);
    public bool IsInMoveScope(ITreeNode declaration);
    public void FilterInconsistentFiles(IProgressIndicator pi, AdjustNamespacesWorkflow adjustNamespacesWorkflow);
    public void AnalyseProjectFile(ProjectItemInfo info, IProgressIndicator pi, AdjustNamespacesWorkflow adjustNamespacesWorkflow);
    public bool AnalyseFile(IFile file, PsiLanguageType language, string expectedNamespace, AdjustNamespacesWorkflow adjustNamespacesWorkflow);
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__AddProjectFile|13_0(IProjectFile sharedFile, <>c__DisplayClass13_0& );
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.AdjustNamespacesHelperBase : object {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual void FixFile(IFile file, string name, ResolveImagesRepository repository, List`1<IDeclaredElement> elements);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual IDeclaredElement GetImportedSymbolOfUsing(ITreeNode element);
    public virtual bool FileHasProblems(IFile file, string ns);
    public virtual IReadOnlyList`1<ITypeDeclaration> GetTopLevelTypeDeclarations(IFile file);
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.AdjustNamespacesRefactoring : DrivenRefactoring`2<AdjustNamespacesWorkflow, AdjustNamespacesBase> {
    private AdjustNamespacesDataModel myAdjustNamespacesDataModel;
    [CompilerGeneratedAttribute]
private ClassPartsCollector <Collector>k__BackingField;
    public ClassPartsCollector Collector { get; private set; }
    public AdjustNamespacesRefactoring(AdjustNamespacesWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public ClassPartsCollector get_Collector();
    [CompilerGeneratedAttribute]
private void set_Collector(ClassPartsCollector value);
    private void PrepareClassParts(IProgressIndicator pi, AdjustNamespacesDataModel adjustNamespacesDataModel);
    public void MakeActionWithPsi(IProjectItem item, Action`2<IFile, PsiLanguageType> action);
    private void PrepareClassParts(ProjectItemInfo info, IProgressIndicator pi);
    private void PrepareClassParts(IFile file, PsiLanguageType language);
    public virtual bool Execute(IProgressIndicator pi);
    protected virtual AdjustNamespacesBase CreateUnsupportedRefactoring();
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.AdjustNamespacesWorkflow : DrivenRefactoringWorkflow2`1<AdjustNamespacesHelperBase> {
    [CompilerGeneratedAttribute]
private AdjustNamespacesDataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNamespacesDataModel <Model>k__BackingField;
    [CanBeNullAttribute]
public AdjustNamespacesDataProvider DataProvider { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public AdjustNamespacesDataModel Model { get; private set; }
    public AdjustNamespacesWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public AdjustNamespacesDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
private void set_DataProvider(AdjustNamespacesDataProvider value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public AdjustNamespacesDataModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(AdjustNamespacesDataModel value);
    public void SetDataProvider(AdjustNamespacesDataProvider dataProvider);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator pi);
    protected virtual AdjustNamespacesHelperBase CreateUnsupportedHelper();
    protected virtual AdjustNamespacesHelperBase CreateHelper(IRefactoringLanguageService service);
    public void MakeActionWithPsi(IProjectItem item, Action`2<IFile, PsiLanguageType> action);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.AdjustNamespacesWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public interface JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.IAdjustNamespacesWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.Impl.AdjustNamespaceRunner : object {
    private List`1<IProjectItem> myFiles;
    private AdjustNamespacesWorkflow myWorkflow;
    private ClassPartsCollector myCollector;
    private ResolveImagesRepository myImagesRepository;
    private IPsiTransactions myPsiTransactions;
    private IList`1<ITreeNode> myUsingsToRemove;
    private ISolution mySolution;
    private IPsiServices myPsiServices;
    public AdjustNamespaceRunner(AdjustNamespacesWorkflow workflow, ClassPartsCollector collector);
    public bool Execute(IProgressIndicator pi);
    private void FixFiles(IProgressIndicator pi);
    private void RemoveUsingsOfEmptyNamespaces(IProgressIndicator pi);
    private void FindUsagesOfTopmostElements(IProgressIndicator pi);
    private void FixFile(IFile file, PsiLanguageType language);
    private void NofityFileFixed(IPsiSourceFile sourceFile, string namespaceNew);
    [CompilerGeneratedAttribute]
private IResolveImagesLanguageSupport <.ctor>b__8_2(PsiLanguageType x);
    [CompilerGeneratedAttribute]
private void <FixFiles>b__10_0(IProjectItem x, IProgressIndicator subSubPi);
    [CompilerGeneratedAttribute]
private void <FixFiles>b__10_1(IFile file, PsiLanguageType language);
    [CompilerGeneratedAttribute]
private void <FixFiles>b__10_2(IProjectItem x, IProgressIndicator subSubPi);
    [CompilerGeneratedAttribute]
private void <FixFiles>b__10_3(IFile file, PsiLanguageType language);
    [CompilerGeneratedAttribute]
private bool <FixFiles>b__10_4(ICollection`1<IDeclaredElement> innerElements);
    [CompilerGeneratedAttribute]
private bool <FixFiles>b__10_5(IDeclaredElement x);
    [CompilerGeneratedAttribute]
private bool <FixFiles>b__10_6(IPsiSourceFile d);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITreeNode> <FixFiles>b__10_7(IFile file, IList`1<INamespace> namespaces);
    [CompilerGeneratedAttribute]
private void <FixFiles>b__10_8(IProjectItem x, IProgressIndicator subSubPi);
    [CompilerGeneratedAttribute]
private void <FixFiles>b__10_9(ITreeNode x, IProgressIndicator subSubPi);
    [CompilerGeneratedAttribute]
private bool <FindUsagesOfTopmostElements>b__12_0(IReference x);
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.Impl.AdjustNamespacesDataProvider : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Conflicts>k__BackingField;
    public List`1<string> Conflicts { get; }
    public AdjustNamespacesDataProvider(List`1<string> conflicts);
    [CompilerGeneratedAttribute]
public List`1<string> get_Conflicts();
    public void CommitConflicts(IList`1<Conflict> conflicts);
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.Impl.AdjustNamespacesPage : SingleBeRefactoringPage {
    private AdjustNamespacesDataModel myDataModel;
    private BeControl myGrid;
    public static string AdjustNamespacesGrid;
    [CompilerGeneratedAttribute]
private string <PageDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string PageDescription { get; }
    public string Description { get; protected set; }
    public AdjustNamespacesPage(AdjustNamespacesWorkflow workflow, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_PageDescription();
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    public virtual BeControl GetPageContent();
    public virtual bool RefreshContents(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.Impl.ClassPartsCollector : object {
    private AdjustNamespacesWorkflow myWorkflow;
    private Dictionary`2<string, IList`1<IDeclaredElement>> myFqnToElements;
    private Dictionary`2<IDeclaredElement, IList`1<Pair`2<string, IDeclaration>>> myDeclaredElementsToNamespaces;
    private Dictionary`2<IDeclaredElement, IList`1<Pair`2<IDeclaration, IProjectFile>>> myOutOfScopeParts;
    [CompilerGeneratedAttribute]
private Dictionary`2<IProjectFile, List`1<IDeclaredElement>> <ImportedSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDeclaredElement> <TopmostElements>k__BackingField;
    private Dictionary`2<IDeclaredElement, ITypeDeclaration> myExternalConflictedElements;
    [CompilerGeneratedAttribute]
private JetHashSet`1<INamespace> <EmptyNamespaceCandidates>k__BackingField;
    public Dictionary`2<IProjectFile, List`1<IDeclaredElement>> ImportedSymbols { get; }
    public IList`1<IDeclaredElement> TopmostElements { get; }
    public JetHashSet`1<INamespace> EmptyNamespaceCandidates { get; }
    public ClassPartsCollector(AdjustNamespacesWorkflow workflow);
    [CompilerGeneratedAttribute]
public Dictionary`2<IProjectFile, List`1<IDeclaredElement>> get_ImportedSymbols();
    [CompilerGeneratedAttribute]
public IList`1<IDeclaredElement> get_TopmostElements();
    [CompilerGeneratedAttribute]
public JetHashSet`1<INamespace> get_EmptyNamespaceCandidates();
    public bool HasConflicts();
    private static bool HasInconsistency(IList`1<Pair`2<string, IDeclaration>> pairs);
    public void Register(IFile file, string s);
    private void ProcessElement(ITreeNode element, string properName);
    private ICollection`1<ITypeElement> GetConflictedTypeElements(string fullName, ISymbolScope cache);
    private static string MakeName(string name, ITypeElement element);
    private List`1<KeyValuePair`2<string, IList`1<IDeclaredElement>>> BuildCollision();
    public IList`1<Conflict> BuildConflicts();
    [CompilerGeneratedAttribute]
private bool <ProcessElement>b__18_1(IDeclaration x);
    [CompilerGeneratedAttribute]
private bool <ProcessElement>b__18_0(ITypeElement x);
    [CompilerGeneratedAttribute]
private bool <ProcessElement>b__18_3(IDeclaration d);
}
internal class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.Impl.EmptyNamespacesUsagesSaver : SearchDomainVisitor {
    [CompilerGeneratedAttribute]
private IList`1<ITreeNode> <UsingsToRemove>k__BackingField;
    [NotNullAttribute]
private List`1<INamespace> myNamespaces;
    private Func`3<IFile, IList`1<INamespace>, IEnumerable`1<ITreeNode>> myGetUsagesOfNamespaceFromFile;
    public IList`1<ITreeNode> UsingsToRemove { get; }
    public bool ProcessingIsFinished { get; }
    public EmptyNamespacesUsagesSaver(List`1<INamespace> namespaces, ISolution solution, Func`3<IFile, IList`1<INamespace>, IEnumerable`1<ITreeNode>> getUsagesOfNamespaceFromFile);
    [CompilerGeneratedAttribute]
public IList`1<ITreeNode> get_UsingsToRemove();
    public virtual void VisitPsiSourceFile(IPsiSourceFile sourceFile);
    public void MakeActionWithPsi(IPsiSourceFile sourceFile, Action`2<IFile, PsiLanguageType> action);
    public virtual bool get_ProcessingIsFinished();
    private void SaveEmptyNamespacesUsingsFromFile(IFile file, List`1<INamespace> namespaces);
    [CompilerGeneratedAttribute]
private void <VisitPsiSourceFile>b__6_0(IFile psiFile, PsiLanguageType language);
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.Impl.FilesCollector : RecursiveProjectVisitor {
    private IList`1<ProjectItemInfo> myProjectFiles;
    private Lifetime myLifetime;
    public FilesCollector(IList`1<ProjectItemInfo> projectFiles, Lifetime lifetime);
    public virtual void VisitProjectFile(IProjectFile projectFile);
}
public class JetBrains.ReSharper.Refactorings.Move.AdjustNamespaces.Impl.ProjectItemInfo : object {
    [CompilerGeneratedAttribute]
private IProjectItem <ProjectItem>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasProblems>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ITreeGridNode> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Included>k__BackingField;
    public IProjectItem ProjectItem { get; }
    public bool HasProblems { get; public set; }
    public List`1<ITreeGridNode> Children { get; public set; }
    public bool Included { get; public set; }
    public ProjectItemInfo(IProjectItem projectItem);
    [CompilerGeneratedAttribute]
public IProjectItem get_ProjectItem();
    [CompilerGeneratedAttribute]
public bool get_HasProblems();
    [CompilerGeneratedAttribute]
public void set_HasProblems(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ITreeGridNode> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Children(List`1<ITreeGridNode> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Included();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Included(bool value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.Move.Common.MoveUtil : object {
    public static bool IsInternal(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
public static IProjectFile CopyProjectFile(IProjectFolder targetFolder, IProjectFile prototypeFile, bool copyContent, BuildAction buildAction);
    public static bool MoveProjectItem(IProjectFolder folder, IProjectItem itemToMove, BuildAction buildAction);
    [CanBeNullAttribute]
public static IProjectFile CreateProjectFileCopy(IProjectFolder folder, VirtualFileSystemPath location, IProjectFile prototypeFile, bool copyContent, BuildAction buildAction);
    public static IProjectFolder CreateProjectFolderFromFullPath(ISolution solution, string newText);
    public static IProjectFile CreateProjectFileFromFullPath(ISolution solution, string newText, IProjectFolder parentFolder);
    private static IProjectFolder GetExistingFolder(String[] stringParts, Int32& index, ISolution solution, IProjectFolder parentFolder);
    public static IProjectFolder CreateProjectFolder(IProjectFolder folder, VirtualFileSystemPath location, bool useLocation, bool deletePrevious);
    [ExtensionAttribute]
public static void ForEachWithProgressMultyCore(ICollection`1<T> collection, IProgressIndicator pi, string taskName, Action`2<T, IProgressIndicator> action);
    public static IList`1<ITreeNode> SaveUsingsOfEmptyNamespaces(IEnumerable`1<Pair`2<IPsiModule, List`1<INamespace>>> emptyNamespaceCandidates, IProgressIndicator pi, Func`3<IFile, IList`1<INamespace>, IEnumerable`1<ITreeNode>> getUsagesOfNamespaceFromFile);
    private static IList`1<ITreeNode> SaveUsingsOfEmptyNamespaces(IPsiModule module, List`1<INamespace> namespaces, IProgressIndicator pi, Func`3<IFile, IList`1<INamespace>, IEnumerable`1<ITreeNode>> getUsagesOfNamespaceFromFile);
    public static IList`1<Pair`2<IPsiModule, List`1<INamespace>>> FindEmptyNamespaces(ISolution solution, ICollection`1<INamespace> emptyNamespaceCandidates, IProgressIndicator pi, Func`2<ICollection`1<IDeclaredElement>, bool> allMembersOfNamespaceAreIncluded);
    private static bool AllTypeElementsAreIncluded(ICollection`1<IClrDeclaredElement> innerElements, Func`2<ICollection`1<IDeclaredElement>, bool> allMembersOfNamespaceAreIncluded, ISymbolScope cache);
    public static IList`1<INamespace> GetAllOwnerEmptyNamespacesCandidates(IEnumerable`1<INamespace> namespaces, string newNamespaceName);
    public static void CopyFileContent(IFile sourceFile, IFile targetFile);
    public static List`1<IProjectModelElement> GetNonNestedProjectItems(IProjectModelElement[] elements, bool filterDependsUpon);
    private static IList`1<IProjectModelElement> ToRootDependsUpon(IProjectModelElement projectItem, bool filterDependsUpon);
    private static bool HasParentsIn(IProjectModelElement item, ICollection`1<IProjectModelElement> items);
    public static IList`1<INamespace> GetPossiblyEmptyNamespaces(IEnumerable`1<IDeclaredElement> elements);
    public static bool IsPrimaryDeclaration(IDeclaration declaration);
    public static bool CanContainCodeFiles(IProjectFolder projectFolder);
    private static bool IsInWebSiteAppCode(IProjectFolder projectFolder);
    public static bool FolderCanContainWebPages(IProjectFolder projectFolder);
}
public class JetBrains.ReSharper.Refactorings.Move.Common.UnusedUsingSaver : object {
    private Dictionary`2<IFile, HashSet`1<ITreeNode>> myRedundantUsings;
    public void RemoveNewRedundantUsings(RemoveSingleUsingDelegate remove, IProgressIndicator progress);
    public void AddUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public bool Contains(IFile file);
}
public class JetBrains.ReSharper.Refactorings.Move.Impl.MoveIntoMatchingFilesDataProvider : object {
    [CompilerGeneratedAttribute]
private bool <MoveTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MoveEnums>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MoveDelegates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Conflicts>k__BackingField;
    public bool MoveTypes { get; }
    public bool MoveEnums { get; }
    public bool MoveDelegates { get; }
    public bool RenameFiles { get; }
    public IList`1<string> Conflicts { get; public set; }
    public MoveIntoMatchingFilesDataProvider(bool moveTypes, bool moveEnums, bool moveDelegates, bool renameFiles, List`1<string> conflicts);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_MoveTypes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_MoveEnums();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_MoveDelegates();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RenameFiles();
    public sealed virtual void AddConflict(IConflict conflict);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Conflicts();
    [CompilerGeneratedAttribute]
public void set_Conflicts(IList`1<string> value);
}
public class JetBrains.ReSharper.Refactorings.Move.Impl.MoveToFileDataProvider : object {
    [CompilerGeneratedAttribute]
private bool <RemoveOldFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaration <TypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public bool RemoveOldFile { get; }
    public IDeclaration TypeDeclaration { get; }
    public string FileName { get; }
    public MoveToFileDataProvider(string fileName, IDeclaration declaration, bool removeOldFile);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RemoveOldFile();
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaration get_TypeDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileName();
}
public interface JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.IMoveIntoMatchingFilesWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.Impl.FilesCollector : RecursiveProjectVisitor {
    private IList`1<IProjectModelElementPointer> myProjectFiles;
    public FilesCollector(IList`1<IProjectModelElementPointer> workflow);
    public virtual void VisitProjectFile(IProjectFile projectFile);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.Impl.FolderFilesCollection : object {
    private MoveIntoMatchingFilesWorkflow myWorkflow;
    private List`1<string> myNamesOfNewFiles;
    [CompilerGeneratedAttribute]
private IProjectFolder <ProjectFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IProjectFile, MovedDeclarationsCollection> <MovedDeclaration>k__BackingField;
    public IProjectFolder ProjectFolder { get; }
    public Dictionary`2<IProjectFile, MovedDeclarationsCollection> MovedDeclaration { get; }
    public FolderFilesCollection(MoveIntoMatchingFilesWorkflow workflow, IProjectFolder projectFolder);
    [CompilerGeneratedAttribute]
public IProjectFolder get_ProjectFolder();
    [CompilerGeneratedAttribute]
public Dictionary`2<IProjectFile, MovedDeclarationsCollection> get_MovedDeclaration();
    public void CommitFile(IProjectFile projectFile, IFile file, PsiLanguageType language, IProgressIndicator pi);
    public void RegisterNewFile(MovedDeclaration declaration);
}
public interface JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.Impl.IMoveIntoMatchingFilesDataProvider {
    public bool MoveTypes { get; }
    public bool MoveEnums { get; }
    public bool MoveDelegates { get; }
    public bool RenameFiles { get; }
    public abstract virtual bool get_MoveTypes();
    public abstract virtual bool get_MoveEnums();
    public abstract virtual bool get_MoveDelegates();
    public abstract virtual bool get_RenameFiles();
    public abstract virtual void AddConflict(IConflict conflicts);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.Impl.MovedDeclaration : object {
    [CompilerGeneratedAttribute]
private MovedDeclarationsCollection <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <ProjectFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProperName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaration <TypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <NamespaceDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private Conflict <MoveConflict>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <TargetProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <TargetLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldBeMoved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustRename>k__BackingField;
    [NotNullAttribute]
public MovedDeclarationsCollection Collection { get; }
    [NotNullAttribute]
public IProjectFile ProjectFile { get; }
    [NotNullAttribute]
public PsiLanguageType Language { get; }
    [NotNullAttribute]
public IProjectFolder ProjectFolder { get; }
    [NotNullAttribute]
public string ProperName { get; public set; }
    [NotNullAttribute]
public IDeclaration TypeDeclaration { get; }
    [CanBeNullAttribute]
public ITreeNode NamespaceDeclaration { get; }
    [CanBeNullAttribute]
public Conflict MoveConflict { get; public set; }
    [CanBeNullAttribute]
public IProjectFile TargetProjectFile { get; public set; }
    [CanBeNullAttribute]
public VirtualFileSystemPath TargetLocation { get; public set; }
    public bool ShouldBeMoved { get; public set; }
    public bool MustRename { get; public set; }
    public MovedDeclaration(IDeclaration typeDeclaration, ITreeNode namespaceDeclaration, IProjectFolder ownerFolder, IProjectFile projectFile, MovedDeclarationsCollection collection);
    [CompilerGeneratedAttribute]
public MovedDeclarationsCollection get_Collection();
    [CompilerGeneratedAttribute]
public IProjectFile get_ProjectFile();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
public IProjectFolder get_ProjectFolder();
    [CompilerGeneratedAttribute]
public string get_ProperName();
    [CompilerGeneratedAttribute]
public void set_ProperName(string value);
    [CompilerGeneratedAttribute]
public IDeclaration get_TypeDeclaration();
    [CompilerGeneratedAttribute]
public ITreeNode get_NamespaceDeclaration();
    [CompilerGeneratedAttribute]
public Conflict get_MoveConflict();
    [CompilerGeneratedAttribute]
public void set_MoveConflict(Conflict value);
    [CompilerGeneratedAttribute]
public IProjectFile get_TargetProjectFile();
    [CompilerGeneratedAttribute]
public void set_TargetProjectFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_TargetLocation();
    [CompilerGeneratedAttribute]
public void set_TargetLocation(VirtualFileSystemPath value);
    [CompilerGeneratedAttribute]
public bool get_ShouldBeMoved();
    [CompilerGeneratedAttribute]
public void set_ShouldBeMoved(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustRename();
    [CompilerGeneratedAttribute]
public void set_MustRename(bool value);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.Impl.MovedDeclarationsCollection : object {
    private string myFileName;
    private IProjectFile myProjectFile;
    private MoveIntoMatchingFilesWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private FolderFilesCollection <FolderFilesCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IDeclaration, MovedDeclaration> <MovedDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTopLevelCode>k__BackingField;
    public FolderFilesCollection FolderFilesCollection { get; }
    public Dictionary`2<IDeclaration, MovedDeclaration> MovedDeclarations { get; }
    public bool HasTopLevelCode { get; }
    public MovedDeclarationsCollection(MoveIntoMatchingFilesWorkflow workflow, FolderFilesCollection collection, IProjectFile projectFile, bool hasTopLevelCode);
    [CompilerGeneratedAttribute]
public FolderFilesCollection get_FolderFilesCollection();
    [CompilerGeneratedAttribute]
public Dictionary`2<IDeclaration, MovedDeclaration> get_MovedDeclarations();
    [CompilerGeneratedAttribute]
public bool get_HasTopLevelCode();
    public void CommitTypeDeclaration(IDeclaration typeDeclaration, ITreeNode namespaceDeclaration, IProjectFile projectFile);
    public IList`1<MovedDeclaration> GetImproperDeclarations();
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.Impl.MoveIntoMatchingFilesCollector : object {
    private MoveIntoMatchingFilesWorkflow myWorkflow;
    private Dictionary`2<IProjectFolder, FolderFilesCollection> myFolderToFiles;
    public MoveIntoMatchingFilesCollector(MoveIntoMatchingFilesWorkflow workflow);
    public void Commit(IList`1<IProjectModelElementPointer> elementPointers, IProgressIndicator pi);
    private void CommitProjectFile(IProjectFile projectFile, IProgressIndicator pi);
    private void CommitPsiFile(IProjectFile projectFile, IFile file, PsiLanguageType language, IProgressIndicator pi);
    public void AssignProperLocations(IProgressIndicator pi);
    private void AssignProperLocationsPerFolder(IProjectFolder projectFolder, FolderFilesCollection collection);
    public IList`1<Conflict> GetConflicts();
    public IList`1<MovedDeclaration> AllDeclarations();
    public IList`1<MovedDeclaration> AllImproperDelclarations();
    public bool CreateRequiredFiles(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private bool <AssignProperLocationsPerFolder>b__7_4(KeyValuePair`2<IDeclaration, MovedDeclaration> x);
    [CompilerGeneratedAttribute]
private bool <AssignProperLocationsPerFolder>b__7_5(KeyValuePair`2<IDeclaration, MovedDeclaration> x);
    [CompilerGeneratedAttribute]
private bool <AssignProperLocationsPerFolder>b__7_6(KeyValuePair`2<IDeclaration, MovedDeclaration> x);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "MoveTypesIntoMatchingFilesActionText")]
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.MoveIntoMatchingFilesAction : ExtensibleRefactoringAction`1<IMoveIntoMatchingFilesWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.MoveIntoMatchingFilesBase : RefactoringExecBase`2<MoveIntoMatchingFilesWorkflow, MoveIntoMatchingFilesRefactoring> {
    public MoveIntoMatchingFilesBase(MoveIntoMatchingFilesWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.MoveIntoMatchingFilesDataModel : object {
    [CompilerGeneratedAttribute]
private bool <MoveTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MoveDelegates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MoveEnums>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuggestTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuggestDelegates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuggestEnums>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IProjectModelElementPointer> <ProjectFiles>k__BackingField;
    public bool MoveTypes { get; public set; }
    public bool MoveDelegates { get; public set; }
    public bool MoveEnums { get; public set; }
    public bool SuggestTypes { get; }
    public bool SuggestDelegates { get; }
    public bool SuggestEnums { get; }
    public IList`1<IProjectModelElementPointer> ProjectFiles { get; }
    public MoveIntoMatchingFilesDataModel(ISolution solution, IEnumerable`1<IProjectModelElementPointer> projectFiles, ILanguageMapOfWorkflow`1<MoveIntoMatchingFilesHelperBase> languageMapOfWorkflow, MoveIntoMatchingFilesDataProvider dataProvider);
    [CompilerGeneratedAttribute]
public bool get_MoveTypes();
    [CompilerGeneratedAttribute]
public void set_MoveTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_MoveDelegates();
    [CompilerGeneratedAttribute]
public void set_MoveDelegates(bool value);
    [CompilerGeneratedAttribute]
public bool get_MoveEnums();
    [CompilerGeneratedAttribute]
public void set_MoveEnums(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuggestTypes();
    [CompilerGeneratedAttribute]
public bool get_SuggestDelegates();
    [CompilerGeneratedAttribute]
public bool get_SuggestEnums();
    [CompilerGeneratedAttribute]
public IList`1<IProjectModelElementPointer> get_ProjectFiles();
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.MoveIntoMatchingFilesHelperBase : object {
    public bool IsLanguageSupported { get; }
    public bool ShouldUpdateAllUsages { get; }
    public bool SuggestEnums { get; }
    public bool SuggestTypes { get; }
    public bool SuggestDelegates { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool get_ShouldUpdateAllUsages();
    public virtual bool get_SuggestEnums();
    public virtual bool get_SuggestTypes();
    public virtual bool get_SuggestDelegates();
    public virtual IReadOnlyList`1<IDeclaration> GetTopLevelTypeDeclarations(IFile file, Boolean& hasTopLevelCode);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual void MoveDeclarationFromFile(MovedDeclaration declaration, ResolveImagesRepository repository);
    public virtual ITreeNode GetOwnerNamespaceDeclaration(IDeclaration declaration);
    public virtual bool IsEnum(IDeclaredElement typeElement);
    public virtual bool IsDelegate(IDeclaredElement typeElement);
    public virtual bool IsType(IDeclaredElement typeElement);
    public virtual void UpdateFileReferences(MovedDeclaration declaration, ISolution solution);
    public virtual bool IsClassOrStruct(IDeclaredElement declaredElement);
    public virtual bool IsInterface(IDeclaredElement declaredElement);
    public virtual bool IsApplicable(IProjectFile file);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.MoveIntoMatchingFilesPage : SingleBeRefactoringPage {
    private MoveIntoMatchingFilesDataModel myDataModel;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public MoveIntoMatchingFilesPage(MoveIntoMatchingFilesDataModel dataModel, Lifetime lifetime);
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__2_0(bool v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__2_1(bool v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__2_2(bool v);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.MoveIntoMatchingFilesRefactoring : DrivenRefactoring`2<MoveIntoMatchingFilesWorkflow, MoveIntoMatchingFilesBase> {
    private ResolveImagesRepository myRepository;
    public MoveIntoMatchingFilesRefactoring(MoveIntoMatchingFilesWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    private void UpdateFileReferences(MovedDeclaration declaration, IProgressIndicator pi);
    private void GenerateNewFiles(MovedDeclaration declaration, IProgressIndicator pi);
    public bool IsFromExtendsList(ITreeNode element);
    public bool IsReferenceName(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.MoveIntoMatchingFilesWorkflow : DrivenRefactoringWorkflow2`1<MoveIntoMatchingFilesHelperBase> {
    private MoveIntoMatchingFilesDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private MoveIntoMatchingFilesDataModel <DataModel>k__BackingField;
    [CompilerGeneratedAttribute]
private MoveIntoMatchingFilesCollector <Collector>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public MoveIntoMatchingFilesDataModel DataModel { get; private set; }
    public MoveIntoMatchingFilesCollector Collector { get; public set; }
    public MoveIntoMatchingFilesWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator pi);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    protected virtual MoveIntoMatchingFilesHelperBase CreateUnsupportedHelper();
    protected virtual MoveIntoMatchingFilesHelperBase CreateHelper(IRefactoringLanguageService service);
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public MoveIntoMatchingFilesDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(MoveIntoMatchingFilesDataModel value);
    public bool IsValid();
    [CompilerGeneratedAttribute]
public MoveIntoMatchingFilesCollector get_Collector();
    [CompilerGeneratedAttribute]
public void set_Collector(MoveIntoMatchingFilesCollector value);
    public bool ShouldBeMoved(IDeclaredElement typeElement);
    public void SetDataProvider(MoveIntoMatchingFilesDataProvider provider);
    [CompilerGeneratedAttribute]
private IRefactoringPage <get_FirstPendingRefactoringPage>b__10_0(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private bool <IsValid>b__23_0(IProjectModelElementPointer x);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Move.MoveIntoMatchingFile.MoveIntoMatchingFilesWorkflowProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.AccessibilityConflictsSearcher : object {
    public OneToListMap`2<IDeclaredElement, IReference> UsagesNotReferenced;
    public OneToListMap`2<IDeclaredElement, IReference> UsagesNotAccessible;
    private JetHashSet`1<Pair`2<IModule, IModule>> myShouldReferenceConflicts;
    private OneToListMap`2<IProjectFile, IDeclaration> myAllDeclarations;
    private JetHashSet`1<IDeclaredElement> myElementsToSearchUsages;
    private IProject myTargetProject;
    private IProject mySourceProject;
    private JetHashSet`1<IModule> mySourceDependencies;
    private JetHashSet`1<IModule> myTargetDependencies;
    private bool myIsMoveUp;
    private bool myIsMoveDown;
    [CompilerGeneratedAttribute]
private MoveToFolderWorkflow <Workflow>k__BackingField;
    public MoveToFolderWorkflow Workflow { get; }
    public AccessibilityConflictsSearcher(MoveToFolderWorkflow workflow);
    [CompilerGeneratedAttribute]
public MoveToFolderWorkflow get_Workflow();
    public IList`1<IDeclaredElement> GetElementsToMakePublic();
    public IList`1<Conflict> GetConflicts(List`1<IDeclaredElement> choosenElementsToMakePublic);
    public void SearchConflicts(IProgressIndicator pi);
    private void ExtractDeclaredElementsToSearch(ITypeDeclaration typeDeclaration);
    private void AddMembers(ITypeElement element);
    public void ProcessElement(ITreeNode element);
    private void AddElementConflicts(IReference reference, IDeclaredElement declaredElement, bool publicsAreVisible, IModule moduleOfReference, IModule targetModule);
    private bool IsIncluded(ITreeNode declaration);
    [CompilerGeneratedAttribute]
private bool <ProcessElement>b__20_0(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.AccessRightsFixer : object {
    public static IList`1<IDeclaredElement> GetElementsToPublic(IList`1<IDeclaredElement> elementsToMakePublic, IProgressIndicator pi, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper);
}
public interface JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.IMoveToFolderDataProvider {
    public bool FixNamespaces { get; public set; }
    public bool MoveFlat { get; public set; }
    public IProjectFolder TargetFolder { get; }
    public abstract virtual bool get_FixNamespaces();
    public abstract virtual void set_FixNamespaces(bool value);
    public abstract virtual bool get_MoveFlat();
    public abstract virtual void set_MoveFlat(bool value);
    public abstract virtual IProjectFolder get_TargetFolder();
    public abstract virtual bool IsItemIncluded(MoveToFolderHierarchyItem item);
    public abstract virtual void AddConflicts(IList`1<Conflict> conflicts);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.MoveToFolderDataProvider : object {
    private IList`1<string> myExcluded;
    private List`1<string> myConflicts;
    [CompilerGeneratedAttribute]
private bool <FixNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MoveFlat>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <TargetFolder>k__BackingField;
    public bool FixNamespaces { get; public set; }
    public bool MoveFlat { get; public set; }
    public IProjectFolder TargetFolder { get; }
    public MoveToFolderDataProvider(bool fixNamespaces, bool moveFlat, IProjectFolder targetFolder, IList`1<string> excluded, List`1<string> conflicts);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FixNamespaces();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FixNamespaces(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_MoveFlat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MoveFlat(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IProjectFolder get_TargetFolder();
    public sealed virtual void AddConflicts(IList`1<Conflict> conflicts);
    public sealed virtual bool IsItemIncluded(MoveToFolderHierarchyItem item);
}
public abstract class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.MoveToFolderExecuterBase : object {
    [CompilerGeneratedAttribute]
private bool <CanContinue>k__BackingField;
    [CompilerGeneratedAttribute]
private MoveToFolderWorkflow <Workflow>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<IDeclaration> <TopLevelMovedTypeDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Conflict> <Conflicts>k__BackingField;
    public bool CanContinue { get; public set; }
    public MoveToFolderWorkflow Workflow { get; }
    public JetHashSet`1<IDeclaration> TopLevelMovedTypeDeclarations { get; private set; }
    public List`1<Conflict> Conflicts { get; }
    protected MoveToFolderExecuterBase(MoveToFolderWorkflow workflow);
    [CompilerGeneratedAttribute]
public bool get_CanContinue();
    [CompilerGeneratedAttribute]
public void set_CanContinue(bool value);
    [CompilerGeneratedAttribute]
public MoveToFolderWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
public JetHashSet`1<IDeclaration> get_TopLevelMovedTypeDeclarations();
    [CompilerGeneratedAttribute]
private void set_TopLevelMovedTypeDeclarations(JetHashSet`1<IDeclaration> value);
    [CompilerGeneratedAttribute]
public List`1<Conflict> get_Conflicts();
    public void CommitFirstPage(IProgressIndicator pi);
    private void AnalyseParts(MoveToFolderHierarchyItem rootItem);
    protected abstract virtual void CheckCanCreateFiles();
    public void AddConflict(Conflict conflict, bool canContinueRefactoring);
    public abstract virtual bool CreateAndAssignProjectFiles(IProjectFolder folder, IList`1<MoveToFolderHierarchyItem> items, IProgressIndicator pi);
    public abstract virtual bool MoveDeclarations(SubProgressIndicator pi);
    protected string GetExpectedNamespaceName(IProjectFile projectFile, IFile file);
    protected bool CopyFileAsText(IProjectFile newFile, IProjectFile oldFile);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.MoveToFolderExecuterFlat : MoveToFolderExecuterBase {
    public MoveToFolderExecuterFlat(MoveToFolderWorkflow workflow);
    protected sealed virtual void CheckCanCreateFiles();
    public virtual bool CreateAndAssignProjectFiles(IProjectFolder folder, IList`1<MoveToFolderHierarchyItem> items, IProgressIndicator pi);
    public virtual bool MoveDeclarations(SubProgressIndicator pi);
    private bool MoveDeclarationsOneByOne(IFile sourceFile, MoveToFolderHierarchyProjectItem item);
    private bool MoveWholeFile(IFile sourceFile, IProjectFile targetProjectFile, MoveToFolderHierarchyProjectItem item);
    private void CheckCanCreateFiles(IEnumerable`1<MoveToFolderHierarchyItem> allItems, IProjectFolder folder);
    private void CheckFileExist(IProjectFolder folder, JetHashSet`1<string> assignedNames, string fileName);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.MoveToFolderExecuterHierarchical : MoveToFolderExecuterBase {
    public MoveToFolderExecuterHierarchical(MoveToFolderWorkflow workflow);
    protected virtual void CheckCanCreateFiles();
    public virtual bool CreateAndAssignProjectFiles(IProjectFolder folder, IList`1<MoveToFolderHierarchyItem> items, IProgressIndicator pi);
    private void AddChildrenToFileElementCorrespondence(MoveToFolderHierarchyProjectItem item, IPsiServices psiServices);
    public virtual bool MoveDeclarations(SubProgressIndicator pi);
    private bool MoveDeclarationsFromFileToFile(MoveToFolderHierarchyProjectItem item, IProjectFile file, IProjectFile targetFile, bool allChildrenAreMoved, IList`1<MoveToFolderHierarchyDeclarationItem> includedDeclarationItems, IFile fileCopy);
    private bool MoveFewDeclarations(IFile sourceFile, IList`1<MoveToFolderHierarchyDeclarationItem> children, IProjectFile targetFile, PsiLanguageType language);
    private bool MoveWholeFile(MoveToFolderHierarchyProjectItem item, IFile psiFile, IProjectFile targetFile, PsiLanguageType language);
    private void CheckCanCreateFiles(IList`1<MoveToFolderHierarchyItem> items, IProjectFolder folder);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.MoveToFolderHierarchyDeclarationItem : MoveToFolderHierarchyItem {
    private MoveToFolderHierarchyProjectItem myParent;
    [CompilerGeneratedAttribute]
private string <OwnerNamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<IDeclaration> <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IDeclaration> <NotIncludedDeclarations>k__BackingField;
    [NotNullAttribute]
public string OwnerNamespaceName { get; }
    [NotNullAttribute]
public ITreeNodePointer`1<IDeclaration> Pointer { get; }
    public List`1<IDeclaration> NotIncludedDeclarations { get; public set; }
    public bool IsValid { get; }
    public MoveToFolderHierarchyDeclarationItem(IDeclaration typeDeclaration, bool canMoveAlone, bool initiallyIncluded, MoveToFolderHierarchyProjectItem parent, string ownerNamespaceName);
    [CompilerGeneratedAttribute]
public string get_OwnerNamespaceName();
    [CompilerGeneratedAttribute]
public ITreeNodePointer`1<IDeclaration> get_Pointer();
    [CompilerGeneratedAttribute]
public List`1<IDeclaration> get_NotIncludedDeclarations();
    [CompilerGeneratedAttribute]
public void set_NotIncludedDeclarations(List`1<IDeclaration> value);
    public virtual bool get_IsValid();
    public virtual void CommitDeclarations(MoveToFolderDataModel dataModel);
    public virtual void CommitReferences(MoveToFolderDataModel dataModel);
    public virtual bool ContaintElement(ITreeNode element, IProjectFile file);
    public virtual string GetCanMoveToProjectFolderError(IProjectFolder projectFolder, MoveToFolderWorkflow workflow);
}
public abstract class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.MoveToFolderHierarchyItem : object {
    [CompilerGeneratedAttribute]
private string <NewProjectFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <PrototypeFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <CreatedProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocument <CreatedDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Included>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MoveToFolderHierarchyItem> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanMoveAlone>k__BackingField;
    [CanBeNullAttribute]
public string NewProjectFileName { get; private set; }
    [CanBeNullAttribute]
public IProjectFile PrototypeFile { get; private set; }
    public IProjectFile CreatedProjectFile { get; private set; }
    public IDocument CreatedDocument { get; private set; }
    public bool Included { get; public set; }
    public IList`1<MoveToFolderHierarchyItem> Children { get; }
    public bool HasIncludedItems { get; }
    public bool CanMoveAlone { get; protected set; }
    public bool IsValid { get; }
    [CompilerGeneratedAttribute]
public string get_NewProjectFileName();
    [CompilerGeneratedAttribute]
private void set_NewProjectFileName(string value);
    [CompilerGeneratedAttribute]
public IProjectFile get_PrototypeFile();
    [CompilerGeneratedAttribute]
private void set_PrototypeFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public IProjectFile get_CreatedProjectFile();
    [CompilerGeneratedAttribute]
private void set_CreatedProjectFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public IDocument get_CreatedDocument();
    [CompilerGeneratedAttribute]
private void set_CreatedDocument(IDocument value);
    [CompilerGeneratedAttribute]
public bool get_Included();
    [CompilerGeneratedAttribute]
public void set_Included(bool value);
    [CompilerGeneratedAttribute]
public IList`1<MoveToFolderHierarchyItem> get_Children();
    public bool get_HasIncludedItems();
    [CompilerGeneratedAttribute]
public bool get_CanMoveAlone();
    [CompilerGeneratedAttribute]
protected void set_CanMoveAlone(bool value);
    public abstract virtual bool get_IsValid();
    public void SetProjectFile(IProjectFile projectFile);
    public static MoveToFolderHierarchyItem BuildFromProjectItem(IProjectItem projectItem, MoveToFolderDataModel dataModel, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper, MoveToFolderHierarchyProjectItem parent);
    private static IEnumerable`1<MoveToFolderHierarchyItem> BuildTopLevelClassDeclarations(IProjectFile projectFile, MoveToFolderDataModel dataModel, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper, MoveToFolderHierarchyProjectItem parent);
    private static bool GetCanMoveAlone(IDeclaration declaration, IReadOnlyList`1<IDeclaration> allDeclarations, bool withDependentFiles, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper);
    public abstract virtual void CommitDeclarations(MoveToFolderDataModel dataModel);
    public abstract virtual void CommitReferences(MoveToFolderDataModel dataModel);
    public abstract virtual bool ContaintElement(ITreeNode element, IProjectFile file);
    public void SetProjectFileName(string newProjectFileName, IProjectFile prototypeFile);
    public void ResetNewProjectName();
    public virtual string GetCanMoveToProjectFolderError(IProjectFolder projectFolder, MoveToFolderWorkflow workflow);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Impl.MoveToFolderHierarchyProjectItem : MoveToFolderHierarchyItem {
    [CompilerGeneratedAttribute]
private IFile <Copy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveThisFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MoveThisFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectItem <ProjectItem>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LanguageIsNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuggestChangeVisibility>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IProjectFile, IFile> <DependentFilesWithCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IProjectFile, IProjectFile> <CreatedDependentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <OldLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <TargetFolder>k__BackingField;
    public IFile Copy { get; private set; }
    public bool RemoveThisFile { get; public set; }
    public bool MoveThisFile { get; public set; }
    public IProjectItem ProjectItem { get; }
    public bool LanguageIsNotSupported { get; public set; }
    public bool SuggestChangeVisibility { get; public set; }
    public Dictionary`2<IProjectFile, IFile> DependentFilesWithCopy { get; public set; }
    public Dictionary`2<IProjectFile, IProjectFile> CreatedDependentFiles { get; }
    public bool AllChildrenAreRemoved { get; }
    public bool IsProjectFile { get; }
    public bool AllChildrenAreMoved { get; }
    public bool HasConflictedNotIncludedItems { get; }
    public bool IsValid { get; }
    public VirtualFileSystemPath OldLocation { get; }
    public IProjectFolder TargetFolder { get; public set; }
    public MoveToFolderHierarchyProjectItem(IProjectItem projectItem);
    [CompilerGeneratedAttribute]
public IFile get_Copy();
    [CompilerGeneratedAttribute]
private void set_Copy(IFile value);
    [CompilerGeneratedAttribute]
public bool get_RemoveThisFile();
    [CompilerGeneratedAttribute]
public void set_RemoveThisFile(bool value);
    [CompilerGeneratedAttribute]
public bool get_MoveThisFile();
    [CompilerGeneratedAttribute]
public void set_MoveThisFile(bool value);
    [CompilerGeneratedAttribute]
public IProjectItem get_ProjectItem();
    [CompilerGeneratedAttribute]
public bool get_LanguageIsNotSupported();
    [CompilerGeneratedAttribute]
public void set_LanguageIsNotSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuggestChangeVisibility();
    [CompilerGeneratedAttribute]
public void set_SuggestChangeVisibility(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IProjectFile, IFile> get_DependentFilesWithCopy();
    [CompilerGeneratedAttribute]
public void set_DependentFilesWithCopy(Dictionary`2<IProjectFile, IFile> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IProjectFile, IProjectFile> get_CreatedDependentFiles();
    public bool get_AllChildrenAreRemoved();
    public bool get_IsProjectFile();
    public bool get_AllChildrenAreMoved();
    public bool get_HasConflictedNotIncludedItems();
    public virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_OldLocation();
    [CompilerGeneratedAttribute]
public IProjectFolder get_TargetFolder();
    [CompilerGeneratedAttribute]
public void set_TargetFolder(IProjectFolder value);
    public virtual void CommitDeclarations(MoveToFolderDataModel dataModel);
    public virtual void CommitReferences(MoveToFolderDataModel dataModel);
    public virtual bool ContaintElement(ITreeNode element, IProjectFile file);
    public virtual string GetCanMoveToProjectFolderError(IProjectFolder projectFolder, MoveToFolderWorkflow workflow);
    public void SetDependentProjectFile(IProjectFile oldFile, IProjectFile newFile);
    public void LoadCopy();
    private IFile CreateCopy(IProjectItem projectItem);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderBase : RefactoringExecBase`2<MoveToFolderWorkflow, MoveToFolderRefactoring> {
    public MoveToFolderBase(MoveToFolderWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderDataModel : object {
    [CompilerGeneratedAttribute]
private bool <FixAccessibility>k__BackingField;
    private TreeSimpleModel myTreeModel;
    private ISolution mySolution;
    private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private bool <HasError>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <FolderInUi>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <DefaultSourceFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyHierarchy>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IDeclaredElement> <ChoosenElementsToMakePublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FromDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDeclaration> <PreselectedDeclarations>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessibilityConflictsSearcher <AccessibilityConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SearchInRelatedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <TargetFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MoveToSameProject>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectLanguage <SourceLanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MoveToFolderHierarchyItem> <RootHierarchyItems>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveImagesRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ITreeNode> <UsingsToRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Pair`2<IPathDeclaredElement, IPathDeclaredElement>> <FileElementCorrespondence>k__BackingField;
    public bool FixAccessibility { get; public set; }
    public bool HasError { get; }
    public IProjectFolder FolderInUi { get; public set; }
    public IProjectFolder DefaultSourceFolder { get; }
    public bool CopyHierarchy { get; public set; }
    public List`1<IDeclaredElement> ChoosenElementsToMakePublic { get; public set; }
    public bool FromDeclaration { get; }
    [CanBeNullAttribute]
public IList`1<IDeclaration> PreselectedDeclarations { get; }
    public AccessibilityConflictsSearcher AccessibilityConflicts { get; public set; }
    public bool FixNamespaces { get; public set; }
    public bool SearchInRelatedFiles { get; public set; }
    public IProjectFolder TargetFolder { get; public set; }
    public bool MoveToSameProject { get; public set; }
    public ProjectLanguage SourceLanguageType { get; }
    public List`1<MoveToFolderHierarchyItem> RootHierarchyItems { get; }
    public ResolveImagesRepository Repository { get; }
    public IList`1<ITreeNode> UsingsToRemove { get; private set; }
    public List`1<Pair`2<IPathDeclaredElement, IPathDeclaredElement>> FileElementCorrespondence { get; }
    public MoveToFolderDataModel(IProjectModelElement[] projectModelElements, IList`1<IDeclaration> declarations, ResolveImagesRepository repository, MoveToFolderWorkflow workflow);
    [CompilerGeneratedAttribute]
public bool get_FixAccessibility();
    [CompilerGeneratedAttribute]
public void set_FixAccessibility(bool value);
    public bool GetSupportedProperty(IProjectFile projectFile, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper);
    public bool GetChangeVisibilityProperty(IProjectFile projectFile, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper);
    public IReadOnlyList`1<IDeclaration> GetTopLevelTypeDeclarations(IProjectFile projectFile, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper);
    public void CollectEntities(IProgressIndicator pi, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper);
    private void SearchUsagesOfTopmostElements(SubProgressIndicator pi, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper);
    private void AddMoreUsingsToRemove(MoveToFolderHierarchyItem x, ILanguageMapOfWorkflow`1<MoveToFolderHelperBase> helper);
    private bool IsInMoveScope(ITreeNode element);
    private IReadOnlyList`1<IDeclaration> GetTopLevelDeclarations(IFile file, MoveToFolderHelperBase helper);
    public void MakeActionWithPsi(IPsiSourceFile sourceFile, Action`2<IFile, PsiLanguageType> action);
    [CompilerGeneratedAttribute]
public bool get_HasError();
    [CompilerGeneratedAttribute]
public IProjectFolder get_FolderInUi();
    [CompilerGeneratedAttribute]
public void set_FolderInUi(IProjectFolder value);
    [CompilerGeneratedAttribute]
public IProjectFolder get_DefaultSourceFolder();
    [CompilerGeneratedAttribute]
public bool get_CopyHierarchy();
    [CompilerGeneratedAttribute]
public void set_CopyHierarchy(bool value);
    [CompilerGeneratedAttribute]
public List`1<IDeclaredElement> get_ChoosenElementsToMakePublic();
    [CompilerGeneratedAttribute]
public void set_ChoosenElementsToMakePublic(List`1<IDeclaredElement> value);
    [CompilerGeneratedAttribute]
public bool get_FromDeclaration();
    [CompilerGeneratedAttribute]
public IList`1<IDeclaration> get_PreselectedDeclarations();
    [CompilerGeneratedAttribute]
public AccessibilityConflictsSearcher get_AccessibilityConflicts();
    [CompilerGeneratedAttribute]
public void set_AccessibilityConflicts(AccessibilityConflictsSearcher value);
    [CompilerGeneratedAttribute]
public bool get_FixNamespaces();
    [CompilerGeneratedAttribute]
public void set_FixNamespaces(bool value);
    [CompilerGeneratedAttribute]
public bool get_SearchInRelatedFiles();
    [CompilerGeneratedAttribute]
public void set_SearchInRelatedFiles(bool value);
    [CompilerGeneratedAttribute]
public IProjectFolder get_TargetFolder();
    [CompilerGeneratedAttribute]
public void set_TargetFolder(IProjectFolder value);
    [CompilerGeneratedAttribute]
public bool get_MoveToSameProject();
    [CompilerGeneratedAttribute]
public void set_MoveToSameProject(bool value);
    [CompilerGeneratedAttribute]
public ProjectLanguage get_SourceLanguageType();
    [CompilerGeneratedAttribute]
public List`1<MoveToFolderHierarchyItem> get_RootHierarchyItems();
    [CompilerGeneratedAttribute]
public ResolveImagesRepository get_Repository();
    [CompilerGeneratedAttribute]
public IList`1<ITreeNode> get_UsingsToRemove();
    [CompilerGeneratedAttribute]
private void set_UsingsToRemove(IList`1<ITreeNode> value);
    [CompilerGeneratedAttribute]
public List`1<Pair`2<IPathDeclaredElement, IPathDeclaredElement>> get_FileElementCorrespondence();
    public TreeModel CreateTreeModel();
    private static void AddChildren(MoveToFolderHierarchyItem item, TreeSimpleModel model);
}
[SolutionFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderDragDropExecutor : object {
    private static string myPresentableName;
    private static Dictionary`2<string, object> ourDefaultParameters;
    private ISolution mySolution;
    public string PresentableName { get; }
    public Dictionary`2<string, object> Parameters { get; }
    private static MoveToFolderDragDropExecutor();
    public MoveToFolderDragDropExecutor(ISolution solution);
    public sealed virtual string get_PresentableName();
    public sealed virtual Dictionary`2<string, object> get_Parameters();
    public sealed virtual void Execute(object droppedItem, object dropDestination, Dictionary`2<string, object> parameters);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderHelperBase : object {
    public bool IsLanguageSupported { get; }
    public bool CanMoveSingleTypeDeclaration { get; }
    public bool CanMoveFiles { get; }
    public bool SuggestFixNamespaces { get; }
    public bool SuggestPreserveHierarchy { get; }
    public bool SuggestChangeVisibility { get; }
    public bool SearchInRelatedFiles { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool get_CanMoveSingleTypeDeclaration();
    public virtual bool get_CanMoveFiles();
    public virtual IReadOnlyList`1<IDeclaration> GetTopLevelTypeDeclarations(IFile file);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual void FillItemsFromCache(object context, List`1<IDeclaredElement> elementsToSearch, IPsiServices psiServices);
    public virtual bool get_SuggestFixNamespaces();
    public virtual bool get_SuggestPreserveHierarchy();
    public virtual bool get_SuggestChangeVisibility();
    public virtual bool get_SearchInRelatedFiles();
    public virtual bool MoveWholeFile(MoveToFolderHierarchyProjectItem item, IFile sourceFile, IFile targetFile, bool fixNamespaces, string name, ResolveImagesRepository repository, bool searchInRelatedFiles);
    public virtual bool MoveFewDeclarations(IFile sourceFile, IFile targetFile, bool fixNamespaces, string name, ResolveImagesRepository repository, IList`1<IDeclaration> children, bool searchInRelatedFiles);
    public virtual bool MoveSingleDeclaration(IDeclaration typeDeclaration, IFile targetFile, string expectedNamespaceName, ResolveImagesRepository repository, bool searchInRelatedFiles);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void MakePublic(IDeclaration declaration);
    public virtual string GetCanMoveToProjectFolderError(IProjectFolder projectFolder);
    public virtual bool DeclarationCanProvideName(IDeclaration declaration);
    public virtual IDeclaredElement CheckTypeElement(IDeclaredElement declaredElement);
    public virtual string GetContainingNamespaceQualifiedName(IDeclaredElement declaredElement);
    public virtual void GetElementToPublicDeps(IDeclaredElement declaredElement, Queue`1<IDeclaredElement> queue, JetHashSet`1<IDeclaredElement> processedElements);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderHelperBase/<GetDependentElements>d__32")]
private static IEnumerable`1<IDeclaredElement> GetDependentElements(IClrDeclaredElement declaredElement);
    private static IEnumerable`1<IDeclaredElement> AddFromType(IType type);
    public virtual bool IsNonPublic(IDeclaredElement declaredElement);
    public virtual void AddMoreUsagesToRemove(IList`1<ITreeNode> usingsToRemove, IFile primaryPsiFile, bool fileMovedOrRemoved, VirtualFileSystemPath oldLocation);
    public virtual void PostProcessFile(IFile file, bool fileMovedOrRemoved, List`1<VirtualFileSystemPath> movedPaths, bool searchInRelatedFiles, VirtualFileSystemPath oldLocation);
    public virtual BeControl GetAdditionalContent(Lifetime lifetime, MoveToFolderDataModel workflowDataModel);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderRefactoring : DrivenRefactoring`2<MoveToFolderWorkflow, MoveToFolderBase> {
    public MoveToFolderRefactoring(MoveToFolderWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    private void CollectMovedFiles(MoveToFolderHierarchyItem x, List`1<VirtualFileSystemPath> paths, bool allChildrenAreRemovedForParent);
    private void PostProcessMove(MoveToFolderHierarchyItem x, List`1<VirtualFileSystemPath> movedPaths, bool allChildrenAreRemovedForParent);
    public virtual bool Execute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderWorkflow : DrivenRefactoringWorkflow2`1<MoveToFolderHelperBase> {
    private IMoveToFolderDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private MoveToFolderExecuterBase <Executer>k__BackingField;
    [CompilerGeneratedAttribute]
private MoveToFolderDataModel <DataModel>k__BackingField;
    public MoveToFolderExecuterBase Executer { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public IConflictSearcher ConflictSearcher { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public MoveToFolderDataModel DataModel { get; private set; }
    public MoveToFolderWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public MoveToFolderExecuterBase get_Executer();
    [CompilerGeneratedAttribute]
private void set_Executer(MoveToFolderExecuterBase value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IConflictSearcher get_ConflictSearcher();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public MoveToFolderDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(MoveToFolderDataModel value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    private static bool MoveMakesSense(IEnumerable`1<IProject> projects);
    private IList`1<IDeclaration> GetDeclarationsFromContext(IDataContext context);
    [CanBeNullAttribute]
private static IDeclaration ToDeclarationInSharedProject(IDeclaration declaration);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    private void RemoveItems(IEnumerable`1<MoveToFolderHierarchyProjectItem> items);
    protected virtual MoveToFolderHelperBase CreateUnsupportedHelper();
    protected virtual MoveToFolderHelperBase CreateHelper(IRefactoringLanguageService service);
    public void MakeActionWithPsi(IPsiSourceFile sourceFile, Action`2<IFile, PsiLanguageType> action);
    public bool HasSupportedPsi(IProjectFile projectFile);
    public IEnumerable`1<MoveToFolderHierarchyItem> AllHierarchyItems();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderWorkflow/<AllHierarchyItemChilden>d__36")]
private static IEnumerable`1<MoveToFolderHierarchyItem> AllHierarchyItemChilden(MoveToFolderHierarchyItem item);
    public virtual bool PreExecute(IProgressIndicator pi);
    public bool DoMove(IProgressIndicator pi);
    private void RemoveUsingsOfEmptyNamespaces(IProgressIndicator pi);
    private void DoMoveFiles(IEnumerable`1<MoveToFolderHierarchyItem> moveToFolderHierarchyItems);
    public IRefactoringPage CommitFirstPage(bool fixNamespaces, IProgressIndicator pi, bool copyHierarchy, string folderName, bool fixAccessibility);
    private void CommitCheckStatesFromDataProvider();
    private IRefactoringPage CommitFirstConflictsPage(IProgressIndicator pi);
    public IEnumerable`1<IDeclaration> GetAllMovedDeclarations();
    public IEnumerable`1<MoveToFolderHierarchyProjectItem> GetAllMovedFiles();
    public void SetDataProvider(IMoveToFolderDataProvider provider);
    public bool IsValid();
    [CompilerGeneratedAttribute]
private IResolveImagesLanguageSupport <Initialize>b__23_0(PsiLanguageType x);
    [CompilerGeneratedAttribute]
private bool <GetDeclarationsFromContext>b__26_0(IDeclaration x);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderWorkflowProvider : MoveWorkflowProvider {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Move.MoveToFolder.MoveToFolderWorkflowProvider/<CreateWorkflow>d__0")]
public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Pages.FixAccessRightsPage : SingleBeRefactoringPage {
    private MoveToFolderDataModel myDataModel;
    private List`1<DeclaredElementNode> myIncludedInternalElements;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public FixAccessRightsPage(MoveToFolderDataModel dataModel, List`1<DeclaredElementNode> includedInternalElements, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    public virtual void Commit();
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Pages.MoveToFolderPage : SingleBeRefactoringPage {
    private MoveToFolderWorkflow myWorkflow;
    private string myFolderPath;
    private bool myPreserveHierarchy;
    private bool myFixNamespaces;
    private bool myChangeVisibility;
    private IProperty`1<string> myError;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; }
    public string Title { get; protected set; }
    public MoveToFolderPage(MoveToFolderWorkflow workflow);
    public virtual string get_Description();
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    private void RevalidateTree();
    private BeGrid GetPathSelector();
    private ValueTuple`3<string, IconModel, ValidationStates> AdditionalFolderNameValidation(string newText);
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__13_0(IDeclaration d);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__13_8(bool s);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__13_2(IDeclaration d);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__13_9(bool s);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__13_3(IDeclaration d);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__13_10(bool s);
    [CompilerGeneratedAttribute]
private List`1<BeControl> <GetPageContent>b__13_5(Lifetime lt, MoveToFolderHierarchyItem e, CheckBoxTreeNodeProperties listProp, TreeNodeProperties treeProp);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__13_12(PropertyChangedEventArgs`1<RichText> v);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__13_7(IDeclaration d);
    [CompilerGeneratedAttribute]
private void <RevalidateTree>b__14_1();
    [CompilerGeneratedAttribute]
private void <RevalidateTree>b__14_2();
    [CompilerGeneratedAttribute]
private bool <RevalidateTree>b__14_4(MoveToFolderHierarchyItem x);
    [CompilerGeneratedAttribute]
private void <GetPathSelector>b__15_0(string s);
    [CompilerGeneratedAttribute]
private ValueTuple`3<string, IconModel, ValidationStates> <GetPathSelector>b__15_1(string v);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.Pages.MoveToFolderPresenter : TreeModelBrowserPresenter {
    [CompilerGeneratedAttribute]
private MoveToFolderWorkflow <Workflow>k__BackingField;
    public MoveToFolderWorkflow Workflow { get; }
    public MoveToFolderPresenter(MoveToFolderWorkflow workflow);
    [CompilerGeneratedAttribute]
public MoveToFolderWorkflow get_Workflow();
    protected virtual void PresentObject(object value, IPresentableItem item, TreeModelNode modelNode, PresentationState state);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToFolder.SimpleHostWithProgress : SimpleWorkflowHost {
    public virtual ITaskExecutor CreateTaskExecutor(string taskName);
}
public interface JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.IMoveToNamespaceDataProvider {
    public string NewNamespace { get; }
    public abstract virtual string get_NewNamespace();
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespaceBase : RefactoringExecBase`2<MoveToNamespaceWorkflow, MoveToNamespaceRefactoring> {
    public MoveToNamespaceBase(MoveToNamespaceWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespaceDataModel : object {
    private IDeclaredElement myTypeElement;
    private IDeclaredElementPointer`1<IDeclaredElement> myTypeElementPointer;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaseSensitiveName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrNameWithoutNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InitialNamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetNamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowsEmpty>k__BackingField;
    public Lifetime Lifetime { get; }
    public bool CaseSensitiveName { get; }
    public string ClrNameWithoutNamespace { get; }
    [CanBeNullAttribute]
public IDeclaredElement TypeElement { get; }
    public string InitialNamespaceName { get; public set; }
    public string TargetNamespaceName { get; public set; }
    public string NamespaceString { get; }
    public bool AllowsEmpty { get; public set; }
    public MoveToNamespaceDataModel(IDeclaredElement typeElement, string containingNamespaceQualifiedName, string fullNameWithoutNamespace, string namespaceString, IMoveToNamespaceDataProvider dataProvider, Lifetime lifetime, bool allowsEmpty);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public bool get_CaseSensitiveName();
    [CompilerGeneratedAttribute]
public string get_ClrNameWithoutNamespace();
    public IDeclaredElement get_TypeElement();
    [CompilerGeneratedAttribute]
public string get_InitialNamespaceName();
    [CompilerGeneratedAttribute]
public void set_InitialNamespaceName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetNamespaceName();
    [CompilerGeneratedAttribute]
public void set_TargetNamespaceName(string value);
    [CompilerGeneratedAttribute]
public string get_NamespaceString();
    [CompilerGeneratedAttribute]
public bool get_AllowsEmpty();
    [CompilerGeneratedAttribute]
public void set_AllowsEmpty(bool value);
    public string Validate(string s);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespaceDataProvider : object {
    [CompilerGeneratedAttribute]
private string <NewNamespace>k__BackingField;
    public string NewNamespace { get; }
    public MoveToNamespaceDataProvider(string newNamespace);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NewNamespace();
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespaceHelperBase : object {
    public bool IsLanguageSupported { get; }
    public bool AllowEmptyNamespace { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool ShouldDisallowByContainingType(IDeclaredElement typeElement);
    public virtual IDeclaredElement GetContainingType(IDeclaredElement typeElement);
    public virtual bool IsTypeElement(IDeclaredElement element);
    public virtual bool IsTypeParameter(IDeclaredElement element);
    public virtual string LanguageSpecificNamespaceName();
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual void FillItemsFromCache(object context, List`1<IDeclaredElement> elementsToSearch, IPsiServices psiServices);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void MovePrimaryDeclaration(IDeclaration typeDeclaration, string newNamespaceName, ResolveImagesRepository repository, IRefactoringDriver driver);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual void RegisterSecondaryDeclaration(IDeclaration typeDeclaration, string targetNamespaceName, ResolveImagesRepository repository);
    public virtual string ValidateNamespaceName(string newNamespace, IDeclaration declaration);
    public virtual string GetContainingNamespaceQualifiedName(IDeclaredElement typeElement);
    public virtual string GetFullNameWithoutNamespace(IDeclaredElement typeElement);
    public virtual bool get_AllowEmptyNamespace();
    public virtual bool CheckTypeExists(string ns, PsiLanguageType language, IPsiServices psiServices, ISolution solution, bool isCaseSensitive, object context, string shortName);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespacePage : SingleBeRefactoringPage {
    public static string TargetName;
    private MoveToNamespaceDataModel myDataModel;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public MoveToNamespacePage(Lifetime lifetime, MoveToNamespaceDataModel dataModel);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual bool RefreshContents(IProgressIndicator pi);
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__12_0(string v);
    [CompilerGeneratedAttribute]
private string <GetPageContent>b__12_1(string s);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespaceProvider : MoveWorkflowProvider {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespaceProvider/<CreateWorkflow>d__0")]
public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespaceRefactoring : DrivenRefactoring`2<MoveToNamespaceWorkflow, MoveToNamespaceBase> {
    private IList`1<ITreeNode> myUsingsToRemove;
    [CompilerGeneratedAttribute]
private ResolveImagesRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <TypeElement>k__BackingField;
    public ResolveImagesRepository Repository { get; }
    public IDeclaredElement TypeElement { get; private set; }
    public MoveToNamespaceRefactoring(MoveToNamespaceWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public ResolveImagesRepository get_Repository();
    [CompilerGeneratedAttribute]
public IDeclaredElement get_TypeElement();
    [CompilerGeneratedAttribute]
private void set_TypeElement(IDeclaredElement value);
    public virtual bool Execute(IProgressIndicator pi);
    private void RemoveUsingsOfEmptyNamespaces(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private IResolveImagesLanguageSupport <.ctor>b__8_0(PsiLanguageType x);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveToNamespace.MoveToNamespaceWorkflow : DrivenRefactoringWorkflow2`1<MoveToNamespaceHelperBase> {
    private IMoveToNamespaceDataProvider myDataProvider;
    private string myLanguageSpecificNamespaceName;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private MoveToNamespaceDataModel <DataModel>k__BackingField;
    public PsiLanguageType LanguageType { get; public set; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public MoveToNamespaceDataModel DataModel { get; private set; }
    public MoveToNamespaceWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
public void set_LanguageType(PsiLanguageType value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public MoveToNamespaceDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(MoveToNamespaceDataModel value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool Initialize(IDataContext context);
    public RichText GetErrorMessageText(string newNamespace);
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailableEx(IDataContext context, IDeclaredElement& typeElement);
    protected virtual MoveToNamespaceHelperBase CreateUnsupportedHelper();
    protected virtual MoveToNamespaceHelperBase CreateHelper(IRefactoringLanguageService service);
    public void SetDataProvider(IMoveToNamespaceDataProvider dataProvider);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private IDeclaredElement <IsAvailableEx>b__25_0(ICollection`1<IDeclaredElement> _);
    [CompilerGeneratedAttribute]
private bool <IsAvailableEx>b__25_2(IDeclaredElement el);
    [CompilerGeneratedAttribute]
private bool <IsAvailableEx>b__25_1(IDeclaration x);
}
public interface JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.IMoveToFileDataProvider {
    public IDeclaration TypeDeclaration { get; }
    public string FileName { get; }
    public bool RemoveOldFile { get; }
    public abstract virtual IDeclaration get_TypeDeclaration();
    public abstract virtual string get_FileName();
    public abstract virtual bool get_RemoveOldFile();
}
public interface JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.IMoveToFileWorkflow {
    public string NewFileExtension { get; }
    public string NewFileName { get; }
    public VirtualFileSystemPath FolderLocation { get; }
    [CanBeNullAttribute]
public IProjectModelElementPointer ProjectFolderPointer { get; }
    public VirtualFileSystemPath FileLocation { get; }
    public abstract virtual string get_NewFileExtension();
    public abstract virtual string get_NewFileName();
    public abstract virtual VirtualFileSystemPath get_FolderLocation();
    public abstract virtual IProjectModelElementPointer get_ProjectFolderPointer();
    public abstract virtual VirtualFileSystemPath get_FileLocation();
    public abstract virtual IRefactoringPage CommitFirstPage(string newFileName, IProgressIndicator pi);
    public abstract virtual bool IsValid();
}
public class JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFileBase : RefactoringExecBase`2<MoveToFileWorkflow, MoveToFileRefactoring> {
    public MoveToFileBase(MoveToFileWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFileDataModel : object {
    [CompilerGeneratedAttribute]
private bool <CanRemoveFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <FileLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <FolderLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFileExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<IDeclaration> <DeclarationPointer>k__BackingField;
    private IProjectModelElementPointer myProjectFilePointer;
    protected IProjectModelElementPointer myProjectFolderPointer;
    private ISolution mySolution;
    [CompilerGeneratedAttribute]
private IProjectFile <NewProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaration <NewDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveOldFile>k__BackingField;
    public bool CanRemoveFiles { get; }
    public bool NonInteractive { get; protected set; }
    public VirtualFileSystemPath FileLocation { get; public set; }
    public VirtualFileSystemPath FolderLocation { get; public set; }
    public string NewFileExtension { get; public set; }
    public ITreeNodePointer`1<IDeclaration> DeclarationPointer { get; }
    public IProjectModelElement ProjectFile { get; }
    public IProjectModelElement ProjectFolder { get; }
    public IProjectFile NewProjectFile { get; public set; }
    public IDeclaration NewDeclaration { get; public set; }
    public bool CanRename { get; public set; }
    public string NewFileName { get; public set; }
    public bool RemoveOldFile { get; public set; }
    public MoveToFileDataModel(IDeclaration declaration, string name, bool canRemoveFiles, IMoveToFileDataProvider provider);
    public MoveToFileDataModel(IMoveToFileDataProvider provider);
    [CompilerGeneratedAttribute]
public bool get_CanRemoveFiles();
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
protected void set_NonInteractive(bool value);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_FileLocation();
    [CompilerGeneratedAttribute]
public void set_FileLocation(VirtualFileSystemPath value);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_FolderLocation();
    [CompilerGeneratedAttribute]
public void set_FolderLocation(VirtualFileSystemPath value);
    [CompilerGeneratedAttribute]
public string get_NewFileExtension();
    [CompilerGeneratedAttribute]
public void set_NewFileExtension(string value);
    [CompilerGeneratedAttribute]
public ITreeNodePointer`1<IDeclaration> get_DeclarationPointer();
    public IProjectModelElement get_ProjectFile();
    public IProjectModelElement get_ProjectFolder();
    [CompilerGeneratedAttribute]
public IProjectFile get_NewProjectFile();
    [CompilerGeneratedAttribute]
public void set_NewProjectFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public IDeclaration get_NewDeclaration();
    [CompilerGeneratedAttribute]
public void set_NewDeclaration(IDeclaration value);
    [CompilerGeneratedAttribute]
public bool get_CanRename();
    [CompilerGeneratedAttribute]
public void set_CanRename(bool value);
    [CompilerGeneratedAttribute]
public string get_NewFileName();
    [CompilerGeneratedAttribute]
public void set_NewFileName(string value);
    [CompilerGeneratedAttribute]
public bool get_RemoveOldFile();
    [CompilerGeneratedAttribute]
public void set_RemoveOldFile(bool value);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFileHelperBase : object {
    public bool IsLanguageSupported { get; }
    public bool ShouldUpdateAllUsages { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool FileHasOtherDeclarations(IDeclaration declaration);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual bool MoveDeclaration(IDeclaration declaration, ResolveImagesRepository repository, IFile file, MoveToFileWorkflow workflow, IRefactoringDriver driver);
    public virtual bool AcceptTypeElement(IDeclaredElement typeElement);
    public virtual IDeclaration GetTypeDeclaration(IDataContext context);
    public virtual bool get_ShouldUpdateAllUsages();
    [NotNullAttribute]
public virtual string GetDefaultFileName(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFilePage : SingleBeRefactoringPage {
    public static string MoveToFileText;
    public static string MoveToFileRemove;
    private MoveToFileDataModel myDataModel;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public MoveToFilePage(MoveToFileDataModel dataModel, Lifetime lifetime);
    public virtual bool RefreshContents(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__13_0(string v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__13_1(bool v);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFileRefactoring : DrivenRefactoring`2<MoveToFileWorkflow, MoveToFileBase> {
    public MoveToFileRefactoring(MoveToFileWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFileUtils : object {
    public static bool CheckExtension(string name, string newFileExtension);
    public static bool CheckValidName(string name);
    [ExtensionAttribute]
public static bool CheckFileExistOnDisk(IMoveToFileWorkflow moveToFileWorkflow, string name);
    [ExtensionAttribute]
public static bool CheckSameFile(IMoveToFileWorkflow moveToFileWorkflow, string name);
}
public class JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFileWorkflow : DrivenRefactoringWorkflow2`1<MoveToFileHelperBase> {
    private IMainWindowPopupWindowContext myMainWindowPopupWindowContext;
    private IMoveToFileDataProvider myProvider;
    [CompilerGeneratedAttribute]
private MoveToFileDataModel <DataModel>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public MoveToFileDataModel DataModel { get; private set; }
    public MoveToFileWorkflow(ISolution solution, string actionId, IMainWindowPopupWindowContext mainWindowPopupWindowContext);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailableInternal(IDataContext context, IDeclaration& declaration);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    protected virtual MoveToFileHelperBase CreateUnsupportedHelper();
    protected virtual MoveToFileHelperBase CreateHelper(IRefactoringLanguageService service);
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public MoveToFileDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(MoveToFileDataModel value);
    public virtual bool PreExecute(IProgressIndicator pi);
    private bool CanRenameFile();
    public bool IsValid();
    public void SetDataProvider(IMoveToFileDataProvider provider);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFileWorkflowProvider : MoveWorkflowProvider {
    public MoveToFileWorkflowProvider(Lifetime lifetime, IShellLocks locks, IWindowsHookManager windowsHookManager);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Move.MoveTypeDeclarationToFile.MoveToFileWorkflowProvider/<CreateWorkflow>d__1")]
public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "MoveActionText")]
public class JetBrains.ReSharper.Refactorings.MoveAction : ExtensibleRefactoringAction`1<MoveWorkflowProvider> {
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
internal class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.A : object {
    private void bbbb();
    private void bbbb2();
    private void bbbb4();
}
internal class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.B : A {
}
public class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.Model.MoveInstanceMethodDataModel : object {
    private OneToListMap`2<IField, IProperty> myField2Property;
    public List`1<IReference> References;
    [CompilerGeneratedAttribute]
private bool <CopyOrDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedThis>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IReference> <InnerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRights <AccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private IParametersOwnerDeclaration <MethodDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IParametersOwnerDeclaration <InitialDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <TargetDeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <SourceType>k__BackingField;
    public bool CopyOrDelegate { get; }
    public bool NeedThis { get; }
    public IList`1<IReference> InnerReferences { get; }
    public bool NeedPublicTarget { get; }
    public AccessRights AccessRights { get; }
    public IParametersOwnerDeclaration MethodDeclaration { get; }
    public IParametersOwnerDeclaration InitialDeclaration { get; public set; }
    public IDeclaredElement TargetDeclaredElement { get; }
    public ITypeElement TargetType { get; }
    public ITypeElement SourceType { get; }
    public MoveInstanceMethodDataModel(bool copyOrDelegate, bool needThis, IParametersOwnerDeclaration methodDeclaration, IList`1<IReference> modelInnerReferences, IParametersOwnerDeclaration initialDeclaration, ITypeOwner targetDeclaredElement);
    [CompilerGeneratedAttribute]
public bool get_CopyOrDelegate();
    [CompilerGeneratedAttribute]
public bool get_NeedThis();
    [CompilerGeneratedAttribute]
public IList`1<IReference> get_InnerReferences();
    public bool get_NeedPublicTarget();
    [CompilerGeneratedAttribute]
public AccessRights get_AccessRights();
    [CompilerGeneratedAttribute]
public IParametersOwnerDeclaration get_MethodDeclaration();
    [CompilerGeneratedAttribute]
public IParametersOwnerDeclaration get_InitialDeclaration();
    [CompilerGeneratedAttribute]
public void set_InitialDeclaration(IParametersOwnerDeclaration value);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_TargetDeclaredElement();
    [CompilerGeneratedAttribute]
public ITypeElement get_TargetType();
    [CompilerGeneratedAttribute]
public ITypeElement get_SourceType();
    public void FillReferences(IProgressIndicator pi);
    public void SetProperty(IField field, IProperty property);
    public IProperty GetProperty(IField field);
}
public class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.Model.MoveInstanceMethodModel : object {
    private IDeclaredElementPointer`1<IMethod> myPointer;
    private IParametersOwnerDeclaration myDummy;
    protected bool myHasThis;
    [CompilerGeneratedAttribute]
private List`1<DeclaredElementNode> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IReference> <InnerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyOrDelegate>k__BackingField;
    public IMethod Method { get; }
    public List`1<DeclaredElementNode> Targets { get; public set; }
    public IParametersOwnerDeclaration MethodDeclaration { get; }
    public IList`1<IReference> InnerReferences { get; }
    public bool CopyOrDelegate { get; public set; }
    public bool NeedThis { get; }
    public MoveInstanceMethodModel(IMethod method);
    public IMethod get_Method();
    [CompilerGeneratedAttribute]
public List`1<DeclaredElementNode> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(List`1<DeclaredElementNode> value);
    public IParametersOwnerDeclaration get_MethodDeclaration();
    [CompilerGeneratedAttribute]
public IList`1<IReference> get_InnerReferences();
    [CompilerGeneratedAttribute]
public bool get_CopyOrDelegate();
    [CompilerGeneratedAttribute]
public void set_CopyOrDelegate(bool value);
    public bool get_NeedThis();
    public void AnalyzeReferences();
    public virtual bool AnalyzeDeclaration();
    public void LoadTargets();
    private bool Fits(ITypeElement typeElement);
    public void RemoveUnavailableTargets();
    public void Clear();
}
public class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.MoveInstanceMethodExec : RefactoringExecBase`2<MoveInstanceMethodWorkflow, MoveInstanceMethodRefactoring> {
    public MoveInstanceMethodExec(MoveInstanceMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.MoveInstanceMethodHelper : object {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual MoveInstanceMethodModel GetModel(MoveInstanceMethodWorkflow moveInstanceMethodWorkflow, IMethod method, Lifetime lifetime);
    public virtual void Rebind(IProgressIndicator pi, MoveInstanceMethodDataModel model);
    public virtual void AddSourceElementParameter(MoveInstanceMethodDataModel model);
    public virtual void AddAdditionalElements(MoveInstanceMethodDataModel model);
    public virtual void ReplaceTargetInDeclaration();
    public sealed virtual bool IsFromExtendsList(ITreeNode element);
    public sealed virtual bool IsReferenceName(ITreeNode element);
    public sealed virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public sealed virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public sealed virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual void ReplaceWithDelegation(IProgressIndicator pi, MoveInstanceMethodDataModel model);
}
internal class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.MoveInstanceMethodHelperUnsupported : MoveInstanceMethodHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
}
public class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.MoveInstanceMethodRefactoring : DrivenRefactoring`2<MoveInstanceMethodWorkflow, MoveInstanceMethodExec> {
    private MoveInstanceMethodDataModel myModel;
    public MoveInstanceMethodRefactoring(MoveInstanceMethodWorkflow workflow, MoveInstanceMethodDataModel dataModel, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    private void RemoveUnneccessaryParams(IProgressIndicator pi);
    private void RebindReferences(IProgressIndicator pi);
    private void CutAndPaste(IProgressIndicator pi);
    private void ProceedAdditionalElements(IProgressIndicator pi);
    private void AnalyzeReferences(IProgressIndicator pi);
    private void FindReferences(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.MoveInstanceMethodWorkflow : DrivenRefactoringWorkflow2`1<MoveInstanceMethodHelper> {
    private MoveInstanceMethodDataModel myDataModel;
    private IDeclaredElementPointer`1<ITypeOwner> myTargetPointer;
    [CompilerGeneratedAttribute]
private MoveInstanceMethodModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    private ITypeOwner Target { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public MoveInstanceMethodModel Model { get; public set; }
    public IRefactoringDriver Driver { get; public set; }
    public MoveInstanceMethodWorkflow(ISolution solution, string actionId);
    private ITypeOwner get_Target();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    [CompilerGeneratedAttribute]
public MoveInstanceMethodModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(MoveInstanceMethodModel value);
    [CompilerGeneratedAttribute]
public IRefactoringDriver get_Driver();
    [CompilerGeneratedAttribute]
public void set_Driver(IRefactoringDriver value);
    public virtual bool IsAvailable(IDataContext context);
    protected bool IsAvailableEx(IDataContext context, IMethod& method);
    public virtual bool Validate();
    public virtual bool Initialize(IDataContext context);
    public virtual void UnsuccessfulFinish(IProgressIndicator pi);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual MoveInstanceMethodHelper CreateUnsupportedHelper();
    protected virtual MoveInstanceMethodHelper CreateHelper(IRefactoringLanguageService service);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public void SetDataProvider(ITypeOwner typeOwner);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.MoveInstanceMethodWorkflowProvider : MoveWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.MoveInstanceMethod.MoveInstancePage : SingleBeRefactoringPage {
    public static string MoveInstanceMethodTargetGrid;
    private DeclaredElementNode myResult;
    private MoveInstanceMethodWorkflow myWorkflow;
    private RichText myMethodPresentation;
    public string Title { get; }
    public string Description { get; }
    public string PageDescription { get; }
    public MoveInstancePage(MoveInstanceMethodWorkflow workflow, Lifetime lifetime);
    public virtual string get_Title();
    public virtual string get_Description();
    public virtual string get_PageDescription();
    public virtual void Commit();
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__12_0(ITreeGridNode v);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "ExtractInterfaceActionText")]
[VsOverrideActionAttribute("({1496A755-94DE-11D0-8C3F-00C04FC2AAE2}:1553)")]
public class JetBrains.ReSharper.Refactorings.MoveMembers.Actions.ExtractInterfaceAction : ExtensibleRefactoringAction`1<IExtractInterfaceWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
    public sealed virtual bool ShouldFallBack(IDataContext context);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.MoveMembers.Actions.ExtractInterfaceProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "ExtractSuperclassActionText")]
public class JetBrains.ReSharper.Refactorings.MoveMembers.Actions.ExtractSuperclassAction : ExtensibleRefactoringAction`1<IExtractSuperclassWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.MoveMembers.Actions.ExtractSuperclassProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Actions.IExtractInterfaceWorkflowProvider {
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Actions.IPullUpWorkflowProvider {
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "PullMembersUpActionText")]
public class JetBrains.ReSharper.Refactorings.MoveMembers.Actions.PullUpAction : ExtensibleRefactoringAction`1<IPullUpWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.MoveMembers.Actions.PullUpProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "PushMembersDownActionText")]
public class JetBrains.ReSharper.Refactorings.MoveMembers.Actions.PushDownAction : ExtensibleRefactoringAction`1<IPushDownWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.MoveMembers.Actions.PushDownProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Analysis.IMoveAnalyser {
    public Dictionary`2<ITypeElement, JetHashSet`1<DeclaredElementNode>> BaseClass2MemberInfosMap { get; }
    public abstract virtual Dictionary`2<ITypeElement, JetHashSet`1<DeclaredElementNode>> get_BaseClass2MemberInfosMap();
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.Analysis.MoveAnalyser : object {
    protected Dictionary`2<ITypeElement, JetHashSet`1<DeclaredElementNode>> myBaseClass2MemberInfosMap;
    protected List`1<ITypeMember> myMembersToMakeOverride;
    protected JetHashSet`1<ITypeElement> myTypeElementsToMakeAbstract;
    [CompilerGeneratedAttribute]
private List`1<ITypeMember> <TypeMembersToRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ITypeMember, JetHashSet`1<ITypeMember>> <OverridesOf>k__BackingField;
    public List`1<ITypeMember> MembersToMakeOverride { get; }
    public List`1<ITypeMember> TypeMembersToRemove { get; protected set; }
    public JetHashSet`1<ITypeElement> TypeElementsToMakeAbstract { get; }
    public IEnumerable`1<ITypeElement> AllTypeElementsToMakeAbstract { get; }
    public Dictionary`2<ITypeMember, JetHashSet`1<ITypeMember>> OverridesOf { get; public set; }
    public Dictionary`2<ITypeElement, JetHashSet`1<DeclaredElementNode>> BaseClass2MemberInfosMap { get; }
    public List`1<ITypeMember> get_MembersToMakeOverride();
    [CompilerGeneratedAttribute]
public List`1<ITypeMember> get_TypeMembersToRemove();
    [CompilerGeneratedAttribute]
protected void set_TypeMembersToRemove(List`1<ITypeMember> value);
    public JetHashSet`1<ITypeElement> get_TypeElementsToMakeAbstract();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.Analysis.MoveAnalyser/<get_AllTypeElementsToMakeAbstract>d__12")]
public virtual IEnumerable`1<ITypeElement> get_AllTypeElementsToMakeAbstract();
    [CompilerGeneratedAttribute]
public Dictionary`2<ITypeMember, JetHashSet`1<ITypeMember>> get_OverridesOf();
    [CompilerGeneratedAttribute]
public void set_OverridesOf(Dictionary`2<ITypeMember, JetHashSet`1<ITypeMember>> value);
    public sealed virtual Dictionary`2<ITypeElement, JetHashSet`1<DeclaredElementNode>> get_BaseClass2MemberInfosMap();
    public abstract virtual List`1<IMethod> GetSuspiciousMethods();
    public abstract virtual void PrepareData(IMoveMembersExecuter executer, IProgressIndicator pi, ITypeElement targetType);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.Analysis.MoveDataModel : object {
    protected IDeclaredElementPointer`1<ITypeElement> myInitialTypeElement;
    [CompilerGeneratedAttribute]
private TargetElementTypes <ElementType>k__BackingField;
    private PsiLanguageType myLanguage;
    [CompilerGeneratedAttribute]
private Dictionary`2<DeclaredElementNode, JetHashSet`1<DeclaredElementNode>> <DependenciesMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DeclaredElementNode> <Members>k__BackingField;
    public TargetElementTypes ElementType { get; protected set; }
    public Dictionary`2<DeclaredElementNode, JetHashSet`1<DeclaredElementNode>> DependenciesMap { get; protected set; }
    public ITypeElement TypeElement { get; private set; }
    public List`1<DeclaredElementNode> Members { get; protected set; }
    public PsiLanguageType Language { get; }
    public IEnumerable`1<DeclaredElementNode> IncludedMembers { get; }
    protected MoveDataModel(ITypeElement typeElement);
    [CompilerGeneratedAttribute]
public TargetElementTypes get_ElementType();
    [CompilerGeneratedAttribute]
protected void set_ElementType(TargetElementTypes value);
    public virtual void InitializeMembers(Func`2<ITypeMember, bool> isMemberIncluded);
    protected static TargetElementTypes ElementTypeOf(ITypeElement typeElement);
    [CompilerGeneratedAttribute]
public Dictionary`2<DeclaredElementNode, JetHashSet`1<DeclaredElementNode>> get_DependenciesMap();
    [CompilerGeneratedAttribute]
protected void set_DependenciesMap(Dictionary`2<DeclaredElementNode, JetHashSet`1<DeclaredElementNode>> value);
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
private void set_TypeElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public List`1<DeclaredElementNode> get_Members();
    [CompilerGeneratedAttribute]
protected void set_Members(List`1<DeclaredElementNode> value);
    protected abstract virtual void AddBaseTypeInfo(IDeclaredType declaredType, bool b);
    protected virtual bool FilterMembers(ITypeMember typeMember);
    public PsiLanguageType get_Language();
    public virtual IEnumerable`1<DeclaredElementNode> get_IncludedMembers();
    public abstract virtual ITypeDeclaration GetTargetDeclaration(ITypeElement typeElement);
    public bool IsValid();
    protected abstract virtual void AddMemberInfo(ITypeMember member, bool isIncluded);
    public virtual bool Validate();
    public abstract virtual bool IsReferenced(DeclaredElementNode info);
    public void InitDependencies();
    public void UpdateTypeElement();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Common.BaseTypeInfoBase : MethodInfo {
    [CompilerGeneratedAttribute]
private MoveDataModel <Analyser>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredType <DeclaredType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <OwnerTypeElement>k__BackingField;
    public MoveDataModel Analyser { get; }
    public IDeclaredType DeclaredType { get; }
    public ITypeElement OwnerTypeElement { get; }
    public BaseTypeInfoBase(IDeclaredType declaredType, MoveDataModel analyser, ITypeElement ownerTypeElement);
    [CompilerGeneratedAttribute]
public MoveDataModel get_Analyser();
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredType get_DeclaredType();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeElement get_OwnerTypeElement();
    public sealed virtual IDeclaredType GetNewDeclaredType(IImageCollector imageCollector, ITypeElement targetTypeElement);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Common.IBaseTypeInfoBase {
    public ITypeElement OwnerTypeElement { get; }
    public IDeclaredType DeclaredType { get; }
    public abstract virtual ITypeElement get_OwnerTypeElement();
    public abstract virtual IDeclaredType get_DeclaredType();
    [CanBeNullAttribute]
public abstract virtual IDeclaredType GetNewDeclaredType(IImageCollector imageCollector, ITypeElement targetTypeElement);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Common.IImageCollector {
    public abstract virtual void SetRefID(Func`2<IReference, IReference> mapDelegate, ITypeElement targetTypeElement);
    public abstract virtual void SetRefID(Func`2<IReference, IReference> mapDelegate);
    public abstract virtual void SetTypeID(ITypeElement oldTypeElement, ITypeElement newTypeElement);
    public abstract virtual void SetTypeID(ITypeElement oldTypeElement, ITypeElement newTypeElement, ITypeElement targetTypeElement);
    public abstract virtual void SetMemberID(ITypeMember oldTypeMember, ITypeMember newTypeMember, ITypeElement targetTypeElement);
    public abstract virtual IDictionary`2<ITypeElement, ITypeElement> GetTypeMap(ITypeElement targetType);
    public abstract virtual IEnumerable`1<IDeclaredElement> GetMemberImages(IDeclaredElement oldTypeMember, ITypeElement targetTypeMember);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Common.IMove {
    public abstract virtual void SetExecuter(IRefactoringExecuter refactoring);
    public abstract virtual bool CheckConflictsWithTargetClassName(ITypeElement element, string name);
    public abstract virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public abstract virtual MoveMembersHelper GetHelper();
    public abstract virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool name);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Common.IMoveMembersExecuter {
    public JetHashSet`1<IReference> RemovedLocalReferences { get; public set; }
    public IMoveAnalyser Analyser { get; }
    public IPsiServices PsiServices { get; }
    public JetHashSet`1<IDeclaredElement> ElementsToMakeProtected { get; }
    public IRefactoringDriver Driver { get; }
    public ISubstitution AllBaseTypeSubst { get; }
    public abstract virtual JetHashSet`1<IReference> get_RemovedLocalReferences();
    public abstract virtual void set_RemovedLocalReferences(JetHashSet`1<IReference> value);
    public abstract virtual IMoveAnalyser get_Analyser();
    public abstract virtual IPsiServices get_PsiServices();
    public abstract virtual JetHashSet`1<IDeclaredElement> get_ElementsToMakeProtected();
    public abstract virtual IRefactoringDriver get_Driver();
    public abstract virtual ISubstitution get_AllBaseTypeSubst();
    public abstract virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement typeElement, bool isItemName);
    [CanBeNullAttribute]
public abstract virtual IPsiModule GetSourceProject();
    public abstract virtual void RemoveSuperType(ITypeElement typeElement, IDeclaredType declaredType);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Common.IReferenceConsumer {
    public abstract virtual void InitRef(IReference reference);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.Common.ITargetTypeWithProjectFile {
    public ITypeElement TypeElement { get; }
    public ITypeDeclaration TypeDeclaration { get; }
    public abstract virtual ITypeElement get_TypeElement();
    public abstract virtual ITypeDeclaration get_TypeDeclaration();
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.Common.MethodInfo : DeclaredElementNode {
    [CompilerGeneratedAttribute]
private bool <MakeAbstract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanHaveAbstract>k__BackingField;
    public bool MakeAbstract { get; public set; }
    public bool CanHaveAbstract { get; public set; }
    protected MethodInfo(IDeclaredElement element, bool initialIncluded);
    [CompilerGeneratedAttribute]
public bool get_MakeAbstract();
    [CompilerGeneratedAttribute]
public void set_MakeAbstract(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanHaveAbstract();
    [CompilerGeneratedAttribute]
public void set_CanHaveAbstract(bool value);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.Common.MovedMemberInfo : MethodInfo {
    protected MoveDataModel myAnalyser;
    protected bool myForceEventToMoveAsVirtual;
    private bool myIsReferenced;
    private IDeclaredElement myRemovedDeclaredElement;
    [CompilerGeneratedAttribute]
private bool <ForceRemoveReadonly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceCut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceOverride2Virtual>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceVirtual2Override>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnsafeContext>k__BackingField;
    public bool ForceRemoveReadonly { get; protected set; }
    public bool ForceCut { get; public set; }
    public IDeclaredElement RemovedDeclaredElement { get; }
    public bool ForceOverride2Virtual { get; public set; }
    public bool ForceVirtual2Override { get; public set; }
    public bool ForceEventToMoveAsVirtual { get; public set; }
    public bool MakeTargetAbstract { get; }
    public bool MakeSourceAbstract { get; }
    public bool MakeTargetOverride { get; }
    public bool UnsafeContext { get; public set; }
    protected MovedMemberInfo(IDeclaredElement declaredElement, bool included, MoveDataModel analyser);
    [CompilerGeneratedAttribute]
public bool get_ForceRemoveReadonly();
    [CompilerGeneratedAttribute]
protected void set_ForceRemoveReadonly(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceCut();
    [CompilerGeneratedAttribute]
public void set_ForceCut(bool value);
    public IDeclaredElement get_RemovedDeclaredElement();
    [CompilerGeneratedAttribute]
public bool get_ForceOverride2Virtual();
    [CompilerGeneratedAttribute]
public void set_ForceOverride2Virtual(bool value);
    public abstract virtual void UpdateType();
    [CompilerGeneratedAttribute]
public bool get_ForceVirtual2Override();
    [CompilerGeneratedAttribute]
public void set_ForceVirtual2Override(bool value);
    public virtual bool get_ForceEventToMoveAsVirtual();
    public virtual void set_ForceEventToMoveAsVirtual(bool value);
    public virtual bool get_MakeTargetAbstract();
    public virtual bool get_MakeSourceAbstract();
    public virtual bool get_MakeTargetOverride();
    [CompilerGeneratedAttribute]
public bool get_UnsafeContext();
    [CompilerGeneratedAttribute]
public void set_UnsafeContext(bool value);
    public abstract virtual bool IsPureInstanceMove();
    public void SetRemovedTypeMember(IDeclaredElement member);
    public abstract virtual bool MakeProtected();
    public abstract virtual bool PerformCutDeclarations();
    public abstract virtual bool MakeOverride();
    public void SetForceRemoveReadonly();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Common.MoveMembersDataProvider : object {
    private string myAbstractSet;
    private string myMembersSet;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    public bool IsDefault { get; }
    public string Target { get; }
    public string ClassName { get; }
    public MoveMembersDataProvider(string target, string membersSet, string abstractSet, string className, bool isDefault);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public string get_ClassName();
    public void ApplyTargetMembers(IList`1<DeclaredElementNode> members);
    public void ApplySelectedAndAbstractMembers(IList`1<DeclaredElementNode> members);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.Common.MoveMembersHelper : object {
    [CompilerGeneratedAttribute]
private IMoveMembersExecuter <Executer>k__BackingField;
    protected IMoveMembersExecuter Executer { get; }
    protected MoveMembersHelper(IMoveMembersExecuter executer);
    [CompilerGeneratedAttribute]
protected IMoveMembersExecuter get_Executer();
    public abstract virtual IList`1<Pair`2<DeclaredElementNode, IDeclaration>> CutDeclarations(IEnumerable`1<DeclaredElementNode> memberInfos, SubProgressIndicator pi);
    public abstract virtual ITypeDeclaration InsertSibling(ITypeDeclaration decl, ITypeDeclaration sourceClass);
    public abstract virtual ITypeDeclaration InsertToNewFile(ITypeDeclaration decl, ITypeDeclaration sourceClass, string ns, IProjectFile fileNearby);
    public abstract virtual void SetSuperclass(ITypeDeclaration sourceTypeDeclaration, ITypeElement newSuperTypeElement, ISubstitution substitution);
    public abstract virtual void PasteDeclarations(IList`1<Pair`2<DeclaredElementNode, IDeclaration>> declarations, ITypeElement targetType, IProjectFile projectFile, ITypeDeclaration targetTypeDeclaration, SubProgressIndicator pi);
    public abstract virtual ITypeDeclaration CreateTargetTypeElement(string name, ITypeElement sourceType, List`1<ITypeParameter> parameters, bool createBaseType, bool preserveAccessRights);
    public abstract virtual void AddBaseInterface(ITypeElement element, IDeclaredType info);
    public abstract virtual void MakeTypeElementAbstract(ITypeElement element);
    public abstract virtual void RemoveDeclaration(ITypeMember member);
    public abstract virtual void MakeOverride(ITypeMember member);
    public abstract virtual bool TryProcessMultiFieldForResolve(IRecursiveElementProcessor collector, IDeclaration declaration);
    public void MakePublic(ITypeMember member);
    public abstract virtual void CheckConstructorReferenceConflict(IReference reference);
    public virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool nameIsItem, IRefactoringDriver driver);
    public abstract virtual void RemoveSuperType(ITypeDeclaration typeDeclaration, IDeclaredType type);
    public virtual IConstructor GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
    public abstract virtual void GenerateConstructors(ITypeElement targetType, ITypeDeclaration typeDeclaration, IDeclaredElementPointer`1<IConstructor> baseConstructor);
    public void MakeProtected(IDeclaredElement element);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.Common.MoveMembersRefactoring`2 : object {
    protected LanguageMapOfRefactoring`1<IMove> myExec;
    private Dictionary`2<IDeclaredElement, IDeclaredElement> myMembersMap;
    private Dictionary`2<IReference, BaseResolveResultImage> myOtherReferences;
    protected Dictionary`2<IReference, BaseResolveResultImage> myLocalReferences;
    private List`1<ReferenceBinding> myReferencesToRebind;
    [CompilerGeneratedAttribute]
private TDataModel <DataModel>k__BackingField;
    [CompilerGeneratedAttribute]
private TAnalyser <Analyser>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<IReference> <RemovedLocalReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<IDeclaredElement> <ElementsToMakeProtected>k__BackingField;
    private IList`1<Pair`2<DeclaredElementNode, IDeclaration>> myCutDeclarations;
    private Dictionary`2<ITypeElement, ITypeElement> myTypesMap;
    private static Key OTHER_REFERENCES_KEY;
    public TDataModel DataModel { get; }
    protected TAnalyser Analyser { get; protected set; }
    private IMoveAnalyser JetBrains.ReSharper.Refactorings.MoveMembers.Common.IMoveMembersExecuter.Analyser { get; }
    public IRefactoringDriver Driver { get; }
    protected ISolution Solution { get; }
    public IPsiServices PsiServices { get; }
    public JetHashSet`1<IReference> RemovedLocalReferences { get; public set; }
    public JetHashSet`1<IDeclaredElement> ElementsToMakeProtected { get; }
    public ISubstitution AllBaseTypeSubst { get; }
    protected MoveMembersRefactoring`2(TDataModel dataModel, ISolution solution, IRefactoringDriver driver);
    private static MoveMembersRefactoring`2();
    protected MoveMembersHelper GetHelper(PsiLanguageType language);
    [CompilerGeneratedAttribute]
public TDataModel get_DataModel();
    protected abstract virtual IMove CreateUnsupportedRefactoring();
    [CompilerGeneratedAttribute]
protected TAnalyser get_Analyser();
    [CompilerGeneratedAttribute]
protected void set_Analyser(TAnalyser value);
    private sealed virtual override IMoveAnalyser JetBrains.ReSharper.Refactorings.MoveMembers.Common.IMoveMembersExecuter.get_Analyser();
    [CompilerGeneratedAttribute]
public sealed virtual IRefactoringDriver get_Driver();
    public sealed virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement typeElement, bool isItemName);
    public sealed virtual IPsiModule GetSourceProject();
    public sealed virtual void RemoveSuperType(ITypeElement typeElement, IDeclaredType declaredType);
    [CompilerGeneratedAttribute]
protected ISolution get_Solution();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiServices get_PsiServices();
    [CompilerGeneratedAttribute]
public sealed virtual JetHashSet`1<IReference> get_RemovedLocalReferences();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RemovedLocalReferences(JetHashSet`1<IReference> value);
    [CompilerGeneratedAttribute]
public sealed virtual JetHashSet`1<IDeclaredElement> get_ElementsToMakeProtected();
    public virtual ISubstitution get_AllBaseTypeSubst();
    public virtual bool Execute(IProgressIndicator pi);
    protected virtual void PrepareData(SubProgressIndicator pi);
    protected virtual bool InitializeBaseType(SubProgressIndicator subPi);
    protected virtual void MakeMembersProtected();
    private void MakeCollectedDeclarationsOverride();
    private void RemoveCollectedDeclarations();
    private void MakeClassesAbstract(IProgressIndicator pi);
    private void MakeClassAbstract(IProgressIndicator pi, ITypeElement element);
    private void CheckMakeClassAbstractConflicts(IProgressIndicator pi, ITypeElement element);
    protected virtual void MakeOverridesPublic();
    private void Rebind(IProgressIndicator pi);
    private void BindSuspiciousReferences(IProgressIndicator pi);
    protected abstract virtual IMove CreateRefactoring(InternalRefactoringLanguageService service, MoveMembersRefactoring`2<TAnalyser, TDataModel> refactoring);
    protected abstract virtual void CheckConflictsWithTargetClassName(SubProgressIndicator subPi);
    protected abstract virtual void CheckConflictsWithExistingElements(SubProgressIndicator pi);
    protected void CheckConflictWithMembersInType(ITypeElement element, SubProgressIndicator pi);
    protected abstract virtual bool IgnoreConflictedMember(ITypeMember info, ITypeElement element);
    protected abstract virtual void CollectMembersToMakeProtected();
    protected void CompareConstraints(ITypeParameter sourceParameter, ITypeParameter targetParameter, ITypeElement targetTypeElement);
    private void RestoreReferences(IProgressIndicator pi);
    protected virtual void RestoreLocalReferences(SubProgressIndicator pi);
    protected void RestoreReferencesForGivenTarget(Dictionary`2<IReference, BaseResolveResultImage> localReferences, ITypeElement targetType, SubProgressIndicator pi);
    private void RestoreLocalReference(IReference reference, BaseResolveResultImage resolveResultImage, ITypeElement targetType);
    protected TypeImageProvider ImageProvider(ITypeElement targetTypeElement);
    protected virtual void RestoreOtherReference(IReference reference, BaseResolveResultImage resolveResultImage);
    protected abstract virtual IEnumerable`1<ITypeElement> GetAllTargetTypes();
    private void CutAndPaste(IProgressIndicator pi);
    protected virtual bool NeedPasteIn(ITypeElement type, Pair`2<DeclaredElementNode, IDeclaration> pair);
    private void StoreReferences(IProgressIndicator pi);
    private void StoreOtherReferences(IProgressIndicator pi);
    private void StoreInternalReferences(SubProgressIndicator subPi);
    protected void ProcessAllMembersForResolve(IRecursiveElementProcessor collector, SubProgressIndicator subPi);
    public abstract virtual void CreateTypeParametersMap();
    public virtual void InitRef(IReference reference);
    public virtual void SetRefID(Func`2<IReference, IReference> mapDelegate, ITypeElement targetTypeElement);
    public sealed virtual void SetRefID(Func`2<IReference, IReference> mapDelegate);
    public sealed virtual void SetTypeID(ITypeElement oldTypeElement, ITypeElement newTypeElement);
    public virtual void SetTypeID(ITypeElement oldTypeElement, ITypeElement newTypeElement, ITypeElement targetTypeElement);
    public virtual void SetMemberID(ITypeMember oldTypeMember, ITypeMember newTypeMember, ITypeElement targetTypeElement);
    public virtual IDictionary`2<ITypeElement, ITypeElement> GetTypeMap(ITypeElement targetType);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.Common.MoveMembersRefactoring`2/<GetMemberImages>d__81")]
public virtual IEnumerable`1<IDeclaredElement> GetMemberImages(IDeclaredElement oldTypeMember, ITypeElement targetTypeMember);
    [CompilerGeneratedAttribute]
private IMove <.ctor>b__6_0(IRefactoringLanguageService service);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.Common.MoveWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private MoveMembersDataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    protected MoveMembersDataProvider DataProvider { get; protected set; }
    protected ISolution Solution { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public bool MightModifyManyDocuments { get; }
    protected MoveWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
protected MoveMembersDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
protected void set_DataProvider(MoveMembersDataProvider value);
    [CompilerGeneratedAttribute]
protected ISolution get_Solution();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual bool get_MightModifyManyDocuments();
    protected bool IsAvailableEx(IDataContext context, ICollection`1& elements, ITypeElement& ownerType);
    protected virtual bool CanRunOnSealed();
    protected virtual bool ElementCanBeMoved(IDeclaredElement element);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Common.ReferenceConsumerOfDelegate : object {
    private Do myAction;
    public ReferenceConsumerOfDelegate(Do action);
    public sealed virtual void InitRef(IReference reference);
}
public enum JetBrains.ReSharper.Refactorings.MoveMembers.Common.TargetElementTypes : Enum {
    public int value__;
    public static TargetElementTypes Interface;
    public static TargetElementTypes Class;
    public static TargetElementTypes AbstractClass;
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Common.TargetTypeWithProjectFile : MethodInfo {
    private TargetTypeWrapper myTargetTypeWrapper;
    [CompilerGeneratedAttribute]
private ITypeDeclaration <TypeDeclaration>k__BackingField;
    public TargetTypeWrapper TargetTypeWrapper { get; }
    public ITypeDeclaration TypeDeclaration { get; }
    public ITypeElement TypeElement { get; }
    public TargetTypeWithProjectFile(TargetTypeWrapper targetTypeWrapper, ITypeDeclaration typeDeclaration);
    public TargetTypeWrapper get_TargetTypeWrapper();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeDeclaration get_TypeDeclaration();
    public sealed virtual ITypeElement get_TypeElement();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Common.TargetTypeWrapper : DeclaredElementNode {
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<ITypeElement> <TypeElementPointer>k__BackingField;
    public IDeclaredElementPointer`1<ITypeElement> TypeElementPointer { get; public set; }
    [NotNullAttribute]
public ITypeElement TypeElement { get; }
    public TargetTypeWrapper(ITypeElement element, bool initialIncluded, bool isRoot);
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<ITypeElement> get_TypeElementPointer();
    [CompilerGeneratedAttribute]
public void set_TypeElementPointer(IDeclaredElementPointer`1<ITypeElement> value);
    public ITypeElement get_TypeElement();
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.PullUpBase : object {
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    private IRefactoringExecuter myExecuter;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    public IRefactoringDriver Driver { get; private set; }
    public IMoveMembersExecuter Executer { get; }
    public ISolution Solution { get; }
    public IRefactoringDriver RefactoringDriver { get; public set; }
    protected PullUpBase(ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public IRefactoringDriver get_Driver();
    [CompilerGeneratedAttribute]
private void set_Driver(IRefactoringDriver value);
    public IMoveMembersExecuter get_Executer();
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    public IRefactoringDriver get_RefactoringDriver();
    public sealed virtual void set_RefactoringDriver(IRefactoringDriver value);
    public sealed virtual void SetExecuter(IRefactoringExecuter refactoring);
    public virtual bool CheckConflictsWithTargetClassName(ITypeElement element, string name);
    public abstract virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public abstract virtual MoveMembersHelper GetHelper();
    public virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool name);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.PullUpBaseAnalyzer : MoveAnalyser {
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DeclaredElementNode> <IncludedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private SubstitutionMap <SubstitutionMap>k__BackingField;
    public ITypeElement TypeElement { get; }
    public IEnumerable`1<DeclaredElementNode> IncludedMembers { get; }
    public SubstitutionMap SubstitutionMap { get; protected set; }
    protected PullUpBaseAnalyzer(MoveDataModel dataModel);
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
public IEnumerable`1<DeclaredElementNode> get_IncludedMembers();
    [CompilerGeneratedAttribute]
public SubstitutionMap get_SubstitutionMap();
    [CompilerGeneratedAttribute]
protected void set_SubstitutionMap(SubstitutionMap value);
    protected virtual void FindOverridesOf(IProgressIndicator pi, IEnumerable`1<IOverridableMember> allMembers, IPsiServices psiServices);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.PullUpBaseDataModel : MoveDataModel {
    public IDocument DocumentToSave;
    [CompilerGeneratedAttribute]
private TargetTypeWithProjectFile <TargetTypeWithProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetElementTypes <TargetElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <CreatedFile>k__BackingField;
    public TargetTypeWithProjectFile TargetTypeWithProjectFile { get; protected set; }
    public TargetElementTypes TargetElementType { get; protected set; }
    public ITypeElement TargetType { get; public set; }
    public IProjectFile CreatedFile { get; public set; }
    protected PullUpBaseDataModel(ITypeElement containingType);
    [CompilerGeneratedAttribute]
public TargetTypeWithProjectFile get_TargetTypeWithProjectFile();
    [CompilerGeneratedAttribute]
protected void set_TargetTypeWithProjectFile(TargetTypeWithProjectFile value);
    [CompilerGeneratedAttribute]
public TargetElementTypes get_TargetElementType();
    [CompilerGeneratedAttribute]
protected void set_TargetElementType(TargetElementTypes value);
    [CompilerGeneratedAttribute]
public ITypeElement get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(ITypeElement value);
    [CompilerGeneratedAttribute]
public IProjectFile get_CreatedFile();
    [CompilerGeneratedAttribute]
public void set_CreatedFile(IProjectFile value);
    public virtual ITypeDeclaration GetTargetDeclaration(ITypeElement typeElement);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.PullUpBaseMemberInfo : MovedMemberInfo {
    [CompilerGeneratedAttribute]
private TargetElementTypes <ElementType>k__BackingField;
    private TargetElementTypes myTargetElementType;
    [CompilerGeneratedAttribute]
private PullUpTypes <PullUpType>k__BackingField;
    public TargetElementTypes ElementType { get; protected set; }
    public TargetElementTypes TargetElementType { get; public set; }
    public bool ForceEventToMoveAsVirtual { get; public set; }
    public bool MakeTargetAbstract { get; }
    public bool MakeSourceAbstract { get; }
    public PullUpTypes PullUpType { get; public set; }
    protected PullUpBaseMemberInfo(IDeclaredElement declaredElement, bool included, TargetElementTypes type, TargetElementTypes elementType, MoveDataModel analyser);
    [CompilerGeneratedAttribute]
public TargetElementTypes get_ElementType();
    [CompilerGeneratedAttribute]
protected void set_ElementType(TargetElementTypes value);
    public TargetElementTypes get_TargetElementType();
    public void set_TargetElementType(TargetElementTypes value);
    public virtual bool IsPureInstanceMove();
    public virtual void UpdateType();
    public virtual bool get_ForceEventToMoveAsVirtual();
    public virtual void set_ForceEventToMoveAsVirtual(bool value);
    public virtual bool get_MakeTargetAbstract();
    public virtual bool get_MakeSourceAbstract();
    [CompilerGeneratedAttribute]
public PullUpTypes get_PullUpType();
    [CompilerGeneratedAttribute]
public void set_PullUpType(PullUpTypes value);
    public PullUpTypes GetPullUpType();
    public virtual bool PerformCutDeclarations();
    public virtual bool MakeProtected();
    public virtual bool MakeOverride();
    public void DisableMember();
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.PullUpBaseRefactoring`2 : MoveMembersRefactoring`2<TAnalyser, TStaticAnalyser> {
    protected PullUpBaseRefactoring`2(TStaticAnalyser dataModel, ISolution solution, IRefactoringDriver driver);
    protected virtual void PrepareData(SubProgressIndicator pi);
    protected virtual void MakeOverridesPublic();
    protected virtual bool IgnoreConflictedMember(ITypeMember info, ITypeElement element);
    protected virtual void CollectMembersToMakeProtected();
    public virtual void CreateTypeParametersMap();
    protected List`1<ITypeParameter> GetUsedTypeParameters(ISubstitution fakeSubst, SubProgressIndicator pi);
    protected virtual void CollectForQuasiInterfaces(JetHashSet`1<ITypeParameter> parameters, JetHashSet`1<ITypeParameter> usedParameters);
    protected virtual void CollectParametersOfBaseClassSpecification(JetHashSet`1<ITypeParameter> sourceTypeTypeParameters, JetHashSet`1<ITypeParameter> usedParameters);
    protected ISubstitution GetMatchedSubstitution(ITypeElement baseClass, List`1<ITypeParameter> typeParameters);
    protected ISubstitution GetMatchedSubstitutionBack(ITypeElement baseClass, List`1<ITypeParameter> typeParameters);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.PullUpTypeInfo : BaseTypeInfoBase {
    [CompilerGeneratedAttribute]
private TargetElementTypes <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetElementTypes <TargetElementType>k__BackingField;
    public TargetElementTypes ElementType { get; }
    public TargetElementTypes TargetElementType { get; public set; }
    public PullUpTypeInfo(IDeclaredType declaredType, TargetElementTypes elementType, TargetElementTypes targetElementType, MoveDataModel analyser, ITypeElement ownerTypeElement);
    [CompilerGeneratedAttribute]
public TargetElementTypes get_ElementType();
    [CompilerGeneratedAttribute]
public TargetElementTypes get_TargetElementType();
    [CompilerGeneratedAttribute]
public void set_TargetElementType(TargetElementTypes value);
}
public enum JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.PullUpTypes : Enum {
    public int value__;
    public static PullUpTypes Common;
    public static PullUpTypes Interface2Interface;
    public static PullUpTypes Abstract2Interface;
    public static PullUpTypes Instance2Interface;
    public static PullUpTypes Override2Interface;
    public static PullUpTypes Instance2Abstract;
    public static PullUpTypes Override2Abstract;
    public static PullUpTypes Abstract2Abstract;
    public static PullUpTypes Instance2Instance;
    public static PullUpTypes Override2Override;
    public static PullUpTypes Virtual2Interface;
    public static PullUpTypes Virtual2Abstract;
    public static PullUpTypes Virtual2Virtual;
    public static PullUpTypes MoveConstructor;
    public static PullUpTypes MoveConstructorBody;
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.VBExtractInterfaceBase : PullUpBase {
    protected VBExtractInterfaceBase(ISolution solution, IRefactoringDriver driver);
    public virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool name);
    public void GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.VBExtractSuperclassBase : PullUpBase {
    protected VBExtractSuperclassBase(ISolution solution, IRefactoringDriver driver);
    public virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool name);
    public void GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplBaseUp.VBPullUpBase : PullUpBase {
    protected VBPullUpBase(ISolution solution, IRefactoringDriver driver);
    public virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool name);
    public void GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractInterface.ExtractInterfaceAnalyser : PullUpBaseAnalyzer {
    public ExtractInterfaceAnalyser(MoveDataModel dataModel);
    public virtual List`1<IMethod> GetSuspiciousMethods();
    public void PrepareExtractData(IMoveMembersExecuter executer, IProgressIndicator pi, ITypeElement targetType, ISubstitution baseSubst);
    public virtual void PrepareData(IMoveMembersExecuter executer, IProgressIndicator pi, ITypeElement targetType);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractInterface.ExtractInterfaceDataModel : ExtractParentDataModel {
    [CompilerGeneratedAttribute]
private Dictionary`2<ExtractInterfaceMemberInfo, ITypeElement> <MemberInfoToBaseType>k__BackingField;
    public Dictionary`2<ExtractInterfaceMemberInfo, ITypeElement> MemberInfoToBaseType { get; }
    public IEnumerable`1<DeclaredElementNode> IncludedMembers { get; }
    public ExtractInterfaceDataModel(ITypeElement containingType, string className, string newNamespace);
    [CompilerGeneratedAttribute]
public Dictionary`2<ExtractInterfaceMemberInfo, ITypeElement> get_MemberInfoToBaseType();
    public virtual IEnumerable`1<DeclaredElementNode> get_IncludedMembers();
    public virtual void InitializeMembers(Func`2<ITypeMember, bool> isMemberIncluded);
    private static int MemberSorter(DeclaredElementNode declaredElementNode);
    protected virtual void AddMemberInfo(ITypeMember member, bool isIncluded);
    protected virtual bool FilterMembers(ITypeMember typeMember);
    private void AddMember(ITypeMember member, Func`2<ITypeMember, bool> isMemberIncluded);
    public virtual bool IsReferenced(DeclaredElementNode info);
    protected virtual void AddBaseTypeInfo(IDeclaredType declaredType, bool b);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractInterface.ExtractInterfaceMemberInfo : PullUpBaseMemberInfo {
    public ExtractInterfaceMemberInfo(IDeclaredElement declaredElement, bool included, TargetElementTypes type, TargetElementTypes elementType, ExtractInterfaceDataModel analyser);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractInterface.ExtractInterfaceRefactoring : PullUpBaseRefactoring`2<ExtractInterfaceAnalyser, ExtractInterfaceDataModel> {
    private ISubstitution myAllBaseTypeSubst;
    public ISubstitution AllBaseTypeSubst { get; }
    public ExtractInterfaceRefactoring(ISolution solution, IRefactoringDriver driver, ExtractInterfaceDataModel dataModel);
    public virtual ISubstitution get_AllBaseTypeSubst();
    protected virtual IMove CreateUnsupportedRefactoring();
    protected virtual void CheckConflictsWithTargetClassName(SubProgressIndicator subPi);
    protected virtual bool InitializeBaseType(SubProgressIndicator subPi);
    protected virtual void PrepareData(SubProgressIndicator pi);
    protected virtual void CollectForQuasiInterfaces(JetHashSet`1<ITypeParameter> parameters, JetHashSet`1<ITypeParameter> usedParameters);
    private ISubstitution GetAllBaseClassesSubstitution();
    private ITypeElement CreateTargetTypeElement(List`1<ITypeParameter> parameters);
    private void CheckNewClassName(string newName);
    private string GetClassName(int parameters);
    protected virtual void CheckConflictsWithExistingElements(SubProgressIndicator pi);
    protected virtual IMove CreateRefactoring(InternalRefactoringLanguageService service, MoveMembersRefactoring`2<ExtractInterfaceAnalyser, ExtractInterfaceDataModel> refactoring);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractInterface.ExtractInterfaceRefactoring/<GetAllTargetTypes>d__15")]
protected virtual IEnumerable`1<ITypeElement> GetAllTargetTypes();
    protected virtual void CollectParametersOfBaseClassSpecification(JetHashSet`1<ITypeParameter> sourceTypeTypeParameters, JetHashSet`1<ITypeParameter> usedParameters);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractInterface.ExtractInterfaceWorkflow : MoveWorkflow {
    private ITreeNodePointer`1<IDeclaration> mySupportedDeclaration;
    [CompilerGeneratedAttribute]
private ExtractInterfaceDataModel <DataModel>k__BackingField;
    public ExtractInterfaceDataModel DataModel { get; protected set; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public HelpId HelpKeyword { get; }
    public ExtractInterfaceWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public ExtractInterfaceDataModel get_DataModel();
    [CompilerGeneratedAttribute]
protected void set_DataModel(ExtractInterfaceDataModel value);
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual HelpId get_HelpKeyword();
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator taskExecutorCreator);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public virtual void UnsuccessfulFinish(IProgressIndicator pi);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual bool ElementCanBeMoved(IDeclaredElement element);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractInterface.IExtractInterface {
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.ExtractParentDataModel : PullUpBaseDataModel {
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MoveSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewNamespace>k__BackingField;
    public string ClassName { get; public set; }
    public bool MoveSibling { get; public set; }
    public string NewNamespace { get; }
    protected ExtractParentDataModel(ITypeElement containingType, string className, string newNamespace);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public bool get_MoveSibling();
    [CompilerGeneratedAttribute]
public void set_MoveSibling(bool value);
    [CompilerGeneratedAttribute]
public string get_NewNamespace();
    public virtual void InitializeMembers(Func`2<ITypeMember, bool> isMemberIncluded);
    protected abstract virtual void AddMemberInfo(ITypeMember member, bool isIncluded);
    protected abstract virtual bool FilterMembers(ITypeMember typeMember);
    public abstract virtual bool IsReferenced(DeclaredElementNode info);
    protected abstract virtual void AddBaseTypeInfo(IDeclaredType declaredType, bool b);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.ExtractSuperclassAnalyser : PullUpBaseAnalyzer {
    public ExtractSuperclassAnalyser(PullUpBaseDataModel dataModel);
    public virtual List`1<IMethod> GetSuspiciousMethods();
    public virtual void PrepareData(IMoveMembersExecuter executer, IProgressIndicator pi, ITypeElement targetType);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.ExtractSuperclassDataModel : ExtractParentDataModel {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <DirectoryPath>k__BackingField;
    public VirtualFileSystemPath DirectoryPath { get; }
    public IEnumerable`1<DeclaredElementNode> IncludedMembers { get; }
    public ExtractSuperclassDataModel(ITypeElement containingType, string className, string newNamespace, VirtualFileSystemPath pathName);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_DirectoryPath();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.ExtractSuperclassDataModel/<get_IncludedMembers>d__4")]
public virtual IEnumerable`1<DeclaredElementNode> get_IncludedMembers();
    protected virtual void AddMemberInfo(ITypeMember member, bool isIncluded);
    protected virtual bool FilterMembers(ITypeMember typeMember);
    public virtual bool IsReferenced(DeclaredElementNode info);
    protected virtual void AddBaseTypeInfo(IDeclaredType declaredType, bool b);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.ExtractSuperclassMemberInfo : PullUpBaseMemberInfo {
    public ExtractSuperclassMemberInfo(IDeclaredElement declaredElement, bool included, TargetElementTypes type, TargetElementTypes elementType, ExtractSuperclassDataModel analyser);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.ExtractSuperclassRefactoring : PullUpBaseRefactoring`2<ExtractSuperclassAnalyser, ExtractSuperclassDataModel> {
    public ExtractSuperclassRefactoring(ISolution solution, IRefactoringDriver driver, ExtractSuperclassDataModel dataModel);
    protected virtual IMove CreateUnsupportedRefactoring();
    protected virtual void CheckConflictsWithTargetClassName(SubProgressIndicator subPi);
    public virtual bool Execute(IProgressIndicator pi);
    protected virtual bool InitializeBaseType(SubProgressIndicator subPi);
    private ITypeElement CreateTargetTypeElement(List`1<ITypeParameter> parameters);
    private void CheckNewClassName(string newName);
    private string GetClassName(int parameters);
    protected virtual void CheckConflictsWithExistingElements(SubProgressIndicator pi);
    protected virtual IMove CreateRefactoring(InternalRefactoringLanguageService service, MoveMembersRefactoring`2<ExtractSuperclassAnalyser, ExtractSuperclassDataModel> refactoring);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.ExtractSuperclassRefactoring/<GetAllTargetTypes>d__10")]
protected virtual IEnumerable`1<ITypeElement> GetAllTargetTypes();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.ExtractSuperclassWorkflow : MoveWorkflow {
    [CompilerGeneratedAttribute]
private ExtractSuperclassDataModel <DataModel>k__BackingField;
    private ITreeNodePointer`1<IDeclaration> mySupportedDeclaration;
    public ExtractSuperclassDataModel DataModel { get; protected set; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public HelpId HelpKeyword { get; }
    public ExtractSuperclassWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public ExtractSuperclassDataModel get_DataModel();
    [CompilerGeneratedAttribute]
protected void set_DataModel(ExtractSuperclassDataModel value);
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual void UnsuccessfulFinish(IProgressIndicator pi);
    public virtual bool IsAvailable(IDataContext context);
    public virtual HelpId get_HelpKeyword();
    public virtual bool Initialize(IDataContext context);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
private void <SuccessfulFinish>b__16_0();
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.ImplExtractSuperclass.IExtractSuperclass {
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.IPullUp {
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.ISelectTypePartData {
    public IDeclaredElement DeclaredElement { get; }
    public IList`1<ITypeDeclaration> Declarations { get; }
    public abstract virtual IDeclaredElement get_DeclaredElement();
    public abstract virtual IList`1<ITypeDeclaration> get_Declarations();
    public abstract virtual void SetDeclaration(ITypeDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.PullUpAnalyzer : PullUpBaseAnalyzer {
    private JetHashSet`1<ITypeElement> myBaseInterfaces;
    private List`1<ITypeElement> myBaseClasses;
    private Dictionary`2<ITypeMember, OverrideInfo> myOverrideInfos;
    private TargetTypeWrapper myRootTargetTypeWrapper;
    private ITypeElement myTargetType;
    private TargetElementTypes myElementType;
    private TargetElementTypes myTargetElementType;
    private TargetTypeWrapper myTargetTargetTypeWrapper;
    public bool HasAbstractMembers { get; }
    public IEnumerable`1<ITypeElement> AllTypeElementsToMakeAbstract { get; }
    public PullUpAnalyzer(PullUpDataModel dataModel);
    public bool get_HasAbstractMembers();
    public List`1<ITypeElement> GetBaseClasses();
    public virtual void PrepareData(IMoveMembersExecuter executer, IProgressIndicator pi, ITypeElement targetType);
    private void CheckJumpOver(IMoveMembersExecuter executer, IProgressIndicator pi);
    private void CollectAllOverrides(IPsiServices psiServices, IProgressIndicator pi);
    public void CheckBaseClasses(IMoveMembersExecuter executer);
    private void CheckOtherBaseClasses(IMoveMembersExecuter executer);
    private ITypeMember FindOverrideOfTypeMember(ITypeElement element, DeclaredElementNode info);
    private void CheckBaseInterfaces();
    private void GetBaseInterfaces(PullUpChainItem item);
    private void CheckTargetTypeElement(IMoveMembersExecuter executer);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.PullUpAnalyzer/<get_AllTypeElementsToMakeAbstract>d__22")]
public virtual IEnumerable`1<ITypeElement> get_AllTypeElementsToMakeAbstract();
    public virtual List`1<IMethod> GetSuspiciousMethods();
    protected void CreateTypeParametersMap();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.PullUpChainItem : TargetTypeWrapper {
    private JetHashSet`1<ITypeElement> myAllBaseElements;
    [CompilerGeneratedAttribute]
private TargetElementTypes <ElementType>k__BackingField;
    public TargetElementTypes ElementType { get; }
    public PullUpChainItem(ITypeElement typeElement);
    public PullUpChainItem(ITypeElement typeElement, PullUpChainItem parent, bool isRoot);
    [CompilerGeneratedAttribute]
public TargetElementTypes get_ElementType();
    protected static TargetElementTypes ElementTypeOf(ITypeElement typeElement);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.PullUpDataModel : PullUpBaseDataModel {
    private MoveMembersDataProvider myDataProvider;
    private IRefactoringWorkflow myWorkflow;
    private Dictionary`2<PullUpMemberInfo, JetHashSet`1<PullUpChainItem>> myReachableMembersUp;
    [CompilerGeneratedAttribute]
private PullUpChainItem <RootTargetTypeWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PullUpChainItem> <BaseElements>k__BackingField;
    [CompilerGeneratedAttribute]
private PullUpChainItem <BaseType>k__BackingField;
    public PullUpChainItem RootTargetTypeWrapper { get; }
    public IList`1<PullUpChainItem> BaseElements { get; }
    public TargetTypeWrapper TargetTargetTypeWrapper { get; }
    public PullUpChainItem BaseType { get; public set; }
    public PullUpDataModel(ITypeElement ownerType, IRefactoringWorkflow workflow, MoveMembersDataProvider dataProvider);
    [CompilerGeneratedAttribute]
public PullUpChainItem get_RootTargetTypeWrapper();
    [CompilerGeneratedAttribute]
public IList`1<PullUpChainItem> get_BaseElements();
    public TargetTypeWrapper get_TargetTargetTypeWrapper();
    public PullUpChainItem GetSelectedTypeElement(string dataProviderTarget);
    private void FillBaseElements(PullUpChainItem rootTargetTypeWrapper);
    public virtual void InitializeMembers(Func`2<ITypeMember, bool> isMemberIncluded);
    private void CreateReachableMap();
    public virtual bool IsReferenced(DeclaredElementNode info);
    private static bool ImplementsInterface(DeclaredElementNode info, DeclaredElementNode memberInfo);
    private static void FillSetOfReachableMembers(ICollection`1<PullUpChainItem> set, IEnumerable`1<OverridableMemberInstance> members, PullUpChainItem item);
    protected virtual void AddMemberInfo(ITypeMember member, bool isIncluded);
    public virtual bool Validate();
    protected virtual void AddBaseTypeInfo(IDeclaredType declaredType, bool b);
    protected virtual bool FilterMembers(ITypeMember typeMember);
    public IRefactoringPage CommitFirstPage();
    [CompilerGeneratedAttribute]
public PullUpChainItem get_BaseType();
    [CompilerGeneratedAttribute]
public void set_BaseType(PullUpChainItem value);
    public void SetTargetTargetTypeWrapper(ITypeDeclaration typeDeclaration, Lifetime lifetime);
    public bool SetTargetElementInfo(PullUpChainItem targetElementInfo);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.PullUpMemberInfo : PullUpBaseMemberInfo {
    public PullUpMemberInfo(IDeclaredElement declaredElement, bool included, TargetElementTypes type, TargetElementTypes elementType, MoveDataModel analyser);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.PullUpRefactoring : PullUpBaseRefactoring`2<PullUpAnalyzer, PullUpDataModel> {
    public PullUpRefactoring(ISolution solution, IRefactoringDriver driver, PullUpDataModel dataModel);
    protected virtual void CheckConflictsWithTargetClassName(SubProgressIndicator subPi);
    protected virtual IMove CreateUnsupportedRefactoring();
    protected virtual IMove CreateRefactoring(InternalRefactoringLanguageService service, MoveMembersRefactoring`2<PullUpAnalyzer, PullUpDataModel> refactoring);
    protected virtual void CheckConflictsWithExistingElements(SubProgressIndicator pi);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.PullUpRefactoring/<GetAllTargetTypes>d__5")]
protected virtual IEnumerable`1<ITypeElement> GetAllTargetTypes();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPullUp.PullUpWorkflow : MoveWorkflow {
    [CompilerGeneratedAttribute]
private PullUpDataModel <DataModel>k__BackingField;
    public PullUpDataModel DataModel { get; protected set; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public HelpId HelpKeyword { get; }
    public string Title { get; }
    public PullUpWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PullUpDataModel get_DataModel();
    [CompilerGeneratedAttribute]
protected void set_DataModel(PullUpDataModel value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool IsAvailable(IDataContext context);
    public virtual HelpId get_HelpKeyword();
    public virtual bool Initialize(IDataContext context);
    private static bool HasBaseTypes(ITypeElement type);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual bool Validate();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
private IRefactoringPage <get_FirstPendingRefactoringPage>b__7_0(IProgressIndicator pi);
}
public interface JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.IPushDown {
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownAnalyser : MoveAnalyser {
    private PushDownDataModel myDataModel;
    [CompilerGeneratedAttribute]
private Dictionary`2<TargetTypeWrapper, SubstitutionMap> <SubstitutionMap>k__BackingField;
    public Dictionary`2<TargetTypeWrapper, SubstitutionMap> SubstitutionMap { get; protected set; }
    public IEnumerable`1<ITypeElement> AllTypeElementsToMakeAbstract { get; }
    public PushDownAnalyser(PushDownDataModel dataModel);
    [CompilerGeneratedAttribute]
public Dictionary`2<TargetTypeWrapper, SubstitutionMap> get_SubstitutionMap();
    [CompilerGeneratedAttribute]
protected void set_SubstitutionMap(Dictionary`2<TargetTypeWrapper, SubstitutionMap> value);
    public virtual IEnumerable`1<ITypeElement> get_AllTypeElementsToMakeAbstract();
    public virtual List`1<IMethod> GetSuspiciousMethods();
    public virtual void PrepareData(IMoveMembersExecuter executer, IProgressIndicator pi, ITypeElement targetType);
    protected void CreateTypeParametersMap();
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownBase : object {
    private ISolution mySolution;
    private IRefactoringDriver myDriver;
    private IRefactoringExecuter myExecuter;
    public IRefactoringDriver Driver { get; }
    public IMoveMembersExecuter Executer { get; }
    public ISolution Solution { get; }
    unknown IRefactoringDriver RefactoringDriver {public set; }
    protected PushDownBase(ISolution solution, IRefactoringDriver driver);
    public IRefactoringDriver get_Driver();
    public IMoveMembersExecuter get_Executer();
    public ISolution get_Solution();
    public sealed virtual void set_RefactoringDriver(IRefactoringDriver value);
    public sealed virtual void SetExecuter(IRefactoringExecuter refactoring);
    public abstract virtual bool CheckConflictsWithTargetClassName(ITypeElement element, string name);
    public abstract virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public abstract virtual MoveMembersHelper GetHelper();
    public sealed virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool name);
    public void GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownDataModel : MoveDataModel {
    [CompilerGeneratedAttribute]
private List`1<TargetTypeWithProjectFile> <InheritorsItems>k__BackingField;
    public List`1<TargetTypeWithProjectFile> InheritorsItems { get; }
    public IEnumerable`1<TargetTypeWithProjectFile> SelectedInheritorsItems { get; }
    public PushDownDataModel(ITypeElement initialTypeElement);
    public virtual void InitializeMembers(Func`2<ITypeMember, bool> isMemberIncluded);
    [CompilerGeneratedAttribute]
public List`1<TargetTypeWithProjectFile> get_InheritorsItems();
    public IEnumerable`1<TargetTypeWithProjectFile> get_SelectedInheritorsItems();
    private void FillInheritors();
    public virtual bool IsReferenced(DeclaredElementNode info);
    public virtual ITypeDeclaration GetTargetDeclaration(ITypeElement typeElement);
    protected virtual void AddMemberInfo(ITypeMember member, bool isIncluded);
    protected virtual void AddBaseTypeInfo(IDeclaredType declaredType, bool b);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownMemberInfo : MovedMemberInfo {
    [CompilerGeneratedAttribute]
private PushDownTypes <PushDownType>k__BackingField;
    public PushDownTypes PushDownType { get; private set; }
    public bool MakeSourceAbstract { get; }
    public bool MakeTargetOverride { get; }
    public PushDownMemberInfo(IDeclaredElement declaredElement, bool included, MoveDataModel analyser);
    [CompilerGeneratedAttribute]
public PushDownTypes get_PushDownType();
    [CompilerGeneratedAttribute]
private void set_PushDownType(PushDownTypes value);
    public virtual bool IsPureInstanceMove();
    public virtual void UpdateType();
    public virtual bool get_MakeSourceAbstract();
    public virtual bool get_MakeTargetOverride();
    public virtual bool MakeProtected();
    public virtual bool PerformCutDeclarations();
    public virtual bool MakeOverride();
    public PushDownTypes GetPushDownType();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownRefactoring : MoveMembersRefactoring`2<PushDownAnalyser, PushDownDataModel> {
    private Dictionary`2<ITypeElement, Dictionary`2<ITypeElement, ITypeElement>> myGenericTypesMap;
    private Dictionary`2<ITypeElement, Dictionary`2<IDeclaredElement, IDeclaredElement>> myTarget2MemberMap;
    private Dictionary`2<ITypeElement, Dictionary`2<IReference, BaseResolveResultImage>> myTarget2RefMap;
    private OneToSetMap`2<ITypeElement, DeclaredElementNode> myItemsDoNotPaste;
    public PushDownRefactoring(PushDownDataModel dataModel, ISolution solution, IRefactoringDriver driver);
    protected virtual IMove CreateUnsupportedRefactoring();
    protected virtual void MakeMembersProtected();
    protected virtual IMove CreateRefactoring(InternalRefactoringLanguageService service, MoveMembersRefactoring`2<PushDownAnalyser, PushDownDataModel> refactoring);
    protected virtual void CheckConflictsWithTargetClassName(SubProgressIndicator subPi);
    protected virtual void CheckConflictsWithExistingElements(SubProgressIndicator pi);
    protected virtual bool IgnoreConflictedMember(ITypeMember info, ITypeElement element);
    protected virtual bool NeedPasteIn(ITypeElement type, Pair`2<DeclaredElementNode, IDeclaration> pair);
    protected virtual void CollectMembersToMakeProtected();
    protected virtual void RestoreLocalReferences(SubProgressIndicator pi);
    protected virtual void RestoreOtherReference(IReference reference, BaseResolveResultImage resolveResultImage);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownRefactoring/<GetAllTargetTypes>d__15")]
protected virtual IEnumerable`1<ITypeElement> GetAllTargetTypes();
    public virtual void CreateTypeParametersMap();
    public virtual void SetRefID(Func`2<IReference, IReference> mapDelegate, ITypeElement targetTypeElement);
    public virtual void SetTypeID(ITypeElement oldTypeElement, ITypeElement newTypeElement, ITypeElement targetTypeElement);
    public virtual void SetMemberID(ITypeMember oldTypeMember, ITypeMember newTypeMember, ITypeElement targetTypeElement);
    public virtual IDictionary`2<ITypeElement, ITypeElement> GetTypeMap(ITypeElement targetType);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownRefactoring/<EnumerateAllTargetOrSingle>d__21")]
private IEnumerable`1<ITypeElement> EnumerateAllTargetOrSingle(ITypeElement targetTypeMember);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownRefactoring/<GetMemberImages>d__22")]
public virtual IEnumerable`1<IDeclaredElement> GetMemberImages(IDeclaredElement oldTypeMember, ITypeElement targetTypeMember);
}
public enum JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownTypes : Enum {
    public int value__;
    public static PushDownTypes Common;
    public static PushDownTypes Interface2Interface;
    public static PushDownTypes Abstract2Abstract;
    public static PushDownTypes Instance2Instance;
    public static PushDownTypes Virtual2Virtual;
    public static PushDownTypes Override2Override;
    public static PushDownTypes Instance2InstanceA;
    public static PushDownTypes Virtual2VirtualA;
    public static PushDownTypes Override2OverrideA;
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.ImplPushDown.PushDownWorkflow : MoveWorkflow {
    [CompilerGeneratedAttribute]
private PushDownDataModel <DataModel>k__BackingField;
    public PushDownDataModel DataModel { get; protected set; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public HelpId HelpKeyword { get; }
    public PushDownWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PushDownDataModel get_DataModel();
    [CompilerGeneratedAttribute]
protected void set_DataModel(PushDownDataModel value);
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool IsAvailable(IDataContext context);
    public virtual HelpId get_HelpKeyword();
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual bool CanRunOnSealed();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.UI.ExtractInterfacePage : ExtractParentPage {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public ExtractInterfacePage(ExtractInterfaceDataModel dataModel, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    protected virtual BeControl GetSecondColumnPresentation(Lifetime lt, MethodInfo e, CheckBoxListNodeProperties p);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.UI.ExtractParentPage : MoveMembersPage {
    public static string NameTextBoxId;
    public static string SiblingsRadioId;
    protected ExtractParentPage(MoveDataModel dataModel, Lifetime lifetime);
    protected virtual ValueTuple`2<BeControl, BeSizingType> GetUpperPanel();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.UI.ExtractSuperclassPage : ExtractParentPage {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public ExtractSuperclassPage(ExtractSuperclassDataModel dataModel, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.UI.MoveMembersPage : SingleBeRefactoringPage {
    protected MoveDataModel myDataModel;
    protected SimpleSignal myOnUpdate;
    protected ValueTuple`3[] Columns;
    public static string MembersGridId;
    public static string ToolbarMembersGridId;
    protected MoveMembersPage(MoveDataModel dataModel, Lifetime lifetime);
    protected abstract virtual ValueTuple`2<BeControl, BeSizingType> GetUpperPanel();
    public virtual BeControl GetPageContent();
    protected BeControl GetMembersPanel();
    protected virtual BeControl GetSecondColumnPresentation(Lifetime lt, MethodInfo e, CheckBoxListNodeProperties p);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.UI.PullUpPage : MoveMembersPage {
    public static string BaseTypeGridId;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; protected set; }
    public PullUpPage(MoveDataModel dataModel, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    protected virtual ValueTuple`2<BeControl, BeSizingType> GetUpperPanel();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.UI.PushDownPage : MoveMembersPage {
    public static string InheritorsGridId;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public PushDownPage(PushDownDataModel dataModel, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    protected virtual ValueTuple`2<BeControl, BeSizingType> GetUpperPanel();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.DependenciesCollector`1 : object {
    private Dictionary`2<MEMBER_INFO, JetHashSet`1<MEMBER_INFO>> myDependenciesMap;
    private MEMBER_INFO myInfoCurrent;
    public bool ProcessingIsFinished { get; }
    public DependenciesCollector`1(Dictionary`2<MEMBER_INFO, JetHashSet`1<MEMBER_INFO>> dependenciesMap, MEMBER_INFO info);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    private void TryAddDependency(MEMBER_INFO infoReferenced);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.ExtractInterfaceSubstitutionMap : SubstitutionMap {
    private ISubstitution myBaseSubstitution;
    private List`1<ITypeParameter> myGetAllParameters;
    public ExtractInterfaceSubstitutionMap(ITypeElement source, ITypeElement target, ISubstitution substitution);
    public virtual List`1<ITypeParameter> GetAllParameters();
    private static void AddTypeParameters(ISubstitution substitution, JetHashSet`1<ITypeParameter> allSimpleParameters);
    public virtual ITypeElement GetParameterImage(ITypeParameter parameter);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.MemberListDataProvider : object {
    private string mySelectedMembers;
    private string myAbstract;
    public MemberListDataProvider(string selectedMembers, string abstract);
    public void Fill(IList`1<DeclaredElementNode> members);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.OverrideInfo : object {
    private bool myDeclaredAbstract;
    private ITypeMember myOverriddenMember;
    public bool DeclaredAbstract { get; }
    public ITypeMember OverriddenMember { get; }
    public OverrideInfo(bool declaredAbstract, ITypeMember overriddenMember);
    public bool get_DeclaredAbstract();
    public ITypeMember get_OverriddenMember();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.PullUpSubstitutionMap : SubstitutionMap {
    private List`1<ITypeParameter> myGetAllParameters;
    public PullUpSubstitutionMap(ITypeElement from, ITypeElement to);
    public virtual List`1<ITypeParameter> GetAllParameters();
    public virtual ITypeElement GetParameterImage(ITypeParameter parameter);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.PushDownSubstitutionMap : SubstitutionMap {
    private List`1<ITypeParameter> myGetAllParameters;
    public PushDownSubstitutionMap(ITypeElement from, ITypeElement to);
    public virtual List`1<ITypeParameter> GetAllParameters();
    public virtual ITypeElement GetParameterImage(ITypeParameter parameter);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.ReferenceCollector : object {
    private IReferenceConsumer myOwner;
    public bool ProcessingIsFinished { get; }
    public ReferenceCollector(IReferenceConsumer owner);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
}
public abstract class JetBrains.ReSharper.Refactorings.MoveMembers.Util.SubstitutionMap : object {
    protected HybridCollection`1<ISubstitution> mySubstList;
    public abstract virtual List`1<ITypeParameter> GetAllParameters();
    public abstract virtual ITypeElement GetParameterImage(ITypeParameter parameter);
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.TypeHierarchyDataProvider : object {
    private PullUpChainItem myRootChainItem;
    private string myTargetPath;
    public TypeHierarchyDataProvider(PullUpChainItem rootChainItem, string targetPath);
    public PullUpChainItem FindChainItem();
}
public class JetBrains.ReSharper.Refactorings.MoveMembers.Util.TypeParametersCollector : object {
    private JetHashSet`1<ITypeParameter> myAllParameters;
    private JetHashSet`1<ITypeParameter> myUsedParameters;
    private ISubstitution myFakeSubst;
    [NotNullAttribute]
public List`1<ITypeParameter> UsedParameters { get; }
    public bool ProcessingIsFinished { get; }
    public TypeParametersCollector(JetHashSet`1<ITypeParameter> allParameters, ISubstitution fakeSubst);
    public List`1<ITypeParameter> get_UsedParameters();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public interface JetBrains.ReSharper.Refactorings.MoveStaticMembers.Impl.IMoveStaticMembersBatchDataProvider {
    public abstract virtual void SelectMembers(IEnumerable`1<StaticMemberInfo> memberInfos);
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetTargetType(IPsiModule module);
}
public class JetBrains.ReSharper.Refactorings.MoveStaticMembers.Impl.StaticMemberInfo : DeclaredElementNode {
    [CanBeNullAttribute]
private ITypeMember myMovedDeclaredElement;
    private IDeclaredElementPointer`1<ITypeMember> myMovedDeclaredElementPointer;
    [CompilerGeneratedAttribute]
private AccessRights <AccessRights>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IDeclaration> <Declarations>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<ITypeParameter> <OldTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<ITypeParameter> <UsedTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeMember <OldDeclaredElement>k__BackingField;
    public AccessRights AccessRights { get; public set; }
    public List`1<IDeclaration> Declarations { get; public set; }
    public JetHashSet`1<ITypeParameter> OldTypeParameters { get; }
    public JetHashSet`1<ITypeParameter> UsedTypeParameters { get; }
    [CanBeNullAttribute]
public ITypeMember MovedDeclaredElement { get; public set; }
    public ITypeMember OldDeclaredElement { get; }
    public StaticMemberInfo(ITypeMember typeMember);
    [CompilerGeneratedAttribute]
public AccessRights get_AccessRights();
    [CompilerGeneratedAttribute]
public void set_AccessRights(AccessRights value);
    [CompilerGeneratedAttribute]
public List`1<IDeclaration> get_Declarations();
    [CompilerGeneratedAttribute]
public void set_Declarations(List`1<IDeclaration> value);
    [CompilerGeneratedAttribute]
public JetHashSet`1<ITypeParameter> get_OldTypeParameters();
    [CompilerGeneratedAttribute]
public JetHashSet`1<ITypeParameter> get_UsedTypeParameters();
    public ITypeMember get_MovedDeclaredElement();
    public void set_MovedDeclaredElement(ITypeMember value);
    [CompilerGeneratedAttribute]
public ITypeMember get_OldDeclaredElement();
    public bool MoveIntoItself(ITypeElement element);
}
public class JetBrains.ReSharper.Refactorings.MoveStaticMembers.Impl.TestMoveStaticMemberBatchDataProvider : object {
    private string mySelectedMembers;
    private JetHashSet`1<int> myIncluded;
    private string myType;
    public TestMoveStaticMemberBatchDataProvider(string selectedMembers, string type);
    private void Init();
    public sealed virtual void SelectMembers(IEnumerable`1<StaticMemberInfo> memberInfos);
    public sealed virtual ITypeElement GetTargetType(IPsiModule module);
}
public class JetBrains.ReSharper.Refactorings.MoveStaticMembers.Impl.TypeParametersCollector : object {
    private StaticMemberInfo myTypeMemberCopy;
    public bool ProcessingIsFinished { get; }
    public TypeParametersCollector(StaticMemberInfo typeMemberCopy);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.MoveStaticMembers.MoveStaticDataModel : object {
    private ISolution mySolution;
    private ITypeElement mySourceElement;
    private IDeclaredElementPointer`1<ITypeElement> mySourceElementPointer;
    [CanBeNullAttribute]
private ITypeElement myTargetElement;
    [CanBeNullAttribute]
private IDeclaredElementPointer`1<ITypeElement> myTargetElementPointer;
    [CompilerGeneratedAttribute]
private List`1<StaticMemberInfo> <MemberInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeDeclaration <TargetDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <NewFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <OwnerProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewNamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFolder <NewFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceName>k__BackingField;
    private string myTargetText;
    public string NewFileExtension { get; }
    public List`1<StaticMemberInfo> MemberInfos { get; public set; }
    public ITypeElement SourceElement { get; public set; }
    public ITypeElement TargetElement { get; public set; }
    [CanBeNullAttribute]
public ITypeDeclaration TargetDeclaration { get; public set; }
    public IEnumerable`1<StaticMemberInfo> IncludedMembers { get; }
    public IProjectFile NewFile { get; public set; }
    [CanBeNullAttribute]
public IProjectFile OwnerProjectFile { get; public set; }
    public string NewNamespaceName { get; protected set; }
    public string NewTypeName { get; public set; }
    public IProjectFolder NewFolder { get; public set; }
    public PsiLanguageType Language { get; public set; }
    public string SourceName { get; }
    public string TargetText { get; public set; }
    public MoveStaticDataModel(ITypeElement typeElement, IEnumerable`1<ITypeMember> initialElements, IProjectFile projectFile, IMoveStaticMembersBatchDataProvider provider, Lifetime lifetime);
    public virtual string get_NewFileExtension();
    [CompilerGeneratedAttribute]
public void set_MemberInfos(List`1<StaticMemberInfo> value);
    [CompilerGeneratedAttribute]
public List`1<StaticMemberInfo> get_MemberInfos();
    public ITypeElement get_SourceElement();
    public void set_SourceElement(ITypeElement value);
    public ITypeElement get_TargetElement();
    public void set_TargetElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public ITypeDeclaration get_TargetDeclaration();
    [CompilerGeneratedAttribute]
public void set_TargetDeclaration(ITypeDeclaration value);
    public virtual IEnumerable`1<StaticMemberInfo> get_IncludedMembers();
    [CompilerGeneratedAttribute]
public IProjectFile get_NewFile();
    [CompilerGeneratedAttribute]
public void set_NewFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public IProjectFile get_OwnerProjectFile();
    [CompilerGeneratedAttribute]
public void set_OwnerProjectFile(IProjectFile value);
    [CompilerGeneratedAttribute]
public string get_NewNamespaceName();
    [CompilerGeneratedAttribute]
protected void set_NewNamespaceName(string value);
    [CompilerGeneratedAttribute]
public string get_NewTypeName();
    [CompilerGeneratedAttribute]
public void set_NewTypeName(string value);
    [CompilerGeneratedAttribute]
public IProjectFolder get_NewFolder();
    [CompilerGeneratedAttribute]
public void set_NewFolder(IProjectFolder value);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(PsiLanguageType value);
    [CompilerGeneratedAttribute]
public string get_SourceName();
    public string get_TargetText();
    public void set_TargetText(string value);
    public void PreExecute();
    public static bool CanMove(ITypeMember typeMember);
    private void InitTypeMembers(IEnumerable`1<ITypeMember> initialElements);
    public bool TestMemberInfos_AnyIncluded();
    public Tuple`2<ValidatorSeverity, RichText> TestMemberInfosNoMoveIntoItself(ITypeElement element);
    public Tuple`2<ValidatorSeverity, RichText> TestTypeElement(ITypeElement typeElement);
    public virtual void ChooseFolderForNewClass(string typeName);
}
public abstract class JetBrains.ReSharper.Refactorings.MoveStaticMembers.MoveStaticMembers : RefactoringExecBase`2<MoveStaticMembersWorkflow, MoveStaticMembersRefactoring> {
    protected MoveStaticMembers(MoveStaticMembersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual void RemoveOldDeclaration(IDeclaration declaration);
    [CanBeNullAttribute]
public abstract virtual Dictionary`2<ITypeParameter, ITypeParameter> PasteDeclaration(StaticMemberInfo copy, ITypeMember& newTypeMember);
    protected void PutOldTypeParameters(StaticMemberInfo memberInfo, Dictionary`2<ITypeParameter, ITypeParameter> ret, ITypeMember newTypeMember);
    public virtual void SetNotPartial(ITypeMember member);
    public virtual ITypeDeclaration CreateTypeDeclaration(IFile file);
    public virtual bool ReferenceShouldBeProcessed(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.MoveStaticMembers.MoveStaticMembersHelper : object {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
}
public class JetBrains.ReSharper.Refactorings.MoveStaticMembers.MoveStaticMembersPage : SingleBeRefactoringPage {
    public static string StaticMembersGrid;
    public static string TargetName;
    private MoveStaticDataModel myDataModel;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public MoveStaticMembersPage(MoveStaticDataModel dataModel, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    public virtual bool RefreshContents(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__12_0(string v);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.MoveStaticMembers.MoveStaticMembersProvider : MoveWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.MoveStaticMembers.MoveStaticMembersRefactoring : DrivenRefactoring`2<MoveStaticMembersWorkflow, MoveStaticMembers> {
    private Dictionary`2<IReference, ResolveResultImage> myLocalReferences;
    private Dictionary`2<IReference, ResolveResultImage> myOtherReferences;
    private Dictionary`2<ITypeElement, ITypeElement> myOtherTypesMap;
    private Dictionary`2<StaticMemberInfo, Dictionary`2<ITypeElement, ITypeElement>> myTypesMap;
    private Dictionary`2<ITypeMember, ITypeMember> myOld2NewMember;
    private Dictionary`2<IReference, DeclaredElementInstance> mySimplyBoundReferences;
    private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private ITypeElement <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeDeclaration <KnownDeclaration>k__BackingField;
    [CanBeNullAttribute]
private StaticMemberInfo myCurInfo;
    public ITypeElement TargetType { get; private set; }
    [CanBeNullAttribute]
public ITypeDeclaration KnownDeclaration { get; private set; }
    public MoveStaticMembersRefactoring(MoveStaticMembersWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    private ITypeElement ID(ITypeElement element);
    [CompilerGeneratedAttribute]
public ITypeElement get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(ITypeElement value);
    [CompilerGeneratedAttribute]
public ITypeDeclaration get_KnownDeclaration();
    [CompilerGeneratedAttribute]
private void set_KnownDeclaration(ITypeDeclaration value);
    public virtual bool Execute(IProgressIndicator pi);
    private ITypeDeclaration CreateDeclaration();
    private void SearchConflictsWithExistingMembers(IProgressIndicator pi);
    private void StoreTargetTypeReferences(IProgressIndicator pi);
    private void UpdateReferences(IProgressIndicator pi);
    private static IReference TryRemoveQualification(IReference reference);
    private static bool IsReferenceName(ITreeNode element);
    private void RestoreLocalReference(IReference reference, ResolveResultImage resolveResultImage);
    private void PasteDeclarations(IProgressIndicator pi);
    private void GetItem(SubProgressIndicator pi);
    private void StoreOtherReferences(IProgressIndicator pi);
    [CanBeNullAttribute]
private IDeclaredElement NewTypeMemberDelegate(IDeclaredElement element);
    [NotNullAttribute]
private Func`2<ITypeElement, ITypeElement> RightTypeMap(StaticMemberInfo foundStaticMember);
    [NotNullAttribute]
private Func`2<ITypeElement, ITypeElement> LeftTypeMap(StaticMemberInfo foundStaticMember);
    private void StoreInternalReferences(IProgressIndicator pi);
    protected virtual MoveStaticMembers CreateRefactoringInternal(InternalRefactoringLanguageService service);
    public sealed virtual void InitRef(IReference reference);
    [CanBeNullAttribute]
private StaticMemberInfo FindIncludedMember(IReference reference);
    public sealed virtual void SetRefID(Func`2<IReference, IReference> mapDelegate, ITypeElement targetTypeElement);
    public sealed virtual void SetRefID(Func`2<IReference, IReference> mapDelegate);
    public sealed virtual void SetTypeID(ITypeElement oldTypeElement, ITypeElement newTypeElement);
    public sealed virtual void SetTypeID(ITypeElement oldTypeElement, ITypeElement newTypeElement, ITypeElement targetTypeElement);
    public sealed virtual void SetMemberID(ITypeMember oldTypeMember, ITypeMember newTypeMember, ITypeElement targetTypeElement);
    public sealed virtual IDictionary`2<ITypeElement, ITypeElement> GetTypeMap(ITypeElement targetType);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.MoveStaticMembers.MoveStaticMembersRefactoring/<GetMemberImages>d__42")]
public sealed virtual IEnumerable`1<IDeclaredElement> GetMemberImages(IDeclaredElement oldTypeMember, ITypeElement targetTypeMember);
    [NotNullAttribute]
protected virtual MoveStaticMembers CreateUnsupportedRefactoring();
}
public class JetBrains.ReSharper.Refactorings.MoveStaticMembers.MoveStaticMembersWorkflow : DrivenRefactoringWorkflow2`1<MoveStaticMembersHelper> {
    protected IMoveStaticMembersBatchDataProvider Provider;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private MoveStaticDataModel <Model>k__BackingField;
    public PsiLanguageType LanguageType { get; public set; }
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public HelpId HelpKeyword { get; }
    public MoveStaticDataModel Model { get; protected set; }
    public MoveStaticMembersWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
public void set_LanguageType(PsiLanguageType value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public MoveStaticDataModel get_Model();
    [CompilerGeneratedAttribute]
protected void set_Model(MoveStaticDataModel value);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual void SetProvider(IMoveStaticMembersBatchDataProvider value);
    protected bool IsAvailable(IDataContext context, IList`1& typeMembers, ITypeElement& ownerType, IProjectFile& projectFile);
    protected virtual bool CanMove(ITypeMember typeMember);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual MoveStaticMembersHelper CreateUnsupportedHelper();
    protected virtual MoveStaticMembersHelper CreateHelper(IRefactoringLanguageService service);
    [CompilerGeneratedAttribute]
private bool <IsAvailable>b__22_2(PsiLanguageType x);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.MoveToOuterScopeProvider : MoveWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public interface JetBrains.ReSharper.Refactorings.MoveTypeToOuterScope.IMoveTypeToOuterScope {
    public abstract virtual bool NeedsTypeParameterOfOuterClass(ITypeParameter parameter, IDeclaration declaration);
    public abstract virtual void SaveLocalReferences(ICollection`1<IDeclaration> declarations);
    public abstract virtual Pair`2<IDeclaration, IDeclaration> CutDeclaration(IDeclaration typeDeclaration);
    public abstract virtual void PasteDeclarations(Pair`2<IDeclaration, IDeclaration> pair);
    public abstract virtual void RestoreLocalReferences(ICollection`1<IDeclaration> declarations);
    public abstract virtual bool IsContextUnsafe(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.MoveTypeToOuterScope.MoveInnerClassDataModel : object {
    private ITypeElement myTypeElement;
    private IDeclaredElementPointer`1<ITypeElement> myTypeElementPointer;
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElementToNavigate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IDeclaration, ICreateNewFileTarget> <TargetContextsMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    public ITypeElement TypeElementToNavigate { get; public set; }
    public ITypeElement TypeElement { get; }
    public string NewName { get; public set; }
    public Dictionary`2<IDeclaration, ICreateNewFileTarget> TargetContextsMap { get; }
    public bool NonInteractive { get; public set; }
    public MoveInnerClassDataModel(ITypeElement declaredElement, MoveInnerClassTestDataProvider dataProvider, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElementToNavigate();
    [CompilerGeneratedAttribute]
public void set_TypeElementToNavigate(ITypeElement value);
    public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IDeclaration, ICreateNewFileTarget> get_TargetContextsMap();
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_NonInteractive(bool value);
}
public class JetBrains.ReSharper.Refactorings.MoveTypeToOuterScope.MoveInnerClassTestDataProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SearchInComments>k__BackingField;
    public string Name { get; }
    public bool SearchInComments { get; }
    public MoveInnerClassTestDataProvider(string name, bool searchInComments);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_SearchInComments();
}
public abstract class JetBrains.ReSharper.Refactorings.MoveTypeToOuterScope.MoveTypeToOuterScopeBase`2 : object {
    [CompilerGeneratedAttribute]
private MoveTypeToOuterScopeRefactoring <Executer>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <RefactoringDriver>k__BackingField;
    public MoveTypeToOuterScopeRefactoring Executer { get; }
    private IRefactoringDriver RefactoringDriver { get; public set; }
    protected MoveTypeToOuterScopeBase`2(MoveTypeToOuterScopeRefactoring refactoring);
    [CompilerGeneratedAttribute]
public MoveTypeToOuterScopeRefactoring get_Executer();
    public sealed virtual Pair`2<IDeclaration, IDeclaration> CutDeclaration(IDeclaration typeDeclaration);
    public sealed virtual bool NeedsTypeParameterOfOuterClass(ITypeParameter parameter, IDeclaration declaration);
    public virtual void PasteDeclarations(Pair`2<IDeclaration, IDeclaration> declarationPair);
    protected virtual void RemoveNewKeyword(TTypeDeclaration declaration);
    [CompilerGeneratedAttribute]
private IRefactoringDriver get_RefactoringDriver();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RefactoringDriver(IRefactoringDriver value);
    public sealed virtual void RestoreLocalReferences(ICollection`1<IDeclaration> declarations);
    public virtual bool IsContextUnsafe(ITreeNode element);
    public sealed virtual void SaveLocalReferences(ICollection`1<IDeclaration> declarations);
    private void PatchAccessRights(TTypeDeclaration copy, TMemberOwnerDeclaration oldContainer);
    protected abstract virtual TMemberOwnerDeclaration GetContainingTypeDeclaration(TTypeDeclaration declaration);
    protected abstract virtual TTypeDeclaration PasteDeclaration(TTypeDeclaration declaration, TMemberOwnerDeclaration oldContainingDeclaration);
    protected abstract virtual AccessRights GetAccessRights(TTypeDeclaration typeDeclaration);
    protected abstract virtual AccessRights GetAccessRights(TMemberOwnerDeclaration typeDeclaration);
    protected abstract virtual void SetAccessRights(TTypeDeclaration typeDeclaration, AccessRights accessRights);
    protected abstract virtual TTypeDeclaration CutDeclaration(TTypeDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.MoveTypeToOuterScope.MoveTypeToOuterScopeRefactoring : object {
    private IRefactoringDriver myRefactoringDriver;
    private LanguageMapOfRefactoring`1<IMoveTypeToOuterScope> myExec;
    private ITypeElement myTypeElement;
    private IPsiServices myPsiServices;
    private IPsiModule myPsiModule;
    private bool myIsCaseSensitiveName;
    private string myNewShortName;
    private ITypeElement myContainingTypeElement;
    private string myTargetNamespaceName;
    private ITypeElement myTargetClass;
    private IList`1<IReference> myReferences;
    private ClrTypeName myNewClrName;
    private ITypeElement myNewTypeElement;
    private IList`1<ITypeParameter> myNeededTypeParametersOfOuterClass;
    private ClassesHiddenByNewClassFixer myClassesHiddenByNewClassFixer;
    private List`1<Nullable`1<int>> myPositionsOfOldTypeParameters;
    private Dictionary`2<ITypeElement, ITypeElement> myExtraTypeParametersMap;
    private Dictionary`2<ITypeElement, ITypeElement> myOldToNewTypeElement;
    private Dictionary`2<IReference, ResolveResultImage> myOuterReferenceImages;
    public bool IsFromUnsafeContext;
    private static Key ourReferenceSearchKey;
    [CompilerGeneratedAttribute]
private Dictionary`2<IReference, ResolveResultImage> <LocalReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TargetTopLevelScope>k__BackingField;
    [CompilerGeneratedAttribute]
private MoveTypeToOuterScopeWorkflow <Workflow>k__BackingField;
    public IClrTypeName NewClrName { get; }
    public IList`1<ITypeParameter> NeededTypeParametersOfOuterClass { get; }
    public Dictionary`2<IReference, ResolveResultImage> LocalReferences { get; public set; }
    public Dictionary`2<ITypeElement, ITypeElement> OldToNewTypeElement { get; }
    public bool TargetTopLevelScope { get; }
    public MoveTypeToOuterScopeWorkflow Workflow { get; }
    public MoveTypeToOuterScopeRefactoring(MoveInnerClassDataModel dataModel, IRefactoringDriver refactoringDriver, MoveTypeToOuterScopeWorkflow workflow);
    private static MoveTypeToOuterScopeRefactoring();
    public IClrTypeName get_NewClrName();
    public IList`1<ITypeParameter> get_NeededTypeParametersOfOuterClass();
    [CompilerGeneratedAttribute]
public Dictionary`2<IReference, ResolveResultImage> get_LocalReferences();
    [CompilerGeneratedAttribute]
public void set_LocalReferences(Dictionary`2<IReference, ResolveResultImage> value);
    public Dictionary`2<ITypeElement, ITypeElement> get_OldToNewTypeElement();
    [CompilerGeneratedAttribute]
public bool get_TargetTopLevelScope();
    [CompilerGeneratedAttribute]
public MoveTypeToOuterScopeWorkflow get_Workflow();
    public sealed virtual bool Execute(IProgressIndicator pi);
    private void EnsureDataModelDeclarationsValidity();
    private void MapContainingTypeTypeParameters(IDictionary`2<ITypeElement, ITypeElement> recoverMap, int typeParametersCount);
    private void AnalyzeNeededTypeParameters();
    private void RebindReferences(IProgressIndicator pi);
    private void RestoreLocalReferences();
    private ITypeElement MoveDeclarations();
    private void UpdateLocalReferences(ReferenceIdentitySaver saver);
    private void SaveLocalReferences();
    private void SearchReferences(IProgressIndicator pi);
    public static void RestoreReferenceFromImage(IRefactoringDriver driver, IReference reference, ResolveResultImage resolveResultImage, string descr);
    public ITypeElement LeftTypeMap(ITypeElement element);
    public ITypeElement RightTypeMap(ITypeElement element);
    private ITypeElement LeftTypeMapOuter(ITypeElement element);
    private ITypeElement RightTypeMapOuter(ITypeElement element);
    public IDeclaredElement NewtypeMember(IDeclaredElement element);
    [CompilerGeneratedAttribute]
private IMoveTypeToOuterScope <.ctor>b__21_0(IRefactoringLanguageService service);
}
public class JetBrains.ReSharper.Refactorings.MoveTypeToOuterScope.MoveTypeToOuterScopeWorkflow : DrivenRefactoringWorkflow {
    private MoveInnerClassTestDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private MoveInnerClassDataModel <DataModel>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public string Title { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public HelpId HelpKeyword { get; }
    public MoveInnerClassDataModel DataModel { get; public set; }
    public MoveTypeToOuterScopeWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual string get_Title();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public MoveInnerClassDataModel get_DataModel();
    [CompilerGeneratedAttribute]
public void set_DataModel(MoveInnerClassDataModel value);
    public bool IsAvailableEx(IDataContext context, ITypeElement& declaredElement);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public void SetDataProvider(MoveInnerClassTestDataProvider moveInnerClassTestDataProvider);
}
public class JetBrains.ReSharper.Refactorings.MoveTypeToOuterScope.UI.MoveTypeToOuterPage : SingleBeRefactoringPage {
    private MoveInnerClassDataModel myDataModel;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public static string TargetName;
    [CompilerGeneratedAttribute]
private string <PageDescription>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public string PageDescription { get; }
    public MoveTypeToOuterPage(MoveInnerClassDataModel model, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string get_PageDescription();
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__15_0(string v);
}
public interface JetBrains.ReSharper.Refactorings.ParamsModifier.IParamsModifierRefactoring {
}
public interface JetBrains.ReSharper.Refactorings.ParamsModifier.IParamsModifierWorkflowProvider {
}
public abstract class JetBrains.ReSharper.Refactorings.ParamsModifier.ParamsModifierConvertBase : ConvertBase`3<IParametersOwner, ParamsModifierWorkflow, IParamsModifierRefactoring> {
    protected ParamsModifierConvertBase(ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool InitialValidate();
}
public class JetBrains.ReSharper.Refactorings.ParamsModifier.ParamsModifierRefactoring : ConvertRefactoring`3<IParametersOwner, ParamsModifierWorkflow, ParamsModifierConvertBase> {
    protected string Caption { get; }
    public ParamsModifierRefactoring(IParametersOwner parametersOwner, ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual string get_Caption();
    protected virtual ParamsModifierConvertBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    protected virtual ParamsModifierConvertBase CreateUnsupportedRefactoring();
    public static IRefactoringExecuter CreateForOverridable(TElement element, ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver refactoringDriver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.ParamsModifier.ParamsModifierWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private bool <setParams>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDeclaredElementPointer`1<IParameter> myParameter;
    public bool SetParam { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public bool MightModifyManyDocuments { get; }
    [NullableAttribute("2")]
public IRefactoringPage FirstPendingRefactoringPage { get; }
    public string Title { get; }
    public ParamsModifierWorkflow(ISolution solution, string actionId, bool setParams);
    public bool get_SetParam();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual bool get_MightModifyManyDocuments();
    [NullableContextAttribute("2")]
public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual string get_Title();
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailable(IDataContext context, IParameter& parameter);
    [NullableContextAttribute("2")]
public static IParameter TryGetParamsParameterIfAvailable(IDeclaredElement declaredElement, bool setParams);
    public virtual bool Initialize(IDataContext context);
    public virtual bool Validate();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    [CompilerGeneratedAttribute]
internal static bool <TryGetParamsParameterIfAvailable>g__CanBeParamsParameter|18_0(IParameter parameter);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "RemoveParamsModifierActionText")]
public class JetBrains.ReSharper.Refactorings.ParamsModifier.RemoveParamsModifierAction : ExtensibleRefactoringAction`1<IParamsModifierWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ParamsModifier.RemoveParamsModifierProvider : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ParamsModifier.RemoveParamsModifierProvider/<CreateWorkflow>d__0")]
public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "SetParamsModifierActionText")]
public class JetBrains.ReSharper.Refactorings.ParamsModifier.SetParamsModifierAction : ExtensibleRefactoringAction`1<IParamsModifierWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.ParamsModifier.SetParamsModifierProvider : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.ParamsModifier.SetParamsModifierProvider/<CreateWorkflow>d__0")]
public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.PostRename.PostRenameModel.NameChangeInfo : object {
    [CompilerGeneratedAttribute]
private string <OldName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ITreeGridNode> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Included>k__BackingField;
    public string OldName { get; }
    public IProperty`1<string> NewName { get; }
    public List`1<ITreeGridNode> Children { get; public set; }
    public bool Included { get; public set; }
    public NameChangeInfo(string oldName, string newName, IList`1<DerivedElement> elements, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public string get_OldName();
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_NewName();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ITreeGridNode> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Children(List`1<ITreeGridNode> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Included();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Included(bool value);
}
public class JetBrains.ReSharper.Refactorings.PostRename.PostRenameModel.NameChangesDataModel : object {
    [CompilerGeneratedAttribute]
private IList`1<NameChangeInfo> <Changes>k__BackingField;
    public IList`1<NameChangeInfo> Changes { get; }
    [CompilerGeneratedAttribute]
public IList`1<NameChangeInfo> get_Changes();
    public void SetDeclaredElements(IList`1<DerivedElement> derivedElements, Lifetime lifetime);
    public void Reload();
}
public enum JetBrains.ReSharper.Refactorings.PostRename.PostRenameModel.NameChangeState : Enum {
    public int value__;
    public static NameChangeState Enabled;
    public static NameChangeState Disabled;
    public static NameChangeState Undefined;
}
public class JetBrains.ReSharper.Refactorings.Properties.AssemblyReferenceClass_PsiFeaturesNewRefactorings : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Refactorings.Properties.Resources : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string AdjustNamespacesPage_Description_Please_review_files_that_have_inconsistent_namespace_names { get; }
    public static string AdjustNamespacesPage_Description_No_files_were_found_with_inconsistent_namespaces { get; }
    public static string AdjustNamespacesPage_Title_Inconsistent_files_review { get; }
    public static string AdjustNamespacesPage_Title_Nothing_to_fix { get; }
    public static string Anonymous2DeclaredWindow_Description_Specify_parameters_of_new_type_declaration___ { get; }
    public static string Anonymous2DeclaredWindow_Title_Configure_type { get; }
    public static string ChangeSignaturePage_Title { get; }
    public static string ChangeSignaturePage_Description { get; }
    public static string TypeSuggestionPage_Title_Specify_unresolved_types { get; }
    public static string TypeSuggestionPage_Description { get; }
    public static string MakeStaticPage_Title { get; }
    public static string MakeStaticPage_Description { get; }
    public static string ExtractClassFromParamsControl_Description { get; }
    public static string ExtractClassFromParamsControl_Title { get; }
    public static string Constructor2FactoryMethodWindow_Description { get; }
    public static string Constructor2FactoryMethodWindow_Title { get; }
    public static string CopyTypePage_Description { get; }
    public static string CopyTypePage_Title { get; }
    public static string EncapsulateFieldPage_Title { get; }
    public static string EncapsulateFieldPage_Description { get; }
    public static string ExtractMethodPage_Title { get; }
    public static string ExtractMethodPage_Description { get; }
    public static string VBFunction2PropertyPage_Title { get; }
    public static string VBFunction2PropertyPage_Description { get; }
    public static string InlineMethodWindow_Description { get; }
    public static string InlineMethodWindow_Title { get; }
    public static string IntroFieldWindow_Title { get; }
    public static string IntroFieldWindow_Description { get; }
    public static string IntroduceParameterWindow_Description { get; }
    public static string IntroduceParameterWindow_Title { get; }
    public static string TransformOutParameters_Description { get; }
    public static string TransformOutParameters_Title { get; }
    public static string MakeMethodNonStaticPage_Title { get; }
    public static string MakeMethodNonStaticPage_Description { get; }
    public static string ConflictsPage_Title { get; }
    public static string ConflictsPage_Description_ReviewProblems { get; }
    public static string ConflictsPage_Description_CanNotExecute { get; }
    public static string MoveIntoMatchingFilesPage_Title { get; }
    public static string MoveIntoMatchingFilesPage_Description { get; }
    public static string MoveToNamespacePage_Title { get; }
    public static string MoveFileRemoveEmptyFilePage_Title { get; }
    public static string MoveFileRemoveEmptyFilePage_Description { get; }
    public static string MoveToFilePage_Description { get; }
    public static string MoveToFilePage_Title { get; }
    public static string MoveTypeToOuterScopePage_Title { get; }
    public static string MoveTypeToOuterScopePage_Description { get; }
    public static string ExtractInterfaceWindow_Title { get; }
    public static string ExtractInterfaceWindow_Description { get; }
    public static string SelectTypePartWindow_Description { get; }
    public static string SelectTypePartWindow_Title { get; }
    public static string MoveStaticMembersControl_Title { get; }
    public static string MoveStaticMembersControl_Description { get; }
    public static string RenameDerived_Title { get; }
    public static string RenameDerived_Title_UsageChanged { get; }
    public static string RenameDerived_Title_UsagesChanged { get; }
    public static string Property2FunctionWindow_Title { get; }
    public static string Property2FunctionWindow_Description { get; }
    public static string RenameNamespaceControl_Title { get; }
    public static string RenameNamespaceControl_Description { get; }
    public static string SafeDeletePageOverridableMember_Title { get; }
    public static string SafeDeletePageOverridableMember_Description { get; }
    public static string SafeDeletePageReplaceTypeUsages_Description { get; }
    public static string SafeDeletePageReplaceTypeUsages_Title { get; }
    public static string UseBaseTypeMainWindow_Title { get; }
    public static string UseBaseTypeMainWindow_Description { get; }
    public static string ConflictsPage_Description { get; }
    public static string SafeDeleteFolderPage_Description { get; }
    public static string SafeDeleteFolderPage_Title { get; }
    public static string SafeDeleteProjectsPage_Description { get; }
    public static string SafeDeleteProjectsPage_Title { get; }
    public static string PushDownWindow_Title { get; }
    public static string PushDownWindow_Description { get; }
    public static string ExtractSuperclassWindow_Description { get; }
    public static string ExtractSuperclassWindow_Title { get; }
    public static string RenameDerivedElementsPage_Description { get; }
    public static string CheckDeclarationsToMakePublicPage_Description { get; }
    public static string CheckDeclarationsToMakePublicPage_Title { get; }
    public static string SafeDeletePage2TypeElement_Title { get; }
    public static string SafeDeletePage2TypeElement_Description { get; }
    public static string SafeDeleteRemoveFilesConfirmation_Title { get; }
    public static string SafeDeleteRemoveFilesConfirmation_Description { get; }
    public static string RenameMainForm_Title { get; }
    public static string RenameInitialControl_Description { get; }
    public static string RenameInitialControl_Title { get; }
    private static Resources();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_AdjustNamespacesPage_Description_Please_review_files_that_have_inconsistent_namespace_names();
    public static string get_AdjustNamespacesPage_Description_No_files_were_found_with_inconsistent_namespaces();
    public static string get_AdjustNamespacesPage_Title_Inconsistent_files_review();
    public static string get_AdjustNamespacesPage_Title_Nothing_to_fix();
    public static string get_Anonymous2DeclaredWindow_Description_Specify_parameters_of_new_type_declaration___();
    public static string get_Anonymous2DeclaredWindow_Title_Configure_type();
    public static string get_ChangeSignaturePage_Title();
    public static string get_ChangeSignaturePage_Description();
    public static string get_TypeSuggestionPage_Title_Specify_unresolved_types();
    public static string get_TypeSuggestionPage_Description();
    public static string get_MakeStaticPage_Title();
    public static string get_MakeStaticPage_Description();
    public static string get_ExtractClassFromParamsControl_Description();
    public static string get_ExtractClassFromParamsControl_Title();
    public static string get_Constructor2FactoryMethodWindow_Description();
    public static string get_Constructor2FactoryMethodWindow_Title();
    public static string get_CopyTypePage_Description();
    public static string get_CopyTypePage_Title();
    public static string get_EncapsulateFieldPage_Title();
    public static string get_EncapsulateFieldPage_Description();
    public static string get_ExtractMethodPage_Title();
    public static string get_ExtractMethodPage_Description();
    public static string get_VBFunction2PropertyPage_Title();
    public static string get_VBFunction2PropertyPage_Description();
    public static string get_InlineMethodWindow_Description();
    public static string get_InlineMethodWindow_Title();
    public static string get_IntroFieldWindow_Title();
    public static string get_IntroFieldWindow_Description();
    public static string get_IntroduceParameterWindow_Description();
    public static string get_IntroduceParameterWindow_Title();
    public static string get_TransformOutParameters_Description();
    public static string get_TransformOutParameters_Title();
    public static string get_MakeMethodNonStaticPage_Title();
    public static string get_MakeMethodNonStaticPage_Description();
    public static string get_ConflictsPage_Title();
    public static string get_ConflictsPage_Description_ReviewProblems();
    public static string get_ConflictsPage_Description_CanNotExecute();
    public static string get_MoveIntoMatchingFilesPage_Title();
    public static string get_MoveIntoMatchingFilesPage_Description();
    public static string get_MoveToNamespacePage_Title();
    public static string get_MoveFileRemoveEmptyFilePage_Title();
    public static string get_MoveFileRemoveEmptyFilePage_Description();
    public static string get_MoveToFilePage_Description();
    public static string get_MoveToFilePage_Title();
    public static string get_MoveTypeToOuterScopePage_Title();
    public static string get_MoveTypeToOuterScopePage_Description();
    public static string get_ExtractInterfaceWindow_Title();
    public static string get_ExtractInterfaceWindow_Description();
    public static string get_SelectTypePartWindow_Description();
    public static string get_SelectTypePartWindow_Title();
    public static string get_MoveStaticMembersControl_Title();
    public static string get_MoveStaticMembersControl_Description();
    public static string get_RenameDerived_Title();
    public static string get_RenameDerived_Title_UsageChanged();
    public static string get_RenameDerived_Title_UsagesChanged();
    public static string get_Property2FunctionWindow_Title();
    public static string get_Property2FunctionWindow_Description();
    public static string get_RenameNamespaceControl_Title();
    public static string get_RenameNamespaceControl_Description();
    public static string get_SafeDeletePageOverridableMember_Title();
    public static string get_SafeDeletePageOverridableMember_Description();
    public static string get_SafeDeletePageReplaceTypeUsages_Description();
    public static string get_SafeDeletePageReplaceTypeUsages_Title();
    public static string get_UseBaseTypeMainWindow_Title();
    public static string get_UseBaseTypeMainWindow_Description();
    public static string get_ConflictsPage_Description();
    public static string get_SafeDeleteFolderPage_Description();
    public static string get_SafeDeleteFolderPage_Title();
    public static string get_SafeDeleteProjectsPage_Description();
    public static string get_SafeDeleteProjectsPage_Title();
    public static string get_PushDownWindow_Title();
    public static string get_PushDownWindow_Description();
    public static string get_ExtractSuperclassWindow_Description();
    public static string get_ExtractSuperclassWindow_Title();
    public static string get_RenameDerivedElementsPage_Description();
    public static string get_CheckDeclarationsToMakePublicPage_Description();
    public static string get_CheckDeclarationsToMakePublicPage_Title();
    public static string get_SafeDeletePage2TypeElement_Title();
    public static string get_SafeDeletePage2TypeElement_Description();
    public static string get_SafeDeleteRemoveFilesConfirmation_Title();
    public static string get_SafeDeleteRemoveFilesConfirmation_Description();
    public static string get_RenameMainForm_Title();
    public static string get_RenameInitialControl_Description();
    public static string get_RenameInitialControl_Title();
}
public class JetBrains.ReSharper.Refactorings.PushPullTool.FixDocumentChange : object {
    private DocumentChange myChange;
    private IRangeMarker myRangeMarker;
    public FixDocumentChange(DocumentChange change, int shift);
    public bool ApplyInversed();
}
public static class JetBrains.ReSharper.Refactorings.PushPullTool.FixExecutor : object {
    public static bool Execute(FixNode fix, IPsiServices psiServices);
    public static bool Rollback(FixNode node, IPsiServices psiServices);
    private static bool ExecuteFix(IPsiServices psiServices, Func`2<IProgressIndicator, bool> action);
    private static bool RunWithProgress(Func`2<IProgressIndicator, TResult> action, string taskName, IPsiServices psiServices);
}
public abstract class JetBrains.ReSharper.Refactorings.PushPullTool.FixFactory : object {
    public int Priority { get; }
    public virtual int get_Priority();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.PushPullTool.FixFactory/<GetIndependentFixes>d__2")]
public virtual IEnumerable`1<FixNode> GetIndependentFixes(ProblemNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.PushPullTool.FixFactory/<GetDependentFixes>d__3")]
public virtual IEnumerable`1<FixNode> GetDependentFixes(ProblemNode node);
    public virtual void Reset(string modelSessionId);
}
public abstract class JetBrains.ReSharper.Refactorings.PushPullTool.FixNode : object {
    protected ProblemNode AncestorProblemNode;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FixDocumentChange> <Changes>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsChecked>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private SimpleSignal <Reload>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ListEvents`1<IFixToolNode> <Children>k__BackingField;
    protected Lifetime Lifetime { get; }
    public List`1<FixDocumentChange> Changes { get; }
    public IProperty`1<bool> IsChecked { get; }
    public IProperty`1<bool> IsEnabled { get; }
    public SimpleSignal Reload { get; }
    [CanBeNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public ListEvents`1<IFixToolNode> Children { get; }
    protected FixNode(ProblemNode ancestorProblemNode, Lifetime lifetime);
    [CompilerGeneratedAttribute]
protected Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public List`1<FixDocumentChange> get_Changes();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsChecked();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsEnabled();
    [CompilerGeneratedAttribute]
public SimpleSignal get_Reload();
    [CompilerGeneratedAttribute]
public virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public ListEvents`1<IFixToolNode> get_Children();
    public abstract virtual bool ExecuteUnderTransaction(IProgressIndicator pi);
    public virtual void PostExecute();
    public virtual void ExecuteWithoutTransaction();
    public virtual BeControl GetPresentation();
    public abstract virtual BeAbstractText GetPresentationText();
    public abstract virtual ValueTuple`2<RichText, RichText> GetProblemFixedText();
    public virtual void Navigate();
    public virtual bool Rollback();
    public void SaveChanges(IEnumerable`1<DocumentChange> changes);
    [CompilerGeneratedAttribute]
private void <Navigate>b__29_0();
    [CompilerGeneratedAttribute]
private void <Navigate>b__29_1();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Refactorings.PushPullTool.FixToolManager : object {
    private IList`1<FixToolSession> myCurrentSessions;
    private IEnumerable`1<FixFactory> myAllFactories;
    private IToolWindowHost myHost;
    private IIconHost myIconHost;
    public IEnumerable`1<FixToolSession> CurrentSessions { get; }
    public FixToolManager(IEnumerable`1<FixFactory> allFactories, IToolWindowHost host, IIconHost iconHost, Lifetime lifetime);
    public virtual IEnumerable`1<FixToolSession> get_CurrentSessions();
    public void Show(FixToolSession modelSession);
    public virtual void TerminateSession(string id);
    public virtual IEnumerable`1<FixNode> GetIndependentFixes(ProblemNode node);
    public virtual IEnumerable`1<FixNode> GetDependentFixes(ProblemNode node);
    public void ReloadSessions();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1();
}
public abstract class JetBrains.ReSharper.Refactorings.PushPullTool.FixToolSession : object {
    [CompilerGeneratedAttribute]
private ListEvents`1<IFixToolNode> <ProblemNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RefactoringIsInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public ListEvents`1<IFixToolNode> ProblemNodes { get; }
    public bool RefactoringIsInProgress { get; public set; }
    public string Name { get; protected set; }
    public string Id { get; protected set; }
    public abstract virtual void ReloadFixes(ProblemNode node);
    [CompilerGeneratedAttribute]
public ListEvents`1<IFixToolNode> get_ProblemNodes();
    [CompilerGeneratedAttribute]
public virtual bool get_RefactoringIsInProgress();
    [CompilerGeneratedAttribute]
public virtual void set_RefactoringIsInProgress(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
protected void set_Id(string value);
}
public interface JetBrains.ReSharper.Refactorings.PushPullTool.IFixToolNode {
    public abstract virtual void Navigate();
}
public abstract class JetBrains.ReSharper.Refactorings.PushPullTool.ProblemNode : object {
    public static string InvalidNodeText;
    private IDeclaredElementPointer`1<IDeclaredElement> myDeclaredElementPointer;
    private IList`1<IRangeMarker> myForbiddenDocumentRanges;
    private ITreeNodePointer`1<ITreeNode> myTreeNodePointer;
    private LifetimeDefinition myChildrenDefinition;
    private IList`1<FixNode> myFixes;
    private BeLocalCookie myCookie;
    [CompilerGeneratedAttribute]
private IRangeMarker <AllowedRange>k__BackingField;
    [CompilerGeneratedAttribute]
private ListEvents`1<IFixToolNode> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<FixNode> <SelectedOption>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsChecked>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <ShouldBeDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private BeAbstractText <Description>k__BackingField;
    public IRangeMarker AllowedRange { get; private set; }
    public ListEvents`1<IFixToolNode> Children { get; }
    public IProperty`1<FixNode> SelectedOption { get; }
    public IProperty`1<bool> IsChecked { get; }
    public IProperty`1<bool> ShouldBeDisabled { get; }
    public ITreeNode TreeNode { get; public set; }
    public IDeclaredElement DeclaredElement { get; }
    public Lifetime Lifetime { get; }
    public BeAbstractText Description { get; protected set; }
    protected ProblemNode(IDeclaredElement declaredElement, ITreeNode treeNode, Lifetime lifetime, FixToolSession session);
    private static ProblemNode();
    [CompilerGeneratedAttribute]
public IRangeMarker get_AllowedRange();
    [CompilerGeneratedAttribute]
private void set_AllowedRange(IRangeMarker value);
    [CompilerGeneratedAttribute]
public ListEvents`1<IFixToolNode> get_Children();
    [CompilerGeneratedAttribute]
public IProperty`1<FixNode> get_SelectedOption();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsChecked();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_ShouldBeDisabled();
    public ITreeNode get_TreeNode();
    public void set_TreeNode(ITreeNode value);
    public IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public BeAbstractText get_Description();
    [CompilerGeneratedAttribute]
protected void set_Description(BeAbstractText value);
    protected virtual DocumentRange GetRange(IDeclaration declaration);
    protected void RegisterDocumentRangeForChanges(DocumentRange range);
    private void RunAction(FixToolSession tool, Action executeFix, Action postExecute);
    private void RollbackFix(FixNode fix);
    private void ExecuteFix(FixNode fix);
    protected void OnDocumentChanged(object sender, EventArgs`1<DocumentChange> args);
    public void DisablePresentation(string descriptionText);
    public virtual void ReloadFixes();
    protected virtual bool Started();
    public FixNode GetSelectedFix();
    public virtual void SetErrorPresentation(string descriptionText);
    public abstract virtual void SetFixedPresentation(RichText mainText, RichText descriptionText);
    public abstract virtual void SetUnresolvedPresentation();
    public abstract virtual void Navigate();
    public void SetAllowedChange(DocumentRange documentRange);
    [CompilerGeneratedAttribute]
private void <ExecuteFix>b__40_0(AddRemoveIndexEventArgs`1<IFixToolNode> e);
    [CompilerGeneratedAttribute]
private void <ExecuteFix>b__40_1(PropertyChangedEventArgs`1<bool> v);
    [CompilerGeneratedAttribute]
private void <DisablePresentation>b__42_0();
}
public interface JetBrains.ReSharper.Refactorings.RefactoringService {
    public abstract virtual ILocalScope[] FindScopesByDeclaredElement(IDeclaredElement declaredElement);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "RefactorThisAction_Title")]
public class JetBrains.ReSharper.Refactorings.RefactorThis.RefactorThisAction : IntroduceWithOccurrencesAction`1<IRefactoringWorkflowProvider> {
    public static string Title { get; }
    protected RichText Caption { get; }
    protected bool ShowMenuWithOneItem { get; }
    public static string get_Title();
    protected virtual RichText get_Caption();
    protected virtual bool get_ShowMenuWithOneItem();
    protected virtual IList`1<IntroduceActionFromMenu> GetWorkflowActions(IIntroduceWorkflowWithOccurrences workflow);
}
public class JetBrains.ReSharper.Refactorings.Rename.AtomicRenames : object {
    private List`1<AtomicRenameBase> myAtomicRenames;
    private bool myReadOnly;
    public IReadOnlyList`1<AtomicRenameBase> Renames { get; }
    public AtomicRenames(AtomicRenameBase[] atomicRenameBases, bool readOnly);
    public IReadOnlyList`1<AtomicRenameBase> get_Renames();
    public void AddRange(AtomicRenameBase[] atomicRenameBases);
    [CanBeNullAttribute]
[PureAttribute]
public AtomicRenameBase GetByDeclaredElement(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Refactorings.Rename.ClrCustomRenameModel : CustomRenameModel {
    [CompilerGeneratedAttribute]
private bool <IsAnonymousTypeProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<RenameScope> <SearchScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <ContextElement>k__BackingField;
    public bool IsAnonymousTypeProperty { get; protected set; }
    public IProperty`1<RenameScope> SearchScope { get; }
    public ITreeNode ContextElement { get; public set; }
    public ClrCustomRenameModel(IDeclaredElement primaryDeclaredElement, IReference reference, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public bool get_IsAnonymousTypeProperty();
    [CompilerGeneratedAttribute]
protected void set_IsAnonymousTypeProperty(bool value);
    [CompilerGeneratedAttribute]
public IProperty`1<RenameScope> get_SearchScope();
    [CompilerGeneratedAttribute]
public ITreeNode get_ContextElement();
    [CompilerGeneratedAttribute]
public void set_ContextElement(ITreeNode value);
    [CanBeNullAttribute]
public virtual ISearchDomain GetCustomDomain();
    public virtual BeControl GetSpecific(Lifetime lifetime, Action update);
}
[RenamePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Rename.ClrPrimaryElementsRenameFactory : object {
    public sealed virtual IDeclaredElement GetPrimaryDeclaredElement(IDeclaredElement element, IReference reference);
}
public class JetBrains.ReSharper.Refactorings.Rename.ClrTypeNameConflictSearcher : object {
    [NotNullAttribute]
private AtomicRenameBase myRename;
    public ConflictSearchResult LastResult { get; }
    public ClrTypeNameConflictSearcher(AtomicRenameBase rename);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator progressIndicator, bool canPerformRefactoring);
    public sealed virtual ConflictSearchResult get_LastResult();
}
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Rename.ColorCanNotBeRenamed : AtomicRenamesFactory {
    public virtual bool IsApplicable(IDeclaredElement declaredElement);
    public virtual RenameAvailabilityCheckResult CheckRenameAvailability(IDeclaredElement declaredElement);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Rename.DefaultIgnorableReferenceTypesService : SuspiciousReferencesSearchService {
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<Type> GetCustomReferenceTypesToIgnore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.Rename.DerivedElement : DeclaredElementNode {
    public IDeclaredElementPointer`1<IDeclaredElement> DeclaredElementPointer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private DeclaredElementEnvoy`1<IDeclaredElement> myDeclaredElementEnvoy;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldName>k__BackingField;
    public string NewName { get; public set; }
    public string OldName { get; }
    public DerivedElement(IDeclaredElement declaredElement, string newName);
    public DerivedElement(IDeclaredElement declaredElement, string newName, string oldName);
    protected bool Equals(DerivedElement other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
    [CompilerGeneratedAttribute]
public string get_OldName();
    [NullableContextAttribute("2")]
public DerivedElement ResolvePointer();
    public void ReloadDeclaredElement();
    [NullableContextAttribute("2")]
private static NameRoot GetNameRoot(IDeclaredElement declaredElement, string oldName);
    public virtual string ToString();
    public void ReloadName(string newName, string oldName);
}
public class JetBrains.ReSharper.Refactorings.Rename.DerivedElementsActionResult : object {
    private List`1<TextOccurrenceRenameMarker> myTextOccurrenceRenameMarkers;
    [CompilerGeneratedAttribute]
private HashSet`1<DerivedElement> <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentStack`1<DerivedElement> <CurrentBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentStack`1<DerivedElement> <ElementsToSearch>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<int> <StartedSearchesNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAggressive>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringPage <StartPage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public HashSet`1<DerivedElement> Result { get; }
    public ConcurrentStack`1<DerivedElement> CurrentBatch { get; }
    public ConcurrentStack`1<DerivedElement> ElementsToSearch { get; }
    public IProperty`1<int> StartedSearchesNumber { get; public set; }
    public bool IsAggressive { get; public set; }
    public IRefactoringPage StartPage { get; public set; }
    public bool IsFinished { get; }
    public string Title { get; }
    public string ResultText { get; }
    public bool Continue { get; }
    public DerivedElementsActionResult(string name, List`1<TextOccurrenceRenameMarker> renameDataModel);
    [CompilerGeneratedAttribute]
public HashSet`1<DerivedElement> get_Result();
    [CompilerGeneratedAttribute]
public ConcurrentStack`1<DerivedElement> get_CurrentBatch();
    [CompilerGeneratedAttribute]
public ConcurrentStack`1<DerivedElement> get_ElementsToSearch();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<int> get_StartedSearchesNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartedSearchesNumber(IProperty`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAggressive();
    [CompilerGeneratedAttribute]
public void set_IsAggressive(bool value);
    [CompilerGeneratedAttribute]
public IRefactoringPage get_StartPage();
    [CompilerGeneratedAttribute]
public void set_StartPage(IRefactoringPage value);
    public sealed virtual bool get_IsFinished();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    public sealed virtual string get_ResultText();
    public sealed virtual bool get_Continue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.Rename.DerivedElementsCollection : object {
    [CompilerGeneratedAttribute]
private List`1<DerivedElement> <DerivedRenames>k__BackingField;
    public List`1<DerivedElement> DerivedRenames { get; }
    [CompilerGeneratedAttribute]
public List`1<DerivedElement> get_DerivedRenames();
    public void AddRename(IDeclaredElement derivedElement, string newName);
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Refactorings.Rename.IDerivedRenamesEvaluator")]
public class JetBrains.ReSharper.Refactorings.Rename.DerivedRenamesEvaluatorAttribute : ShellComponentAttribute {
    public DerivedRenamesEvaluatorAttribute(Instantiation instantiation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Rename.DerivedRenamesEvaluators : object {
    private List`1<IDerivedRenamesEvaluator> myEvaluators;
    public DerivedRenamesEvaluators(IEnumerable`1<IDerivedRenamesEvaluator> evaluators);
    public void EvaluateDerivedRenames(DerivedElementsActionResult derivedElementsActionResult, RenameWorkflowBase renameWorkflow, IProgressIndicator pi);
    [NullableContextAttribute("2")]
private static NameRoot GetNameRoot(IDeclaredElement declaredElement, string oldName);
    private void GetDerived(DerivedElementsActionResult actionResult, DerivedElement derivedElement, RenameDataModel renameDataModel, IProgressIndicator pi);
    public List`1<DerivedElement> GetFromElement(DerivedElement parentDerivedElement, RenameDataModel renameDataModel, IProgressIndicator pi);
    private static void AddElementsToSearch(HashSet`1<DerivedElement> derivedElements, DerivedElementsActionResult actionResult);
    public List`1<DerivedElement> GetFromReference(DerivedElement parentDerivedElement, IReference reference, IProgressIndicator pi);
    private DerivedElement GetDerivedElement(DerivedElement parentDerivedDeclaredElement, IDeclaredElement candidate, bool suggestedElementsHaveDerivedName);
    private static bool IsGoodDerivedElement(DerivedElement derivedDeclaredElement, IDeclaredElement candidate, bool suggestDerivedName, String& newDerivedName);
    [CompilerGeneratedAttribute]
internal static void <AddElementsToSearch>g__AddToProcessedAndInProgress|6_0(DerivedElement derivedElement, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <AddElementsToSearch>g__AddElementToSearchWithHierarchy|6_1(DerivedElement derivedElement, <>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Rename.EntityFrameworkMigrationsSuspiciousReferencesSearchService : SuspiciousReferencesSearchService {
    [CompilerGeneratedAttribute]
private EntityFrameworkMigrationsSearchFilter <searchFilter>P;
    public EntityFrameworkMigrationsSuspiciousReferencesSearchService(EntityFrameworkMigrationsSearchFilter searchFilter);
    public virtual object TryGetKey(IDeclaredElement declaredElement, string newName);
    public virtual bool CanContainSuspiciousReferences(IPsiSourceFile sourceFile, object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("10")]
internal class JetBrains.ReSharper.Refactorings.Rename.FilterOutByLanguageSuspiciousReferencesSearchService : SuspiciousReferencesSearchService {
    private List`1<ISearchFilter> myLanguageSearchFilters;
    public FilterOutByLanguageSuspiciousReferencesSearchService(IEnumerable`1<ISearchFilter> searchFilters);
    public virtual object TryGetKey(IDeclaredElement declaredElement, string newName);
    public virtual bool CanContainSuspiciousReferences(IPsiSourceFile sourceFile, object key);
}
public class JetBrains.ReSharper.Refactorings.Rename.Fixes.BulkRenameOccurrence : DeclaredElementOccurrence {
    private IDeclaredElementPointer`1<IDeclaredElement> myDeclaredElementPointer;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Included>k__BackingField;
    public string NewName { get; public set; }
    public string OldName { get; }
    public bool Included { get; public set; }
    public IDeclaredElement DeclaredElement { get; }
    public BulkRenameOccurrence(IDeclaredElement declaredElement, bool included, string newName);
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
    [CompilerGeneratedAttribute]
public string get_OldName();
    [CompilerGeneratedAttribute]
public bool get_Included();
    [CompilerGeneratedAttribute]
public void set_Included(bool value);
    public IDeclaredElement get_DeclaredElement();
}
public class JetBrains.ReSharper.Refactorings.Rename.Fixes.BulkRenamePage : SingleBeRefactoringPage {
    public static string BulkRenameUsages;
    private BulkRenameModel myBulkRenameModel;
    public string Description { get; }
    public string Title { get; }
    public BulkRenamePage(BulkRenameWorkflow workflow, List`1<BulkRenameOccurrence> infos);
    public virtual string get_Description();
    public virtual string get_Title();
    public virtual BeControl GetPageContent();
}
public class JetBrains.ReSharper.Refactorings.Rename.Fixes.BulkRenamePresenter : TreeModelBrowserPresenter {
    protected virtual void PresentObject(object value, IPresentableItem item, TreeModelNode modelNode, PresentationState state);
}
public class JetBrains.ReSharper.Refactorings.Rename.Fixes.BulkRenameWorkflow : RenameWorkflowBase {
    private ICollection`1<IDeclaredElement> myDeclaredElements;
    [CompilerGeneratedAttribute]
private List`1<BulkRenameOccurrence> <MemberInfos>k__BackingField;
    public List`1<BulkRenameOccurrence> MemberInfos { get; private set; }
    public bool MightModifyManyDocuments { get; }
    public bool HasUI { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public string Title { get; }
    public string ActionId { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public BulkRenameWorkflow(ISolution solution);
    [CompilerGeneratedAttribute]
public List`1<BulkRenameOccurrence> get_MemberInfos();
    [CompilerGeneratedAttribute]
private void set_MemberInfos(List`1<BulkRenameOccurrence> value);
    public virtual bool get_MightModifyManyDocuments();
    public virtual bool get_HasUI();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual string get_Title();
    public virtual string get_ActionId();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual bool PreExecute(IProgressIndicator pi);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    [CompilerGeneratedAttribute]
private BulkRenameOccurrence <Initialize>b__21_0(IDeclaredElement e);
}
public static class JetBrains.ReSharper.Refactorings.Rename.FixTypoRenameSuggestionsDataConstant : object {
    public static DataConstant`1<IList`1<string>> SUGGESTIONS;
    private static FixTypoRenameSuggestionsDataConstant();
}
[RefactoringWorkflowProviderAttribute("0")]
internal class JetBrains.ReSharper.Refactorings.Rename.GlobalInlineRenameProvider : RenameWorkflowProvider {
    private RenameRefactoringService myRenameRefactoringService;
    public GlobalInlineRenameProvider(RenameRefactoringService renameRefactoringService);
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Rename.GlobalInlineRenameWorkflow : RenameWorkflowBase {
    private List`1<IDeclaredElement> mySecondaryElements;
    private IConflictSearcher myConflictSearcher;
    private ITextControl myCurrentTextControl;
    private HotspotInfo myFieldInfo;
    private INamingProjection myNamingProjection;
    private RenameWorkflowPopupOccurrence myValue;
    [CompilerGeneratedAttribute]
private List`1<SmartDeclarationPointer`1<IDeclaration>> <InitialDeclarationPointers>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <CustomLifetime>k__BackingField;
    public IConflictSearcher ConflictSearcher { get; }
    public bool HasUI { get; }
    public List`1<SmartDeclarationPointer`1<IDeclaration>> InitialDeclarationPointers { get; private set; }
    public string Title { get; }
    public Lifetime CustomLifetime { get; private set; }
    public GlobalInlineRenameWorkflow(string actionId, ISolution solution);
    public virtual IConflictSearcher get_ConflictSearcher();
    public virtual bool get_HasUI();
    [CompilerGeneratedAttribute]
public List`1<SmartDeclarationPointer`1<IDeclaration>> get_InitialDeclarationPointers();
    [CompilerGeneratedAttribute]
private void set_InitialDeclarationPointers(List`1<SmartDeclarationPointer`1<IDeclaration>> value);
    public virtual string get_Title();
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual bool Execute(IProgressIndicator progressIndicator);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    private void InitializeReferences(List`1<IDocument> documents, ICollection`1<DocumentRange> rangesList);
    private int FindDriverRangeFromCaretPosition(IList`1<DocumentRange> rangesList);
    private bool InitializePrimaryDeclaredElement(IDeclaredElement initialElement);
    private bool AddNameRanges(IDeclaredElement initialElement, List`1<DocumentRange> rangesList);
    private void ConsumeReference(ICollection`1<IReference> refs, ICollection`1<IReference> invalidRef, IReference reference);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    private HotspotSession InitializeHotspot();
    [CompilerGeneratedAttribute]
public sealed virtual Lifetime get_CustomLifetime();
    [CompilerGeneratedAttribute]
private void set_CustomLifetime(Lifetime value);
}
internal class JetBrains.ReSharper.Refactorings.Rename.HotTypeMemberRenameConflictSearcher : object {
    private AtomicRenames myAllRenames;
    [NotNullAttribute]
private AtomicRenameBase myAtomicRenameBase;
    public ConflictSearchResult LastResult { get; }
    public HotTypeMemberRenameConflictSearcher(AtomicRenameBase atomicRenameBase, AtomicRenames allRenames);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    public sealed virtual ConflictSearchResult get_LastResult();
    private void SearchConflictsDown(IProgressIndicator progressIndicator, ICollection`1<IConflict> conflicts);
    private void SearchOverridesConflictsDown(IProgressIndicator progressIndicator, IOverridableMember overridableMember, ICollection`1<IConflict> conflicts);
    private void SearchConflictsUp(IProgressIndicator progressIndicator, ICollection`1<IConflict> conflicts);
}
public interface JetBrains.ReSharper.Refactorings.Rename.IBulkRenameDataProvider {
    public abstract virtual string GetName(IDeclaredElement element);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Refactorings.Rename.IDerivedRenamesEvaluator {
    public bool SuggestedElementsHaveDerivedName { get; }
    public abstract virtual bool get_SuggestedElementsHaveDerivedName();
    public abstract virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public abstract virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.Rename.Impl.InlineRenameWorkflow : RefactoringWorkflowBase {
    [CompilerGeneratedAttribute]
private RenameDataProvider <DataProvider>k__BackingField;
    private IReferencePointer myReferencePointer;
    private IDeclaredElementPointer`1<IDeclaredElement> myElementPointer;
    private ITextControl myTextControl;
    private HotspotInfo myFieldInfo;
    private IDeclaredElement myPrimevalDeclaredElement;
    public static string InlineRenameCommand;
    public static PropertyId`1<bool> RenamePropertyId;
    private OneToSetMap`2<IDeclaredElementPointer`1<IDeclaredElement>, IReferencePointer> myReferences;
    private IList`1<string> mySuggestions;
    [CompilerGeneratedAttribute]
private CachingLanguageSpecificImpl`1<RenameHelperBase> <LanguageSpecific>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <CustomLifetime>k__BackingField;
    public RenameDataProvider DataProvider { get; public set; }
    private CachingLanguageSpecificImpl`1<RenameHelperBase> LanguageSpecific { get; }
    public IconId Icon { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public string ActionId { get; }
    public bool HasUI { get; }
    public HelpId HelpKeyword { get; }
    public IConflictSearcher ConflictSearcher { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public Lifetime CustomLifetime { get; private set; }
    public InlineRenameWorkflow(ISolution solution, string actionId);
    private static InlineRenameWorkflow();
    [CompilerGeneratedAttribute]
public RenameDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
public void set_DataProvider(RenameDataProvider value);
    [CompilerGeneratedAttribute]
private CachingLanguageSpecificImpl`1<RenameHelperBase> get_LanguageSpecific();
    public virtual IconId get_Icon();
    public virtual RefactoringActionGroup get_ActionGroup();
    [CompilerGeneratedAttribute]
public virtual string get_ActionId();
    public virtual bool get_HasUI();
    public virtual HelpId get_HelpKeyword();
    public virtual IConflictSearcher get_ConflictSearcher();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual bool Execute(IProgressIndicator progressIndicator);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    private void CreateAndExecuteHotspotSession(HotspotInfo hotspotInfo);
    [CompilerGeneratedAttribute]
public sealed virtual Lifetime get_CustomLifetime();
    [CompilerGeneratedAttribute]
private void set_CustomLifetime(Lifetime value);
    [CompilerGeneratedAttribute]
private Task <CreateAndExecuteHotspotSession>b__42_5();
}
public interface JetBrains.ReSharper.Refactorings.Rename.INameSuggestionsProvider {
    public abstract virtual bool AreSuggestionsEnabled();
    public abstract virtual IconId GetSuggestionIcon();
    public abstract virtual Task`1<List`1<string>> GetSuggestionsAsync(Lifetime lifetime, ISolution solution, IDeclaredElement declaredElement);
    public abstract virtual RenameSuggestionType GetRenameSuggestionType();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Rename.InlineRenameProvider : RenameWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
internal class JetBrains.ReSharper.Refactorings.Rename.LightOverridesFinder : object {
    [NotNullAttribute]
private IOverridableMember myOverridableMember;
    [NotNullAttribute]
private IFinder myFinder;
    [CompilerGeneratedAttribute]
private HashSet`1<HierarchyMember> <Overrides>k__BackingField;
    [NotNullAttribute]
public HashSet`1<HierarchyMember> Overrides { get; }
    private LightOverridesFinder(IOverridableMember overridableMember);
    [CompilerGeneratedAttribute]
public HashSet`1<HierarchyMember> get_Overrides();
    [NotNullAttribute]
public static LightOverridesFinder CreateInstance(IOverridableMember owner);
    public void Find(IProgressIndicator pi);
    [NotNullAttribute]
private static IList`1<HierarchyMember> FindRootMembers(IOverridableMember member);
    private static void ProcessBasesAndEnqueueNotCompiled(IOverridableMember member, Queue`1<OverridableMemberInstance> intermediateMembers, ICollection`1<HierarchyMember> rootMembers);
    private void RemoveWrongProblems();
    private void IterateHierarchyDown(HierarchyMember superMember, SubProgressIndicator pi);
    [NotNullAttribute]
private HierarchyMember EnqueueImplementations(Queue`1<IOverridableMember> queue, IOverridableMember overridableMember, IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.Rename.LocalElementConflictSearcher : object {
    private ICollection`1<ITreeNode> myScopeElements;
    private string myName;
    private Func`2<IDeclaredElement, Nullable`1<ConflictSeverity>> myGetConflictSeverity;
    private ICollection`1<IDeclaredElement> myIgnoredElements;
    [CompilerGeneratedAttribute]
private ConflictSearchResult <LastResult>k__BackingField;
    public ConflictSearchResult LastResult { get; private set; }
    public LocalElementConflictSearcher(ICollection`1<ITreeNode> scopeElements, string name, ICollection`1<IDeclaredElement> ignoredElements);
    public LocalElementConflictSearcher(IDeclaredElement declaredElement, string name, Func`2<IDeclaredElement, Nullable`1<ConflictSeverity>> getConflictSeverity);
    [CompilerGeneratedAttribute]
public sealed virtual ConflictSearchResult get_LastResult();
    [CompilerGeneratedAttribute]
private void set_LastResult(ConflictSearchResult value);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    private void FindConflictsInScope(ITreeNode scope, List`1<IConflict> conflicts);
    private void SearchConflictsUp(ITreeNode scope, List`1<IConflict> conflicts);
    private void SearchConflictsInDescentants(ITreeNode scope, List`1<IConflict> conflicts);
    private static ILocalScope[] FindScopesByDeclaredElement(IDeclaredElement declaredElement);
    private void CheckLocalElement(IDeclaredElement localElement, List`1<IConflict> conflicts);
}
internal class JetBrains.ReSharper.Refactorings.Rename.MatchingMemberRenameConflictSearcher : object {
    [NotNullAttribute]
private AtomicRenameBase myAtomicRenameBase;
    public ConflictSearchResult LastResult { get; }
    public MatchingMemberRenameConflictSearcher(AtomicRenameBase atomicRenameBase);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    public sealed virtual ConflictSearchResult get_LastResult();
}
internal class JetBrains.ReSharper.Refactorings.Rename.NamespaceRenameConflictSearcher : object {
    private string myNewQualifiedName;
    private INamespace myNamespace;
    public ConflictSearchResult LastResult { get; }
    public NamespaceRenameConflictSearcher(AtomicRenameBase renameBase);
    public NamespaceRenameConflictSearcher(string newQualifiedName, INamespace ns);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    public sealed virtual ConflictSearchResult get_LastResult();
    private static void SearchConflictsInNamespaces(INamespace ns1, INamespace ns2, ICollection`1<IConflict> conflicts);
    private string GetNewQualifiedName(AtomicRenameBase atomicRenameBase);
}
public interface JetBrains.ReSharper.Refactorings.Rename.Pages.IOccurrencesProvider {
    public IReadOnlyList`1<IOccurrence> Occurrences { get; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public bool AllEnabled { get; }
    public string AllEnabledText { get; }
    public abstract virtual IReadOnlyList`1<IOccurrence> get_Occurrences();
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual bool get_AllEnabled();
    public abstract virtual string get_AllEnabledText();
    public abstract virtual void SetSelected(IList`1<IOccurrence> selectedOccurrences, bool allEnabled);
}
public class JetBrains.ReSharper.Refactorings.Rename.Pages.OccurrencesPage : SingleBeRefactoringPage {
    private BeGrid myContent;
    private IOccurrencesProvider myProvider;
    private IList`1<IOccurrence> mySelectedOccurrences;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PageDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <GlobalEnabled>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public string PageDescription { get; }
    public IProperty`1<bool> GlobalEnabled { get; }
    protected IOccurrencesProvider Provider { get; }
    public OccurrencesPage(IOccurrencesProvider provider, Lifetime lifetime, ISolution solution);
    public OccurrencesPage(IOccurrencesProvider provider, Lifetime lifetime, ISolution solution, OccurrenceBrowserDescriptor usagesDescriptor);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string get_PageDescription();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_GlobalEnabled();
    public virtual void Commit();
    public virtual BeControl GetPageContent();
    protected IOccurrencesProvider get_Provider();
}
public class JetBrains.ReSharper.Refactorings.Rename.Pages.OccurrencesProvider : object {
    private Action`2<IList`1<IOccurrence>, bool> mySetSelected;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IOccurrence> <Occurrences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllEnabledText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllEnabled>k__BackingField;
    public IReadOnlyList`1<IOccurrence> Occurrences { get; }
    public string Title { get; public set; }
    public string AllEnabledText { get; public set; }
    public string Description { get; public set; }
    public bool AllEnabled { get; }
    public OccurrencesProvider(IReadOnlyList`1<IOccurrence> occurrences, bool enableAll, Action`2<IList`1<IOccurrence>, bool> setSelected);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IOccurrence> get_Occurrences();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AllEnabledText();
    [CompilerGeneratedAttribute]
public void set_AllEnabledText(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllEnabled();
    public sealed virtual void SetSelected(IList`1<IOccurrence> selectedOccurrences, bool allEnabled);
}
public class JetBrains.ReSharper.Refactorings.Rename.Pages.RenameDerivedElementsPage : SingleBeRefactoringPage {
    private NameChangesDataModel myChanges;
    private BeGrid myContent;
    private IProperty`1<bool> myGlobalEnabled;
    public static string GlobalEnabled;
    public string Title { get; }
    public string Description { get; }
    public string PageDescription { get; }
    public RenameDerivedElementsPage(RenameWorkflowBase workflow, DerivedElementsCollection derivedElementsCollection, Lifetime lifetime);
    public virtual string get_Title();
    public virtual string get_Description();
    public virtual string get_PageDescription();
    public virtual BeControl GetPageContent();
    public virtual void Commit();
    public virtual bool RefreshContents(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private List`1<BeControl> <.ctor>b__10_0(Lifetime lt, ITreeGridNode e, CheckBoxTreeNodeProperties lc, TreeNodeProperties tc);
}
public class JetBrains.ReSharper.Refactorings.Rename.Pages.RenameFilePage : SingleBeRefactoringPage {
    private IProperty`1<bool> myChangeTextOccurrences;
    private IProperty`1<bool> myQuickRename;
    private BeGrid myContent;
    private IContextBoundSettingsStore myContextBoundSettingsStore;
    private RenameDataModel myDataModel;
    private IProperty`1<string> myNewName;
    private IProperty`1<bool> myRenameType;
    [CanBeNullAttribute]
private BeCheckbox myRenameTypeCheckbox;
    private BeCheckbox myQuickRenameCheckbox;
    private BeCheckbox myChangeTextOccurrencesCheckbox;
    private RenameWorkflow myWorkflow;
    private RenameHelperBase myRenameHelper;
    private RenameFileHelper myRenameFileHelper;
    private bool myLastRenameTypeValue;
    public static string NewName;
    public static string RenameType;
    public static string ChangeTextOccurrences;
    public static string QuickRename;
    public string Title { get; }
    public RenameFilePage(RenameWorkflow workflow);
    public virtual string get_Title();
    public virtual BeControl GetPageContent();
    private void SetCheckboxesRelations();
    private bool ValidateExtension(string newName);
    private bool ValidateTypeName(string newName);
    private void TryAddCheckboxForRenameType();
    public virtual void Commit();
    private void AddExtraDeclaredElements(IReadOnlyCollection`1<IDeclaredElement> declaredElements);
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__21_0(string name);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__21_1(string name);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__21_2(PropertyChangedEventArgs`1<string> x);
    [CompilerGeneratedAttribute]
private void <SetCheckboxesRelations>b__22_0(PropertyChangedEventArgs`1<bool> v);
    [CompilerGeneratedAttribute]
private void <SetCheckboxesRelations>b__22_1(PropertyChangedEventArgs`1<bool> v);
    [CompilerGeneratedAttribute]
private void <SetCheckboxesRelations>b__22_2(PropertyChangedEventArgs`1<bool> v);
    [CompilerGeneratedAttribute]
private bool <AddExtraDeclaredElements>b__27_0(IDeclaredElement element);
}
public class JetBrains.ReSharper.Refactorings.Rename.Pages.RenameIds : object {
    public static string TextCheckBox;
    public static string DerivedTreeGridId;
}
public class JetBrains.ReSharper.Refactorings.Rename.Pages.RenameInitialControlPage : SingleBeRefactoringPage {
    private BeGrid myContent;
    private RenameWorkflow myWorkflow;
    private RenameDataModel myDataModel;
    private bool myCanRenameFiles;
    private IProperty`1<bool> myChangeTextOccurrences;
    private IProperty`1<bool> myRenameFile;
    private IProperty`1<string> myNewName;
    private SynchronizedSet`1<RenameSuggestion> myProvidedSuggestions;
    public static string ChangeTextOccurrences;
    public static string RenameFile;
    public static string NewName;
    [CompilerGeneratedAttribute]
private Action OnCommit;
    public string Title { get; }
    public RenameInitialControlPage(RenameWorkflow workflow);
    public virtual string get_Title();
    private BeTextBox GetNewNameControl();
    public virtual BeControl GetPageContent();
    protected virtual void AddCustomValidation(BeTextBox newName, IDeclaredElement element);
    public virtual void Commit();
    private void UpdateStatistics(string newName);
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    [CompilerGeneratedAttribute]
public void add_OnCommit(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnCommit(Action value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0(PropertyChangedEventArgs`1<bool> v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_1(PropertyChangedEventArgs`1<bool> v);
}
[DerivedRenamesEvaluatorAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Rename.ParameterInHierarchyDerivedRenamesEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Rename.ParameterInOverloadRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("0")]
internal class JetBrains.ReSharper.Refactorings.Rename.ParameterSuspiciousReferencesSearchService : SuspiciousReferencesSearchService {
    [CompilerGeneratedAttribute]
private NamedArgumentCache <namedArgumentCache>P;
    [CompilerGeneratedAttribute]
private IPsiServices <psiServices>P;
    [CompilerGeneratedAttribute]
private ParameterSearchFilter <parameterSearchFilter>P;
    public ParameterSuspiciousReferencesSearchService(NamedArgumentCache namedArgumentCache, IPsiServices psiServices, ParameterSearchFilter parameterSearchFilter);
    public virtual ISearchDomain TryGetAdditionalSearchDomain(IDeclaredElement declaredElement, string newName);
    public virtual object TryGetKey(IDeclaredElement declaredElement, string newName);
    public virtual bool CanContainSuspiciousReferences(IPsiSourceFile sourceFile, object key);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Rename.Protobuf.ProtobufDerivedRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
}
[ZoneMarkerAttribute]
internal class JetBrains.ReSharper.Refactorings.Rename.Protobuf.ZoneMarker : object {
}
public class JetBrains.ReSharper.Refactorings.Rename.ReferenceRebinder : object {
    private INamespace myNs;
    private string myNewName;
    private bool myCaseSensitive;
    private IDictionary`2<IReferencePointer, IDeclaredElement> myDeclaredElements;
    private IDictionary`2<IReferencePointer, QName> myNewTargets;
    public ReferenceRebinder(ITreeNode element, INamespace ns, string newName, bool caseSensitive);
    private void CollectData(ITreeNode element);
    public void Restore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.Rename.ReferencesStore : object {
    private long myDocumentsVersion;
    private long myReferencesVersion;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<IDeclaredElement> myDeclaredElementsWithActualReferences;
    private ElementPointerMap`1<IList`1<IReferencePointer>> myReferences;
    public ReferencesStore(Lifetime lifetime, IPsiServices psiServices);
    private void RehashReferencesIfRequired();
    public IList`1<IReference> GetElementReferences(IDeclaredElement declaredElement);
    public IList`1<IDeclaredElement> GetElementsWithoutActualSearchResults(IList`1<IDeclaredElement> declaredElements);
    public void MarkAsSearched(IList`1<IDeclaredElement> declaredElements);
    public void SaveReference(IDeclaredElement declaredElement, IReference reference);
}
[FileRenameProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Rename.RelatedFileRenameProvider : object {
    public virtual IEnumerable`1<FileRename> GetFileRenames(IDeclaredElement declaredElement, string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Rename.RelatedFileRenameProvider/<GetDependentProjectFiles>d__1")]
private static IEnumerable`1<IProjectFile> GetDependentProjectFiles(IDeclaredElement typeElement);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "RenameActionText")]
[VsOverrideActionAttribute("({1496A755-94DE-11D0-8C3F-00C04FC2AAE2}:1550)")]
public class JetBrains.ReSharper.Refactorings.Rename.RenameAction : ExtensibleRefactoringAction`1<RenameWorkflowProvider> {
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
    public sealed virtual bool ShouldFallBack(IDataContext context);
}
[RefactoringWorkflowProviderAttribute("0")]
internal class JetBrains.ReSharper.Refactorings.Rename.RenameBasicProvider : RenameWorkflowProvider {
    private RenameRefactoringService myRenameRefactoringService;
    public RenameBasicProvider(RenameRefactoringService renameRefactoringService);
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Rename.RenameDataModel : object {
    private List`1<FileRename> myFileRenames;
    private DerivedElementsCollection myDerivedElements;
    private IDeclaredElementPointer`1<IDeclaredElement> myInitialDeclaredElementPointer;
    [CompilerGeneratedAttribute]
private DerivedElementsActionResult <ActionResult>k__BackingField;
    [CompilerGeneratedAttribute]
private CustomRenameModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDeclaredElementPointer`1<IDeclaredElement>> <ExtraElementPointers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RdProjectModelCommand> <ExtraProjectModelCommands>k__BackingField;
    [CanBeNullAttribute]
private IReferencePointer myReferencePointer;
    [CompilerGeneratedAttribute]
private NameRoot <InitialRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InitialName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<HierarchyConflict> <HierarchyConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private INamingPolicyProvider <PrimaryNamingPolicyProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    public Dictionary`2<IDeclaredElement, string> DeclaredElementToNewNameDictionary;
    [CompilerGeneratedAttribute]
private RenameFilesOption <CanHaveFileRenames>k__BackingField;
    private HashSet`1<IDeclaredElementPointer`1<IDeclaredElement>> myTypesToRename;
    private HashSet`1<IDeclaredElementPointer`1<IDeclaredElement>> myExtraFilesToRename;
    [CompilerGeneratedAttribute]
private List`1<TextOccurrenceRenameMarker> <TextOccurrences>k__BackingField;
    private IList`1<ITextOccurrenceRenameMarker> myExtraTextOccurrences;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TextOccurrenceRenameMarker> <ActualOccurrences>k__BackingField;
    [CompilerGeneratedAttribute]
private IShellLocks <Locks>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingPolicy <NamingPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NameRoot> <Roots>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<AtomicRenameBase> <BaseRenames>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AtomicRenameBase> <DerivedRenames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NameHasChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExternalTypesToRename>k__BackingField;
    [CompilerGeneratedAttribute]
private INamesSuggestion <Suggestion>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferencesStore <ReferencesStore>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <PredefinedSuggestions>k__BackingField;
    public DerivedElementsActionResult ActionResult { get; }
    public CustomRenameModel Model { get; public set; }
    public IDeclaredElement InitialDeclaredElement { get; public set; }
    public DerivedElementsCollection DerivedElements { get; }
    public IList`1<IDeclaredElementPointer`1<IDeclaredElement>> ExtraElementPointers { get; }
    public List`1<RdProjectModelCommand> ExtraProjectModelCommands { get; }
    [CanBeNullAttribute]
public IReference Reference { get; }
    public NameRoot InitialRoot { get; protected set; }
    public string InitialName { get; public set; }
    [CanBeNullAttribute]
public List`1<HierarchyConflict> HierarchyConflicts { get; public set; }
    public INamingPolicyProvider PrimaryNamingPolicyProvider { get; protected set; }
    public PsiLanguageType LanguageType { get; protected set; }
    public IList`1<IDeclaredElementPointer`1<IDeclaredElement>> AllInitialElementsPointers { get; }
    public IEnumerable`1<IDeclaredElement> AllInitialElements { get; }
    public RenameFilesOption CanHaveFileRenames { get; protected set; }
    public IEnumerable`1<FileRename> FileRenames { get; }
    public IReadOnlyCollection`1<IDeclaredElement> TypesToRename { get; }
    public IReadOnlyCollection`1<IDeclaredElement> ExtraFilesToRename { get; }
    public List`1<TextOccurrenceRenameMarker> TextOccurrences { get; }
    public IEnumerable`1<TextOccurrenceRenameMarker> ActualOccurrences { get; public set; }
    public IEnumerable`1<ITextOccurrenceRenameMarker> AllTextOccurrences { get; }
    public IShellLocks Locks { get; }
    public NamingPolicy NamingPolicy { get; private set; }
    public IEnumerable`1<NameRoot> Roots { get; public set; }
    public Lifetime Lifetime { get; }
    public string NewName { get; public set; }
    public ICollection`1<AtomicRenameBase> BaseRenames { get; private set; }
    public IList`1<AtomicRenameBase> DerivedRenames { get; }
    public bool NameHasChanged { get; public set; }
    public bool RenameType { get; public set; }
    public bool HasExternalTypesToRename { get; public set; }
    public INamesSuggestion Suggestion { get; private set; }
    public AtomicRenames AllRenames { get; }
    public IPsiServices PsiServices { get; }
    public bool IsInteractive { get; public set; }
    public ISolution Solution { get; }
    public ReferencesStore ReferencesStore { get; public set; }
    public IList`1<string> PredefinedSuggestions { get; }
    public RenameDataModel(ICollection`1<IDeclaredElement> declaredElements, IReference reference, RenameFilesOption canHaveFileRenames, Lifetime lifetime, ISolution solution, CustomRenameModel model, RenameWorkflowBase renameWorkflow, IList`1<string> predefinedSuggestions);
    [CompilerGeneratedAttribute]
public DerivedElementsActionResult get_ActionResult();
    [CompilerGeneratedAttribute]
public CustomRenameModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(CustomRenameModel value);
    public IDeclaredElement get_InitialDeclaredElement();
    public void set_InitialDeclaredElement(IDeclaredElement value);
    public DerivedElementsCollection get_DerivedElements();
    [CompilerGeneratedAttribute]
public IList`1<IDeclaredElementPointer`1<IDeclaredElement>> get_ExtraElementPointers();
    [CompilerGeneratedAttribute]
public List`1<RdProjectModelCommand> get_ExtraProjectModelCommands();
    public IReference get_Reference();
    [CompilerGeneratedAttribute]
public NameRoot get_InitialRoot();
    [CompilerGeneratedAttribute]
protected void set_InitialRoot(NameRoot value);
    [CompilerGeneratedAttribute]
public string get_InitialName();
    [CompilerGeneratedAttribute]
public void set_InitialName(string value);
    [CompilerGeneratedAttribute]
public List`1<HierarchyConflict> get_HierarchyConflicts();
    [CompilerGeneratedAttribute]
public void set_HierarchyConflicts(List`1<HierarchyConflict> value);
    [CompilerGeneratedAttribute]
public INamingPolicyProvider get_PrimaryNamingPolicyProvider();
    [CompilerGeneratedAttribute]
protected void set_PrimaryNamingPolicyProvider(INamingPolicyProvider value);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
protected void set_LanguageType(PsiLanguageType value);
    public IList`1<IDeclaredElementPointer`1<IDeclaredElement>> get_AllInitialElementsPointers();
    public IEnumerable`1<IDeclaredElement> get_AllInitialElements();
    [CompilerGeneratedAttribute]
public RenameFilesOption get_CanHaveFileRenames();
    [CompilerGeneratedAttribute]
protected void set_CanHaveFileRenames(RenameFilesOption value);
    public IEnumerable`1<FileRename> get_FileRenames();
    public IReadOnlyCollection`1<IDeclaredElement> get_TypesToRename();
    public IReadOnlyCollection`1<IDeclaredElement> get_ExtraFilesToRename();
    [CompilerGeneratedAttribute]
public List`1<TextOccurrenceRenameMarker> get_TextOccurrences();
    [CompilerGeneratedAttribute]
public IEnumerable`1<TextOccurrenceRenameMarker> get_ActualOccurrences();
    [CompilerGeneratedAttribute]
public void set_ActualOccurrences(IEnumerable`1<TextOccurrenceRenameMarker> value);
    public IEnumerable`1<ITextOccurrenceRenameMarker> get_AllTextOccurrences();
    [CompilerGeneratedAttribute]
public IShellLocks get_Locks();
    [CompilerGeneratedAttribute]
public NamingPolicy get_NamingPolicy();
    [CompilerGeneratedAttribute]
private void set_NamingPolicy(NamingPolicy value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NameRoot> get_Roots();
    [CompilerGeneratedAttribute]
public void set_Roots(IEnumerable`1<NameRoot> value);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<AtomicRenameBase> get_BaseRenames();
    [CompilerGeneratedAttribute]
private void set_BaseRenames(ICollection`1<AtomicRenameBase> value);
    [CompilerGeneratedAttribute]
public IList`1<AtomicRenameBase> get_DerivedRenames();
    [CompilerGeneratedAttribute]
public bool get_NameHasChanged();
    [CompilerGeneratedAttribute]
public void set_NameHasChanged(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameType();
    [CompilerGeneratedAttribute]
public void set_RenameType(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasExternalTypesToRename();
    [CompilerGeneratedAttribute]
public void set_HasExternalTypesToRename(bool value);
    [CompilerGeneratedAttribute]
public INamesSuggestion get_Suggestion();
    [CompilerGeneratedAttribute]
private void set_Suggestion(INamesSuggestion value);
    public AtomicRenames get_AllRenames();
    [CompilerGeneratedAttribute]
public IPsiServices get_PsiServices();
    [CompilerGeneratedAttribute]
public bool get_IsInteractive();
    [CompilerGeneratedAttribute]
public void set_IsInteractive(bool value);
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    [CompilerGeneratedAttribute]
public ReferencesStore get_ReferencesStore();
    [CompilerGeneratedAttribute]
public void set_ReferencesStore(ReferencesStore value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_PredefinedSuggestions();
    private void CollectTypesAndFilesToRename(RenameWorkflowBase renameWorkflow, IDeclaredElement declaredElement);
    private void ReloadNames(string oldName);
    public NameChangesDataModel GetNameChanges(DerivedElementsCollection derivedElements);
    [NotNullAttribute]
public IList`1<IReference> GetElementReferences(IDeclaredElement declaredElement);
    public void InitializeNaming(IDeclaredElement primaryDeclaredElement, IReference reference);
    public void AddExtraDeclaredElements(IEnumerable`1<IDeclaredElement> elements);
    public void AddFileRename(IEnumerable`1<FileRename> selectMany);
    private RenameHelperBase GetRenameHelper(RenameWorkflowBase renameWorkflow, IDeclaredElement declaredElement);
    public void LoadBaseRenames(IProgressIndicator pi, RenameWorkflowBase renameWorkflowBase, bool forceReload);
    public List`1<TextOccurrenceRenameMarker> CalculateActualTextOccurrences(IProgressIndicator subPi, List`1<TextOccurrenceRenameMarker> textOccurenceRenameMarkers);
    public void ClearBase();
    public void AddExtraTextOccurrence(ITextOccurrenceRenameMarker occurrence);
}
public enum JetBrains.ReSharper.Refactorings.Rename.RenameFilesOption : Enum {
    public int value__;
    public static RenameFilesOption NothingToRename;
    public static RenameFilesOption RenameWithoutConfirmation;
    public static RenameFilesOption RenameWithConfirmation;
}
public class JetBrains.ReSharper.Refactorings.Rename.RenameHierarchyConflictTextProvider : HierarchyConflictTextProviderBase {
    public virtual string WillAlsoOverride();
    public virtual string WillAlsoImplement();
    public virtual string QuasiImplements();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Rename.RenameNamespaceProvider : RenameWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.Rename.RenameNamespaceRefactoringUtil : object {
    public static string GetNewDeclarationName(INamespaceDeclaration nd, INamespace originalNamespace, string newName, Boolean& haveUpperChanges, string topLevelNamespace);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Refactorings.Rename.RenameRefactoring : DrivenRefactoringBase`1<RenameWorkflowBase> {
    private UsageStatistics myUsageStatistics;
    private RenameFileHelper myRenameFileHelper;
    private IRenameWorkflow JetBrains.ReSharper.Feature.Services.Refactorings.Specific.Rename.IRenameRefactoring.Workflow { get; }
    public RenameRefactoring(RenameWorkflowBase workFlow, ISolution solution, IRefactoringDriver driver);
    private sealed virtual override IRenameWorkflow JetBrains.ReSharper.Feature.Services.Refactorings.Specific.Rename.IRenameRefactoring.get_Workflow();
    private void SearchFileReferences(IProgressIndicator pi, FileRename fileRename);
    private static VirtualFileSystemPath GetProjectItemLocation(IProjectItem item);
    private bool FilterUserFile(IPsiSourceFile psiSourceFile);
    private ValueTuple`2<IConflictSearcher, IConflictSearcher> CreateConflictSearchers();
    private void AddConflictSearchers(AtomicRenameBase renameBase, ICollection`1<IConflictSearcher> coldConflictSearchers, ICollection`1<IConflictSearcher> hotConflictSearchers);
    public virtual bool Execute(IProgressIndicator pi);
    private bool IsInvalidNewName(AtomicRenameBase x);
    private void AddHierarchyConflicts();
    private void CheckSuspiciousReferences(List`1<ReferenceBinding> suspiciousReferences, IProgressIndicator pi);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Execute>b__10_0(FileRename fileRename, string newName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Execute>b__10_1(IConflict c);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.Refactorings.RefactoringsMruSettings", "JetBrains.ReSharper.Refactorings.Resources.Strings", "RenameRefactoringSettingsSettingDescription")]
public class JetBrains.ReSharper.Refactorings.Rename.RenameRefactoringSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "WhetherToRenameFileNameWhenASingleClassInTheFileIsRenamedSettingDescription")]
public bool DoRenameFile;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "WhetherToRenameTypeWhenTheFileIsRenamedSettingDescription")]
public bool DoRenameType;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "WhetherToSearchForTextInStringsSettingDescription")]
public bool DoSearchForTextInStrings;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "WhetherToIgnoreAnyReferencesWhenFileIsRenamedSettingDescription")]
public bool DoQuickRename;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "WhetherToSearchForPossibleDynamicOccurrencesSettingDescription")]
public bool DoSearchForDynamics;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Refactorings.Resources.Strings", "WhetherToSearchForStructurallyCompatibleMembersSettingDescription")]
public bool DoSearchForStructurallyCompatible;
}
[GlobalSettingsUpgraderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Rename.RenameRefactoringSettingsUpgrader : SettingTablesUpgrader {
    public RenameRefactoringSettingsUpgrader(ProductConfigurations productConfigurations);
    protected virtual void DoUpgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime, SettingsTableBase workspaceSettingsTable, SettingsTableBase globalSettingsTable);
}
public enum JetBrains.ReSharper.Refactorings.Rename.RenameScope : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("_Method")]
public static RenameScope Method;
    [LocalizedDescriptionAttribute("C_lass")]
public static RenameScope Class;
    [LocalizedDescriptionAttribute("_Project")]
public static RenameScope Project;
    [LocalizedDescriptionAttribute("_Solution")]
public static RenameScope Solution;
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.Rename.RenameTupleComponentProvider : RenameWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public static class JetBrains.ReSharper.Refactorings.Rename.RenameUtil : object {
    public static PsiLanguageType GetPsiLanguageTypeOrKnownLanguage(IDeclaredElement declaredElement);
    private static PsiLanguageType GetPsiLanguageTypeOrKnownLanguage(IPathDeclaredElement pathDeclaredElement);
}
public class JetBrains.ReSharper.Refactorings.Rename.RenameWorkflow : RenameWorkflowBase {
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool HasUI { get; }
    public RenameWorkflow(ISolution solution, string actionId);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    private IRefactoringPage GetInitialPage();
    public virtual bool get_HasUI();
    public virtual void UpdateInitialReferences(IProgressIndicator pi);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual bool Validate();
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public virtual bool IsAvailable(IDataContext context);
    private void CollectFrontendUsages();
    private void RenameFrontendUsages();
    [CompilerGeneratedAttribute]
private IRefactoringPage <get_FirstPendingRefactoringPage>b__2_0(IProgressIndicator indicator);
}
public abstract class JetBrains.ReSharper.Refactorings.Rename.RenameWorkflowBase : DrivenRefactoringWorkflow {
    private static ILogger ourLog;
    [CanBeNullAttribute]
private DerivedStageExecuter myDerivedStageExecuter;
    private InitialStageExecuter myInitialStageExecuter;
    [CompilerGeneratedAttribute]
private RenameDataModel <DataModel>k__BackingField;
    [CompilerGeneratedAttribute]
private RenameDataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CachingLanguageSpecificImpl`1<RenameHelperBase> <LanguageSpecific>k__BackingField;
    public RenameDataModel DataModel { get; protected set; }
    private InitialStageExecuter InitialStageExecuter { get; }
    public RenameDataProvider DataProvider { get; protected set; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public bool HasUI { get; }
    private DerivedStageExecuter DerivedStageExecuter { get; }
    public CachingLanguageSpecificImpl`1<RenameHelperBase> LanguageSpecific { get; }
    protected RenameWorkflowBase(ISolution solution, string actionId);
    private static RenameWorkflowBase();
    [CompilerGeneratedAttribute]
public RenameDataModel get_DataModel();
    [CompilerGeneratedAttribute]
protected void set_DataModel(RenameDataModel value);
    private InitialStageExecuter get_InitialStageExecuter();
    [CompilerGeneratedAttribute]
public RenameDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
protected void set_DataProvider(RenameDataProvider value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    public virtual bool get_HasUI();
    private DerivedStageExecuter get_DerivedStageExecuter();
    [CompilerGeneratedAttribute]
public sealed virtual CachingLanguageSpecificImpl`1<RenameHelperBase> get_LanguageSpecific();
    public sealed virtual IList`1<IReference> GetElementReferences(IDeclaredElement declaredElement);
    public sealed virtual void SetHierarchyConflicts(List`1<HierarchyConflict> conflicts);
    protected bool IsAvailable(IDataContext context, IList`1& declaredElements);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    private bool CheckFileRenamesWritable(ICollection`1<FileRename> fileRenames);
    public void TryAddFileRename(IDeclaredElement declaredElement, string name);
    private void Find(IProgressIndicator pi, IList`1<IDeclaredElement> elementsToSearch);
    private IDeclaredElement[] GetElementsToSearch();
    protected FindExecution Consume(FindResult result);
    protected virtual void ConsumeReference(IFindResultReference resultReference);
    protected void ConsumeReference(IDeclaredElement declaredElement, IReference reference);
    protected void ConsumeText(FindResult result);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public void IterateRenameFiles(Action`2<FileRename, string> action);
    public IRefactoringPage CommitInitialStage();
    protected IRefactoringPage LoadNextPage(IProgressIndicator pi);
    public IRefactoringPage CommitRenameDerivedStage(IProgressIndicator pi);
    private IRefactoringPage NextReferencesConfirmationPage(IList`1<AtomicRenameBase> renames, IProgressIndicator pi);
    protected virtual void RenameFile(FileRename fileRename, string newName);
    public void RenameTextOccurrences();
    protected void SetRenameDataProvider(RenameDataProvider value);
    public void AddExtraDeclaredElements(IEnumerable`1<IDeclaredElement> elements);
    public virtual void UpdateInitialReferences(IProgressIndicator pi);
    private IDeclaredElement[] GetElementsToSearch(DerivedElementsActionResult actionResult);
    public void UpdateReferences(DerivedElementsActionResult result, IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.Rename.SameNestedNameRenameConflictSearcher : object {
    [NotNullAttribute]
private AtomicRenameBase myRename;
    public ConflictSearchResult LastResult { get; }
    public SameNestedNameRenameConflictSearcher(AtomicRenameBase rename);
    public sealed virtual ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    public sealed virtual ConflictSearchResult get_LastResult();
}
public class JetBrains.ReSharper.Refactorings.Rename.Stages.DerivedStageExecuter : object {
    private RenameDataModel myRenameDataModel;
    private bool myEnabled;
    public void Init(RenameDataModel renameDataModel, ISolution solution);
    public IRefactoringPage Run(IProgressIndicator pi);
    [NotNullAttribute]
public static OccurrencesPage CreateOccurrencesPage(Lifetime lifetime, ISolution solution, List`1<TextOccurrenceRenameMarker> occurrences, bool enabled, Action`2<List`1<TextOccurrenceRenameMarker>, bool> setSelected);
    [CompilerGeneratedAttribute]
private void <Run>b__3_0(List`1<TextOccurrenceRenameMarker> list, bool allEnabled);
}
public class JetBrains.ReSharper.Refactorings.Rename.Stages.InitialStageExecuter : object {
    [NotNullAttribute]
public IRefactoringPage Run(IProgressIndicator pi, RenameWorkflowBase renameWorkflow);
    [NotNullAttribute]
private static IRefactoringPage GetPage(RenameWorkflowBase workflow);
}
public class JetBrains.ReSharper.Refactorings.Rename.Stages.RenameAdditionalEntitiesWorkflow : DrivenRefactoringWorkflow {
    private DerivedElementsActionResult myActionResult;
    private UnderlyingRenameWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private RefactoringNotificationModel <Model>k__BackingField;
    public RefactoringNotificationModel Model { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public IActionResult ActionResult { get; }
    public RenameAdditionalEntitiesWorkflow(RenameWorkflowBase workflow);
    [CompilerGeneratedAttribute]
public sealed virtual RefactoringNotificationModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(RefactoringNotificationModel value);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public sealed virtual IActionResult get_ActionResult();
    public sealed virtual void PreExecuteAsync();
    public sealed virtual bool ShouldBeCancelled(IRefactoringWorkflow refactoringWorkflow);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator pi);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.Rename.SuspiciousReferencesFinder : SearchDomainVisitorParallel {
    private List`1<ReferenceBinding> mySuspiciousBindings;
    private RenameWorkflowBase myRenameWorkflow;
    private SuspiciousReferenceSearchContext myContext;
    public bool ProcessingIsFinished { get; }
    private SuspiciousReferencesFinder(ISearchDomain searchDomain, IProgressIndicator pi, HashSet`1<string> names, HashSet`1<IDeclaredElement> declaredElements, IFilteringReferenceProviderFactory referenceProviderFactory, RenameWorkflowBase renameWorkflow);
    public static List`1<ReferenceBinding> Find(RenameWorkflowBase workflow, IProgressIndicator pi);
    public virtual bool get_ProcessingIsFinished();
    protected virtual bool ProcessProjectFile(IPsiSourceFile sourceFile);
    protected virtual bool ProcessElement(ITreeNode element);
    protected virtual bool ProcessAssembly(IPsiAssembly assembly);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(IReference reference, IDeclaredElement suspiciousElement, ISubstitution suspiciousSubstitution);
    [CompilerGeneratedAttribute]
internal static void <Find>g__ProcessAtomicRename|5_0(AtomicRenameBase atomicRename, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static ISearchDomain <Find>g__GetFilteredSearchDomain|5_1(SearchDomainData searchDomainData, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static IFilteringReferenceProviderFactory <Find>g__GetFilteringReferenceProviderFactory|5_2(<>c__DisplayClass5_0& );
}
internal class JetBrains.ReSharper.Refactorings.Rename.UnderlyingRenameWorkflow : RenameWorkflow {
    private List`1<SmartDeclarationPointer`1<IDeclaration>> myDeclarationPointers;
    private Func`1<bool> myRestoreNameAction;
    private bool myInitialWasChecked;
    private ITextControl myTextControl;
    [CompilerGeneratedAttribute]
private Lifetime <CustomLifetime>k__BackingField;
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool HasUI { get; }
    public Lifetime CustomLifetime { get; private set; }
    public UnderlyingRenameWorkflow(GlobalInlineRenameWorkflow workflow, RenameRefactoringService renameRefactoringService, string actionId, ISolution solution, Func`1<bool> restoreaction);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool Initialize(IDataContext context);
    public virtual bool get_HasUI();
    public void UpdateReferences();
    private IList`1<IDeclaredElement> GetElementsToSearch(DerivedElementsActionResult actionResult);
    protected virtual void ConsumeReference(IFindResultReference resultReference);
    private void AddDerivedElementsFromElement(DerivedElement parentDerivedElement, DerivedElementsActionResult actionResult);
    private FindExecution ConsumeAndConquer(FindResult arg);
    private void AddDerivedElementsFromReference(IReference reference);
    private void AddElements(IEnumerable`1<DerivedElement> declaredElements, DerivedElementsActionResult actionResult);
    protected virtual void RenameFile(FileRename fileRename, string newName);
    public virtual void UpdateInitialReferences(IProgressIndicator pi);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    private bool RestoreAndReload();
    [CompilerGeneratedAttribute]
public sealed virtual Lifetime get_CustomLifetime();
    [CompilerGeneratedAttribute]
private void set_CustomLifetime(Lifetime value);
    [CompilerGeneratedAttribute]
private string <PreExecute>b__22_2(IDeclaredElement r);
}
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.Rename.VarArgParameterCanNotBeRenamed : AtomicRenamesFactory {
    public virtual bool IsApplicable(IDeclaredElement declaredElement);
    public virtual RenameAvailabilityCheckResult CheckRenameAvailability(IDeclaredElement declaredElement);
}
public interface JetBrains.ReSharper.Refactorings.RenameFile.IRenameFileDataProvider {
    public string NewName { get; }
    public bool RenameType { get; }
    public IProjectFile ProjectFile { get; }
    public abstract virtual string get_NewName();
    public abstract virtual bool get_RenameType();
    public abstract virtual IProjectFile get_ProjectFile();
}
public class JetBrains.ReSharper.Refactorings.RenameFile.RenameFileDataModel : object {
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <RenameType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuggestRenameType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowChangeExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <PsiFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    public string NewName { get; public set; }
    public IProperty`1<bool> RenameType { get; }
    public bool SuggestRenameType { get; public set; }
    public bool AllowChangeExtension { get; public set; }
    public IProjectFile ProjectFile { get; }
    public IFile PsiFile { get; }
    public string Extension { get; }
    public string FullNewName { get; }
    public RenameFileDataModel(IProjectFile projectFile, Lifetime lifetime, IRenameFileDataProvider dataProvider);
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_RenameType();
    [CompilerGeneratedAttribute]
public bool get_SuggestRenameType();
    [CompilerGeneratedAttribute]
public void set_SuggestRenameType(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowChangeExtension();
    [CompilerGeneratedAttribute]
public void set_AllowChangeExtension(bool value);
    [CompilerGeneratedAttribute]
public IProjectFile get_ProjectFile();
    [CompilerGeneratedAttribute]
public IFile get_PsiFile();
    [CompilerGeneratedAttribute]
public string get_Extension();
    public string get_FullNewName();
}
public class JetBrains.ReSharper.Refactorings.RenameFile.RenameFileDataProvider : object {
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameType>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFile <ProjectFile>k__BackingField;
    public string NewName { get; }
    public bool RenameType { get; }
    public IProjectFile ProjectFile { get; }
    public RenameFileDataProvider(string newName, bool renameType, IProjectFile projectFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NewName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RenameType();
    [CompilerGeneratedAttribute]
public sealed virtual IProjectFile get_ProjectFile();
}
public class JetBrains.ReSharper.Refactorings.RenameFile.RenameFileHelper : object {
    protected RenameFileWorkflow Workflow;
    public bool IsLanguageSupported { get; }
    public bool SuggestTypeRename { get; }
    public bool AllowChangeExtension { get; }
    public RenameFileHelper(RenameFileWorkflow workflow);
    public virtual bool get_IsLanguageSupported();
    public virtual bool get_SuggestTypeRename();
    public bool get_AllowChangeExtension();
    public virtual void PostRename(IProjectFile projectFile, string newName);
    public virtual void PreRename(IProjectFile projectFile, IFile psiFile, string newName, IProgressIndicator subPi);
    public virtual IDeclaredElement GetSingleTypeElement(IFile psiFile);
}
public class JetBrains.ReSharper.Refactorings.RenameFile.RenameFilePage : SingleBeRefactoringPage {
    private RenameFileDataModel myDataModel;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public RenameFilePage(RenameFileDataModel dataModel, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    public virtual bool RefreshContents(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__10_0(string s);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.RenameFile.RenameFileProvider : RenameWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.RenameFile.RenameFileRefactoring : DrivenRefactoring`2<RenameFileWorkflow, RefactoringExecBase`2<RenameFileWorkflow, RenameFileRefactoring>> {
    private RenameFileWorkflow myWorkflow;
    public RenameFileRefactoring(RenameFileWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.RenameFile.RenameFileWorkflow : DrivenRefactoringWorkflow2`1<RenameFileHelper> {
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    private IRenameFileDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private RenameFileDataModel <DataModel>k__BackingField;
    public HelpId HelpKeyword { get; }
    public PsiLanguageType Language { get; private set; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public RenameFileDataModel DataModel { get; private set; }
    public RenameFileWorkflow(ISolution solution, string actionId);
    public virtual HelpId get_HelpKeyword();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(PsiLanguageType value);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public void SetDataProvider(IRenameFileDataProvider dataProvider);
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailableEx(IDataContext context, IProjectFile& projectFile);
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    [CompilerGeneratedAttribute]
public RenameFileDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(RenameFileDataModel value);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual RenameFileHelper CreateUnsupportedHelper();
    protected virtual RenameFileHelper CreateHelper(IRefactoringLanguageService service);
    public virtual bool PostExecute(IProgressIndicator pi);
}
public abstract class JetBrains.ReSharper.Refactorings.RenameModel.AnonymousTypePropertyAtomicRenameBase : AtomicRenameBase {
    private IDeclaredElementPointer`1<IDeclaredElement> myOriginalElementPointer;
    private IDeclaredElementPointer`1<IDeclaredElement> myNewElementPointer;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldName>k__BackingField;
    public IList`1<IDeclaredElement> SecondaryDeclaredElements { get; }
    public IDeclaredElement NewDeclaredElement { get; }
    public string NewName { get; }
    public string OldName { get; }
    public IDeclaredElement PrimaryDeclaredElement { get; }
    protected AnonymousTypePropertyAtomicRenameBase(IDeclaredElement originalElement, string newName);
    public virtual IList`1<IDeclaredElement> get_SecondaryDeclaredElements();
    public virtual void Rename(IRenameRefactoring executer, IProgressIndicator pi, bool hasConflictsWithDeclarations, IRefactoringDriver driver);
    protected abstract virtual IDeclaredElement SetName(IDeclaredElement element, string name);
    protected abstract virtual int CompareReferencesOnMemberDeclarations(IReference r1, IReference r2);
    public virtual IDeclaredElement get_NewDeclaredElement();
    [CompilerGeneratedAttribute]
public sealed virtual string get_NewName();
    [CompilerGeneratedAttribute]
public virtual string get_OldName();
    public virtual IDeclaredElement get_PrimaryDeclaredElement();
}
public class JetBrains.ReSharper.Refactorings.RenameModel.ElementChange : DeclaredElementOccurrence {
    private DerivedElement myElementPointer;
    private IconId myIcon;
    private SequentialLifetimes myLifetimes;
    private string myName;
    private bool myEnabled;
    private bool myIsValid;
    private IPsiServices myPsiServices;
    private Lifetime myLifetime;
    [CompilerGeneratedAttribute]
private DerivedElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public string SectionName { get; }
    public string ElementPresented { get; }
    public string TextOfInvalidElement { get; }
    public bool IsValidCached { get; }
    public bool IsValid { get; }
    public bool Included { get; public set; }
    [CanBeNullAttribute]
public DerivedElement DeclaredElement { get; private set; }
    public IconId Icon { get; }
    public ElementChange(bool enabled, DerivedElement declaredElement, Lifetime lifetime);
    public sealed virtual string get_SectionName();
    public string get_ElementPresented();
    public string get_TextOfInvalidElement();
    public bool get_IsValidCached();
    public sealed virtual bool get_IsValid();
    public sealed virtual bool get_Included();
    public sealed virtual void set_Included(bool value);
    [CompilerGeneratedAttribute]
public DerivedElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
private void set_DeclaredElement(DerivedElement value);
    public IconId get_Icon();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public void Reload();
    public void Dispose();
    private void UpdateDeclaredElement(object sender, EventArgs`1<DocumentChange> args);
    private void InitElementLifetimes();
    [NotifyPropertyChangedInvocatorAttribute]
protected virtual void OnPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
private void <UpdateDeclaredElement>b__33_0();
    [CompilerGeneratedAttribute]
private void <UpdateDeclaredElement>b__33_1();
    [CompilerGeneratedAttribute]
private void <InitElementLifetimes>b__34_0(Lifetime lt);
}
public interface JetBrains.ReSharper.Refactorings.RenameModel.IRenameAdditionalOccurrence {
    public string SectionName { get; }
    public bool Included { get; public set; }
    public abstract virtual string get_SectionName();
    public abstract virtual bool get_Included();
    public abstract virtual void set_Included(bool value);
}
public interface JetBrains.ReSharper.Refactorings.RenameNamespace.INamespaceDeclarationUpdater {
    public abstract virtual void PreProcess();
    public abstract virtual void SetNewName();
    public abstract virtual void RestoreReferences();
}
public interface JetBrains.ReSharper.Refactorings.RenameNamespace.IRenameNamespace {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<INamespaceDeclarationUpdater> BuildNamespaceDeclarationUpdatersForFile(INamespace namespace, IFile file, string newName);
    [CanBeNullAttribute]
public abstract virtual IConflictSearcher GetConflictSearcher(INamespace namespace, string name);
}
public interface JetBrains.ReSharper.Refactorings.RenameNamespace.IRenameNamespaceFilesFilter {
    public abstract virtual bool IsFiltered(IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Refactorings.RenameNamespace.RenameNamespaceDataProvider : RenameDataProvider {
    [CompilerGeneratedAttribute]
private IRenameNamespaceFilesFilter <Filter>k__BackingField;
    [CanBeNullAttribute]
public IRenameNamespaceFilesFilter Filter { get; public set; }
    public RenameNamespaceDataProvider(Dictionary`2<IDeclaredElement, string> dictionary);
    public RenameNamespaceDataProvider(IDeclaredElement element, string newName);
    public RenameNamespaceDataProvider(string newName);
    [CompilerGeneratedAttribute]
public IRenameNamespaceFilesFilter get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(IRenameNamespaceFilesFilter value);
}
public class JetBrains.ReSharper.Refactorings.RenameNamespace.RenameNamespaceExec : RefactoringExecBase`2<RenameNamespaceWorkflow, RenameNamespaceRefactoring> {
    public RenameNamespaceExec(RenameNamespaceWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.RenameNamespace.RenameNamespaceModel : object {
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Items>k__BackingField;
    public string NewName { get; public set; }
    public PsiLanguageType Language { get; }
    public ISolution Solution { get; }
    public List`1<string> Items { get; public set; }
    public RenameNamespaceModel(string namespaceQualifiedName, PsiLanguageType language, ISolution solution);
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    [CompilerGeneratedAttribute]
public List`1<string> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<string> value);
}
public class JetBrains.ReSharper.Refactorings.RenameNamespace.RenameNamespacePage : SingleBeRefactoringPage {
    private RenameNamespaceModel myDataModel;
    public static string TargetName;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public RenameNamespacePage(RenameNamespaceModel dataModel, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__11_0(string v);
}
public class JetBrains.ReSharper.Refactorings.RenameNamespace.RenameNamespaceRefactoring : DrivenRefactoring`2<RenameNamespaceWorkflow, RenameNamespaceExec> {
    private IPsiServices myPsiServices;
    private INamespace myNamespace;
    private string myNewName;
    private NamespaceRedundancyProblemsFixer myNamespaceRedundancyProblemsFixer;
    [CompilerGeneratedAttribute]
private CachingLanguageSpecificImpl`1<RenameHelperBase> <LanguageSpecific>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<KeyValuePair`2<PsiLanguageType, IList`1<IReferencePointer>>> <References>k__BackingField;
    protected CachingLanguageSpecificImpl`1<RenameHelperBase> LanguageSpecific { get; }
    public IList`1<KeyValuePair`2<PsiLanguageType, IList`1<IReferencePointer>>> References { get; private set; }
    public RenameNamespaceRefactoring(RenameNamespaceWorkflow workflow, INamespace namespace, string newName, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
protected CachingLanguageSpecificImpl`1<RenameHelperBase> get_LanguageSpecific();
    [CompilerGeneratedAttribute]
public IList`1<KeyValuePair`2<PsiLanguageType, IList`1<IReferencePointer>>> get_References();
    [CompilerGeneratedAttribute]
private void set_References(IList`1<KeyValuePair`2<PsiLanguageType, IList`1<IReferencePointer>>> value);
    public void DoRefactoring(IProgressIndicator pi);
    private void RebindReferences(IProgressIndicator indicator);
    private void RestoreReferences(IProgressIndicator indicator, List`1<INamespaceDeclarationUpdater> updaters);
    private void SetNewName(IProgressIndicator progressIndicator, List`1<INamespaceDeclarationUpdater> updaters);
    [CanBeNullAttribute]
private List`1<INamespaceDeclarationUpdater> PreprocessDeclarations(IProgressIndicator pi);
    [NotNullAttribute]
private IReadOnlyCollection`1<ICaseSensitiveNamespace> GetCaseSensitiveNamespaces();
    public void SearchReferences(IProgressIndicator searchProgress);
    private void SearchReferences(IFindResultConsumer`1<FindResult> consumer, IProgressIndicator progressIndicator);
    public IConflictSearcher GetConflictSearcher();
    public void RenameTextualOccurrences();
    public virtual bool Execute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.RenameNamespace.RenameNamespaceWorkflow : DrivenRefactoringWorkflow {
    private INamespace myNamespace;
    [CompilerGeneratedAttribute]
private RenameNamespaceModel <NamespaceModel>k__BackingField;
    [CompilerGeneratedAttribute]
private IRenameNamespaceFilesFilter <FilesFilter>k__BackingField;
    private RenameDataProvider myRenameDataProvider;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    public RenameNamespaceModel NamespaceModel { get; private set; }
    [CanBeNullAttribute]
public IRenameNamespaceFilesFilter FilesFilter { get; private set; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public PsiLanguageType Language { get; private set; }
    public bool HasUI { get; }
    public HelpId HelpKeyword { get; }
    public RenameNamespaceWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public RenameNamespaceModel get_NamespaceModel();
    [CompilerGeneratedAttribute]
private void set_NamespaceModel(RenameNamespaceModel value);
    [CompilerGeneratedAttribute]
public IRenameNamespaceFilesFilter get_FilesFilter();
    [CompilerGeneratedAttribute]
private void set_FilesFilter(IRenameNamespaceFilesFilter value);
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(PsiLanguageType value);
    public virtual bool get_HasUI();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    [CanBeNullAttribute]
private static INamespace GetNamespace(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public void SetDataProvider(RenameDataProvider dataProvider);
}
public class JetBrains.ReSharper.Refactorings.RenameProject.Impl.LinkedFilesFix : object {
    protected List`1<IProjectFile> LinkedFiles;
    protected VirtualFileSystemPath OriginalLocation;
    public string Name { get; }
    public LinkedFilesFix(RenameProjectDataModel model);
    public sealed virtual string get_Name();
    public sealed virtual void Execute(IProjectModelTransactionCookie cookie, IProject newProject, IProgressIndicator pi);
    protected virtual void AddProjectFile(IProjectModelTransactionCookie cookie, IProjectFolder parent, IProjectItem matchingFile, IProjectFile originalFile);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__2_0(IProjectFile x);
}
internal class JetBrains.ReSharper.Refactorings.RenameProject.Impl.MoveInFileSystemAction : object {
    private VirtualFileSystemPath myFrom;
    private VirtualFileSystemPath myTo;
    public string Name { get; }
    public MoveInFileSystemAction(VirtualFileSystemPath from, VirtualFileSystemPath to);
    public sealed virtual string get_Name();
    public sealed virtual void Commit();
    public sealed virtual void Rollback();
}
public class JetBrains.ReSharper.Refactorings.RenameProject.Impl.ProjectPropertiesFix : object {
    private RenameProjectDataModel myModel;
    public string Name { get; }
    public ProjectPropertiesFix(RenameProjectDataModel model);
    public sealed virtual string get_Name();
    public sealed virtual void Execute(IProjectModelTransactionCookie cookie, IProject newProject, IProgressIndicator pi);
    private bool EqualsProjectName(List`1<IManagedProjectConfiguration> configurations, Func`2<IManagedProjectConfiguration, string> func);
}
public class JetBrains.ReSharper.Refactorings.RenameProject.Impl.ProjectReferencesFix : object {
    private ICollection`1<IProjectToProjectReference> myReferences;
    public string Name { get; }
    public ProjectReferencesFix(RenameProjectDataModel model);
    public sealed virtual string get_Name();
    public sealed virtual void Execute(IProjectModelTransactionCookie cookie, IProject newProject, IProgressIndicator pi);
    protected virtual void ReplaceReference(IProjectModelTransactionCookie cookie, IProjectToProjectReference reference, IProject newProject, IProject someProject);
}
public interface JetBrains.ReSharper.Refactorings.RenameProject.IRenameInSolutionAction {
    [NotNullAttribute]
public abstract virtual IProject GetNewProject();
}
public class JetBrains.ReSharper.Refactorings.RenameProject.OccurenceMarker : object {
    [NotNullAttribute]
private IDocument myDocument;
    [CanBeNullAttribute]
private RangeMarker myRangeMarker;
    private TextRange myTextRange;
    [CompilerGeneratedAttribute]
private IProject <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    [CanBeNullAttribute]
public IProject Owner { get; }
    [NotNullAttribute]
public VirtualFileSystemPath Location { get; }
    [NotNullAttribute]
public PsiLanguageType Language { get; }
    public bool IsValid { get; }
    public OccurenceMarker(TextOccurrenceRenameMarker occurrence);
    public OccurenceMarker(IReference reference);
    [CompilerGeneratedAttribute]
public IProject get_Owner();
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_Location();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_Language();
    public bool get_IsValid();
    public void UpdateDocument(IDocument document);
    public void Init();
    public DocumentRange GetDocumentRange();
}
internal class JetBrains.ReSharper.Refactorings.RenameProject.RenameNamespaceFilter : object {
    [NotNullAttribute]
private IProject myProject;
    public RenameNamespaceFilter(IProject project);
    public sealed virtual bool IsFiltered(IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectDataModel : object {
    [NotNullAttribute]
private static Regex ourNamePattern;
    [NotNullAttribute]
public ISolution Solution;
    [NotNullAttribute]
public string OriginalName;
    [NotNullAttribute]
public VirtualFileSystemPath OriginalProjectFileLocation;
    [NotNullAttribute]
private string myName;
    public bool CanRenameProjectFolder;
    public bool RenameProjectFolder;
    public bool CanRenameTextOccurrences;
    public bool RenameTextOccurrences;
    public bool RenameRootNamespaceNotSupported;
    public bool CanRenameRootNamespace;
    public bool RenameRootNamespace;
    [CompilerGeneratedAttribute]
private IProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private RenameProjectSupport <Support>k__BackingField;
    [CompilerGeneratedAttribute]
private IProject <NewProject>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<OccurenceMarker> <TextOccurrences>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<OccurenceMarker> <ModuleReferenceOccurrences>k__BackingField;
    [NotNullAttribute]
public string Name { get; public set; }
    [NotNullAttribute]
public string OriginalNamespaceName { get; }
    [NotNullAttribute]
public string NamespaceName { get; }
    public bool ChangedName { get; }
    public bool CasingRename { get; }
    [NotNullAttribute]
public IProject Project { get; private set; }
    [NotNullAttribute]
public RenameProjectSupport Support { get; }
    [CanBeNullAttribute]
public IProject NewProject { get; private set; }
    [CanBeNullAttribute]
public IList`1<OccurenceMarker> TextOccurrences { get; public set; }
    [CanBeNullAttribute]
public IList`1<OccurenceMarker> ModuleReferenceOccurrences { get; public set; }
    public string ProjectFileExtension { get; }
    public string NewProjectFileName { get; }
    public VirtualFileSystemPath OldProjectFile { get; }
    public VirtualFileSystemPath NewProjectFile { get; }
    public VirtualFileSystemPath NewProjectFileInOldProjectFolder { get; }
    public VirtualFileSystemPath OldProjectFolder { get; }
    public VirtualFileSystemPath NewProjectFolder { get; }
    public RenameProjectDataModel(IProject project, RenameProjectSupport support);
    private static RenameProjectDataModel();
    public string get_Name();
    public void set_Name(string value);
    public string get_OriginalNamespaceName();
    public string get_NamespaceName();
    public bool get_ChangedName();
    public bool get_CasingRename();
    [CompilerGeneratedAttribute]
public IProject get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(IProject value);
    [CompilerGeneratedAttribute]
public RenameProjectSupport get_Support();
    [CompilerGeneratedAttribute]
public IProject get_NewProject();
    [CompilerGeneratedAttribute]
private void set_NewProject(IProject value);
    [CompilerGeneratedAttribute]
public IList`1<OccurenceMarker> get_TextOccurrences();
    [CompilerGeneratedAttribute]
public void set_TextOccurrences(IList`1<OccurenceMarker> value);
    [CompilerGeneratedAttribute]
public IList`1<OccurenceMarker> get_ModuleReferenceOccurrences();
    [CompilerGeneratedAttribute]
public void set_ModuleReferenceOccurrences(IList`1<OccurenceMarker> value);
    public string get_ProjectFileExtension();
    public string get_NewProjectFileName();
    public VirtualFileSystemPath get_OldProjectFile();
    public VirtualFileSystemPath get_NewProjectFile();
    public VirtualFileSystemPath get_NewProjectFileInOldProjectFolder();
    public VirtualFileSystemPath get_OldProjectFolder();
    public VirtualFileSystemPath get_NewProjectFolder();
    public IEnumerable`1<FileSystemPair> FindRelatedFiles();
    public void RestoreState();
    public void AssignNewProject(IProject newProject);
    [CanBeNullAttribute]
public string Validate();
}
public class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectPage : SingleBeRefactoringPage {
    private RenameProjectWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private IProperty`1<string> <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <RenameProjectFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <RenameRootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <RenameTextOccurrences>k__BackingField;
    public IProperty`1<string> NewName { get; }
    public IProperty`1<bool> RenameProjectFolder { get; }
    public IProperty`1<bool> RenameRootNamespace { get; }
    public IProperty`1<bool> RenameTextOccurrences { get; }
    public string Title { get; }
    public string Description { get; }
    public RenameProjectPage(RenameProjectWorkflow workflow);
    [CompilerGeneratedAttribute]
public IProperty`1<string> get_NewName();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_RenameProjectFolder();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_RenameRootNamespace();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_RenameTextOccurrences();
    public virtual string get_Title();
    public virtual string get_Description();
    public virtual BeControl GetPageContent();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectPropertiesRequest : object {
    public IEnumerable`1<string> RequestedProperties { get; }
    public sealed virtual IEnumerable`1<string> get_RequestedProperties();
}
public class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectRefactoring : DrivenRefactoringBase`1<RenameProjectWorkflow> {
    [NotNullAttribute]
private ILogger myLogger;
    public RenameProjectRefactoring(ILogger logger, RenameProjectWorkflow workflow, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    private static void BindModuleReference(IReference reference, IProject newProject);
    [CanBeNullAttribute]
private INamespace FindNamespace(IProject newProject, RenameProjectDataModel model);
}
public abstract class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectSupport : object {
    public abstract virtual IRenameInSolutionAction CreateRenameInSolutionAction(RenameProjectDataModel model);
    public abstract virtual bool HasProjectInSolution(RenameProjectDataModel model, string name);
    public virtual IProjectModelFix CreateProjectReferencesFix(RenameProjectDataModel model);
    public virtual IProjectModelFix CreateLinkedFilesFix(RenameProjectDataModel model);
    public virtual IProjectModelFix CreateProjectPropertiesFix(RenameProjectDataModel model);
    public virtual void OnStart(RenameProjectDataModel model);
    public virtual void OnFinish(RenameProjectDataModel model);
    public virtual void OnSuccessfulFinish(RenameProjectDataModel model, IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectTextCollector : object {
    private RenameProjectWorkflow myWorkflow;
    private List`1<TextOccurrenceRenameMarker> myOccurrences;
    public RenameProjectTextCollector(RenameProjectWorkflow workflow, IProgressIndicator progressIndicator);
    public IRefactoringPage GetPage();
    private void SetModel(List`1<TextOccurrenceRenameMarker> occurrences);
    private FindExecution ConsumeOccurence(FindResult result);
    private void ConsumeOccurence(FindResultText result);
    [CompilerGeneratedAttribute]
private void <GetPage>b__3_0(List`1<TextOccurrenceRenameMarker> list, bool allEnabled);
}
public class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectTransaction : object {
    private ILogger myLogger;
    private RenameProjectDataModel myModel;
    private List`1<IRollbackAction> myCompletedActions;
    public RenameProjectTransaction(ILogger logger, RenameProjectDataModel model);
    public IProject Commit(IProgressIndicator pi);
    private void CommitAction(IRollbackAction action, IProgressIndicator pi);
    public void Rollback();
}
public class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectWorkflow : RenameProjectElementWorkflowBase`1<IProject> {
    [CanBeNullAttribute]
private string myPredefinedName;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private RenameProjectSupport <Support>k__BackingField;
    [CompilerGeneratedAttribute]
private RenameProjectDataModel <DataModel>k__BackingField;
    [CompilerGeneratedAttribute]
private RenameProjectTransaction <Transaction>k__BackingField;
    public ILogger Logger { get; }
    public RenameProjectSupport Support { get; }
    public RenameProjectDataModel DataModel { get; private set; }
    public RenameProjectTransaction Transaction { get; private set; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public RenameProjectWorkflow(ISolution solution, string actionId, RenameProjectSupport support, string predefinedName);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public RenameProjectSupport get_Support();
    [CompilerGeneratedAttribute]
public RenameProjectDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(RenameProjectDataModel value);
    [CompilerGeneratedAttribute]
public RenameProjectTransaction get_Transaction();
    [CompilerGeneratedAttribute]
private void set_Transaction(RenameProjectTransaction value);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator pi);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    public virtual void UnsuccessfulFinish(IProgressIndicator pi);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual IProject GetElementToRename(IProjectModelElement element);
    private List`1<OccurenceMarker> CollectModuleReferences(IProgressIndicator pi);
    private void RenameTextOccurrences(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private IRefactoringPage <get_FirstPendingRefactoringPage>b__17_0(IProgressIndicator pi);
}
[RefactoringWorkflowProviderAttribute("16")]
public class JetBrains.ReSharper.Refactorings.RenameProject.RenameProjectWorkflowProvider : RenameWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public static class JetBrains.ReSharper.Refactorings.RenameProjectElement.RenameProjectElementUtil : object {
    public static string MakePageTitle(string elementType);
    public static string MakePageDescription(string elementType, string elementName);
    public static bool CheckName(string name, Regex pattern, String& reason);
}
public abstract class JetBrains.ReSharper.Refactorings.RenameProjectElement.RenameProjectElementWorkflowBase`1 : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private T <Element>k__BackingField;
    public T Element { get; private set; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public bool HasUI { get; }
    public RefactoringActionGroup ActionGroup { get; }
    protected RenameProjectElementWorkflowBase`1(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public T get_Element();
    [CompilerGeneratedAttribute]
private void set_Element(T value);
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    public virtual bool get_HasUI();
    public virtual RefactoringActionGroup get_ActionGroup();
    public sealed virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    [CanBeNullAttribute]
private T GetElementToRename(IDataContext context);
    [CanBeNullAttribute]
protected abstract virtual T GetElementToRename(IProjectModelElement element);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.NamedTupleComponentSearcher : object {
    [NotNullAttribute]
[DebuggerStepThroughAttribute]
public static NamedTupleComponentSearcher GetInstance(PsiLanguageType language);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.RenameTupleComponent.NamedTupleComponentSearcher/<FindReferencesInScope>d__1")]
[NotNullAttribute]
public virtual IEnumerable`1<IReference> FindReferencesInScope(string componentName, ITreeNode scope);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.NonStrictNamedTupleComponentComparer : object {
    [NotNullAttribute]
public static IEqualityComparer`1<INamedTupleComponent> Instance;
    private static NonStrictNamedTupleComponentComparer();
    public sealed virtual bool Equals(INamedTupleComponent x, INamedTupleComponent y);
    public sealed virtual int GetHashCode(INamedTupleComponent obj);
    [PureAttribute]
public static bool AreTupleTypesMatch(DecoratedType`1<TupleTypeDecoration> x, DecoratedType`1<TupleTypeDecoration> y);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.RenameTupleComponentContext : UserDataHolder {
    [CompilerGeneratedAttribute]
private INamedTupleComponent <InitialTupleComponent>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTupleComponent <NewTupleComponent>k__BackingField;
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiServices <PsiServices>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeChangesTree <EstimatedTypeChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private PostActionsRegistry <PostActions>k__BackingField;
    [NotNullAttribute]
public INamedTupleComponent InitialTupleComponent { get; }
    [NotNullAttribute]
public INamedTupleComponent NewTupleComponent { get; }
    [NotNullAttribute]
public string OldName { get; }
    [NotNullAttribute]
public string NewName { get; }
    [NotNullAttribute]
public IEqualityComparer`1<INamedTupleComponent> NonStrictTupleComponentComparer { get; }
    [NotNullAttribute]
public IEqualityComparer`1<INamedTupleComponent> StrictTupleComponentComparer { get; }
    [NotNullAttribute]
public IRefactoringDriver Driver { get; }
    public IPsiServices PsiServices { get; }
    public TypeChangePropagationMode TypeChangePropagationMode { get; }
    public TypeChangesTree EstimatedTypeChanges { get; }
    public PostActionsRegistry PostActions { get; }
    public RenameTupleComponentContext(IPsiServices psiServices, INamedTupleComponent initialTupleComponent, INamedTupleComponent newTupleComponent, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public INamedTupleComponent get_InitialTupleComponent();
    [CompilerGeneratedAttribute]
public INamedTupleComponent get_NewTupleComponent();
    public string get_OldName();
    public string get_NewName();
    public IEqualityComparer`1<INamedTupleComponent> get_NonStrictTupleComponentComparer();
    public IEqualityComparer`1<INamedTupleComponent> get_StrictTupleComponentComparer();
    [CompilerGeneratedAttribute]
public sealed virtual IRefactoringDriver get_Driver();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiServices get_PsiServices();
    public sealed virtual TypeChangePropagationMode get_TypeChangePropagationMode();
    [CompilerGeneratedAttribute]
public sealed virtual TypeChangesTree get_EstimatedTypeChanges();
    [CompilerGeneratedAttribute]
public sealed virtual PostActionsRegistry get_PostActions();
    public sealed virtual object GetStateBeforeChange(IEnumerable`1<ITreeNode> scopes);
    public sealed virtual void FixStateAfterChange(object stateBeforeChange, IProgressIndicator progress);
    [NotNullAttribute]
private TupleComponentReferences FindReferencesInScope(ITreeNode scope);
    private void FixBrokenReferences(TupleComponentReferences tupleComponentReferences, IProgressIndicator progress);
    private void AddPostExecuteResolveCheck(IReference reference, INamedTupleComponent expectedTupleComponent, bool renameIfNotResolved);
    [CompilerGeneratedAttribute]
private TupleComponentReferences <GetStateBeforeChange>b__29_0(ITreeNode scope);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.RenameTupleComponentDataProvider : object {
    [NotNullAttribute]
public static DataConstant`1<RenameTupleComponentDataProvider> DataConstant;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [NotNullAttribute]
public string NewName { get; }
    public RenameTupleComponentDataProvider(string newName);
    private static RenameTupleComponentDataProvider();
    [CompilerGeneratedAttribute]
public string get_NewName();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.RenameTupleComponentHelper : object {
    [NotNullAttribute]
[DebuggerStepThroughAttribute]
public static RenameTupleComponentHelper GetInstance(PsiLanguageType language);
    [PureAttribute]
public virtual bool CanRename(IReference reference);
    [PureAttribute]
[CanBeNullAttribute]
public virtual IChangeNode`1<RenameTupleComponentContext> TryCreateChangeNode(IReference reference, RenameTupleComponentContext context);
    [NotNullAttribute]
public virtual IReference RenameReference(IReference reference, RenameTupleComponentContext context);
    [CanBeNullAttribute]
public virtual IReference FixPossibleNameMismatch(IReference suspiciousReference, RenameTupleComponentContext context);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.RenameTupleComponentModel : object {
    [CompilerGeneratedAttribute]
private IReferencePointer <InitialReferencePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [NotNullAttribute]
public IReferencePointer InitialReferencePointer { get; }
    [NotNullAttribute]
public string NewName { get; public set; }
    public RenameTupleComponentModel(IReferencePointer initialReferencePointer, string newName);
    [CompilerGeneratedAttribute]
public IReferencePointer get_InitialReferencePointer();
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public void set_NewName(string value);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.RenameTupleComponentPage : SingleBeRefactoringPage {
    private RenameTupleComponentModel myDataModel;
    [NotNullAttribute]
private ISolution mySolution;
    public static string TargetName;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; }
    public RenameTupleComponentPage(RenameTupleComponentModel dataModel, ISolution solution, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    public virtual string get_Title();
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__10_0(string value);
    [CompilerGeneratedAttribute]
private ValidationRuleWithProperty`1<string> <GetPageContent>b__10_1(IViewableProperty`1<string> p);
    [CompilerGeneratedAttribute]
private ValidationRuleWithProperty`1<string> <GetPageContent>b__10_2(IViewableProperty`1<string> p);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.RenameTupleComponentRefactoring : object {
    [NotNullAttribute]
private RenameTupleComponentWorkflow myWorkflow;
    [NotNullAttribute]
private IRefactoringDriver myDriver;
    public RenameTupleComponentRefactoring(RenameTupleComponentWorkflow workflow, IRefactoringDriver driver);
    public sealed virtual bool Execute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.RenameTupleComponentWorkflow : DrivenRefactoringWorkflow {
    [CanBeNullAttribute]
private IReferencePointer myInitialReferencePointer;
    [CanBeNullAttribute]
private RenameTupleComponentModel myModel;
    [CompilerGeneratedAttribute]
private RenameTupleComponentDataProvider <DataProvider>k__BackingField;
    [CanBeNullAttribute]
public RenameTupleComponentDataProvider DataProvider { get; protected set; }
    [NotNullAttribute]
public RenameTupleComponentModel Model { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public bool MightModifyManyDocuments { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public RenameTupleComponentWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public RenameTupleComponentDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
protected void set_DataProvider(RenameTupleComponentDataProvider value);
    public RenameTupleComponentModel get_Model();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    public virtual bool get_MightModifyManyDocuments();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.StrictNamedTupleComponentComparer : object {
    [NotNullAttribute]
public static IEqualityComparer`1<INamedTupleComponent> Instance;
    private static StrictNamedTupleComponentComparer();
    public sealed virtual bool Equals(INamedTupleComponent x, INamedTupleComponent y);
    public sealed virtual int GetHashCode(INamedTupleComponent obj);
    [PureAttribute]
public static bool AreTupleTypesMatch(DecoratedType`1<TupleTypeDecoration> x, DecoratedType`1<TupleTypeDecoration> y);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.RenameTupleComponent.TupleComponentExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static INamedTupleComponent WithNewName(INamedTupleComponent element, string newName);
    [ExtensionAttribute]
[PureAttribute]
public static DecoratedType`1<TupleTypeDecoration> WithNewComponentName(DecoratedType`1<TupleTypeDecoration> tupleType, int componentIndex, string newName);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.TupleComponentReferences : object {
    [NotNullAttribute]
public static TupleComponentReferences Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReference> <FullMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ValueTuple`2<IReference, INamedTupleComponent>> <NameMatches>k__BackingField;
    [NotNullAttribute]
public IReadOnlyList`1<IReference> FullMatches { get; }
    [NotNullAttribute]
public IReadOnlyList`1<ValueTuple`2<IReference, INamedTupleComponent>> NameMatches { get; }
    public TupleComponentReferences(IReadOnlyList`1<IReference> fullMatches, IReadOnlyList`1<ValueTuple`2<IReference, INamedTupleComponent>> nameMatches);
    private static TupleComponentReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReference> get_FullMatches();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ValueTuple`2<IReference, INamedTupleComponent>> get_NameMatches();
    [NotNullAttribute]
public TupleComponentReferencesPointer CreatePointer();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.RenameTupleComponent.TupleComponentReferencesExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static TupleComponentReferences Merge(IEnumerable`1<TupleComponentReferences> source);
}
public class JetBrains.ReSharper.Refactorings.RenameTupleComponent.TupleComponentReferencesPointer : object {
    [NotNullAttribute]
private IReadOnlyList`1<IReferencePointer> myFullMatchPointers;
    [NotNullAttribute]
private IReadOnlyList`1<ValueTuple`2<IReferencePointer, IDeclaredElementPointer`1<INamedTupleComponent>>> myNameMatchPointers;
    public TupleComponentReferencesPointer(TupleComponentReferences tupleComponentReferences);
    [NotNullAttribute]
[PureAttribute]
public TupleComponentReferences Find();
}
public class JetBrains.ReSharper.Refactorings.Resources.RefactoringsThemedIcons : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Refactorings.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string AbstractClassToInterfaceActionText { get; }
    public static string AdjustNamespacesActionText { get; }
    public static string AnonymousToDeclaredTypeRefactoringMRUSettingDescription { get; }
    public static string AnonymousToNamedTypeActionText { get; }
    public static string ChangeSignatureActionText { get; }
    public static string ChooseValueOfParameter_RecursiveParameterKeep_Text { get; }
    public static string ConstructorToFactoryMethodActionText { get; }
    public static string ConvertActionGroupText { get; }
    public static string CopyTypeActionText { get; }
    public static string DeconstructMethodShouldContainOnlyOutParameters_Text { get; }
    public static string DelegateViaOverloading_Text { get; }
    public static string DynamicInvocation_Text { get; }
    public static string EncapsulateFieldActionText { get; }
    public static string EncapsulateFieldToAutoPropertySettingDescription { get; }
    public static string ExtensionMethodToPlainStaticActionText { get; }
    public static string ExtractActionGroupText { get; }
    public static string ExtractClassActionText { get; }
    public static string ExtractInterfaceActionText { get; }
    public static string ExtractMembersToPartialActionText { get; }
    public static string ExtractMethodActionText { get; }
    public static string ExtractSuperclassActionText { get; }
    public static string GenerateHashcodeSettingDescription { get; }
    public static string GenerateRecordTypeSettingDescription { get; }
    public static string GenerateToStringSettingDescription { get; }
    public static string IndexerToMethodActionText { get; }
    public static string InlineActionGroupText { get; }
    public static string InlineActionText { get; }
    public static string InlineMethodRefactoringSettingsSettingDescription { get; }
    public static string InterfaceToAbstractClassActionText { get; }
    public static string IntroduceFieldActionText { get; }
    public static string IntroduceParameterActionText { get; }
    public static string IntroduceVariableActionText { get; }
    public static string InvertBooleanActionText { get; }
    public static string ExtractMethodPage_LoadingNameSuggestions_Text { get; }
    public static string MakeEncapsulatingFieldPrivateSettingDescription { get; }
    public static string MakeMethodNonStaticActionText { get; }
    public static string MakeMethodStaticActionText { get; }
    public static string MethodBodyWillHaveErrorsBecauseItUsesMembers_Text { get; }
    public static string MethodBodyWillHaveErrorsBecauseItUsesCaptures_Text { get; }
    public static string MethodBodyWillHaveErrorsBecauseItUsesFunctions_Text { get; }
    public static string MethodToIndexerActionText { get; }
    public static string MethodToPropertyActionText { get; }
    public static string MoveActionText { get; }
    public static string MoveTypesIntoMatchingFilesActionText { get; }
    public static string ExtractMethodPage_NameSuggestionGenerationTimedOut_Text { get; }
    public static string ExtractMethodPage_NameSuggestionsAreAvailable_Text { get; }
    public static string ExtractMethodPage_NoSuggestions_Text { get; }
    public static string ExtractMethodPage_NameSuggestionGenerationFailed_Text { get; }
    public static string OptionalParametersMustAppearAfterAll_Text { get; }
    public static string ParameterNameCannotBeEmpty_Text { get; }
    public static string ParamsParameterMustAppearAfterAll_Text { get; }
    public static string PersistentSettingsForEncapsulateFieldRefactoringSettingDescription { get; }
    public static string PlaceTopLevelSettingDescription { get; }
    public static string PropertiesKindSettingDescription { get; }
    public static string PropertyToAutoPropertyActionText { get; }
    public static string PropertyToMethodSActionText { get; }
    public static string PullMembersUpActionText { get; }
    public static string PushMembersDownActionText { get; }
    public static string RemoveParamsModifierActionText { get; }
    public static string RemoveParamsModifierRefactoringCaption { get; }
    public static string RemoveParamsModifierRefactoringTitle { get; }
    public static string RemoveParamsModifier_Text { get; }
    public static string RenameActionText { get; }
    public static string RenameRefactoringSettingsSettingDescription { get; }
    public static string SafeDeleteActionText { get; }
    public static string SearchInAllSolutionSettingDescription { get; }
    public static string SetParamsModifierActionText { get; }
    public static string SetParamsModifierRefactoringCaption { get; }
    public static string SetParamsModifierRefactoringTitle { get; }
    public static string SetParamsModifier_Text { get; }
    public static string ShowInFindResultsSettingDescription { get; }
    public static string StaticToExtensionMethodActionText { get; }
    public static string TransformParametersActionText { get; }
    public static string UpdateExternalFieldUsagesOnlySettingDescription { get; }
    public static string UseBaseTypeWherePossibleActionText { get; }
    public static string UsingStatementConflict_Text { get; }
    public static string WhetherToInlineAllUsagesOrJustTheCurrentUsageIfAvailableSettingDescription { get; }
    public static string WhetherToRemoveTheMethodDeclarationAfterItsBeenInlinedIntoAllOfItsUsagesSettingDescription { get; }
    public static string WhetherToRenameFileNameWhenASingleClassInTheFileIsRenamedSettingDescription { get; }
    public static string WhetherToRenameTypeWhenTheFileIsRenamedSettingDescription { get; }
    public static string WhetherToSearchForPossibleDynamicOccurrencesSettingDescription { get; }
    public static string WhetherToSearchForStructurallyCompatibleMembersSettingDescription { get; }
    public static string WhetherToSearchForTextInStringsSettingDescription { get; }
    public static string WhetherToIgnoreAnyReferencesWhenFileIsRenamedSettingDescription { get; }
    public static string RefactorThisAction_Title { get; }
    public static string RefactorThisAction_Caption { get; }
    public static string ReplaceAnonymousTypeWithNamedType_Text { get; }
    public static string CreateANewClassToReplaceAllOccurrences_Text { get; }
    public static string Scope_Text { get; }
    public static string Whole_solution_Text { get; }
    public static string _LocalScope_Text { get; }
    public static string Location_Text { get; }
    public static string T_opLevelType_Text { get; }
    public static string N_estedType_Text { get; }
    public static string Generate_recordType_Text { get; }
    public static string Generate_mutableProperties_Text { get; }
    public static string GenerateE_qualsAndGetHashCode_Text { get; }
    public static string Generate_ToString_Text { get; }
    public static string Show_processedUsagesInFindResults_Text { get; }
    public static string N_ame_Text { get; }
    public static string Usages_Text { get; }
    public static string AddParameterAt__Text { get; }
    public static string Add_ParameterTo__Text { get; }
    public static string ChangeSignature_Text { get; }
    public static string Na_me_Text { get; }
    public static string Return_type_Text { get; }
    public static string ParametersShouldHaveDifferentNames_Text { get; }
    public static string ParameterHasInvalidType_Text { get; }
    public static string ParameterHasInvalidName_Text { get; }
    public static string MoveU_p_ButtonWithListAction_ToolTip { get; }
    public static string Param_eters_Text { get; }
    public static string SignaturePreview_Text { get; }
    public static string C_HangeSignature_Text { get; }
    public static string SearchingInheritors_Text { get; }
    public static string TypeNameShouldnTBeEmpty_Text { get; }
    public static string TypeIsNotValid_Text { get; }
    public static string Indexer_Text { get; }
    public static string Property_Text { get; }
    public static string Constructor_Text { get; }
    public static string Method_Text { get; }
    public static string TypeCannotBeResolved_Text { get; }
    public static string ErrorInDefaultValueExpression_Text { get; }
    public static string ChooseValueOfParameter_ToBeUsedToCorrect_Text { get; }
    public static string ChooseValueOfParameter_ToBeUsedAsDefault_Text { get; }
    public static string DefaultValueForParameter__Text { get; }
    public static string UseAsParameterDefaultValue__Text { get; }
    public static string ErrorOccured_Text { get; }
    public static string UseCustomValue_Text { get; }
    public static string UseCustomValue__Text { get; }
    public static string Selected__Text { get; }
    public static string LeaveAsIs_Text { get; }
    public static string NoParametersAdded_Text { get; }
    public static string Use___Text { get; }
    public static string Selected___Text { get; }
    public static string NodeBecameInvalid_Text { get; }
    public static string CreateParameter_In___Text { get; }
    public static string Parameter_CreatedIn___Text { get; }
    public static string UserEdit_Text { get; }
    public static string EditedByUser_Text { get; }
    public static string Starting_Text { get; }
    public static string MakeMethodNonStatic_Text { get; }
    public static string ConvertIntoAnInstanceMethodAndMoveIt_Text { get; }
    public static string SelectAn_instanceParameter_Text { get; }
    public static string MakeStatic_Text { get; }
    public static string DefineHowToTransformUsagesOfInstance_Text { get; }
    public static string DoNotAddParametersToTheMethod_Text { get; }
    public static string Add_thisParameterOfType_WithName_Text { get; }
    public static string Introduce_parametersFromFollowingExpressions_Text { get; }
    public static string SearchingExpressionOccurrences_Text { get; }
    public static string PreparingNewArguments_Text { get; }
    public static string PreProcessingUsages_Text { get; }
    public static string UpdatingDeclaration_Text { get; }
    public static string UpdatingUsages_Text { get; }
    public static string Finishing_Text { get; }
    public static string UpdatingRecursiveCalls_Text { get; }
    public static string Ma_KeStatic_Text { get; }
    public static string FindReferencesOf__Text { get; }
    public static string Process__Text { get; }
    public static string ReviewTypeChanges_Text { get; }
    public static string ReviewChangesToTypesOfRelatedSymbols_Text { get; }
    public static string _UpdateRelatedSymbols_Text { get; }
    public static string InvalidDeclaredElement_Text { get; }
    public static string Symbol_Text { get; }
    public static string NewType_Text { get; }
    public static string Navigate_Text { get; }
    public static string Conflicts_Text { get; }
    public static string AbstractClassToInterface_Text { get; }
    public static string COnvertAbstractClassToInterface_Text { get; }
    public static string ConstructorToFactoryMethod_Text { get; }
    public static string InC_lass_Text { get; }
    public static string Factory_methodName_Text { get; }
    public static string Create_singleInstance_Text { get; }
    public static string ReplaceConstructorWithFactoryMethod_Text { get; }
    public static string _RefactoringWillBeTerminated_Text { get; }
    public static string UpdatingDeclarations_Text { get; }
    public static string SearchingReferences_Text { get; }
    public static string StoringSuspiciousReferences_Text { get; }
    public static string UpdatingSuspiciousReferences_Text { get; }
    public static string UpdatingReferences_Text { get; }
    public static string SearchingOverrides_Text { get; }
    public static string RefactoringFailedToCreateBaseTypeDeclaration_Text { get; }
    public static string AnalyseTypeParameters_Text { get; }
    public static string SearchingMembersToMakeProtected_Text { get; }
    public static string AnalysingConflicts_Text { get; }
    public static string FixingOverrides_Text { get; }
    public static string SearchingSuspiciousReferences_Text { get; }
    public static string RemovingLegacyDeclarations_Text { get; }
    public static string MovingMembers_Text { get; }
    public static string MakingClassesAbstract_Text { get; }
    public static string MakingMembersProtected_Text { get; }
    public static string UpdatingCaches_Text { get; }
    public static string Scanning__Text { get; }
    public static string UpdatingLocalReferences_Text { get; }
    public static string UpdatingOtherReferences_Text { get; }
    public static string ProcessingReference_Of__Text { get; }
    public static string CutDeclarations_Text { get; }
    public static string PasteDeclarations_Text { get; }
    public static string FixingTypeDeclarations_Text { get; }
    public static string SearchingUsages_Text { get; }
    public static string InternalReferences_Text { get; }
    public static string Select_public_Text { get; }
    public static string Select_dependent_Text { get; }
    public static string Select_members_Text { get; }
    public static string __OverridesImplements_FromCompiledCode_Text { get; }
    public static string _OverridesImplements_FromBaseTypeDo_Text { get; }
    public static string MethodToIndexer_Text { get; }
    public static string ConvertMethodToProperty_Text { get; }
    public static string ConvertMethodToProperty_Ellipsis_Text { get; }
    public static string PropertyN_ame_Text { get; }
    public static string Make_default_Text { get; }
    public static string IndexerToFunction_Text { get; }
    public static string ConvertInterfaceToAbstract_Text { get; }
    public static string COnvertInterfaceToAbstractClass_Text { get; }
    public static string PropertyToAutoProperty_Text { get; }
    public static string Preparing_Text { get; }
    public static string SearchingBackingFieldUsages_Text { get; }
    public static string CreatingProperty_Text { get; }
    public static string UpdatingBackingFieldUsages_Text { get; }
    public static string ConvertPropertyToAutoProperty_Text { get; }
    public static string FunctionToProperty_Text { get; }
    public static string ConvertPropertyToMethodS_Text { get; }
    public static string StoringReferences_Text { get; }
    public static string SearchConflictsWithExistingMembers_Text { get; }
    public static string SearchingForAmbiguitiesInTheTargetType_Text { get; }
    public static string UpdatingInternalReferences_Text { get; }
    public static string Reference_Of__Text { get; }
    public static string CopyingDeclarations_Text { get; }
    public static string Inserting_Text { get; }
    public static string Removing_Text { get; }
    public static string TargetTypeIsNotAccessibleAt0CallSite_Text { get; }
    public static string SomeMembersAreNotImplemented_Text { get; }
    public static string ConvertMethodToIndexer_Text { get; }
    public static string COnvertIndexerToMethodS_Text { get; }
    public static string Convert_getterToMethodWithName_Text { get; }
    public static string Convert_setterToMethodWithName_Text { get; }
    public static string ExtensionMethodToPlainStatic_Text { get; }
    public static string StaticToExtensionMethod_Text { get; }
    public static string COnvertStaticMethodToExtension_Text { get; }
    public static string ExtensionMethodTo_PlainStatic_Text { get; }
    public static string ExtractMembersToPartial_Text { get; }
    public static string PathIsEmpty_Text { get; }
    public static string PathContainsInvalidCharacters_Text { get; }
    public static string FileNameIsEmpty_Text { get; }
    public static string FileAlreadyExists_Text { get; }
    public static string RefactorToPartialType_Text { get; }
    public static string MakeTheTypePartialIfItIsnTAndMoveThe_Text { get; }
    public static string Select_membersToMove_Text { get; }
    public static string Use_existingPart_Text { get; }
    public static string Select_fileForNewPart_Text { get; }
    public static string CreateNewPart_Text { get; }
    public static string Invalid_Text { get; }
    public static string FileIsAutogenerated_Text { get; }
    public static string FileDoesnTExistAndCannotBeCreated__Text { get; }
    public static string CopyType_Text { get; }
    public static string Copy__Text { get; }
    public static string EncapsulateField_Text { get; }
    public static string EncapsulatedFieldWillBeInaccessible_Text { get; }
    public static string UsePropertyToExposeOrReplaceTheField_Text { get; }
    public static string CreateNewProperty_Text { get; }
    public static string Choose_property_Text { get; }
    public static string To_autoProperty_Text { get; }
    public static string _WriteUsages_Text { get; }
    public static string _ReadUsages_Text { get; }
    public static string Nam_eUsages_Text { get; }
    public static string Make_fieldPrivate_Text { get; }
    public static string DoNotUpdate_localUsages_Text { get; }
    public static string PropertyNa_me_Text { get; }
    public static string Encapsulate_Text { get; }
    public static string Or_Text { get; }
    public static string AnalysingEmptyNamespaces_Text { get; }
    public static string _Of__Text { get; }
    public static string AnalyzingEmptyNamespaces_Text { get; }
    public static string ScanningProject_Of__Text { get; }
    public static string CreatingFiles_Text { get; }
    public static string MoveTypesIntoMatchingFiles_Text { get; }
    public static string MoveIntoSeparateFiles_Text { get; }
    public static string _ClassStructureAndInterfaceDeclarations_Text { get; }
    public static string _DelegateDeclarations_Text { get; }
    public static string _EnumDeclarations_Text { get; }
    public static string ReplacingFieldReferences_Text { get; }
    public static string ReplacingReferences_Text { get; }
    public static string En_CapsulateField_Text { get; }
    public static string ExtractClass_Text { get; }
    public static string Extract_Class_Refactoring_Title { get; }
    public static string FillInTheNameForTheNewClassAndSelect_Text { get; }
    public static string SourceClass_Text { get; }
    public static string _ExtractedClass_Text { get; }
    public static string _ReferenceToExtracted_Text { get; }
    public static string ReferenceTo_source_Text { get; }
    public static string ExtractedClassPlacement_Text { get; }
    public static string Same_fileAsTheSource_Text { get; }
    public static string _itsOwnFile_Text { get; }
    public static string Select_allSuggestedMembers_Text { get; }
    public static string Extract_Text { get; }
    public static string None_Text { get; }
    public static string Used_Text { get; }
    public static string UsedBy_Text { get; }
    public static string MoveU_p_Text { get; }
    public static string Move_Down_Text { get; }
    public static string ConstructorParameters_Text { get; }
    public static string MethodParameters_Text { get; }
    public static string Par_ameters_Text { get; }
    public static string Preview_Text { get; }
    public static string ClassNa_me_Text { get; }
    public static string MethodNa_me_Text { get; }
    public static string _ReturnType_Text { get; }
    public static string CreateAsField_Text { get; }
    public static string CreateAsProperty_Text { get; }
    public static string ExtractingDeclarationsFromSourceFiles_Text { get; }
    public static string ResolvingReferencesFromSourceFiles_Text { get; }
    public static string GeneratingNewCode_Text { get; }
    public static string GeneratingUsingDirectives_Text { get; }
    public static string RemovingObsoleteImports_Text { get; }
    public static string MoveTypeToAnother__Text { get; }
    public static string NewFolderIsNestedInTheOriginalFolder_Text { get; }
    public static string ProjectIsNullForThisFolder_Text { get; }
    public static string TargetProjectLanguageShouldBe__Text { get; }
    public static string TargetFolderShouldBeDifferentFromThe_Text { get; }
    public static string _TargetFolder_Text { get; }
    public static string SpecifyTargetFolderAndMoveOptions_Text { get; }
    public static string SpecifyHowToCreateNewFiles_Text { get; }
    public static string Preserve_hierarchyOfFoldersAndFileNames_Text { get; }
    public static string PutClassesInto_separateFiles_Text { get; }
    public static string _FixNamespaces_Text { get; }
    public static string _AllowChangeInternalVisibilityToPublic_Text { get; }
    public static string __Text { get; }
    public static string DeclarationsInThisFileShouldBeIncluded_Text { get; }
    public static string SpecifySetOfClassesToMove_Text { get; }
    public static string SpecifySetOfFilesToMove_Text { get; }
    public static string SelectionShouldnTBeEmpty_Text { get; }
    public static string SelectedDeclarationsContainConflicts_Text { get; }
    public static string RenameNamespace_Text { get; }
    public static string NewN_ame_Text { get; }
    public static string RenameF_Ile_Text { get; }
    public static string _RenameSingleTypeToMatchFileName_Text { get; }
    public static string RenameTypeToMatchTheNewFileName_Text { get; }
    public static string TheNewFileNameExtensionIsNotValidForSourceCodeFiles_Text { get; }
    public static string TheNewFileNameCannotBeUsedAsAValidTypeName_Text { get; }
    public static string RenameFile_Text { get; }
    public static string RenameFileAndUpdateReferencesToIt_Text { get; }
    public static string NoFixesAvailableForThisNode_Text { get; }
    public static string NodeHadChangedStateCannotBeRestored_Text { get; }
    public static string RenameRootNamespace_Text { get; }
    public static string RenameProjectReferencesInTheSourceCode_Text { get; }
    public static string RenameInCommentsAnd_stringLiterals_Text { get; }
    public static string TheNameOfTheRootNamespaceDiffersFrom_Text { get; }
    public static string RenameRoot_namespace__Text { get; }
    public static string NotSupportedForThisProject_Text { get; }
    public static string TheNameOfTheProjectFolderDiffersFrom_Text { get; }
    public static string RenameProject_folder_Text { get; }
    public static string Rename__Text { get; }
    public static string GiveANewNameToThe___Text { get; }
    public static string GiveANewNameToThe_File_Text { get; }
    public static string NameIsEmpty_Text { get; }
    public static string NameIsInvalid_Text { get; }
    public static string Project__Text { get; }
    public static string ProjectWithName_AlreadyExistsInTheSolution_Text { get; }
    public static string File_AlreadyExists_Text { get; }
    public static string Folder_AlreadyExists_Text { get; }
    public static string FixReferencesToTheProject_Text { get; }
    public static string FixProjectProperties_Text { get; }
    public static string FixLinkedFiles_Text { get; }
    public static string Re_Name_Text { get; }
    public static string RefactoringChangeSignature_Text { get; }
    public static string ExecuteChangeSignatureFixes_Text { get; }
    public static string MoveToAnotherFIle_Text { get; }
    public static string _RemoveSourceFile_Text { get; }
    public static string _TargetFileName_Text { get; }
    public static string Target__Text { get; }
    public static string TupleComponentWithSuchNameAlreadyExists_Text { get; }
    public static string InvalidTupleComponentName_Text { get; }
    public static string SelectScopeWhereToSearchForAnonymous_Text { get; }
    public static string ReviewItemsThatWillBeRenamed_Text { get; }
    public static string BulkRenameRefactoring_Text { get; }
    public static string SearchIn_textOccurrences_Text { get; }
    public static string Synchronize_filename_Text { get; }
    public static string Usage_WillReferToComponentOfType_Instead_Text { get; }
    public static string Usage_WillBeBroken_Text { get; }
    public static string ProcessingCommentsAndStringLiterals_Text { get; }
    public static string CollectingProjectReferencesInTheSource_Text { get; }
    public static string IOError__Text { get; }
    public static string UnableToPerformRefactoring_Caption { get; }
    public static string RenameProject_Text { get; }
    public static string PrepareFileSystem_Text { get; }
    public static string AnalyzeProjectDependencies_Text { get; }
    public static string ProjectFileIsNotValid_Text { get; }
    public static string WebPageCannotBeMovedIntoAppCodeFolder_Text { get; }
    public static string HierarchyCannotBePreservedForDeclaration_Text { get; }
    public static string Select_membersToMakePublic_Text { get; }
    public static string MoveToFoldeR_Text { get; }
    public static string RenameRelatedSYmbols_Text { get; }
    public static string File_Exists_Text { get; }
    public static string Folder_Exists_Text { get; }
    public static string SearchConflicts_Text { get; }
    public static string ScanningHierarchy_Text { get; }
    public static string PerformRename_Text { get; }
    public static string ScanningFiles_Text { get; }
    public static string CheckingSuspiciousReferences_Text { get; }
    public static string FindUsagesAndTextualOccurrences_Text { get; }
    public static string ScanConflictsInHierarchy_Text { get; }
    public static string AlsoRename_filesToReflectThisChange_Text { get; }
    public static string SearchIn_commentsAndStringLiterals_Text { get; }
    public static string QuickRename_IgnoreAnyReferences_Text { get; }
    public static string _1Symbol_Text { get; }
    public static string __Symbols_Text { get; }
    public static string _RenameRelatedSymbols_Text { get; }
    public static string Related_symbols_Text { get; }
    public static string _IsAMemberOfAHierarchyWhatWouldYouLike_Text { get; }
    public static string Remove_WHOLEHierarchy_Text { get; }
    public static string RemoveElementAndAll_INHERITORS_Text { get; }
    public static string RemoveA_SINGLEMemberOfTheHierarchy_Text { get; }
    public static string _HasDerivedTypesWhatWouldYouLikeToDo_Text { get; }
    public static string R_emove_AndInheritors_Text { get; }
    public static string _Remove_Only_Text { get; }
    public static string SafeDelete_Text { get; }
    public static string ObjectCreationCannotBeDeleted_Text { get; }
    public static string DeletingFromTheFileSystem_Text { get; }
    public static string CollectingProjectReferences_Text { get; }
    public static string CollectingProjectsReferences_Text { get; }
    public static string DeletingProjectsReferences_Text { get; }
    public static string DeletingProjects_Text { get; }
    public static string Add_To__Text { get; }
    public static string AndSpecifyOtherOptions_Text { get; }
    public static string EnterMethodName_Text { get; }
    public static string EnterPropertyName_Text { get; }
    public static string EnterLocalFunctionName_Text { get; }
    public static string EnterMethodObjectName_Text { get; }
    public static string ChooseConstructorParameters_Text { get; }
    public static string ExtractMethod_Text { get; }
    public static string _ExtractMethod_Text { get; }
    public static string Success_Text { get; }
    public static string LanguageOfSourceCodeIsNotSupportedBy_Text { get; }
    public static string SelectedBlockOfCodeCannotBeExtracted_Text { get; }
    public static string ExpressionTypeIsUnknown_Text { get; }
    public static string ExpressionTypeIsVoid_Text { get; }
    public static string AnonymousTypesCannotCrossExtractedBlock_Text { get; }
    public static string ExtractedBlockHasMultipleEntries_Text { get; }
    public static string ExtractedBlockHasExitsToDifferentPoints_Text { get; }
    public static string _ProceedWithRefactoring_Text { get; }
    public static string ExtractMethod_Caption { get; }
    public static string ExtractMethodCannotProceed_Caption { get; }
    public static string _Visibility_Text { get; }
    public static string Declare_shared_Text { get; }
    public static string MethodR_eceives_Text { get; }
    public static string Method_returns_Text { get; }
    public static string Select_parametersToTransform_Text { get; }
    public static string In_Text { get; }
    public static string Out_Text { get; }
    public static string ReturnValue__Text { get; }
    public static string DefaultParameterValue_Text { get; }
    public static string AppendToExisting_tuple_Text { get; }
    public static string TupleElementsNumberCannotBeMoreThan_Text { get; }
    public static string TransformParameters_Text { get; }
    public static string UseBaseTypeWherePossible_Text { get; }
    public static string ReplaceReferencesToTheSelectedTypeWith_Text { get; }
    public static string ReplaceTypesIn_typeofOperator_Text { get; }
    public static string ReplaceTypesIn_isOperator_Text { get; }
    public static string Select_baseType_Text { get; }
    public static string _UseBaseTypeWherePossible_Text { get; }
    public static string ReplaceOneOccurrence_Text { get; }
    public static string ReplaceInitialExpressionOnly_Text { get; }
    public static string Replace_Occurrences_Text { get; }
    public static string Replace1Occurrence_Text { get; }
    public static string ReplaceAllHighlightedOccurrencesOfInitial_Text { get; }
    public static string ReplaceSelectedOccurrences_Text { get; }
    public static string UseSelectedExpressionAsASource_Text { get; }
    public static string Method_InvalidatedSinceRefactoringStarted_Text { get; }
    public static string TooManyTupleParametersMaximumNumber_Text { get; }
    public static string NoSuchType___Text { get; }
    public static string RemovingUnusedUsings_Text { get; }
    public static string ValidatingUsagesOfSymbols_Of__Text { get; }
    public static string SearchingUsagesOfMovedSymbols_Text { get; }
    public static string StoringUsagesOfMovedSymbols_Text { get; }
    public static string InlineClass_Text { get; }
    public static string FieldIsUsedAs0RefOutArgument_Text { get; }
    public static string _ValueWillBeLost_Text { get; }
    public static string _HasInitializer_Text { get; }
    public static string ChangeSignatureIsAppliedTo_ThatAlsoOverrides_Text { get; }
    public static string ChangeSignatureIsAppliedTo_ThatAlsoImplements_Text { get; }
    public static string _IsQuasiImplementedBy_ThatWillNotBe_Text { get; }
    public static string Converted_AlsoOverrides_ThatWillNot_Text { get; }
    public static string Converted_AlsoImplements_ThatWillNot_Text { get; }
    public static string Converted_IsQuasiImplementedBy_That_Text { get; }
    public static string Removed_AlsoOverrides_ThatWillNotBe_Text { get; }
    public static string Removed_AlsoImplements_ThatWillNotBe_Text { get; }
    public static string Removed_IsQuasiImplementedBy_ThatWill_Text { get; }
    public static string _AlsoOverrides_ThatWillNotBeChanged_Text { get; }
    public static string _AlsoImplements_ThatWillNotBeChanged_Text { get; }
    public static string _Overrides_ThatWillNotBeChangedPlease_Text { get; }
    public static string _Implements_ThatWillNotBeChangedPlease_Text { get; }
    public static string IntroduceParameterIsAppliedTo_ThatAlsoOverrides_Text { get; }
    public static string IntroduceParameterIsAppliedTo_ThatAlsoImplements_Text { get; }
    public static string Renamed_AlsoOverrides_ThatWillNotBe_Text { get; }
    public static string Renamed_AlsoImplements_ThatWillNotBe_Text { get; }
    public static string Renamed_IsQuasiImplementedBy_ThatWill_Text { get; }
    public static string _HasHandlesClause_Text { get; }
    public static string Usage_Text { get; }
    public static string UnableToChangeSignatureOf0Element_Text { get; }
    public static string AccessTo0Instance_Text { get; }
    public static string ContainingType_HasNameSameToTheNewName_Text { get; }
    public static string NoMembersWereFoundToPushDownRefactoring_Text { get; }
    public static string NoAppropriateInheritorsWereFoundRefactoring_Text { get; }
    public static string Error_Caption { get; }
    public static string PushMembersDoWn_Text { get; }
    public static string VirtualChainLeapOver_Detected_Text { get; }
    public static string Abstract_IsAlreadyDeclaredInTheTarget_Text { get; }
    public static string Virtual_IsAlreadyDeclaredInTheTarget_Text { get; }
    public static string Override_IsAlreadyDeclaredInTheTarget_Text { get; }
    public static string _WithGetterAlreadyExists_Text { get; }
    public static string _WithSetterAlreadyExists_Text { get; }
    public static string _IsPresentedButItIsNotDefault_Text { get; }
    public static string _IsAlreadyDeclaredWithAnotherType_Text { get; }
    public static string ConflictWithModifiersListFoundIn__Text { get; }
    public static string NotDefault_WithThisNameIsAlreadyDeclared_Text { get; }
    public static string _WillBeHidden_Text { get; }
    public static string NewDeclarationIsHiddenBy__Text { get; }
    public static string NewElementHides__Text { get; }
    public static string NewElementIsHiddenBy__Text { get; }
    public static string AutoPropertyWillBeTransformedIntoProperty_Text { get; }
    public static string Declaration_Text { get; }
    public static string _HasSetterThatCannotOverrideTheBase_Text { get; }
    public static string _HasGetterThatCannotOverrideTheBase_Text { get; }
    public static string _ImplementsConvertedInterfaceExplicitly_Text { get; }
    public static string _IsAQuasiImplementation_Text { get; }
    public static string ConvertedInterfaceIsImplementedBy_That_Text { get; }
    public static string _ExtendsConvertedInterface_Text { get; }
    public static string UnableToAccessTypeOf_InFactoryClass_Text { get; }
    public static string Backing_IsMoreVisibleThanPropertyOr_Text { get; }
    public static string TargetClassHasMemberWithTheSameName_Text { get; }
    public static string _HasInitializerAnd_WriteUsageS1First_Text { get; }
    public static string _Has_WriteUsages1FirstWriteUsage2Second_Text { get; }
    public static string WriteUsageIsFoundButInitialization_Text { get; }
    public static string NoWriteUsagesWereFound_Text { get; }
    public static string LanguageOfInlinedDeclarationIs_ButLanguage_Text { get; }
    public static string InLineField_Text { get; }
    public static string FixingCode_Text { get; }
    public static string NoValueProvidedFor0Parameter_Text { get; }
    public static string _ParameterUsagesWillBeBroken_Text { get; }
    public static string UsageWillBeFixed_Text { get; }
    public static string InlineParameter_Text { get; }
    public static string InlineParameterOptions_Text { get; }
    public static string NewParameterHasToBeCreated_Text { get; }
    public static string _NewParametersHasToBeCreated_Text { get; }
    public static string _SourceOfArgumentsToBeInlined_Text { get; }
    public static string CannotBeInlined_Text { get; }
    public static string DefaultValue__Text { get; }
    public static string __From__Text { get; }
    public static string ParametersWillBe_removed_Text { get; }
    public static string ParametersWillBe_added_Text { get; }
    public static string NewParameterSuggestion_Text { get; }
    public static string ParameterUsagesWillBeBroken_Text { get; }
    public static string InLineVariable_Text { get; }
    public static string NoUsagesFound_Text { get; }
    public static string UnableToUse_FromTheCallSite_Text { get; }
    public static string CannotInlineCombinedReadAndWriteAccess_Text { get; }
    public static string Inline_Text { get; }
    public static string UnableToInline0UsageMethodGroupIsNot_Text { get; }
    public static string ReplaceInvocationsOfMethodWithItsImplementation_Text { get; }
    public static string _RemoveInlinedMethodDeclaration_Text { get; }
    public static string Inline_allUsages_Text { get; }
    public static string Inlined_OverridesBaseClassMemberDeclaration_Text { get; }
    public static string Inlined_ImplementsInterfaceMemberDeclaration_Text { get; }
    public static string InlinedMethodHasAnotherImplementation_Text { get; }
    public static string NoUsagesOfMethodWereFound_Text { get; }
    public static string UnableToInline0CollectionInitializer_Text { get; }
    public static string UnableToInline0UsageInAnObjectInitializer_Text { get; }
    public static string UnableToInline0DeconstructionUsage_Text { get; }
    public static string UnableToInline0UsageInlinedMethodHas_Text { get; }
    public static string UnableToInline0UsageCannotIntroduce_Text { get; }
    public static string UnableToInline0UsageUnableToIntroduce_Text { get; }
    public static string UnableToInline0UsageUnableToIntroduce_Text2 { get; }
    public static string UnableToInline0UsageUnableToIntroduce_Text3 { get; }
    public static string UnableToInline0UsageUnableToIntroduce_Text4 { get; }
    public static string UnableToInline0UsageUnableToIntroduce_Text5 { get; }
    public static string UnableToInline0Usage_Text { get; }
    public static string InLineMethod_Text { get; }
    public static string ProcessingUsages_Text { get; }
    public static string _HasType_ThatCannotBeUsedDirectlyFrom_Text { get; }
    public static string TypeCannotBeUsedAtTheCallSite_Text { get; }
    public static string Make_readonly_Text { get; }
    public static string Make_static_Text { get; }
    public static string InitializeFieldIn_Text { get; }
    public static string In_TroduceField_Text { get; }
    public static string IntroduceField_Text { get; }
    public static string IntroduceParameter_Text { get; }
    public static string ThereAreNoUsagesOf0_ValueOfNewParameter_Text { get; }
    public static string IntroduceParameter__Text { get; }
    public static string In___Text { get; }
    public static string ParameterType_Text { get; }
    public static string ParameterN_ame_Text { get; }
    public static string SelectParametersTo_enlambda_Text { get; }
    public static string ParametersThatCanBeSafely_removed_Text { get; }
    public static string IntroduceVariable_Text { get; }
    public static string Introduce_Variable_Text { get; }
    public static string ExpressionTypeUnknown_Text { get; }
    public static string ExpressionUsesLambdaParameterOrRange_Text { get; }
    public static string UnableToIntroduceVariable_Text { get; }
    public static string InvertBoolean_Text { get; }
    public static string InvertBooleanValue_Text { get; }
    public static string InvertU_sagesOfMember_Text { get; }
    public static string InvertValues_insideMember_Text { get; }
    public static string ElementHasOverrides_Text { get; }
    public static string _ReferenceCannotBeInverted_Text { get; }
    public static string ReferenceCannotBeInverted_Text { get; }
    public static string Move_Text { get; }
    public static string MoveInstanceMethod_Text { get; }
    public static string ThisMethodIsAnImplementationOrAnOverride_Text { get; }
    public static string SelectElement_Text { get; }
    public static string ToMoveMethod_To_Text { get; }
    public static string SelectATypeToMoveMethod_ToAllCallsWill_Text { get; }
    public static string _Targets_Text { get; }
    public static string ExtractInterface_Text { get; }
    public static string ExtractSuperclass_Text { get; }
    public static string PullMembersUp_Text { get; }
    public static string PushMemberDown_Text { get; }
    public static string Reference_MayBeBroken_Text { get; }
    public static string _DeclaredInTheTargetElementHasConflicts_Text { get; }
    public static string _DoesnTHaveClassConstraint_Text { get; }
    public static string _DoesnTHaveValueConstraint_Text { get; }
    public static string _DoesnTDefaultConstructorConstraint_Text { get; }
    public static string _DoesnTHaveConstraint_ForTheTypeParameter_Text { get; }
    public static string SomeReferencesTo_WillNeedManualFix_Text { get; }
    public static string UnableToSaveReferenceTo__Text { get; }
    public static string Extract_Superclass_Text { get; }
    public static string SearchingConflictsFor__Text { get; }
    public static string UpdatingLocalReferencesFor__Text { get; }
    public static string TypeParameterAmbiguity_Text { get; }
    public static string SelectWhereToMove_Text { get; }
    public static string _sameFileAsTheSourceClass_Text { get; }
    public static string SelectTarget_baseType_Text { get; }
    public static string SelectBaseTypeAndMembers_Text { get; }
    public static string E_XtractInterface_Text { get; }
    public static string PullMem_BersUp_Text { get; }
    public static string Select_typesWhereYouWantToMoveMembers_Text { get; }
    public static string FullyQualifiedTargetTypeNa_me_Text { get; }
    public static string _StaticMembersToMove_Text { get; }
    public static string MoveToAnotherTYpe_Text { get; }
    public static string _WillNotBeAccessible__Text { get; }
    public static string _CannotBeReferenced__Text { get; }
    public static string InMovedType_Text { get; }
    public static string AfterMove_Text { get; }
    public static string MoveToOuterScoPe_Text { get; }
    public static string MoveNestedTypeOneLevelUpAndOptionally_Text { get; }
    public static string AdjustNamespaces_Text { get; }
    public static string SearchingFilesWithInconsistentNamespaces_Text { get; }
    public static string AnalyzingPossibleProblems_Text { get; }
    public static string _AdjustNamespaces_Text { get; }
    public static string RegisteringNewCopies_Text { get; }
    public static string Choose_filesWhereYouWantToFixNamespaces_Text { get; }
    public static string Name_ShouldBeUsedForType__Text { get; }
    public static string NamespaceFor0DeclarationCannotBeFixed_Text { get; }
    public static string PartOf_ShouldBeInNamespace__Text { get; }
    public static string PartialDeclarationInFile_IsNotIncluded_Text { get; }
    public static string UnableToMove_BecauseThereIsAnotherDeclaration_Text { get; }
    public static string UnableToMove_BecauseFolderWithName__Text { get; }
    public static string UnableToMove_BecauseAFileWithTheName_Text { get; }
    public static string UnableToMove_StructureOfDependentFiles_Text { get; }
    public static string CollectingReferencesToMovedTypes_Text { get; }
    public static string GeneratingNewFiles_Text { get; }
    public static string UpdatingReferencesForRenamedFiles_Text { get; }
    public static string _MoveTypesIntoMatchingFiles_Text { get; }
    public static string _ShouldReference__Text { get; }
    public static string RefactoringHasDetectedThatExtraReferences_Text { get; }
    public static string ScanningInternalDeclarationsThatShould_Text { get; }
    public static string PartOf_IsNotIncludedOtherPartCannot_Text { get; }
    public static string FolderWithThisNameAlreadyExistsInTarget_Text { get; }
    public static string UnableToMove_AFileWithTheSameNameExists_Text { get; }
    public static string Invocation_Text { get; }
    public static string ReplaceInitialTypeOnly_Text { get; }
    public static string ReplaceAllHighlightedOccurrencesOfType_Text { get; }
    public static string ReplaceInitialNamespaceOnly_Text { get; }
    public static string ReplaceAllHighlightedOccurrencesOfNamespace_Text { get; }
    public static string ReplaceAllHighlightedOccurrencesWithNewVariable_Text { get; }
    public static string TypeDeclaration_Text { get; }
    public static string Expression_Text { get; }
    public static string UnableToCreateClassDeclarationParameters_Text { get; }
    public static string Type_AlreadyExists_Text { get; }
    public static string CannotCreateClassDeclaration_Text { get; }
    public static string Sa_FeDelete_Text { get; }
    public static string Remove_emptyFiles_Text { get; }
    public static string SomeFilesMayBecomeEmpty_Text { get; }
    public static string TheSymbolIsGoingToBeRemovedAndItsUsagesAre_Text { get; }
    public static string SymbolRemovalConfirmation_Text { get; }
    public static string ThereAreUsagesOf_WhatWouldYouLikeTo_Text { get; }
    public static string Report_conflict_Text { get; }
    public static string ReplaceWith_baseType__Text { get; }
    public static string ReplaceWith_derivedType__Text { get; }
    public static string UsageOf_CannotBeReplacedWith__Text { get; }
    public static string _IsTheLastConstructorItCallsTheBase_Text { get; }
    public static string FailedToFindUsagesOf_In__Text { get; }
    public static string _DeleteProjectFolderAndFilesFromThe_Text { get; }
    public static string ThereAreSomeOtherProjectsInSameProjectFolders_Text { get; }
    public static string ThereAreSomeProjectsInSolutionDirectory_Text { get; }
    public static string SearchFor_usages_Text { get; }
    public static string Projects_Text { get; }
    public static string SearchingUsagesOfMovedTypes_Text { get; }
    public static string CollectingObsoleteUsages_Text { get; }
    public static string SearchingUsagesOfRemovedElements_Text { get; }
    public static string PleaseReviewElementsThatWillBe_deleted_Text { get; }
    public static string EvaluateDerivedRenames_Text { get; }
    public static string Update_occurrences_Text { get; }
    public static string CheckUsagesThatShouldBeUpdated_Text { get; }
    public static string RefactoringHasFoundUsagesRelatedToRefactoring_Text { get; }
    public static string _HasFoundSomeTextualOccurrencesInComments_Text { get; }
    public static string UsagesInCommentsAndStringLiterals_Text { get; }
    public static string _RenameUsagesInCommentsAndStringLiterals_Text { get; }
    public static string ContainingTypeHasTheSameNameAsTheNew_Text { get; }
    public static string Rename_Text { get; }
    public static string Rena_Me_Text { get; }
    public static string BulkRename_Text { get; }
    public static string PostProcessingMovedFiles_Text { get; }
    public static string CollectingMovedFiles_Text { get; }
    public static string FixingAccessRights_Text { get; }
    public static string FileName_IsAlreadyUsedForAnotherMoved_Text { get; }
    public static string _WillHide__Text { get; }
    public static string _WillImplement__Text { get; }
    public static string _WillOverride__Text { get; }
    public static string FoundAtLeast1UsageOf_In_2FindAllUsages_Text { get; }
    public static string _FromDeletedElementImplements__Text { get; }
    public static string _FromDeletedElementOverridesAbstract_Text { get; }
    public static string _Implements__Text { get; }
    public static string _OverridesAbstract__Text { get; }
    public static string SearchingRelatedElementsFor__Text { get; }
    public static string CLass_DescriptionText { get; }
    public static string ConstructorS_DescriptionText { get; }
    public static string CreateAccessor_DescriptionText { get; }
    public static string CreateANewLocalVariableAndUseIt_DescriptionText { get; }
    public static string CreateCopy_DescriptionText { get; }
    public static string CreateDelegatingWrapper_DescriptionText { get; }
    public static string CreateProperty_DescriptionText { get; }
    public static string CurrentMember_DescriptionText { get; }
    public static string DiscardOutParameterValue_DescriptionText { get; }
    public static string DoNotApplyFix_DescriptionText { get; }
    public static string ExistingClass_DescriptionText { get; }
    public static string FieldInitializer_DescriptionText { get; }
    public static string IntroduceConstant_DescriptionText { get; }
    public static string LeaveCodeNonCompilableIllCorrectCallsMyself_DescriptionText { get; }
    public static string MakePublic_DescriptionText { get; }
    public static string MemberIsNotAccessedAnywhere_DescriptionText { get; }
    public static string MethodDescriptionText { get; }
    public static string NewClassWithAutoProperties_DescriptionText { get; }
    public static string NewClassWithPublicFields_DescriptionText { get; }
    public static string None_DescriptionText { get; }
    public static string Project_DescriptionText { get; }
    public static string ResolveWithCallTree_DescriptionText { get; }
    public static string Solution_DescriptionText { get; }
    public static string SplitRefParameterToInAndOut_DescriptionText { get; }
    public static string Tuple_DescriptionText { get; }
    public static string USe_DescriptionText { get; }
    public static string UseOutParameterAsReturnValue_DescriptionText { get; }
    public static string UseTheFollowingValue_DescriptionText { get; }
    public static string UseUniqueValueOfTypeAtThePointOfCallIfExists_DescriptionText { get; }
    public static string Members_ColumnName { get; }
    public static string MakeAbstract_ColumnName { get; }
    public static string Modifier_Column_Name { get; }
    public static string Name_Column_Name { get; }
    public static string Type_Column_Name { get; }
    public static string OldName_Column_Text { get; }
    public static string NewName_Column_Text { get; }
    public static string Name_space_Text { get; }
    public static string Namespace_Lower_Text { get; }
    public static string Module_Lower_Text { get; }
    public static string Usages_Column_Text { get; }
    public static string SourceClassMember_Column_Text { get; }
    public static string TargetClassMember_Column_Text { get; }
    public static string Name_Column_Text { get; }
    public static string Modifier_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_AbstractClassToInterfaceActionText();
    public static string get_AdjustNamespacesActionText();
    public static string get_AnonymousToDeclaredTypeRefactoringMRUSettingDescription();
    public static string get_AnonymousToNamedTypeActionText();
    public static string get_ChangeSignatureActionText();
    public static string get_ChooseValueOfParameter_RecursiveParameterKeep_Text();
    public static string get_ConstructorToFactoryMethodActionText();
    public static string get_ConvertActionGroupText();
    public static string get_CopyTypeActionText();
    public static string get_DeconstructMethodShouldContainOnlyOutParameters_Text();
    public static string get_DelegateViaOverloading_Text();
    public static string get_DynamicInvocation_Text();
    public static string get_EncapsulateFieldActionText();
    public static string get_EncapsulateFieldToAutoPropertySettingDescription();
    public static string get_ExtensionMethodToPlainStaticActionText();
    public static string get_ExtractActionGroupText();
    public static string get_ExtractClassActionText();
    public static string get_ExtractInterfaceActionText();
    public static string get_ExtractMembersToPartialActionText();
    public static string get_ExtractMethodActionText();
    public static string get_ExtractSuperclassActionText();
    public static string get_GenerateHashcodeSettingDescription();
    public static string get_GenerateRecordTypeSettingDescription();
    public static string get_GenerateToStringSettingDescription();
    public static string get_IndexerToMethodActionText();
    public static string get_InlineActionGroupText();
    public static string get_InlineActionText();
    public static string get_InlineMethodRefactoringSettingsSettingDescription();
    public static string get_InterfaceToAbstractClassActionText();
    public static string get_IntroduceFieldActionText();
    public static string get_IntroduceParameterActionText();
    public static string get_IntroduceVariableActionText();
    public static string get_InvertBooleanActionText();
    public static string get_ExtractMethodPage_LoadingNameSuggestions_Text();
    public static string get_MakeEncapsulatingFieldPrivateSettingDescription();
    public static string get_MakeMethodNonStaticActionText();
    public static string get_MakeMethodStaticActionText();
    public static string get_MethodBodyWillHaveErrorsBecauseItUsesMembers_Text();
    public static string get_MethodBodyWillHaveErrorsBecauseItUsesCaptures_Text();
    public static string get_MethodBodyWillHaveErrorsBecauseItUsesFunctions_Text();
    public static string get_MethodToIndexerActionText();
    public static string get_MethodToPropertyActionText();
    public static string get_MoveActionText();
    public static string get_MoveTypesIntoMatchingFilesActionText();
    public static string get_ExtractMethodPage_NameSuggestionGenerationTimedOut_Text();
    public static string get_ExtractMethodPage_NameSuggestionsAreAvailable_Text();
    public static string get_ExtractMethodPage_NoSuggestions_Text();
    public static string get_ExtractMethodPage_NameSuggestionGenerationFailed_Text();
    public static string get_OptionalParametersMustAppearAfterAll_Text();
    public static string get_ParameterNameCannotBeEmpty_Text();
    public static string get_ParamsParameterMustAppearAfterAll_Text();
    public static string get_PersistentSettingsForEncapsulateFieldRefactoringSettingDescription();
    public static string get_PlaceTopLevelSettingDescription();
    public static string get_PropertiesKindSettingDescription();
    public static string get_PropertyToAutoPropertyActionText();
    public static string get_PropertyToMethodSActionText();
    public static string get_PullMembersUpActionText();
    public static string get_PushMembersDownActionText();
    public static string get_RemoveParamsModifierActionText();
    public static string get_RemoveParamsModifierRefactoringCaption();
    public static string get_RemoveParamsModifierRefactoringTitle();
    public static string get_RemoveParamsModifier_Text();
    public static string get_RenameActionText();
    public static string get_RenameRefactoringSettingsSettingDescription();
    public static string get_SafeDeleteActionText();
    public static string get_SearchInAllSolutionSettingDescription();
    public static string get_SetParamsModifierActionText();
    public static string get_SetParamsModifierRefactoringCaption();
    public static string get_SetParamsModifierRefactoringTitle();
    public static string get_SetParamsModifier_Text();
    public static string get_ShowInFindResultsSettingDescription();
    public static string get_StaticToExtensionMethodActionText();
    public static string get_TransformParametersActionText();
    public static string get_UpdateExternalFieldUsagesOnlySettingDescription();
    public static string get_UseBaseTypeWherePossibleActionText();
    public static string get_UsingStatementConflict_Text();
    public static string get_WhetherToInlineAllUsagesOrJustTheCurrentUsageIfAvailableSettingDescription();
    public static string get_WhetherToRemoveTheMethodDeclarationAfterItsBeenInlinedIntoAllOfItsUsagesSettingDescription();
    public static string get_WhetherToRenameFileNameWhenASingleClassInTheFileIsRenamedSettingDescription();
    public static string get_WhetherToRenameTypeWhenTheFileIsRenamedSettingDescription();
    public static string get_WhetherToSearchForPossibleDynamicOccurrencesSettingDescription();
    public static string get_WhetherToSearchForStructurallyCompatibleMembersSettingDescription();
    public static string get_WhetherToSearchForTextInStringsSettingDescription();
    public static string get_WhetherToIgnoreAnyReferencesWhenFileIsRenamedSettingDescription();
    public static string get_RefactorThisAction_Title();
    public static string get_RefactorThisAction_Caption();
    public static string get_ReplaceAnonymousTypeWithNamedType_Text();
    public static string get_CreateANewClassToReplaceAllOccurrences_Text();
    public static string get_Scope_Text();
    public static string get_Whole_solution_Text();
    public static string get__LocalScope_Text();
    public static string get_Location_Text();
    public static string get_T_opLevelType_Text();
    public static string get_N_estedType_Text();
    public static string get_Generate_recordType_Text();
    public static string get_Generate_mutableProperties_Text();
    public static string get_GenerateE_qualsAndGetHashCode_Text();
    public static string get_Generate_ToString_Text();
    public static string get_Show_processedUsagesInFindResults_Text();
    public static string get_N_ame_Text();
    public static string get_Usages_Text();
    public static string get_AddParameterAt__Text();
    public static string get_Add_ParameterTo__Text();
    public static string get_ChangeSignature_Text();
    public static string get_Na_me_Text();
    public static string get_Return_type_Text();
    public static string get_ParametersShouldHaveDifferentNames_Text();
    public static string get_ParameterHasInvalidType_Text();
    public static string get_ParameterHasInvalidName_Text();
    public static string get_MoveU_p_ButtonWithListAction_ToolTip();
    public static string get_Param_eters_Text();
    public static string get_SignaturePreview_Text();
    public static string get_C_HangeSignature_Text();
    public static string get_SearchingInheritors_Text();
    public static string get_TypeNameShouldnTBeEmpty_Text();
    public static string get_TypeIsNotValid_Text();
    public static string get_Indexer_Text();
    public static string get_Property_Text();
    public static string get_Constructor_Text();
    public static string get_Method_Text();
    public static string get_TypeCannotBeResolved_Text();
    public static string get_ErrorInDefaultValueExpression_Text();
    public static string get_ChooseValueOfParameter_ToBeUsedToCorrect_Text();
    public static string get_ChooseValueOfParameter_ToBeUsedAsDefault_Text();
    public static string get_DefaultValueForParameter__Text();
    public static string get_UseAsParameterDefaultValue__Text();
    public static string get_ErrorOccured_Text();
    public static string get_UseCustomValue_Text();
    public static string get_UseCustomValue__Text();
    public static string get_Selected__Text();
    public static string get_LeaveAsIs_Text();
    public static string get_NoParametersAdded_Text();
    public static string get_Use___Text();
    public static string get_Selected___Text();
    public static string get_NodeBecameInvalid_Text();
    public static string get_CreateParameter_In___Text();
    public static string get_Parameter_CreatedIn___Text();
    public static string get_UserEdit_Text();
    public static string get_EditedByUser_Text();
    public static string get_Starting_Text();
    public static string get_MakeMethodNonStatic_Text();
    public static string get_ConvertIntoAnInstanceMethodAndMoveIt_Text();
    public static string get_SelectAn_instanceParameter_Text();
    public static string get_MakeStatic_Text();
    public static string get_DefineHowToTransformUsagesOfInstance_Text();
    public static string get_DoNotAddParametersToTheMethod_Text();
    public static string get_Add_thisParameterOfType_WithName_Text();
    public static string get_Introduce_parametersFromFollowingExpressions_Text();
    public static string get_SearchingExpressionOccurrences_Text();
    public static string get_PreparingNewArguments_Text();
    public static string get_PreProcessingUsages_Text();
    public static string get_UpdatingDeclaration_Text();
    public static string get_UpdatingUsages_Text();
    public static string get_Finishing_Text();
    public static string get_UpdatingRecursiveCalls_Text();
    public static string get_Ma_KeStatic_Text();
    public static string get_FindReferencesOf__Text();
    public static string get_Process__Text();
    public static string get_ReviewTypeChanges_Text();
    public static string get_ReviewChangesToTypesOfRelatedSymbols_Text();
    public static string get__UpdateRelatedSymbols_Text();
    public static string get_InvalidDeclaredElement_Text();
    public static string get_Symbol_Text();
    public static string get_NewType_Text();
    public static string get_Navigate_Text();
    public static string get_Conflicts_Text();
    public static string get_AbstractClassToInterface_Text();
    public static string get_COnvertAbstractClassToInterface_Text();
    public static string get_ConstructorToFactoryMethod_Text();
    public static string get_InC_lass_Text();
    public static string get_Factory_methodName_Text();
    public static string get_Create_singleInstance_Text();
    public static string get_ReplaceConstructorWithFactoryMethod_Text();
    public static string get__RefactoringWillBeTerminated_Text();
    public static string get_UpdatingDeclarations_Text();
    public static string get_SearchingReferences_Text();
    public static string get_StoringSuspiciousReferences_Text();
    public static string get_UpdatingSuspiciousReferences_Text();
    public static string get_UpdatingReferences_Text();
    public static string get_SearchingOverrides_Text();
    public static string get_RefactoringFailedToCreateBaseTypeDeclaration_Text();
    public static string get_AnalyseTypeParameters_Text();
    public static string get_SearchingMembersToMakeProtected_Text();
    public static string get_AnalysingConflicts_Text();
    public static string get_FixingOverrides_Text();
    public static string get_SearchingSuspiciousReferences_Text();
    public static string get_RemovingLegacyDeclarations_Text();
    public static string get_MovingMembers_Text();
    public static string get_MakingClassesAbstract_Text();
    public static string get_MakingMembersProtected_Text();
    public static string get_UpdatingCaches_Text();
    public static string get_Scanning__Text();
    public static string get_UpdatingLocalReferences_Text();
    public static string get_UpdatingOtherReferences_Text();
    public static string get_ProcessingReference_Of__Text();
    public static string get_CutDeclarations_Text();
    public static string get_PasteDeclarations_Text();
    public static string get_FixingTypeDeclarations_Text();
    public static string get_SearchingUsages_Text();
    public static string get_InternalReferences_Text();
    public static string get_Select_public_Text();
    public static string get_Select_dependent_Text();
    public static string get_Select_members_Text();
    public static string get___OverridesImplements_FromCompiledCode_Text();
    public static string get__OverridesImplements_FromBaseTypeDo_Text();
    public static string get_MethodToIndexer_Text();
    public static string get_ConvertMethodToProperty_Text();
    public static string get_ConvertMethodToProperty_Ellipsis_Text();
    public static string get_PropertyN_ame_Text();
    public static string get_Make_default_Text();
    public static string get_IndexerToFunction_Text();
    public static string get_ConvertInterfaceToAbstract_Text();
    public static string get_COnvertInterfaceToAbstractClass_Text();
    public static string get_PropertyToAutoProperty_Text();
    public static string get_Preparing_Text();
    public static string get_SearchingBackingFieldUsages_Text();
    public static string get_CreatingProperty_Text();
    public static string get_UpdatingBackingFieldUsages_Text();
    public static string get_ConvertPropertyToAutoProperty_Text();
    public static string get_FunctionToProperty_Text();
    public static string get_ConvertPropertyToMethodS_Text();
    public static string get_StoringReferences_Text();
    public static string get_SearchConflictsWithExistingMembers_Text();
    public static string get_SearchingForAmbiguitiesInTheTargetType_Text();
    public static string get_UpdatingInternalReferences_Text();
    public static string get_Reference_Of__Text();
    public static string get_CopyingDeclarations_Text();
    public static string get_Inserting_Text();
    public static string get_Removing_Text();
    public static string get_TargetTypeIsNotAccessibleAt0CallSite_Text();
    public static string get_SomeMembersAreNotImplemented_Text();
    public static string get_ConvertMethodToIndexer_Text();
    public static string get_COnvertIndexerToMethodS_Text();
    public static string get_Convert_getterToMethodWithName_Text();
    public static string get_Convert_setterToMethodWithName_Text();
    public static string get_ExtensionMethodToPlainStatic_Text();
    public static string get_StaticToExtensionMethod_Text();
    public static string get_COnvertStaticMethodToExtension_Text();
    public static string get_ExtensionMethodTo_PlainStatic_Text();
    public static string get_ExtractMembersToPartial_Text();
    public static string get_PathIsEmpty_Text();
    public static string get_PathContainsInvalidCharacters_Text();
    public static string get_FileNameIsEmpty_Text();
    public static string get_FileAlreadyExists_Text();
    public static string get_RefactorToPartialType_Text();
    public static string get_MakeTheTypePartialIfItIsnTAndMoveThe_Text();
    public static string get_Select_membersToMove_Text();
    public static string get_Use_existingPart_Text();
    public static string get_Select_fileForNewPart_Text();
    public static string get_CreateNewPart_Text();
    public static string get_Invalid_Text();
    public static string get_FileIsAutogenerated_Text();
    public static string get_FileDoesnTExistAndCannotBeCreated__Text();
    public static string get_CopyType_Text();
    public static string get_Copy__Text();
    public static string get_EncapsulateField_Text();
    public static string get_EncapsulatedFieldWillBeInaccessible_Text();
    public static string get_UsePropertyToExposeOrReplaceTheField_Text();
    public static string get_CreateNewProperty_Text();
    public static string get_Choose_property_Text();
    public static string get_To_autoProperty_Text();
    public static string get__WriteUsages_Text();
    public static string get__ReadUsages_Text();
    public static string get_Nam_eUsages_Text();
    public static string get_Make_fieldPrivate_Text();
    public static string get_DoNotUpdate_localUsages_Text();
    public static string get_PropertyNa_me_Text();
    public static string get_Encapsulate_Text();
    public static string get_Or_Text();
    public static string get_AnalysingEmptyNamespaces_Text();
    public static string get__Of__Text();
    public static string get_AnalyzingEmptyNamespaces_Text();
    public static string get_ScanningProject_Of__Text();
    public static string get_CreatingFiles_Text();
    public static string get_MoveTypesIntoMatchingFiles_Text();
    public static string get_MoveIntoSeparateFiles_Text();
    public static string get__ClassStructureAndInterfaceDeclarations_Text();
    public static string get__DelegateDeclarations_Text();
    public static string get__EnumDeclarations_Text();
    public static string get_ReplacingFieldReferences_Text();
    public static string get_ReplacingReferences_Text();
    public static string get_En_CapsulateField_Text();
    public static string get_ExtractClass_Text();
    public static string get_Extract_Class_Refactoring_Title();
    public static string get_FillInTheNameForTheNewClassAndSelect_Text();
    public static string get_SourceClass_Text();
    public static string get__ExtractedClass_Text();
    public static string get__ReferenceToExtracted_Text();
    public static string get_ReferenceTo_source_Text();
    public static string get_ExtractedClassPlacement_Text();
    public static string get_Same_fileAsTheSource_Text();
    public static string get__itsOwnFile_Text();
    public static string get_Select_allSuggestedMembers_Text();
    public static string get_Extract_Text();
    public static string get_None_Text();
    public static string get_Used_Text();
    public static string get_UsedBy_Text();
    public static string get_MoveU_p_Text();
    public static string get_Move_Down_Text();
    public static string get_ConstructorParameters_Text();
    public static string get_MethodParameters_Text();
    public static string get_Par_ameters_Text();
    public static string get_Preview_Text();
    public static string get_ClassNa_me_Text();
    public static string get_MethodNa_me_Text();
    public static string get__ReturnType_Text();
    public static string get_CreateAsField_Text();
    public static string get_CreateAsProperty_Text();
    public static string get_ExtractingDeclarationsFromSourceFiles_Text();
    public static string get_ResolvingReferencesFromSourceFiles_Text();
    public static string get_GeneratingNewCode_Text();
    public static string get_GeneratingUsingDirectives_Text();
    public static string get_RemovingObsoleteImports_Text();
    public static string get_MoveTypeToAnother__Text();
    public static string get_NewFolderIsNestedInTheOriginalFolder_Text();
    public static string get_ProjectIsNullForThisFolder_Text();
    public static string get_TargetProjectLanguageShouldBe__Text();
    public static string get_TargetFolderShouldBeDifferentFromThe_Text();
    public static string get__TargetFolder_Text();
    public static string get_SpecifyTargetFolderAndMoveOptions_Text();
    public static string get_SpecifyHowToCreateNewFiles_Text();
    public static string get_Preserve_hierarchyOfFoldersAndFileNames_Text();
    public static string get_PutClassesInto_separateFiles_Text();
    public static string get__FixNamespaces_Text();
    public static string get__AllowChangeInternalVisibilityToPublic_Text();
    public static string get___Text();
    public static string get_DeclarationsInThisFileShouldBeIncluded_Text();
    public static string get_SpecifySetOfClassesToMove_Text();
    public static string get_SpecifySetOfFilesToMove_Text();
    public static string get_SelectionShouldnTBeEmpty_Text();
    public static string get_SelectedDeclarationsContainConflicts_Text();
    public static string get_RenameNamespace_Text();
    public static string get_NewN_ame_Text();
    public static string get_RenameF_Ile_Text();
    public static string get__RenameSingleTypeToMatchFileName_Text();
    public static string get_RenameTypeToMatchTheNewFileName_Text();
    public static string get_TheNewFileNameExtensionIsNotValidForSourceCodeFiles_Text();
    public static string get_TheNewFileNameCannotBeUsedAsAValidTypeName_Text();
    public static string get_RenameFile_Text();
    public static string get_RenameFileAndUpdateReferencesToIt_Text();
    public static string get_NoFixesAvailableForThisNode_Text();
    public static string get_NodeHadChangedStateCannotBeRestored_Text();
    public static string get_RenameRootNamespace_Text();
    public static string get_RenameProjectReferencesInTheSourceCode_Text();
    public static string get_RenameInCommentsAnd_stringLiterals_Text();
    public static string get_TheNameOfTheRootNamespaceDiffersFrom_Text();
    public static string get_RenameRoot_namespace__Text();
    public static string get_NotSupportedForThisProject_Text();
    public static string get_TheNameOfTheProjectFolderDiffersFrom_Text();
    public static string get_RenameProject_folder_Text();
    public static string get_Rename__Text();
    public static string get_GiveANewNameToThe___Text();
    public static string get_GiveANewNameToThe_File_Text();
    public static string get_NameIsEmpty_Text();
    public static string get_NameIsInvalid_Text();
    public static string get_Project__Text();
    public static string get_ProjectWithName_AlreadyExistsInTheSolution_Text();
    public static string get_File_AlreadyExists_Text();
    public static string get_Folder_AlreadyExists_Text();
    public static string get_FixReferencesToTheProject_Text();
    public static string get_FixProjectProperties_Text();
    public static string get_FixLinkedFiles_Text();
    public static string get_Re_Name_Text();
    public static string get_RefactoringChangeSignature_Text();
    public static string get_ExecuteChangeSignatureFixes_Text();
    public static string get_MoveToAnotherFIle_Text();
    public static string get__RemoveSourceFile_Text();
    public static string get__TargetFileName_Text();
    public static string get_Target__Text();
    public static string get_TupleComponentWithSuchNameAlreadyExists_Text();
    public static string get_InvalidTupleComponentName_Text();
    public static string get_SelectScopeWhereToSearchForAnonymous_Text();
    public static string get_ReviewItemsThatWillBeRenamed_Text();
    public static string get_BulkRenameRefactoring_Text();
    public static string get_SearchIn_textOccurrences_Text();
    public static string get_Synchronize_filename_Text();
    public static string get_Usage_WillReferToComponentOfType_Instead_Text();
    public static string get_Usage_WillBeBroken_Text();
    public static string get_ProcessingCommentsAndStringLiterals_Text();
    public static string get_CollectingProjectReferencesInTheSource_Text();
    public static string get_IOError__Text();
    public static string get_UnableToPerformRefactoring_Caption();
    public static string get_RenameProject_Text();
    public static string get_PrepareFileSystem_Text();
    public static string get_AnalyzeProjectDependencies_Text();
    public static string get_ProjectFileIsNotValid_Text();
    public static string get_WebPageCannotBeMovedIntoAppCodeFolder_Text();
    public static string get_HierarchyCannotBePreservedForDeclaration_Text();
    public static string get_Select_membersToMakePublic_Text();
    public static string get_MoveToFoldeR_Text();
    public static string get_RenameRelatedSYmbols_Text();
    public static string get_File_Exists_Text();
    public static string get_Folder_Exists_Text();
    public static string get_SearchConflicts_Text();
    public static string get_ScanningHierarchy_Text();
    public static string get_PerformRename_Text();
    public static string get_ScanningFiles_Text();
    public static string get_CheckingSuspiciousReferences_Text();
    public static string get_FindUsagesAndTextualOccurrences_Text();
    public static string get_ScanConflictsInHierarchy_Text();
    public static string get_AlsoRename_filesToReflectThisChange_Text();
    public static string get_SearchIn_commentsAndStringLiterals_Text();
    public static string get_QuickRename_IgnoreAnyReferences_Text();
    public static string get__1Symbol_Text();
    public static string get___Symbols_Text();
    public static string get__RenameRelatedSymbols_Text();
    public static string get_Related_symbols_Text();
    public static string get__IsAMemberOfAHierarchyWhatWouldYouLike_Text();
    public static string get_Remove_WHOLEHierarchy_Text();
    public static string get_RemoveElementAndAll_INHERITORS_Text();
    public static string get_RemoveA_SINGLEMemberOfTheHierarchy_Text();
    public static string get__HasDerivedTypesWhatWouldYouLikeToDo_Text();
    public static string get_R_emove_AndInheritors_Text();
    public static string get__Remove_Only_Text();
    public static string get_SafeDelete_Text();
    public static string get_ObjectCreationCannotBeDeleted_Text();
    public static string get_DeletingFromTheFileSystem_Text();
    public static string get_CollectingProjectReferences_Text();
    public static string get_CollectingProjectsReferences_Text();
    public static string get_DeletingProjectsReferences_Text();
    public static string get_DeletingProjects_Text();
    public static string get_Add_To__Text();
    public static string get_AndSpecifyOtherOptions_Text();
    public static string get_EnterMethodName_Text();
    public static string get_EnterPropertyName_Text();
    public static string get_EnterLocalFunctionName_Text();
    public static string get_EnterMethodObjectName_Text();
    public static string get_ChooseConstructorParameters_Text();
    public static string get_ExtractMethod_Text();
    public static string get__ExtractMethod_Text();
    public static string get_Success_Text();
    public static string get_LanguageOfSourceCodeIsNotSupportedBy_Text();
    public static string get_SelectedBlockOfCodeCannotBeExtracted_Text();
    public static string get_ExpressionTypeIsUnknown_Text();
    public static string get_ExpressionTypeIsVoid_Text();
    public static string get_AnonymousTypesCannotCrossExtractedBlock_Text();
    public static string get_ExtractedBlockHasMultipleEntries_Text();
    public static string get_ExtractedBlockHasExitsToDifferentPoints_Text();
    public static string get__ProceedWithRefactoring_Text();
    public static string get_ExtractMethod_Caption();
    public static string get_ExtractMethodCannotProceed_Caption();
    public static string get__Visibility_Text();
    public static string get_Declare_shared_Text();
    public static string get_MethodR_eceives_Text();
    public static string get_Method_returns_Text();
    public static string get_Select_parametersToTransform_Text();
    public static string get_In_Text();
    public static string get_Out_Text();
    public static string get_ReturnValue__Text();
    public static string get_DefaultParameterValue_Text();
    public static string get_AppendToExisting_tuple_Text();
    public static string get_TupleElementsNumberCannotBeMoreThan_Text();
    public static string get_TransformParameters_Text();
    public static string get_UseBaseTypeWherePossible_Text();
    public static string get_ReplaceReferencesToTheSelectedTypeWith_Text();
    public static string get_ReplaceTypesIn_typeofOperator_Text();
    public static string get_ReplaceTypesIn_isOperator_Text();
    public static string get_Select_baseType_Text();
    public static string get__UseBaseTypeWherePossible_Text();
    public static string get_ReplaceOneOccurrence_Text();
    public static string get_ReplaceInitialExpressionOnly_Text();
    public static string get_Replace_Occurrences_Text();
    public static string get_Replace1Occurrence_Text();
    public static string get_ReplaceAllHighlightedOccurrencesOfInitial_Text();
    public static string get_ReplaceSelectedOccurrences_Text();
    public static string get_UseSelectedExpressionAsASource_Text();
    public static string get_Method_InvalidatedSinceRefactoringStarted_Text();
    public static string get_TooManyTupleParametersMaximumNumber_Text();
    public static string get_NoSuchType___Text();
    public static string get_RemovingUnusedUsings_Text();
    public static string get_ValidatingUsagesOfSymbols_Of__Text();
    public static string get_SearchingUsagesOfMovedSymbols_Text();
    public static string get_StoringUsagesOfMovedSymbols_Text();
    public static string get_InlineClass_Text();
    public static string get_FieldIsUsedAs0RefOutArgument_Text();
    public static string get__ValueWillBeLost_Text();
    public static string get__HasInitializer_Text();
    public static string get_ChangeSignatureIsAppliedTo_ThatAlsoOverrides_Text();
    public static string get_ChangeSignatureIsAppliedTo_ThatAlsoImplements_Text();
    public static string get__IsQuasiImplementedBy_ThatWillNotBe_Text();
    public static string get_Converted_AlsoOverrides_ThatWillNot_Text();
    public static string get_Converted_AlsoImplements_ThatWillNot_Text();
    public static string get_Converted_IsQuasiImplementedBy_That_Text();
    public static string get_Removed_AlsoOverrides_ThatWillNotBe_Text();
    public static string get_Removed_AlsoImplements_ThatWillNotBe_Text();
    public static string get_Removed_IsQuasiImplementedBy_ThatWill_Text();
    public static string get__AlsoOverrides_ThatWillNotBeChanged_Text();
    public static string get__AlsoImplements_ThatWillNotBeChanged_Text();
    public static string get__Overrides_ThatWillNotBeChangedPlease_Text();
    public static string get__Implements_ThatWillNotBeChangedPlease_Text();
    public static string get_IntroduceParameterIsAppliedTo_ThatAlsoOverrides_Text();
    public static string get_IntroduceParameterIsAppliedTo_ThatAlsoImplements_Text();
    public static string get_Renamed_AlsoOverrides_ThatWillNotBe_Text();
    public static string get_Renamed_AlsoImplements_ThatWillNotBe_Text();
    public static string get_Renamed_IsQuasiImplementedBy_ThatWill_Text();
    public static string get__HasHandlesClause_Text();
    public static string get_Usage_Text();
    public static string get_UnableToChangeSignatureOf0Element_Text();
    public static string get_AccessTo0Instance_Text();
    public static string get_ContainingType_HasNameSameToTheNewName_Text();
    public static string get_NoMembersWereFoundToPushDownRefactoring_Text();
    public static string get_NoAppropriateInheritorsWereFoundRefactoring_Text();
    public static string get_Error_Caption();
    public static string get_PushMembersDoWn_Text();
    public static string get_VirtualChainLeapOver_Detected_Text();
    public static string get_Abstract_IsAlreadyDeclaredInTheTarget_Text();
    public static string get_Virtual_IsAlreadyDeclaredInTheTarget_Text();
    public static string get_Override_IsAlreadyDeclaredInTheTarget_Text();
    public static string get__WithGetterAlreadyExists_Text();
    public static string get__WithSetterAlreadyExists_Text();
    public static string get__IsPresentedButItIsNotDefault_Text();
    public static string get__IsAlreadyDeclaredWithAnotherType_Text();
    public static string get_ConflictWithModifiersListFoundIn__Text();
    public static string get_NotDefault_WithThisNameIsAlreadyDeclared_Text();
    public static string get__WillBeHidden_Text();
    public static string get_NewDeclarationIsHiddenBy__Text();
    public static string get_NewElementHides__Text();
    public static string get_NewElementIsHiddenBy__Text();
    public static string get_AutoPropertyWillBeTransformedIntoProperty_Text();
    public static string get_Declaration_Text();
    public static string get__HasSetterThatCannotOverrideTheBase_Text();
    public static string get__HasGetterThatCannotOverrideTheBase_Text();
    public static string get__ImplementsConvertedInterfaceExplicitly_Text();
    public static string get__IsAQuasiImplementation_Text();
    public static string get_ConvertedInterfaceIsImplementedBy_That_Text();
    public static string get__ExtendsConvertedInterface_Text();
    public static string get_UnableToAccessTypeOf_InFactoryClass_Text();
    public static string get_Backing_IsMoreVisibleThanPropertyOr_Text();
    public static string get_TargetClassHasMemberWithTheSameName_Text();
    public static string get__HasInitializerAnd_WriteUsageS1First_Text();
    public static string get__Has_WriteUsages1FirstWriteUsage2Second_Text();
    public static string get_WriteUsageIsFoundButInitialization_Text();
    public static string get_NoWriteUsagesWereFound_Text();
    public static string get_LanguageOfInlinedDeclarationIs_ButLanguage_Text();
    public static string get_InLineField_Text();
    public static string get_FixingCode_Text();
    public static string get_NoValueProvidedFor0Parameter_Text();
    public static string get__ParameterUsagesWillBeBroken_Text();
    public static string get_UsageWillBeFixed_Text();
    public static string get_InlineParameter_Text();
    public static string get_InlineParameterOptions_Text();
    public static string get_NewParameterHasToBeCreated_Text();
    public static string get__NewParametersHasToBeCreated_Text();
    public static string get__SourceOfArgumentsToBeInlined_Text();
    public static string get_CannotBeInlined_Text();
    public static string get_DefaultValue__Text();
    public static string get___From__Text();
    public static string get_ParametersWillBe_removed_Text();
    public static string get_ParametersWillBe_added_Text();
    public static string get_NewParameterSuggestion_Text();
    public static string get_ParameterUsagesWillBeBroken_Text();
    public static string get_InLineVariable_Text();
    public static string get_NoUsagesFound_Text();
    public static string get_UnableToUse_FromTheCallSite_Text();
    public static string get_CannotInlineCombinedReadAndWriteAccess_Text();
    public static string get_Inline_Text();
    public static string get_UnableToInline0UsageMethodGroupIsNot_Text();
    public static string get_ReplaceInvocationsOfMethodWithItsImplementation_Text();
    public static string get__RemoveInlinedMethodDeclaration_Text();
    public static string get_Inline_allUsages_Text();
    public static string get_Inlined_OverridesBaseClassMemberDeclaration_Text();
    public static string get_Inlined_ImplementsInterfaceMemberDeclaration_Text();
    public static string get_InlinedMethodHasAnotherImplementation_Text();
    public static string get_NoUsagesOfMethodWereFound_Text();
    public static string get_UnableToInline0CollectionInitializer_Text();
    public static string get_UnableToInline0UsageInAnObjectInitializer_Text();
    public static string get_UnableToInline0DeconstructionUsage_Text();
    public static string get_UnableToInline0UsageInlinedMethodHas_Text();
    public static string get_UnableToInline0UsageCannotIntroduce_Text();
    public static string get_UnableToInline0UsageUnableToIntroduce_Text();
    public static string get_UnableToInline0UsageUnableToIntroduce_Text2();
    public static string get_UnableToInline0UsageUnableToIntroduce_Text3();
    public static string get_UnableToInline0UsageUnableToIntroduce_Text4();
    public static string get_UnableToInline0UsageUnableToIntroduce_Text5();
    public static string get_UnableToInline0Usage_Text();
    public static string get_InLineMethod_Text();
    public static string get_ProcessingUsages_Text();
    public static string get__HasType_ThatCannotBeUsedDirectlyFrom_Text();
    public static string get_TypeCannotBeUsedAtTheCallSite_Text();
    public static string get_Make_readonly_Text();
    public static string get_Make_static_Text();
    public static string get_InitializeFieldIn_Text();
    public static string get_In_TroduceField_Text();
    public static string get_IntroduceField_Text();
    public static string get_IntroduceParameter_Text();
    public static string get_ThereAreNoUsagesOf0_ValueOfNewParameter_Text();
    public static string get_IntroduceParameter__Text();
    public static string get_In___Text();
    public static string get_ParameterType_Text();
    public static string get_ParameterN_ame_Text();
    public static string get_SelectParametersTo_enlambda_Text();
    public static string get_ParametersThatCanBeSafely_removed_Text();
    public static string get_IntroduceVariable_Text();
    public static string get_Introduce_Variable_Text();
    public static string get_ExpressionTypeUnknown_Text();
    public static string get_ExpressionUsesLambdaParameterOrRange_Text();
    public static string get_UnableToIntroduceVariable_Text();
    public static string get_InvertBoolean_Text();
    public static string get_InvertBooleanValue_Text();
    public static string get_InvertU_sagesOfMember_Text();
    public static string get_InvertValues_insideMember_Text();
    public static string get_ElementHasOverrides_Text();
    public static string get__ReferenceCannotBeInverted_Text();
    public static string get_ReferenceCannotBeInverted_Text();
    public static string get_Move_Text();
    public static string get_MoveInstanceMethod_Text();
    public static string get_ThisMethodIsAnImplementationOrAnOverride_Text();
    public static string get_SelectElement_Text();
    public static string get_ToMoveMethod_To_Text();
    public static string get_SelectATypeToMoveMethod_ToAllCallsWill_Text();
    public static string get__Targets_Text();
    public static string get_ExtractInterface_Text();
    public static string get_ExtractSuperclass_Text();
    public static string get_PullMembersUp_Text();
    public static string get_PushMemberDown_Text();
    public static string get_Reference_MayBeBroken_Text();
    public static string get__DeclaredInTheTargetElementHasConflicts_Text();
    public static string get__DoesnTHaveClassConstraint_Text();
    public static string get__DoesnTHaveValueConstraint_Text();
    public static string get__DoesnTDefaultConstructorConstraint_Text();
    public static string get__DoesnTHaveConstraint_ForTheTypeParameter_Text();
    public static string get_SomeReferencesTo_WillNeedManualFix_Text();
    public static string get_UnableToSaveReferenceTo__Text();
    public static string get_Extract_Superclass_Text();
    public static string get_SearchingConflictsFor__Text();
    public static string get_UpdatingLocalReferencesFor__Text();
    public static string get_TypeParameterAmbiguity_Text();
    public static string get_SelectWhereToMove_Text();
    public static string get__sameFileAsTheSourceClass_Text();
    public static string get_SelectTarget_baseType_Text();
    public static string get_SelectBaseTypeAndMembers_Text();
    public static string get_E_XtractInterface_Text();
    public static string get_PullMem_BersUp_Text();
    public static string get_Select_typesWhereYouWantToMoveMembers_Text();
    public static string get_FullyQualifiedTargetTypeNa_me_Text();
    public static string get__StaticMembersToMove_Text();
    public static string get_MoveToAnotherTYpe_Text();
    public static string get__WillNotBeAccessible__Text();
    public static string get__CannotBeReferenced__Text();
    public static string get_InMovedType_Text();
    public static string get_AfterMove_Text();
    public static string get_MoveToOuterScoPe_Text();
    public static string get_MoveNestedTypeOneLevelUpAndOptionally_Text();
    public static string get_AdjustNamespaces_Text();
    public static string get_SearchingFilesWithInconsistentNamespaces_Text();
    public static string get_AnalyzingPossibleProblems_Text();
    public static string get__AdjustNamespaces_Text();
    public static string get_RegisteringNewCopies_Text();
    public static string get_Choose_filesWhereYouWantToFixNamespaces_Text();
    public static string get_Name_ShouldBeUsedForType__Text();
    public static string get_NamespaceFor0DeclarationCannotBeFixed_Text();
    public static string get_PartOf_ShouldBeInNamespace__Text();
    public static string get_PartialDeclarationInFile_IsNotIncluded_Text();
    public static string get_UnableToMove_BecauseThereIsAnotherDeclaration_Text();
    public static string get_UnableToMove_BecauseFolderWithName__Text();
    public static string get_UnableToMove_BecauseAFileWithTheName_Text();
    public static string get_UnableToMove_StructureOfDependentFiles_Text();
    public static string get_CollectingReferencesToMovedTypes_Text();
    public static string get_GeneratingNewFiles_Text();
    public static string get_UpdatingReferencesForRenamedFiles_Text();
    public static string get__MoveTypesIntoMatchingFiles_Text();
    public static string get__ShouldReference__Text();
    public static string get_RefactoringHasDetectedThatExtraReferences_Text();
    public static string get_ScanningInternalDeclarationsThatShould_Text();
    public static string get_PartOf_IsNotIncludedOtherPartCannot_Text();
    public static string get_FolderWithThisNameAlreadyExistsInTarget_Text();
    public static string get_UnableToMove_AFileWithTheSameNameExists_Text();
    public static string get_Invocation_Text();
    public static string get_ReplaceInitialTypeOnly_Text();
    public static string get_ReplaceAllHighlightedOccurrencesOfType_Text();
    public static string get_ReplaceInitialNamespaceOnly_Text();
    public static string get_ReplaceAllHighlightedOccurrencesOfNamespace_Text();
    public static string get_ReplaceAllHighlightedOccurrencesWithNewVariable_Text();
    public static string get_TypeDeclaration_Text();
    public static string get_Expression_Text();
    public static string get_UnableToCreateClassDeclarationParameters_Text();
    public static string get_Type_AlreadyExists_Text();
    public static string get_CannotCreateClassDeclaration_Text();
    public static string get_Sa_FeDelete_Text();
    public static string get_Remove_emptyFiles_Text();
    public static string get_SomeFilesMayBecomeEmpty_Text();
    public static string get_TheSymbolIsGoingToBeRemovedAndItsUsagesAre_Text();
    public static string get_SymbolRemovalConfirmation_Text();
    public static string get_ThereAreUsagesOf_WhatWouldYouLikeTo_Text();
    public static string get_Report_conflict_Text();
    public static string get_ReplaceWith_baseType__Text();
    public static string get_ReplaceWith_derivedType__Text();
    public static string get_UsageOf_CannotBeReplacedWith__Text();
    public static string get__IsTheLastConstructorItCallsTheBase_Text();
    public static string get_FailedToFindUsagesOf_In__Text();
    public static string get__DeleteProjectFolderAndFilesFromThe_Text();
    public static string get_ThereAreSomeOtherProjectsInSameProjectFolders_Text();
    public static string get_ThereAreSomeProjectsInSolutionDirectory_Text();
    public static string get_SearchFor_usages_Text();
    public static string get_Projects_Text();
    public static string get_SearchingUsagesOfMovedTypes_Text();
    public static string get_CollectingObsoleteUsages_Text();
    public static string get_SearchingUsagesOfRemovedElements_Text();
    public static string get_PleaseReviewElementsThatWillBe_deleted_Text();
    public static string get_EvaluateDerivedRenames_Text();
    public static string get_Update_occurrences_Text();
    public static string get_CheckUsagesThatShouldBeUpdated_Text();
    public static string get_RefactoringHasFoundUsagesRelatedToRefactoring_Text();
    public static string get__HasFoundSomeTextualOccurrencesInComments_Text();
    public static string get_UsagesInCommentsAndStringLiterals_Text();
    public static string get__RenameUsagesInCommentsAndStringLiterals_Text();
    public static string get_ContainingTypeHasTheSameNameAsTheNew_Text();
    public static string get_Rename_Text();
    public static string get_Rena_Me_Text();
    public static string get_BulkRename_Text();
    public static string get_PostProcessingMovedFiles_Text();
    public static string get_CollectingMovedFiles_Text();
    public static string get_FixingAccessRights_Text();
    public static string get_FileName_IsAlreadyUsedForAnotherMoved_Text();
    public static string get__WillHide__Text();
    public static string get__WillImplement__Text();
    public static string get__WillOverride__Text();
    public static string get_FoundAtLeast1UsageOf_In_2FindAllUsages_Text();
    public static string get__FromDeletedElementImplements__Text();
    public static string get__FromDeletedElementOverridesAbstract_Text();
    public static string get__Implements__Text();
    public static string get__OverridesAbstract__Text();
    public static string get_SearchingRelatedElementsFor__Text();
    public static string get_CLass_DescriptionText();
    public static string get_ConstructorS_DescriptionText();
    public static string get_CreateAccessor_DescriptionText();
    public static string get_CreateANewLocalVariableAndUseIt_DescriptionText();
    public static string get_CreateCopy_DescriptionText();
    public static string get_CreateDelegatingWrapper_DescriptionText();
    public static string get_CreateProperty_DescriptionText();
    public static string get_CurrentMember_DescriptionText();
    public static string get_DiscardOutParameterValue_DescriptionText();
    public static string get_DoNotApplyFix_DescriptionText();
    public static string get_ExistingClass_DescriptionText();
    public static string get_FieldInitializer_DescriptionText();
    public static string get_IntroduceConstant_DescriptionText();
    public static string get_LeaveCodeNonCompilableIllCorrectCallsMyself_DescriptionText();
    public static string get_MakePublic_DescriptionText();
    public static string get_MemberIsNotAccessedAnywhere_DescriptionText();
    public static string get_MethodDescriptionText();
    public static string get_NewClassWithAutoProperties_DescriptionText();
    public static string get_NewClassWithPublicFields_DescriptionText();
    public static string get_None_DescriptionText();
    public static string get_Project_DescriptionText();
    public static string get_ResolveWithCallTree_DescriptionText();
    public static string get_Solution_DescriptionText();
    public static string get_SplitRefParameterToInAndOut_DescriptionText();
    public static string get_Tuple_DescriptionText();
    public static string get_USe_DescriptionText();
    public static string get_UseOutParameterAsReturnValue_DescriptionText();
    public static string get_UseTheFollowingValue_DescriptionText();
    public static string get_UseUniqueValueOfTypeAtThePointOfCallIfExists_DescriptionText();
    public static string get_Members_ColumnName();
    public static string get_MakeAbstract_ColumnName();
    public static string get_Modifier_Column_Name();
    public static string get_Name_Column_Name();
    public static string get_Type_Column_Name();
    public static string get_OldName_Column_Text();
    public static string get_NewName_Column_Text();
    public static string get_Name_space_Text();
    public static string get_Namespace_Lower_Text();
    public static string get_Module_Lower_Text();
    public static string get_Usages_Column_Text();
    public static string get_SourceClassMember_Column_Text();
    public static string get_TargetClassMember_Column_Text();
    public static string get_Name_Column_Text();
    public static string get_Modifier_Text();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteFolder.Impl.SafeDeleteFolderPage : SingleBeRefactoringPage {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    private List`1<ProjectItemInfo> myWorkflowIncludedProjectFiles;
    public static string TreeGrid;
    public string Title { get; protected set; }
    public string Description { get; protected set; }
    public SafeDeleteFolderPage(SafeDeleteFolderWorkflow workflow);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    public virtual BeControl GetPageContent();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.SafeDeleteFolder.Impl.SafeDeleteFolderWorkflowProvider : SafeDeleteWorkflowProvider {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.SafeDeleteFolder.Impl.SafeDeleteFolderWorkflowProvider/<CreateWorkflow>d__0")]
public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteFolder.SafeDeleteFolderBase : RefactoringExecBase`2<SafeDeleteFolderWorkflow, SafeDeleteFolderRefactoring> {
    public SafeDeleteFolderBase(SafeDeleteFolderWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteFolder.SafeDeleteFolderRefactoring : DrivenRefactoring`2<SafeDeleteFolderWorkflow, SafeDeleteFolderBase> {
    private IList`1<ITreeNode> myUsingsToRemove;
    public SafeDeleteFolderRefactoring(SafeDeleteFolderWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
    private void RemoveUsingsOfEmptyNamespaces(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private bool <Execute>b__2_0(ICollection`1<IDeclaredElement> innerElements);
    [CompilerGeneratedAttribute]
private bool <Execute>b__2_1(IDeclaredElement x);
    [CompilerGeneratedAttribute]
private bool <Execute>b__2_2(IPsiSourceFile d);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITreeNode> <Execute>b__2_3(IFile file, IList`1<INamespace> namespaces);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteFolder.SafeDeleteFolderWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private List`1<ProjectItemInfo> <IncludedProjectFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDeclaredElement> <ElementsToSearch>k__BackingField;
    private OneToSetMap`2<IDeclaredElement, IReference> myConflictReferences;
    [CompilerGeneratedAttribute]
private CachingLanguageSpecificImpl`1<SafeDeleteFolderLanguageSpecific> <LanguageSpecific>k__BackingField;
    public List`1<ProjectItemInfo> IncludedProjectFiles { get; private set; }
    public IList`1<IDeclaredElement> ElementsToSearch { get; private set; }
    public CachingLanguageSpecificImpl`1<SafeDeleteFolderLanguageSpecific> LanguageSpecific { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public HelpId HelpKeyword { get; }
    public SafeDeleteFolderWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public List`1<ProjectItemInfo> get_IncludedProjectFiles();
    [CompilerGeneratedAttribute]
private void set_IncludedProjectFiles(List`1<ProjectItemInfo> value);
    [CompilerGeneratedAttribute]
public IList`1<IDeclaredElement> get_ElementsToSearch();
    [CompilerGeneratedAttribute]
private void set_ElementsToSearch(IList`1<IDeclaredElement> value);
    [CompilerGeneratedAttribute]
public CachingLanguageSpecificImpl`1<SafeDeleteFolderLanguageSpecific> get_LanguageSpecific();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual HelpId get_HelpKeyword();
    public IRefactoringPage CommitFirstPage(IProgressIndicator pi);
    public bool IsIncluded(IReference reference);
    public bool IsIncluded(IProjectFile projectFile);
    public bool IsValid(IProgressIndicator pi);
    public void CreateReviewTree(IEnumerable`1<IProjectItem> projectItems);
    private void FillModelNodes(IProjectItem item, ProjectItemInfo parent, bool isRoot);
    private void CollectExternalDeclaredElements(IFile file, ProjectItemInfo projectItem);
    public void MakeActionWithPsi(IPsiSourceFile sourceFile, Action`2<IFile, PsiLanguageType> action);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteProjects.Impl.SafeDeleteProjectsPage : SingleBeRefactoringPage {
    public static string TreeGrid;
    private SafeDeleteProjectsWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <SafeDeleteWithUsageSearch>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <DeleteFilesFromDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public IProperty`1<bool> SafeDeleteWithUsageSearch { get; }
    public IProperty`1<bool> DeleteFilesFromDisk { get; }
    public string Title { get; protected set; }
    public string Description { get; protected set; }
    public SafeDeleteProjectsPage(SafeDeleteProjectsWorkflow workflow);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_SafeDeleteWithUsageSearch();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_DeleteFilesFromDisk();
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    public virtual BeControl GetPageContent();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.SafeDeleteProjects.Impl.SafeDeleteProjectsWorkflowProvider : SafeDeleteWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public interface JetBrains.ReSharper.Refactorings.SafeDeleteProjects.IProjectToDelete {
    [NotNullAttribute]
public List`1<IProjectToDelete> Children { get; }
    [CanBeNullAttribute]
public IProject Project { get; }
    public abstract virtual List`1<IProjectToDelete> get_Children();
    public abstract virtual IProject get_Project();
    public abstract virtual void RemoveProject(ISolution solution);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetLocationsToDelete();
    public abstract virtual BeControl GetLinePresentation();
    public abstract virtual void NavigateToSolutionExplorer();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteProjects.SafeDeleteProjectDataModel : object {
    public List`1<IProjectToDelete> ProjectsToDelete;
    public bool DeleteFilesFromDisk;
    public Nullable`1<DeleteFilesFromDiskForbiddenReason> DeleteFilesFromDiskForbidden;
    public bool SafeDeleteWithUsageSearch;
    [CompilerGeneratedAttribute]
private IList`1<IProjectToProjectReference> <ProjectToProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IReference> <RedundantUsagesToRemove>k__BackingField;
    [NotNullAttribute]
public IList`1<IProjectToProjectReference> ProjectToProjectReferences { get; public set; }
    [NotNullAttribute]
public IList`1<IReference> RedundantUsagesToRemove { get; public set; }
    public SafeDeleteProjectDataModel(ISolution solution, List`1<IProjectToDelete> projectsToDelete, bool deleteFilesFromDiskPredefinedValue);
    private Nullable`1<DeleteFilesFromDiskForbiddenReason> GetForbiddenReasonOrNull(ISolution solution, List`1<IProjectToDelete> projectsToDelete);
    [CompilerGeneratedAttribute]
public IList`1<IProjectToProjectReference> get_ProjectToProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ProjectToProjectReferences(IList`1<IProjectToProjectReference> value);
    [CompilerGeneratedAttribute]
public IList`1<IReference> get_RedundantUsagesToRemove();
    [CompilerGeneratedAttribute]
public void set_RedundantUsagesToRemove(IList`1<IReference> value);
    [NotNullAttribute]
public List`1<IProjectToDelete> GetAllProjectsToDelete();
    [NotNullAttribute]
private List`1<IProjectToDelete> GetAllChildrenAndThis(IProjectToDelete projectToDelete);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteProjects.SafeDeleteProjectsBase : RefactoringExecBase`2<SafeDeleteProjectsWorkflow, SafeDeleteProjectsRefactoring> {
    public SafeDeleteProjectsBase(SafeDeleteProjectsWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public abstract class JetBrains.ReSharper.Refactorings.SafeDeleteProjects.SafeDeleteProjectsHelper : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual List`1<IProjectToDelete> GetProjectsToDelete(ISolution solution, IDataContext context);
    [NotNullAttribute]
[ItemNotNullAttribute]
public virtual IEnumerable`1<VirtualFileSystemPath> GetLocationsToDeleteWithDisableUndo(ISolution solution, IProjectToDelete project);
    public virtual void DeleteWithDisabledUndo(ISolution solution, VirtualFileSystemPath fileSystemPath);
    public virtual void RemoveProjectReference(ISolution solution, IProjectToProjectReference reference);
    public virtual void SuspendAsyncProjectsReload(Lifetime lifetime, ISolution solution);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteProjects.SafeDeleteProjectsRefactoring : DrivenRefactoring`2<SafeDeleteProjectsWorkflow, SafeDeleteProjectsBase> {
    public SafeDeleteProjectsRefactoring(SafeDeleteProjectsWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool Execute(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteProjects.SafeDeleteProjectsWorkflow : DrivenRefactoringWorkflow {
    [NotNullAttribute]
private IActionManager myActionManager;
    private bool myDeleteFilesFromDiskDefaultValue;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeDeleteProjectsHelper <Helper>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeDeleteProjectDataModel <DataModel>k__BackingField;
    public ILogger Logger { get; }
    public SafeDeleteProjectsHelper Helper { get; }
    public SafeDeleteProjectDataModel DataModel { get; private set; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public SafeDeleteProjectsWorkflow(ISolution solution, string actionId, SafeDeleteProjectsHelper helper, IActionManager actionManager, bool deleteFilesFromDiskDefaultValue);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public SafeDeleteProjectsHelper get_Helper();
    [CompilerGeneratedAttribute]
public SafeDeleteProjectDataModel get_DataModel();
    [CompilerGeneratedAttribute]
private void set_DataModel(SafeDeleteProjectDataModel value);
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual bool IsAvailable(IDataContext context);
    [CanBeNullAttribute]
public IRefactoringPage CommitFirstPage(IProgressIndicator initialPi);
    [NotNullAttribute]
private List`1<IProjectToProjectReference> CollectReferencesToProjects(IProgressIndicator pi);
    [NotNullAttribute]
private IList`1<IProjectToProjectReference> CollectReferencesToProject(IProgressIndicator pi, IProjectToDelete projectToDelete);
    public virtual bool Initialize(IDataContext context);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private void <PostExecute>b__29_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<VirtualFileSystemPath> <PostExecute>b__29_2(IProjectToDelete x);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteProjects.SearchReferencedCodeForRemoveProjectConsumer : SearchReferencedCodeConsumer {
    private bool mySearchForFirstUsageResult;
    public List`1<IReference> RedundantUsagesToRemove;
    public SearchReferencedCodeForRemoveProjectConsumer(List`1<IModule> modulesClosure, IEqualityComparer`1<IPsiModule> comparer, TargetFrameworkId targetFrameworkId, bool trackOverflow, bool searchForFirstUsageResult);
    public virtual IOccurrence Build(FindResult result);
    public virtual FindExecution Merge(IOccurrence data);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Data.RemovedCodeScope : object {
    [NotNullAttribute]
private List`1<ITreeNode> myDeletedElements;
    [NotNullAttribute]
public IEnumerable`1<ITreeNode> DeletedElements { get; }
    public RemovedCodeScope(List`1<ITreeNode> deletedElements);
    public IEnumerable`1<ITreeNode> get_DeletedElements();
    [PureAttribute]
public bool IsDeleted(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Data.RemovedElementsInfo : object {
    [NotNullAttribute]
private IList`1<Action`1<SafeDeleteRefactoring>> myActions1;
    [NotNullAttribute]
private IList`1<Action`1<SafeDeleteRefactoring>> myActions2;
    [CompilerGeneratedAttribute]
private IList`1<ElementRemover> <Removers>k__BackingField;
    [CompilerGeneratedAttribute]
private RemovedCodeScope <RemovedCodeScope>k__BackingField;
    [NotNullAttribute]
public IList`1<ElementRemover> Removers { get; }
    public RemovedCodeScope RemovedCodeScope { get; }
    public RemovedElementsInfo(IList`1<ElementRemover> removers, RemovedCodeScope removedCodeScope, IList`1<Action`1<SafeDeleteRefactoring>> actions1, IList`1<Action`1<SafeDeleteRefactoring>> actions2);
    public RemovedElementsInfo(RemovedElementsInfo[] infos);
    [CompilerGeneratedAttribute]
public IList`1<ElementRemover> get_Removers();
    [CompilerGeneratedAttribute]
public RemovedCodeScope get_RemovedCodeScope();
    public void BeforeRemovingDeclarations(SafeDeleteRefactoring refactoring);
    public void BeforeUpdatingReferences(SafeDeleteRefactoring refactoring);
}
public abstract class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Data.SafeDeleteData : object {
    public bool IsValid { get; }
    public abstract virtual bool get_IsValid();
    public virtual IRefactoringPage GetOptionsPage(IProgressIndicator pi);
    [CanBeNullAttribute]
public abstract virtual RemovedElementsInfo Execute(IProgressIndicator pi, SafeDeleteRefactoring refactoring);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteClassData : SafeDeleteData {
    [CompilerGeneratedAttribute]
private SafeDeleteWorkflow <Workflow>k__BackingField;
    private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private IElementInstancePointer`1<ITypeElement> <SuperTypePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<ITypeElement> <ClassOrInterfacePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<ITypeElement> <SingleInheritor>k__BackingField;
    [CompilerGeneratedAttribute]
private UsagesProcessingTypes <UsagesProcessingType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveSingleClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInheritors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private RichText <PresentedTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SingleInheritorName>k__BackingField;
    [NotNullAttribute]
public SafeDeleteWorkflow Workflow { get; }
    [CanBeNullAttribute]
public IElementInstancePointer`1<ITypeElement> SuperTypePointer { get; private set; }
    [NotNullAttribute]
public IDeclaredElementPointer`1<ITypeElement> ClassOrInterfacePointer { get; }
    [CanBeNullAttribute]
public IDeclaredElementPointer`1<ITypeElement> SingleInheritor { get; private set; }
    public UsagesProcessingTypes UsagesProcessingType { get; private set; }
    public bool RemoveSingleClass { get; private set; }
    public string ElementKind { get; private set; }
    public bool HasInheritors { get; private set; }
    public bool IsInterface { get; private set; }
    public RichText PresentedTypeName { get; private set; }
    [CanBeNullAttribute]
public string BaseTypeName { get; private set; }
    [CanBeNullAttribute]
public string SingleInheritorName { get; private set; }
    public bool IsValid { get; }
    public DeleteClassData(ITypeElement classOrInterface, SafeDeleteWorkflow workflow);
    [CompilerGeneratedAttribute]
public SafeDeleteWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
public IElementInstancePointer`1<ITypeElement> get_SuperTypePointer();
    [CompilerGeneratedAttribute]
private void set_SuperTypePointer(IElementInstancePointer`1<ITypeElement> value);
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<ITypeElement> get_ClassOrInterfacePointer();
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<ITypeElement> get_SingleInheritor();
    [CompilerGeneratedAttribute]
private void set_SingleInheritor(IDeclaredElementPointer`1<ITypeElement> value);
    [CompilerGeneratedAttribute]
public UsagesProcessingTypes get_UsagesProcessingType();
    [CompilerGeneratedAttribute]
private void set_UsagesProcessingType(UsagesProcessingTypes value);
    [CompilerGeneratedAttribute]
public bool get_RemoveSingleClass();
    [CompilerGeneratedAttribute]
private void set_RemoveSingleClass(bool value);
    [CompilerGeneratedAttribute]
public string get_ElementKind();
    [CompilerGeneratedAttribute]
private void set_ElementKind(string value);
    [CompilerGeneratedAttribute]
public bool get_HasInheritors();
    [CompilerGeneratedAttribute]
private void set_HasInheritors(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInterface();
    [CompilerGeneratedAttribute]
private void set_IsInterface(bool value);
    [CompilerGeneratedAttribute]
public RichText get_PresentedTypeName();
    [CompilerGeneratedAttribute]
private void set_PresentedTypeName(RichText value);
    [CompilerGeneratedAttribute]
public string get_BaseTypeName();
    [CompilerGeneratedAttribute]
private void set_BaseTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_SingleInheritorName();
    [CompilerGeneratedAttribute]
private void set_SingleInheritorName(string value);
    public virtual bool get_IsValid();
    public IPsiServices GetPsiServices();
    public virtual IRefactoringPage GetOptionsPage(IProgressIndicator pi);
    public IRefactoringPage CommitHierarchyPage(bool removeSingleClass, IProgressIndicator pi);
    public IRefactoringPage CommitUsagesPage(UsagesProcessingTypes processingTypes);
    [CanBeNullAttribute]
private IRefactoringPage ShowRemoveFilesPageIfMatters(ITypeElement typeElement);
    private IRefactoringPage ShowRemoveFilesPage();
    public virtual RemovedElementsInfo Execute(IProgressIndicator pi, SafeDeleteRefactoring refactoring);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteClassExecuter : object {
    private DeleteClassData myData;
    private SafeDeleteRefactoring myRefactoring;
    private ITypeElement myTypeElement;
    private List`1<ElementRemover> myElementRemovers;
    private List`1<ITypeDeclaration> myRemovedElements;
    private List`1<Action`1<SafeDeleteRefactoring>> myActionsBefore;
    private HashSet`1<INamespace> myPossiblyEmptyNamespacesNamespaces;
    private IList`1<ITreeNode> myUsingsToRemove;
    public DeleteClassExecuter(DeleteClassData data, SafeDeleteRefactoring refactoring);
    public RemovedElementsInfo Execute(IProgressIndicator pi);
    private bool AllMembersOfNamespaceAreIncluded(IEnumerable`1<IDeclaredElement> declaredElements);
    private void CollectElementRemovers(IProgressIndicator pi);
    private void RegisterOwnerNamespaces(IDeclaration declaration);
    private void CollectElementRemoversForDoNotReplace(IProgressIndicator pi);
    private void CollectElementRemoversForUseBase(IProgressIndicator pi);
    private void CollectElementRemoversForUseChild(IProgressIndicator pi);
    private static Action`1<SafeDeleteRefactoring> GetMakeVirtualAction(ITypeMember immediateOverride);
    private bool ReviveData();
    private void FixMustHaveMethodImpl(IEnumerable`1<ITypeElement> immediateInheritors, IOverridableMember overridableMember, OverridableMemberInstance abstractBaseMember);
    private void ProcessInheritorsInWholeHierarchy(ICollection`1<IOverridableMember> membersToMakeVirtualInTheWholeHierarchy, IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITreeNode> <Execute>b__9_1(IFile file, IList`1<INamespace> namespaces);
    [CompilerGeneratedAttribute]
private void <Execute>b__9_0(SafeDeleteRefactoring _);
    [CompilerGeneratedAttribute]
private bool <AllMembersOfNamespaceAreIncluded>b__10_0(IDeclaredElement x);
    [CompilerGeneratedAttribute]
private bool <AllMembersOfNamespaceAreIncluded>b__10_1(ITypeDeclaration y);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteElementData : SafeDeleteData {
    [NotNullAttribute]
private SafeDeleteWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<IDeclaredElement> <ElementPointer>k__BackingField;
    [NotNullAttribute]
public IDeclaredElementPointer`1<IDeclaredElement> ElementPointer { get; }
    public bool IsValid { get; }
    public DeleteElementData(IDeclaredElement element, SafeDeleteWorkflow workflow);
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<IDeclaredElement> get_ElementPointer();
    public virtual bool get_IsValid();
    public virtual IRefactoringPage GetOptionsPage(IProgressIndicator pi);
    public virtual RemovedElementsInfo Execute(IProgressIndicator pi, SafeDeleteRefactoring refactoring);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteElementExecuter : object {
    private DeleteElementData myData;
    public DeleteElementExecuter(DeleteElementData data);
    public RemovedElementsInfo Execute(IProgressIndicator pi, SafeDeleteRefactoring refactoring);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteHierarchyMemberData : SafeDeleteData {
    private IPsiServices myPsiServices;
    private bool myIsAccessor;
    private bool myIsAccessorFromIntercace;
    [CompilerGeneratedAttribute]
private SafeDeleteWorkflow <Workflow>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<IOverridableMember> <MemberPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOverrides>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PresentedMemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessHierarchyMemberTypes <ProcessHierarchyMemberType>k__BackingField;
    [NotNullAttribute]
public SafeDeleteWorkflow Workflow { get; }
    [NotNullAttribute]
public IDeclaredElementPointer`1<IOverridableMember> MemberPointer { get; }
    public bool HasOverrides { get; private set; }
    public bool HasBase { get; private set; }
    public string PresentedMemberName { get; private set; }
    public ProcessHierarchyMemberTypes ProcessHierarchyMemberType { get; private set; }
    public bool IsValid { get; }
    public DeleteHierarchyMemberData(IOverridableMember overridableMember, SafeDeleteWorkflow workflow);
    [CompilerGeneratedAttribute]
public sealed virtual SafeDeleteWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<IOverridableMember> get_MemberPointer();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasOverrides();
    [CompilerGeneratedAttribute]
private void set_HasOverrides(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasBase();
    [CompilerGeneratedAttribute]
private void set_HasBase(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PresentedMemberName();
    [CompilerGeneratedAttribute]
private void set_PresentedMemberName(string value);
    [CompilerGeneratedAttribute]
public ProcessHierarchyMemberTypes get_ProcessHierarchyMemberType();
    [CompilerGeneratedAttribute]
private void set_ProcessHierarchyMemberType(ProcessHierarchyMemberTypes value);
    public virtual bool get_IsValid();
    public virtual IRefactoringPage GetOptionsPage(IProgressIndicator pi);
    public sealed virtual IRefactoringPage CommitHierarchyPage(ProcessHierarchyMemberTypes type, IProgressIndicator pi);
    public virtual RemovedElementsInfo Execute(IProgressIndicator pi, SafeDeleteRefactoring refactoring);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteHierarchyMemberExecuter : HierarchyConflictTextProviderBase {
    private DeleteHierarchyMemberData myData;
    private SafeDeleteRefactoring myRefactoring;
    public DeleteHierarchyMemberExecuter(DeleteHierarchyMemberData data, SafeDeleteRefactoring refactoring);
    public RemovedElementsInfo Execute(IProgressIndicator pi);
    public virtual string WillAlsoOverride();
    public virtual string WillAlsoImplement();
    public virtual string QuasiImplements();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteParameterData : SafeDeleteData {
    [NotNullAttribute]
private SafeDeleteWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<IParameter> <ParameterPointer>k__BackingField;
    [NotNullAttribute]
public IDeclaredElementPointer`1<IParameter> ParameterPointer { get; }
    public bool IsValid { get; }
    public DeleteParameterData(IParameter overridableMember, SafeDeleteWorkflow workflow);
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<IParameter> get_ParameterPointer();
    public virtual bool get_IsValid();
    public virtual IRefactoringPage GetOptionsPage(IProgressIndicator pi);
    public virtual RemovedElementsInfo Execute(IProgressIndicator pi, SafeDeleteRefactoring refactoring);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteParameterExecuter : HierarchyConflictTextProviderBase {
    private DeleteParameterData myData;
    private SafeDeleteRefactoring myRefactoring;
    public DeleteParameterExecuter(DeleteParameterData data, SafeDeleteRefactoring refactoring);
    public RemovedElementsInfo Execute(IProgressIndicator pi);
    private static void RemoveParameter(SafeDeleteRefactoring refactoring, ParameterRemover parameterRemover);
    private static void AddRemoveNullCheckAction(IParameter parameter, List`1<Action`1<SafeDeleteRefactoring>> actions);
    public virtual string WillAlsoOverride();
    public virtual string WillAlsoImplement();
    public virtual string QuasiImplements();
    [CompilerGeneratedAttribute]
private void <Execute>g__CheckOverloads|3_0(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
private void <Execute>g__CheckOverload|3_1(IDeclaredElement conflictingDeclaredElement, <>c__DisplayClass3_0& );
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteTypeParameterData : SafeDeleteData {
    [CompilerGeneratedAttribute]
private SafeDeleteWorkflow <Workflow>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<ITypeParameter> <TypeParameterPointer>k__BackingField;
    [NotNullAttribute]
public SafeDeleteWorkflow Workflow { get; }
    [NotNullAttribute]
public IDeclaredElementPointer`1<ITypeParameter> TypeParameterPointer { get; }
    public bool IsValid { get; }
    public DeleteTypeParameterData(ITypeParameter overridableMember, SafeDeleteWorkflow workflow);
    [CompilerGeneratedAttribute]
public SafeDeleteWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<ITypeParameter> get_TypeParameterPointer();
    public virtual bool get_IsValid();
    public virtual IRefactoringPage GetOptionsPage(IProgressIndicator pi);
    public virtual RemovedElementsInfo Execute(IProgressIndicator pi, SafeDeleteRefactoring refactoring);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.DeleteTypeParameterExecuter : HierarchyConflictTextProviderBase {
    private DeleteTypeParameterData myData;
    private SafeDeleteRefactoring myRefactoring;
    public DeleteTypeParameterExecuter(DeleteTypeParameterData data, SafeDeleteRefactoring refactoring);
    [CanBeNullAttribute]
public RemovedElementsInfo Execute(IProgressIndicator pi);
    private static void Remove(SafeDeleteRefactoring refactoring, ITypeParameter parameter);
    public virtual string WillAlsoOverride();
    public virtual string WillAlsoImplement();
    public virtual string QuasiImplements();
}
public interface JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Impl.IDeleteHierarchyMemberData {
    [NotNullAttribute]
public SafeDeleteWorkflow Workflow { get; }
    public bool HasOverrides { get; }
    public bool HasBase { get; }
    public string PresentedMemberName { get; }
    public bool IsValid { get; }
    public abstract virtual SafeDeleteWorkflow get_Workflow();
    public abstract virtual bool get_HasOverrides();
    public abstract virtual bool get_HasBase();
    public abstract virtual string get_PresentedMemberName();
    public abstract virtual bool get_IsValid();
    public abstract virtual IRefactoringPage CommitHierarchyPage(ProcessHierarchyMemberTypes type, IProgressIndicator pi);
}
public interface JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.ISafeDeleteDataProvider {
    public bool AllHierarchy { get; }
    public UsagesProcessingTypes UsagesProcessingTypes { get; }
    public ProcessHierarchyMemberTypes ProcessHierarchyMemberType { get; }
    public abstract virtual bool get_AllHierarchy();
    public abstract virtual UsagesProcessingTypes get_UsagesProcessingTypes();
    public abstract virtual ProcessHierarchyMemberTypes get_ProcessHierarchyMemberType();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.AccessorUsagesRemover : ElementRemover {
    private IAccessor myAccessor;
    private IOverridableMember myOverridableMember;
    private bool myIsGetter;
    private bool myRemoveExplicitInterfaceQualification;
    public IDeclaredElement ElementToRemove { get; }
    public IDeclaredElement ElementToSearch { get; }
    public AccessorUsagesRemover(IAccessor element);
    public virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
    public virtual IDeclaredElement get_ElementToRemove();
    public virtual IDeclaredElement get_ElementToSearch();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.ArgumentRemover : ElementRemover {
    private IParameter myParameter;
    private IParametersOwner myOwner;
    [CompilerGeneratedAttribute]
private bool <IsExtensionFirstParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DeconstructComponentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParametersCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IReference, PerReferenceData> <Data>k__BackingField;
    public bool IsExtensionFirstParameter { get; }
    public string ParameterName { get; }
    public int DeconstructComponentIndex { get; }
    public int ParametersCount { get; }
    private Dictionary`2<IReference, PerReferenceData> Data { get; }
    public IDeclaredElement ElementToRemove { get; }
    public IDeclaredElement ElementToSearch { get; }
    public ArgumentRemover(int index, IParametersOwner parametersOwner);
    [CompilerGeneratedAttribute]
public bool get_IsExtensionFirstParameter();
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public int get_DeconstructComponentIndex();
    [CompilerGeneratedAttribute]
public int get_ParametersCount();
    [CompilerGeneratedAttribute]
private Dictionary`2<IReference, PerReferenceData> get_Data();
    public virtual IDeclaredElement get_ElementToRemove();
    public virtual IDeclaredElement get_ElementToSearch();
    public virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
    public virtual void InitReference(SafeDeleteRefactoring refactoring, IReference reference);
}
public abstract class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.ElementRemover : object {
    [CanBeNullAttribute]
public IDeclaredElement ElementToRemove { get; }
    [CanBeNullAttribute]
public IDeclaredElement ElementToSearch { get; }
    public abstract virtual IDeclaredElement get_ElementToRemove();
    public abstract virtual IDeclaredElement get_ElementToSearch();
    public abstract virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
    public virtual void InitReference(SafeDeleteRefactoring refactoring, IReference reference);
    public virtual IEnumerable`1<IDeclaration> GetDeclarationsToRemove();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.ParameterRemover : ElementRemover {
    [CompilerGeneratedAttribute]
private IParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanReplaceWithLocalVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplaceWithLocalVariable>k__BackingField;
    [NotNullAttribute]
public IParameter Parameter { get; }
    private bool CanReplaceWithLocalVariable { get; }
    public bool ReplaceWithLocalVariable { get; private set; }
    public IDeclaredElement ElementToRemove { get; }
    public IDeclaredElement ElementToSearch { get; }
    public ParameterRemover(IParameter parameter);
    [CompilerGeneratedAttribute]
public IParameter get_Parameter();
    [CompilerGeneratedAttribute]
private bool get_CanReplaceWithLocalVariable();
    [CompilerGeneratedAttribute]
public bool get_ReplaceWithLocalVariable();
    [CompilerGeneratedAttribute]
private void set_ReplaceWithLocalVariable(bool value);
    public virtual IDeclaredElement get_ElementToRemove();
    public virtual IDeclaredElement get_ElementToSearch();
    public virtual void InitReference(SafeDeleteRefactoring refactoring, IReference reference);
    public virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.ReplaceTypeElementRemover : ElementRemover {
    private ITypeElement myElement;
    private ITypeElement myInheritor;
    private ISubstitution mySubstitution;
    public IDeclaredElement ElementToRemove { get; }
    public IDeclaredElement ElementToSearch { get; }
    public ReplaceTypeElementRemover(ITypeElement element, ITypeElement inheritor, ISubstitution substitution);
    public virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
    public virtual IDeclaredElement get_ElementToRemove();
    public virtual IDeclaredElement get_ElementToSearch();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.SimpleRemover : ElementRemover {
    private IDeclaredElement myElement;
    private bool myReplaceCallsToBase;
    private bool mySearchUsages;
    public IDeclaredElement ElementToRemove { get; }
    public IDeclaredElement ElementToSearch { get; }
    public SimpleRemover(IDeclaredElement element, bool replaceCallsToBase, bool searchUsages);
    public virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
    public virtual IDeclaredElement get_ElementToRemove();
    public virtual IDeclaredElement get_ElementToSearch();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.SimpleRemoverUsagesOnly : ElementRemover {
    private IDeclaredElement myElement;
    private bool myRemoveCallToBase;
    public IDeclaredElement ElementToRemove { get; }
    public IDeclaredElement ElementToSearch { get; }
    public SimpleRemoverUsagesOnly(IDeclaredElement element, bool removeCallToBase);
    public virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
    public virtual IDeclaredElement get_ElementToRemove();
    public virtual IDeclaredElement get_ElementToSearch();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.TypeArgumentRemover : ElementRemover {
    private ITypeParametersOwner myOwner;
    private ITypeParameter myTypeParameter;
    private IDeclaredElementPointer`1<ITypeParametersOwner> myElementToBindPointer;
    private Dictionary`2<IReference, List`1<Pair`2<IDeclaredElementPointer`1<ITypeParameter>, ITypePointer>>> mySubsImages;
    public IDeclaredElement ElementToRemove { get; }
    public IDeclaredElement ElementToSearch { get; }
    public TypeArgumentRemover(ITypeParametersOwner owner, ITypeParameter removedTypeParameter);
    public virtual IDeclaredElement get_ElementToRemove();
    public virtual IDeclaredElement get_ElementToSearch();
    public virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
    public virtual void InitReference(SafeDeleteRefactoring refactoring, IReference reference);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.Removers.TypeParameterUsagesRemover : ElementRemover {
    private ITypeParameter myTypeParameter;
    public IDeclaredElement ElementToRemove { get; }
    public IDeclaredElement ElementToSearch { get; }
    public TypeParameterUsagesRemover(ITypeParameter typeParameter);
    public virtual IDeclaredElement get_ElementToRemove();
    public virtual IDeclaredElement get_ElementToSearch();
    public virtual bool RemoveReference(IReference reference, SafeDeleteRefactoring refactoring);
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "SafeDeleteActionText")]
[VsOverrideActionAttribute("({1496A755-94DE-11D0-8C3F-00C04FC2AAE2}:1555)")]
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeleteAction : ExtensibleRefactoringAction`1<SafeDeleteWorkflowProvider> {
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
    public sealed virtual bool ShouldFallBack(IDataContext context);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeleteBase : RefactoringExecBase`2<SafeDeleteWorkflow, SafeDeleteRefactoring> {
    public SafeDeleteBase(SafeDeleteWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void RemoveDeclaration(IDeclaration declaration);
    public virtual void RemoveTypeParameterDeclaration(IDeclaration declaration);
    public virtual void MakeVirtual(IDeclaration declaration, bool sealedType);
    public virtual void SetBaseTypes(IDeclaration declaration, IDeclaredType baseClass, IList`1<IDeclaredType> param, ITypeElement baseElementToRemove);
    public virtual bool IsReferenceOnConstructor(IReference reference);
    public virtual bool RemoveCallToBaseMethod(IReference reference);
    public virtual bool ReplaceExplicitImplementation(IReference reference);
    public virtual void ReplaceExplicitImplementation(IDeclaration declaration);
    [PureAttribute]
public virtual bool CanRemoveExpression(IExpression expression);
    public virtual bool RemoveExpression(IExpression expression);
    public virtual void ReplaceParameterWithLocalVariable(IDeclaration declaration);
    public virtual void RemoveArgument(IReference reference, ArgumentRemover remover, PerReferenceData data);
    public virtual bool IsPartial(IMethod method);
    public virtual void TryRemoveNullChecking(IDeclaration declaration);
    public virtual bool RemoveSubscription(IReference reference);
    public virtual bool IsSingleAndCallsToBase(IConstructor constructor);
    public virtual void SaveUnusedUsings(IFile file);
    public virtual void RemoveNewRedundantUsings(IFile file, HashSet`1<ITreeNode> oldUsings, IProgressIndicator progress);
    [NotNullAttribute]
public virtual IList`1<IArgument> GetArgumentsToRemove(IReference reference, IParametersOwner owner, IParameter parameter);
    public virtual bool IsExtensionCall(IReference reference);
    public virtual bool IsMethodGroup(IReference reference);
    public virtual bool WillExistsAfterLastParameterRemoval(IParametersOwner parametersOwner);
    public virtual bool RemoveInterfaceMemberSpecification(IReference expression, bool remove);
    public virtual void RemoveImplicitAccessor(IAccessor accessor);
    [NotNullAttribute]
public virtual IList`1<ElementRemover> GetExtraElementsFromDeclaration(IDeclaration declaration);
    public virtual bool RemoveInvocationStatement(IReference reference);
    public virtual bool RemoveReference(IReference reference);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeleteBasicProvider : SafeDeleteWorkflowProvider {
    public virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeleteDataProvider : object {
    [CompilerGeneratedAttribute]
private ProcessHierarchyMemberTypes <ProcessHierarchyMemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllHierarchy>k__BackingField;
    [CompilerGeneratedAttribute]
private UsagesProcessingTypes <UsagesProcessingTypes>k__BackingField;
    public ProcessHierarchyMemberTypes ProcessHierarchyMemberType { get; }
    public bool AllHierarchy { get; }
    public UsagesProcessingTypes UsagesProcessingTypes { get; }
    public SafeDeleteDataProvider(ProcessHierarchyMemberTypes processHierarchyMemberType, bool allHierarchy, UsagesProcessingTypes usagesProcessingTypes);
    public SafeDeleteDataProvider(string classes, string replace, string overrides);
    [CompilerGeneratedAttribute]
public sealed virtual ProcessHierarchyMemberTypes get_ProcessHierarchyMemberType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllHierarchy();
    [CompilerGeneratedAttribute]
public sealed virtual UsagesProcessingTypes get_UsagesProcessingTypes();
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeleteHelperUnsupported : object {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual SafeDeleteData CreateData(IDeclaredElement declaredElement, SafeDeleteWorkflow workflow);
    public virtual bool CanBeRemoved(IDeclaredElement element);
    [CanBeNullAttribute]
public virtual IList`1<IDeclaration> GetDeclarationsToCheckAvailability(IDeclaredElement element);
    public virtual bool CanBeRemoved(IDeclaration declaration);
    public virtual bool IsBaseClassSpecifier(IReference reference);
    public virtual bool IsInterfaceImplementationSpecifier(IReference reference);
    [NotNullAttribute]
public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void RemoveUsing(ITreeNode element);
    [NotNullAttribute]
public virtual IDeclaredElement GetActualElementToRemove(IDeclaredElement declaredElement);
    public virtual bool IsRemovableImplicitElement(IDeclaredElement declaredElement);
    [NotNullAttribute]
public virtual IEnumerable`1<IDeclaredElement> GetDependentElementToRemove(IDeclaredElement declaredElement, IProgressIndicator pi);
    [PureAttribute]
public virtual bool IsTypeDefinitelyNotAloneInFile(ITypeElement typeElement);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeletePage2TypeElementPage : SingleBeRefactoringPage {
    private DeleteClassData myData;
    private IProperty`1<bool> myDeleteInheritors;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Description { get; protected set; }
    public string Title { get; protected set; }
    public bool DoNotShow { get; }
    public SafeDeletePage2TypeElementPage(DeleteClassData data, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    public virtual bool get_DoNotShow();
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    public virtual bool RefreshContents(IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeletePageOverridableMemberPage : SingleBeRefactoringPage {
    private IDeleteHierarchyMemberData myData;
    private IProperty`1<ProcessHierarchyMemberTypes> myDeleteInheritors;
    public string Description { get; }
    public string Title { get; }
    public bool DoNotShow { get; }
    public SafeDeletePageOverridableMemberPage(IDeleteHierarchyMemberData data);
    public virtual string get_Description();
    public virtual string get_Title();
    public virtual bool get_DoNotShow();
    public virtual BeControl GetPageContent();
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__9_1(ProcessHierarchyMemberTypes types);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeletePageReplaceTypeUsagesPage : SingleBeRefactoringPage {
    private DeleteClassData myData;
    private IProperty`1<UsagesProcessingTypes> myDeleteInheritors;
    public string Description { get; }
    public string Title { get; }
    public bool DoNotShow { get; }
    public SafeDeletePageReplaceTypeUsagesPage(DeleteClassData data);
    public virtual string get_Description();
    public virtual string get_Title();
    public virtual bool get_DoNotShow();
    public virtual BeControl GetPageContent();
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
    [CompilerGeneratedAttribute]
private string <GetPageContent>b__9_0(UsagesProcessingTypes types, RadioButtonProperties properties);
    [CompilerGeneratedAttribute]
private bool <GetPageContent>b__9_1(UsagesProcessingTypes types);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeletePageStartPage : SingleBeRefactoringPage {
    private SafeDeleteWorkflow myWorkflow;
    private IRefactoringPage myNextPage;
    public string Title { get; }
    public bool DoNotShow { get; }
    public SafeDeletePageStartPage(SafeDeleteWorkflow workflow);
    public virtual string get_Title();
    public virtual bool get_DoNotShow();
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    public virtual BeControl GetPageContent();
    public virtual bool Initialize(IProgressIndicator pi);
    public virtual bool RefreshContents(IProgressIndicator progressIndicator);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeleteRefactoring : DrivenRefactoring`2<SafeDeleteWorkflow, SafeDeleteBase> {
    [CanBeNullAttribute]
private IReference myReference;
    [CompilerGeneratedAttribute]
private UnusedUsingSaver <UsingsSaver>k__BackingField;
    public UnusedUsingSaver UsingsSaver { get; private set; }
    public SafeDeleteRefactoring(SafeDeleteWorkflow workFlow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public UnusedUsingSaver get_UsingsSaver();
    [CompilerGeneratedAttribute]
private void set_UsingsSaver(UnusedUsingSaver value);
    public virtual bool Execute(IProgressIndicator pi);
    protected virtual SafeDeleteBase CreateUnsupportedRefactoring();
    protected virtual SafeDeleteBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    [CompilerGeneratedAttribute]
private void <Execute>b__6_4(IFile file, HashSet`1<ITreeNode> elements, IProgressIndicator indicator);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeleteRemoveFilesConfirmationPage : SingleBeRefactoringPage {
    private static string RemoveFileId;
    private SafeDeleteWorkflow myWorkflow;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; protected set; }
    public SafeDeleteRemoveFilesConfirmationPage(SafeDeleteWorkflow workflow);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    public virtual BeControl GetPageContent();
    public virtual bool RefreshContents(IProgressIndicator pi);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__7_0(Nullable`1<bool> v);
}
public class JetBrains.ReSharper.Refactorings.SafeDeleteTheSecond.SafeDeleteWorkflow : DrivenRefactoringWorkflow2`1<SafeDeleteHelperUnsupported> {
    [NotNullAttribute]
private List`1<IProjectFile> myFilesToRemove;
    [CompilerGeneratedAttribute]
private bool <RemoveFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReferencePointer <ReferencePointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ISafeDeleteDataProvider <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeDeleteData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SafeDeleteData> <AdditionalData>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<IDeclaredElement> <ElementPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PresentedElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    public bool RemoveFiles { get; public set; }
    [CanBeNullAttribute]
public IReferencePointer ReferencePointer { get; private set; }
    [CanBeNullAttribute]
public ISafeDeleteDataProvider DataProvider { get; private set; }
    [CanBeNullAttribute]
public SafeDeleteData Data { get; private set; }
    [CanBeNullAttribute]
public IReadOnlyList`1<SafeDeleteData> AdditionalData { get; private set; }
    public IDeclaredElementPointer`1<IDeclaredElement> ElementPointer { get; private set; }
    public string PresentedElementName { get; private set; }
    public PsiLanguageType LanguageType { get; private set; }
    public RefactoringActionGroup ActionGroup { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public bool IsValid { get; }
    public HelpId HelpKeyword { get; }
    public SafeDeleteWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public bool get_RemoveFiles();
    [CompilerGeneratedAttribute]
public void set_RemoveFiles(bool value);
    [CompilerGeneratedAttribute]
public IReferencePointer get_ReferencePointer();
    [CompilerGeneratedAttribute]
private void set_ReferencePointer(IReferencePointer value);
    [CompilerGeneratedAttribute]
public ISafeDeleteDataProvider get_DataProvider();
    [CompilerGeneratedAttribute]
private void set_DataProvider(ISafeDeleteDataProvider value);
    [CompilerGeneratedAttribute]
public SafeDeleteData get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(SafeDeleteData value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SafeDeleteData> get_AdditionalData();
    [CompilerGeneratedAttribute]
private void set_AdditionalData(IReadOnlyList`1<SafeDeleteData> value);
    [CompilerGeneratedAttribute]
public IDeclaredElementPointer`1<IDeclaredElement> get_ElementPointer();
    [CompilerGeneratedAttribute]
private void set_ElementPointer(IDeclaredElementPointer`1<IDeclaredElement> value);
    [CompilerGeneratedAttribute]
public string get_PresentedElementName();
    [CompilerGeneratedAttribute]
private void set_PresentedElementName(string value);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
private void set_LanguageType(PsiLanguageType value);
    public virtual RefactoringActionGroup get_ActionGroup();
    [CanBeNullAttribute]
private IDeclaredElement IsAvailableInternal(IDataContext context);
    private void InitInternal(IDeclaredElement element);
    public virtual bool Initialize(IDataContext context);
    public virtual bool IsAvailable(IDataContext context);
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public bool get_IsValid();
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    protected virtual SafeDeleteHelperUnsupported CreateUnsupportedHelper();
    protected virtual SafeDeleteHelperUnsupported CreateHelper(IRefactoringLanguageService service);
    public virtual HelpId get_HelpKeyword();
    public void AddProjectFileToRemove(IProjectFile file);
    public void SetDataProvider(ISafeDeleteDataProvider provider);
    public IRefactoringPage GetFirstPageOrNull(IProgressIndicator pi);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual void SuccessfulFinish(IProgressIndicator pi);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.SmartDeclarationPointer : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static SmartDeclarationPointer`1<TDeclaration> CreateSmartPointer(TDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.SmartDeclarationPointer`1 : object {
    private Type myDeclarationType;
    private ITreeNodePointer`1<TDeclaration> myTreeNodePointer;
    private IRangeMarker myNameMarker;
    public SmartDeclarationPointer`1(TDeclaration declaration);
    private void InitTreeElementPointer(TDeclaration declaration);
    private void InitNameMarker(TDeclaration declaration);
    [CanBeNullAttribute]
public TDeclaration GetDeclaration();
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.ConstructorInfo : DeclaredElementNode {
    public ConstructorInfo(IConstructor element);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.Entities.ClassEntity : object {
    private IPsiModule myModule;
    private IPsiServices myPsiServices;
    private IType myNewType;
    private string myParameterName;
    [CompilerGeneratedAttribute]
private ITypeElement <NewClass>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<TypeParameter, IDeclaration> <CreatedTypeParameters>k__BackingField;
    public ITypeElement NewClass { get; public set; }
    public Dictionary`2<TypeParameter, IDeclaration> CreatedTypeParameters { get; public set; }
    public bool IsWritable { get; }
    public ClassEntity(IParametersOwner parametersOwner);
    [CompilerGeneratedAttribute]
public ITypeElement get_NewClass();
    [CompilerGeneratedAttribute]
public void set_NewClass(ITypeElement value);
    [CompilerGeneratedAttribute]
public void set_CreatedTypeParameters(Dictionary`2<TypeParameter, IDeclaration> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<TypeParameter, IDeclaration> get_CreatedTypeParameters();
    public sealed virtual string GetVarName(ITreeNode treeNode);
    public sealed virtual string GetParameterName(IDeclaration parametersOwnerDeclaration);
    public sealed virtual IType GetDelegateType(IType oldType);
    public sealed virtual bool get_IsWritable();
    public sealed virtual string GetTupleEntityName();
    public sealed virtual IType GetNewType(IParametersOwner parametersOwner, ITransformTypeInfo typeInfo, bool outIsIn);
    public sealed virtual IType GetNewType(ISubstitution substitution);
    public void AddMembers(IEnumerable`1<IParametersOwner> dataModelRootOverrides, Func`2<PsiLanguageType, ConstructionUtil> constructionUtil, IEnumerable`1<ITransformParameterInfo> parametersToUseInDeclaration, bool outIsIn, bool hasProperties);
    public void AddMembers(IParametersOwner owner, ConstructionUtil constructionUtil, IEnumerable`1<ITransformParameterInfo> parametersToUseInDeclaration, bool outIsIn, bool hasProperties);
    private static NameRoot GetName(NamingManager naming, IPsiSourceFile sourceFile, NamedElementKinds typeOfParameter, string name);
    public void AddGenericParameters(Func`2<PsiLanguageType, ConstructionUtil> util, IDeclaredElement owner, SignatureGenerifier generifier);
    [CompilerGeneratedAttribute]
private ITypeParameter <AddMembers>b__22_0(TypeParameter typeParam);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.Entities.ExistingClassEntity : object {
    private ITypeElement myExistingType;
    [CompilerGeneratedAttribute]
private bool <IsWritable>k__BackingField;
    public bool IsWritable { get; private set; }
    public ExistingClassEntity(ITypeElement existingType, ITransformTypeInfo typeInfo);
    public sealed virtual IType GetNewType(IParametersOwner parametersOwner, ITransformTypeInfo typeInfo, bool outIsIn);
    public sealed virtual IType GetNewType(ISubstitution substitution);
    public sealed virtual string GetVarName(ITreeNode treeNode);
    public sealed virtual string GetParameterName(IDeclaration treeNode);
    public sealed virtual IType GetDelegateType(IType oldType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsWritable();
    [CompilerGeneratedAttribute]
private void set_IsWritable(bool value);
    public sealed virtual string GetTupleEntityName();
}
public interface JetBrains.ReSharper.Refactorings.TransformParameters.Entities.ITransformTypeInfo {
    public ITypeEntity TypeEntity { get; public set; }
    public List`1<ITransformParameterInfo> SelectedParameters { get; }
    public string TargetClassName { get; public set; }
    public bool ReturnTypeIsSimpleType { get; public set; }
    public abstract virtual ITypeEntity get_TypeEntity();
    public abstract virtual void set_TypeEntity(ITypeEntity value);
    public abstract virtual List`1<ITransformParameterInfo> get_SelectedParameters();
    public abstract virtual string get_TargetClassName();
    public abstract virtual void set_TargetClassName(string value);
    public abstract virtual void set_ReturnTypeIsSimpleType(bool value);
    public abstract virtual bool get_ReturnTypeIsSimpleType();
}
public interface JetBrains.ReSharper.Refactorings.TransformParameters.Entities.ITypeEntity {
    public bool IsWritable { get; }
    [NotNullAttribute]
public abstract virtual IType GetNewType(IParametersOwner parametersOwner, ITransformTypeInfo typeInfo, bool outIsIn);
    [CanBeNullAttribute]
public abstract virtual IType GetNewType(ISubstitution substitution);
    [NotNullAttribute]
public abstract virtual string GetVarName(ITreeNode treeNode);
    [CanBeNullAttribute]
public abstract virtual string GetParameterName(IDeclaration parametersOwnerDeclaration);
    public abstract virtual IType GetDelegateType(IType oldType);
    public abstract virtual bool get_IsWritable();
    public abstract virtual string GetTupleEntityName();
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.Entities.OutTypeInfo : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TransformParameterInfo> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnTypeEnum <OutEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeEntity <TypeEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppendToTuple>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnTypeParameterInfo <ReturnParameterInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCreatedClassAsReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnTypeIsSimpleType>k__BackingField;
    public IEnumerable`1<TransformParameterInfo> Parameters { get; }
    public ReturnTypeEnum OutEntityType { get; }
    public ITypeEntity TypeEntity { get; public set; }
    public bool AppendToTuple { get; public set; }
    public List`1<ITransformParameterInfo> SelectedParameters { get; }
    [CanBeNullAttribute]
public ReturnTypeParameterInfo ReturnParameterInfo { get; }
    public string TargetClassName { get; public set; }
    public bool UseCreatedClassAsReturnValue { get; public set; }
    public bool ReturnTypeIsSimpleType { get; public set; }
    public bool HasOut { get; }
    public OutTypeInfo(IList`1<ITransformParameterInfo> allParametersInfo, string name, ReturnTypeEnum outEntityType, bool useClass, bool append);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TransformParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
public ReturnTypeEnum get_OutEntityType();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeEntity get_TypeEntity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TypeEntity(ITypeEntity value);
    [CompilerGeneratedAttribute]
public bool get_AppendToTuple();
    [CompilerGeneratedAttribute]
public void set_AppendToTuple(bool value);
    public sealed virtual List`1<ITransformParameterInfo> get_SelectedParameters();
    [CompilerGeneratedAttribute]
public ReturnTypeParameterInfo get_ReturnParameterInfo();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetClassName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetClassName(string value);
    [CompilerGeneratedAttribute]
public bool get_UseCreatedClassAsReturnValue();
    [CompilerGeneratedAttribute]
public void set_UseCreatedClassAsReturnValue(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnTypeIsSimpleType(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReturnTypeIsSimpleType();
    public bool get_HasOut();
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.Entities.TupleEntity : object {
    public static int MaxSupportedTupleArity;
    private IPsiModule myModule;
    private IPsiServices myPsiServices;
    private IType myNewType;
    private string myParameterName;
    [CompilerGeneratedAttribute]
private ITypeElement[] <TupleGenericType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public ITypeElement[] TupleGenericType { get; public set; }
    public bool IsWritable { get; }
    public string Error { get; }
    public TupleEntity(IParametersOwner parametersOwner, ITransformTypeInfo transformInfo);
    [CompilerGeneratedAttribute]
public ITypeElement[] get_TupleGenericType();
    [CompilerGeneratedAttribute]
public void set_TupleGenericType(ITypeElement[] value);
    public sealed virtual IType GetNewType(ISubstitution substitution);
    public sealed virtual IType GetNewType(IParametersOwner parametersOwner, ITransformTypeInfo typeInfo, bool outIsIn);
    public sealed virtual string GetVarName(ITreeNode treeNode);
    public sealed virtual string GetParameterName(IDeclaration parametersOwnerDeclaration);
    public sealed virtual IType GetDelegateType(IType oldType);
    public sealed virtual bool get_IsWritable();
    [CompilerGeneratedAttribute]
public string get_Error();
    public sealed virtual string GetTupleEntityName();
    [CanBeNullAttribute]
public IType CreateTupleReturnType(String& errmsg, ITransformTypeInfo typeInfo, IParametersOwner parametersOwner);
}
internal class JetBrains.ReSharper.Refactorings.TransformParameters.Entities.ValueTupleEntity : object {
    [CompilerGeneratedAttribute]
private bool <IsWritable>k__BackingField;
    public bool IsWritable { get; private set; }
    public sealed virtual IType GetNewType(IParametersOwner parametersOwner, ITransformTypeInfo typeInfo, bool outIsIn);
    public sealed virtual IType GetNewType(ISubstitution substitution);
    public sealed virtual string GetVarName(ITreeNode declaration);
    public sealed virtual string GetParameterName(IDeclaration parametersOwnerDeclaration);
    public sealed virtual IType GetDelegateType(IType oldType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsWritable();
    [CompilerGeneratedAttribute]
private void set_IsWritable(bool value);
    public sealed virtual string GetTupleEntityName();
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.Entities.WrappedInTupleEntity : object {
    public static int MaxSupportedTupleArity;
    private IPsiModule myModule;
    private IPsiServices myPsiServices;
    private IType myNewType;
    private string myParameterName;
    private string myTupleEntityName;
    [CompilerGeneratedAttribute]
private ITypeElement[] <TupleGenericType>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<TypeParameter, IDeclaration> <CreatedTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeEntity <InitialEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWritable>k__BackingField;
    public ITypeElement[] TupleGenericType { get; public set; }
    public Dictionary`2<TypeParameter, IDeclaration> CreatedTypeParameters { get; public set; }
    public ITypeEntity InitialEntity { get; public set; }
    public bool IsWritable { get; private set; }
    public WrappedInTupleEntity(ITypeEntity typeEntity, IParametersOwner parametersOwner, ITransformTypeInfo transformInfo);
    [CompilerGeneratedAttribute]
public ITypeElement[] get_TupleGenericType();
    [CompilerGeneratedAttribute]
public void set_TupleGenericType(ITypeElement[] value);
    [CompilerGeneratedAttribute]
public void set_CreatedTypeParameters(Dictionary`2<TypeParameter, IDeclaration> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<TypeParameter, IDeclaration> get_CreatedTypeParameters();
    [CompilerGeneratedAttribute]
public ITypeEntity get_InitialEntity();
    [CompilerGeneratedAttribute]
public void set_InitialEntity(ITypeEntity value);
    public sealed virtual string GetVarName(ITreeNode declaration);
    public sealed virtual string GetParameterName(IDeclaration parametersOwnerDeclaration);
    public sealed virtual IType GetDelegateType(IType oldType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsWritable();
    [CompilerGeneratedAttribute]
private void set_IsWritable(bool value);
    public sealed virtual string GetTupleEntityName();
    public sealed virtual IType GetNewType(IParametersOwner parametersOwner, ITransformTypeInfo typeInfo, bool outIsIn);
    private IDeclaredType NewType(IParametersOwner parametersOwner, ITransformTypeInfo typeInfo, bool outIsIn);
    public sealed virtual IType GetNewType(ISubstitution substitution);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.ExistingTypeMappingInfo : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyValue>k__BackingField;
    public List`1<string> Properties { get; public set; }
    public string PropertyValue { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_PropertyValue();
    [CompilerGeneratedAttribute]
public void set_PropertyValue(string value);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.ExistingTypeViewModel : object {
    [CompilerGeneratedAttribute]
private ITypeElement <ExistingTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ConstructorValue>k__BackingField;
    public ITypeElement ExistingTypeElement { get; }
    public IList`1<ConstructorInfo> Constructors { get; }
    public ConstructorInfo ConstructorValue { get; public set; }
    public ExistingTypeViewModel(ITypeElement element);
    [CompilerGeneratedAttribute]
public ITypeElement get_ExistingTypeElement();
    public IList`1<ConstructorInfo> get_Constructors();
    [CompilerGeneratedAttribute]
public ConstructorInfo get_ConstructorValue();
    [CompilerGeneratedAttribute]
public void set_ConstructorValue(ConstructorInfo value);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.InTypeInfo : object {
    [CompilerGeneratedAttribute]
private List`1<TransformParameterInfo> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnTypeEnum <InEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnTypeIsSimpleType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeEntity <TypeEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IDeclaration, string> <NewParameterNames>k__BackingField;
    public List`1<TransformParameterInfo> Parameters { get; }
    public ReturnTypeEnum InEntityType { get; }
    public string TargetClassName { get; public set; }
    public bool ReturnTypeIsSimpleType { get; public set; }
    public ITypeEntity TypeEntity { get; public set; }
    public Dictionary`2<IDeclaration, string> NewParameterNames { get; public set; }
    public List`1<ITransformParameterInfo> SelectedParameters { get; }
    public bool HasIn { get; }
    public InTypeInfo(IEnumerable`1<ITransformParameterInfo> allParameterInfos, string className, ReturnTypeEnum inEntityType);
    [CompilerGeneratedAttribute]
public List`1<TransformParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
public ReturnTypeEnum get_InEntityType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetClassName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetClassName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReturnTypeIsSimpleType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnTypeIsSimpleType(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeEntity get_TypeEntity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TypeEntity(ITypeEntity value);
    [CompilerGeneratedAttribute]
public void set_NewParameterNames(Dictionary`2<IDeclaration, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IDeclaration, string> get_NewParameterNames();
    public sealed virtual List`1<ITransformParameterInfo> get_SelectedParameters();
    public bool get_HasIn();
}
public interface JetBrains.ReSharper.Refactorings.TransformParameters.ITransformParameterInfo {
    public bool IsOut { get; }
    public IType Type { get; }
    public int Index { get; }
    public IType CreatedType { get; public set; }
    public TypeBuilder Builder { get; public set; }
    public IDeclaredElement CreatedElement { get; }
    public IField CreatedField { get; public set; }
    public bool IsPropertyWritable { get; public set; }
    public string EntityName { get; public set; }
    public bool IsRef { get; }
    public ExistingTypeMappingInfo MappingToExisting { get; }
    public bool IsOptional { get; }
    public bool Included { get; public set; }
    public abstract virtual bool get_IsOut();
    public abstract virtual IType get_Type();
    public abstract virtual int get_Index();
    public abstract virtual IType get_CreatedType();
    public abstract virtual void set_CreatedType(IType value);
    public abstract virtual void set_Builder(TypeBuilder value);
    public abstract virtual TypeBuilder get_Builder();
    public abstract virtual IDeclaredElement get_CreatedElement();
    public abstract virtual void set_CreatedField(IField value);
    public abstract virtual IField get_CreatedField();
    public abstract virtual bool get_IsPropertyWritable();
    public abstract virtual void set_IsPropertyWritable(bool value);
    public abstract virtual string get_EntityName();
    public abstract virtual void set_EntityName(string value);
    public abstract virtual bool get_IsRef();
    public abstract virtual ExistingTypeMappingInfo get_MappingToExisting();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_Included();
    public abstract virtual void set_Included(bool value);
}
public interface JetBrains.ReSharper.Refactorings.TransformParameters.ITransformParametersWorkflowProvider {
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.ParameterInfoComparer : object {
    public sealed virtual int Compare(DeclaredElementNode x, DeclaredElementNode y);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.PreProcessedCall : object {
    [CompilerGeneratedAttribute]
private IDeclaration <ParametersOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<int> <ArgumentsToRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<int> <ArgumentsToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private IReference <Reference>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexOfExtensionArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexOfParamsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRecursiveCall>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    public IDeclaration ParametersOwner { get; }
    public JetHashSet`1<int> ArgumentsToRemove { get; }
    public JetHashSet`1<int> ArgumentsToAdd { get; }
    public IReference Reference { get; }
    public int IndexOfExtensionArgument { get; public set; }
    public int IndexOfParamsArray { get; public set; }
    public bool IsRecursiveCall { get; public set; }
    public ISubstitution Substitution { get; public set; }
    public PreProcessedCall(IReference reference, IDeclaration parametersOwner);
    [CompilerGeneratedAttribute]
public IDeclaration get_ParametersOwner();
    [CompilerGeneratedAttribute]
public JetHashSet`1<int> get_ArgumentsToRemove();
    [CompilerGeneratedAttribute]
public JetHashSet`1<int> get_ArgumentsToAdd();
    [CompilerGeneratedAttribute]
public IReference get_Reference();
    [CompilerGeneratedAttribute]
public int get_IndexOfExtensionArgument();
    [CompilerGeneratedAttribute]
public void set_IndexOfExtensionArgument(int value);
    [CompilerGeneratedAttribute]
public int get_IndexOfParamsArray();
    [CompilerGeneratedAttribute]
public void set_IndexOfParamsArray(int value);
    [CompilerGeneratedAttribute]
public bool get_IsRecursiveCall();
    [CompilerGeneratedAttribute]
public void set_IsRecursiveCall(bool value);
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    [CompilerGeneratedAttribute]
public void set_Substitution(ISubstitution value);
}
public enum JetBrains.ReSharper.Refactorings.TransformParameters.ReturnTypeEnum : Enum {
    public int value__;
    [LocalizedDescriptionAttribute(" ")]
public static ReturnTypeEnum CAN_NOT_BE_CHANGED;
    [LocalizedDescriptionAttribute("None")]
public static ReturnTypeEnum NONE;
    [LocalizedDescriptionAttribute("Tuple")]
public static ReturnTypeEnum TUPLE;
    [LocalizedDescriptionAttribute("Split ref parameter to in and out")]
public static ReturnTypeEnum SINGLE_IN_VALUE;
    [LocalizedDescriptionAttribute("Use out parameter as return value")]
public static ReturnTypeEnum SINGLE_OUT_VALUE;
    [LocalizedDescriptionAttribute("New class with auto-properties ")]
public static ReturnTypeEnum CLASS_PROPERTIES;
    [LocalizedDescriptionAttribute("New class with public fields")]
public static ReturnTypeEnum CLASS_FIELDS;
    [LocalizedDescriptionAttribute("Existing class")]
public static ReturnTypeEnum EXISTING_CLASS;
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.ReturnTypeParameterInfo : DeclaredElementNode {
    [CompilerGeneratedAttribute]
private bool <IsPropertyWritable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <CreatedType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <CreatedElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IField <CreatedField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExistingTypeMappingInfo <MappingToExisting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public bool IsPropertyWritable { get; public set; }
    public bool IsOut { get; }
    public bool IsProperty { get; public set; }
    public IType Type { get; }
    public int Index { get; }
    public IType CreatedType { get; public set; }
    public TypeBuilder Builder { get; public set; }
    public IDeclaredElement CreatedElement { get; public set; }
    public IField CreatedField { get; public set; }
    public string EntityName { get; public set; }
    public bool IsRef { get; }
    public ExistingTypeMappingInfo MappingToExisting { get; }
    public bool IsOptional { get; }
    public ReturnTypeParameterInfo(IParametersOwner owner);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPropertyWritable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsPropertyWritable(bool value);
    public sealed virtual bool get_IsOut();
    [CompilerGeneratedAttribute]
public bool get_IsProperty();
    [CompilerGeneratedAttribute]
public void set_IsProperty(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_CreatedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CreatedType(IType value);
    [CompilerGeneratedAttribute]
public sealed virtual TypeBuilder get_Builder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Builder(TypeBuilder value);
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredElement get_CreatedElement();
    [CompilerGeneratedAttribute]
public void set_CreatedElement(IDeclaredElement value);
    [CompilerGeneratedAttribute]
public sealed virtual IField get_CreatedField();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CreatedField(IField value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EntityName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EntityName(string value);
    public sealed virtual bool get_IsRef();
    [CompilerGeneratedAttribute]
public sealed virtual ExistingTypeMappingInfo get_MappingToExisting();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOptional();
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.SignatureGenerifier : object {
    private Dictionary`2<ITypeParameter, TypeParameter> myParamsIndex;
    public Dictionary`2<ITypeParameter, TypeParameter> ParamsIndex { get; }
    public Dictionary`2<ITypeParameter, TypeParameter> get_ParamsIndex();
    public bool CheckTypesIdentity(IEnumerable`1<IType> types, TypeBuilder& builder);
    private bool CheckPointerTypes(IEnumerable`1<IType> types, TypeBuilder& builder);
    private bool CheckDeclaredTypes(IEnumerable`1<IType> types, TypeBuilder& builder);
    private bool CheckArrayTypes(IEnumerable`1<IType> types, TypeBuilder& builder);
    private static bool CheckGenerics(IType type);
    private static bool CheckIfPureGenericPresented(IEnumerable`1<IType> types);
    private bool TryAddTypeParameter(IType type, TypeParameter& createdParameter);
    public static ISubstitution BuildSubstitution(IType mostGenericType, IType specializedType);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParameterInfo : ParameterElement {
    [CompilerGeneratedAttribute]
private bool <IsOut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRef>k__BackingField;
    [CompilerGeneratedAttribute]
private ExistingTypeMappingInfo <MappingToExisting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <CreatedType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPropertyWritable>k__BackingField;
    [CompilerGeneratedAttribute]
private IField <CreatedField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    public bool IsOut { get; }
    public bool IsRef { get; }
    public ExistingTypeMappingInfo MappingToExisting { get; }
    public bool IsOptional { get; }
    public bool IsProperty { get; public set; }
    public IType CreatedType { get; public set; }
    public TypeBuilder Builder { get; public set; }
    public IDeclaredElement CreatedElement { get; }
    public bool IsPropertyWritable { get; public set; }
    public IField CreatedField { get; public set; }
    public string EntityName { get; public set; }
    public TransformParameterInfo(IParameter parameter);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOut();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRef();
    [CompilerGeneratedAttribute]
public sealed virtual ExistingTypeMappingInfo get_MappingToExisting();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOptional();
    [CompilerGeneratedAttribute]
public bool get_IsProperty();
    [CompilerGeneratedAttribute]
public void set_IsProperty(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_CreatedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CreatedType(IType value);
    [CompilerGeneratedAttribute]
public sealed virtual TypeBuilder get_Builder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Builder(TypeBuilder value);
    public sealed virtual IDeclaredElement get_CreatedElement();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPropertyWritable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsPropertyWritable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IField get_CreatedField();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CreatedField(IField value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EntityName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EntityName(string value);
    private sealed virtual override IType JetBrains.ReSharper.Refactorings.TransformParameters.ITransformParameterInfo.get_Type();
    private sealed virtual override int JetBrains.ReSharper.Refactorings.TransformParameters.ITransformParameterInfo.get_Index();
}
[ActionAttribute("JetBrains.ReSharper.Refactorings.Resources.Strings", "TransformParametersActionText")]
public class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParametersAction : ExtensibleRefactoringAction`1<ITransformParametersWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public abstract class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParametersBase : RefactoringExecBase`2<TransformParametersWorkflow, TransformParametersRefactoring> {
    protected TransformParametersBase(TransformParametersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual bool IsPureRecursiveCall(IReference reference);
    public abstract virtual PreProcessedCall PreProcessCall(IReference reference);
    public abstract virtual void FixUsage(PreProcessedCall call, string name);
    public abstract virtual void TransformDeclaration(IParametersOwner method, IRefactoringDriver driver, ISubstitution substsOfOverrides);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParametersDataModel : object {
    [CompilerGeneratedAttribute]
private bool <HasIn>k__BackingField;
    [CompilerGeneratedAttribute]
private InTypeInfo <InInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private OutTypeInfo <OutInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <OldType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OldTupleArity>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureGenerifier <Generifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IParametersOwner> <AllOverrides>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IParametersOwner> <RootOverrides>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PreProcessedCall> <PreProcessedCalls>k__BackingField;
    [CompilerGeneratedAttribute]
private IParametersOwner <ParametersOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewParameterPlace>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITransformParameterInfo> <SelectedParameterInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOut>k__BackingField;
    public bool HasIn { get; }
    public InTypeInfo InInfo { get; public set; }
    public OutTypeInfo OutInfo { get; public set; }
    public IType OldType { get; }
    public int OldTupleArity { get; }
    public SignatureGenerifier Generifier { get; public set; }
    public IList`1<IParametersOwner> AllOverrides { get; public set; }
    public IList`1<IParametersOwner> RootOverrides { get; public set; }
    public List`1<PreProcessedCall> PreProcessedCalls { get; public set; }
    public int NumberOfReturnedParams { get; }
    [CanBeNullAttribute]
public IParametersOwner ParametersOwner { get; }
    public int NewParameterPlace { get; }
    public bool OutIsIn { get; }
    public IEnumerable`1<ITransformParameterInfo> SelectedParameterInfos { get; }
    public bool HasOut { get; }
    public TransformParametersDataModel(TransformParametersViewModel model);
    [CompilerGeneratedAttribute]
public bool get_HasIn();
    [CompilerGeneratedAttribute]
public InTypeInfo get_InInfo();
    [CompilerGeneratedAttribute]
public void set_InInfo(InTypeInfo value);
    [CompilerGeneratedAttribute]
public OutTypeInfo get_OutInfo();
    [CompilerGeneratedAttribute]
public void set_OutInfo(OutTypeInfo value);
    [CompilerGeneratedAttribute]
public IType get_OldType();
    [CompilerGeneratedAttribute]
public int get_OldTupleArity();
    [CompilerGeneratedAttribute]
public SignatureGenerifier get_Generifier();
    [CompilerGeneratedAttribute]
public void set_Generifier(SignatureGenerifier value);
    [CompilerGeneratedAttribute]
public IList`1<IParametersOwner> get_AllOverrides();
    [CompilerGeneratedAttribute]
public void set_AllOverrides(IList`1<IParametersOwner> value);
    [CompilerGeneratedAttribute]
public IList`1<IParametersOwner> get_RootOverrides();
    [CompilerGeneratedAttribute]
public void set_RootOverrides(IList`1<IParametersOwner> value);
    [CompilerGeneratedAttribute]
public List`1<PreProcessedCall> get_PreProcessedCalls();
    [CompilerGeneratedAttribute]
public void set_PreProcessedCalls(List`1<PreProcessedCall> value);
    public int get_NumberOfReturnedParams();
    [CompilerGeneratedAttribute]
public IParametersOwner get_ParametersOwner();
    [CompilerGeneratedAttribute]
public int get_NewParameterPlace();
    public bool get_OutIsIn();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITransformParameterInfo> get_SelectedParameterInfos();
    [CompilerGeneratedAttribute]
public bool get_HasOut();
    public bool CreateEntities(IRefactoringDriver refactoringDriver, String& errmsg, Func`2<PsiLanguageType, ConstructionUtil> util);
    private bool CreateClassEntity(String& errmsg, Func`2<PsiLanguageType, ConstructionUtil> util, string name, ITransformTypeInfo typeInfo, bool withProperties, bool appendToTuple);
    public void FindOverrides(IProgressIndicator pi);
    [CanBeNullAttribute]
public ITypeElement CreateClassDeclaration(ConstructionUtil constructor, String& errmsg, string className);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParametersPage : SingleBeRefactoringPage {
    public static string ParametersGridId;
    public static string InComboId;
    public static string InTextBoxId;
    public static string AppendToTupleId;
    public static string OutComboId;
    public static string OutTextBoxId;
    private Property`1<string> myCodePreviewText;
    private BeControl myContent;
    private bool myHasTupleInProject;
    private ListEvents`1<ReturnTypeEnum> myInComboValues;
    private string myInitialReturnType;
    private List`1<ITransformParameterInfo> myInParameters;
    private BeLocalCookie myLocalCookie;
    private RichText myMethodName;
    private ListEvents`1<ReturnTypeEnum> myOutComboValues;
    private List`1<ITransformParameterInfo> myOutParameters;
    private Dictionary`2<ITransformParameterInfo, string> myParametersTypePreview;
    private IModuleReferenceResolveContext myResolveContext;
    private ReturnTypeEnum myCurrentIn;
    private ReturnTypeEnum myCurrentOut;
    private BeLocalCookie myOutComboCookie;
    private BeLocalCookie myInComboCookie;
    public string Title { get; }
    public string Description { get; }
    public TransformParametersPage(Lifetime lifetime, ISolution solution, TransformParametersViewModel viewModel);
    public virtual string get_Title();
    public virtual string get_Description();
    private void ResetOutValues(BeComboBox outCombo, TransformParametersViewModel viewModel);
    private void ResetInValues(BeComboBox inCombo, TransformParametersViewModel viewModel);
    public void Update(TransformParametersViewModel model, IShellLocks locks);
    private string GetTuplePreview(List`1<ITransformParameterInfo> selected, PsiLanguageType language);
    private string GetPreview(ITransformParameterInfo parameter, PsiLanguageType language);
    private string GetTypePreview(ITransformParameterInfo parameter, PsiLanguageType language);
    private string GetReturnType(List`1<ITransformParameterInfo> selected, TransformParametersViewModel model);
    public virtual BeControl GetPageContent();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParametersProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParametersRefactoring : DrivenRefactoring`2<TransformParametersWorkflow, TransformParametersBase> {
    [CompilerGeneratedAttribute]
private TransformParametersDataModel <DataModel>k__BackingField;
    public TransformParametersDataModel DataModel { get; }
    public TransformParametersRefactoring(TransformParametersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public TransformParametersDataModel get_DataModel();
    public virtual bool Execute(IProgressIndicator pi);
    private bool CreateEntity();
    private void ChangeParametersOwner();
    [NotNullAttribute]
private ISubstitution FindSubstitutionOfOverride(IParametersOwner owner);
    private void AnalyseParametersAccessibility(IProgressIndicator pi);
    private void AnalyseParameterAccessibility(IParametersOwner over, IProgressIndicator pi);
    private void PreProcessCalls(IProgressIndicator pi);
    private void PostProcessCalls();
    private bool IsPureRecursiveCall(IReference reference);
    private ISubstitution BuildSubstitution(IReference reference, ITransformTypeInfo typeInfo);
    private static ISubstitution ExtendSubst(ISubstitution subst, ISubstitution substitution);
    private ISubstitution RemapSubstitution(ISubstitution substitution, ITransformTypeInfo typeInfo);
    protected virtual TransformParametersBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    protected virtual TransformParametersBase CreateUnsupportedRefactoring();
    [CompilerGeneratedAttribute]
private ConstructionUtil <CreateEntity>b__5_0(PsiLanguageType lang);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParametersViewModel : object {
    private IParametersOwner myParametersOwner;
    private IDeclaredElementPointer`1<IParametersOwner> myParametersOwnerPointer;
    private TransformParametersDataModel myDataModel;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ITransformParameterInfo> <ParameterInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnTypeParameterInfo <ReturnParameterInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnTypeEnum <OutEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnTypeEnum <InEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCreatedClassAsReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InTargetClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutTargetClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppendToTuple>k__BackingField;
    public bool NonInteractive { get; public set; }
    public List`1<ITransformParameterInfo> ParameterInfos { get; }
    [CanBeNullAttribute]
public IParametersOwner ParametersOwner { get; }
    public ReturnTypeParameterInfo ReturnParameterInfo { get; public set; }
    public ReturnTypeEnum OutEntityType { get; public set; }
    public ReturnTypeEnum InEntityType { get; public set; }
    public bool UseCreatedClassAsReturnValue { get; }
    public string InTargetClassName { get; public set; }
    public string OutTargetClassName { get; public set; }
    public bool AppendToTuple { get; public set; }
    public int NewParameterPlace { get; }
    public TransformParametersViewModel(IParametersOwner parametersOwner, IParameter parameter);
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_NonInteractive(bool value);
    [CompilerGeneratedAttribute]
public List`1<ITransformParameterInfo> get_ParameterInfos();
    public IParametersOwner get_ParametersOwner();
    [CompilerGeneratedAttribute]
public ReturnTypeParameterInfo get_ReturnParameterInfo();
    [CompilerGeneratedAttribute]
public void set_ReturnParameterInfo(ReturnTypeParameterInfo value);
    [CompilerGeneratedAttribute]
public ReturnTypeEnum get_OutEntityType();
    [CompilerGeneratedAttribute]
public void set_OutEntityType(ReturnTypeEnum value);
    [CompilerGeneratedAttribute]
public ReturnTypeEnum get_InEntityType();
    [CompilerGeneratedAttribute]
public void set_InEntityType(ReturnTypeEnum value);
    [CompilerGeneratedAttribute]
public bool get_UseCreatedClassAsReturnValue();
    [CompilerGeneratedAttribute]
public string get_InTargetClassName();
    [CompilerGeneratedAttribute]
public void set_InTargetClassName(string value);
    [CompilerGeneratedAttribute]
public string get_OutTargetClassName();
    [CompilerGeneratedAttribute]
public void set_OutTargetClassName(string value);
    [CompilerGeneratedAttribute]
public bool get_AppendToTuple();
    [CompilerGeneratedAttribute]
public void set_AppendToTuple(bool value);
    public int get_NewParameterPlace();
    public TransformParametersDataModel GetData();
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TransformParametersWorkflow : DrivenRefactoringWorkflow {
    [CompilerGeneratedAttribute]
private TransformParametersViewModel <ViewModel>k__BackingField;
    public TransformParametersViewModel ViewModel { get; private set; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public TransformParametersWorkflow(ISolution solution, string actionId);
    [CompilerGeneratedAttribute]
public TransformParametersViewModel get_ViewModel();
    [CompilerGeneratedAttribute]
private void set_ViewModel(TransformParametersViewModel value);
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    private static bool IsAvailable(IDataContext dataContext, IParametersOwner& owner, IParameter& parameter);
    [PureAttribute]
public static bool IsAvailable(IParametersOwner parametersOwner);
    public virtual bool Initialize(IDataContext context);
    public virtual bool Validate();
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TypeBuilder : MulticastDelegate {
    public TypeBuilder(object object, IntPtr method);
    public virtual IType Invoke(TypeProjection projection);
    public virtual IAsyncResult BeginInvoke(TypeProjection projection, AsyncCallback callback, object object);
    public virtual IType EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TypeParameter : object {
    private bool myLocked;
    [CompilerGeneratedAttribute]
private JetHashSet`1<ITypeParameter> <Parameters>k__BackingField;
    public bool Locked { get; }
    public JetHashSet`1<ITypeParameter> Parameters { get; }
    public bool get_Locked();
    public void Lock();
    [CompilerGeneratedAttribute]
public JetHashSet`1<ITypeParameter> get_Parameters();
}
public class JetBrains.ReSharper.Refactorings.TransformParameters.TypeProjection : MulticastDelegate {
    public TypeProjection(object object, IntPtr method);
    public virtual ITypeParameter Invoke(TypeParameter parameter);
    public virtual IAsyncResult BeginInvoke(TypeParameter parameter, AsyncCallback callback, object object);
    public virtual ITypeParameter EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.Anonymous2DeclaredUnsupported : Anonymous2Declared {
    public Anonymous2DeclaredUnsupported(Anonymous2DeclaredWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IList`1<ITreeNode> SearchForAnonymousTypes(SubProgressIndicator pi);
    public virtual ITypeElement CreateClassDeclaration(IList`1<ITypeParameter> usedTypeParameters, ISubstitution& substitution);
    public virtual void ChangeReference(ITreeNode element, ITypeElement targetType, ISubstitution substitution);
    public virtual IList`1<ITypeParameter> GetUsagedTypeParameters();
}
public class JetBrains.ReSharper.Refactorings.Unsupported.ConstraintSearcherUtilUnsupported : ConstraintSearcherUtil {
    public virtual bool TryFindTypeMemberConstraint(ITreeNode preparedElement, ITypeMember& memberCalled, ExpressionAccessType& memberAccessType);
    public virtual bool TryFindArgumentConstraint(ITreeNode preparedElement, IParameter& parameter);
    public virtual bool TryFindSimpleReturnConstraint(ITreeNode preparedElement, ITypeMember& returnFromMember);
    public virtual bool TryFindAssignmentConstraint(ITreeNode preparedElement, IDeclaredElement& assignmentDest);
    public virtual bool TryFindInitializerConstraint(ITreeNode preparedElement, IDeclaredElement& initializedElement);
    public virtual void ProcessUp(ITreeNode directlyUsedElement, TypeElementUsage node);
    public virtual ITreeNode GetDirectlyUsedElement(ITreeNode someElement);
    public virtual bool IsUnsupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Refactorings.Unsupported.ConstructorToFactoryMethodUnsupported : ConstructorToFactoryMethodBase {
    public ConstructorToFactoryMethodUnsupported(Constructor2FactoryMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual ITypeMember CreateFactoryMethodDeclaration(ITypeElement targetTypeElement, IConstructor constructorToCall, string factoryMethodName);
    public virtual ITypeMember CreateSingleInstanceMemberDeclaration(ITypeElement targetTypeElement, IConstructor constructorToCall, string instancePropertyName);
    public virtual void ConvertUsage(ITypeMember factoryMember, IReference reference);
    public virtual string GetModifiersString(IParameter parameter);
}
internal class JetBrains.ReSharper.Refactorings.Unsupported.EncapsulateFieldUnsupported : EncapsulateFieldBase {
    public EncapsulateFieldUnsupported(EncapsulateFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IDeclaredElement CreatePropertyDeclaration(IDeclaredElement field);
    public virtual void RemoveFieldDeclaration(IDeclaredElement field);
    public virtual IDeclaredElement EnsureReadable(IDeclaredElement property, IDeclaredElement field);
    public virtual IDeclaredElement EnsureWriteable(IDeclaredElement property, IDeclaredElement field);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.ExtractClassHelperUnsupported : ExtractClassHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
}
public class JetBrains.ReSharper.Refactorings.Unsupported.ExtractInterfaceUnsupported : MoveMembersUnsupportedBase {
    public ExtractInterfaceUnsupported(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.ExtractSuperclassUnsupported : MoveMembersUnsupportedBase {
    public ExtractSuperclassUnsupported(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.Function2PropertyUnsupported : Function2PropertyBase {
    public Function2PropertyUnsupported(Function2PropertyWorkflow workflow, FunctionToPropertyDataProvider dataProvider, ISolution solution, IRefactoringDriver driver);
    protected virtual void ProcessMethod(IDeclaredElement element);
    protected virtual bool CheckExplicitImplementationList(IOverridableMember accessor, IMethod method);
    protected virtual bool AreEquals(string name1, string name2);
    public virtual bool InitialValidate();
    public virtual void ExecuteReferencesRefactoring(IReference reference);
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement element, IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.InlineClassUnsupported : InlineClassHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
}
public class JetBrains.ReSharper.Refactorings.Unsupported.InlineFieldUnsupported : InlineFieldBase {
    private InlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public InlineFieldUnsupported(InlineFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual IExpression GetInitializerExpression(IReference reference);
    public virtual bool ThisIsUsed(IExpression expression);
    public virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public virtual void RemoveAssignment(IReference reference);
    public virtual void RemoveField(IDeclaration declaration);
    public virtual IExpression GetInitializerExpression(IField field);
    public virtual bool GetCanUseRefOut(IExpression expression);
    public virtual bool CanInlineReference(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.InlineHelperUnsupported : InlineHelper {
    public InlineHelperUnsupported(IRefactoringDriver driver);
    public virtual bool CanHaveSideEffects(IExpression expression);
    public virtual void ReplaceTypeParameter(IReference reference, ITypeParameter parameter, ISubstitution substitution);
    public virtual IExpression GetQualifierExpression(IReference reference);
    public virtual Dictionary`2<IParameter, ArgumentFromParameter> GetParameter2Argument(IReference reference, IParametersOwner param);
    public virtual Dictionary`2<ArgumentFromParameter, InlinedArgumentInfo> GetArgument2Infos(IReference reference, Dictionary`2<IParameter, ArgumentFromParameter> parameter2argument, Dictionary`2<int, IParameter> inlinedMethodParameterInfos);
    public virtual bool CanHaveSideEffects(IArgument argument);
    public virtual IDeclaredElement SplitDeclarationAndInitializer(IDeclaredElement declaredElement);
    public virtual IDeclaredElement InsertReturnValueTempVariable(InlineMethodCallInfo inlineMethodCallInfo, IType returnType, IReference reference, CallSiteContext context);
    public virtual IDeclaredElement InsertTempForQualifier(IExpression qualifierExpression, IReference reference, CallSiteContext context, ReferenceIdentitySaver saver, ReferenceKind referenceKind);
    public virtual IDeclaredElement InsertTempVariableForAssignedValue(IExpression assignedExpression, IReference reference, CallSiteContext context, ReferenceIdentitySaver referenceIdentitySaver);
    public virtual IDeclaredElement InsertTempForArgument(IParameter parameterInfo, InlinedArgumentInfo argumentInfo, IReference reference, CallSiteContext context, ReferenceIdentitySaver saver, ArgumentFromParameter argumentFromParameter);
    public virtual void RemoveCastFromElement(ITreeNode element);
    public virtual IArgumentsOwner GetArgumentOwner(IReference& reference, bool replaceMethodGroup);
    public virtual IEnumerable`1<IReference> AllNotQualifiableReferences(IReference reference);
    public virtual ITreeNode GetContainingStatement(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.InlineMethodUnsupported : InlineMethod {
    private InlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public InlineMethodUnsupported(InlineMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual bool IsReturnStatementOnly(IDeclaredElement element, IExpression& returnedExpression, ITreeNode& blockOfStatements);
    public virtual bool CanIntroduceStatementsBefore(IReference reference);
    public virtual bool IsFromExpressionBody(IReference reference);
    public virtual bool ReplaceCall(IReference reference, ITreeNode returnedExpression, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    public virtual bool ReplaceStatement(IReference& reference, ITreeNode statements, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context, bool replaceOriginal);
    public virtual void ReplaceConditionalAccess(IReference& reference, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    public virtual bool IsReturned(IReference reference, InlinedElementKinds inlinedElementKind);
    public virtual bool IsLastStatement(IReference reference);
    public virtual bool IsLastStatementInScope(IReference reference);
    public virtual AssignmentInfo FindContainingAssignment(InlinedElementKinds inlinedElementKind, IReference reference);
    public virtual IReadOnlyList`1<IExpression> GetExpressionsReferencingThis(ITreeNode methodBody);
    public virtual bool AllReturnsAreLast(IDeclaredElement element);
    public virtual IReadOnlyList`1<IExpression> CollectSetterValueParameterAccesses(ITreeNode methodBody);
    public virtual bool IsCollectionInitializer(IReference reference);
    public virtual bool IsDeconstruction(IReference reference);
    public virtual IType FindRealReturnType(IParametersOwner parametersOwner, ITreeNode context);
    public virtual InlinedReferenceContext InspectReferenceContext(ITreeNode treeNode);
    public virtual bool GetIsDestinationOfAssignment(IReference reference, IExpression& assignmentSource);
    public virtual bool GetUsedAsDelegate(InlinedMethodInfo info, IReference reference);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.InlineParameterHelperUnsupported : InlineParameterHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
}
public class JetBrains.ReSharper.Refactorings.Unsupported.InlineParameterUnsupported : InlineParameterBase {
    public InlineHelper InlineHelper { get; }
    public InlineParameterUnsupported(InlineParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
}
public class JetBrains.ReSharper.Refactorings.Unsupported.InlineVarUnsupported : InlineVarBase {
    public InlineHelper InlineHelper { get; }
    public InlineVarUnsupported(InlineVarWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public virtual InlineHelper get_InlineHelper();
    public virtual void RemoveVariableDeclaration(IDeclaration declaration);
    public virtual void RemoveAssignment(ITreeNode expression);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.IntroduceFieldUnsupported : IntroduceFieldBase {
    public IntroduceFieldUnsupported(IntroduceFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual ITypeMember AddField(ITypeDeclaration typeDeclaration, IExpression initExpression, IList`1<ITreeNode> tags, object type);
    public virtual bool ReplaceUsages(IList`1<ITreeNode> expressions, ITypeMember field, ITreeNode initializer);
    public virtual void AddAssignment(IParameter variable, ITypeMember member, IExpression expression);
    public virtual bool ReplaceVariableDeclaration(ILocalVariable variable, ITypeMember field, IExpression initializer);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.IntroParameterUnsupported : IntroduceParameterBase {
    private InlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public IntroParameterUnsupported(IntroduceParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual void CallInline(IReference reference, CallSiteContext context, IntroduceParameterInlineCallInfo info, IList`1<string> lambdaParameterNames, int index);
    public virtual void FixOtherArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public virtual void AddParameter(IType type, string name, IDeclaration declaration, ISubstitution substitution, ITreeNode defaultValue);
    public virtual void ReplaceExpression(ITreeNode element);
    public virtual IReference AddBaseClause(IDeclaredElement constructor);
    public virtual void RemoveLocalVariable(ILocalVariable variable);
    public virtual void RemoveArguments(IReference reference, IList`1<DeclaredElementNode> parametersToRemove);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.MakeStaticHelperUnsupported : object {
    public bool IsLanguageSupported { get; }
    public sealed virtual bool get_IsLanguageSupported();
    public sealed virtual bool CheckElement(IDeclaredElement declaredElement, ITypeElement& containingTypeElement);
    public sealed virtual void CollectUsages(ThisUsagesCollector collector, IParametersOwnerDeclaration parametersOwnerDeclaration, IPsiServices psiServices);
    public sealed virtual string GetTitle();
}
internal class JetBrains.ReSharper.Refactorings.Unsupported.MakeStaticUnsupported : MakeStatic {
    public InlineHelper InlineHelper { get; }
    public MakeStaticUnsupported(MakeStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void BindTo(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual void Qualify(ITreeNode node, IParameter parameter);
    public virtual void AddArgumentAndBind(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution, DisposableMarker marker);
    public virtual void SetStatic(IDeclaration declaration);
    public virtual IParameter AddParameter(IDeclaration declaration, IType type, string name);
    public virtual int ReferencesToThis(IExpression expression);
    public virtual InlineHelper get_InlineHelper();
    public virtual void Replace(ITreeNode node, string name);
    public virtual void CallInline(IReference reference, CallSiteContext context, IntroduceParameterInlineCallInfo info, IList`1<string> lambdaParameterNames);
    public virtual void FixOtherArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public virtual IReference ConvertMethodGroupToLambda(IReference reference, IList`1<IParameter> parameters);
    public virtual void AddArgument(IReference reference, string marker);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.MoveMembersHelperUnsupported : MoveMembersHelper {
    [CompilerGeneratedAttribute]
private IRefactoringDriver <Driver>k__BackingField;
    public IRefactoringDriver Driver { get; }
    public MoveMembersHelperUnsupported(IMoveMembersExecuter executer, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public IRefactoringDriver get_Driver();
    public virtual IList`1<Pair`2<DeclaredElementNode, IDeclaration>> CutDeclarations(IEnumerable`1<DeclaredElementNode> memberInfos, SubProgressIndicator pi);
    public virtual void SetSuperclass(ITypeDeclaration sourceTypeDeclaration, ITypeElement newSuperTypeElement, ISubstitution substitution);
    public virtual void AddBaseInterface(ITypeElement element, IDeclaredType info);
    public virtual ITypeDeclaration CreateTargetTypeElement(string name, ITypeElement sourceType, List`1<ITypeParameter> parameters, bool createBaseType, bool preserveAccessRights);
    public virtual ITypeDeclaration InsertSibling(ITypeDeclaration decl, ITypeDeclaration sourceClass);
    public virtual ITypeDeclaration InsertToNewFile(ITypeDeclaration decl, ITypeDeclaration sourceClass, string ns, IProjectFile fileNearby);
    public virtual void MakeOverride(ITypeMember member);
    public virtual void MakeTypeElementAbstract(ITypeElement element);
    public virtual void PasteDeclarations(IList`1<Pair`2<DeclaredElementNode, IDeclaration>> declarations, ITypeElement targetType, IProjectFile projectFile, ITypeDeclaration targetTypeDeclaration, SubProgressIndicator pi);
    public virtual void RemoveDeclaration(ITypeMember member);
    public virtual bool TryProcessMultiFieldForResolve(IRecursiveElementProcessor collector, IDeclaration declaration);
    public virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool nameIsItem, IRefactoringDriver driver);
    public virtual void RemoveSuperType(ITypeDeclaration typeDeclaration, IDeclaredType type);
    public virtual IConstructor GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
    public virtual void GenerateConstructors(ITypeElement targetType, ITypeDeclaration typeDeclaration, IDeclaredElementPointer`1<IConstructor> baseConstructor);
    public virtual void CheckConstructorReferenceConflict(IReference reference);
}
public abstract class JetBrains.ReSharper.Refactorings.Unsupported.MoveMembersUnsupportedBase : object {
    private IRefactoringDriver myDriver;
    public IRefactoringDriver Driver { get; }
    unknown IRefactoringDriver RefactoringDriver {public set; }
    public MoveMembersUnsupportedBase(IRefactoringDriver driver);
    public IRefactoringDriver get_Driver();
    public sealed virtual void SetExecuter(IRefactoringExecuter refactoring);
    public sealed virtual bool CheckConflictsWithTargetClassName(ITypeElement element, string name);
    public sealed virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public sealed virtual MoveMembersHelper GetHelper();
    public sealed virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool name);
    public void GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
    public sealed virtual void set_RefactoringDriver(IRefactoringDriver value);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.MoveStaticMembersUnsupported : MoveStaticMembers {
    public MoveStaticMembersUnsupported(MoveStaticMembersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void RemoveOldDeclaration(IDeclaration declaration);
    public virtual Dictionary`2<ITypeParameter, ITypeParameter> PasteDeclaration(StaticMemberInfo copy, ITypeMember& newTypeMember);
}
internal class JetBrains.ReSharper.Refactorings.Unsupported.MoveTypeToOuterScopeUnsupported : object {
    private IRefactoringDriver myRefactoringDriver;
    unknown IRefactoringDriver RefactoringDriver {public set; }
    public MoveTypeToOuterScopeUnsupported(IRefactoringDriver refactoringDriver);
    public sealed virtual void set_RefactoringDriver(IRefactoringDriver value);
    public sealed virtual void SaveLocalReferences(ICollection`1<IDeclaration> declarations);
    public sealed virtual Pair`2<IDeclaration, IDeclaration> CutDeclaration(IDeclaration typeDeclaration);
    public sealed virtual void PasteDeclarations(Pair`2<IDeclaration, IDeclaration> pair);
    public sealed virtual void RestoreLocalReferences(ICollection`1<IDeclaration> declarations);
    public sealed virtual bool IsContextUnsafe(ITreeNode element);
    public sealed virtual bool NeedsTypeParameterOfOuterClass(ITypeParameter parameter, IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.ParamsModifierUnsupported : ParamsModifierConvertBase {
    public ParamsModifierUnsupported(ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void ExecuteReferencesRefactoring(IReference reference);
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement element, IProgressIndicator progressIndicator);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.Property2FunctionUnsupported : Property2FunctionBase {
    public Property2FunctionUnsupported(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void ProcessProperty(IDeclaredElement propertyOrMethod);
    protected virtual bool AreEquals(string name1, string name2);
    public virtual bool InitialValidate();
    public virtual void ExecuteReferencesRefactoring(IReference reference);
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement element, IProgressIndicator pi);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.PullUpUnsupported : MoveMembersUnsupportedBase {
    public PullUpUnsupported(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.PushDownUnsupported : MoveMembersUnsupportedBase {
    public PushDownUnsupported(IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.SafeDeleteUnsupported : SafeDeleteBase {
    public SafeDeleteUnsupported(SafeDeleteWorkflow workflow, ISolution solution, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.Static2ExtensionUnsupported : Static2ExtensionBase {
    public Static2ExtensionUnsupported(Static2ExtensionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void MakeCallExtension(IReference reference);
    public virtual void MakeCallPlainStatic(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.TransformParametersUnsupported : TransformParametersBase {
    public TransformParametersUnsupported(TransformParametersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool IsPureRecursiveCall(IReference reference);
    public virtual PreProcessedCall PreProcessCall(IReference reference);
    public virtual void FixUsage(PreProcessedCall call, string name);
    public virtual void TransformDeclaration(IParametersOwner method, IRefactoringDriver driver, ISubstitution substsOfOverrides);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.Type2PartialUnsupported : object {
    public bool IsLanguageSupported { get; }
    public sealed virtual bool get_IsLanguageSupported();
    public sealed virtual bool IsAvailableForTypeElement(ITypeElement typeElement, IPsiSourceFile psiSourceFile);
    public sealed virtual bool CanSuggestProjectFile(IProjectFile projectFile);
    public sealed virtual ITypeDeclaration AddNewTypePart(Type2PartialDataModel model, ITreeNode& formatRoot);
    public sealed virtual string GetExtension();
    public sealed virtual TreeTextRange AdjustSelectedRange(IFile psiFile, TreeTextRange treeTextRange, String& partName);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.UnsupportedTypeUsageSearcherUtil : TypeUsageSearcherUtil {
    public virtual bool TryFindTypeParameterOwner(IReference reference, ITreeNode& typeUsageElement, ITypeParameter& parameter);
    public virtual bool TryFindDelegateDeclaration(IReference reference, ITypeElement& delegateElement);
    public virtual bool TryFindChilidTypeElement(IReference reference, ITypeElement& childTypeElement);
    public virtual bool TryFindConstrainedParameter(IReference reference, ITypeParameter& parameter);
    public virtual int GetArrayRank(ITreeNode typUsageElement);
}
public class JetBrains.ReSharper.Refactorings.Unsupported.UseBaseTypeUnsupported : UseBaseTypeBase {
    private UnsupportedTypeUsageSearcherUtil myTypeUsageSearcherUtil;
    private ConstraintSearcherUtilUnsupported myUnsupported;
    public bool MethodGroupTypeMatch { get; }
    public UseBaseTypeUnsupported(UseBaseTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool get_MethodGroupTypeMatch();
    public virtual IDeclaredElement[] GetDeclaredElements(IReference reference);
    public virtual bool CheckConstraintElement(IDeclaredElement element);
    public virtual TypeUsageSearcherUtil GetTypeUsageSearcherUtil();
    public virtual ConstraintSearcherUtil GetConstraintSearcherUtil();
    public virtual IDeclaredElement GetDelegateDeclaration(ITreeNode directlyUsedElement);
    public virtual IReference BindUsage(IReference reference);
    public virtual bool GetConstructedExpression(IReference reference, IExpression& expression);
    public virtual bool GetCastExpressionExpression(IReference reference, IExpression& expression);
    public virtual bool GetTypeOfExpression(IReference reference, IExpression& expression);
    public virtual bool GetIsExpression(IReference reference, IExpression& expression);
}
public abstract class JetBrains.ReSharper.Refactorings.UseBaseType.ConstraintSearch.ConstraintBase : object {
    public bool IsBlocker { get; }
    public IEnumerable`1<IDeclaredElement> ConstraintElements { get; }
    public abstract virtual bool get_IsBlocker();
    public virtual IEnumerable`1<IDeclaredElement> get_ConstraintElements();
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.ConstraintSearch.ConstraintSearcher : LanguageSpecificHelper`1<ConstraintSearcherUtil> {
    private UseBaseTypeRefactoring myRefactoring;
    private Dictionary`2<Pair`2<IReference, ITypeParameter>, InferBindedCall> myInferBindedCalls;
    public ConstraintSearcher(UseBaseTypeRefactoring refactoring, LanguageSpecificUtilProvider`1<ConstraintSearcherUtil> utilProvider);
    public ITreeNode GetDirectlyUsedElement(IReference reference);
    public ITreeNode GetDirectlyUsedElement(ITreeNode element);
    public ConstraintBase GetConstraints(ITreeNode directlyUsedElement, bool searchInvocations);
    private static ConstraintBase GetDeclaredElementConstraint(IDeclaredElement parameter);
    private ConstraintBase GetTypeMemberConstraint(ITypeMember typeMember, ExpressionAccessType memberAccessType);
    private bool CheckIfMemberIsFromParent(ITypeMember memberToTest, ExpressionAccessType memebrAccessType);
    private static bool HasRightAccess(IOverridableMember member, ExpressionAccessType accessType);
    public void ProcessUp(ITreeNode directlyUsedElement, Node node);
    public void AddMultiplexerConstraints();
    public void AddInferBindedParameter(IReference reference, TypeElementUsage usage, int index, IMethod method, ITypeParameter typeParameter);
    private static ITypeParameter FindTypeParameter(ITypeParameter parameter, IType type);
}
public abstract class JetBrains.ReSharper.Refactorings.UseBaseType.ConstraintSearch.ConstraintSearcherUtil : object {
    public abstract virtual bool TryFindTypeMemberConstraint(ITreeNode preparedElement, ITypeMember& memberCalled, ExpressionAccessType& memberAccessType);
    public abstract virtual bool TryFindArgumentConstraint(ITreeNode preparedElement, IParameter& parameter);
    public abstract virtual bool TryFindSimpleReturnConstraint(ITreeNode preparedElement, ITypeMember& returnFromMember);
    public abstract virtual bool TryFindAssignmentConstraint(ITreeNode preparedElement, IDeclaredElement& assignmentDest);
    public abstract virtual bool TryFindInitializerConstraint(ITreeNode preparedElement, IDeclaredElement& initializedElement);
    public abstract virtual void ProcessUp(ITreeNode directlyUsedElement, TypeElementUsage node);
    public abstract virtual ITreeNode GetDirectlyUsedElement(ITreeNode someElement);
    public static TypeElementUsage WrapTypeUsage(TypeElementUsage usage, IType parameterType);
    public static TypeElementUsage FoldTypeUsage(IType returnType, IType usageType, TypeElementUsage usage);
    public static TypeElementUsage DecorateTypeUsage(IType returnType, ITypeParameter parameter, TypeElementUsage usage);
    public virtual bool IsUnsupported();
    public virtual bool TryFindExtensionMethodConstraint(ITreeNode treeNode, IParameter& extensionParameter);
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.Dependencies.Edge : object {
    private Node myStart;
    private Node myEnd;
    public Node Start { get; }
    public Node End { get; }
    public Edge(Node start, Node end);
    public sealed virtual Node get_Start();
    public sealed virtual Node get_End();
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.Dependencies.Graph : object {
    private List`1<Edge> myEdges;
    private OneToListMap`2<Node, Edge> myOutgoing;
    private OneToListMap`2<Node, Edge> myIncoming;
    private Dictionary`2<IDeclaredElement, Node> myDeclaredElementToNode;
    private Dictionary`2<TypeElementUsage, Node> myUsageToNode;
    private JetHashSet`1<Node> myMarkedNodes;
    private int myDeclaredElementsCount;
    public List`1<Edge> Edges { get; }
    public OneToListMap`2<Node, Edge> Outgoing { get; }
    public OneToListMap`2<Node, Edge> Incoming { get; }
    public Dictionary`2<IDeclaredElement, Node> DeclaredElementToNode { get; }
    public Dictionary`2<TypeElementUsage, Node> ReferenceToNode { get; }
    public int DeclaredElementsCount { get; }
    public IEnumerable`1<Node> Nodes { get; }
    public sealed virtual List`1<Edge> get_Edges();
    public sealed virtual OneToListMap`2<Node, Edge> get_Outgoing();
    public sealed virtual OneToListMap`2<Node, Edge> get_Incoming();
    public Dictionary`2<IDeclaredElement, Node> get_DeclaredElementToNode();
    public Dictionary`2<TypeElementUsage, Node> get_ReferenceToNode();
    public int get_DeclaredElementsCount();
    public sealed virtual IEnumerable`1<Node> get_Nodes();
    private sealed virtual override IEnumerable`1<Node> JetBrains.Util.Graph.IDirectedGraph<JetBrains.ReSharper.Refactorings.UseBaseType.Dependencies.Node>.Outgoing(Node node);
    private sealed virtual override IEnumerable`1<Node> JetBrains.Util.Graph.IDirectedGraph<JetBrains.ReSharper.Refactorings.UseBaseType.Dependencies.Node>.Incoming(Node node);
    public IEnumerable`1<Edge> Out(Node node);
    public IEnumerable`1<Edge> In(Node node);
    public IEnumerable`1<Node> Pred(Node node);
    public IEnumerable`1<Node> Succ(Node node);
    public bool IsMarked(Node node);
    public bool IsMarked(JetHashSet`1<Node> nodes);
    public void Mark(Node node);
    public void Mark(IEnumerable`1<Node> set);
    public Node AddNode(TypeElementUsage usage, IDeclaredElement[] elements);
    public void AddCreationNode(TypeElementUsage usage, IExpression expression);
    public void AddCastNode(TypeElementUsage usage, IExpression expression);
    public void AddTypeOfExpression(TypeElementUsage usage, IExpression expression, bool mark);
    public void IterateDeclNodes(Action`3<Node, IDeclaredElement, IProgressIndicator> action, IProgressIndicator pi);
    public void IterateExprNodes(Action`3<Node, IExpression, IProgressIndicator> action, IProgressIndicator pi);
    public void CreateEdge(Node start, Node end);
    public void PropagateMarkers();
    private void PropagateMarkers(Node node);
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.Dependencies.GraphBuilder : object {
    private UseBaseTypeRefactoring myRefactoring;
    private IFinder myFinder;
    [CompilerGeneratedAttribute]
private Graph <Graph>k__BackingField;
    public Graph Graph { get; }
    public GraphBuilder(UseBaseTypeRefactoring refactoring);
    [CompilerGeneratedAttribute]
public Graph get_Graph();
    public Graph BuildGraph(IProgressIndicator pi);
    private void CreateExprEdge(Node node, IExpression expression, IProgressIndicator pi);
    private void CreateDeclEdge(Node node, IDeclaredElement element, IProgressIndicator pi);
    private void CreateAnonymousDelegateDependency(Node node, IDeclaredElement element);
    private void CreateParameterDependencies(Node node, IParameter parameter);
    private void CreateOverridableMemberDependencies(Node childNode, IOverridableMember overridable);
    private void CreateTypeOwnerDependencies(IDeclaredElement typeOwner, Node node, IProgressIndicator pi);
    private void AddUsageForDelegateConstraints(IMethod method);
    private void AddMethod2DelegateRelation(IMethod method, IDelegate delegateDecl, IReference methodReference);
    private void AddUsageBasedConstraints(ITreeNode directlyUsedElement, TypeElementUsage elementUsage);
    private static bool CreateBidirectional(Node constraintNode);
    private void AddGenerifiedConstraints(ITreeNode directlyUsedElement, Node node);
    public void AddComplexDependency(ITreeNode upElement, TypeElementUsage usage);
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.Dependencies.Node : object {
    private IDeclaredElement[] myElements;
    [CompilerGeneratedAttribute]
private IExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeElementUsage <TypeUsage>k__BackingField;
    public IExpression Expression { get; }
    public TypeElementUsage TypeUsage { get; }
    public IDeclaredElement[] Elements { get; }
    public Node(TypeElementUsage reference, IDeclaredElement[] elements);
    public Node(TypeElementUsage reference, IExpression expression);
    [CompilerGeneratedAttribute]
public IExpression get_Expression();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public TypeElementUsage get_TypeUsage();
    public IDeclaredElement[] get_Elements();
}
public interface JetBrains.ReSharper.Refactorings.UseBaseType.GraphBase.IDiGraph`2 {
    public List`1<EDGE> Edges { get; }
    public OneToListMap`2<NODE, EDGE> Outgoing { get; }
    public OneToListMap`2<NODE, EDGE> Incoming { get; }
    public abstract virtual List`1<EDGE> get_Edges();
    public abstract virtual OneToListMap`2<NODE, EDGE> get_Outgoing();
    public abstract virtual OneToListMap`2<NODE, EDGE> get_Incoming();
}
public interface JetBrains.ReSharper.Refactorings.UseBaseType.GraphBase.IEdge`1 {
    public NODE Start { get; }
    public NODE End { get; }
    public abstract virtual NODE get_Start();
    public abstract virtual NODE get_End();
}
public interface JetBrains.ReSharper.Refactorings.UseBaseType.GraphBase.INode {
}
public interface JetBrains.ReSharper.Refactorings.UseBaseType.GraphBase.IScc`2 {
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.GraphBase.SCCBuilder`2 : object {
    private IDiGraph`2<NODE, EDGE> myGraph;
    private Dictionary`2<NODE, int> myPostOrder;
    public SCCBuilder`2(IDiGraph`2<NODE, EDGE> graph);
    public IScc`2<NODE, EDGE> BuildSCC();
    private int BuildPostOrder(NODE node, int cur);
}
public interface JetBrains.ReSharper.Refactorings.UseBaseType.IUseBaseTypeDataProvider {
}
public interface JetBrains.ReSharper.Refactorings.UseBaseType.IUseBaseTypeExecuter {
}
public interface JetBrains.ReSharper.Refactorings.UseBaseType.IUseBaseTypeWorkflowProvider {
}
public abstract class JetBrains.ReSharper.Refactorings.UseBaseType.TypeUsageSearch.TypeElementUsage : object {
    private IReference myReference;
    private IType myType;
    private TypeElementUsageKinds myKind;
    private TypeElementUsage myParent;
    private JetHashSet`1<Node> myNodes;
    [CompilerGeneratedAttribute]
private bool <HasSuperUsage>k__BackingField;
    public bool HasSuperUsage { get; public set; }
    public TypeElementUsage Parent { get; }
    public TypeElementUsageKinds Kind { get; }
    public IType Type { get; }
    public IReference Reference { get; }
    public ITypeParameter Parameter { get; }
    public bool CanHaveInvocationConstraint { get; }
    protected TypeElementUsage(IType type, IReference reference, TypeElementUsageKinds kind, TypeElementUsage parent);
    public static TypeElementUsage CreateOrigianl(IType element, IReference reference);
    public static TypeElementUsage CreateCodeBased(IType type, IReference reference, TypeElementUsage baseUsage, TypeElementUsageKinds kind);
    public static TypeElementUsage CreateFake(IType type, TypeElementUsage baseUsage, TypeElementUsageKinds kind);
    public static TypeElementUsage CreateGenericBasedUsage(IType type, IReference reference, TypeElementUsage baseUsage, ITypeParameter prameter);
    [CompilerGeneratedAttribute]
public bool get_HasSuperUsage();
    [CompilerGeneratedAttribute]
public void set_HasSuperUsage(bool value);
    public JetHashSet`1<Node> AllNodes();
    public TypeElementUsage get_Parent();
    public TypeElementUsageKinds get_Kind();
    public IType get_Type();
    public IReference get_Reference();
    public virtual ITypeParameter get_Parameter();
    public bool get_CanHaveInvocationConstraint();
    public void AddNode(Node node);
    public void AddNodes(IEnumerable`1<Node> nodes);
    public sealed virtual bool Equals(TypeElementUsage typeElementUsage);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public TypeElementUsage GetBaseUsage();
}
public enum JetBrains.ReSharper.Refactorings.UseBaseType.TypeUsageSearch.TypeElementUsageKinds : Enum {
    public int value__;
    public static TypeElementUsageKinds Original;
    public static TypeElementUsageKinds Delegate;
    public static TypeElementUsageKinds TypeParameter;
    public static TypeElementUsageKinds BaseType;
    public static TypeElementUsageKinds ConstrainedParameter;
    public static TypeElementUsageKinds Array;
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.TypeUsageSearch.TypeUsageSearcher : LanguageSpecificHelper`1<TypeUsageSearcherUtil> {
    private ITypeElement myTypeElement;
    private IFinder myFinder;
    private TypeUsageSearchResult mySearchResult;
    public TypeUsageSearcher(ITypeElement typeElement, LanguageSpecificUtilProvider`1<TypeUsageSearcherUtil> utilProvider);
    public TypeUsageSearchResult Find(IProgressIndicator pi);
    private void Find(ITypeElement element, IProgressIndicator pi, TypeElementUsageKinds kind, TypeElementUsage parent);
    private TypeElementUsage GetUsage(IReference reff, TypeElementUsageKinds kind, IType type, TypeElementUsage baseUsage);
    private TypeElementUsage GetUsage(IType type, IReference reference, TypeElementUsage baseUsage, ITypeParameter typeParameter);
}
public abstract class JetBrains.ReSharper.Refactorings.UseBaseType.TypeUsageSearch.TypeUsageSearcherUtil : object {
    public abstract virtual bool TryFindTypeParameterOwner(IReference reference, ITreeNode& typeUsageElement, ITypeParameter& parameter);
    public abstract virtual bool TryFindDelegateDeclaration(IReference reference, ITypeElement& delegateElement);
    public abstract virtual bool TryFindChilidTypeElement(IReference reference, ITypeElement& childTypeElement);
    public abstract virtual bool TryFindConstrainedParameter(IReference reference, ITypeParameter& parameter);
    public abstract virtual int GetArrayRank(ITreeNode typUsageElement);
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.TypeUsageSearch.TypeUsageSearchResult : object {
    private JetHashSet`1<ITypeElement> myProcessedElements;
    private List`1<TypeElementUsage> myUsages;
    public JetHashSet`1<ITypeElement> ProcessedElementsUsage { get; }
    public List`1<TypeElementUsage> TypeUsages { get; }
    public JetHashSet`1<ITypeElement> get_ProcessedElementsUsage();
    public List`1<TypeElementUsage> get_TypeUsages();
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.UI.BaseTypeTree : object {
    private IList`1<IDeclaredElement> myAllTypes;
    private PsiIconManager myPsiIconManager;
    public object Root { get; }
    public bool AutoExpandSingleChild { get; }
    public BaseTypeTree(IList`1<IDeclaredElement> allTypes);
    public sealed virtual object get_Root();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.UseBaseType.UI.BaseTypeTree/<GetChildren>d__5")]
public sealed virtual IEnumerable GetChildren(object item);
    public sealed virtual bool AreChildrenEquivalent(object child1, object child2);
    public sealed virtual int GetChildEquivalenceHashCode(object child);
    public sealed virtual object SaveItem(object item);
    public sealed virtual object RestoreItem(object o);
    public sealed virtual bool CanHaveChildren(object item);
    public sealed virtual bool IsInitiallyExpanded(object item);
    public sealed virtual bool get_AutoExpandSingleChild();
    public sealed virtual void UpdateNode(IAbstractTreeNode node, object item);
    public sealed virtual void DisposeNode(IAbstractTreeNode node, object item);
}
[ActionAttribute("UseBaseTypeAction", "JetBrains.ReSharper.Refactorings.Resources.Strings", "UseBaseTypeWherePossibleActionText")]
public class JetBrains.ReSharper.Refactorings.UseBaseType.UseBaseTypeAction : ExtensibleRefactoringAction`1<IUseBaseTypeWorkflowProvider> {
    public static string ACTION_ID;
    protected RichText Caption { get; }
    protected virtual RichText get_Caption();
}
public abstract class JetBrains.ReSharper.Refactorings.UseBaseType.UseBaseTypeBase : RefactoringExecBase`2<UseBaseTypeWorkflow, UseBaseTypeRefactoring> {
    public bool MethodGroupTypeMatch { get; }
    protected UseBaseTypeBase(UseBaseTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public abstract virtual bool get_MethodGroupTypeMatch();
    public abstract virtual IDeclaredElement[] GetDeclaredElements(IReference reference);
    public abstract virtual bool CheckConstraintElement(IDeclaredElement element);
    public abstract virtual TypeUsageSearcherUtil GetTypeUsageSearcherUtil();
    public abstract virtual ConstraintSearcherUtil GetConstraintSearcherUtil();
    public abstract virtual IDeclaredElement GetDelegateDeclaration(ITreeNode directlyUsedElement);
    public abstract virtual IReference BindUsage(IReference reference);
    public virtual void CreateAnonymousDelegateDependency(IParametersOwner owner, Node node, int index, IParameter& delegateParameter);
    public abstract virtual bool GetConstructedExpression(IReference reference, IExpression& expression);
    public abstract virtual bool GetCastExpressionExpression(IReference reference, IExpression& expression);
    public abstract virtual bool GetTypeOfExpression(IReference reference, IExpression& expression);
    public abstract virtual bool GetIsExpression(IReference reference, IExpression& expression);
    protected static ITypeElement FindSupertypeContainingMember(ITypeMember testMember, ITypeElement desiredResult, ExpressionAccessType accessType);
    protected bool CheckConstraintElementCommon(IDeclaredElement element, PsiLanguageType language);
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.UseBaseTypeDataModel : object {
    private IDeclaredElementPointer`1<ITypeElement> myClassElementPointer;
    [CompilerGeneratedAttribute]
private bool <ChangeIs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChangeTypeOf>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DeclaredElementNode> <BaseElements>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredElementNode <Selected>k__BackingField;
    public bool ChangeIs { get; public set; }
    public bool ChangeTypeOf { get; public set; }
    public IList`1<DeclaredElementNode> BaseElements { get; }
    public DeclaredElementNode Selected { get; public set; }
    [CanBeNullAttribute]
public ITypeElement Class { get; }
    [CanBeNullAttribute]
public ITypeElement BaseTypeElement { get; }
    public UseBaseTypeDataModel(ITypeElement typeElement, UseBaseTypeDataProvider dataProvider);
    [CompilerGeneratedAttribute]
public bool get_ChangeIs();
    [CompilerGeneratedAttribute]
public void set_ChangeIs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ChangeTypeOf();
    [CompilerGeneratedAttribute]
public void set_ChangeTypeOf(bool value);
    [CompilerGeneratedAttribute]
public IList`1<DeclaredElementNode> get_BaseElements();
    [CompilerGeneratedAttribute]
public DeclaredElementNode get_Selected();
    [CompilerGeneratedAttribute]
public void set_Selected(DeclaredElementNode value);
    public ITypeElement get_Class();
    public ITypeElement get_BaseTypeElement();
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.UseBaseTypeDataProvider : object {
    private string myBaseTypeElementName;
    [CompilerGeneratedAttribute]
private bool <ChangeInTypeof>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChangeIs>k__BackingField;
    public bool ChangeInTypeof { get; }
    public bool ChangeIs { get; }
    public UseBaseTypeDataProvider(string baseTypeElementName, bool changeIs, bool changeInTypeof);
    public void SelectBaseTypeElement(IList`1<DeclaredElementNode> list);
    [CompilerGeneratedAttribute]
public bool get_ChangeInTypeof();
    [CompilerGeneratedAttribute]
public bool get_ChangeIs();
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.UseBaseTypePage : SingleBeRefactoringPage {
    public static string Selected;
    public static string TypeOf;
    public static string Is;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    private UseBaseTypeDataModel myDataModel;
    public string Title { get; protected set; }
    public string Description { get; protected set; }
    public string PageDescription { get; }
    public UseBaseTypePage(UseBaseTypeDataModel model, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
protected virtual void set_Title(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
protected virtual void set_Description(string value);
    public virtual string get_PageDescription();
    public virtual BeControl GetPageContent();
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__15_0(bool v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__15_1(bool v);
    [CompilerGeneratedAttribute]
private void <GetPageContent>b__15_2(ITreeGridNode v);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.UseBaseType.UseBaseTypeProvider : object {
    public sealed virtual IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.UseBaseTypeRefactoring : DrivenRefactoring`2<UseBaseTypeWorkflow, UseBaseTypeBase> {
    private TypeUsageSearcher myTypeUsageSearcher;
    private List`1<IReference> myChanges;
    [CompilerGeneratedAttribute]
private IFinder <Finder>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeUsageSearchResult <FindResult>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstraintSearcher <ConstraintSearcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TargetTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    public IFinder Finder { get; }
    public ITypeElement TypeElement { get; }
    public TypeUsageSearchResult FindResult { get; private set; }
    public GraphBuilder Builder { get; private set; }
    public ConstraintSearcher ConstraintSearcher { get; }
    public ITypeElement TargetTypeElement { get; }
    public ISubstitution Substitution { get; }
    public UseBaseTypeRefactoring(UseBaseTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public IFinder get_Finder();
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
public TypeUsageSearchResult get_FindResult();
    [CompilerGeneratedAttribute]
private void set_FindResult(TypeUsageSearchResult value);
    [CompilerGeneratedAttribute]
public GraphBuilder get_Builder();
    [CompilerGeneratedAttribute]
private void set_Builder(GraphBuilder value);
    [CompilerGeneratedAttribute]
public ConstraintSearcher get_ConstraintSearcher();
    protected virtual UseBaseTypeBase CreateUnsupportedRefactoring();
    public virtual bool Execute(IProgressIndicator pi);
    private void BindUsages(IProgressIndicator pi);
    private void FindTypeElementUsages(IProgressIndicator pi);
    protected virtual UseBaseTypeBase CreateRefactoringInternal(InternalRefactoringLanguageService service);
    [CompilerGeneratedAttribute]
public ITypeElement get_TargetTypeElement();
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    public IDeclaredElement[] GetDeclaredElements(IReference typeReference);
    public ConstraintBase FindSimpleConstraint(ITreeNode directlyUsedElement, bool searchInvocationConstraints);
    public bool CheckConstraintElement(IDeclaredElement element);
    public IDeclaredElement GetDelegateDeclaration(ITreeNode directlyUsedElement);
    public void CreateAnonymousDelegateDependency(IParametersOwner owner, Node node, int index, IParameter& delegateParameter);
    public bool GetConstructedExpression(IReference reference, IExpression& expression);
    public bool GetCastExpressionExpression(IReference reference, IExpression& expression);
    public bool GetTypeOfExpression(IReference reference, IExpression& expression);
    public bool GetIsExpression(IReference reference, IExpression& expression);
    [CompilerGeneratedAttribute]
private TypeUsageSearcherUtil <.ctor>b__2_0(PsiLanguageType language);
    [CompilerGeneratedAttribute]
private ConstraintSearcherUtil <.ctor>b__2_1(PsiLanguageType language);
}
public class JetBrains.ReSharper.Refactorings.UseBaseType.UseBaseTypeWorkflow : DrivenRefactoringWorkflow {
    private UseBaseTypeDataProvider myDataProvider;
    [CompilerGeneratedAttribute]
private UseBaseTypeDataModel <Model>k__BackingField;
    public RefactoringActionGroup ActionGroup { get; }
    public HelpId HelpKeyword { get; }
    public IRefactoringPage FirstPendingRefactoringPage { get; }
    public bool MightModifyManyDocuments { get; }
    public string Title { get; }
    public UseBaseTypeDataModel Model { get; private set; }
    public UseBaseTypeWorkflow(ISolution solution, string actionId);
    public virtual RefactoringActionGroup get_ActionGroup();
    public virtual HelpId get_HelpKeyword();
    public virtual IRefactoringPage get_FirstPendingRefactoringPage();
    public virtual bool get_MightModifyManyDocuments();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public UseBaseTypeDataModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(UseBaseTypeDataModel value);
    public void SetMyDataProvider(UseBaseTypeDataProvider value);
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    private bool IsAvailable(IDataContext context, ITypeElement& ownerClass);
    public virtual bool Initialize(IDataContext context);
    public virtual bool PreExecute(IProgressIndicator progressIndicator);
    public virtual bool PostExecute(IProgressIndicator pi);
    public virtual bool Validate();
}
public abstract class JetBrains.ReSharper.Refactorings.Util.AccessRightsChecker : object {
    protected abstract virtual IAccessContext BuildAccessContext(IReference reference, ITypeElement targetType, ITypeMember& accessedElement, AccessRights accessRights);
    public bool IsSymbolAccessible(AccessRights accessRights, ITypeElement targetType, IReference reference);
}
public static class JetBrains.ReSharper.Refactorings.Util.Binding.RefactoringsBindingUtil : object {
    public static IReference BindWithCleanup(IReference reference, DeclaredElementInstance instance, Func`2<IReference, IReference> tryRemoveQualification);
    public static bool CheckResolvedTo(IReference reference, IDeclaredElement target);
}
public class JetBrains.ReSharper.Refactorings.Util.ClassesHiddenByNewClassFixer : object {
    private IPsiServices myPsiServices;
    private ClrTypeName myNewClassName;
    private OneToSetMap`2<IDeclaredElement, IReference> myReferences;
    public ClassesHiddenByNewClassFixer(IPsiServices psiServices, ClrTypeName newClassName);
    public void SearchTypesAndReferences(IProgressIndicator progressIndicator);
    public void RebindAllReferences(IProgressIndicator progressIndicator);
    private ICollection`1<IDeclaredElement> GetAllSuspiciousTypeElements(IClrTypeName newClassName);
    [CompilerGeneratedAttribute]
private FindExecution <SearchTypesAndReferences>b__4_0(FindResult r);
}
public class JetBrains.ReSharper.Refactorings.Util.CSharpLikeLanguagesUtil : object {
    public static INamespaceDeclaration GetNamespaceDeclaration(ITypeAndNamespaceHolderDeclaration typeAndNamespaceHolder, string searchedName);
}
public static class JetBrains.ReSharper.Refactorings.Util.DependencyUtil : object {
    [ItemNotNullAttribute]
[NotNullAttribute]
public static ITypeMember[] GetDependentTypeMembers(ITypeMember typeMember);
    [NotNullAttribute]
public static DependencyResult AnalyzeDependencies(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.Util.DocumentCollectionUtil : object {
}
public interface JetBrains.ReSharper.Refactorings.Util.ILanguageSpecificProjectFileHandler {
    public abstract virtual void InitializeEmptyFile(IFile file);
}
public interface JetBrains.ReSharper.Refactorings.Util.InstanceObjectUsageChecker {
    public abstract virtual InstanceObjectUsageResult GetCheckResult(ITreeNode element);
}
public interface JetBrains.ReSharper.Refactorings.Util.InstanceObjectUsageResult {
    public bool UsesThisObject { get; }
    public bool UsesBaseObject { get; }
    public abstract virtual bool get_UsesThisObject();
    public abstract virtual bool get_UsesBaseObject();
}
public class JetBrains.ReSharper.Refactorings.Util.IntroducePopupOccurrence : TreeNodePopupOccurrence {
    [CompilerGeneratedAttribute]
private ITreeNode <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITreeNode> <Usages>k__BackingField;
    public ITreeNode Context { get; }
    public IEnumerable`1<ITreeNode> Usages { get; }
    public IntroducePopupOccurrence(string name, string description, ITreeNode treeNode);
    public IntroducePopupOccurrence(ITreeNode context, string name, string description, IList`1<ITreeNode> treeNodes);
    [CompilerGeneratedAttribute]
public ITreeNode get_Context();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITreeNode> get_Usages();
}
public static class JetBrains.ReSharper.Refactorings.Util.IntroduceUtil : object {
    [CanBeNullAttribute]
public static ITreeNode GetContainingLambda(ITreeNode expression);
    public static List`1<IntroducePopupOccurrence> GetOccurrences(IDataContext dataContext, Lifetime lifetime, ITreeNode expression, IList`1<ITreeNode> memberContexts, Func`2<ValueTuple`2<ITreeNode, ITreeNode>, bool> filter);
    public static IEnumerable`1<ITreeNode> FindOccurrences(ITreeNode element, ITreeNode scope, Func`2<ITreeNode, bool> filter);
    public static List`1<WorkflowPopupMenuOccurrence`1<T>> GetOccurrences(IList`1<T[]> usages, Func`2<T, DocumentRange[]> getranges);
    public static ITreeNode SelectExpression(IDataContext context, Lifetime lifetime, IEnumerable`1<ITreeNode> expressions);
    public static IEnumerable`1<IExpression> GetInnerExpressions(IDataContext context, ITreeNode initialTreeNode, Func`3<IExpression, IType, bool> isApplicable);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Refactorings.Util.LanguageSpecificHelper`1 : object {
    private LanguageSpecificUtilProvider`1<LANGUAGE_HELPER> myUtilProvider;
    protected LANGUAGE_HELPER Item { get; }
    public LanguageSpecificHelper`1(LanguageSpecificUtilProvider`1<LANGUAGE_HELPER> utilProvider);
    protected LANGUAGE_HELPER get_Item(PsiLanguageType language);
}
public class JetBrains.ReSharper.Refactorings.Util.LanguageSpecificUtilProvider`1 : MulticastDelegate {
    public LanguageSpecificUtilProvider`1(object object, IntPtr method);
    public virtual T Invoke(PsiLanguageType language);
    public virtual IAsyncResult BeginInvoke(PsiLanguageType language, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Refactorings.Util.MovedElementsCollector : object {
    private JetHashSet`1<IDeclaredElement> myElements;
    public bool ProcessingIsFinished { get; }
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public bool Contains(IDeclaredElement declaredElement);
    public void ProcessDeclaredElement(IDeclaredElement declaredElement);
}
public interface JetBrains.ReSharper.Refactorings.Util.NewTypeImages.IReferenceImage {
    [NotNullAttribute]
public abstract virtual IReference Recover(IReference reference, ResolveResultImage image);
}
public interface JetBrains.ReSharper.Refactorings.Util.NewTypeImages.IResolveImagesLanguageSupport {
    public abstract virtual bool IsFromExtendsList(ITreeNode element);
    public abstract virtual bool IsReferenceName(ITreeNode element);
    public abstract virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public abstract virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public abstract virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
}
public class JetBrains.ReSharper.Refactorings.Util.NewTypeImages.ResolveImagesRepository : object {
    private static int ExtendsListIndex;
    private static int ReferenceNameIndex;
    private static int ReferenceExpressionIndex;
    private static Key`1<DeclaredElementId> ourDeclarationKey;
    private static Key`1<List`1<ResolveResultImage>> ourReferencesKey;
    private Dictionary`2<IDeclaredElement, DeclaredElementId> myElementsId;
    private List`1[] myReferences;
    private Dictionary`2<DeclaredElementId, IDeclaredElement> myNewDeclaredElements;
    private Func`2<PsiLanguageType, IResolveImagesLanguageSupport> myGetLanguageSupport;
    private Dictionary`2<IDeclaredElement, IDeclaredElement> myManuallyMappedElements;
    private UnusedUsingSaver myUsingsSaver;
    [CompilerGeneratedAttribute]
private HashSet`1<IDeclaredElement> <ExternalDeclaredElements>k__BackingField;
    public List`1<ITreeNode> RegisteredCopies;
    public HashSet`1<IDeclaredElement> ExternalDeclaredElements { get; }
    public ResolveImagesRepository(Func`2<PsiLanguageType, IResolveImagesLanguageSupport> getLanguageSupport);
    private static ResolveImagesRepository();
    [CompilerGeneratedAttribute]
public HashSet`1<IDeclaredElement> get_ExternalDeclaredElements();
    public void CommitDeclaration(ITreeNode element);
    public void RemoveNewUnusedUsings(IProgressIndicator progressIndicator);
    private void RemoveNewUnusedUsing(IFile file, HashSet`1<ITreeNode> oldUnusedUsings, IProgressIndicator progress);
    public void MarkReferences(ITreeNode element);
    public void RegisterCopyLazy(ITreeNode element);
    public void RegisterCopy(ITreeNode element);
    public void ForceRegisterCopy(ITreeNode element);
    [CanBeNullAttribute]
public IType Substitute(IType type);
    public void BindReferences(IProgressIndicator progress, ISolution solution);
    private void RegisterElementCopy(ITreeNode element, IReferenceContextCodec referenceContextCodec);
    public void AddRebindableReference(IReference reference, ResolveResultImage image);
    private void InitRebindableReferencesIdentity(ITreeNode element, IReferenceContextCodec referenceContextCodec);
    private void InitDeclaredElementsIdentity(ITreeNode element);
    public void CommitUsagesOfTopmostElements(Func`2<ITreeNode, bool> isInScope, ISolution solution, IProgressIndicator pi, Action`2<List`1<IDeclaredElement>, IPsiServices> addElementsFromCache);
    private void AddIdentity(IDeclaredElement element, IDeclaration declaration);
    public void ProvideManualElementsIdentity(IDeclaredElement oldElement, IDeclaredElement newElement);
    [CanBeNullAttribute]
public IDeclaredElement GetManuallyMappedElement(IDeclaredElement element);
}
public class JetBrains.ReSharper.Refactorings.Util.NewTypeImages.ResolveResultImage : object {
    [CanBeNullAttribute]
private IReferenceImage myReferenceImage;
    [CompilerGeneratedAttribute]
private IReference <OldReference>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveErrorType <ResolveErrorType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ITypeElement, ITypeElement> <LeftTypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ITypeElement, ITypeElement> <RightTypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IDeclaredElement, IDeclaredElement> <NewTypeMemberDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    [NotNullAttribute]
public IReference OldReference { get; }
    [NotNullAttribute]
public ResolveErrorType ResolveErrorType { get; }
    public Func`2<ITypeElement, ITypeElement> LeftTypeMap { get; }
    public Func`2<ITypeElement, ITypeElement> RightTypeMap { get; }
    public Func`2<IDeclaredElement, IDeclaredElement> NewTypeMemberDelegate { get; }
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    public ResolveResultImage(IReference reference, Func`2<ITypeElement, ITypeElement> leftTypeMap, Func`2<ITypeElement, ITypeElement> rightTypeMap, Func`2<IDeclaredElement, IDeclaredElement> newTypeMemberDelegate);
    [CompilerGeneratedAttribute]
public IReference get_OldReference();
    [CompilerGeneratedAttribute]
public ResolveErrorType get_ResolveErrorType();
    [CompilerGeneratedAttribute]
public Func`2<ITypeElement, ITypeElement> get_LeftTypeMap();
    [CompilerGeneratedAttribute]
public Func`2<ITypeElement, ITypeElement> get_RightTypeMap();
    [CompilerGeneratedAttribute]
public Func`2<IDeclaredElement, IDeclaredElement> get_NewTypeMemberDelegate();
    [CompilerGeneratedAttribute]
public IPsiModule get_PsiModule();
    public IReference Recover(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.Util.NewTypeImages.SubstitutionImage : object {
    [CanBeNullAttribute]
private IDeclaredElement myDeclaredElement;
    [CanBeNullAttribute]
private Dictionary`2<ITypeParameter, TypeImage> mySubstitutionImages;
    private bool myNonQualifiedReference;
    public SubstitutionImage(IDeclaredElement declaredElement, ISubstitution substitution, bool nonQualifiedReference);
    public sealed virtual IReference Recover(IReference reference, ResolveResultImage image);
    [NotNullAttribute]
private IReference NormalizeQualifier(IReference reference);
    [NotNullAttribute]
private ISubstitution RecoverSubstitution(ResolveResultImage image);
}
public class JetBrains.ReSharper.Refactorings.Util.NewTypeImages.TypeReferenceImage : Visitor`1<IType> {
    [NotNullAttribute]
private TypeImage myTypeImage;
    [NotNullAttribute]
private ResolveResultImage myResolveImage;
    public TypeReferenceImage(TypeImage typeImage, ResolveResultImage resolveImage);
    public sealed virtual IReference Recover(IReference reference, ResolveResultImage image);
    public virtual IType VisitDeclaredType(DeclaredTypeImage declaredTypeImage);
    public virtual IType VisitArrayType(ArrayTypeImage arrayTypeImage);
    public virtual IType VisitPointerType(PointerTypeImage pointerTypeImage);
    public virtual IType VisitType(TypeImage typeImage);
}
[RequiredMemberAttribute]
public class JetBrains.ReSharper.Refactorings.Util.OriginalParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterKind <Kind>k__BackingField;
    [RequiredMemberAttribute]
public string Name { get; public set; }
    [RequiredMemberAttribute]
public IType Type { get; public set; }
    [RequiredMemberAttribute]
public ParameterKind Kind { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(IType value);
    [CompilerGeneratedAttribute]
public ParameterKind get_Kind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Kind(ParameterKind value);
    public static List`1<OriginalParameter> Collect(IEnumerable`1<IParameter> parameters);
}
public static class JetBrains.ReSharper.Refactorings.Util.PsiUtil : object {
    [CanBeNullAttribute]
public static TTypeDeclaration ChooseDeclaration(TTypeDeclaration defaultDeclaration);
    [CanBeNullAttribute]
public static TTypeDeclaration ChooseDeclaration(ITypeElement typeElement);
    [PureAttribute]
public static bool IsUnderTypeDeclaration(ITreeNode element, ITypeElement containingType);
    public static bool Contains(ITreeRange range);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Util.PsiUtil/<GetReferences>d__4")]
public static IEnumerable`1<IReference> GetReferences(ITreeRange treeRange);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Util.PsiUtil/<GetReferences>d__5")]
public static IEnumerable`1<IReference> GetReferences(ITreeNode element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.Util.PsiUtil/<GetNonQualifiedReferences>d__6")]
public static IEnumerable`1<IReference> GetNonQualifiedReferences(ITreeRange treeRange);
}
public class JetBrains.ReSharper.Refactorings.Util.QName : ValueType {
    private string myString;
    private StringComparison myComparison;
    public QName(string string, StringComparison comparison);
    [PureAttribute]
public bool HasPrefix(QName other);
    [PureAttribute]
public bool HasPostfix(QName other);
    [PureAttribute]
public QName Append(QName other);
    [PureAttribute]
public QName ChopPrefix(QName other);
    [PureAttribute]
public QName ChopPostfix(QName other);
    [PureAttribute]
public virtual string ToString();
    public virtual bool Equals(object obj);
    public bool Equals(QName name);
    public static bool op_Equality(QName left, QName right);
    public static bool op_Inequality(QName left, QName right);
    public virtual int GetHashCode();
    public static string op_Implicit(QName qName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Refactorings.Util.ReferenceBinding : ValueType {
    private IDeclaredElementPointer`1<IDeclaredElement> myDeclaredElementPointer;
    private ISubstitution mySubstitution;
    private IReferencePointer myReferencePointer;
    public ReferenceBinding(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution);
    [NullableContextAttribute("2")]
public bool TryEnsureResolve(IReference& conflictReference, IDeclaredElement& targetDeclaredElement);
}
public static class JetBrains.ReSharper.Refactorings.Util.ReferenceCollectorUtil : object {
    [NotNullAttribute]
public static IList`1<TReference> Process(ITreeNode element);
    [NotNullAttribute]
public static IList`1<IReference> Process(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.Util.ReferencedElementsCollector : object {
    private bool myOnlyNonQualified;
    private List`1<IReference> myReferences;
    private JetHashSet`1<IDeclaredElement> myDeclaredElements;
    public IDeclaredElement[] ReferencedElements { get; }
    public bool ProcessingIsFinished { get; }
    public ReferencedElementsCollector(bool onlyNonQualified);
    public IDeclaredElement[] get_ReferencedElements();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public static class JetBrains.ReSharper.Refactorings.Util.ReferenceOwnerSorter : object {
    [NotNullAttribute]
public static List`1<T> Sort(IEnumerable`1<T> references, Func`2<T, IReference> getReference, PsiLanguageType language);
}
public class JetBrains.ReSharper.Refactorings.Util.ReferenceOwnerSorterUtil`1 : object {
    [NotNullAttribute]
private List`1<T> myList;
    [NotNullAttribute]
private OneToListMap`2<ITreeNode, IReference> myReferences;
    [NotNullAttribute]
private Func`2<T, IReference> myGetReference;
    [NotNullAttribute]
private ReferenceComparatorDelegate myComparator;
    public ReferenceOwnerSorterUtil`1(IEnumerable`1<T> references, Func`2<T, IReference> getReference, ReferenceComparatorDelegate comparator);
    public List`1<T> Sort();
    [CompilerGeneratedAttribute]
private int <Sort>b__5_0(T r1, T r2);
}
public static class JetBrains.ReSharper.Refactorings.Util.ReferenceUpdateUtil : object {
    public static void UpdateReferences(ReferenceIdentitySaver saver, IImageCollector executer, ITypeElement targetTypeElement, IProgressIndicator pi);
}
public static class JetBrains.ReSharper.Refactorings.Util.SuperTypesUtil : object {
    public static void ProcessTypeAndSuperTypes(ITypeElement typeElement, TypeElementHandler handle);
    public static void ProcessClassAndSuperClasses(IClass class, Action`1<IClass> handle);
    public static void ProcessTypeAndBaseClassesAndInterfaces(ITypeElement typeElement, TypeElementHandler handle);
    private static void ProcessTypeAndBaseClassesAndInterfaces(JetHashSet`1<ITypeElement> visited, ITypeElement element, TypeElementHandler handle);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeElementHandler : MulticastDelegate {
    public TypeElementHandler(object object, IntPtr method);
    public virtual void Invoke(ITypeElement superClass);
    public virtual IAsyncResult BeginInvoke(ITypeElement superClass, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.AnonymousTypeImage : TypeImage {
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    public IPsiModule PsiModule { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public AnonymousTypeImage(IPsiModule module);
    public virtual T Accept(Visitor`1<T> visitor);
    [CompilerGeneratedAttribute]
public virtual IPsiModule get_PsiModule();
    public virtual TypeDecorationSet get_TypeDecorations();
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.ArrayTypeImage : TypeImage {
    [CompilerGeneratedAttribute]
private TypeImage <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDecorationSet <TypeDecorations>k__BackingField;
    public IPsiModule PsiModule { get; }
    [NotNullAttribute]
public TypeImage ElementType { get; }
    public int Rank { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public ArrayTypeImage(IArrayType arrayType);
    public virtual IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public TypeImage get_ElementType();
    [CompilerGeneratedAttribute]
public int get_Rank();
    [CompilerGeneratedAttribute]
public virtual TypeDecorationSet get_TypeDecorations();
    public virtual T Accept(Visitor`1<T> visitor);
}
public abstract class JetBrains.ReSharper.Refactorings.Util.TypeImages.BaseResolveResultImage : object {
    protected ResolveErrorType myType;
    protected bool myWasRebinded;
    protected IPsiServices myPsiServices;
    public bool WasRebinded { get; }
    public IDeclaredElement InitialTypeElement { get; }
    public ResolveErrorType OldErrorType { get; }
    protected BaseResolveResultImage(ResolveErrorType type, IPsiServices psiServices);
    public bool get_WasRebinded();
    public virtual IDeclaredElement get_InitialTypeElement();
    public ResolveErrorType get_OldErrorType();
    public IResolveResult Recover(MemberImagesProvider memberImagesProvider, ImageProviderOfTypeElement imageProvider, IReference updatedReference, ITypeElement targetType, IReference& rebindedReference, bool substType);
    protected abstract virtual IResolveResult RecoverInternal(MemberImagesProvider memberImagesProvider, ImageProviderOfTypeElement imageProvider, IReference reference, ITypeElement targetType, IReference& rebindedReference, bool substType);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.DeclaredTypeImage : TypeImage {
    [CompilerGeneratedAttribute]
private IDeclaredType <UnresolvedType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ITypeParameter, TypeImage> <SubstitutionImage>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDecorationSet <TypeDecorations>k__BackingField;
    [CanBeNullAttribute]
public IDeclaredType UnresolvedType { get; }
    [CanBeNullAttribute]
public ITypeElement TypeElement { get; }
    [NotNullAttribute]
public Dictionary`2<ITypeParameter, TypeImage> SubstitutionImage { get; }
    public IPsiModule PsiModule { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public DeclaredTypeImage(IDeclaredType declaredType);
    [CompilerGeneratedAttribute]
public IDeclaredType get_UnresolvedType();
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
public Dictionary`2<ITypeParameter, TypeImage> get_SubstitutionImage();
    [CompilerGeneratedAttribute]
public virtual IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public virtual TypeDecorationSet get_TypeDecorations();
    public virtual T Accept(Visitor`1<T> visitor);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.IDResolveResultImage : BaseResolveResultImage {
    private IResolveResult myResult;
    public IDResolveResultImage(ResolveErrorType type, IResolveResult result, IPsiServices psiServices);
    protected virtual IResolveResult RecoverInternal(MemberImagesProvider memberImagesProvider, ImageProviderOfTypeElement imageProvider, IReference reference, ITypeElement targetType, IReference& rebindedReference, bool substType);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.ImageProviderOfTypeElement : MulticastDelegate {
    public ImageProviderOfTypeElement(object object, IntPtr method);
    public virtual TypeImageProvider Invoke(ITypeElement targetTypeElement);
    public virtual IAsyncResult BeginInvoke(ITypeElement targetTypeElement, AsyncCallback callback, object object);
    public virtual TypeImageProvider EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.MemberImagesProvider : MulticastDelegate {
    public MemberImagesProvider(object object, IntPtr method);
    public virtual IEnumerable`1<IDeclaredElement> Invoke(IDeclaredElement oldMember, ITypeElement target);
    public virtual IAsyncResult BeginInvoke(IDeclaredElement oldMember, ITypeElement target, AsyncCallback callback, object object);
    public virtual IEnumerable`1<IDeclaredElement> EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.PointerTypeImage : TypeImage {
    [CompilerGeneratedAttribute]
private TypeImage <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDecorationSet <TypeDecorations>k__BackingField;
    public TypeImage ElementType { get; }
    public IPsiModule PsiModule { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public PointerTypeImage(IPointerType pointerType);
    [CompilerGeneratedAttribute]
public TypeImage get_ElementType();
    public virtual IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public virtual TypeDecorationSet get_TypeDecorations();
    public virtual T Accept(Visitor`1<T> visitor);
}
public static class JetBrains.ReSharper.Refactorings.Util.TypeImages.ResolveResultImages : object {
    public static BaseResolveResultImage CreateImage(IResolveResult resolveResult, ResolveErrorType resolveErrorType, IReference originalReference, IPsiServices psiServices, bool toMovedElement);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.SubstitutionImage : object {
    [NotNullAttribute]
private Dictionary`2<ITypeParameter, TypeImage> mySubstitutionImage;
    public SubstitutionImage(ISubstitution substitution);
    [NotNullAttribute]
public ISubstitution Recover(TypeImageProvider provider, IDeclaredElement typeMember);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.TypeElementImage : object {
    private ITypeElement myOldTypeElement;
    private IList`1<TypeElementImage> myTypeParameterImages;
    private Dictionary`2<Pair`2<string, int>, TypeElementImage> myInnerTypeImages;
    public ITypeElement OldTypeElement { get; }
    public ITypeElement[] NestedTypeElements { get; }
    public TypeElementImage(ITypeElement oldTypeElement);
    public ITypeElement get_OldTypeElement();
    private void GetNestedTypeElements(JetHashSet`1<ITypeElement> result);
    public ITypeElement[] get_NestedTypeElements();
    private void Recover(ITypeElement newTypeElement, ExternalRecoverer externalRecoverer, Dictionary`2<ITypeElement, ITypeElement> result);
    public IDictionary`2<ITypeElement, ITypeElement> Recover(ITypeElement newTypeElement, ExternalRecoverer externalRecoverer);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.TypeElementResolveResultImage : BaseResolveResultImage {
    private DeclaredTypeImage myImage;
    public IDeclaredElement InitialTypeElement { get; }
    public TypeElementResolveResultImage(ResolveErrorType type, DeclaredTypeImage image, IPsiServices psiServices);
    public virtual IDeclaredElement get_InitialTypeElement();
    protected virtual IResolveResult RecoverInternal(MemberImagesProvider memberImagesProvider, ImageProviderOfTypeElement imageProvider, IReference reference, ITypeElement targetType, IReference& rebindedReference, bool substType);
}
public abstract class JetBrains.ReSharper.Refactorings.Util.TypeImages.TypeImage : object {
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    [NotNullAttribute]
public TypeDecorationSet TypeDecorations { get; }
    [NotNullAttribute]
[PureAttribute]
public static TypeImage Create(IType type);
    public abstract virtual T Accept(Visitor`1<T> visitor);
    public abstract virtual IPsiModule get_PsiModule();
    public abstract virtual TypeDecorationSet get_TypeDecorations();
}
[CanBeNullAttribute]
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.TypeImageProvider : MulticastDelegate {
    public TypeImageProvider(object object, IntPtr method);
    public virtual ITypeElement Invoke(ITypeElement oldTypeElement);
    public virtual IAsyncResult BeginInvoke(ITypeElement oldTypeElement, AsyncCallback callback, object object);
    public virtual ITypeElement EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.TypeMemberResolveResultImage : BaseResolveResultImage {
    private ITypeMember myMember;
    private SubstitutionImage mySubstitutionImage;
    public IDeclaredElement InitialTypeElement { get; }
    public TypeMemberResolveResultImage(ResolveErrorType type, ITypeMember member, IPsiServices psiServices, ISubstitution substitution);
    public virtual IDeclaredElement get_InitialTypeElement();
    protected virtual IResolveResult RecoverInternal(MemberImagesProvider memberImagesProvider, ImageProviderOfTypeElement imageProvider, IReference reference, ITypeElement targetType, IReference& rebindedReference, bool substType);
}
public class JetBrains.ReSharper.Refactorings.Util.TypeImages.TypeRecoverer : Visitor`1<IType> {
    private bool mySubstRight;
    private TypeImageProvider myImageProvider;
    public TypeRecoverer(TypeImageProvider imageProvider, bool substRight);
    public virtual IType VisitArrayType(ArrayTypeImage arrayTypeImage);
    public virtual IType VisitPointerType(PointerTypeImage pointerTypeImage);
    [NotNullAttribute]
public virtual IType VisitDeclaredType(DeclaredTypeImage declaredTypeImage);
    [NotNullAttribute]
public ISubstitution GetNewSubstitution(Dictionary`2<ITypeParameter, TypeImage> substitutionImage, IEnumerable`1<ITypeParameter> newTypeParameter, bool left);
    public virtual IType VisitType(TypeImage typeImage);
}
public abstract class JetBrains.ReSharper.Refactorings.Util.TypeImages.Visitor`1 : object {
    public abstract virtual T VisitType(TypeImage typeImage);
    public virtual T VisitDeclaredType(DeclaredTypeImage declaredTypeImage);
    public virtual T VisitArrayType(ArrayTypeImage arrayTypeImage);
    public virtual T VisitPointerType(PointerTypeImage pointerTypeImage);
}
public class JetBrains.ReSharper.Refactorings.Util.VisibilityUtil : object {
    public static bool TargetTypeAccessible(ITreeNode accessPoint, ITypeElement targetType);
}
public abstract class JetBrains.ReSharper.Refactorings.Workflow.DrivenRefactoring`2 : DrivenRefactoringBase`1<TWorkflow> {
    [CompilerGeneratedAttribute]
private ConstructorsMap <Constructors>k__BackingField;
    [CompilerGeneratedAttribute]
private LanguageMapOfRefactoring`1<TRefactoring> <Exec>k__BackingField;
    [NotNullAttribute]
protected ConstructorsMap Constructors { get; }
    [NotNullAttribute]
public LanguageMapOfRefactoring`1<TRefactoring> Exec { get; }
    protected DrivenRefactoring`2(TWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
protected ConstructorsMap get_Constructors();
    [CompilerGeneratedAttribute]
public LanguageMapOfRefactoring`1<TRefactoring> get_Exec();
    [CanBeNullAttribute]
protected virtual TRefactoring CreateUnsupportedRefactoring();
    [NotNullAttribute]
[DebuggerStepThroughAttribute]
protected static RefactoringsHelper GetHelper(PsiLanguageType language);
    [CanBeNullAttribute]
protected virtual TRefactoring CreateRefactoringInternal(InternalRefactoringLanguageService service);
    [CanBeNullAttribute]
protected virtual TRefactoring CreateRefactoring(IRefactoringLanguageService service);
    [CompilerGeneratedAttribute]
private TRefactoring <.ctor>b__6_0(IRefactoringLanguageService refactoringLanguageService);
}
public abstract class JetBrains.ReSharper.Refactorings.Workflow.InternalRefactoringLanguageService : object {
    [CanBeNullAttribute]
public RefactoringsHelper Helper { get; }
    [CanBeNullAttribute]
public static InternalRefactoringLanguageService Get(PsiLanguageType languageType);
    public virtual RefactoringsHelper get_Helper();
    [CanBeNullAttribute]
public virtual IMoveTypeToOuterScope MoveTypeToOuterScope(MoveTypeToOuterScopeRefactoring refactoring);
    [CanBeNullAttribute]
public virtual IConvertRefactoring Property2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IConvertRefactoring Indexer2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IConvertRefactoring Function2Property(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IPullUp PullUpRefactoring(ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IPushDown PushDownRefactoring(ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IConvertRefactoring Function2Indexer(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IRefactoringPage GetFunction2PropertyUI(Function2PropertyWorkflow workflow);
    [CanBeNullAttribute]
public virtual IExtractSuperclass ExtractSuperclassRefactoring(ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IExtractInterface ExtractInterfaceRefactoring(ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IConvert CreateAbstract2Interface(Abstract2InterfaceWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IConvert CreateInterface2Abstract(Interface2AbstractWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual TransformParametersBase CreateTransformParameters(TransformParametersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IntroduceVariableBase CreateIntroduceVariable(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual Static2ExtensionBase CreateStatic2Extension(Static2ExtensionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual ConstructorToFactoryMethodBase CreateConstructor2FactoryMethod(Constructor2FactoryMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual UseBaseTypeBase CreateUseBaseType(UseBaseTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual EncapsulateFieldBase CreateEncapsulateField(EncapsulateFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual MoveStaticMembers CreateMoveStaticMembers(MoveStaticMembersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual MoveStaticMembersHelper CreateMoveStaticMembersHelper();
    [CanBeNullAttribute]
public virtual Property2AutoBase CreateProperty2Auto(Property2AutoWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual Anonymous2Declared CreateAnonymous2Declared(Anonymous2DeclaredWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual InlineMethod CreateInlineMethod(InlineMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IntroduceParameterBase CreateIntroRefactoring(IntroduceParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual IntroduceFieldBase CreateIntroduceField(IntroduceFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual InlineFieldBase CreateInlineField(InlineFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual InlineVarBase CreateInlineVar(InlineVarWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual InlineParameterBase CreateInlineParameter(InlineParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual SafeDeleteBase CreateSafeDeleteBase(SafeDeleteWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual MakeStatic CreateMakeStaticHelper(MakeStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual ParamsModifierConvertBase CreateParamsModifier(ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual InlineParameterHelper CreateInlineParameterHelper();
    [CanBeNullAttribute]
public virtual IMakeStaticHelper CreateMakeStaticHelper();
    [CanBeNullAttribute]
public virtual SafeDeleteHelperUnsupported CreateSafeDeleteHelper();
    [CanBeNullAttribute]
public virtual AdjustNamespacesHelperBase CreateAdjustNamespaceHelper();
    [CanBeNullAttribute]
public virtual MoveIntoMatchingFilesHelperBase CreateMoveIntoMatchingFilesHelper();
    [CanBeNullAttribute]
public virtual MoveToFileHelperBase CreateMoveToFileHelper();
    [CanBeNullAttribute]
public virtual MoveToFolderHelperBase CreateMoveToFolderHelper();
    [CanBeNullAttribute]
public virtual MoveToNamespaceHelperBase CreateMoveToNamespaceHelper();
    [CanBeNullAttribute]
public virtual IntroduceVariableHelper CreateIntroduceVariableHelper();
    [CanBeNullAttribute]
public virtual RenameHelperBase CreateRenameHelper();
    [CanBeNullAttribute]
public virtual ExtractClassHelper CreateExtractClassHelper(ExtractClassWorkflow workflow);
    [CanBeNullAttribute]
public virtual ExtractClassRefactoringExec ExtractClassExec(ExtractClassWorkflow workflow, IRefactoringDriver driver);
    [CanBeNullAttribute]
public virtual InlineClassHelper CreateInlineClassHelper(InlineClassWorkflow inlineClassWorkflow);
    [CanBeNullAttribute]
public virtual IInlineClassRefactoringExec InlineClassExec(InlineClassWorkflow workflow);
    [CanBeNullAttribute]
public virtual MoveInstanceMethodHelper CreateMoveInstanceMethodHelper(MoveInstanceMethodWorkflow moveInstanceMethodWorkflow);
    [CanBeNullAttribute]
public virtual RenameFileHelper CreateRenameFileHelper(RenameFileWorkflow renameFileWorkflow);
    [CanBeNullAttribute]
public virtual InvertBoolHelper CreateInvertBoolHelper(InvertBoolWorkflow invertBoolWorkflow);
    [CanBeNullAttribute]
public virtual IType2PartialHelper CreateType2Partial(Type2PartialWorkflow type2PartialWorkflow);
    [CanBeNullAttribute]
public virtual IUnresolvedTypesChooser GetUnresolvedTypesChooser(ITreeNode context);
    public sealed virtual bool IsAvailable();
}
public abstract class JetBrains.ReSharper.Refactorings.Workflow.RefactoringAction : object {
    [NotNullAttribute]
private Action`1<IDataContext> myAfterRefactoringExecuted;
    [NotNullAttribute]
private Func`2<ISolution, IRefactoringWorkflow> myCreateWorkflow;
    [NotNullAttribute]
private Action`1<IDataContext> AfterRefactoringExecuted { get; }
    protected RefactoringAction(Func`2<ISolution, IRefactoringWorkflow> createWorkflow);
    private Action`1<IDataContext> get_AfterRefactoringExecuted();
    public virtual void SetPresentation(IDataContext context, ActionPresentation presentation);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual IActionRequirement GetRequirement(IDataContext dataContext);
}
public static class JetBrains.ReSharper.Refactorings.Workflow.RefactoringInvocator : object {
    public static T TryExecute(string actionID, Func`1<T> func, T defaultValue);
}
public class JetBrains.ReSharper.Refactorings.Workflow.RefactoringsHelper : object {
    [NotNullAttribute]
[PureAttribute]
[DebuggerStepThroughAttribute]
public static RefactoringsHelper GetHelper(PsiLanguageType language);
    public virtual bool ExtensionMethodsSupported(ITypeDeclaration typeDeclaration);
    [CanBeNullAttribute]
public virtual IProperty2AutoChecker CreateProperty2AutoChecker();
    public virtual bool IndexerIsPresented();
    public virtual string GetMakeMethodNonStaticTitle();
    public virtual bool CheckAnonymous2Declared(IDataContext context, ITreeNode& objectCreationElement);
    public virtual bool CheckForIntroduceAccessible(ITreeNode expression, IParametersOwner parametersOwner);
    [NotNullAttribute]
[ItemNotNullAttribute]
public virtual IReadOnlyList`1<IParametersOwnerDeclaration> GetIntroduceParameterCandidates(IExpression sourceExpression);
    public virtual bool DeclarationHasBody(IDeclaredElement element);
    public virtual bool Function2PropertyAvailable(IMethod method);
    [CanBeNullAttribute]
public virtual ITreeNode GetContainingLambda(ITreeNode expression);
    [CanBeNullAttribute]
public virtual INamespaceRedundancyProblemFixer NamespaceRedundancyFileFixer(INamespace namespace, IFile file);
    [CanBeNullAttribute]
public virtual IExpression IntroParameterGetInitializer(ILocalVariable variable);
    public virtual bool CanUseExplicitly(IType type, ITreeNode context);
    [NotNullAttribute]
public virtual IEnumerable`1<IDeclaredElement> GetLocals(IExpression expression, IParametersOwner owner);
    [NotNullAttribute]
public virtual IDeclaredElement GetPrimaryQueryElement(IDeclaredElement variable);
    [CanBeNullAttribute]
[PureAttribute]
public virtual IConstructor TryGetPrimaryConstructor(ITypeElement typeElement);
    public virtual bool IsLocalVariable(IDeclaredElement element);
    public virtual bool IsPartialMethod(ITypeMember member);
    public virtual bool IsLocalFunction(IParametersOwner parametersOwner);
    public virtual bool IsValidMember(ITypeMember member);
    public virtual TMethod GetMainElement(TMethod method);
    public virtual bool CanBeInlined(IDeclaredElement element);
    public virtual ITypeDeclaration GetTypeDeclarationForField(ITypeDeclaration typeDeclaration, Boolean& baseTypeChoosed);
    [NotNullAttribute]
public virtual IntroduceFieldAnalyser CreateIntroFieldAnalyser();
    public virtual bool CanUseInstanceFields(ITreeNode declaration);
    public virtual bool ReferencesRangeVariables(IExpression expression);
    public virtual bool CanUseRecordType(ITreeNode context, bool requireInitOnlyMembers);
    [CanBeNullAttribute]
public virtual ITreeNode GetStatementVisibleForAll(IReadOnlyList`1<IExpression> expressions);
    [CanBeNullAttribute]
public virtual ITreeNode GetContainingStatementEnsureableNode(IReadOnlyList`1<IExpression> expressions);
    public virtual bool GetShouldBeConstant(IExpression expression);
    public virtual string PresentAccessRights(AccessRights rights, bool useMnemonics);
    public virtual bool IsIterator(IDeclaration declaration);
    public virtual bool InitializerIsRecursive(IDeclaredElement element);
    [CanBeNullAttribute]
public virtual IArgumentsOwner GetArgumentsOwner(IReference& reference, bool replaceMethodGroup);
    public virtual bool IsNew(IDeclaration declaration);
    public virtual void SetNew(ITypeMemberDeclaration typeMember, bool isNew);
    [CanBeNullAttribute]
public virtual InlineVarAnalyserBase CreateInlineVarAnalyser(InlineVarWorkflow workflow);
    public virtual bool IsInvocationReference(IReference reference);
    public virtual bool IsNonQualifiedStaticMemberReference(IReference reference);
    public virtual IReference RemoveQualification(IReference reference);
    public virtual IReference AddQualification(IReference reference);
    public virtual bool FailOnReferencesToLocals(IExpression expression);
    public virtual bool CanContainExtensionMethods(IClass classType, IMethod candidate);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual bool HasIndexerToFunction();
    public virtual bool CanExtractSuperclass(IDeclaration declaration);
    public virtual DocumentRange GetSignatureRange(IDeclaration declaration);
    public virtual bool IsAsyncMethod(ITypeMember method);
    public virtual bool CanBeDefaultParameter(IExpression expression);
    public virtual bool CanHaveDefaultProperty();
    [PureAttribute]
public virtual bool CanIntroduceVariableFrom(IExpression expression);
    [PureAttribute]
public virtual bool CanIntroduceFieldFrom(IExpression expression);
    [PureAttribute]
public virtual bool CanIntroduceFieldFrom(ILocalVariable localVariable);
    [PureAttribute]
public virtual bool CanIntroduceFieldFrom(IParameter parameter);
    [PureAttribute]
public virtual bool IsValidIntroduceInnerExpression(IExpression expression);
    [PureAttribute]
public virtual bool IsValidIntroduceExpressionType(IType expressionType);
    [CanBeNullAttribute]
public virtual IType GetParameterType(IExpression selectedExpression);
    public virtual bool CanInlineVariable(IDeclaredElement declaredElement);
    public virtual bool CanInlineField(IField field);
    [NotNullAttribute]
public virtual IType GetVariableTypeWithEffectiveNullability(ILocalVariable variable);
    public virtual void EnsureNullableAnalysisIsFinished(IExpression expression);
    public virtual bool CanHaveAccessRights(AccessRights accessRights, ITreeNode treeNode);
    [PureAttribute]
public virtual bool CanSafelyBeMadeStatic(IMethod method);
    [PureAttribute]
public virtual bool IsSupportedExtensionMethodQualifierParameterKind(IParameter parameter);
    [CanBeNullAttribute]
public virtual IType GetITypeOrFunctionType(IExpressionType expressionType);
    public virtual bool CanBeParamsParameter(IParameter parameter);
    [CompilerGeneratedAttribute]
internal static bool <GetIntroduceParameterCandidates>g__IsValidTypeMember|7_0(IDeclaredElement containingTypeMember);
}
public static class JetBrains.ReSharper.Refactorings.Workflow.RefactoringWorkflowUtil : object {
    public static bool CheckInheritance(IDeclaredElement& declaredElement, string caption);
    public static CustomHighlightingRequest GetHighlightingRequest(ITextControl textControl, IEnumerable`1<DocumentRange> elementRanges, bool unhighlightOnDocumentChange, ISolution solution);
    [CanBeNullAttribute]
public static TTypeDeclaration GetTypeDeclaration(IDataContext context, Boolean& invokedFromCode);
    public static void UnhighlightRequest(CustomHighlightingRequest highlightingRequest, ISolution solution);
}
public class JetBrains.ReSharper.Refactorings.Workflow.SequencePages : SingleBeRefactoringPage {
    private Func`2[] myNextPages;
    [CompilerGeneratedAttribute]
private IRefactoringPage <FirstPage>k__BackingField;
    public IRefactoringPage FirstPage { get; }
    public string Description { get; }
    public string PageDescription { get; }
    public string Title { get; }
    public bool DoNotShow { get; }
    public SequencePages(IRefactoringPage firstPage, Lifetime lifetime, Func`2[] nextPages);
    public SequencePages(IList`1<IRefactoringPage> sequence, Lifetime lifetime);
    public static IRefactoringPage CreateFromCallbacks(Lifetime lifetime, IProgressIndicator pi, Func`2[] nextPages);
    [CompilerGeneratedAttribute]
public IRefactoringPage get_FirstPage();
    public virtual string get_Description();
    public virtual string get_PageDescription();
    public virtual string get_Title();
    public virtual bool get_DoNotShow();
    public virtual IRefactoringPage Commit(IProgressIndicator pi);
    public bool Initialize(IProgressIndicator pi);
    public virtual bool RefreshContents(IProgressIndicator pi);
    public virtual BeControl GetPageContent();
}
public class JetBrains.ReSharper.Refactorings.Workflow.TextualRefactoringChange : object {
    [CompilerGeneratedAttribute]
private bool <Included>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OriginalLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IRangeMarker <RangeMarker>k__BackingField;
    public bool Included { get; public set; }
    public int OriginalLength { get; }
    public IRangeMarker RangeMarker { get; public set; }
    public TextualRefactoringChange(FindResultText occurrence, DocumentManager documentManager);
    [CompilerGeneratedAttribute]
public bool get_Included();
    [CompilerGeneratedAttribute]
public void set_Included(bool value);
    [CompilerGeneratedAttribute]
public int get_OriginalLength();
    [CompilerGeneratedAttribute]
public IRangeMarker get_RangeMarker();
    [CompilerGeneratedAttribute]
public void set_RangeMarker(IRangeMarker value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[SolutionComponentAttribute("10")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Refactorings.WorkflowNew.BeRefactoringActionHostProvider : object {
    private RefactoringInteractionModel myRefactoringInteraction;
    private IUIApplication myEnvironment;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsApplicable>k__BackingField;
    public IProperty`1<bool> IsApplicable { get; }
    public BeRefactoringActionHostProvider(ISolution solution, ProductConfigurations configurations, IUIApplication environment, ISettingsStore settingsStore, Lifetime lifetime);
    public virtual void ExecuteRefactoring(IDataContext context, IRefactoringWorkflow workflow);
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsApplicable();
}
public class JetBrains.ReSharper.Refactorings.WorkflowNew.BeRefactoringsTaskExecutor : object {
    private BeRefactoringForm myForm;
    public LifetimeDefinition DisposablesGlobal;
    public IProperty`1<TaskHelperExecutionState> State;
    public BeRefactoringsTaskExecutor(BeRefactoringForm form, IUIApplication environment);
    public sealed virtual void Dispose();
    public sealed virtual bool ExecuteTask(string name, TaskCancelable cancelable, Action`1<IProgressIndicator> task);
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable PushProgressCanceledInterruptableCookie(IProgressIndicator pi, TaskThreadAffinity threadAffinity);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0();
}
public interface JetBrains.ReSharper.Refactorings.WorkflowNew.IIntroduceItems`1 {
    public T Expression { get; }
    public List`1<T> Usages { get; }
    public List`1<T> MoreUsages { get; }
    public abstract virtual T get_Expression();
    public abstract virtual List`1<T> get_Usages();
    public abstract virtual List`1<T> get_MoreUsages();
}
public interface JetBrains.ReSharper.Refactorings.WorkflowNew.IIntroduceNodes {
}
public interface JetBrains.ReSharper.Refactorings.WorkflowNew.IIntroduceOccurencesPresentation {
    public abstract virtual RichText GetMenuText();
    public abstract virtual RichText GetTooltip();
}
public interface JetBrains.ReSharper.Refactorings.WorkflowNew.IIntroduceWorkflowWithOccurrences {
    public bool HasManyUsages { get; }
    public CustomHighlightingRequest HighlightingRequest { get; public set; }
    public ITextControl TextControl { get; }
    public ISolution Solution { get; }
    public abstract virtual bool get_HasManyUsages();
    public abstract virtual CustomHighlightingRequest get_HighlightingRequest();
    public abstract virtual void set_HighlightingRequest(CustomHighlightingRequest value);
    public abstract virtual ITextControl get_TextControl();
    public abstract virtual ISolution get_Solution();
    public abstract virtual void SetIndex(SelectedOccurrences value);
    public abstract virtual bool Initialize(IDataContext context);
    public abstract virtual IIntroduceOccurencesPresentation TryCreateSelectedOccurences(SelectedOccurrences value);
    public abstract virtual IEnumerable`1<DocumentRange> GetRangesForHighlighting(SelectedOccurrences value);
}
public class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceActionFromMenu : object {
    [CompilerGeneratedAttribute]
private RichText <Presentation>k__BackingField;
    [CompilerGeneratedAttribute]
private RichText <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectedOccurrences <ReplaceAll>k__BackingField;
    [NotNullAttribute]
protected IIntroduceWorkflowWithOccurrences myWorkflow;
    [NotNullAttribute]
public RichText Presentation { get; }
    [NotNullAttribute]
public RichText Description { get; }
    public SelectedOccurrences ReplaceAll { get; }
    public IntroduceActionFromMenu(IIntroduceWorkflowWithOccurrences workflow, RichText presentation, RichText description, SelectedOccurrences index);
    [CompilerGeneratedAttribute]
public RichText get_Presentation();
    [CompilerGeneratedAttribute]
public RichText get_Description();
    [CompilerGeneratedAttribute]
public SelectedOccurrences get_ReplaceAll();
    public virtual void Execute(IDataContext context);
}
public class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceExpressionOccurencesPresentation : IntroduceOccurencesPresentationBase {
    public IntroduceExpressionOccurencesPresentation(IntroduceOccurences introduceOccurences);
    public virtual RichText GetTooltip();
}
public class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceNamespacePresentation : IntroduceOccurencesPresentationBase {
    public IntroduceNamespacePresentation(IntroduceOccurences introduceOccurences);
    public virtual RichText GetTooltip();
}
public class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceOccurences : ValueType {
    public SelectedOccurrences SelectedOccurenesKind;
    public int UsagesCount;
}
public abstract class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceOccurencesPresentationBase : object {
    [CompilerGeneratedAttribute]
private IntroduceOccurences <IntroduceOccurences>k__BackingField;
    protected IntroduceOccurences IntroduceOccurences { get; }
    protected IntroduceOccurencesPresentationBase(IntroduceOccurences introduceOccurences);
    [CompilerGeneratedAttribute]
protected IntroduceOccurences get_IntroduceOccurences();
    public sealed virtual RichText GetMenuText();
    public abstract virtual RichText GetTooltip();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceOccurencesUtil : object {
    [ExtensionAttribute]
public static IIntroduceOccurencesPresentation PresentExpressionOccurences(Nullable`1<IntroduceOccurences> occurences);
    [ExtensionAttribute]
public static IIntroduceOccurencesPresentation PresentTypeOccurences(Nullable`1<IntroduceOccurences> occurences);
    [ExtensionAttribute]
public static IIntroduceOccurencesPresentation PresentNamespaceOccurences(Nullable`1<IntroduceOccurences> occurences);
}
public class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceTypeOccurencesPresentation : IntroduceOccurencesPresentationBase {
    public IntroduceTypeOccurencesPresentation(IntroduceOccurences introduceOccurences);
    public virtual RichText GetTooltip();
}
public abstract class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceWithOccurrencesAction`1 : ExtensibleRefactoringAction`1<TRefactoringWorkflowProvider> {
    private static void SetHighlightingForOccurrences(IIntroduceWorkflowWithOccurrences workflow, SelectedOccurrences highlight);
    private static void RemoveOldHighlighting(IIntroduceWorkflowWithOccurrences workflow);
    protected virtual void Execute(IDataContext context, IRefactoringWorkflow refactoringWorkflow);
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
protected virtual IList`1<IntroduceActionFromMenu> GetWorkflowActions(IIntroduceWorkflowWithOccurrences workflow);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Refactorings.WorkflowNew.IntroduceWorkflowWithPsiNodesUtil : object {
    [ExtensionAttribute]
public static Nullable`1<IntroduceOccurences> TryCreateNodeOccurences(IIntroduceItems`1<T> nodes, SelectedOccurrences value);
    [ExtensionAttribute]
public static IEnumerable`1<DocumentRange> GetRangesForNodes(IIntroduceItems`1<T> nodes, SelectedOccurrences value);
}
public interface JetBrains.ReSharper.Refactorings.WorkflowNew.IRefactoringConfiguration {
    [CanBeNullAttribute]
public abstract virtual IRefactoringConfiguration GetNextConfiguration(IRefactoringWorkflow refactoringWorkflow);
}
public enum JetBrains.ReSharper.Refactorings.WorkflowNew.SelectedOccurrences : Enum {
    public int value__;
    public static SelectedOccurrences One;
    public static SelectedOccurrences More;
    public static SelectedOccurrences All;
}
public class JetBrains.ReSharper.Refactorings.WorkflowNew.WorkflowHostWithBeWizardForm : object {
    private WorkflowExecuter myExecuter;
    private bool myFormIsShown;
    private bool myHasFinished;
    private Timer myDelayedFromShowTimer;
    private bool myIsUpdatingNow;
    private BeRefactoringForm myWizardForm;
    private RefactoringInteractionModel myInteraction;
    private IUIApplication myEnvironment;
    public WorkflowHostWithBeWizardForm(RefactoringInteractionModel interaction, IUIApplication environment);
    public sealed virtual void Initialize(WorkflowExecuter executer);
    public sealed virtual ITaskExecutor CreateTaskExecutor(string taskName);
    private void AttachForm();
    public sealed virtual IRefactoringPage CreateConflictsPage(WorkflowExecuter executer, IEnumerable`1<IConflict> conflicts);
    public sealed virtual ITaskExecutor CreateFinalizeTaskExecuter();
    public sealed virtual void ShowMessage(string text, string title);
    public sealed virtual void DisposePage(IRefactoringPage pages);
    public sealed virtual bool ShowPage(IRefactoringPage page, bool hasBack);
    private bool ShowEditorUIPage(IEditorUIRefactoringPage editorUIPage, bool hasBack);
    private bool IsNotReady();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <AttachForm>b__11_0();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Refactorings.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class NoConstraint : ConstraintBase {
    private static NoConstraint myInstance;
    public bool IsBlocker { get; }
    public static NoConstraint Instance { get; }
    private static NoConstraint();
    public virtual bool get_IsBlocker();
    public static NoConstraint get_Instance();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
