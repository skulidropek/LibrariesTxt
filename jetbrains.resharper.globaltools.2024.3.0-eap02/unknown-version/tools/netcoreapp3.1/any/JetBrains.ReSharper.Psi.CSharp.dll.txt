[ExtensionAttribute]
public static class JetBrains.ReSharper.Feature.Services.CSharp.FileLayout.FileLayoutUtil : object {
    [ExtensionAttribute]
public static void ReorderMembers(ICSharpTypeAndNamespaceHolderDeclaration declaration);
    public static Patterns ParseFileLayoutPattern(ISolution solution, string patternsText);
}
public class JetBrains.ReSharper.Psi.CSharp.AnonymousMethodType : object {
    [CanBeNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private IAnonymousMethodExpression myMethodExpression;
    [NotNullAttribute]
private IPsiModule myPsiModule;
    [CanBeNullAttribute]
private IType[] myParameterTypes;
    [CanBeNullAttribute]
private ParameterKind[] myParameterKinds;
    [CanBeNullAttribute]
private ScopedKind[] myParameterScopes;
    private bool myIsAsync;
    private bool myHasNaturalType;
    [CanBeNullAttribute]
private IType myAnnotatedInferredReturnType;
    private IList`1<IExpressionType> myReturnValues;
    private bool myIsRefReturn;
    private Nullable`1<bool> myImplicitReturnIsReachable;
    private object myLock;
    [NotNullAttribute]
private IResolveContext ResolveContext { get; }
    private IList`1<IExpressionType> ReturnValues { get; }
    public ITreeNode VerificationScope { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public IType ExplicitReturnType { get; }
    public ReferenceKind ExplicitReturnKind { get; }
    private bool IsRefReturn { get; }
    private ICollection`1<IExpressionType> JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionType.ReturnValues { get; }
    private bool ImplicitReturnIsReachable { get; }
    public bool IsAsync { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    public bool HasParametersList { get; }
    public bool HasReturnStatements { get; }
    public IReadOnlyList`1<Pair`2<IType, ParameterKind>> ParameterTypesAndKinds { get; }
    public IPsiModule Module { get; }
    public bool IsNonCacheable { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public AnonymousMethodType(IResolveContext resolveContext, IAnonymousMethodExpression methodExpression, IType annotatedInferredReturnType);
    private IResolveContext get_ResolveContext();
    private void CalculateReturnTypesAndRefness();
    private bool CalculateReachableImplicitReturn();
    private IList`1<IExpressionType> get_ReturnValues();
    public sealed virtual IType InferredResultTypeWithoutAsync();
    public sealed virtual IType InferredResultTypeWithoutAsync(bool allowFunctionTypes, Boolean& isRefReturn, ICollection`1& returnValues);
    public sealed virtual ITreeNode get_VerificationScope();
    public sealed virtual IReadOnlyList`1<IParameter> GetImplicitLambdaParameters();
    public sealed virtual CSharpLanguageLevel get_LanguageLevel();
    public sealed virtual bool HasImplicitLambdaParameters();
    public sealed virtual IType get_ExplicitReturnType();
    public sealed virtual ReferenceKind get_ExplicitReturnKind();
    private bool get_IsRefReturn();
    private sealed virtual override ICollection`1<IExpressionType> JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionType.get_ReturnValues();
    private bool get_ImplicitReturnIsReachable();
    public sealed virtual IType ToIType();
    private IType CalculateIType();
    public IType GetFunctionType();
    public sealed virtual bool IsReturnTypeConvertibleTo(IDelegate delegate, ISubstitution substitution);
    public sealed virtual IList`1<IExpressionType> GetReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    public sealed virtual bool IsSignatureConvertibleTo(IDelegate delegate, ISubstitution substitution);
    public sealed virtual bool VerifyFunctionType(IDelegate delegate, ISubstitution substitution);
    public sealed virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
    public sealed virtual bool get_IsAsync();
    public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    public sealed virtual bool get_HasParametersList();
    public sealed virtual bool get_HasReturnStatements();
    public sealed virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> get_ParameterTypesAndKinds();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsNonCacheable();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
    public sealed virtual bool CanHaveNaturalType();
    private sealed virtual override IType JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionTypeImpl.TryComputeNaturalTypeFromExplicitSignature();
    private sealed virtual override IType JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionTypeImpl.TryComputeImplicitNaturalType(ICollection`1<IExpressionType> returnTypes, bool hasRefReturn);
    [CanBeNullAttribute]
private IType TryComputeNaturalTypeFromExplicitSignature();
    [CanBeNullAttribute]
private IType TryComputeImplicitNaturalType(ICollection`1<IExpressionType> returnTypes, bool hasRefReturn);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
[PureAttribute]
private IType <TryComputeImplicitNaturalType>g__TryFindStandardVoidReturningDelegateOrFallbackToAnonymousDelegate|71_0(IType realReturnType, <>c__DisplayClass71_0& );
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
[PureAttribute]
private IType <TryComputeImplicitNaturalType>g__TryFindStandardDelegateByInferredReturnTypeOrFallbackToAnonymousDelegate|71_1(IType inferredReturnType, <>c__DisplayClass71_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
private bool <TryComputeImplicitNaturalType>g__ParametersCanMatchStandardDelegate|71_2(<>c__DisplayClass71_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
private bool <TryComputeImplicitNaturalType>g__ReturnTypeCanMatchStandardDelegate|71_3(IType realReturnType, <>c__DisplayClass71_0& );
    [CompilerGeneratedAttribute]
private bool <TryComputeImplicitNaturalType>g__TryAddParameterTypes|71_4(List`1<IType> typeArguments, <>c__DisplayClass71_0& );
    [CompilerGeneratedAttribute]
private bool <TryComputeImplicitNaturalType>g__TryAddVoidReturnTypeArgument|71_5(List`1<IType> typeArguments, <>c__DisplayClass71_0& );
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
[PureAttribute]
private IType <TryComputeImplicitNaturalType>g__TryCreateAnonymousDelegateType|71_6(IType realReturnType, ReferenceKind returnKind, <>c__DisplayClass71_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.ArgumentInfoExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExpressionType GetExpressionType(ICSharpArgumentInfo argumentInfo);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAddressOfArgumentTaken(ICSharpArgumentInfo argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.CollectionExpressionCache : SimpleICache`1<byte> {
    private static byte ContainsAny;
    private static byte ContainsEvidentOnly;
    private static object ourBoxedContainsAny;
    private static object ourBoxedContainsEvidentOnly;
    private IPsiFiles myPsiFiles;
    public CollectionExpressionCache(Lifetime lifetime, IShellLocks locks, IPersistentIndexManager persistentIndexManager, IPsiFiles psiFiles);
    private static CollectionExpressionCache();
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public bool CanContainCollectionExpression(IPsiSourceFile sourceFile, Boolean& evidentOnly);
    public IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyContainingNonEvidentCollectionExpressions(HashSet`1<IPsiSourceFile> exclusions);
    public IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyContainingCollectionExpressions(HashSet`1<IPsiSourceFile> exclusions);
    private IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyContainingCollectionExpressions(HashSet`1<IPsiSourceFile> exclusions, Nullable`1<byte> requiredValueOpt);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.CSharpAnnotatedMembersCacheProcessor : object {
    [NullableContextAttribute("1")]
public sealed virtual void Process(IFile file, HashSet`1<string> attributeNames, AnnotatedEntitiesSet context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.GlobalUsingsCache : SimpleICache`1<Byte[]> {
    private IPsiFiles myPsiFiles;
    private IPsiModules myPsiModules;
    private GlobalUsingsMarshaller myGlobalUsingsMarshaller;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<IPsiModule, GlobalUsingsSandBox> myGlobalUsingsSandboxes;
    private Dictionary`2<IPsiModule, Dictionary`2<string, CSharpGlobalUsingAlias>> myGlobalUsingAliasDeclaredElements;
    private ReaderWriterLockSlim myGlobalUsingAliasesLock;
    private ConcurrentDictionary`2<IPsiModule, OneToSetMap`2<string, string>> myGlobalAliasesPerModule;
    private static Byte[] ourEmptyUsingsValue;
    private static OneToSetMap`2<string, string> ourEmptyAliasTable;
    public GlobalUsingsCache(Lifetime lifetime, IShellLocks locks, IPersistentIndexManager persistentIndexManager, IPsiFiles psiFiles, IPsiModules psiModules, ChangeManager changeManager, ILanguageManager languageManager, CommonIdentifierIntern commonIdentifierIntern);
    private static GlobalUsingsCache();
    protected virtual bool IsApplicable(IPsiSourceFile sourceFile);
    public virtual object Load(IProgressIndicator progress, bool enablePersistence);
    [NullableContextAttribute("2")]
public virtual void MergeLoaded(object data);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    private bool TryGetValue(IPsiSourceFile file, UsingDirectiveInfo[]& usingDirectives);
    public virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    private void RemoveParts(IPsiSourceFile sourceFile, UsingDirectiveInfo[] oldUsingDirectives, Dictionary`2<string, CSharpGlobalUsingAlias> globalUsingAliases);
    public virtual void Drop(IPsiSourceFile sourceFile);
    public TreeNodeEnumerable`1<IUsingDirective> GetGlobalUsings(IPsiModule module);
    public IReadOnlyDictionary`2<IPsiSourceFile, UsingDirectiveInfo[]> GetGlobalUsingsPerFile(IPsiModule module);
    public IEnumerable`1<string> GetAliasesInModule(string typeShortName, IPsiModule module);
    private OneToSetMap`2<string, string> GetGlobalAliasesForModule(IPsiModule module);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Caches.GlobalUsingsCache/<GetAliases>d__22")]
public sealed virtual IEnumerable`1<string> GetAliases(string name);
    internal CSharpGlobalUsingAlias GetGlobalSymbolAlias(string aliasName, IPsiModule psiModule);
    private GlobalUsingsSandBox GetGlobalUsingsSandBoxForModule(IPsiModule module);
    public virtual void SyncUpdate(bool underTransaction);
    public sealed virtual object Execute(IChangeMap changeMap);
    public bool HasGlobalUsings(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveCache {
    [PureAttribute]
public abstract virtual IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyDeclaringAlias(string aliasName, Func`2<IPsiSourceFile, bool> sourceFilePredicate);
    [PureAttribute]
public abstract virtual IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyDeclaringAliasesTo(AliasedSymbol aliasedSymbol, Func`2<IPsiSourceFile, bool> sourceFilePredicate);
    [PureAttribute]
public abstract virtual IAliasDirectiveSearcher CreateAliasDirectiveSearcher(ICSharpFile file, bool includeGlobalAliases);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CSharp.Caches.IAliasDirectiveSearcher {
    public abstract virtual IUsingAliasDirective FindSingleAvailableAliasFor(ITypeUsage typeUsage);
    public abstract virtual IUsingAliasDirective FindSingleAvailableAliasFor(IReferenceName referenceName);
    public abstract virtual IUsingAliasDirective FindSingleAvailableAliasFor(IReferenceExpression referenceExpression);
    public abstract virtual IUsingAliasDirective FindSingleAvailableAliasFor(IPredefinedTypeExpression predefinedTypeExpression);
    public abstract virtual IReadOnlyList`1<IUsingAliasDirective> FindAllAliasesFor(IType type);
    public abstract virtual IReadOnlyList`1<IUsingAliasDirective> FindAllAliasesFor(INamespace namespaceElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.InterceptedLocation : object {
    [CompilerGeneratedAttribute]
private string <InterceptedCallFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InterceptedCallLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InterceptedCallCharacter>k__BackingField;
    public string InterceptedCallFilePath { get; }
    public int InterceptedCallLine { get; }
    public int InterceptedCallCharacter { get; }
    public InterceptedLocation(string targetFilePath, int line, int character);
    [CompilerGeneratedAttribute]
public string get_InterceptedCallFilePath();
    [CompilerGeneratedAttribute]
public int get_InterceptedCallLine();
    [CompilerGeneratedAttribute]
public int get_InterceptedCallCharacter();
    private bool Equals(InterceptedLocation other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(InterceptedLocation left, InterceptedLocation right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(InterceptedLocation left, InterceptedLocation right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.InterceptorAttributes : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private FrugalLocalHashSet`1<InterceptorSourceLocation> myCollisions;
    public InterceptorSourceLocation SingleSourceLocation { get; }
    public bool HasCollisions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FrugalLocalHashSet`1& Collisions { get; }
    [NullableContextAttribute("1")]
public InterceptorAttributes(InterceptorSourceLocation singleSourceLocation);
    public InterceptorSourceLocation get_SingleSourceLocation();
    public bool get_HasCollisions();
    public FrugalLocalHashSet`1& get_Collisions();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.InterceptorsCache : SimpleICache`1<JetHashSet`1<InterceptorSourceLocation>> {
    private ConcurrentDictionary`2<IPsiSourceFile, JetHashSet`1<InterceptorSourceLocation>> myInterceptorDataByFile;
    private ConcurrentDictionary`2<IPsiModule, ConcurrentDictionary`2<InterceptedLocation, InterceptorAttributes>> myInterceptors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<IPsiModule, ConcurrentDictionary`2<InterceptorSourceLocation, InterceptedLocation>> myNonConstantInterceptors;
    private ConcurrentDictionary`2<IPsiModule, OneToSetMap`2<string, InterceptedLocation>> myInterceptedLocationsPerFile;
    private ConcurrentDictionary`2<IPsiModule, UpToDateWrapper> myUpToDateModules;
    private IPsiModules myPsiModules;
    public string Version { get; }
    public InterceptorsCache(Lifetime lifetime, IShellLocks locks, IPersistentIndexManager persistentIndexManager, ChangeManager changeManager, IPsiModules psiModules);
    public virtual string get_Version();
    public sealed virtual object Execute(IChangeMap changeMap);
    public bool HasInterceptorsForPsiModule(IPsiModule psiModule);
    public void Prepare(IPsiModule psiModule);
    public ISet`1<InterceptedLocation> GetInterceptedLocations(IPsiSourceFile file);
    public static string NormalizeFilePath(IPsiSourceFile sourceFile);
    public static string NormalizeFilePath(IPsiSourceFile sourceFile, String& fileName);
    [MustUseReturnValueAttribute]
public Hash CalculateInterceptorsHashPerFile(IPsiModule psiModule, IPsiSourceFile file);
    public IReadOnlyList`1<ValueTuple`2<string, Hash>> CalculateFileHashes(IPsiModule module);
    public virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public InterceptorAttributes TryGetValue(IPsiModule psiModule, InterceptedLocation location);
    protected virtual bool IsApplicable(IPsiSourceFile sourceFile);
    [NullableContextAttribute("2")]
public virtual void MergeLoaded(object data);
    public virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    private void AddInterceptorsFromFile(IPsiSourceFile sourceFile, JetHashSet`1<InterceptorSourceLocation> interceptorsData);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public virtual void Drop(IPsiSourceFile sourceFile);
    private void RemoveInterceptorSource(ConcurrentDictionary`2<InterceptedLocation, InterceptorAttributes> allInterceptorsForPsiModule, InterceptorSourceLocation interceptorSourceLocation);
    private static InterceptorAttributes UpdateCollisionWithExistingInterceptor(InterceptorAttributes attributes, InterceptorAttributes existingValue);
    private static InterceptorAttributes UpdateCollisionWithExistingInterceptor(InterceptorSourceLocation interceptorSourceLocation, InterceptorAttributes existingValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.InterceptorSourceLocation : object {
    private IMethod myOwnerMethod;
    [CompilerGeneratedAttribute]
private int <TreeOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private InterceptedLocation <StaticInterceptedLocation>k__BackingField;
    public int TreeOffset { get; public set; }
    public IPsiSourceFile SourceFile { get; public set; }
    public InterceptedLocation StaticInterceptedLocation { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TreeOffset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TreeOffset(int value);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
public void set_SourceFile(IPsiSourceFile value);
    [CompilerGeneratedAttribute]
public InterceptedLocation get_StaticInterceptedLocation();
    [CompilerGeneratedAttribute]
public void set_StaticInterceptedLocation(InterceptedLocation value);
    public InterceptedLocation Resolve();
    public IMethod GetOwnerMethod();
    [NullableContextAttribute("1")]
public static InterceptorSourceLocation CreateFromAttribute(IPsiSourceFile sourceFile, IAttribute attribute, IMethodDeclaration declaration);
    [NullableContextAttribute("1")]
protected bool Equals(InterceptorSourceLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.InterceptorSourceLocationMarshaller : object {
    public static InterceptorSourceLocationMarshaller Instance;
    private static InterceptorSourceLocationMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, InterceptorSourceLocation value);
    public sealed virtual InterceptorSourceLocation Unmarshal(UnsafeReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Caches.TargetTypedObjectCreationCache : SimpleICache`1<byte> {
    private static byte ContainsAny;
    private static byte ContainsEvidentOnly;
    private static object ourBoxedContainsAny;
    private static object ourBoxedContainsEvidentOnly;
    private IPsiFiles myPsiFiles;
    public TargetTypedObjectCreationCache(Lifetime lifetime, IShellLocks locks, IPersistentIndexManager persistentIndexManager, IPsiFiles psiFiles);
    private static TargetTypedObjectCreationCache();
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public bool CanContainTargetTypedObjectCreation(IPsiSourceFile sourceFile, Boolean& evidentOnly);
    public IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyContainingNonEvidentTargetTypedObjectCreation(HashSet`1<IPsiSourceFile> exclusions);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.CodeAnnotations.ConditionalAttributeProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, IReadOnlyList`1<string>> {
    private static string AttributeShortName;
    public static ClrTypeName AttributeName;
    public ConditionalAttributeProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static ConditionalAttributeProvider();
    [PureAttribute]
public IReadOnlyList`1<string> GetConditionalSymbols(IDeclaredElement declaredElement);
    protected virtual bool Accepts(IAttributesOwner attributesOwner);
    protected virtual IReadOnlyList`1<string> CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual IReadOnlyList`1<string> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual IReadOnlyList`1<string> GetDefaultInfo(IAttributesOwner attributesOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.CodeAnnotations.UnmanagedCallersOnlyAttributeProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, CallingConvention> {
    private static string AttributeShortName;
    public static string CallConventionsParameterName;
    public static string CallConventionTypePrefix;
    public static IClrTypeName AttributeName;
    private static Dictionary`2<IClrTypeName, CallingConvention> ourWellKnownConventions;
    public UnmanagedCallersOnlyAttributeProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static UnmanagedCallersOnlyAttributeProvider();
    [NullableContextAttribute("2")]
[PureAttribute]
public bool IsUnmanaged(IDeclaredElement declaredElement);
    protected virtual bool Accepts(IAttributesOwner attributesOwner);
    protected virtual CallingConvention CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    private static CallingConvention CalculateFromAttribute(IAttributeInstance attributeInstance);
    protected virtual CallingConvention CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual CallingConvention GetDefaultInfo(IAttributesOwner attributesOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.CodeAnnotations.ValueRangeAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, AbstractValue> {
    public ClrTypeName ValueRangeAttributeName;
    public ClrTypeName NonNegativeAttributeName;
    public ValueRangeAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual AbstractValue CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    private static bool TryGetOneArgument(IAttributeInstance attribute, Builder builder);
    private static bool TryGetTwoArguments(IAttributeInstance attribute, Builder builder);
    [NullableContextAttribute("2")]
protected virtual AbstractValue GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual bool Accepts(IAttributesOwner attributesOwner);
    [PureAttribute]
public bool IsValueRangeAttribute(IAttributeInstance attributeInstance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Advisers.DefaultStaticQualifierStyleAdviser : object {
    private static Expression`1<Func`2<StaticQualifierSettingsKey, QualifiedMember>> ourMembersToQualifyAccessor;
    private static Expression`1<Func`2<StaticQualifierSettingsKey, StaticMemberQualifierStyle>> ourQualifyWithAccessor;
    private IContextBoundSettingsStore myStore;
    public DefaultStaticQualifierStyleAdviser(IContextBoundSettingsStore store);
    private static DefaultStaticQualifierStyleAdviser();
    public virtual StaticMemberQualifierStyle Advise(QualifiedMember memberKind);
    public virtual IResolveResult ResolveUnqualified(IReferenceExpression expr);
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Advisers.IStaticQualifierStyleAdviser {
    public abstract virtual StaticMemberQualifierStyle Advise(QualifiedMember memberKind);
    [NullableContextAttribute("1")]
public abstract virtual IResolveResult ResolveUnqualified(IReferenceExpression expr);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpAttributeForSingleLineMethodUpgrade : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpAttributeForSingleLineMethodUpgrade/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetEntriesToMigrate>d__0")]
private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpCodeCleanupUtil : object {
    [ExtensionAttribute]
public static void OptimizeUsings(ICSharpFile file, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static void ShortenQualifiedReferences(ICSharpFile file, IRangeMarker rangeMarker, IProgressIndicator progressIndicator);
    public static void Optimize(ICSharpFile file, IRangeMarker rangeMarker, bool optimizeUsings, bool shortenQualifiedReferences, IProgressIndicator progressIndicator);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CFileLayoutPatternSettingDescription")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpFileLayoutPatternsSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "FileLayoutPatternSettingDescription")]
public string Pattern;
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpFileLayoutPatternsUpgrade : object {
    private static Regex ourRegionNameTemplateRegex;
    private static CSharpFileLayoutPatternsUpgrade();
    public sealed virtual IEnumerable`1<SettingsEntry> GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpFileLayoutPatternsUpgrade/<GetKeysToMigrate>d__2")]
public sealed virtual IEnumerable`1<SettingsKey> GetKeysToMigrate(ISettingsSchema schema);
    public sealed virtual void Migrate(IContextBoundSettingsStoreImplementation store);
    private string GetUpgradedPattern(IContextBoundSettingsStore settingsStore);
    private string MigratePattern(string oldPattern);
    private void ConvertRegionName(Region region);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpFormatHighlightingIds : object {
    public static string BadNamespaceBracesIndent;
    public static string BadDeclarationBracesIndent;
    public static string BadControlBracesIndent;
    public static string BadSwitchIndent;
    public static string BadExpressionBracesIndent;
    public static string BadChildStatementIndent;
    public static string BadPreprocessorIndent;
    public static string MultipleStatementsOnOneLine;
    public static string MultipleTypeMembersOnOneLine;
    public static string BadDeclarationBracesLineBreaks;
    public static string BadControlBracesLineBreaks;
    public static string BadExpressionBracesLineBreaks;
    public static string BadEmptyBracesLineBreaks;
    public static string BadLinqLineBreaks;
    public static string BadParensLineBreaks;
    public static string BadListLineBreaks;
    public static string BadSpacesAfterKeyword;
    public static string BadCommaSpaces;
    public static string BadSemicolonSpaces;
    public static string BadSymbolSpaces;
    public static string BadMemberAccessSpaces;
    public static string BadColonSpaces;
    public static string BadParensSpaces;
    public static string BadSquareBracketsSpaces;
    public static string BadBracesSpaces;
    public static string BadGenericBracketsSpaces;
    public static string BadAttributeSpaces;
    public static string IncorrectBlankLinesNearBraces;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpFormatterHelper : object {
    [ExtensionAttribute]
public static bool ContainsLineBreak(ITreeNode node);
    [ExtensionAttribute]
public static bool ContainsLineBreakExceptInSomeChildren(ITreeNode node, Predicate`1<ITreeNode> isExcepted);
    [ExtensionAttribute]
public static void ReformatBlankLinesAround(ITreeNode node);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpKeepExistingMigration : object {
    private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpKeepExistingMigration/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetKeysToMigrate>d__1")]
private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
public static class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpMemberOrderDefaultPattern : object {
    [CompilerGeneratedAttribute]
private static string <DefaultPatternUsingRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultPatternWithoutRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MemberReorderingMigrationTranform>k__BackingField;
    public static string DefaultPatternUsingRegions { get; }
    public static string DefaultPatternWithoutRegions { get; }
    public static string MemberReorderingMigrationTranform { get; }
    private static CSharpMemberOrderDefaultPattern();
    [CompilerGeneratedAttribute]
public static string get_DefaultPatternUsingRegions();
    [CompilerGeneratedAttribute]
public static string get_DefaultPatternWithoutRegions();
    [CompilerGeneratedAttribute]
public static string get_MemberReorderingMigrationTranform();
}
[ObsoleteAttribute("Use CSharpFileLayoutPatternsSettings")]
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CMemberOrderPatternSettingDescription")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpMemberOrderPatternSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "LayoutTypeSettingDescription")]
public CSharpMemberOrderPatternType LayoutType;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CustomPatternUseNullForDefaultPatternSettingDescription")]
public string CustomPattern;
}
[ObsoleteAttribute("Use CSharpFileLayoutPatternsSettings")]
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpMemberOrderPatternType : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Default layout without regions")]
public static CSharpMemberOrderPatternType WithoutRegions;
    [LocalizedDescriptionAttribute("Default layout using regions")]
public static CSharpMemberOrderPatternType UsingRegions;
    [LocalizedDescriptionAttribute("Custom layout")]
public static CSharpMemberOrderPatternType CustomLayout;
}
[SolutionSettingsUpgraderAttribute("0")]
[GlobalSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpMemberOrderPatternUpgrade : CodeStyleSettingsUpgrade {
    public CSharpMemberOrderPatternUpgrade(ShellPartCatalogSet partsSet, ISolution solution);
    protected virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore boundSettingsStore);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpPlaceEmbeddedOnSameLineMigration : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpPlaceEmbeddedOnSameLineMigration/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetEntriesToMigrate>d__0")]
private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpPlaceEmbeddedOnSameLineMigration/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetKeysToMigrate>d__1")]
private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpRenamePlacementToArrangementMigration : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpRenamePlacementToArrangementMigration/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetEntriesToMigrate>d__0")]
private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpUseContinuousIndentInsideBracesMigration : object {
    private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpUseContinuousIndentInsideBracesMigration/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetKeysToMigrate>d__1")]
private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CNamespaceImportSettingDescription")]
[EditorConfigKeyAttribute("csharp")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpUsingSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AddusingDirectiveToDeepestScopeSettingDescription")]
public bool AddImportsToDeepestScope;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferFullyQualifiedUsingNameAtNestedScopeSettingDescription")]
public bool QualifiedUsingAtNestedScope;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UseUsingAliasDirectiveToResolveConflictsSettingDescription")]
public bool AllowAlias;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AllowglobalPrefixUseSettingDescription")]
public bool CanUseGlobalAlias;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferFullyQualifiedReferencesSettingDescription")]
public bool PreferQualifiedReference;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "SortusingDirectivesSettingDescription")]
public bool SortUsings;
    [EditorConfigEntryAliasAttribute("dotnet_sort_system_directives_first", "50")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSystemAndWindowsNamespacesFirstWhenSortingusingDirectivesSettingDescription")]
public bool SortUsingsWithSystemFirst;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepNonTrivialUsingAliasesSettingDescription")]
public bool KeepNontrivialAlias;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "RemoveUnusedOnlyUsingAliasesSettingDescription")]
public bool RemoveOnlyUnusedAliases;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepusingDirectivesOnOptimizationSettingDescription")]
public IIndexedEntry`2<string, string> KeepImports;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AddusingDirectivesOnOptimizationSettingDescription")]
public IIndexedEntry`2<string, string> MandatoryImports;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "NamespacesThatShouldNotBeRemovedFromFullyQualifiedTypeNamesSettingDescription")]
public IIndexedEntry`2<string, string> NonRedundantNamespaces;
}
public static class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpUsingSettingsAccessor : object {
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> AddImportsToDeepestScope;
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> QualifiedUsingAtNestedScope;
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> AllowAlias;
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> CanUseGlobalAlias;
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> PreferQualifiedReference;
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> SortUsings;
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> SortUsingsWithSystemFirst;
    public static Expression`1<Func`2<CSharpUsingSettings, IIndexedEntry`2<string, string>>> KeepImports;
    public static Expression`1<Func`2<CSharpUsingSettings, IIndexedEntry`2<string, string>>> MandatoryImports;
    public static Expression`1<Func`2<CSharpUsingSettings, IIndexedEntry`2<string, string>>> NonRedundantNamespaces;
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> KeepNontrivialAlias;
    public static Expression`1<Func`2<CSharpUsingSettings, bool>> RemoveOnlyUnusedAliases;
    private static CSharpUsingSettingsAccessor();
    public static AliasOptimizationPolicy GetAliasOptimizationPolicy(IContextBoundSettingsStore settingsStore);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpVarKeywordUsageSettingsSettingDescription")]
[EditorConfigKeyAttribute("csharp")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpVarKeywordUsageSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ForBuiltInTypesSettingDescription")]
public VariableStyle ForBuiltInTypes;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ForSimpleTypesSettingDescription")]
public VariableStyle ForSimpleTypes;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ElsewhereSettingDescription")]
public VariableStyle ForOtherTypes;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferRoslynVisualStudioLogicForTypeEvidenceSettingDescription")]
public bool UseRoslynLogicForEvidentTypes;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferSeparateDeclarationsForDeconstructedVariablesSettingDescription")]
public bool PreferSeparateDeconstructedVariablesDeclaration;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UsevarKeywordForDiscardsSettingDescription")]
public bool PreferExplicitDiscardDeclaration;
}
public static class JetBrains.ReSharper.Psi.CSharp.CodeStyle.CSharpVarKeywordUsageSettingsAccessor : object {
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpVarKeywordUsageSettings, VariableStyle>> ForBuiltInTypes;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpVarKeywordUsageSettings, VariableStyle>> ForSimpleTypes;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpVarKeywordUsageSettings, VariableStyle>> ForOtherTypes;
    public static Expression`1<Func`2<CSharpVarKeywordUsageSettings, bool>> UseRoslynLogicForEvidentTypes;
    public static Expression`1<Func`2<CSharpVarKeywordUsageSettings, bool>> PreferSeparateDeconstructedVariablesDeclaration;
    public static Expression`1<Func`2<CSharpVarKeywordUsageSettings, bool>> PreferExplicitDiscardDeclaration;
    private static CSharpVarKeywordUsageSettingsAccessor();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class JetBrains.ReSharper.Psi.CSharp.CodeStyle.FileLayoutPatternResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DefaultMemberReorderingPatterns { get; }
    internal static string DefaultMemberReorderingPatternsWithoutRegions { get; }
    internal static string MemberReorderingMigrationTransform { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DefaultMemberReorderingPatterns();
    internal static string get_DefaultMemberReorderingPatternsWithoutRegions();
    internal static string get_MemberReorderingMigrationTransform();
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.AlignIndentDontChangeStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Align")]
public static AlignIndentDontChangeStyle ALIGN;
    [LocalizedDescriptionAttribute("Indent to previous line")]
public static AlignIndentDontChangeStyle INDENT;
    [LocalizedDescriptionAttribute("Do not change")]
public static AlignIndentDontChangeStyle DO_NOT_CHANGE;
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.CodeStyle.CodeFormattingSettingsKey", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CodeFormattingInCSettingDescription")]
[EditorConfigKeyAttribute("csharp")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKey : FormatSettingsKeyBase {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "RevertToOldFormattingEngineSettingDescription")]
public bool OLD_ENGINE;
    [EditorConfigEntryAliasAttribute("space_between_method_call_name_and_opening_parenthesis", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodCallParenthesesSettingDescription")]
public bool SPACE_BEFORE_METHOD_CALL_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_method_call_name_and_opening_parenthesis", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodCallEmptyParenthesesSettingDescription")]
public bool SPACE_BEFORE_EMPTY_METHOD_CALL_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_method_call_parameter_list_parentheses", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodCallParenthesesSettingDescription")]
public bool SPACE_WITHIN_METHOD_CALL_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_method_call_empty_parameter_list_parentheses", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodCallEmptyParenthesesSettingDescription")]
public bool SPACE_WITHIN_EMPTY_METHOD_CALL_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_method_declaration_name_and_open_parenthesis", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodDeclarationParenthesesSettingDescription")]
public bool SPACE_BEFORE_METHOD_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_method_declaration_name_and_open_parenthesis", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodDeclarationEmptyParenthesesSettingDescription")]
public bool SPACE_BEFORE_EMPTY_METHOD_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_method_declaration_parameter_list_parentheses", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodDeclarationParenthesesSettingDescription")]
public bool SPACE_WITHIN_METHOD_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_method_declaration_empty_parameter_list_parentheses", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodDeclarationEmptyParenthesesSettingDescription")]
public bool SPACE_WITHIN_EMPTY_METHOD_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_before_open_square_brackets", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeArrayAccessBracketsSettingDescription")]
public bool SPACE_BEFORE_ARRAY_ACCESS_BRACKETS;
    [EditorConfigEntryAliasAttribute("space_between_square_brackets", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinArrayAccessBracketsSettingDescription")]
public bool SPACE_WITHIN_ARRAY_ACCESS_BRACKETS;
    [EditorConfigEntryAliasAttribute("space_between_square_brackets", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinListPatternBracketsSettingDescription")]
public bool SPACE_WITHIN_LIST_PATTERN_BRACKETS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinSlicePatternSettingDescription")]
public bool SPACE_WITHIN_SLICE_PATTERN;
    [EditorConfigEntryAliasAttribute("space_before_open_square_brackets", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeArrayRankBracketsSettingDescription")]
public bool SPACE_BEFORE_ARRAY_RANK_BRACKETS;
    [EditorConfigEntryAliasAttribute("space_between_square_brackets", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinArrayRankBracketsSettingDescription")]
public bool SPACE_WITHIN_ARRAY_RANK_BRACKETS;
    [EditorConfigEntryAliasAttribute("space_between_empty_square_brackets", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinArrayRankEmptyBracketsSettingDescription")]
public bool SPACE_WITHIN_ARRAY_RANK_EMPTY_BRACKETS;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceIfParenthesesDescription")]
public bool SPACE_BEFORE_IF_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceIfParenthesesDescription")]
public bool SPACE_WITHIN_IF_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceWhileParenthesesDescription")]
public bool SPACE_BEFORE_WHILE_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceWhileParenthesesDescription")]
public bool SPACE_WITHIN_WHILE_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceCatchParenthesesDescription")]
public bool SPACE_BEFORE_CATCH_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceCatchParenthesesDescription")]
public bool SPACE_WITHIN_CATCH_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceSwitchParenthesesDescription")]
public bool SPACE_BEFORE_SWITCH_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceSwitchParenthesesDescription")]
public bool SPACE_WITHIN_SWITCH_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceForParenthesesDescription")]
public bool SPACE_BEFORE_FOR_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceForParenthesesDescription")]
public bool SPACE_WITHIN_FOR_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceForeachParenthesesDescription")]
public bool SPACE_BEFORE_FOREACH_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceForeachParenthesesDescription")]
public bool SPACE_WITHIN_FOREACH_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceUsingParenthesesDescription")]
public bool SPACE_BEFORE_USING_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceUsingParenthesesDescription")]
public bool SPACE_WITHIN_USING_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceLockParenthesesDescription")]
public bool SPACE_BEFORE_LOCK_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceLockParenthesesDescription")]
public bool SPACE_WITHIN_LOCK_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_keywords_in_control_flow_statements", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceFixedParenthesesDescription")]
public bool SPACE_BEFORE_FIXED_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_parentheses_of_control_flow_statements", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceFixedParenthesesDescription")]
public bool SPACE_WITHIN_FIXED_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_between_typecast_parentheses", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "TypeCastParenthesesSettingDescription")]
public bool SPACE_WITHIN_TYPECAST_PARENTHESES;
    [EditorConfigEntryAliasAttribute("space_after_cast", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterTypeCastParenthesesSettingDescription")]
public bool SPACE_AFTER_TYPECAST_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BetweenKeywordAndExpressionSettingDescription")]
public bool SPACE_BETWEEN_KEYWORD_AND_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BetweenKeywordAndTypeSettingDescription")]
public bool SPACE_BETWEEN_KEYWORD_AND_TYPE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ParenthesesSettingDescription")]
public bool SPACE_WITHIN_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceTypeofParenthesesDescription")]
public bool SPACE_BEFORE_TYPEOF_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceTypeofParenthesesDescription")]
public bool SPACE_WITHIN_TYPEOF_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceDefaultParenthesesDescription")]
public bool SPACE_BEFORE_DEFAULT_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceDefaultParenthesesDescription")]
public bool SPACE_WITHIN_DEFAULT_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceSizeofParenthesesDescription")]
public bool SPACE_BEFORE_SIZEOF_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceSizeofParenthesesDescription")]
public bool SPACE_WITHIN_SIZEOF_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceCheckedUncheckedParenthesesDescription")]
public bool SPACE_BEFORE_CHECKED_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceCheckedUncheckedParenthesesDescription")]
public bool SPACE_WITHIN_CHECKED_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceNameofParenthesesDescription")]
public bool SPACE_BEFORE_NAMEOF_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceNameofParenthesesDescription")]
public bool SPACE_WITHIN_NAMEOF_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceNewParenthesesDescription")]
public bool SPACE_BEFORE_NEW_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "SpaceNewParenthesesDescription")]
public bool SPACE_WITHIN_NEW_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeTypeParameterListAngleSettingDescription")]
public bool SPACE_BEFORE_TYPE_PARAMETER_ANGLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "TypeParameterAnglesSettingDescription")]
public bool SPACE_WITHIN_TYPE_PARAMETER_ANGLES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeTypeArgumentListAngleSettingDescription")]
public bool SPACE_BEFORE_TYPE_ARGUMENT_ANGLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "TypeArgumentAnglesSettingDescription")]
public bool SPACE_WITHIN_TYPE_ARGUMENT_ANGLES;
    [EditorConfigEntryAliasAttribute("space_between_square_brackets", "18")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinAttributeBracketsSettingDescription")]
public bool SPACE_WITHIN_ATTRIBUTE_BRACKETS;
    [EditorConfigEntryAliasAttribute("", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterCommaSettingDescription")]
public bool SPACE_AFTER_COMMA;
    [EditorConfigEntryAliasAttribute("", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeCommaSettingDescription")]
public bool SPACE_BEFORE_COMMA;
    [EditorConfigEntryAliasAttribute("space_before_semicolon_in_for_statement", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_SpaceBeforeForSemicolon_SettingsEntryDescription")]
public bool SPACE_BEFORE_FOR_SEMICOLON;
    [EditorConfigEntryAliasAttribute("space_after_semicolon_in_for_statement", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_SpaceAfterForSemicolon_SettingsEntryDescription")]
public bool SPACE_AFTER_FOR_SEMICOLON;
    [EditorConfigEntryAliasAttribute("space_around_ternary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeQuestSettingDescription")]
public bool SPACE_BEFORE_TERNARY_QUEST;
    [EditorConfigEntryAliasAttribute("space_around_ternary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterQuestSettingDescription")]
public bool SPACE_AFTER_TERNARY_QUEST;
    [EditorConfigEntryAliasAttribute("space_around_ternary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeColonSettingDescription")]
public bool SPACE_BEFORE_TERNARY_COLON;
    [EditorConfigEntryAliasAttribute("space_around_ternary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterColonSettingDescription")]
public bool SPACE_AFTER_TERNARY_COLON;
    [EditorConfigEntryAliasAttribute("space_before_colon", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeOtherColonsSettingDescription")]
public bool SPACE_BEFORE_ATTRIBUTE_COLON;
    [EditorConfigEntryAliasAttribute("space_after_colon", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterOtherColonsSettingDescription")]
public bool SPACE_AFTER_ATTRIBUTE_COLON;
    [EditorConfigEntryAliasAttribute("space_before_colon_in_inheritance_clause", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeBaseTypesListColonSettingDescription")]
public bool SPACE_BEFORE_EXTENDS_COLON;
    [EditorConfigEntryAliasAttribute("space_after_colon_in_inheritance_clause", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterBaseTypesListColonSettingDescription")]
public bool SPACE_AFTER_EXTENDS_COLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeTypeParameterConstraintColonSettingDescription")]
public bool SPACE_BEFORE_TYPE_PARAMETER_CONSTRAINT_COLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterTypeParameterConstraintColonSettingDescription")]
public bool SPACE_AFTER_TYPE_PARAMETER_CONSTRAINT_COLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundLambdaArrowSettingDescription")]
public bool SPACE_AROUND_LAMBDA_ARROW;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AssignmentOperatorsSettingDescription")]
public bool SPACE_AROUND_ASSIGNMENT_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "LogicalOperatorsSettingDescription")]
public bool SPACE_AROUND_LOGICAL_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "EqualityOperatorsSettingDescription")]
public bool SPACE_AROUND_EQUALITY_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "RelationalOperatorsSettingDescription")]
public bool SPACE_AROUND_RELATIONAL_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BitwiseOperatorsSettingDescription")]
public bool SPACE_AROUND_BITWISE_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AdditiveOperatorsSettingDescription")]
public bool SPACE_AROUND_ADDITIVE_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MultiplicativeOperatorsSettingDescription")]
public bool SPACE_AROUND_MULTIPLICATIVE_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ShiftOperatorsSettingDescription")]
public bool SPACE_AROUND_SHIFT_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "NullCoalescingOperatorSettingDescription")]
public bool SPACE_AROUND_NULLCOALESCING_OP;
    [EditorConfigEntryAliasAttribute("space_around_member_access_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UnsafeArrowOperatorSettingDescription")]
public bool SPACE_AROUND_ARROW_OP;
    [EditorConfigEntryAliasAttribute("space_after_unary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UnsafeAddressofOperatorSettingDescription")]
public bool SPACE_AFTER_AMPERSAND_OP;
    [EditorConfigEntryAliasAttribute("space_after_unary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UnsafeAsteriskOperatorSettingDescription")]
public bool SPACE_AFTER_ASTERIK_OP;
    [EditorConfigEntryAliasAttribute("space_after_unary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "LogicalNotOperatorSettingDescription")]
public bool SPACE_AFTER_LOGICAL_NOT_OP;
    [EditorConfigEntryAliasAttribute("space_after_unary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UnaryPlusOperatorSettingDescription")]
public bool SPACE_AFTER_UNARY_PLUS_OP;
    [EditorConfigEntryAliasAttribute("space_after_unary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UnaryMinusOperatorSettingDescription")]
public bool SPACE_AFTER_UNARY_MINUS_OP;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeAfterAndSettingDescription")]
public bool SPACE_NEAR_POSTFIX_AND_PREFIX_OP;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundInNamespaceAliasDirectiveSettingDescription")]
public bool SPACE_AROUND_ALIAS_EQ;
    [EditorConfigEntryAliasAttribute("space_around_member_access_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundDotSettingDescription")]
public bool SPACE_AROUND_DOT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeSingleLineAccessorsBlockSettingDescription")]
public bool SPACE_BEFORE_SINGLELINE_ACCESSORHOLDER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinSingleLineAccessorSettingDescription")]
public bool SPACE_IN_SINGLELINE_ACCESSORHOLDER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BetweenAccessorsInSingleLinePropertyEventSettingDescription")]
public bool SPACE_BETWEEN_ACCESSORS_IN_SINGLELINE_PROPERTY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BetweenAttributeSectionsSettingDescription")]
public bool SPACE_BETWEEN_ATTRIBUTE_SECTIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterAttributesSettingDescription")]
public bool SPACE_AFTER_ATTRIBUTES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinSingleLineMethodSettingDescription")]
public bool SPACE_IN_SINGLELINE_METHOD;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinSingleLineAnonymousMethodSettingDescription")]
public bool SPACE_IN_SINGLELINE_ANONYMOUS_METHOD;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeSemicolonSettingDescription")]
public bool SPACE_BEFORE_SEMICOLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_SpaceBeforeColonInUse_SettingsEntryDescription")]
public bool SPACE_BEFORE_COLON_IN_CASE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_SpaceAfterColonInCase_SettingsEntryDescription")]
public bool SPACE_AFTER_COLON_IN_CASE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeNullableMarkSettingDescription")]
public bool SPACE_BEFORE_NULLABLE_MARK;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeUnsafePointerDeclarationSettingDescription")]
public bool SPACE_BEFORE_POINTER_ASTERIK_DECLARATION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WithinSingleLineExpressionBracesSettingDescription")]
public bool SPACE_WITHIN_SINGLE_LINE_ARRAY_INITIALIZER_BRACES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeEndOfLineCommentSettingDescription")]
public bool SPACE_BEFORE_TRAILING_COMMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterOperatorKeywordSettingDescription")]
public bool SPACE_AFTER_OPERATOR_KEYWORD;
    [EditorConfigEntryAliasAttribute("space_within_empty_braces", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "SpaceBetweenEmptyBracesSettingDescription")]
public bool SPACE_WITHING_EMPTY_BRACES;
    [EditorConfigEntryAliasAttribute("brace_style", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "TypeAndNamespaceDeclarationSettingDescription")]
public BraceFormatStyleEx TYPE_DECLARATION_BRACES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentInsideNamespaceDeclarationSettingDescription")]
public bool INDENT_INSIDE_NAMESPACE;
    [EditorConfigEntryAliasAttribute("brace_style", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodDeclarationSettingDescription")]
public BraceFormatStyleEx INVOCABLE_DECLARATION_BRACES;
    [EditorConfigEntryAliasAttribute("brace_style", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "LambdaAndDelegateAnonymousMethodDeclarationSettingDescription")]
public BraceFormatStyleEx ANONYMOUS_METHOD_DECLARATION_BRACES;
    [EditorConfigEntryAliasAttribute("brace_style", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PropertyDeclarationSettingDescription")]
public BraceFormatStyleEx ACCESSOR_OWNER_DECLARATION_BRACES;
    [EditorConfigEntryAliasAttribute("brace_style", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AccessorDeclarationSettingDescription")]
public BraceFormatStyleEx ACCESSOR_DECLARATION_BRACES;
    [EditorConfigEntryAliasAttribute("brace_style", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CaseBlockBracesSettingDescription")]
public BraceFormatStyleEx CASE_BLOCK_BRACES;
    [EditorConfigEntryAliasAttribute("brace_style", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ExpressionsInitializersSwitchExpressionsPatternsSettingDescription")]
public BraceFormatStyleEx INITIALIZER_BRACES;
    [EditorConfigEntryAliasAttribute("brace_style", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OtherSettingDescription")]
public BraceFormatStyleEx OTHER_BRACES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "EmptyBracesFormattingSettingDescription")]
public EmptyBlockStyle EMPTY_BLOCK_STYLE;
    [EditorConfigEntryAliasAttribute("new_line_before_else", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_PlaceElseOnNewLine_SettingsEntryDescription")]
public bool PLACE_ELSE_ON_NEW_LINE;
    [EditorConfigEntryAliasAttribute("new_line_before_while", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_PlaceWhileOnNewLine_SettingsEntryDescription")]
public bool PLACE_WHILE_ON_NEW_LINE;
    [EditorConfigEntryAliasAttribute("new_line_before_catch", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_PlaceCatchOnNewLine_SettingsEntryDescription")]
public bool PLACE_CATCH_ON_NEW_LINE;
    [EditorConfigEntryAliasAttribute("new_line_before_finally", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_PlaceFinallyOnNewLine_SettingsEntryDescription")]
public bool PLACE_FINALLY_ON_NEW_LINE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[EditorConfigEntryAliasAttribute("keep_existing_linebreaks", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingLineBreaksSettingDescription")]
public bool KEEP_USER_LINEBREAKS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "NestedTernaryExpressionStyleSettingDescription")]
public NestedTernaryExpressionStyle NESTED_TERNARY_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepMaxBlankLinesInDeclarationsSettingDescription")]
public int KEEP_BLANK_LINES_IN_DECLARATIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_RemoveBlankLinesNearBracesInDeclaration_SettingsEntryDescription")]
public bool REMOVE_BLANK_LINES_NEAR_BRACES_IN_DECLARATIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepMaxBlankLinesInCodeSettingDescription")]
public int KEEP_BLANK_LINES_IN_CODE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_RemoveBlankLinesNearBracesInCode_SettingsEntryDescription")]
public bool REMOVE_BLANK_LINES_NEAR_BRACES_IN_CODE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundNamespaceSettingDescription")]
public int BLANK_LINES_AROUND_NAMESPACE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "InsideNamespaceSettingDescription")]
public int BLANK_LINES_INSIDE_NAMESPACE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterFileScopedNamespaceDirectiveSettingDescription")]
public int BLANK_LINES_AFTER_FILE_SCOPED_NAMESPACE_DIRECTIVE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundTypeSettingDescription")]
public int BLANK_LINES_AROUND_TYPE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundSingleLineTypeSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_TYPE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "InsideTypeSettingDescription")]
public int BLANK_LINES_INSIDE_TYPE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundFieldSettingDescription")]
public int BLANK_LINES_AROUND_FIELD;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundSingleLineFieldSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_FIELD;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundPropertyEventSettingDescription")]
public int BLANK_LINES_AROUND_PROPERTY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundSingleLinePropertyEventSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_PROPERTY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundAutoAbstractPropertyEventSettingDescription")]
public int BLANK_LINES_AROUND_AUTO_PROPERTY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundSingleLineAutoAbstractPropertyEventSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_AUTO_PROPERTY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundPropertyEventAccessorSettingDescription")]
public int BLANK_LINES_AROUND_ACCESSOR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundSingleLinePropertyEventAccessorSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_ACCESSOR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundMethodSettingDescription")]
public int BLANK_LINES_AROUND_INVOCABLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundSingleLineMethodSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_INVOCABLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundLocalFunctionSettingDescription")]
public int BLANK_LINES_AROUND_LOCAL_METHOD;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundSingleLineLocalFunctionSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_LOCAL_METHOD;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundRegionSettingDescription")]
public int BLANK_LINES_AROUND_REGION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "InsideRegionSettingDescription")]
public int BLANK_LINES_INSIDE_REGION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_BlankLinesBetweenUsingGroups_SettingsEntryDescription")]
public int BLANK_LINES_BETWEEN_USING_GROUPS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_BlankLinesAfterUsingList_SettingsEntryDescription")]
public int BLANK_LINES_AFTER_USING_LIST;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterFileHeaderCommentSettingDescription")]
public int BLANK_LINES_AFTER_START_COMMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeSingleLineCommentSettingDescription")]
public int BLANK_LINES_BEFORE_SINGLE_LINE_COMMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeStatementsWithControlTransferSettingDescription")]
public int BLANK_LINES_BEFORE_CONTROL_TRANSFER_STATEMENTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterStatementsWithControlTransferSettingDescription")]
public int BLANK_LINES_AFTER_CONTROL_TRANSFER_STATEMENTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeStatementsWithChildBlocksSettingDescription")]
public int BLANK_LINES_BEFORE_BLOCK_STATEMENTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterStatementsWithChildBlocksSettingDescription")]
public int BLANK_LINES_AFTER_BLOCK_STATEMENTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeMultilineStatementsSettingDescription")]
public int BLANK_LINES_BEFORE_MULTILINE_STATEMENTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AfterMultilineStatementsSettingDescription")]
public int BLANK_LINES_AFTER_MULTILINE_STATEMENTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_BlankLinesBeforeCase_SettingsEntryDescription")]
public int BLANK_LINES_BEFORE_CASE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_BlankLinesAfterCase_SettingsEntryDescription")]
public int BLANK_LINES_AFTER_CASE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_BlankLinesAroundMultilineCaseSection_SettingsEntryDescription")]
public int BLANK_LINES_AROUND_MULTILINE_CASE_SECTION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_BlankLinesAroundBlockCaseSection_SettingsEntryDescription")]
public int BLANK_LINES_AROUND_BLOCK_CASE_SECTION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodParametersSettingDescription")]
public bool ALIGN_MULTILINE_PARAMETER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CallArgumentsSettingDescription")]
public bool ALIGN_MULTILINE_ARGUMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "TupleComponentsSettingDescription")]
public bool ALIGN_TUPLE_COMPONENTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ListOfBaseClassesAndInterfacesSettingDescription")]
public bool ALIGN_MULTILINE_EXTENDS_LIST;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ArrayObjectAndCollectionInitializerSettingDescription")]
public bool ALIGN_MULTILINE_ARRAY_AND_OBJECT_INITIALIZER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PropertyPatternsSettingDescription")]
public bool ALIGN_MULTILINE_PROPERTY_PATTERN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ListPatternsSettingDescription")]
public bool ALIGN_MULTILINE_LIST_PATTERN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "SwitchExpressionsSettingDescription")]
public bool ALIGN_MULTILINE_SWITCH_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "StatementConditionsInsideParenthesisSettingDescription")]
public bool ALIGN_MULTILINE_STATEMENT_CONDITIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OtherExpressionsSettingDescription")]
public bool ALIGN_MULTILINE_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OutdentTernaryExpressionsSettingDescription")]
public bool OUTDENT_TERNARY_OPS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ChainedMethodCallsSettingDescription")]
public bool ALIGN_MULTILINE_CALLS_CHAIN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OutdentDotsInChainedMethodCallsSettingDescription")]
public bool OUTDENT_DOTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BinaryExpressionsSettingDescription")]
public bool ALIGN_MULTILINE_BINARY_EXPRESSIONS_CHAIN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OutdentBinaryOperatorsSettingDescription")]
public bool OUTDENT_BINARY_OPS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BinaryPatternsSettingDescription")]
public bool ALIGN_MULTILINE_BINARY_PATTERNS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OutdentBinaryPatternsSettingDescription")]
public bool OUTDENT_BINARY_PATTERN_OPS;
    [EditorConfigEntryAliasAttribute("align_multiline_type_parameter_list", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "TypeParametersListSettingDescription")]
public bool ALIGN_MULTLINE_TYPE_PARAMETER_LIST;
    [EditorConfigEntryAliasAttribute("align_multiline_type_parameter_constraints", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "TypeParameterConstraintsSettingDescription")]
public bool ALIGN_MULTLINE_TYPE_PARAMETER_CONSTRAINS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_AlignMultilineForStmt_SettingsEntryDescription")]
public bool ALIGN_MULTILINE_FOR_STMT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MultipleDeclarationsSettingDescription")]
public bool ALIGN_MULTIPLE_DECLARATION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CallArgumentsBySettingDescription")]
public bool ALIGN_FIRST_ARG_BY_PAREN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "LINQQuerySettingDescription")]
public bool ALIGN_LINQ_QUERY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AnonymousMethodBodySettingDescription")]
public bool INDENT_ANONYMOUS_METHOD_BLOCK;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OutdentCommasSettingDescription")]
public bool OUTDENT_COMMAS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OutdentStatementLabelsSettingDescription")]
public bool OUTDENT_STATEMENT_LABELS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentBracesInsideStatementConditionsSettingDescription")]
public bool INDENT_BRACES_INSIDE_STATEMENT_CONDITIONS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "FieldsAndConstantsSettingDescription")]
public bool INT_ALIGN_FIELDS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PropertiesAndEventsSettingDescription")]
public bool INT_ALIGN_PROPERTIES;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "SimpleMethodsOperatorsDelegatesSettingDescription")]
public bool INT_ALIGN_METHODS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MultilineMethodSignatureSettingDescription")]
public bool INT_ALIGN_PARAMETERS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "VariablesAndLocalConstantsSettingDescription")]
public bool INT_ALIGN_VARIABLES;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PropertyPatternsSettingDescription")]
public bool INT_ALIGN_PROPERTY_PATTERNS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OtherAssignmentsAndInitializersSettingDescription")]
public bool INT_ALIGN_ASSIGNMENTS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "NestedTernaryOperatorsSettingDescription")]
public bool INT_ALIGN_NESTED_TERNARY;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "InvocationsOfTheSameMethodSettingDescription")]
public bool INT_ALIGN_INVOCATIONS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BinaryExpressionsSettingDescription")]
public bool INT_ALIGN_BINARY_EXPRESSIONS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "EndCommentsSettingDescription")]
public bool INT_ALIGN_COMMENTS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "SimpleSwitchSectionsSettingDescription")]
public bool INT_ALIGN_SWITCH_SECTIONS;
    [EditorConfigEntryAliasAttribute("int_align", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "SwitchExpressionsSettingDescription")]
public bool INT_ALIGN_SWITCH_EXPRESSIONS;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfParenthesisInInvocationSettingDescription")]
public bool KEEP_EXISTING_INVOCATION_PARENS_ARRANGEMENT;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfParenthesisInDeclarationSettingDescription")]
public bool KEEP_EXISTING_DECLARATION_PARENS_ARRANGEMENT;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfParenthesisInDeclarationSettingDescription")]
public bool KEEP_EXISTING_PRIMARY_CONSTRUCTOR_DECLARATION_PARENS_ARRANGEMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeInvocationRpar_SettingsEntryDescription")]
public bool WRAP_BEFORE_INVOCATION_RPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeInvocationLpar_SettingsEntryDescription")]
public bool WRAP_BEFORE_INVOCATION_LPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapAfterInvocationLpar_SettingsEntryDescription")]
public bool WRAP_AFTER_INVOCATION_LPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeDeclarationRpar_SettingsEntryDescription")]
public bool WRAP_BEFORE_DECLARATION_RPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeDeclarationRpar_SettingsEntryDescription")]
public bool WRAP_BEFORE_PRIMARY_CONSTRUCTOR_DECLARATION_RPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeDeclarationLpar_SettingsEntryDescription")]
public bool WRAP_BEFORE_DECLARATION_LPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeDeclarationLpar_SettingsEntryDescription")]
public bool WRAP_BEFORE_PRIMARY_CONSTRUCTOR_DECLARATION_LPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapAfterDeclarationLpar_SettingsEntryDescription")]
public bool WRAP_AFTER_DECLARATION_LPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapAfterDeclarationLpar_SettingsEntryDescription")]
public bool WRAP_AFTER_PRIMARY_CONSTRUCTOR_DECLARATION_LPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferWrapBeforeTypeParametersOpeningAngleSettingDescription")]
public bool WRAP_BEFORE_TYPE_PARAMETER_LANGLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeExtendsColon_SettingsEntryDescription")]
public bool WRAP_BEFORE_EXTENDS_COLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferWrapBeforeOperatorInBinaryExpressionSettingDescription")]
public bool WRAP_BEFORE_BINARY_OPSIGN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferWrapBeforeOperatorInBinaryPatternSettingDescription")]
public bool WRAP_BEFORE_BINARY_PATTERN_OP;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferWrapBeforeFirstConstraintSettingDescription")]
public bool WRAP_BEFORE_FIRST_TYPE_PARAMETER_CONSTRAINT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapAfterDotInMethodCalls_SettingsEntryDescription")]
public bool WRAP_AFTER_DOT_IN_METHOD_CALLS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_PreferToWrapBeforeFirstMethodCall_SettingsEntryDescription")]
public bool WRAP_BEFORE_FIRST_METHOD_CALL;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_PreferToWrapAfterPropertiesAndFields_SettingsEntryDescription")]
public bool WRAP_AFTER_PROPERTY_IN_CHAINED_METHOD_CALLS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeComma_SettingsEntryDescription")]
public bool WRAP_BEFORE_COMMA;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeEq_SettingsEntryDescription")]
public bool WRAP_BEFORE_EQ;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapAroundEq_SettingsEntryDescription")]
public PreferWrap PREFER_WRAP_AROUND_EQ;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeTernaryOpsigns_SettingsEntryDescription")]
public bool WRAP_BEFORE_TERNARY_OPSIGNS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferWrapBeforeMultilineLINQExpressionsSettingDescription")]
public bool WRAP_BEFORE_LINQ_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceChopCompoundIfExpressionDescription")]
public bool FORCE_CHOP_COMPOUND_IF_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceChopCompoundWhileExpressionDescription")]
public bool FORCE_CHOP_COMPOUND_WHILE_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceChopCompoundDoExpressionDescription")]
public bool FORCE_CHOP_COMPOUND_DO_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_PlaceLinqInotOnNewLine_SettingsEntryDescription")]
public bool PLACE_LINQ_INTO_ON_NEW_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapFormalParametersSettingDescription")]
public WrapStyle WRAP_PARAMETERS_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapPrimaryConstructorParametersSettingDescription")]
public WrapStyle WRAP_PRIMARY_CONSTRUCTOR_PARAMETERS_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapInvocationArgumentsSettingDescription")]
public WrapStyle WRAP_ARGUMENTS_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapExtendsImplementsListSettingDescription")]
public WrapStyle WRAP_EXTENDS_LIST_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapForStmtHeaderStyle_SettingsEntryDescription")]
public WrapStyle WRAP_FOR_STMT_HEADER_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapTernaryExpressionSettingDescription")]
public WrapStyle WRAP_TERNARY_EXPR_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapMultipleDeclarationSettingDescription")]
public WrapStyle WRAP_MULTIPLE_DECLARATION_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapObjectAndCollectionInitializerSettingDescription")]
public WrapStyle WRAP_OBJECT_AND_COLLECTION_INITIALIZER_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapPropertyPatternSettingDescription")]
public WrapStyle WRAP_PROPERTY_PATTERN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapListPatternSettingDescription")]
public WrapStyle WRAP_LIST_PATTERN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapSwitchExpressionSettingDescription")]
public WrapStyle WRAP_SWITCH_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapArrayInitializerSettingDescription")]
public WrapStyle WRAP_ARRAY_INITIALIZER_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapChainedMethodCallsSettingDescription")]
public WrapStyle WRAP_CHAINED_METHOD_CALLS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapLINQExpressionsSettingDescription")]
public WrapStyle WRAP_LINQ_EXPRESSIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapEnumerationDeclarationSettingDescription")]
public WrapStyle WRAP_ENUM_DECLARATION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapChainedBinaryExpressionsSettingDescription")]
public WrapStyleSimple WRAP_CHAINED_BINARY_EXPRESSIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapComplexBinaryPatternsSettingDescription")]
public WrapStyleSimple WRAP_CHAINED_BINARY_PATTERNS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapVerbatimInterpolatedStringsSettingDescription")]
public WrapStyleExpanded WRAP_VERBATIM_INTERPOLATED_STRINGS;
    [EditorConfigEntryAliasAttribute("wrap_multiple_type_parameter_constraints_style", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WrapMultipleTypeParameterConstraintsSettingDescription")]
public WrapStyle WRAP_MULTIPLE_TYPE_PARAMEER_CONSTRAINTS_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MaxFormalParametersOnASingleLineSettingDescription")]
public int MAX_FORMAL_PARAMETERS_ON_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MaxPrimaryConstructorParametersOnASingleLineSettingDescription")]
public int MAX_PRIMARY_CONSTRUCTOR_PARAMETERS_ON_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MaxInvocationArgumentsOnASingleLineSettingDescription")]
public int MAX_INVOCATION_ARGUMENTS_ON_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MaxObjectAndCollectionInitializerElementsOnASingleLineSettingDescription")]
public int MAX_INITIALIZER_ELEMENTS_ON_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MaxArrayInitializerElementsOnASingleLineSettingDescription")]
public int MAX_ARRAY_INITIALIZER_ELEMENTS_ON_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MaxEnumerationMembersOnASingleLineSettingDescription")]
public int MAX_ENUM_MEMBERS_ON_LINE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfDeclarationBlocksSettingDescription")]
public bool KEEP_EXISTING_DECLARATION_BLOCK_ARRANGEMENT;
    [EditorConfigEntryAliasAttribute("place_simple_blocks_on_single_line", "2")]
[EditorConfigEntryAliasAttribute("place_simple_declaration_blocks_on_single_line", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceAbstractAutoPropertyIndexerEventDeclarationOnSingleLineSettingDescription")]
public bool PLACE_ABSTRACT_ACCESSORHOLDER_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("place_simple_blocks_on_single_line", "2")]
[EditorConfigEntryAliasAttribute("place_simple_declaration_blocks_on_single_line", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimplePropertyIndexerEventDeclarationOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_ACCESSORHOLDER_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("place_simple_blocks_on_single_line", "2")]
[EditorConfigEntryAliasAttribute("place_simple_declaration_blocks_on_single_line", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceItOnSingleLineEvenWhenItHasAttributesOnAccessorsSettingDescription")]
public bool PLACE_ACCESSOR_WITH_ATTRS_HOLDER_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("place_simple_blocks_on_single_line", "2")]
[EditorConfigEntryAliasAttribute("place_simple_declaration_blocks_on_single_line", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimpleAccessorOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_ACCESSOR_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("place_simple_blocks_on_single_line", "2")]
[EditorConfigEntryAliasAttribute("place_simple_declaration_blocks_on_single_line", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimpleMethodOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_METHOD_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfEnumerationSettingDescription")]
public bool KEEP_EXISTING_ENUM_ARRANGEMENT;
    [EditorConfigEntryAliasAttribute("place_simple_blocks_on_single_line", "2")]
[EditorConfigEntryAliasAttribute("place_simple_declaration_blocks_on_single_line", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimpleEnumerationOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_ENUM_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfExpressionBodiedMembersSettingDescription")]
public bool KEEP_EXISTING_EXPR_MEMBER_ARRANGEMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceMethodExpressionBodyOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_EXPR_METHOD_ON_SINGLE_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlacePropertyExpressionBodyOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_EXPR_PROPERTY_ON_SINGLE_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlacePropertyAccessorExpressionBodyOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_EXPR_ACCESSOR_ON_SINGLE_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_WrapBeforeArrowWithExpressions_SettingsEntryDescription")]
public bool WRAP_BEFORE_ARROW_WITH_EXPRESSIONS;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfEmbeddedStatementsSettingDescription")]
public bool KEEP_EXISTING_EMBEDDED_ARRANGEMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimpleEmbeddedStatementOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_SIMPLE_EMBEDDED_STATEMENT_ON_SAME_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_PlaceSimpleCaseStatementOnSameLine_SettingsEntryDescription")]
public PlaceOnSameLineAsOwner PLACE_SIMPLE_CASE_STATEMENT_ON_SAME_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_TreatCaseStatementWithBreakAsSimple_SettingsEntryDescription")]
public bool TREAT_CASE_STATEMENT_WITH_BREAK_AS_SIMPLE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfEmbeddedBlocksSettingDescription")]
public bool KEEP_EXISTING_EMBEDDED_BLOCK_ARRANGEMENT;
    [EditorConfigEntryAliasAttribute("place_simple_blocks_on_single_line", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceABlockWithASingleSimpleStatementOnTheSameLineSettingDescription")]
public bool PLACE_SIMPLE_EMBEDDED_BLOCK_ON_SAME_LINE;
    [EditorConfigEntryAliasAttribute("place_simple_blocks_on_single_line", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimpleAnonymousMethodOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_ANONYMOUSMETHOD_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfInitializersSettingDescription")]
public bool KEEP_EXISTING_INITIALIZER_ARRANGEMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimpleArrayObjectAndCollectionOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_INITIALIZER_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfPropertyPatternsSettingDescription")]
public bool KEEP_EXISTING_PROPERTY_PATTERNS_ARRANGEMENT;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfListPatternsSettingDescription")]
public bool KEEP_EXISTING_LIST_PATTERNS_ARRANGEMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimplePropertyPatternOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_PROPERTY_PATTERN_ON_SINGLE_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimpleListPatternOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_LIST_PATTERN_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfSwitchExpressionsSettingDescription")]
public bool KEEP_EXISTING_SWITCH_EXPRESSION_ARRANGEMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSimpleSwitchExpressionOnSingleLineSettingDescription")]
public bool PLACE_SIMPLE_SWITCH_EXPRESSION_ON_SINGLE_LINE;
    [EditorConfigEntryAliasAttribute("keep_existing_arrangement", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingArrangementOfAttributesSettingDescription")]
public bool KEEP_EXISTING_ATTRIBUTE_ARRANGEMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceAttributeSectionListOnSeparateLineIfItIsLongerThanSettingDescription")]
public int MAX_ATTRIBUTE_LENGTH_FOR_SAME_LINE;
    [EditorConfigEntryAliasAttribute("place_attribute_on_same_line", "2")]
[EditorConfigEntryAliasAttribute("place_type_attribute_on_same_line", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceTypeAttributeOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_TYPE_ATTRIBUTE_ON_SAME_LINE_EX;
    [EditorConfigEntryAliasAttribute("place_attribute_on_same_line", "2")]
[EditorConfigEntryAliasAttribute("place_method_attribute_on_same_line", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceMethodAttributeOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_METHOD_ATTRIBUTE_ON_SAME_LINE_EX;
    [EditorConfigEntryAliasAttribute("place_attribute_on_same_line", "2")]
[EditorConfigEntryAliasAttribute("place_accessorholder_attribute_on_same_line", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlacePropertyIndexerEventAttributeOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_ACCESSORHOLDER_ATTRIBUTE_ON_SAME_LINE_EX;
    [EditorConfigEntryAliasAttribute("place_attribute_on_same_line", "2")]
[EditorConfigEntryAliasAttribute("place_accessor_attribute_on_same_line", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceAccessorAttributeOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_ACCESSOR_ATTRIBUTE_ON_SAME_LINE_EX;
    [EditorConfigEntryAliasAttribute("place_attribute_on_same_line", "2")]
[EditorConfigEntryAliasAttribute("place_field_attribute_on_same_line", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceFieldAttributeOnTheSameLineSettingDescription")]
public PlaceOnSameLineAsOwner PLACE_FIELD_ATTRIBUTE_ON_SAME_LINE_EX;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AllowTypeConstraintsOnTheSameLineSettingDescription")]
public bool PLACE_TYPE_CONSTRAINTS_ON_SAME_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AllowConstructorInitializerOnTheSameLineSettingDescription")]
public bool PLACE_CONSTRUCTOR_INITIALIZER_ON_SAME_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AllowPrimaryConstructorInitializerOnTheSameLineSettingDescription")]
public bool PLACE_PRIMARY_CONSTRUCTOR_INITIALIZER_ON_SAME_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AllowCommentAfterSettingDescription")]
public bool ALLOW_COMMENT_AFTER_LBRACE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_SpecialElseIfTreatment_SettingsEntryDescription")]
public bool SPECIAL_ELSE_IF_TREATMENT;
    [EditorConfigEntryAliasAttribute("place_attribute_on_same_line", "2")]
[EditorConfigEntryAliasAttribute("place_record_field_attribute_on_same_line", "0")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceRecordFieldAttributeOnTheSameLine")]
public PlaceOnSameLineAsOwner PLACE_RECORD_FIELD_ATTRIBUTE_ON_SAME_LINE_EX;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentIfElseElifEndifSettingDescription")]
public SpecialIndent INDENT_PREPROCESSOR_IF;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentRegionEndregionSettingDescription")]
public SpecialIndent INDENT_PREPROCESSOR_REGION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentOtherPreprocessorDirectivesSettingDescription")]
public SpecialIndent INDENT_PREPROCESSOR_OTHER;
    [EditorConfigEntryAliasAttribute("indent_switch_labels", "16")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_IndentCaseFromSwitch_SettingsEntry")]
public bool INDENT_CASE_FROM_SWITCH;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_IndentCaseFromSwitch_SettingsEntry")]
public bool INDENT_BREAK_FROM_CASE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "IndentNestedUsingsStmtDescription")]
public bool INDENT_NESTED_USINGS_STMT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "IndentNestedFixedStmtDescription")]
public bool INDENT_NESTED_FIXED_STMT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "IndentNestedLockStmtDescription")]
public bool INDENT_NESTED_LOCK_STMT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "IndentNestedForStmtDescription")]
public bool INDENT_NESTED_FOR_STMT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "IndentNestedForeachStmtDescription")]
public bool INDENT_NESTED_FOREACH_STMT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "IndentNestedWhileStmtDescription")]
public bool INDENT_NESTED_WHILE_STMT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentTypeConstraintsSettingDescription")]
public bool INDENT_TYPE_CONSTRAINTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentMethodDeclarationsParenthesisSettingDescription")]
public ParsFormatStyle INDENT_METHOD_DECL_PARS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentPrimaryConstructorDeclarationsParenthesisSettingDescription")]
public ParsFormatStyle INDENT_PRIMARY_CONSTRUCTOR_DECL_PARS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentMethodCallsParenthesisSettingDescription")]
public ParsFormatStyle INDENT_INVOCATION_PARS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentStatementIfWhileForEtcParenthesisSettingDescription")]
public ParsFormatStyle INDENT_STATEMENT_PARS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentTypeParametersAnglesSettingDescription")]
public ParsFormatStyle INDENT_TYPEPARAM_ANGLES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentTypeArgumentsAnglesSettingDescription")]
public ParsFormatStyle INDENT_TYPEARG_ANGLES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IndentOtherParenthesisAndBracketsSettingDescription")]
public ParsFormatStyle INDENT_PARS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UseContinuousLineIndentInsideParenthesisSettingDescription")]
public bool USE_CONTINUOUS_INDENT_INSIDE_PARENS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "UseContinuousLineIndentInsideExpressionBracesSettingDescription")]
public bool USE_CONTINUOUS_INDENT_INSIDE_INITIALIZER_BRACES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "DontIndentCommentsStartedAtFirstColumnSettingDescription")]
public bool STICK_COMMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceCommentsAtFirstColumnWhenCommentingOutCodeSettingDescription")]
public bool PLACE_COMMENTS_AT_FIRST_COLUMN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "IncludePrefixCommentsInIndentsSettingDescription")]
public bool INCLUDE_PREFIX_COMMENT_IN_INDENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AlignMultilineCommentsWithAsterisksSettingsDescription")]
public bool ALIGN_MULTILINE_COMMENTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "HowToIndentRawStringLiteralsSettingsDescription")]
public AlignIndentDontChangeStyle INDENT_RAW_LITERAL_STRING;
    [ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "GeneratorModeSettingDescription")]
public bool GeneratorMode;
    [ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "DontRemoveExtraBlankLinesSettingDescription")]
public bool DontRemoveExtraBlankLines;
    [ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "DontForceSingleLinesSettingDescription")]
public bool IgnoreForceSingleLineSetting;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BreakLineInSingleEmbeddedStatementSettingDescription")]
public SimpleEmbeddedStatementStyle SIMPLE_EMBEDDED_STATEMENT_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_SimpleCaseStatementStyle_SettingsEntryDescription")]
public SimpleEmbeddedStatementStyle SIMPLE_CASE_STATEMENT_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BreakLineInABlockWithASingleStatementSettingDescription")]
public SimpleEmbeddedStatementStyle SIMPLE_EMBEDDED_BLOCK_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "KeepExistingAttributePlacementSettingDescription")]
public bool KEEP_EXISTING_ATTRIBUTE_PLACEMENT;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceAttributeOnSeparateLineIfItIsLongerThanSettingDescription")]
public int MAX_ATTRIBUTES_LENGTH_FOR_SAME_LINE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceIfElseBracesStyleDescription")]
public ForceBraceStyle FORCE_IFELSE_BRACES_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceForBracesStyleDescription")]
public ForceBraceStyle FORCE_FOR_BRACES_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceForeachBracesStyleDescription")]
public ForceBraceStyle FORCE_FOREACH_BRACES_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceWhileBracesStyleDescription")]
public ForceBraceStyle FORCE_WHILE_BRACES_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceUsingBracesStyleDescription")]
public ForceBraceStyle FORCE_USING_BRACES_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper", "ForceFixedBracesStyleDescription")]
public ForceBraceStyle FORCE_FIXED_BRACES_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CSharpFormatSettingsKey_RedundantThisQualifierStyle_SettingsEntryDescription")]
public ThisQualifierStyle2 REDUNDANT_THIS_QUALIFIER_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceTypeAttributeOnTheSameLineSettingDescription")]
public bool PLACE_TYPE_ATTRIBUTE_ON_SAME_LINE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceMethodAttributeOnTheSameLineSettingDescription")]
public bool PLACE_METHOD_ATTRIBUTE_ON_SAME_LINE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSinglelineMethodAttributeOnTheSameLineSettingDescription")]
public bool PLACE_SINGLELINE_METHOD_ATTRIBUTE_ON_SAME_LINE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlacePropertyIndexerEventAttributeOnTheSameLineSettingDescription")]
public bool PLACE_ACCESSORHOLDER_ATTRIBUTE_ON_SAME_LINE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceSinglelineAccessorAttributeOnTheSameLineSettingDescription")]
public bool PLACE_SIMPLE_ACCESSOR_ATTRIBUTE_ON_SAME_LINE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceMultilineAccessorAttributeOnTheSameLineSettingDescription")]
public bool PLACE_COMPLEX_ACCESSOR_ATTRIBUTE_ON_SAME_LINE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PlaceFieldAttributeOnTheSameLineSettingDescription")]
public bool PLACE_FIELD_ATTRIBUTE_ON_SAME_LINE;
    public bool REMOVE_BLANK_LINES_NEAR_BRACES_IN_PARENT_LANGUAGES;
    public CSharpFormatSettingsKey Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingsKeyConstantsHelper : object {
    public static string SpaceIfParenthesesDescription { get; }
    public static string SpaceWhileParenthesesDescription { get; }
    public static string SpaceCatchParenthesesDescription { get; }
    public static string SpaceSwitchParenthesesDescription { get; }
    public static string SpaceForParenthesesDescription { get; }
    public static string SpaceForeachParenthesesDescription { get; }
    public static string SpaceUsingParenthesesDescription { get; }
    public static string SpaceLockParenthesesDescription { get; }
    public static string SpaceFixedParenthesesDescription { get; }
    public static string SpaceTypeofParenthesesDescription { get; }
    public static string SpaceDefaultParenthesesDescription { get; }
    public static string SpaceSizeofParenthesesDescription { get; }
    public static string SpaceCheckedUncheckedParenthesesDescription { get; }
    public static string SpaceNameofParenthesesDescription { get; }
    public static string SpaceNewParenthesesDescription { get; }
    public static string ForceChopCompoundIfExpressionDescription { get; }
    public static string ForceChopCompoundWhileExpressionDescription { get; }
    public static string ForceChopCompoundDoExpressionDescription { get; }
    public static string IndentNestedUsingsStmtDescription { get; }
    public static string IndentNestedFixedStmtDescription { get; }
    public static string IndentNestedLockStmtDescription { get; }
    public static string IndentNestedForStmtDescription { get; }
    public static string IndentNestedForeachStmtDescription { get; }
    public static string IndentNestedWhileStmtDescription { get; }
    public static string ForceIfElseBracesStyleDescription { get; }
    public static string ForceForBracesStyleDescription { get; }
    public static string ForceForeachBracesStyleDescription { get; }
    public static string ForceWhileBracesStyleDescription { get; }
    public static string ForceUsingBracesStyleDescription { get; }
    public static string ForceFixedBracesStyleDescription { get; }
    public static string get_SpaceIfParenthesesDescription();
    public static string get_SpaceWhileParenthesesDescription();
    public static string get_SpaceCatchParenthesesDescription();
    public static string get_SpaceSwitchParenthesesDescription();
    public static string get_SpaceForParenthesesDescription();
    public static string get_SpaceForeachParenthesesDescription();
    public static string get_SpaceUsingParenthesesDescription();
    public static string get_SpaceLockParenthesesDescription();
    public static string get_SpaceFixedParenthesesDescription();
    public static string get_SpaceTypeofParenthesesDescription();
    public static string get_SpaceDefaultParenthesesDescription();
    public static string get_SpaceSizeofParenthesesDescription();
    public static string get_SpaceCheckedUncheckedParenthesesDescription();
    public static string get_SpaceNameofParenthesesDescription();
    public static string get_SpaceNewParenthesesDescription();
    public static string get_ForceChopCompoundIfExpressionDescription();
    public static string get_ForceChopCompoundWhileExpressionDescription();
    public static string get_ForceChopCompoundDoExpressionDescription();
    public static string get_IndentNestedUsingsStmtDescription();
    public static string get_IndentNestedFixedStmtDescription();
    public static string get_IndentNestedLockStmtDescription();
    public static string get_IndentNestedForStmtDescription();
    public static string get_IndentNestedForeachStmtDescription();
    public static string get_IndentNestedWhileStmtDescription();
    public static string get_ForceIfElseBracesStyleDescription();
    public static string get_ForceForBracesStyleDescription();
    public static string get_ForceForeachBracesStyleDescription();
    public static string get_ForceWhileBracesStyleDescription();
    public static string get_ForceUsingBracesStyleDescription();
    public static string get_ForceFixedBracesStyleDescription();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.CSharpFormatSettingUpgradeDescription : object {
    [CompilerGeneratedAttribute]
private ICollectionEvents`1<ScalarSettingDescription> <Items>k__BackingField;
    public ICollectionEvents`1<ScalarSettingDescription> Items { get; }
    public CSharpFormatSettingUpgradeDescription(ISettingsSchema schema);
    [CompilerGeneratedAttribute]
public sealed virtual ICollectionEvents`1<ScalarSettingDescription> get_Items();
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.ForceBraceStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Do not change")]
public static ForceBraceStyle DO_NOT_CHANGE;
    [LocalizedDescriptionAttribute("Remove braces")]
public static ForceBraceStyle ALWAYS_REMOVE;
    [LocalizedDescriptionAttribute("Add braces")]
public static ForceBraceStyle ALWAYS_ADD;
    [LocalizedDescriptionAttribute("Use braces for multiline")]
public static ForceBraceStyle ONLY_FOR_MULTILINE;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.PreferWrap : Enum {
    public int value__;
    [DisplayAttribute]
public static PreferWrap ALWAYS_IF_MULTILINE;
    [DisplayAttribute]
public static PreferWrap STRONGLY;
    [DisplayAttribute]
public static PreferWrap DEFAULT;
    [DisplayAttribute]
public static PreferWrap AVOID;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.FormatSettings.ThisQualifierStyle2 : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Use always")]
public static ThisQualifierStyle2 ALWAYS_USE;
    [LocalizedDescriptionAttribute("For fields")]
public static ThisQualifierStyle2 USE_FOR_FIELD;
    [LocalizedDescriptionAttribute("For this class members")]
public static ThisQualifierStyle2 USE_FOR_THIS_CLASS;
    [LocalizedDescriptionAttribute("For fields in this class")]
public static ThisQualifierStyle2 USE_FOR_VARIABLES_IN_THIS_CLASS;
    [LocalizedDescriptionAttribute("Do not use")]
public static ThisQualifierStyle2 DO_NOT_USE;
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.IAdditionalCSharpFileLayoutPatternProvider {
    public abstract virtual Patterns GetPattern(IContextBoundSettingsStore store, ICSharpTypeAndNamespaceHolderDeclaration declaration);
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.ICSharpCodeFormatter {
    public abstract virtual void FormatDocComment(IDocCommentBlock docCommentBlock);
    public abstract virtual void UpdateAccessorOwnerLayout(IAccessorDeclaration accessor);
    public abstract virtual Nullable`1<Whitespace> GetIndent(ITreeNode node, Position position, ITreeNode imagineLineBreakBeforeThis, FmtSettingsHolder`1<CSharpFormatSettingsKey> settings);
    public abstract virtual FmtSettingsHolder`1<CSharpFormatSettingsKey> GetFormattingSettings(ITreeNode node, AdditionalFormatterParameters parameters);
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.ICustomIndentHandler {
    public abstract virtual string Indent(ITreeNode node, CustomIndentType indentType, FmtSettingsClassic`1<CSharpFormatSettingsKey> settings);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.MemberReordering.Migrations.CSharpFileLayoutPatternRemoveIsAttributeUpgrade : object {
    public sealed virtual IEnumerable`1<SettingsEntry> GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.MemberReordering.Migrations.CSharpFileLayoutPatternRemoveIsAttributeUpgrade/<GetKeysToMigrate>d__1")]
public sealed virtual IEnumerable`1<SettingsKey> GetKeysToMigrate(ISettingsSchema schema);
    public sealed virtual void Migrate(IContextBoundSettingsStoreImplementation store);
    private string GetUpgradedPattern(IContextBoundSettingsStore settingsStore);
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.NullCheckingPatternStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("")]
public static NullCheckingPatternStyle EmptyRecursivePattern;
    [LocalizedDescriptionAttribute("")]
public static NullCheckingPatternStyle NotNullPattern;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.AccessorOwnerBodyStyle : Enum {
    public int value__;
    [DescriptionAttribute("Expression body")]
public static AccessorOwnerBodyStyle ExpressionBody;
    [DescriptionAttribute("Accessors with expression body")]
public static AccessorOwnerBodyStyle AccessorsWithExpressionBody;
    [DescriptionAttribute("Accessors with block body")]
public static AccessorOwnerBodyStyle AccessorsWithBlockBody;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.ArgumentsStyle : Enum {
    public int value__;
    [DescriptionAttribute("Positional argument")]
public static ArgumentsStyle Positional;
    [DescriptionAttribute("Named argument")]
public static ArgumentsStyle Named;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.AttributeStyle : Enum {
    public int value__;
    [DescriptionAttribute("Join")]
public static AttributeStyle Join;
    [DescriptionAttribute("Separate")]
public static AttributeStyle Separate;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.BinaryOperationGroupType : Enum {
    public int value__;
    [BrowsableAttribute("False")]
public static BinaryOperationGroupType None;
    [DescriptionAttribute("*  /  %  +  -  <<  >>  &  ^  |")]
public static BinaryOperationGroupType Arithmetic;
    [DescriptionAttribute("<  >  <=  >=  ==  !=")]
public static BinaryOperationGroupType Relational;
    [DescriptionAttribute("&& || ??")]
public static BinaryOperationGroupType Conditional;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.BinaryOperationType : Enum {
    public int value__;
    [BrowsableAttribute("False")]
public static BinaryOperationType None;
    [DescriptionAttribute("*  /  %")]
[BrowsableAttribute("False")]
public static BinaryOperationType Multiplicative;
    [DescriptionAttribute("+  -")]
[BrowsableAttribute("False")]
public static BinaryOperationType Additive;
    [DescriptionAttribute("*  /  %  +  -")]
public static BinaryOperationType Arithmetic;
    [DescriptionAttribute("<<  >>")]
public static BinaryOperationType Shift;
    [DescriptionAttribute("<  >  <=  >=")]
public static BinaryOperationType Relational;
    [DescriptionAttribute("==  !=")]
public static BinaryOperationType Equality;
    [DescriptionAttribute("&")]
[BrowsableAttribute("False")]
public static BinaryOperationType BitwiseAnd;
    [DescriptionAttribute("^")]
[BrowsableAttribute("False")]
public static BinaryOperationType BitwiseExclusiveOr;
    [DescriptionAttribute("|")]
[BrowsableAttribute("False")]
public static BinaryOperationType BitwiseInclusiveOr;
    [DescriptionAttribute("&  ^  |")]
public static BinaryOperationType Bitwise;
    [DescriptionAttribute("&&")]
[BrowsableAttribute("False")]
public static BinaryOperationType ConditionalAnd;
    [DescriptionAttribute("||")]
[BrowsableAttribute("False")]
public static BinaryOperationType ConditionalOr;
    [DescriptionAttribute("&&  ||")]
public static BinaryOperationType Conditional;
    [DescriptionAttribute("??")]
public static BinaryOperationType NullCoalescing;
    [DescriptionAttribute("..")]
public static BinaryOperationType Range;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
public static BinaryOperationType Lowest;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.BracesCodeStyle : Enum {
    public int value__;
    [DescriptionAttribute("Do not enforce")]
public static BracesCodeStyle NotRequired;
    [DescriptionAttribute("Enforce always")]
public static BracesCodeStyle Required;
    [DescriptionAttribute("Enforce if body is multi-line")]
public static BracesCodeStyle RequiredForMultiline;
    [DescriptionAttribute("Enforce if statement is multi-line")]
public static BracesCodeStyle RequiredForMultilineStatement;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
[DescriptionAttribute("Enforce if body is complex")]
public static BracesCodeStyle RequiredForComplex;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.BuiltInTypeStyle : Enum {
    public int value__;
    [DescriptionAttribute("Keyword")]
public static BuiltInTypeStyle UseKeyword;
    [DescriptionAttribute("CLR type name")]
public static BuiltInTypeStyle UseClrName;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
public static BuiltInTypeStyle Dynamic;
}
public static class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsAccessors : object {
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> APPLY_ON_COMPLETION;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BuiltInTypeStyle>> BUILTIN_TYPE_REFERENCE_STYLE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BuiltInTypeStyle>> BUILTIN_TYPE_REFERENCE_FOR_MEMBER_ACCESS_STYLE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> BUILTIN_TYPE_APPLY_TO_NATIVE_INTEGER;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, DefaultModifierDefinition>> DEFAULT_PRIVATE_MODIFIER;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, DefaultModifierDefinition>> DEFAULT_INTERNAL_MODIFIER;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, string>> MODIFIERS_ORDER;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> ARGUMENTS_SKIP_SINGLE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> ARGUMENTS_LITERAL;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> ARGUMENTS_STRING_LITERAL;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> ARGUMENTS_NAMED_EXPRESSION;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> ARGUMENTS_ANONYMOUS_FUNCTION;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ArgumentsStyle>> ARGUMENTS_OTHER;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ParenthesesRedundancyStyle>> PARENTHESES_REDUNDANCY_STYLE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BinaryOperationType>> PARENTHESES_NON_OBVIOUS_OPERATIONS;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BinaryOperationGroupType>> PARENTHESES_GROUP_NON_OBVIOUS_OPERATIONS;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> PARENTHESES_SAME_TYPE_OPERATIONS;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> BRACES_REDUNDANT;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, IfElseBracesCodeStyle>> BRACES_FOR_IFELSE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> BRACES_FOR_FOR;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> BRACES_FOR_FOREACH;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> BRACES_FOR_WHILE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> BRACES_FOR_DOWHILE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> BRACES_FOR_USING;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> BRACES_FOR_LOCK;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, BracesCodeStyle>> BRACES_FOR_FIXED;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, AttributeStyle>> FORCE_ATTRIBUTE_STYLE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, FunctionBodyStyle>> METHOD_OR_OPERATOR_BODY;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, FunctionBodyStyle>> LOCAL_FUNCTION_BODY;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, FunctionBodyStyle>> CONSTRUCTOR_OR_DESTRUCTOR_BODY;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, AccessorOwnerBodyStyle>> ACCESSOR_OWNER_BODY;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, NamespaceBodyStyle>> NAMESPACE_BODY;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> USE_HEURISTICS_FOR_BODY_STYLE;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> TRAILING_COMMA_IN_MULTILINE_LISTS;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, bool>> TRAILING_COMMA_IN_SINGLELINE_LISTS;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ObjectCreationStyle>> OBJECT_CREATION_WHEN_TYPE_EVIDENT;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, ObjectCreationStyle>> OBJECT_CREATION_WHEN_TYPE_NOT_EVIDENT;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, DefaultValueStyle>> DEFAULT_VALUE_WHEN_TYPE_EVIDENT;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, DefaultValueStyle>> DEFAULT_VALUE_WHEN_TYPE_NOT_EVIDENT;
    [NotNullAttribute]
public static Expression`1<Func`2<ThisQualifierSettingsKey, QualifiedMember>> USE_THIS_FOR;
    [NotNullAttribute]
public static Expression`1<Func`2<ThisQualifierSettingsKey, MemberDeclaredIn>> QUALIFY_MEMBERS_DECLARED_IN;
    [NotNullAttribute]
public static Expression`1<Func`2<StaticQualifierSettingsKey, QualifiedMember>> STATIC_MEMBERS_TO_QUALIFY;
    [NotNullAttribute]
public static Expression`1<Func`2<StaticQualifierSettingsKey, StaticMemberQualifierStyle>> QUALIFY_WITH_NAME_OF;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpCodeStyleSettingsKey, NullCheckingPatternStyle>> PATTERNS_NULL_CHECKING_PATTERN_STYLE;
    private static CSharpCodeStyleSettingsAccessors();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.CodeStyle.CodeFormattingSettingsKey", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "SyntaxStyleInCSettingDescription")]
[EditorConfigKeyAttribute("csharp")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKey : object {
    public static string DefaultModifiersOrderString;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ApplySyntaxStyleOnCodeCompletionSettingDescription")]
public bool APPLY_ON_COMPLETION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "InLocalsMembersAndParametersPreferSettingDescription")]
public BuiltInTypeStyle BUILTIN_TYPE_REFERENCE_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "InMemberAccessExpressionsPreferSettingDescription")]
public BuiltInTypeStyle BUILTIN_TYPE_REFERENCE_FOR_MEMBER_ACCESS_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ApplyToNativeIntegerDescription")]
public bool BUILTIN_TYPE_APPLY_TO_NATIVE_INTEGER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferExplicitImplicitPrivateModifierForTypeMembersSettingDescription")]
public DefaultModifierDefinition DEFAULT_PRIVATE_MODIFIER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PreferExplicitImplicitInternalModifierForTypesSettingDescription")]
public DefaultModifierDefinition DEFAULT_INTERNAL_MODIFIER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ModifiersOrderSettingDescription")]
public string MODIFIERS_ORDER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "SkipSingleArgumentsSettingDescription")]
public bool ARGUMENTS_SKIP_SINGLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "LiteralValuesSettingDescription")]
public ArgumentsStyle ARGUMENTS_LITERAL;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "StringLiteralValuesSettingDescription")]
public ArgumentsStyle ARGUMENTS_STRING_LITERAL;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "NamedExpressionsVariablesPropertiesMethodsEtcSettingDescription")]
public ArgumentsStyle ARGUMENTS_NAMED;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AnonymousMethodsDelegatesAndLambdasSettingDescription")]
public ArgumentsStyle ARGUMENTS_ANONYMOUS_FUNCTION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "OtherSettingDescription")]
public ArgumentsStyle ARGUMENTS_OTHER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "RemoveRedundantParenthesesSettingDescription")]
public ParenthesesRedundancyStyle PARENTHESES_REDUNDANCY_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "AroundOperandsOfTheFollowingOperationsSettingDescription")]
public BinaryOperationType PARENTHESES_NON_OBVIOUS_OPERATIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WhenTheOperationsFromTheFollowingGroupsAreNestedSettingDescription")]
public BinaryOperationGroupType PARENTHESES_GROUP_NON_OBVIOUS_OPERATIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "EvenWhenOperationsOfTheSameTypeAreNestedSettingDescription")]
public bool PARENTHESES_SAME_TYPE_OPERATIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "RemoveRedundantSettingDescription")]
public bool BRACES_REDUNDANT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper", "BracesForIfElseDescription")]
public IfElseBracesCodeStyle BRACES_FOR_IFELSE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper", "BracesForForDescription")]
public BracesCodeStyle BRACES_FOR_FOR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper", "BracesForForeachDescription")]
public BracesCodeStyle BRACES_FOR_FOREACH;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper", "BracesForWhileDescription")]
public BracesCodeStyle BRACES_FOR_WHILE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper", "BracesForDoWhileDescription")]
public BracesCodeStyle BRACES_FOR_DOWHILE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper", "BracesForUsingDescription")]
public BracesCodeStyle BRACES_FOR_USING;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper", "BracesForLockDescription")]
public BracesCodeStyle BRACES_FOR_LOCK;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper", "BracesForFixedDescription")]
public BracesCodeStyle BRACES_FOR_FIXED;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "JoinOrSeparateAttributesInSectionSettingDescription")]
public AttributeStyle FORCE_ATTRIBUTE_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MethodsAndOperatorsSettingDescription")]
public FunctionBodyStyle METHOD_OR_OPERATOR_BODY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "LocalFunctionsSettingDescription")]
public FunctionBodyStyle LOCAL_FUNCTION_BODY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ConstructorsAndDestructorsSettingDescription")]
public FunctionBodyStyle CONSTRUCTOR_OR_DESTRUCTOR_BODY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "PropertiesIndexersAndEventsSettingDescription")]
public AccessorOwnerBodyStyle ACCESSOR_OWNER_BODY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "NamespacesSettingDescription")]
public NamespaceBodyStyle NAMESPACE_BODY;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ApplyStyleHeuristicsSettingDescription")]
public bool USE_HEURISTICS_FOR_BODY_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "BeforeANewLineInMultilineListsSettingDescription")]
public bool TRAILING_COMMA_IN_MULTILINE_LISTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WhenTheLastElementIsNotFollowedByANewLineSettingDescription")]
public bool TRAILING_COMMA_IN_SINGLELINE_LISTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WhenCreatedTypeIsEvidentFromUsageSettingDescription")]
public ObjectCreationStyle OBJECT_CREATION_WHEN_TYPE_EVIDENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WhenCreatedTypeIsNotEvidentFromUsageSettingDescription")]
public ObjectCreationStyle OBJECT_CREATION_WHEN_TYPE_NOT_EVIDENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WhenTypeIsEvidentFromUsageSettingDescription")]
public DefaultValueStyle DEFAULT_VALUE_WHEN_TYPE_EVIDENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "WhenTypeIsNotEvidentFromUsageSettingDescription")]
public DefaultValueStyle DEFAULT_VALUE_WHEN_TYPE_NOT_EVIDENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "NullCheckingPatternStyle")]
public NullCheckingPatternStyle NULL_CHECKING_PATTERN_STYLE;
}
public static class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKeyConstantsHelper : object {
    public static string BracesForIfElseDescription { get; }
    public static string BracesForForDescription { get; }
    public static string BracesForForeachDescription { get; }
    public static string BracesForWhileDescription { get; }
    public static string BracesForDoWhileDescription { get; }
    public static string BracesForUsingDescription { get; }
    public static string BracesForLockDescription { get; }
    public static string BracesForFixedDescription { get; }
    public static string get_BracesForIfElseDescription();
    public static string get_BracesForForDescription();
    public static string get_BracesForForeachDescription();
    public static string get_BracesForWhileDescription();
    public static string get_BracesForDoWhileDescription();
    public static string get_BracesForUsingDescription();
    public static string get_BracesForLockDescription();
    public static string get_BracesForFixedDescription();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpPredefinedNamingRulesWithDefaultValues : HaveDefaultSettings`1<CSharpNamingSettings> {
    private static AccessRightKinds NonPrivateAccessRights;
    public static Guid TypesAndNamespacesGuid;
    public static Guid InterfacesGuid;
    public static Guid TypeParametersGuid;
    public static Guid MethodGuid;
    public static Guid PropertyGuid;
    public static Guid EventGuid;
    public static Guid LocalsGuid;
    public static Guid LocalConstantsGuid;
    public static Guid ParametersGuid;
    public static Guid PrivateInstanceFieldsGuid;
    public static Guid PrivateStaticFieldsGuid;
    public static Guid ConstantsGuid;
    public static Guid PrivateConstantsGuid;
    public static Guid StaticReadonlyGuid;
    public static Guid PrivateStaticReadonlyGuid;
    public static Guid LocalFunctionsGuid;
    public static Guid PublicInstanceFieldsGuid;
    public static Guid PublicStaticFieldsGuid;
    public static Guid EnumMembersGuid;
    public static IReadOnlyList`1<NamingRuleData> Data;
    public string Name { get; }
    public CSharpPredefinedNamingRulesWithDefaultValues(ILogger logger, ISettingsSchema settingsSchema);
    private static CSharpPredefinedNamingRulesWithDefaultValues();
    [NullableContextAttribute("2")]
[PureAttribute]
public static NamingRuleData GetNamingRuleData(Guid guid);
    [NullableContextAttribute("2")]
[PureAttribute]
public static NamingPolicy GetDefaultNamingPolicy(Guid guid);
    [NullableContextAttribute("2")]
[PureAttribute]
public static string GetNamingRuleExportName(Guid guid);
    public static FrugalLocalList`1<NamingRuleData> GetRulesForNamedElementKinds(NamedElementKinds kind);
    public static OneToListMap`2<NamedElementKinds, ValueTuple`2<Guid, ClrNamedElementDescriptor>> GetPredefinedNamingRulesToDefaultUserRuleDescriptorsMap();
    public static int CompareGuidsDefaultOrder(Guid guid1, Guid guid2);
    public virtual void InitDefaultSettings(ISettingsStorageMountPoint mountPoint);
    public virtual string get_Name();
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.DefaultModifierDefinition : Enum {
    public int value__;
    [DescriptionAttribute("Explicit")]
public static DefaultModifierDefinition Explicit;
    [DescriptionAttribute("Implicit")]
public static DefaultModifierDefinition Implicit;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.DefaultValueStyle : Enum {
    public int value__;
    [DescriptionAttribute("Omit type: 'default'")]
public static DefaultValueStyle DefaultLiteral;
    [DescriptionAttribute("Specify type: 'default(T)'")]
public static DefaultValueStyle DefaultExpression;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.FunctionBodyStyle : Enum {
    public int value__;
    [DescriptionAttribute("Expression body")]
public static FunctionBodyStyle ExpressionBody;
    [DescriptionAttribute("Block body")]
public static FunctionBodyStyle BlockBody;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.IfElseBracesCodeStyle : Enum {
    public int value__;
    [DescriptionAttribute("Do not enforce")]
public static IfElseBracesCodeStyle NotRequired;
    [DescriptionAttribute("Enforce if any part requires braces")]
public static IfElseBracesCodeStyle NotRequiredForBoth;
    [DescriptionAttribute("Enforce always")]
public static IfElseBracesCodeStyle Required;
    [DescriptionAttribute("Enforce if body is multi-line")]
public static IfElseBracesCodeStyle RequiredForMultiline;
    [DescriptionAttribute("Enforce if statement is multi-line")]
public static IfElseBracesCodeStyle RequiredForMultilineStatement;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
[DescriptionAttribute("Enforce if body is complex")]
public static IfElseBracesCodeStyle RequiredForComplex;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.MemberDeclaredIn : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("same class")]
public static MemberDeclaredIn ThisClass;
    [LocalizedDescriptionAttribute("base class")]
public static MemberDeclaredIn BaseClass;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.NamespaceBodyStyle : Enum {
    public int value__;
    [DescriptionAttribute("File-scoped")]
public static NamespaceBodyStyle FileScoped;
    [DescriptionAttribute("Block-scoped")]
public static NamespaceBodyStyle BlockScoped;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.ObjectCreationStyle : Enum {
    public int value__;
    [DescriptionAttribute("Omit type: 'new()'")]
public static ObjectCreationStyle TargetTyped;
    [DescriptionAttribute("Specify type: 'new T()'")]
public static ObjectCreationStyle ExplicitlyTyped;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.ParenthesesRedundancyStyle : Enum {
    public int value__;
    [DescriptionAttribute("Always")]
public static ParenthesesRedundancyStyle Remove;
    [DescriptionAttribute("If not clarifies precedence")]
public static ParenthesesRedundancyStyle RemoveIfNotClarifiesPrecedence;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.QualifiedMember : Enum {
    public int value__;
    [BrowsableAttribute("False")]
public static QualifiedMember None;
    public static QualifiedMember Field;
    public static QualifiedMember Property;
    public static QualifiedMember Event;
    public static QualifiedMember Method;
    [BrowsableAttribute("False")]
public static QualifiedMember All;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.StaticMemberQualifierStyle : Enum {
    public int value__;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
public static StaticMemberQualifierStyle DoNotChange;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
public static StaticMemberQualifierStyle None;
    [DescriptionAttribute("Current type")]
public static StaticMemberQualifierStyle CurrentType;
    [DescriptionAttribute("Declared-in type")]
public static StaticMemberQualifierStyle DeclaredType;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
public static StaticMemberQualifierStyle All;
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKey", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "StaticMemberQualifierSettingDescription")]
[EditorConfigKeyAttribute("csharp")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.StaticQualifierSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "MembersToQualifySettingDescription")]
public QualifiedMember STATIC_MEMBERS_QUALIFY_MEMBERS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "QualifyWithTheNameOfSettingDescription")]
public StaticMemberQualifierStyle STATIC_MEMBERS_QUALIFY_WITH;
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.CSharpCodeStyleSettingsKey", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ThisQualifierSettingsKey_Description")]
[EditorConfigKeyAttribute("csharp")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.ThisQualifierSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "ThisQualifierSettingsKey_InstanceMembersQualifyMembers_SettingsEntryDescription")]
public QualifiedMember INSTANCE_MEMBERS_QUALIFY_MEMBERS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "QualifyMembersDeclaredInSettingDescription")]
public MemberDeclaredIn INSTANCE_MEMBERS_QUALIFY_DECLARED_IN;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Settings.ThisQualifierStyle : Enum {
    public int value__;
    [BrowsableAttribute("False")]
public static ThisQualifierStyle DoNotChange;
    public static ThisQualifierStyle None;
    public static ThisQualifierStyle This;
    public static ThisQualifierStyle Base;
    [BrowsableAttribute("False")]
public static ThisQualifierStyle All;
}
[CodeStyleSettingsAttribute("CSharp")]
[ObsoleteAttribute("Obsolete settings class, see members for new types")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.CSharpCodeStyleSettings : object {
    private CSharpFormatSettingsObsolete myFormatSettings;
    private CSharpUsingsSettingsObsolete myUsingsSettings;
    private string myCustomMembersReorderingPatterns;
    [ObsoleteAttribute("Deprecated, use CSharpFormatSettingsKey")]
public CSharpFormatSettingsObsolete FormatSettings { get; public set; }
    [ObsoleteAttribute("Deprecated, use CSharpUsingSettings")]
public CSharpUsingsSettingsObsolete UsingSettings { get; public set; }
    [ObsoleteAttribute("Deprecated, use CSharpMemberOrderPatternSettings")]
public string CustomMembersReorderingPatternsObsolete { get; public set; }
    private IEnumerable`1<string> JetBrains.Application.Configuration.IXmlUpgradable.LegacyTagNames { get; }
    public CSharpFormatSettingsObsolete get_FormatSettings();
    public void set_FormatSettings(CSharpFormatSettingsObsolete value);
    public CSharpUsingsSettingsObsolete get_UsingSettings();
    public void set_UsingSettings(CSharpUsingsSettingsObsolete value);
    public string get_CustomMembersReorderingPatternsObsolete();
    public void set_CustomMembersReorderingPatternsObsolete(string value);
    public sealed virtual void ReadFromXml(XmlElement element);
    private sealed virtual override IEnumerable`1<string> JetBrains.Application.Configuration.IXmlUpgradable.get_LegacyTagNames();
    private sealed virtual override bool JetBrains.Application.Configuration.IXmlUpgradable.UpgradeFromXml(XmlElement element, Version version);
    public sealed virtual object Clone();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.CSharpFormatSettingsObsolete : UserDataHolder {
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int CONTINUOUS_INDENT_MULTIPLIER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_METHOD_CALL_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_EMPTY_METHOD_CALL_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_METHOD_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_EMPTY_METHOD_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_METHOD_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_EMPTY_METHOD_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_METHOD_CALL_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_EMPTY_METHOD_CALL_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_ARRAY_ACCESS_BRACKETS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_ARRAY_ACCESS_BRACKETS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_IF_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_IF_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_TYPECAST_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_TYPECAST_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_WHILE_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_WHILE_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_CATCH_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_CATCH_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_SWITCH_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_SWITCH_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_FOR_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_FOR_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_FOREACH_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_FOREACH_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_USING_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_USING_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_LOCK_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_LOCK_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_TYPEOF_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_TYPEOF_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_FIXED_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_FIXED_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_SIZEOF_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_SIZEOF_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_TYPE_PARAMETER_ANGLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_TYPE_PARAMETER_ANGLES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_TYPE_ARGUMENT_ANGLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_TYPE_ARGUMENT_ANGLES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_COMMA;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_COMMA;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_FOR_SEMICOLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_FOR_SEMICOLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_TERNARY_QUEST;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_TERNARY_QUEST;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_TERNARY_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_TERNARY_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_ATTRIBUTE_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_ATTRIBUTE_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_EXTENDS_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_EXTENDS_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_TYPE_PARAMETER_CONSTRAINT_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_TYPE_PARAMETER_CONSTRAINT_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_LAMBDA_ARROW;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_ASSIGNMENT_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_LOGICAL_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_EQUALITY_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_RELATIONAL_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_BITWISE_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_ADDITIVE_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_MULTIPLICATIVE_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_SHIFT_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_NULLCOALESCING_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_AMPERSAND_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_ASTERIK_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_ARROW_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_ALIAS_EQ;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_DOT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_SINGLELINE_ACCESSORHOLDER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_IN_SINGLELINE_ACCESSORHOLDER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BETWEEN_ACCESSORS_IN_SINGLELINE_PROPERTY;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_IN_SINGLELINE_METHOD;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_IN_SINGLELINE_ANONYMOUS_METHOD;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_ATTRIBUTE_BRACKETS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_SEMICOLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_COLON_IN_CASE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_NULLABLE_MARK;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_ARRAY_CREATION_BRACE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_ARRAY_RANK_BRACKETS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_ARRAY_RANK_BRACKETS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_ARRAY_RANK_EMPTY_BRACKETS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_POINTER_ASTERIK_DECLARATION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_SINGLE_LINE_ARRAY_INITIALIZER_BRACES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_TRAILING_COMMENT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public BraceFormatStyleEx TYPE_DECLARATION_BRACES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public BraceFormatStyleEx INVOCABLE_DECLARATION_BRACES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public BraceFormatStyleEx ANONYMOUS_METHOD_DECLARATION_BRACES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public BraceFormatStyleEx CASE_BLOCK_BRACES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public BraceFormatStyleEx INITIALIZER_BRACES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public BraceFormatStyleEx OTHER_BRACES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public EmptyBlockStyle EMPTY_BLOCK_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_ELSE_ON_NEW_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_WHILE_ON_NEW_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_CATCH_ON_NEW_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_FINALLY_ON_NEW_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool KEEP_USER_LINEBREAKS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public SimpleEmbeddedStatementStyle SIMPLE_EMBEDDED_STATEMENT_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public ForceBraceStyle FORCE_IFELSE_BRACES_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public ForceBraceStyle FORCE_FOR_BRACES_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public ForceBraceStyle FORCE_FOREACH_BRACES_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public ForceBraceStyle FORCE_WHILE_BRACES_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public ForceBraceStyle FORCE_USING_BRACES_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public ForceBraceStyle FORCE_FIXED_BRACES_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int KEEP_BLANK_LINES_IN_DECLARATIONS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int KEEP_BLANK_LINES_IN_CODE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_BEFORE_USING;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AFTER_USING;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_NAMESPACE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_TYPE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_FIELD;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_SINGLE_LINE_FIELD;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_INVOCABLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_SINGLE_LINE_INVOCABLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_REGION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_INSIDE_REGION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_BETWEEN_USING_GROUPS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AFTER_USING_LIST;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AFTER_START_COMMENT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public String[] MODIFIERS_ORDER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool EXPLICIT_PRIVATE_MODIFIER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool EXPLICIT_INTERNAL_MODIFIER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ARRANGE_MODIFIER_IN_EXISTING_CODE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_PARAMETER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_ARGUMENT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_EXTENDS_LIST;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_EXPRESSION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_ARRAY_AND_OBJECT_INITIALIZER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTLINE_TYPE_PARAMETER_LIST;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTLINE_TYPE_PARAMETER_CONSTRAINS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_FOR_STMT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTIPLE_DECLARATION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_FIRST_ARG_BY_PAREN;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_LINQ_QUERY;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_LINES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int WRAP_LIMIT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_INVOCATION_LPAR;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_AFTER_INVOCATION_LPAR;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_DECLARATION_LPAR;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_AFTER_DECLARATION_LPAR;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_TYPE_PARAMETER_LANGLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_EXTENDS_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_BINARY_OPSIGN;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_AFTER_BINARY_OPSIGN;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_FIRST_TYPE_PARAMETER_CONSTRAINT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool FORCE_CHOP_COMPOUND_IF_EXPRESSION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool FORCE_CHOP_COMPOUND_WHILE_EXPRESSION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool FORCE_CHOP_COMPOUND_DO_EXPRESSION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_PARAMETERS_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_ARGUMENTS_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_EXTENDS_LIST_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_FOR_STMT_HEADER_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_TERNARY_EXPR_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_MULTIPLE_DECLARATION_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_MULTIPLE_TYPE_PARAMEER_CONSTRAINTS_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_OBJECT_AND_COLLECTION_INITIALIZER_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public AttributeStyle FORCE_ATTRIBUTE_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_ABSTRACT_ACCESSORHOLDER_ON_SINGLE_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_SIMPLE_ACCESSORHOLDER_ON_SINGLE_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_SIMPLE_ACCESSOR_ON_SINGLE_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_SIMPLE_METHOD_ON_SINGLE_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_SIMPLE_ANONYMOUSMETHOD_ON_SINGLE_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_SIMPLE_LINQ_ON_SINGLE_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_SIMPLE_INITIALIZER_ON_SINGLE_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_TYPE_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_METHOD_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_ACCESSORHOLDER_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_FIELD_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_TYPE_CONSTRAINTS_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALLOW_COMMENT_AFTER_LBRACE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_CONSTRUCTOR_INITIALIZER_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool INDENT_ANONYMOUS_METHOD_BLOCK;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool INDENT_EMBRACED_INITIALIZER_BLOCK;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPECIAL_ELSE_IF_TREATMENT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool INDENT_CASE_FROM_SWITCH;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool INDENT_NESTED_USINGS_STMT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool INDENT_NESTED_FIXED_STMT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool STICK_COMMENT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool LINE_FEED_AT_FILE_END;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public ThisQualifierStyle2 REDUNDANT_THIS_QUALIFIER_STYLE;
    public static String[] DefaultModifiersOrder;
    private static CSharpFormatSettingsObsolete();
    public sealed virtual void ReadFromXml(XmlElement element);
    public void WriteToXml(XmlElement element);
    public CSharpFormatSettingsObsolete Clone();
}
[SolutionSettingsUpgraderAttribute("0")]
[GlobalSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.CSharpFormatSettingsUpgrade : CodeStyleSettingsUpgrade {
    public CSharpFormatSettingsUpgrade(ShellPartCatalogSet partsSet, ISolution solution);
    protected virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore boundSettingsStore);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.CSharpPlaceAttributeOnSameLineMigration : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.CSharpPlaceAttributeOnSameLineMigration/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetEntriesToMigrate>d__0")]
private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
[SolutionSettingsUpgraderAttribute("0")]
[GlobalSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.CSharpUsingSettingsUpgrade : CodeStyleSettingsUpgrade {
    public CSharpUsingSettingsUpgrade(ShellPartCatalogSet partsSet, ISolution solution);
    protected virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore boundSettingsStore);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.CSharpUsingsSettingsObsolete : object {
    private String[] myKeepImports;
    private String[] myMandatoryImports;
    [CompilerGeneratedAttribute]
private bool <AddImportsToDeepestScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QualifiedUsingAtNestedScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferQualifiedReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanUseGlobalAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortUsings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepNontrivialAlias>k__BackingField;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool AddImportsToDeepestScope { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool QualifiedUsingAtNestedScope { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool AllowAlias { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PreferQualifiedReference { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool CanUseGlobalAlias { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SortUsings { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public String[] KeepImports { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public String[] MandatoryImports { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool KeepNontrivialAlias { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AddImportsToDeepestScope();
    [CompilerGeneratedAttribute]
public void set_AddImportsToDeepestScope(bool value);
    [CompilerGeneratedAttribute]
public bool get_QualifiedUsingAtNestedScope();
    [CompilerGeneratedAttribute]
public void set_QualifiedUsingAtNestedScope(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAlias();
    [CompilerGeneratedAttribute]
public void set_AllowAlias(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreferQualifiedReference();
    [CompilerGeneratedAttribute]
public void set_PreferQualifiedReference(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanUseGlobalAlias();
    [CompilerGeneratedAttribute]
public void set_CanUseGlobalAlias(bool value);
    [CompilerGeneratedAttribute]
public bool get_SortUsings();
    [CompilerGeneratedAttribute]
public void set_SortUsings(bool value);
    public String[] get_KeepImports();
    public void set_KeepImports(String[] value);
    public String[] get_MandatoryImports();
    public void set_MandatoryImports(String[] value);
    [CompilerGeneratedAttribute]
public bool get_KeepNontrivialAlias();
    [CompilerGeneratedAttribute]
public void set_KeepNontrivialAlias(bool value);
    public sealed virtual void ReadFromXml(XmlElement element);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.MigrateBlankLinesAroundFieldToBlankLinesAroundProperty : object {
    private static void MigrateOne(IContextBoundSettingsStoreImplementation store, Expression`1<Func`2<CSharpFormatSettingsKey, int>> exprOld, Expression`1[] news);
    private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.MigrateBlankLinesAroundFieldToBlankLinesAroundProperty/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetKeysToMigrate>d__2")]
private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.MigrateThisQualifierSettings : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.MigrateThisQualifierSettings/<GetEntriesToMigrate>d__0")]
public sealed virtual IEnumerable`1<SettingsEntry> GetEntriesToMigrate(ISettingsSchema schema);
    public sealed virtual IEnumerable`1<SettingsKey> GetKeysToMigrate(ISettingsSchema schema);
    public sealed virtual void Migrate(IContextBoundSettingsStoreImplementation store);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.PredefinedNamingRulesToUserRulesUpgrade : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.PredefinedNamingRulesToUserRulesUpgrade/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetEntriesToMigrate>d__0")]
private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.CodeStyle.SettingsUpgrade.PredefinedNamingRulesToUserRulesUpgrade/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetKeysToMigrate>d__1")]
private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.AccessorOwnerBodyCodeStyleSuggestion : CodeStyleSuggestion`1<IAccessorOwnerDeclaration> {
    [NotNullAttribute]
private IArrangeAccessorBodyCodeStyleSuggestion[] myAccessorSuggestions;
    [CompilerGeneratedAttribute]
private AccessorOwnerBodyFix <SuggestedFix>k__BackingField;
    public AccessorOwnerBodyFix SuggestedFix { get; }
    public string Message { get; }
    public IReadOnlyCollection`1<IArrangeAccessorBodyCodeStyleSuggestion> AccessorSuggestions { get; }
    private AccessorOwnerBodyCodeStyleSuggestion(IAccessorOwnerDeclaration declaration, AccessorOwnerBodyFix accessorOwnerBodyFix, IArrangeAccessorBodyCodeStyleSuggestion[] accessorSuggestions);
    public AccessorOwnerBodyCodeStyleSuggestion(IAccessorOwnerDeclaration declaration, AccessorOwnerBodyFix accessorOwnerBodyFix, bool useHeuristics);
    [CompilerGeneratedAttribute]
public sealed virtual AccessorOwnerBodyFix get_SuggestedFix();
    public sealed virtual string get_Message();
    public sealed virtual IReadOnlyCollection`1<IArrangeAccessorBodyCodeStyleSuggestion> get_AccessorSuggestions();
    protected virtual bool CanBeApplied();
    [NotNullAttribute]
protected virtual ITreeNode ApplySuggestion(IAccessorOwnerDeclaration declaration);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
    public sealed virtual ITreeNode[] GetNodesToHighlight();
    [NotNullAttribute]
private ITreeNode[] GetEnforceBlockBodiedAccessorsHighlighting();
    [NotNullAttribute]
private ITreeNode[] GetEnforceExpressionBodiedPropertyHighlighting();
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.AccessorOwnerBodyFix : Enum {
    public int value__;
    public static AccessorOwnerBodyFix EnforceExpressionBodiedAccessors;
    public static AccessorOwnerBodyFix EnforceBlockBodiedAccessors;
    public static AccessorOwnerBodyFix EnforceExpressionBodiedProperty;
    public static AccessorOwnerBodyFix EnforceExpressionBodiedGetter;
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.AddParenthesesCodeStyleSuggestion : CodeStyleSuggestion`1<IBinaryExpression> {
    public AddParenthesesCodeStyleSuggestion(IBinaryExpression binaryExpression);
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IBinaryExpression binaryExpression);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.AttributeCodeStyleSuggestion : CodeStyleSuggestion`1<IAttributeSectionList> {
    private AttributeStyle myAttributeStyle;
    public AttributeStyle SuggestedStyle { get; }
    public AttributeCodeStyleSuggestion(AttributeStyle attributeStyle, IAttributeSectionList attributeSectionList);
    public sealed virtual AttributeStyle get_SuggestedStyle();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IAttributeSectionList target);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.BracesCodeStyleSuggestion : CodeStyleSuggestion`1<ICSharpStatement> {
    [NotNullAttribute]
private ICSharpStatement myStatementBody;
    private BracesCodeStyleSuggestionType myType;
    public BracesCodeStyleSuggestionType Type { get; }
    public ICSharpStatement Statement { get; }
    [NotNullAttribute]
public ICSharpStatement StatementBody { get; }
    private BracesCodeStyleSuggestion(ICSharpStatement statement, ICSharpStatement statementBody, BracesCodeStyleSuggestionType type);
    public sealed virtual BracesCodeStyleSuggestionType get_Type();
    public sealed virtual ICSharpStatement get_Statement();
    public sealed virtual ICSharpStatement get_StatementBody();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ICSharpStatement statement);
    [NotNullAttribute]
public static IBracesCodeStyleSuggestion AddBraces(ICSharpStatement statement, ICSharpStatement expressionStatement);
    [NotNullAttribute]
public static IBracesCodeStyleSuggestion RemoveBraces(ICSharpStatement statement, IBlock statementBody);
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.BracesCodeStyleSuggestionType : Enum {
    public int value__;
    public static BracesCodeStyleSuggestionType Add;
    public static BracesCodeStyleSuggestionType Remove;
    public static BracesCodeStyleSuggestionType Mixed;
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.BracesForIfElseStatementCodeStyleSuggestion : CodeStyleSuggestion`1<IIfStatement> {
    [CanBeNullAttribute]
private BracesForIfElseStatementCodeStyleSuggestion myTopSuggestion;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SuggestionForThen>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SuggestionForElse>k__BackingField;
    [CompilerGeneratedAttribute]
private BracesForIfElseStatementCodeStyleSuggestion <NextSuggestion>k__BackingField;
    public BracesCodeStyleSuggestionType Type { get; }
    private ICSharpStatement JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IBracesCodeStyleSuggestion.Statement { get; }
    public IIfStatement Statement { get; }
    public ICSharpStatement StatementBody { get; }
    public Nullable`1<bool> SuggestionForThen { get; }
    public Nullable`1<bool> SuggestionForElse { get; }
    public BracesForIfElseStatementCodeStyleSuggestion NextSuggestion { get; private set; }
    public BracesForIfElseStatementCodeStyleSuggestion TopSuggestion { get; }
    public BracesForIfElseStatementCodeStyleSuggestion(IIfStatement statement, Nullable`1<bool> suggestionForThen, Nullable`1<bool> suggestionForElse);
    public sealed virtual BracesCodeStyleSuggestionType get_Type();
    private sealed virtual override ICSharpStatement JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IBracesCodeStyleSuggestion.get_Statement();
    public sealed virtual IIfStatement get_Statement();
    public sealed virtual ICSharpStatement get_StatementBody();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_SuggestionForThen();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_SuggestionForElse();
    [CompilerGeneratedAttribute]
public sealed virtual BracesForIfElseStatementCodeStyleSuggestion get_NextSuggestion();
    [CompilerGeneratedAttribute]
private void set_NextSuggestion(BracesForIfElseStatementCodeStyleSuggestion value);
    public sealed virtual BracesForIfElseStatementCodeStyleSuggestion get_TopSuggestion();
    protected virtual bool CanBeApplied();
    [NotNullAttribute]
protected virtual ITreeNode ApplySuggestion(IIfStatement ifStatement);
    private static void ApplyBranchSuggestion(Nullable`1<bool> suggestion, ICSharpStatement ifBranch);
    public void AddNext(BracesForIfElseStatementCodeStyleSuggestion suggestion);
    public void AddTop(BracesForIfElseStatementCodeStyleSuggestion suggestion);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.DeclarationExpressionVarStyleSuggestion : SingleVariableDeclarationVarStyleSuggestionBase {
    private DeclarationExpressionVarStyleSuggestion(IDeclarationExpression node, VarStyleInfo varStyleInfo);
    protected virtual ITreeNode ApplySuggestion(ITreeNode targetNode);
    [NotNullAttribute]
public static VarStyleSuggestion Create(IDeclarationExpression node, IList`1<VarStyleInfo> varStyleSuggestions);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.DeconstructedVariableVarKeywordUsageSuggestion : CodeStyleSuggestion`1<ICSharpTreeNode> {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITokenNode> <VarKeywords>k__BackingField;
    [NotNullAttribute]
public string Message { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<ITokenNode> VarKeywords { get; }
    public DeconstructedVariableVarKeywordUsageSuggestion(IDeclarationExpression declarationExpression);
    public DeconstructedVariableVarKeywordUsageSuggestion(IVarDeconstructionPattern varDeconstructionPattern);
    public DeconstructedVariableVarKeywordUsageSuggestion(ITupleExpression tupleExpression, IReadOnlyList`1<ITokenNode> varKeywords);
    public DeconstructedVariableVarKeywordUsageSuggestion(IRecursivePattern recursivePattern, IReadOnlyList`1<ITokenNode> varKeywords);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ITokenNode> get_VarKeywords();
    protected virtual bool CanBeApplied();
    [NotNullAttribute]
protected virtual ITreeNode ApplySuggestion(ICSharpTreeNode targetNode);
    private static void RewriteToDeclarationExpression(ICSharpExpression expression, FactoryArgumentsBuilder& argumentsBuilder);
    private static void RewriteWithoutTypeDesignations(IVariableDesignation designation, FactoryArgumentsBuilder& argumentsBuilder);
    private static void RewriteToVarPattern(IPattern pattern, FactoryArgumentsBuilder& argumentsBuilder);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.DeconstructingDeclarationVarStyleSuggestion : VarStyleSuggestion {
    [NotNullAttribute]
private IList`1<VarStyleInfo> myVarStyleSuggestions;
    [CompilerGeneratedAttribute]
private VariableStyle <SuggestedStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private VariableTypeKind <Kind>k__BackingField;
    public VariableStyle SuggestedStyle { get; }
    public VariableTypeKind Kind { get; }
    public bool InferredTypeIsChanged { get; }
    public string SuggestedStyleTitle { get; }
    public DeconstructingDeclarationVarStyleSuggestion(IDeclarationExpression node, IList`1<VarStyleInfo> varStyleSuggestions);
    [CompilerGeneratedAttribute]
public virtual VariableStyle get_SuggestedStyle();
    [CompilerGeneratedAttribute]
public virtual VariableTypeKind get_Kind();
    public virtual bool get_InferredTypeIsChanged();
    public virtual string get_SuggestedStyleTitle();
    protected virtual ITreeNode ApplySuggestion(ITreeNode targetNode);
    private static void RewriteVariableDesignation(IVariableDesignation variableDesignation, IDictionary`2<ISingleVariableDesignation, VarStyleInfo> designationToSuggestionMap, FactoryArgumentsBuilder& argumentsBuilder);
    private static void RewriteSingleVariableDesignation(ISingleVariableDesignation singleVariableDesignation, IDictionary`2<ISingleVariableDesignation, VarStyleInfo> designationToSuggestionMap, FactoryArgumentsBuilder& argumentsBuilder);
    private static void RewriteParenthesizedDesignation(IParenthesizedVariableDesignation parenthesizedVariableDesignation, IDictionary`2<ISingleVariableDesignation, VarStyleInfo> designationToSuggestionMap, FactoryArgumentsBuilder& argumentsBuilder);
    [PureAttribute]
private static bool ShouldRewriteParenthesizedDesignationToDeclarationExpression(IParenthesizedVariableDesignation designation, IDictionary`2<ISingleVariableDesignation, VarStyleInfo> designationToSuggestionMap);
    [CompilerGeneratedAttribute]
internal static bool <ShouldRewriteParenthesizedDesignationToDeclarationExpression>g__CanUseImplicitTypesForAllDesignations|16_0(IParenthesizedVariableDesignation parenthesizedVariableDesignation, <>c__DisplayClass16_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.DefaultAccessModifiersCodeStyleSuggestion : CodeStyleSuggestion`1<IModifiersListOwner> {
    [CompilerGeneratedAttribute]
private TokenNodeType <ModifierTokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenNode <ModifierToRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsElementTypeMember>k__BackingField;
    public TokenNodeType ModifierTokenType { get; }
    public ITokenNode ModifierToRemove { get; }
    public bool IsMissing { get; }
    public bool IsElementTypeMember { get; }
    private DefaultAccessModifiersCodeStyleSuggestion(IModifiersListOwner modifiersListOwner, ITokenNode accessModifier, TokenNodeType modifierTokenType, bool isMissingOrRedundant, bool isElementTypeMember);
    [CompilerGeneratedAttribute]
public sealed virtual TokenNodeType get_ModifierTokenType();
    [CompilerGeneratedAttribute]
public sealed virtual ITokenNode get_ModifierToRemove();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMissing();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsElementTypeMember();
    protected virtual bool CanBeApplied();
    [NotNullAttribute]
protected virtual ITreeNode ApplySuggestion(IModifiersListOwner modifiersListOwner);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
    [NotNullAttribute]
public static DefaultAccessModifiersCodeStyleSuggestion Missing(IModifiersListOwner targetNode, TokenNodeType modifierTokenType, bool isElementTypeMember);
    [NotNullAttribute]
public static DefaultAccessModifiersCodeStyleSuggestion Redundant(IModifiersListOwner targetNode, ITokenNode redundantModifier, TokenNodeType modifierTokenType, bool isElementTypeMember);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.DefaultValueStyleSuggestion : CodeStyleSuggestion`1<ICSharpExpression> {
    [CompilerGeneratedAttribute]
private DefaultValueStyle <SuggestedStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEvidentContext>k__BackingField;
    public ICSharpExpression Expression { get; }
    public DefaultValueStyle SuggestedStyle { get; }
    public bool IsEvidentContext { get; }
    public DefaultValueStyleSuggestion(ICSharpExpression targetNode, DefaultValueStyle suggestedStyle, bool isEvidentContext);
    public sealed virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual DefaultValueStyle get_SuggestedStyle();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEvidentContext();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ICSharpExpression targetNode);
    [CompilerGeneratedAttribute]
private bool <CanBeApplied>g__CheckNotVar|9_0();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.DiscardDeclarationVarKeywordSuggestion : CodeStyleSuggestion`1<ICSharpTreeNode> {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenNode <VarKeyword>k__BackingField;
    [NotNullAttribute]
public string Message { get; }
    [CanBeNullAttribute]
public ITokenNode VarKeyword { get; }
    private DiscardDeclarationVarKeywordSuggestion(ICSharpTreeNode targetNode, ITokenNode varKeyword, string message);
    public DiscardDeclarationVarKeywordSuggestion(IReferenceExpression referenceExpression);
    public DiscardDeclarationVarKeywordSuggestion(IDiscardPattern discardPattern);
    public DiscardDeclarationVarKeywordSuggestion(IDeclarationExpression declarationExpression);
    public DiscardDeclarationVarKeywordSuggestion(IVarPattern varPattern);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public ITokenNode get_VarKeyword();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ICSharpTreeNode targetNode);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.FunctionBodyCodeStyleSuggestion : CodeStyleSuggestion`1<IExpressionBodyOwnerDeclaration> {
    private FunctionBodyFix myFunctionBodyFix;
    public FunctionBodyFix SuggestedFix { get; }
    public string Message { get; }
    public FunctionBodyCodeStyleSuggestion(FunctionBodyFix functionBodyFix, IExpressionBodyOwnerDeclaration declaration);
    public sealed virtual FunctionBodyFix get_SuggestedFix();
    public sealed virtual string get_Message();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IExpressionBodyOwnerDeclaration functionDeclaration);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
    public sealed virtual ITreeNode[] GetNodesToHighlight();
    [NotNullAttribute]
[PureAttribute]
private static ITreeNode[] GetNodesToHighlightFromBlockBody(IBlock blockBody);
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.FunctionBodyFix : Enum {
    public int value__;
    public static FunctionBodyFix EnfroceExpressionBody;
    public static FunctionBodyFix EnforceBlockBody;
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IArrangeAccessorBodyCodeStyleSuggestion {
    public AccessorOwnerBodyFix SuggestedFix { get; }
    [NotNullAttribute]
public string Message { get; }
    [NotNullAttribute]
public IAccessorDeclaration AccessorDeclaration { get; }
    public abstract virtual AccessorOwnerBodyFix get_SuggestedFix();
    public abstract virtual string get_Message();
    public abstract virtual IAccessorDeclaration get_AccessorDeclaration();
    [NotNullAttribute]
public abstract virtual ITreeNode[] GetNodesToHighlight();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IArrangeAccessorOwnerBodyCodeStyleSuggestion {
    public AccessorOwnerBodyFix SuggestedFix { get; }
    [NotNullAttribute]
public string Message { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<IArrangeAccessorBodyCodeStyleSuggestion> AccessorSuggestions { get; }
    public abstract virtual AccessorOwnerBodyFix get_SuggestedFix();
    public abstract virtual string get_Message();
    public abstract virtual IReadOnlyCollection`1<IArrangeAccessorBodyCodeStyleSuggestion> get_AccessorSuggestions();
    [NotNullAttribute]
public abstract virtual ITreeNode[] GetNodesToHighlight();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IArrangeAttributesCodeStyleSuggestion {
    public AttributeStyle SuggestedStyle { get; }
    public abstract virtual AttributeStyle get_SuggestedStyle();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IArrangeFunctionBodyCodeStyleSuggestion {
    public FunctionBodyFix SuggestedFix { get; }
    [NotNullAttribute]
public string Message { get; }
    public abstract virtual FunctionBodyFix get_SuggestedFix();
    public abstract virtual string get_Message();
    [NotNullAttribute]
public abstract virtual ITreeNode[] GetNodesToHighlight();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IBracesCodeStyleSuggestion {
    public BracesCodeStyleSuggestionType Type { get; }
    [NotNullAttribute]
public ICSharpStatement Statement { get; }
    [CanBeNullAttribute]
public ICSharpStatement StatementBody { get; }
    public abstract virtual BracesCodeStyleSuggestionType get_Type();
    public abstract virtual ICSharpStatement get_Statement();
    public abstract virtual ICSharpStatement get_StatementBody();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IBracesForIfElseStatementCodeStyleSuggestion {
    [NotNullAttribute]
public IIfStatement Statement { get; }
    public Nullable`1<bool> SuggestionForThen { get; }
    public Nullable`1<bool> SuggestionForElse { get; }
    [CanBeNullAttribute]
public BracesForIfElseStatementCodeStyleSuggestion NextSuggestion { get; }
    [NotNullAttribute]
public BracesForIfElseStatementCodeStyleSuggestion TopSuggestion { get; }
    public abstract virtual IIfStatement get_Statement();
    public abstract virtual Nullable`1<bool> get_SuggestionForThen();
    public abstract virtual Nullable`1<bool> get_SuggestionForElse();
    public abstract virtual BracesForIfElseStatementCodeStyleSuggestion get_NextSuggestion();
    public abstract virtual BracesForIfElseStatementCodeStyleSuggestion get_TopSuggestion();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IBuiltInTypeReferenceStyleSuggestion {
    public ITreeNode HighlightingAnchor { get; }
    public BuiltInTypeStyle SuggestedStyle { get; }
    public bool IsForMemberAccessExpression { get; }
    public abstract virtual ITreeNode get_HighlightingAnchor();
    public abstract virtual BuiltInTypeStyle get_SuggestedStyle();
    public abstract virtual bool get_IsForMemberAccessExpression();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IDefaultAccessModifiersCodeStyleSuggestion {
    [NotNullAttribute]
public TokenNodeType ModifierTokenType { get; }
    [CanBeNullAttribute]
public ITokenNode ModifierToRemove { get; }
    public bool IsElementTypeMember { get; }
    public bool IsMissing { get; }
    public abstract virtual TokenNodeType get_ModifierTokenType();
    public abstract virtual ITokenNode get_ModifierToRemove();
    public abstract virtual bool get_IsElementTypeMember();
    public abstract virtual bool get_IsMissing();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IDefaultValueStyleSuggestion {
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public DefaultValueStyle SuggestedStyle { get; }
    public bool IsEvidentContext { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual DefaultValueStyle get_SuggestedStyle();
    public abstract virtual bool get_IsEvidentContext();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IMissingParenthesesCodeStyleSuggestion {
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IModifiersOrderCodeStyleSuggestion {
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.INamespaceBodyStyleSuggestion {
    [NotNullAttribute]
public ICSharpNamespaceDeclaration NamespaceDeclaration { get; }
    public NamespaceBodyStyle SuggestedStyle { get; }
    public abstract virtual ICSharpNamespaceDeclaration get_NamespaceDeclaration();
    public abstract virtual NamespaceBodyStyle get_SuggestedStyle();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IObjectCreationStyleSuggestion {
    [NotNullAttribute]
public IObjectCreationExpression ObjectCreationExpression { get; }
    public ObjectCreationStyle SuggestedStyle { get; }
    public bool IsEvidentContext { get; }
    public abstract virtual IObjectCreationExpression get_ObjectCreationExpression();
    public abstract virtual ObjectCreationStyle get_SuggestedStyle();
    public abstract virtual bool get_IsEvidentContext();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.IRedundantParenthesesCodeStyleSuggestion {
    public bool NeedsToRemove { get; }
    public abstract virtual bool get_NeedsToRemove();
}
public interface JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.ITrailingCommaSuggestion {
    public bool TrailingCommaSuggested { get; }
    public bool Multiline { get; }
    public ITreeNode LastElement { get; }
    public ITreeNode LastComma { get; }
    [NotNullAttribute]
public string Message { get; }
    public abstract virtual bool get_TrailingCommaSuggested();
    public abstract virtual bool get_Multiline();
    public abstract virtual ITreeNode get_LastElement();
    public abstract virtual ITreeNode get_LastComma();
    public abstract virtual string get_Message();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.LocalVariableDeclarationVarStyleSuggestion : SingleVariableDeclarationVarStyleSuggestionBase {
    public LocalVariableDeclarationVarStyleSuggestion(IMultipleLocalVariableDeclaration node, VarStyleInfo varStyleInfo);
    protected virtual ITreeNode ApplySuggestion(ITreeNode targetNode);
    protected virtual bool CanBeApplied();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.ModifiersOrderCodeStyleSuggestion : CodeStyleSuggestion`1<ICSharpModifiersOwnerDeclaration> {
    [NotNullAttribute]
private string myModifiersOrderString;
    private ModifiersOrderCodeStyleSuggestion(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration, string modifiersOrderString);
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
    [NotNullAttribute]
public static ModifiersOrderCodeStyleSuggestion Sort(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration, string modifiersOrderString);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.NamespaceBodyStyleSuggestion : CodeStyleSuggestion`1<ICSharpNamespaceDeclaration> {
    [CompilerGeneratedAttribute]
private NamespaceBodyStyle <SuggestedStyle>k__BackingField;
    public ICSharpNamespaceDeclaration NamespaceDeclaration { get; }
    public NamespaceBodyStyle SuggestedStyle { get; }
    public NamespaceBodyStyleSuggestion(ICSharpNamespaceDeclaration targetNode, NamespaceBodyStyle suggestedStyle);
    public sealed virtual ICSharpNamespaceDeclaration get_NamespaceDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual NamespaceBodyStyle get_SuggestedStyle();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ICSharpNamespaceDeclaration namespaceDeclaration);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.NullCheckingPatternStyleSuggestion : CodeStyleSuggestion`1<IPattern> {
    private NullCheckingPatternStyle mySuggestedStyle;
    [CompilerGeneratedAttribute]
private IPattern <Pattern>k__BackingField;
    public string Message { get; }
    public IPattern Pattern { get; }
    public NullCheckingPatternStyleSuggestion(IPattern pattern, NullCheckingPatternStyle suggestedStyle);
    public string get_Message();
    [CompilerGeneratedAttribute]
public IPattern get_Pattern();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IPattern targetNode);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.ObjectCreationStyleSuggestion : CodeStyleSuggestion`1<IObjectCreationExpression> {
    [CompilerGeneratedAttribute]
private ObjectCreationStyle <SuggestedStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEvidentContext>k__BackingField;
    [NotNullAttribute]
private static Expression`1<Func`2<CSharpFormatSettingsKey, int>> ourWrapLimitAccessor;
    public IObjectCreationExpression ObjectCreationExpression { get; }
    public ObjectCreationStyle SuggestedStyle { get; }
    public bool IsEvidentContext { get; }
    public ObjectCreationStyleSuggestion(IObjectCreationExpression targetNode, ObjectCreationStyle suggestedStyle, bool isEvidentContext);
    private static ObjectCreationStyleSuggestion();
    public sealed virtual IObjectCreationExpression get_ObjectCreationExpression();
    [CompilerGeneratedAttribute]
public sealed virtual ObjectCreationStyle get_SuggestedStyle();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEvidentContext();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IObjectCreationExpression targetNode);
    private static void Format(IObjectCreationExpression objectCreationExpression);
    private static NullableAnnotation GetNullableAnnotation(ITreeNode nullableContextNode);
    [CompilerGeneratedAttribute]
private bool <CanBeApplied>g__CheckNotVar|9_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.PredefinedTypeToUserTypeCodeStyleSuggestion : CodeStyleSuggestion`1<ITreeNode> {
    private IReference myPredefinedTypeReference;
    [CompilerGeneratedAttribute]
private bool <IsForMemberAccessExpression>k__BackingField;
    public ITreeNode HighlightingAnchor { get; }
    public BuiltInTypeStyle SuggestedStyle { get; }
    public bool IsForMemberAccessExpression { get; }
    public PredefinedTypeToUserTypeCodeStyleSuggestion(ITreeNode typeReference, IReference predefinedTypeReference, bool isMemberAccessExpression);
    public sealed virtual ITreeNode get_HighlightingAnchor();
    public sealed virtual BuiltInTypeStyle get_SuggestedStyle();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsForMemberAccessExpression();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ITreeNode node);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.RedundantParenthesesCodeStyleSuggestion : CodeStyleSuggestion`1<IParenthesizedExpression> {
    private bool myNeedsToRemove;
    public bool NeedsToRemove { get; }
    private RedundantParenthesesCodeStyleSuggestion(bool needsToRemove, IParenthesizedExpression parenthesizedExpression);
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IParenthesizedExpression targetNode);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
    public sealed virtual bool get_NeedsToRemove();
    public static RedundantParenthesesCodeStyleSuggestion Remove(IParenthesizedExpression parenthesizedExpression);
    public static RedundantParenthesesCodeStyleSuggestion KeepAsIs(IParenthesizedExpression parenthesizedExpression);
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.RedundantParenthesesInSwitchWithTupleCodeStyleSuggestion : CodeStyleSuggestion`1<ISwitchStatement> {
    [NotNullAttribute]
private ISwitchStatement mySwitchStatement;
    public bool NeedsToRemove { get; }
    public RedundantParenthesesInSwitchWithTupleCodeStyleSuggestion(ISwitchStatement switchStatement);
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ISwitchStatement switchStatement);
    public sealed virtual bool get_NeedsToRemove();
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.SingleVariableDeclarationVarStyleSuggestionBase : VarStyleSuggestion {
    [CompilerGeneratedAttribute]
private VarStyleInfo <VarStyleInfo>k__BackingField;
    protected VarStyleInfo VarStyleInfo { get; }
    public VariableStyle SuggestedStyle { get; }
    public VariableTypeKind Kind { get; }
    public bool InferredTypeIsChanged { get; }
    public string SuggestedStyleTitle { get; }
    protected SingleVariableDeclarationVarStyleSuggestionBase(ITreeNode node, VarStyleInfo varStyleInfo);
    [CompilerGeneratedAttribute]
protected VarStyleInfo get_VarStyleInfo();
    public virtual VariableStyle get_SuggestedStyle();
    public virtual VariableTypeKind get_Kind();
    public virtual bool get_InferredTypeIsChanged();
    public virtual string get_SuggestedStyleTitle();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.StaticQualifierCodeStyleSuggestion : CodeStyleSuggestion`1<IReferenceExpression> {
    [CompilerGeneratedAttribute]
private StaticMemberQualifierStyle <SuggestedStyle>k__BackingField;
    public StaticMemberQualifierStyle SuggestedStyle { get; }
    public StaticQualifierCodeStyleSuggestion(IReferenceExpression expr, StaticMemberQualifierStyle suggestedStyle);
    [CompilerGeneratedAttribute]
public StaticMemberQualifierStyle get_SuggestedStyle();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IReferenceExpression referenceExpression);
    public ICodeStyleSuggestionPointer CreatePointer();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.ThisQualifierCodeStyleSuggestion : CodeStyleSuggestion`1<IReferenceExpression> {
    private ThisQualifierStyle mySuggestedStyle;
    [CompilerGeneratedAttribute]
private ThisQualifierStyle <CurrentStyle>k__BackingField;
    public ThisQualifierStyle CurrentStyle { get; }
    public ThisQualifierStyle SuggestedStyle { get; }
    public ThisQualifierCodeStyleSuggestion(IReferenceExpression referenceExpression, ThisQualifierStyle currentStyle, ThisQualifierStyle suggestedStyle);
    [CompilerGeneratedAttribute]
public ThisQualifierStyle get_CurrentStyle();
    public ThisQualifierStyle get_SuggestedStyle();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(IReferenceExpression referenceExpression);
    public ICodeStyleSuggestionPointer CreatePointer();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.TrailingCommaSuggestion : CodeStyleSuggestion`1<ITreeNode> {
    [CompilerGeneratedAttribute]
private bool <TrailingCommaSuggested>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Multiline>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <LastElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <LastComma>k__BackingField;
    public bool TrailingCommaSuggested { get; }
    public bool Multiline { get; }
    public ITreeNode LastElement { get; }
    public ITreeNode LastComma { get; }
    public string Message { get; }
    public TrailingCommaSuggestion(bool trailingCommaSuggested, bool multiline, ITreeNode targetNode, ITreeNode lastElement, ITreeNode lastComma);
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ITreeNode targetNode);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TrailingCommaSuggested();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Multiline();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_LastElement();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_LastComma();
    public sealed virtual string get_Message();
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.UserTypeToPredefinedTypeCodeStyleSuggestion : CodeStyleSuggestion`1<ITreeNode> {
    [NotNullAttribute]
private IQualifiableReference myQualifiableReference;
    [CompilerGeneratedAttribute]
private bool <IsForMemberAccessExpression>k__BackingField;
    [NotNullAttribute]
public ITreeNode HighlightingAnchor { get; }
    public BuiltInTypeStyle SuggestedStyle { get; }
    public bool IsForMemberAccessExpression { get; }
    public UserTypeToPredefinedTypeCodeStyleSuggestion(ITreeNode reference, IQualifiableReference qualifiableReference, bool isMemberAccessExpression);
    public sealed virtual ITreeNode get_HighlightingAnchor();
    public sealed virtual BuiltInTypeStyle get_SuggestedStyle();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsForMemberAccessExpression();
    protected virtual bool CanBeApplied();
    protected virtual ITreeNode ApplySuggestion(ITreeNode targetNode);
    public sealed virtual ICodeStyleSuggestionPointer CreatePointer();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.VarStyleInfo : ValueType {
    public VariableTypeKind VariableTypeKind;
    public VariableStyle SuggestedStyle;
    [NotNullAttribute]
public IType DeclaredType;
    [CanBeNullAttribute]
private IType myInferredType;
    private VariableStyle myCurrentStyle;
    public bool InferredTypeIsChanged { get; }
    public VarStyleInfo(VariableTypeKind variableTypeKind, VariableStyle currentStyle, VariableStyle suggestedStyle, IType declaredType, IType inferredType);
    public bool get_InferredTypeIsChanged();
    public bool IsImplicitTypeSuggestion();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CSharp.CodeStyle.Suggestions.VarStyleSuggestion : CodeStyleSuggestion`1<ITreeNode> {
    public VariableStyle SuggestedStyle { get; }
    public VariableTypeKind Kind { get; }
    public bool InferredTypeIsChanged { get; }
    public string SuggestedStyleTitle { get; }
    public ITreeNode RelatedNode { get; }
    protected VarStyleSuggestion(ITreeNode targetNode);
    public abstract virtual VariableStyle get_SuggestedStyle();
    public abstract virtual VariableTypeKind get_Kind();
    public abstract virtual bool get_InferredTypeIsChanged();
    public abstract virtual string get_SuggestedStyleTitle();
    public ITreeNode get_RelatedNode();
    protected virtual bool CanBeApplied();
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.VariableStyle : Enum {
    public int value__;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
public static VariableStyle CanUseEither;
    [ExcludeFromEditorConfigAttribute]
[BrowsableAttribute("False")]
public static VariableStyle DoNotChange;
    [LocalizedDescriptionAttribute("Use 'var'")]
public static VariableStyle UseVar;
    [LocalizedDescriptionAttribute("Use 'var' when evident")]
public static VariableStyle UseVarWhenEvident;
    [LocalizedDescriptionAttribute("Use explicit type")]
public static VariableStyle UseExplicitType;
}
public enum JetBrains.ReSharper.Psi.CSharp.CodeStyle.VariableTypeKind : Enum {
    public int value__;
    public static VariableTypeKind Unknown;
    public static VariableTypeKind BuiltIn;
    public static VariableTypeKind Simple;
    public static VariableTypeKind MultipleDeclarations;
    public static VariableTypeKind Other;
}
[SettingsKeyAttribute("JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.GeneralVirtualIndentingSettings", "Code virtual formatting in C#")]
public class JetBrains.ReSharper.Psi.CSharp.CodeStyle.VirtualFormatSettings.CSharpVirtualFormatSettingsKey : CSharpFormatSettingsKey {
}
public abstract class JetBrains.ReSharper.Psi.CSharp.ConstantValues.CSharpConstantCalculator : object {
    [NotNullAttribute]
public static CSharpConstantCalculator Instance { get; }
    public static CSharpConstantCalculator get_Instance();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ConstantValue CalculateUnaryOperator(ISignOperator unaryOperator, ConstantValue value, bool isChecked);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ConstantValue CalculateBinaryOperator(ISignOperator binaryOperator, ConstantValue leftValue, ConstantValue rightValue, bool isChecked);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ConstantValue ToTypeImplicit(ConstantValue value, IType type, ICSharpTypeConversionRule conversionRule);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ConstantValue ToTypeExplicit(ConstantValue value, IType type, ICSharpTypeConversionRule conversionRule, bool isChecked);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ConstantValue CalculateBinaryEnumOperator(string operatorName, IEnum enum, ConstantValue leftValue, ConstantValue rightValue, bool isChecked);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.ConstantValues.CSharpConstantCalculatorImpl : CSharpConstantCalculator {
    [NotNullAttribute]
private CSharpLanguage myLanguage;
    [NotNullAttribute]
private static Dictionary`2<Pair`2<string, string>, UnaryOperationCalculator> ourCheckedConversionCalculators;
    [NotNullAttribute]
private static Dictionary`2<Pair`2<string, string>, UnaryOperationCalculator> ourUncheckedConversionCalculators;
    [NotNullAttribute]
private static Dictionary`2<Key, BinaryOperationCalculator> ourBinaryCheckedCalculators;
    [NotNullAttribute]
private static Dictionary`2<Key, BinaryOperationCalculator> ourBinaryUncheckedCalculators;
    [NotNullAttribute]
private static Dictionary`2<Key, UnaryOperationCalculator> ourUnaryCheckedCalculators;
    [NotNullAttribute]
private static Dictionary`2<Key, UnaryOperationCalculator> ourUnaryUncheckedCalculators;
    [NotNullAttribute]
private static Dictionary`2<Key, BinaryOperationCalculator> ourEnumBinaryCheckedCalculators;
    [NotNullAttribute]
private static Dictionary`2<Key, BinaryOperationCalculator> ourEnumBinaryUncheckedCalculators;
    [NotNullAttribute]
private static Dictionary`2<Key, UnaryOperationCalculator> ourEnumUnaryCheckedCalculators;
    [NotNullAttribute]
private static Dictionary`2<Key, UnaryOperationCalculator> ourEnumUnaryUncheckedCalculators;
    private static TypePresentationStyle ourTypePresentationStyle;
    private static CSharpConstantCalculatorImpl();
    public CSharpConstantCalculatorImpl(CSharpLanguage language);
    private static ConstantValue MultiplyUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MultiplyDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue DivideDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ModDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusStringStringChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusStringStringUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessThanDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterThanDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LessEqThanDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue GreaterEqThanDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityObjectObjectChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityObjectObjectUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityBoolBoolChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityBoolBoolUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityStringStringChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityStringStringUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue EqualityDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityObjectObjectChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityObjectObjectUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityDoubleDoubleChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityDoubleDoubleUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityBoolBoolChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityBoolBoolUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityStringStringChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityStringStringUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityFloatFloatChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityFloatFloatUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityDecimalDecimalChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue InequalityDecimalDecimalUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LeftShiftIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LeftShiftIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LeftShiftUlongIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LeftShiftUlongIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LeftShiftUintIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LeftShiftUintIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LeftShiftLongIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue LeftShiftLongIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue RightShiftIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue RightShiftIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue RightShiftUlongIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue RightShiftUlongIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue RightShiftUintIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue RightShiftUintIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue RightShiftLongIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue RightShiftLongIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndBoolBoolChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndBoolBoolUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrBoolBoolChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrBoolBoolUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorUlongUlongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorUlongUlongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorIntIntChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorIntIntUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorLongLongChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorLongLongUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorBoolBoolChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorBoolBoolUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorUintUintChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorUintUintUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndAlsoBoolBoolChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndAlsoBoolBoolUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrElseBoolBoolChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrElseBoolBoolUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusUlongChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusUlongUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusIntChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusIntUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusDecimalChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusDecimalUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusLongChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusLongUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusFloatChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusFloatUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusUintChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusUintUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusDoubleChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue PlusDoubleUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusIntChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusIntUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusLongChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusLongUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusFloatChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusFloatUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusDecimalChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusDecimalUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusDoubleChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue MinusDoubleUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue LogicalNotBoolChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue LogicalNotBoolUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementUlongChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementUlongUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementIntChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementIntUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementLongChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementLongUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementUintChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementUintUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue UnsignedRightShiftIntInt(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue UnsignedRightShiftUintInt(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue UnsignedRightShiftLongInt(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue UnsignedRightShiftUlongInt(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static void Initialize();
    private static ConstantValue PlusEnumSbyteSbyteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusEnumSbyteSbyteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusEnumByteByteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusEnumByteByteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusEnumShortShortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusEnumShortShortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusEnumUshortUshortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue PlusEnumUshortUshortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusEnumSbyteSbyteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusEnumSbyteSbyteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusEnumByteByteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusEnumByteByteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusEnumShortShortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusEnumShortShortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusEnumUshortUshortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue MinusEnumUshortUshortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndEnumSbyteSbyteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndEnumSbyteSbyteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndEnumByteByteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndEnumByteByteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndEnumShortShortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndEnumShortShortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndEnumUshortUshortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue AndEnumUshortUshortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrEnumSbyteSbyteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrEnumSbyteSbyteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrEnumByteByteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrEnumByteByteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrEnumShortShortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrEnumShortShortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrEnumUshortUshortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue OrEnumUshortUshortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorEnumSbyteSbyteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorEnumSbyteSbyteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorEnumByteByteChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorEnumByteByteUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorEnumShortShortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorEnumShortShortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorEnumUshortUshortChecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue XorEnumUshortUshortUnchecked(ConstantValue left, ConstantValue right, IPsiModule psiModule);
    private static ConstantValue ComplementEnumSbyteChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementEnumSbyteUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementEnumByteChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementEnumByteUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementEnumShortChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementEnumShortUnchecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementEnumUshortChecked(ConstantValue value, IPsiModule psiModule);
    private static ConstantValue ComplementEnumUshortUnchecked(ConstantValue value, IPsiModule psiModule);
    private static void InitializeEnum();
    private static void InitializeConversions();
    public virtual ConstantValue CalculateUnaryOperator(ISignOperator unaryOperator, ConstantValue value, bool isChecked);
    public virtual ConstantValue CalculateBinaryOperator(ISignOperator binaryOperator, ConstantValue leftValue, ConstantValue rightValue, bool isChecked);
    [NotNullAttribute]
internal ConstantValue CalculateUnaryEnumOperator(string operatorName, IEnum enum, ConstantValue value, bool isChecked);
    public virtual ConstantValue CalculateBinaryEnumOperator(string operatorName, IEnum enum, ConstantValue leftValue, ConstantValue rightValue, bool isChecked);
    public virtual ConstantValue ToTypeImplicit(ConstantValue value, IType type, ICSharpTypeConversionRule conversionRule);
    public virtual ConstantValue ToTypeExplicit(ConstantValue value, IType type, ICSharpTypeConversionRule conversionRule, bool isChecked);
    [NotNullAttribute]
private static ConstantValue ErrorHandling(Calculator calculator, ConstantValue valueInCaseOfOverflow);
    private static ConstantValue GetValueInCaseOfOverflow(IType returnType, bool isChecked);
    [CanBeNullAttribute]
private BinaryOperationCalculator GetBinaryCalculator(ISignOperator binaryOperator, bool isChecked);
    [CanBeNullAttribute]
private BinaryOperationCalculator GetBinaryEnumCalculator(EnumPredefinedOperator enumOperator, bool isChecked);
    [CanBeNullAttribute]
private BinaryOperationCalculator GetBinaryEnumCalculator(string operatorName, IEnum enum, bool isChecked);
    [CanBeNullAttribute]
private UnaryOperationCalculator GetUnaryCalculator(ISignOperator unaryOperator, bool isChecked);
    [CanBeNullAttribute]
private UnaryOperationCalculator GetUnaryEnumCalculator(EnumPredefinedOperator enumOperator, bool isChecked);
    [CanBeNullAttribute]
private UnaryOperationCalculator GetUnaryEnumCalculator(string operatorName, IEnum enum, bool isChecked);
    private Key KeyOf(string operatorName, IType type);
    private string GetKeyForConstantCalculation(IType type);
    private Key KeyOf(string operatorName, IType type1, IType type2);
    private Pair`2<string, string> KeyOf(IType type1, IType type2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.ConstantValues.CSharpConstantValueFactory : object {
    public static ConstantValue PURE_DEFAULT_VALUE;
    private static CSharpConstantValueFactory();
    [PureAttribute]
public static ConstantValue CreatePureNullValue(IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateSbyteValue(sbyte x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateByteValue(byte x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateShortValue(short x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateUshortValue(ushort x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateIntValue(int x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateUintValue(UInt32 x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateLongValue(long x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateUlongValue(ulong x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateDecimalValue(decimal x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateFloatValue(float x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateDoubleValue(double x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateCharValue(char x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateBoolValue(bool x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateStringValue(string x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateEnumValue(IEnum enum, object value);
    [PureAttribute]
public static ConstantValue CreateNullValue(IType type, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateDefaultValue(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPureDefaultValue(ConstantValue value);
    [PureAttribute]
public static ConstantValue CreateSpanOfCharConstantValue(string value, IType spanType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSpanOfCharConstantValue(ConstantValue constantValue);
    [PureAttribute]
public static ConstantValue CreateUtf8StringValue(string value, IPsiModule psiModule);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUtf8StringConstantValue(ConstantValue constantValue, String& stringValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.ConstantValues.CSharpConstantValuePresenter : ClrConstantValuePresenter {
    private CSharpLanguage myLanguage;
    public CSharpConstantValuePresenter(CSharpLanguage language);
    public virtual RichText Present(PsiLanguageType language, ConstantValue constantValue, TypePresentationStyle typePresentationStyle);
    [PureAttribute]
internal string PresentNullValue();
    [PureAttribute]
private RichText PresentNullValue(DeclaredElementPresenterTextStyles styles);
    [PureAttribute]
private RichText PresentDefaultLiteral(DeclaredElementPresenterTextStyles styles);
    [PureAttribute]
internal string PresentBooleanValue(ConstantValue constantValue);
    [PureAttribute]
private RichText PresentBooleanValue(ConstantValue constantValue, DeclaredElementPresenterTextStyles styles);
    [PureAttribute]
internal string PresentString(ConstantValue constantValue, CSharpLanguageLevel languageLevel);
    [PureAttribute]
private RichText PresentString(ConstantValue constantValue, DeclaredElementPresenterTextStyles styles);
    [PureAttribute]
internal string PresentChar(ConstantValue constantValue, CSharpLanguageLevel languageLevel);
    [PureAttribute]
private RichText PresentChar(ConstantValue constantValue, DeclaredElementPresenterTextStyles styles);
    [PureAttribute]
internal string PresentNumerable(ConstantValue constantValue);
    [PureAttribute]
private static RichText PresentEnum(PsiLanguageType language, ConstantValue constantValue, IEnum enum, DeclaredElementPresenterTextStyles styles);
    [PureAttribute]
public static RichText PresentEnum(ConstantValue constantValue, IEnum enum, Func`3<RichText, IField, RichText> memberFormatter);
    [CompilerGeneratedAttribute]
internal static RichText <Present>g__PresentNumber|2_0(string presentation, <>c__DisplayClass2_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.ConstantValues.CSharpConstantValueService : ClrConstantValueService {
    public CSharpConstantValueService(IConstantValuePresenter constantValuePresenter);
    public virtual ConstantValue GetDefaultValue(IType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CSharp.ConstantValues.RawStringErrorConstantValue : BadConstantValueBase {
    [CompilerGeneratedAttribute]
private TreeTextRange <ErrorRange>k__BackingField;
    public TreeTextRange ErrorRange { get; }
    private RawStringErrorConstantValue(TreeTextRange errorRange);
    [CompilerGeneratedAttribute]
public TreeTextRange get_ErrorRange();
    [NullableContextAttribute("2")]
public virtual bool Equals(ConstantValue other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class JetBrains.ReSharper.Psi.CSharp.ConstantValues.StringConstantValueUtil : object {
    private static UTF8Encoding ourUtf8Encoding;
    private static StringConstantValueUtil();
    [PureAttribute]
public static ConstantValue ParseStringLiteral(string text, IPsiModule psiModule);
    [PureAttribute]
private static string ConvertRegularStringLiteralPresentationToValue(string presentation, CSharpLanguageLevel languageLevel);
    [PureAttribute]
public static ConstantValue ParseCharLiteral(string text, IPsiModule psiModule);
    [PureAttribute]
public static bool IsValidUtf8StringValue(string text);
    [PureAttribute]
private static ConstantValue CreateUtf8StringValueWithValidation(string text, IPsiModule psiModule);
    public static ConstantValue ParseRawStringLiteral(ITokenNode token, bool isMultiline, IResolveContext resolveContext);
    [PureAttribute]
private static ConstantValue ProcessMultilineRawStringLiteral(ITokenNode token, string text, int startingQuoteCount, bool hasUtf8Suffix, IResolveContext resolveContext);
    [PureAttribute]
public static ConstantValue GetInterpolatedStringConstantValue(IInterpolatedStringExpression expression, IResolveContext resolveContext);
    [PureAttribute]
private static string TryBuildConstantString(IInterpolatedStringExpression expression, IResolveContext resolveContext);
    [MustUseReturnValueAttribute]
private static bool TryAddRegularValuePart(ITreeNode child, PooledStringBuilder builder, int start);
    [MustUseReturnValueAttribute]
private static bool TryAddVerbatimValuePart(ITreeNode child, PooledStringBuilder builder, int start);
    [MustUseReturnValueAttribute]
private static bool TryAddStringInsert(ITreeNode childNode, PooledStringBuilder builder, IResolveContext resolveContext);
    [PureAttribute]
private static ConstantValue GetRawInterpolatedStringConstantValue(IInterpolatedStringExpression expression, bool isMultiline, IResolveContext resolveContext);
    [MustUseReturnValueAttribute]
private static bool CheckInterpolatedStringRawTextBorders(bool checkStart, ITokenNode textToken, int dollarSignCount, ConstantValue& error);
}
public class JetBrains.ReSharper.Psi.CSharp.ConstantValues.Utf8StringEncodingErrorConstantValue : BadConstantValueBase {
    [CompilerGeneratedAttribute]
private string <StringValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Codepoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInValue>k__BackingField;
    public string StringValue { get; }
    public int Codepoint { get; }
    public int IndexInValue { get; }
    protected string DumpMessage { get; }
    public Utf8StringEncodingErrorConstantValue(string stringValue, int codepoint, int indexInValue);
    [CompilerGeneratedAttribute]
public virtual string get_StringValue();
    [CompilerGeneratedAttribute]
public int get_Codepoint();
    [CompilerGeneratedAttribute]
public int get_IndexInValue();
    protected virtual string get_DumpMessage();
}
public class JetBrains.ReSharper.Psi.CSharp.ControlFlow.AnalysisInfo : object {
    public int VariableInfoCount;
    public int MemorySnapshotCount;
    public int ReferenceAccessCount;
    public int TypesCount;
    public int TotalContexts;
    public int TotalSnapshots;
    public int TotalUniqueArrays;
    public int OverflowedContexts;
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.CSharp.ControlFlow.ConstantExpressionValue : Enum {
    public int value__;
    public static ConstantExpressionValue TRUE;
    public static ConstantExpressionValue FALSE;
    public static ConstantExpressionValue NULL;
}
public enum JetBrains.ReSharper.Psi.CSharp.ControlFlow.ControlFlowEdgeCondition : Enum {
    public byte value__;
    public static ControlFlowEdgeCondition None;
    public static ControlFlowEdgeCondition True;
    public static ControlFlowEdgeCondition False;
    public static ControlFlowEdgeCondition Null;
    public static ControlFlowEdgeCondition NotNull;
}
public static class JetBrains.ReSharper.Psi.CSharp.ControlFlow.ControlFlowUtil : object {
    [NotNullAttribute]
public static IDictionary`2<ILocalVariableDeclaration, IAssignmentExpression> FindJoinableDeclarationsAndAssignments(ICSharpControlFlowAnalysisResult analysisResult, ICollection`1<IStatement> availableStatements);
    [NotNullAttribute]
public static ICSharpStatement JoinDeclarationsAndAssignments(IAssignmentExpression assignmentExpression, ILocalVariableDeclaration variableDeclaration);
    [CanBeNullAttribute]
private static IAssignmentExpression FindAssignment(IDeclaredElement element);
    [NotNullAttribute]
private static IReference[] FindReferences(IDeclaredElement variable);
    [CanBeNullAttribute]
private static IReference GetFirstReference(IDeclaredElement element);
    [CanBeNullAttribute]
private static ILocalVariableDeclaration FindSuitableLocalVariableDeclaration(IDeclaredElement element);
    [CanBeNullAttribute]
private static ILocalVariableDeclaration FindDeclaration(IAssignmentExpression expression);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpControlFlowBuilder : object {
    public sealed virtual bool CanBuildFrom(ITreeNode treeNode);
    public sealed virtual IControlFlowGraph GraphFromNode(ITreeNode graphOwner, IResolveContext context, bool buildExpressions);
}
public enum JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpControlFlowErrorType : Enum {
    public int value__;
    public static CSharpControlFlowErrorType MISSING_BREAK_IN_SWITCH;
    public static CSharpControlFlowErrorType JUMP_FROM_FINALLY;
    public static CSharpControlFlowErrorType UNRESOLVED_JUMP;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpControlFlowNullReferenceState : Enum {
    public int value__;
    public static CSharpControlFlowNullReferenceState UNKNOWN;
    public static CSharpControlFlowNullReferenceState NOT_NULL;
    public static CSharpControlFlowNullReferenceState NULL;
    public static CSharpControlFlowNullReferenceState MAY_BE_NULL;
}
public class JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpExitFromFinallyEdgeInfo : object {
    [CompilerGeneratedAttribute]
private ICSharpControlFlowEdge <PassThroughFinally>k__BackingField;
    public ICSharpControlFlowEdge PassThroughFinally { get; internal set; }
    [CompilerGeneratedAttribute]
public ICSharpControlFlowEdge get_PassThroughFinally();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PassThroughFinally(ICSharpControlFlowEdge value);
}
public class JetBrains.ReSharper.Psi.CSharp.ControlFlow.CSharpPassThroughFinallyEdgeInfo : object {
    [CompilerGeneratedAttribute]
private ITryStatement <TryStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private IControlFlowElement <ExitMultiplexor>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpControlFlowEdge <ExitFromFinallyEdge>k__BackingField;
    public ITryStatement TryStatement { get; internal set; }
    public IControlFlowElement ExitMultiplexor { get; internal set; }
    public ICSharpControlFlowEdge ExitFromFinallyEdge { get; internal set; }
    [CompilerGeneratedAttribute]
public ITryStatement get_TryStatement();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TryStatement(ITryStatement value);
    [CompilerGeneratedAttribute]
public IControlFlowElement get_ExitMultiplexor();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExitMultiplexor(IControlFlowElement value);
    [CompilerGeneratedAttribute]
public ICSharpControlFlowEdge get_ExitFromFinallyEdge();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExitFromFinallyEdge(ICSharpControlFlowEdge value);
}
public class JetBrains.ReSharper.Psi.CSharp.ControlFlow.CumulativeCSharpControlFlowAnalysisResult : ConcurrentDictionary`2<IDeclaration, ISharedControlFlowAnalysisResult> {
}
public interface JetBrains.ReSharper.Psi.CSharp.ControlFlow.ICSharpControlFlowAnalysisResult {
    public bool HasComplexityOverflow { get; }
    public bool HasRecursionOnAllReachableExits { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public ValueAnalysisMode AnalysisMode { get; }
    public HashSet`1<ICSharpExpression> PossibleNullReferenceAccess { get; }
    public HashSet`1<ICSharpExpression> PossibleInvalidCastExpressions { get; }
    public IList`1<IAsExpression> AlwaysSuccessTryCastExpressions { get; }
    public IReadOnlyDictionary`2<IAssignmentExpression, IParameter> RefAssignmentsToUnassignedOutParameters { get; }
    public IDictionary`2<ICSharpExpression, ConstantExpressionValue> ConstantConditionExpressions { get; }
    public IDictionary`2<ValueTuple`2<ICSharpExpression, ICSharpExpression>, CSharpControlFlowNullReferenceState> ConstantConditionNullCoalescingExpression { get; }
    public IDictionary`2<IConditionalAccessExpression, CSharpControlFlowNullReferenceState> ConstantConditionalAccessExpressions { get; }
    public ICollection`1<ICSharpExpression> NullCoalescingOperatorRightOperandIsAlwaysNull { get; }
    public HashSet`1<ITreeNode> AssignNullToNotNullEntity { get; }
    public CSharpControlFlowNullReferenceState SuggestReturnValueAnnotationAttribute { get; }
    public IDictionary`2<IDeclaredElement, CSharpControlFlowNullReferenceState> InferredNullability { get; }
    public ICollection`1<IAssignmentExpression> MeaninglessAssignments { get; }
    public OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, ICSharpExpression> PossibleMultipleEnumeration { get; }
    public IEnumerable`1<IIsExpression> HeuristicTrueIsExpressions { get; }
    public IEnumerable`1<ISwitchCaseLabel> HeuristicUnreachableCaseLabels { get; }
    public IEnumerable`1<ISwitchExpressionArm> HeuristicUnreachableSwitchArms { get; }
    public ICollection`1<ICSharpStatement> HeuristicUnreachableCode { get; }
    public ICollection`1<ICSharpExpression> LoopVariablesNotChangedInsideLoop { get; }
    public IEnumerable`1<KeyValuePair`2<IDeclaredElement, ISet`1<ITreeNode>>> EnumerablesAccessedInClosure { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<ILocalFunctionDeclaration> LocalFunctionsWithRecursionOnAllReachableExits { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<PatternMatchingCandidateData> PatternMatchingSuggestions { get; }
    [NotNullAttribute]
public IEnumerable`1<ValueTuple`2<IReferenceExpression, IType>> ByRefTypesInAwaitOrYieldClosure { get; }
    [NotNullAttribute]
public IEnumerable`1<IReferenceExpression> RefLocalsInAwaitOrYieldClosure { get; }
    public abstract virtual bool get_HasComplexityOverflow();
    public abstract virtual bool get_HasRecursionOnAllReachableExits();
    public abstract virtual CSharpLanguageLevel get_LanguageLevel();
    public abstract virtual ValueAnalysisMode get_AnalysisMode();
    public abstract virtual HashSet`1<ICSharpExpression> get_PossibleNullReferenceAccess();
    public abstract virtual HashSet`1<ICSharpExpression> get_PossibleInvalidCastExpressions();
    public abstract virtual IList`1<IAsExpression> get_AlwaysSuccessTryCastExpressions();
    public abstract virtual IReadOnlyDictionary`2<IAssignmentExpression, IParameter> get_RefAssignmentsToUnassignedOutParameters();
    public abstract virtual IDictionary`2<ICSharpExpression, ConstantExpressionValue> get_ConstantConditionExpressions();
    public abstract virtual IDictionary`2<ValueTuple`2<ICSharpExpression, ICSharpExpression>, CSharpControlFlowNullReferenceState> get_ConstantConditionNullCoalescingExpression();
    public abstract virtual IDictionary`2<IConditionalAccessExpression, CSharpControlFlowNullReferenceState> get_ConstantConditionalAccessExpressions();
    public abstract virtual ICollection`1<ICSharpExpression> get_NullCoalescingOperatorRightOperandIsAlwaysNull();
    public abstract virtual HashSet`1<ITreeNode> get_AssignNullToNotNullEntity();
    public abstract virtual CSharpControlFlowNullReferenceState get_SuggestReturnValueAnnotationAttribute();
    public abstract virtual IDictionary`2<IDeclaredElement, CSharpControlFlowNullReferenceState> get_InferredNullability();
    public abstract virtual ICollection`1<IAssignmentExpression> get_MeaninglessAssignments();
    public abstract virtual OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, ICSharpExpression> get_PossibleMultipleEnumeration();
    public abstract virtual IEnumerable`1<IIsExpression> get_HeuristicTrueIsExpressions();
    public abstract virtual IEnumerable`1<ISwitchCaseLabel> get_HeuristicUnreachableCaseLabels();
    public abstract virtual IEnumerable`1<ISwitchExpressionArm> get_HeuristicUnreachableSwitchArms();
    public abstract virtual ICollection`1<ICSharpStatement> get_HeuristicUnreachableCode();
    public abstract virtual ICollection`1<ICSharpExpression> get_LoopVariablesNotChangedInsideLoop();
    public abstract virtual IEnumerable`1<KeyValuePair`2<IDeclaredElement, ISet`1<ITreeNode>>> get_EnumerablesAccessedInClosure();
    public abstract virtual IEnumerable`1<ILocalFunctionDeclaration> get_LocalFunctionsWithRecursionOnAllReachableExits();
    public abstract virtual IEnumerable`1<PatternMatchingCandidateData> get_PatternMatchingSuggestions();
    public abstract virtual IEnumerable`1<ValueTuple`2<IReferenceExpression, IType>> get_ByRefTypesInAwaitOrYieldClosure();
    public abstract virtual IEnumerable`1<IReferenceExpression> get_RefLocalsInAwaitOrYieldClosure();
    public abstract virtual CSharpControlFlowNullReferenceState GetExpressionNullReferenceState(IReferenceExpression expression, bool includeWeakNotNull);
    public abstract virtual ControlFlowVariableAccessState GetVariableAccessStateAt(IControlFlowEdge edge, IDeclaredElement variable);
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<ITreeNode> GetRecentAssignmentsList(IControlFlowEdge edge, IDeclaredElement variable);
    public abstract virtual CSharpControlFlowNullReferenceState GetVariableStateAt(IControlFlowElement position, IDeclaredElement variable);
    public abstract virtual bool IsAssignedTypeCouldBePureEnumerable(IDeclaredElement declaredElement, ITreeNode assignment);
    public abstract virtual bool IsLambdaKnownToBeExecutedLocally(ITreeNode lambda);
    public abstract virtual ISharedControlFlowAnalysisResult CreateSharedControlFlowAnalysisResult();
    [NotNullAttribute]
public abstract virtual AnalysisInfo GetStatistics();
    public abstract virtual LocalFunctionInfo GetLocalFunctionInfo(ILocalFunction localFunction);
}
public interface JetBrains.ReSharper.Psi.CSharp.ControlFlow.ICSharpControlFlowEdge {
    [NotNullAttribute]
public ICSharpControlFlowElement Source { get; }
    [CanBeNullAttribute]
public ICSharpControlFlowElement Target { get; public set; }
    public ControlFlowEdgeCondition Condition { get; }
    [CanBeNullAttribute]
public CSharpPassThroughFinallyEdgeInfo PassThroughFinally { get; }
    [CanBeNullAttribute]
public CSharpExitFromFinallyEdgeInfo ExitFromFinally { get; }
    [NotNullAttribute]
public IEnumerable`1<IDeclaredElement> ExitFromUsings { get; }
    [NotNullAttribute]
public IEnumerable`1<ICSharpStatement> ExitFromLoops { get; }
    public abstract virtual ICSharpControlFlowElement get_Source();
    public abstract virtual ICSharpControlFlowElement get_Target();
    public abstract virtual void set_Target(ICSharpControlFlowElement value);
    public abstract virtual ControlFlowEdgeCondition get_Condition();
    public abstract virtual CSharpPassThroughFinallyEdgeInfo get_PassThroughFinally();
    public abstract virtual CSharpExitFromFinallyEdgeInfo get_ExitFromFinally();
    public abstract virtual IEnumerable`1<IDeclaredElement> get_ExitFromUsings();
    public abstract virtual IEnumerable`1<ICSharpStatement> get_ExitFromLoops();
}
public interface JetBrains.ReSharper.Psi.CSharp.ControlFlow.ICSharpControlFlowElement {
    public bool ExecutesCode { get; }
    public abstract virtual bool get_ExecutesCode();
}
public interface JetBrains.ReSharper.Psi.CSharp.ControlFlow.ICSharpControlFlowError {
    public CSharpControlFlowErrorType ErrorType { get; }
    public abstract virtual CSharpControlFlowErrorType get_ErrorType();
}
public interface JetBrains.ReSharper.Psi.CSharp.ControlFlow.ICSharpControlFlowGraph {
    [NotNullAttribute]
public ISolution Solution { get; }
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    [NotNullAttribute]
public ICSharpTreeNode OwnerNode { get; }
    [CanBeNullAttribute]
public ICSharpDeclaration Declaration { get; }
    [NotNullAttribute]
public ICSharpTreeNode Body { get; }
    public CSharpLanguageLevel CSharpLanguageLevel { get; }
    [NotNullAttribute]
public ICSharpTypeConversionRule ConversionRule { get; }
    public bool IsInstanceStructConstructor { get; }
    [NotNullAttribute]
public IList`1<IParameter> Parameters { get; }
    [NotNullAttribute]
public IDictionary`2<ITreeNode, CSharpControlFlowErrorType> ControlFlowErrors { get; }
    [NotNullAttribute]
public ICollection`1<ICSharpControlFlowEdge> ReachableExits { get; }
    [NotNullAttribute]
public ICollection`1<ICSharpStatement> RedundantJumpStatements { get; }
    public bool HasReachableImplicitReturn { get; }
    public abstract virtual ISolution get_Solution();
    public abstract virtual IPsiModule get_PsiModule();
    public abstract virtual ICSharpTreeNode get_OwnerNode();
    public abstract virtual ICSharpDeclaration get_Declaration();
    public abstract virtual ICSharpTreeNode get_Body();
    public abstract virtual CSharpLanguageLevel get_CSharpLanguageLevel();
    public abstract virtual ICSharpTypeConversionRule get_ConversionRule();
    public abstract virtual bool get_IsInstanceStructConstructor();
    public abstract virtual IList`1<IParameter> get_Parameters();
    public abstract virtual IDictionary`2<ITreeNode, CSharpControlFlowErrorType> get_ControlFlowErrors();
    public abstract virtual ICollection`1<ICSharpControlFlowEdge> get_ReachableExits();
    public abstract virtual ICollection`1<ICSharpStatement> get_RedundantJumpStatements();
    public abstract virtual bool get_HasReachableImplicitReturn();
    public abstract virtual bool IsJumpStatementMandatoryForSwitch(ICSharpStatement statement);
    public abstract virtual bool IsImplicitSwitchBlockImplicitExitEdge(ICSharpControlFlowEdge edge);
}
public interface JetBrains.ReSharper.Psi.CSharp.ControlFlow.ICSharpControlFlowStatement {
    [CanBeNullAttribute]
public ICSharpStatement Statement { get; }
    public abstract virtual ICSharpStatement get_Statement();
}
public interface JetBrains.ReSharper.Psi.CSharp.ControlFlow.IMayThrowInsideCatchMultiplexor {
    [NotNullAttribute]
public ICatchClause CatchClause { get; }
    public abstract virtual ICatchClause get_CatchClause();
}
public class JetBrains.ReSharper.Psi.CSharp.Conversions.CollectionExpressionUncommonData : object {
    [NullableAttribute("1")]
public IType ElementType;
    public CollectionExpressionKind Kind;
    [NullableContextAttribute("1")]
public CollectionExpressionUncommonData(IType elementType, CollectionExpressionKind kind);
    public sealed virtual bool IsValid(ConversionKind conversionKind);
    [NullableContextAttribute("2")]
public void Deconstruct(IType& elementType, CollectionExpressionKind& kind);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Conversions.Conversion : ValueType {
    public static Conversion NoConversion;
    internal static Conversion Identity;
    internal static Conversion ImplicitConstant;
    internal static Conversion ImplicitNumeric;
    internal static Conversion ImplicitReference;
    internal static Conversion ImplicitEnumeration;
    internal static Conversion ImplicitPointer;
    internal static Conversion ImplicitThrow;
    internal static Conversion AnonymousFunction;
    internal static Conversion Boxing;
    internal static Conversion NullLiteral;
    internal static Conversion NullToPointer;
    internal static Conversion PointerToVoid;
    internal static Conversion PointerToPointer;
    internal static Conversion PointerToInteger;
    internal static Conversion IntegerToPointer;
    internal static Conversion Unboxing;
    internal static Conversion ExplicitReference;
    internal static Conversion IntPtr;
    internal static Conversion ExplicitEnumeration;
    internal static Conversion ExplicitNumeric;
    internal static Conversion ImplicitDynamic;
    internal static Conversion ExplicitDynamic;
    internal static Conversion InterpolatedString;
    internal static Conversion InterpolatedStringHandler;
    internal static Conversion DefaultLiteral;
    internal static Conversion FunctionType;
    internal static Conversion TargetTypedObjectCreation;
    internal static Conversion InlineArray;
    [CanBeNullAttribute]
private IUncommonData myUncommonData;
    [CompilerGeneratedAttribute]
private ConversionKind <Kind>k__BackingField;
    public ConversionKind Kind { get; }
    public bool IsImplicit { get; }
    public bool IsExplicit { get; }
    public bool IsIdentity { get; }
    public bool IsReference { get; }
    public bool IsUserDefined { get; }
    public bool IsValid { get; }
    [CanBeNullAttribute]
public UserDefinedConversionAnalysis UserDefinedConversionAnalysis { get; }
    private Conversion(ConversionKind kind);
    public Conversion(ConversionKind kind, IUncommonData uncommonData);
    public Conversion(UserDefinedConversionResult conversionResult, bool isImplicit);
    public Conversion(ConversionKind kind, IReadOnlyList`1<TypeConversionInfo> nestedConversions);
    private static Conversion();
    internal static Conversion GetTrivialConversion(ConversionKind kind);
    [CompilerGeneratedAttribute]
public ConversionKind get_Kind();
    public bool get_IsImplicit();
    public bool get_IsExplicit();
    public bool get_IsIdentity();
    public bool get_IsReference();
    public bool get_IsUserDefined();
    public bool get_IsValid();
    public UserDefinedConversionAnalysis get_UserDefinedConversionAnalysis();
    [CanBeNullAttribute]
[PureAttribute]
public IUncommonData GetUncommonData();
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<Conversion> GetNestedConversions();
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<Conversion> GetTopLevelNestedConversions();
    [NotNullAttribute]
[PureAttribute]
private IReadOnlyList`1<Conversion> GetNestedConversionsImpl(bool topLevelConversionsOnly);
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<TypeConversionInfo> GetNestedConversionsWithTypeInfo();
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<TypeConversionInfo> GetTopLevelNestedConversionsWithTypeInfo();
    [NotNullAttribute]
[PureAttribute]
private IReadOnlyList`1<TypeConversionInfo> GetNestedConversionsWithTypeInfoImpl(bool topLevelConversionsOnly);
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<IConversionOperator> GetAllUsedUserDefinedConversionOperators();
    [PureAttribute]
public bool HasAnyUsedUserDefinedConversionOperators();
    [CanBeNullAttribute]
[PureAttribute]
public IConversionOperator GetTopLevelUserDefinedConversionOperator();
    [ObsoleteAttribute("Semantic is unclear as the C# language specification doesn't define such conversion kind.")]
public bool IsPredefined();
    [PureAttribute]
private static bool IsImplicitConversion(ConversionKind conversionKind);
    [PureAttribute]
[NotNullAttribute]
internal string Dump(string indent);
    internal void Dump(StringBuilder builder, string indent);
    private void DumpUserDefinedConversionInfo(StringBuilder builder, string indent);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertTrivialConversion(ConversionKind kind);
    public virtual string ToString();
    public sealed virtual bool Equals(Conversion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Conversions.ConversionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsValidExtensionMethodConversion(Conversion conversion);
}
public enum JetBrains.ReSharper.Psi.CSharp.Conversions.ConversionKind : Enum {
    public byte value__;
    public static ConversionKind NoConversion;
    public static ConversionKind Identity;
    public static ConversionKind ImplicitNumeric;
    public static ConversionKind ImplicitEnumeration;
    public static ConversionKind ImplicitThrow;
    public static ConversionKind ImplicitTupleLiteral;
    public static ConversionKind ImplicitTuple;
    public static ConversionKind ExplicitTupleLiteral;
    public static ConversionKind ExplicitTuple;
    public static ConversionKind ImplicitNullable;
    public static ConversionKind NullLiteral;
    public static ConversionKind ImplicitReference;
    public static ConversionKind Boxing;
    public static ConversionKind PointerToVoid;
    public static ConversionKind NullToPointer;
    public static ConversionKind ImplicitDynamic;
    public static ConversionKind ExplicitDynamic;
    public static ConversionKind ImplicitConstant;
    public static ConversionKind ImplicitUserDefined;
    public static ConversionKind AnonymousFunction;
    public static ConversionKind MethodGroup;
    public static ConversionKind FunctionType;
    public static ConversionKind ExplicitNumeric;
    public static ConversionKind ExplicitEnumeration;
    public static ConversionKind ExplicitNullable;
    public static ConversionKind ExplicitReference;
    public static ConversionKind Unboxing;
    public static ConversionKind ExplicitUserDefined;
    public static ConversionKind PointerToPointer;
    public static ConversionKind IntegerToPointer;
    public static ConversionKind PointerToInteger;
    public static ConversionKind IntPtr;
    public static ConversionKind InterpolatedString;
    public static ConversionKind SwitchExpression;
    public static ConversionKind ConditionalExpression;
    public static ConversionKind StackAllocToPointerType;
    public static ConversionKind StackAllocToSpanType;
    public static ConversionKind DefaultLiteral;
    public static ConversionKind ObjectCreation;
    public static ConversionKind ImplicitPointer;
    public static ConversionKind InterpolatedStringHandler;
    public static ConversionKind InlineArray;
    public static ConversionKind CollectionExpression;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Conversions.CSharpTypeConversionRuleExtension : object {
    [NotNullAttribute]
private static Key`1<ICSharpTypeConversionRule> ourTypeConversionRuleKey;
    private static CSharpTypeConversionRuleExtension();
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ICSharpTypeConversionRule GetTypeConversionRule(ITreeNode node, bool includeNullability);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ICSharpTypeConversionRule GetTypeConversionRule(IPsiModule module, bool includeNullability);
    [ExtensionAttribute]
[ObsoleteAttribute("Replace this method with conversion classification API of ICSharpTypeConversionRule. It's here for backward compatibility only and will be removed later. It returns only top level used defined conversion operator and ignores all nested ones.")]
[PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public static bool IsImplicitlyConvertibleTo(ICSharpTypeConversionRule conversionRule, IType from, IType to, IConversionOperator& userOperator);
    [ExtensionAttribute]
[ObsoleteAttribute("Replace this method with conversion classification API of ICSharpTypeConversionRule. It's here for backward compatibility only and will be removed later. It returns only top level used defined conversion operator and ignores all nested ones.")]
[PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public static bool IsExplicitlyConvertibleTo(ICSharpTypeConversionRule conversionRule, IType from, IType to, IConversionOperator& userOperator);
    [ExtensionAttribute]
[ObsoleteAttribute("Replace this method with conversion classification API of ICSharpTypeConversionRule. It's here for backward compatibility only and will be removed later.")]
[PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public static bool ExplicitReferenceConversionExist(ICSharpTypeConversionRule conversionRule, IType from, IType to);
    [ExtensionAttribute]
[ObsoleteAttribute("Replace this method with conversion classification API of ICSharpTypeConversionRule. It's here for backward compatibility only and will be removed later.")]
[PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public static bool IsUnboxingConversion(ICSharpTypeConversionRule conversionRule, IType from, IType to);
    [ExtensionAttribute]
[ObsoleteAttribute("Replace this method with conversion classification API of ICSharpTypeConversionRule. It's here for backward compatibility only and will be removed later.")]
[PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public static bool IsBoxingConversion(ICSharpTypeConversionRule conversionRule, IType from, IType to);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasNullabilityConversion(ICSharpTypeConversionRule conversionRule, IType from, IType to, bool requireIdentity);
}
public interface JetBrains.ReSharper.Psi.CSharp.Conversions.ICSharpTypeConversionRule {
    public bool IncludeNullability { get; }
    public abstract virtual bool get_IncludeNullability();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IType BestCommonType(ICollection`1<TExpressionType> types);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IType BestCommonType(ICollection`1<TExpressionType> types, bool allowFunctionTypes);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool ImplicitReferenceConversionExist(IType from, IType to);
    [PureAttribute]
public abstract virtual Conversion ClassifyImplicitConversion(IType from, IType to);
    [PureAttribute]
public abstract virtual Conversion ClassifyConversionFromType(IType from, IType to, bool isChecked);
    [PureAttribute]
public abstract virtual Conversion ClassifyBuiltInConversion(IType from, IType to);
    [PureAttribute]
public abstract virtual Conversion ClassifyImplicitConversionFromExpression(IExpressionType from, IType to);
    [PureAttribute]
public abstract virtual Conversion ClassifyConversionFromExpression(IExpressionType fromExpressionType, IType to, bool isChecked);
    [PureAttribute]
public abstract virtual Conversion ClassifyImplicitExtensionMethodThisArgumentConversion(IExpressionType fromExpressionType, IType to);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual CSharpTypeConversionRule WithNullability(bool includeNullability);
    [PureAttribute]
public abstract virtual bool HasTopLevelNullabilityImplicitConversion(IExpressionType source, IType destination);
    [PureAttribute]
public abstract virtual bool HasTopLevelNullabilityIdentityConversion(IType source, IType destination);
    [PureAttribute]
public abstract virtual bool HasImplicitTypeParameterConversion(IType fromTypeParameterType, IType to);
    [PureAttribute]
public abstract virtual bool ImplementsVarianceCompatibleInterface(IDeclaredType derivedType, IType baseType);
    public abstract virtual bool HasImplicitConversionToOrImplementsVarianceCompatibleInterface(IType typeToCheck, IDeclaredType targetInterfaceType, Boolean& needSupportForRefStructInterfaces);
    public abstract virtual bool HasImplicitConversionToOrImplementsVarianceCompatibleInterface(IExpressionType expressionTypeToCheck, IDeclaredType targetInterfaceType, Boolean& needSupportForRefStructInterfaces);
}
public interface JetBrains.ReSharper.Psi.CSharp.Conversions.IUncommonData {
    public abstract virtual bool IsValid(ConversionKind conversionKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Conversions.NestedConversionsUncommonData : object {
    [CompilerGeneratedAttribute]
private UserDefinedConversionResult <UserDefinedConversionResult>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TypeConversionInfo> <NestedTypeConversionInfo>k__BackingField;
    public UserDefinedConversionResult UserDefinedConversionResult { get; }
    public IReadOnlyList`1<TypeConversionInfo> NestedTypeConversionInfo { get; }
    public NestedConversionsUncommonData(UserDefinedConversionResult conversionResult, IReadOnlyList`1<TypeConversionInfo> nestedTypeConversionInfo);
    [CompilerGeneratedAttribute]
public UserDefinedConversionResult get_UserDefinedConversionResult();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TypeConversionInfo> get_NestedTypeConversionInfo();
    public sealed virtual bool IsValid(ConversionKind conversionKind);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Conversions.TypeConversionInfo : ValueType {
    [NotNullAttribute]
public IExpressionType SourceType;
    [NotNullAttribute]
public IType TargetType;
    public Conversion Conversion;
    public TypeConversionInfo(IExpressionType sourceType, IType targetType, Conversion conversion);
    public sealed virtual bool Equals(TypeConversionInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Conversions.UserDefinedConversionAnalysis : object {
    public OperatorInfo OperatorInfo;
    [NotNullAttribute]
public IExpressionType FromType;
    [NotNullAttribute]
public IType ToType;
    [NotNullAttribute]
public IType EffectiveOperatorSourceType;
    [NotNullAttribute]
public IType EffectiveOperatorTargetType;
    public Conversion SourceConversion;
    public Conversion TargetConversion;
    public bool VerificationFailed;
    public UserDefinedConversionAnalysis(OperatorInfo op, Conversion sourceConversion, Conversion targetConversion, IExpressionType fromType, IType toType, IType effectiveOperatorSourceType, IType effectiveOperatorTargetType, bool verificationFailed);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Conversions.UserDefinedConversionResult : ValueType {
    [CanBeNullAttribute]
public UserDefinedConversionAnalysis Result;
    public UserDefinedConversionResultKind Kind;
    public static UserDefinedConversionResult NoApplicableOperators;
    public static UserDefinedConversionResult NoBestSourceType;
    public static UserDefinedConversionResult NoBestTargetType;
    public static UserDefinedConversionResult Ambiguous;
    private UserDefinedConversionResult(UserDefinedConversionResultKind kind, UserDefinedConversionAnalysis result);
    private static UserDefinedConversionResult();
    public static UserDefinedConversionResult Valid(UserDefinedConversionAnalysis result);
}
public enum JetBrains.ReSharper.Psi.CSharp.Conversions.UserDefinedConversionResultKind : Enum {
    public byte value__;
    public static UserDefinedConversionResultKind NoApplicableOperators;
    public static UserDefinedConversionResultKind NoBestSourceType;
    public static UserDefinedConversionResultKind NoBestTargetType;
    public static UserDefinedConversionResultKind Ambiguous;
    public static UserDefinedConversionResultKind Valid;
}
public static class JetBrains.ReSharper.Psi.CSharp.CSharpAttributeInstanceUtil : object {
    private static HashSet`1<string> ourSkipAttributes;
    private static CSharpAttributeInstanceUtil();
    public static IAttributeInstance[] FilterAttributes(IAttributesSet owner, bool showNonVisibleMembers, bool showExternalAnnotations, bool showTupleElementNames, bool showNullableAttributes, bool fieldTargeted);
    public static bool IsDebuggerBrowsableNeverAttribute(IAttributeInstance instance);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.CSharpElementFactory : object {
    [NotNullAttribute]
[PureAttribute]
public static CSharpElementFactory GetInstance(ITreeNode element, bool applyCodeFormatter);
    [NotNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Use ITreeNode overload instead")]
public static CSharpElementFactory GetInstance(IPsiModule module, bool applyCodeFormatter);
    [NotNullAttribute]
[PureAttribute]
public ICSharpFile CreateFile(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
protected abstract virtual ICSharpFile CreateFileImpl(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IBlock CreateBlock(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITopLevelCode CreateTopLevelCode();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression CreateExpressionAsIs(string format, bool applyCodeFormatter);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression CreateExpressionAsIs(string format);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression CreateExpression(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IThrowExpression CreateThrowExpression(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDeclarationExpression CreateDeclarationExpression(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpTypeMemberDeclaration CreateTypeMemberDeclaration(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpStatement CreateStatement(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IBlock CreateEmptyBlock();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IUsingDirective CreateUsingDirective(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IUsingDirective CreateUsingStaticDirective(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExternAliasDirective CreateExternAliasDirective(string externAlias);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReferenceExpression CreateReferenceExpression(string expr, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReferenceName CreateReferenceName(string name, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpNamespaceDeclaration CreateNamespaceDeclaration(string name, bool isFileScoped);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpParameterDeclaration CreateParameterDeclaration(IParametersOwnerDeclaration ownerDeclaration, ParameterKind kind, bool isParams, bool isVarArg, IType type, string name, ICSharpExpression defaultValue);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpParameterDeclaration CreateTypeMemberParameterDeclaration(ParameterKind kind, bool isParams, bool isVarArg, IType type, string name, ICSharpExpression defaultValue);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpArgument CreateArgument(ParameterKind kind, ICSharpExpression arg);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpArgument CreateArgument(ParameterKind kind, string name, ICSharpExpression arg);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPropertyAssignment CreatePropertyAssignment(string name, ICSharpExpression arg);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAccessorDeclaration CreateAccessorDeclaration(AccessorKind kind, bool withBody);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAccessorDeclaration CreateAccessorDeclaration(CSharpAccessorKind kind, bool withBody);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAccessorDeclaration CreateAccessorDeclaration(string format, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IConstructorInitializer CreateThisConstructorInitializer();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IConstructorInitializer CreateBaseConstructorInitializer();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IConstructorDeclaration CreateConstructorDeclaration();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDestructorDeclaration CreateDestructorDeclaration();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITypeParameterOfLocalFunctionDeclaration CreateTypeParameterOfLocalFunctionDeclaration(string name);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITypeParameterOfTypeDeclaration CreateTypeParameterOfTypeDeclaration(string name);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITypeParameterOfMethodDeclaration CreateTypeParameterOfMethodDeclaration(string name);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITypeParameterConstraintsClause CreateTypeParameterConstraintsClause(ITypeParameter typeParameter, ISubstitution substitution, string parameterName);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IArrayCreationExpression CreateArrayCreationExpression(IArrayType arrayType, IArrayInitializer arrayInitializer);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAttribute CreateAttribute(IAttributeInstance instance);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAttribute CreateAttribute(ITypeElement attributeClass, AttributeValue[] fixedArguments, Pair`2[] namedArguments);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IWhitespaceNode[] CreateWhitespaces(string whitespaces);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpCommentNode CreateComment(string text);
    [NotNullAttribute]
[PureAttribute]
public IAttribute CreateAttribute(ITypeElement attributeClass);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITypeUsage CreateTypeUsage(string typeUsageText);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITypeUsage CreateTypeUsage(string typeUsage, Object[] args);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITypeUsage CreateTypeUsage(IType type, ITreeNode context, Nullable`1<TypePresentationOptions> options);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression CreateExpressionByConstantValue(ConstantValue value, bool safeConstantValueExactType, int qualifierDepth);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression CreateExpressionByConstantValue(ConstantValue value);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression CreateExpressionByDefaultValue(DefaultValue value, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpLiteralExpression CreateStringLiteralExpression(string value);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDocCommentBlock CreateDocCommentBlock(string text);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDocCommentNode CreateDocComment(string text, bool useMultiline);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAnonymousMemberDeclaration CreateAnonymousMemberDeclaration(string name, ICSharpExpression expression);
    [PureAttribute]
public abstract virtual Pair`2<IStartRegion, IEndRegion> CreateRegionDirective(string name);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionInitializer CreateExpressionInitializer(ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IObjectInitializer CreateObjectInitializer();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPropertyInitializer CreateObjectPropertyInitializer(string propertyName, ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICollectionInitializer CreateCollectionInitializer();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICollectionElementInitializer CreateCollectionElementInitializer(ICSharpExpression[] expressions);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionElement CreateCollectionExpressionElement(ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISpreadElement CreateCollectionExpressionSpread(ICSharpExpression collectionExpression);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IQueryClause CreateQueryClause(string clause, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IQueryRangeVariableDeclaration CreateRangeVariableDeclaration(string name, IType type);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IQueryParameterPlatform CreateQueryPlatform(ICSharpExpression e);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPropertyDeclaration CreatePropertyDeclaration(IType type, string name);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IIndexerDeclaration CreateIndexerDeclaration(IType type);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IFieldDeclaration CreateFieldDeclaration(IType type, string name);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAnonymousMemberDeclaration CreateAnonymousMemberDeclaration(ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ILocalRegularParameterDeclaration CreateLocalRegularParameterDeclaration(IType parameterType, string name, ParameterKind kind, bool isParams, ICSharpExpression defaultValue);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ILocalArglistParameterDeclaration CreateLocalArglistParameterDeclaration();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDelegateDeclaration CreateDelegateDeclaration();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumMemberDeclaration CreateEnumMemberDeclaration(string enumMemberName);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEventDeclaration CreateEventDeclaration(IDeclaredType eventType, string name);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IConstantDeclaration CreateConstDeclaration(IDeclaredType type, string name, string value);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITupleTypeComponent CreateTupleTypeComponent(IType type, string name);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISwitchSection CreateEmptySwitchSection();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISwitchCaseLabel CreateSwitchCaseLabel(string caseTemplate, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISwitchExpressionArm CreateSwitchExpressionArm(string armTemplate, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITupleComponent CreateTupleComponent(ICSharpExpression arg);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITupleComponent CreateTupleComponent(string name, ICSharpExpression arg);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IVariableDesignation CreateVariableDesignation(string template, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDiscardDesignation CreateDiscardDesignation();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPattern CreatePattern(string template, Object[] args);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDiscardPattern CreateDiscardPattern();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISwitchExpression CreateEmptySwitchExpression();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual INullableDirective CreateNullableDirective(NullableDirectiveSettingKind settingKind, Nullable`1<NullableDirectiveTargetKind> targetKind);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPreprocessorDirective CreatePreprocessorDirectiveAsIs(string directive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.CSharpElementFactoryExtensions : object {
    [ExtensionAttribute]
public static IUsingDirective CreateUsingStaticDirective(CSharpElementFactory factory, DeclaredElementInstance`1<ITypeElement> importTarget, string externAlias);
    [ExtensionAttribute]
public static IUsingDirective CreateUsingDirective(CSharpElementFactory factory, INamespace nameSpace, string externAlias);
    [ExtensionAttribute]
public static IUsingAliasDirective CreateUsingAliasDirective(CSharpElementFactory factory, string aliasName, AliasedSymbol aliasedSymbol, ITreeNode context, string externAlias);
    [ExtensionAttribute]
public static IReferenceExpression CreateQualifiedReference(CSharpElementFactory factory, DeclaredElementInstance memberInstance, int qualifierDepth);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.CSharpExtensionMethods : object {
    private static Key`1<ILanguageLevelProvider`2<CSharpLanguageLevel, CSharpLanguageVersion>> ourLanguageLevelProviderKey;
    private static Key`1<INullableContextProvider> ourNullableContextProviderKey;
    [NotNullAttribute]
private static Key`1<EditorConfigIsGeneratedCodeProperty> ourIsGeneratedCodeFileProperty;
    private static CSharpExtensionMethods();
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp3Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp4Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp5Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp6Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp7Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp71Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp72Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp73Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp8Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp9Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp10Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp11Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp12Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp13Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharpExperimentalSupported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInPreview(CSharpLanguageLevel languageLevel, ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpLanguageLevel GetCSharpLanguageLevel(ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpLanguageLevel GetLatestSupportedCSharpLanguageLevel(ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpLanguageLevel GetLatestSupportedCSharpLanguageLevel(ITreeNode treeNode, Boolean& isPreview);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSupportedAndNotInPreview(CSharpLanguageLevel languageLevel, ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableAnnotationsContextEnabled(ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableWarningsContextEnabled(ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNullableAnnotationsContextEnabledAt(ICSharpFile file, TreeOffset& offset);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNullableWarningsContextEnabledAt(ICSharpFile file, TreeOffset& offset);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableWarningsEnabledAnywhereIn(ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableAnnotationsEnabledAnywhereIn(ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableAnnotationsOrWarningsEnabledAnywhereIn(ITreeNode treeNode);
    [ExtensionAttribute]
public static bool IsNullableWarningsEnabledAnywhereIn(ICSharpFile file, TreeTextRange& range);
    [ExtensionAttribute]
public static bool IsNullableAnnotationsEnabledAnywhereIn(ICSharpFile file, TreeTextRange& range);
    [ExtensionAttribute]
public static bool IsNullableAnnotationsOrWarningsEnabledAnywhereIn(ICSharpFile file, TreeTextRange& range);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableWarningsEnabledEverywhereIn(ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNullableWarningsEnabledEverywhereIn(ICSharpFile file, TreeTextRange& range);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableAnnotationsEnabledEverywhereIn(ITreeNode treeNode);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNullableAnnotationsEnabledEverywhereIn(ICSharpFile file, TreeTextRange& range);
    [ExtensionAttribute]
[PureAttribute]
public static NullableContextInfo GetMergedNullableContextIn(ICSharpFile file, TreeTextRange& range);
    [PureAttribute]
private static bool IsNullableContextEnabled(ITreeNode treeNode, bool isNullableAnnotationsContext);
    [PureAttribute]
private static bool IsNullableContextEnabled(Nullable`1<NullableContext> nullableContext, ITreeNode treeNode, ICSharpFile containingFile, bool isNullableAnnotationsContext);
    [PureAttribute]
private static bool IsNullableContextEnabledAt(ICSharpFile file, TreeOffset& offset, bool isNullableAnnotationsContext);
    [PureAttribute]
private static Nullable`1<NullableContext> TryGetNullableContextAt(ICSharpFile file, TreeOffset& offset, bool isNullableAnnotationsContext);
    [PureAttribute]
private static Nullable`1<NullableContext> TryGetNullableContext(ITreeNode treeNode, bool isNullableAnnotationsContext, ICSharpFile& containingFile);
    [PureAttribute]
private static Nullable`1<NullableContext> TryGetNullableContextByNullableDirective(ITreeNode treeNode, bool isNullableAnnotationsContext);
    [PureAttribute]
private static Nullable`1<NullableContext> ConvertNullableDirectiveToNullableContext(INullableDirective nullableDirective, bool isNullableAnnotationsContext);
    [ExtensionAttribute]
[PureAttribute]
public static NullableContextInfo GetModuleNullableContext(ICSharpFile file);
    [PureAttribute]
private static bool IsNullableContextEnabledInPsiModule(ITreeNode element, bool isNullableAnnotationsContext);
    [PureAttribute]
public static CSharpLanguageLevel GetCSharpLanguageLevel(IPsiModule module);
    private static ILanguageLevelProvider`2<CSharpLanguageLevel, CSharpLanguageVersion> GetCSharpLanguageLevelProvider(IPsiModule module);
    [PureAttribute]
private static ValueTuple`2<CSharpLanguageLevel, bool> GetLatestSupportedCSharpLanguageLevel(IPsiModule module);
    [PureAttribute]
private static ValueTuple`2<bool, bool> GetNullableContextInPsiModule(IPsiModule module);
    private static INullableContextProvider GetNullableContextProvider(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsGeneratedFileForCompiler(ICSharpFile file);
    [ExtensionAttribute]
public static bool HasAutoGeneratedComment(ICSharpFile file);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDefaultInterfaceImplementationSupported(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnmanagedCallingConventionSupported(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsStaticAbstractsInInterfacesSupported(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCovariantReturnsOfClassesSupported(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool ArePreviewFeaturesEnabled(ITreeNode treeNode);
    [PureAttribute]
public static bool ArePreviewFeaturesEnabled(IPsiModule psiModule);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpTypeConstraintsVerifier GetTypeConstraintsVerifier(IPsiModule psiModule);
    [ExtensionAttribute]
[PureAttribute]
public static TypePresentationOptions GetTypePresentationOptions(ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCheckedContext(ITreeNode treeNode, Nullable`1<bool> defaultValue);
    [CompilerGeneratedAttribute]
internal static bool <IsCheckedContext>g__ProjectConfigurationCheckForOverflowUnderflow|62_0(ITreeNode treeNode1);
}
public static class JetBrains.ReSharper.Psi.CSharp.CSharpFeatures : object {
    public static string ImplicitArray;
    public static string AnonymousTypes;
    public static string ObjectInitializer;
    public static string CollectionInitializer;
    public static string Lambda;
    public static string QueryExpression;
    public static string ExtensionMethod;
    public static string PartialMethod;
    public static string ImplicitLocal;
    public static string AutoImplementedProperties;
    public static string Dynamic;
    public static string TypeVariance;
    public static string NamedArgument;
    public static string OptionalParameter;
    public static string Async;
    public static string AwaitExpresssion;
    public static string ExceptionFilter;
    public static string AutoPropertyInitializer;
    public static string NullPropagatingOperator;
    public static string ExpressionBodiedMethod;
    public static string ExpressionBodiedProperty;
    public static string ExpressionBodiedIndexer;
    public static string Nameof;
    public static string DictionaryInitializer;
    public static string UsingStatic;
    public static string InterpolatedStrings;
    public static string AwaitInCatchAndFinally;
    public static string ReadonlyAutoImplementedProperties;
    public static string BinaryLiteral;
    public static string DigitSeparator;
    public static string LocalFunctions;
    public static string RefLocalsReturns;
    public static string RefExpression;
    public static string PatternMatching;
    public static string ThrowExpression;
    public static string Tuples;
    public static string OutVar;
    public static string ExpressionBodiedAccessor;
    public static string ExpressionBodiedDeOrConstructor;
    public static string Discards;
    public static string AsyncMain;
    public static string DefaultLiteral;
    public static string InferredTupleNames;
    public static string GenericPatternMatching;
    public static string NonTrailingNamedArguments;
    public static string LeadingDigitSeparator;
    public static string PrivateProtected;
    public static string ReadOnlyReferences;
    public static string RefStructs;
    public static string ReadOnlyStructs;
    public static string RefExtensionMethods;
    public static string RefConditional;
    public static string AttributesOnBackingFields;
    public static string ImprovedOverloadCandidates;
    public static string TupleEquality;
    public static string RefReassignment;
    public static string RefFor;
    public static string RefForEach;
    public static string EnumGenericTypeConstraint;
    public static string DelegateGenericTypeConstraint;
    public static string UnmanagedGenericTypeConstraint;
    public static string StackAllocInitializer;
    public static string ExpressionVariablesInQueriesAndInitializers;
    public static string ExtensibleFixedStatement;
    public static string IndexingMovableFixedBuffers;
    public static string AltInterpolatedVerbatimStrings;
    public static string CoalesceAssignmentExpression;
    public static string UnconstrainedTypeParameterInNullCoalescingOperator;
    public static string NullableReferenceTypes;
    public static string IndexFromEndOperator;
    public static string RangeOperator;
    public static string AsyncStreams;
    public static string RecursivePatterns;
    public static string UsingDeclarations;
    public static string AwaitUsingDeclarations;
    public static string StaticLocalFunctions;
    public static string NameShadowingInNestedFunctions;
    public static string UnmanagedConstructedTypes;
    public static string ObsoleteOnPropertyAccessor;
    public static string ReadOnlyMembers;
    public static string DefaultInterfaceImplementation;
    public static string OverrideWithConstraints;
    public static string NestedStackalloc;
    public static string SwitchExpression;
    public static string AsyncUsing;
    public static string NotNullGenericTypeConstraint;
    public static string NullPointerConstantPattern;
    public static string LambdaDiscardParameters;
    public static string FunctionPointers;
    public static string LocalFunctionAttributes;
    public static string ExternLocalFunctions;
    public static string TargetTypedObjectCreation;
    public static string MemberNotNull;
    public static string OrPattern;
    public static string AndPattern;
    public static string NotPattern;
    public static string RelationalPattern;
    public static string ParenthesizedPattern;
    public static string TypePattern;
    public static string ExtensionGetEnumerator;
    public static string ExtensionGetAsyncEnumerator;
    public static string NativeInt;
    public static string ExtendedPartialMethods;
    public static string TopLevelStatements;
    public static string InitOnlySetters;
    public static string Records;
    public static string WithExpression;
    public static string TargetTypedConditional;
    public static string CovariantReturnsForOverrides;
    public static string StaticAnonymousFunction;
    public static string ModuleInitializers;
    public static string DefaultTypeParameterConstraint;
    public static string VarianceSafetyForStaticInterfaceMembers;
    public static string MixedDeclarationsAndExpressionsInDeconstruction;
    public static string SealedToStringInRecord;
    public static string ImprovedInterpolatedStrings;
    public static string RecordStructs;
    public static string WithOnStructs;
    public static string WithOnAnonymousTypes;
    public static string PositionalFieldsInRecords;
    public static string GlobalUsing;
    public static string InferredDelegateType;
    public static string LambdaAttributes;
    public static string ExtendedPropertyPatterns;
    public static string LambdaReturnType;
    public static string AsyncMethodBuilderOverride;
    public static string ConstantInterpolatedStrings;
    public static string ImplicitImplementationOfNonPublicMembers;
    public static string LineSpanDirective;
    public static string FileScopedNamespace;
    public static string ParameterlessStructConstructors;
    public static string StructFieldInitializers;
    public static string StaticAbstractMembersInInterfaces;
    public static string GenericAttributes;
    public static string NewLinesInInterpolations;
    public static string ListPattern;
    public static string ParameterNullChecking;
    public static string CheckedOperators;
    public static string UnsignedRightShift;
    public static string RequiredMembers;
    public static string CacheStaticMethodGroupConversion;
    public static string RefFields;
    public static string RawStringLiterals;
    public static string UTF8StringLiterals;
    public static string FileLocalTypes;
    public static string PrimaryConstructors;
    public static string FeatureLambdaOptionalParameters;
    public static string FeatureLambdaParamsArray;
    public static string UsingTypeAlias;
    public static string InlineArrays;
    public static string RefReadonlyParameters;
    public static string CollectionExpressions;
    public static string RefStructInterfaces;
    public static string RefUnsafeInIteratorAsync;
    public static string LockObject;
    public static string OverloadResolutionPriority;
}
[LanguageDefinitionAttribute("CSHARP")]
public class JetBrains.ReSharper.Psi.CSharp.CSharpLanguage : KnownLanguage {
    public static string Name;
    [CompilerGeneratedAttribute]
private static CSharpLanguage <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Synonyms>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static CSharpLanguage Instance { get; private set; }
    public PsiLanguageCategories SupportedCategories { get; }
    public String[] Synonyms { get; }
    protected CSharpLanguage(string name);
    protected CSharpLanguage(string name, string presentableName);
    [CompilerGeneratedAttribute]
public static CSharpLanguage get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(CSharpLanguage value);
    public virtual PsiLanguageCategories get_SupportedCategories();
    [CompilerGeneratedAttribute]
public virtual String[] get_Synonyms();
}
public enum JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevel : Enum {
    public int value__;
    public static CSharpLanguageLevel CSharp20;
    public static CSharpLanguageLevel CSharp30;
    public static CSharpLanguageLevel CSharp40;
    public static CSharpLanguageLevel CSharp50;
    public static CSharpLanguageLevel CSharp60;
    public static CSharpLanguageLevel CSharp70;
    public static CSharpLanguageLevel CSharp71;
    public static CSharpLanguageLevel CSharp72;
    public static CSharpLanguageLevel CSharp73;
    public static CSharpLanguageLevel CSharp80;
    public static CSharpLanguageLevel CSharp90;
    public static CSharpLanguageLevel CSharp100;
    public static CSharpLanguageLevel CSharp110;
    public static CSharpLanguageLevel CSharp120;
    public static CSharpLanguageLevel CSharp130;
    public static CSharpLanguageLevel Latest;
    public static CSharpLanguageLevel Experimental;
}
public class JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevelComparer : object {
    [NotNullAttribute]
public static CSharpLanguageLevelComparer Instance;
    private static CSharpLanguageLevelComparer();
    public sealed virtual int Compare(CSharpLanguageLevel x, CSharpLanguageLevel y);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.CSharpLanguageLevelUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string ToDisplayValue(CSharpLanguageLevel languageLevel);
    [PureAttribute]
public static CSharpLanguageLevel FromDisplayValue(string displayValue, Nullable`1<CSharpLanguageLevel> unknownLevel);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpLanguageVersion ToLanguageVersion(CSharpLanguageLevel languageLevel);
}
public class JetBrains.ReSharper.Psi.CSharp.CSharpNodeTypeIndexer : AbstractNodeTypeIndexer {
    [NullableAttribute("1")]
public static CSharpNodeTypeIndexer Instance;
    private static CSharpNodeTypeIndexer();
}
public class JetBrains.ReSharper.Psi.CSharp.CSharpParameterInstance : DeclaredElementInstance`1<IParameter> {
    [CompilerGeneratedAttribute]
private ExpandedKind <Expanded>k__BackingField;
    public ExpandedKind Expanded { get; }
    [NotNullAttribute]
public IType Type { get; }
    public CSharpParameterInstance(IParameter parameter, ISubstitution substitution, ExpandedKind expanded);
    [CompilerGeneratedAttribute]
public ExpandedKind get_Expanded();
    public IType get_Type();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.CSharpPragmaControlConstruct : object {
    public static string PragmaWarning;
    public static string PragmaDisable;
    public static string PragmaRestore;
    public static string RedundantUsingDirective;
    public static string RedundantNameQualifier;
    [PureAttribute]
public static ControlConstructInfo ParsePragmaMessage(string pragmaText);
    private static bool SkipWhitespace(string text, Int32& index);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyCollection`1<string> GetCompilerIds(ControlConstructInfo info);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.CSharpPredefined : object {
    public static string BINARY_ANDALSO;
    public static string BINARY_ORELSE;
    private static Dictionary`2<TokenNodeType, string> myUnaryOperatorNames;
    private static Dictionary`2<TokenNodeType, string> myBinaryOperatorNames;
    private static Dictionary`2<TokenNodeType, string> myCheckedUnaryOperatorNames;
    private static Dictionary`2<TokenNodeType, string> myCheckedBinaryOperatorNames;
    public ISignOperator UnaryPlusInt { get; }
    public ISignOperator UnaryPlusUint { get; }
    public ISignOperator UnaryPlusLong { get; }
    public ISignOperator UnaryPlusUlong { get; }
    public ISignOperator UnaryPlusFloat { get; }
    public ISignOperator UnaryPlusDouble { get; }
    public ISignOperator UnaryPlusDecimal { get; }
    public ISignOperator UnaryMinusInt { get; }
    public ISignOperator UnaryMinusLong { get; }
    public ISignOperator UnaryMinusFloat { get; }
    public ISignOperator UnaryMinusDouble { get; }
    public ISignOperator UnaryMinusDecimal { get; }
    public ISignOperator UnaryLogicalNegation { get; }
    public ISignOperator UnaryBitwiseComplementInt { get; }
    public ISignOperator UnaryBitwiseComplementUint { get; }
    public ISignOperator UnaryBitwiseComplementLong { get; }
    public ISignOperator UnaryBitwiseComplementUlong { get; }
    public ISignOperator UnaryIncrementSbyte { get; }
    public ISignOperator UnaryIncrementByte { get; }
    public ISignOperator UnaryIncrementShort { get; }
    public ISignOperator UnaryIncrementUshort { get; }
    public ISignOperator UnaryIncrementInt { get; }
    public ISignOperator UnaryIncrementUint { get; }
    public ISignOperator UnaryIncrementLong { get; }
    public ISignOperator UnaryIncrementUlong { get; }
    public ISignOperator UnaryIncrementChar { get; }
    public ISignOperator UnaryIncrementFloat { get; }
    public ISignOperator UnaryIncrementDouble { get; }
    public ISignOperator UnaryIncrementDecimal { get; }
    public ISignOperator UnaryDecrementSbyte { get; }
    public ISignOperator UnaryDecrementByte { get; }
    public ISignOperator UnaryDecrementShort { get; }
    public ISignOperator UnaryDecrementUshort { get; }
    public ISignOperator UnaryDecrementInt { get; }
    public ISignOperator UnaryDecrementUint { get; }
    public ISignOperator UnaryDecrementLong { get; }
    public ISignOperator UnaryDecrementUlong { get; }
    public ISignOperator UnaryDecrementChar { get; }
    public ISignOperator UnaryDecrementFloat { get; }
    public ISignOperator UnaryDecrementDouble { get; }
    public ISignOperator UnaryDecrementDecimal { get; }
    public ISignOperator BinaryMultiplicationInt { get; }
    public ISignOperator BinaryMultiplicationUint { get; }
    public ISignOperator BinaryMultiplicationLong { get; }
    public ISignOperator BinaryMultiplicationUlong { get; }
    public ISignOperator BinaryMultiplicationFloat { get; }
    public ISignOperator BinaryMultiplicationDouble { get; }
    public ISignOperator BinaryMultiplicationDecimal { get; }
    public ISignOperator BinaryDivisionInt { get; }
    public ISignOperator BinaryDivisionUint { get; }
    public ISignOperator BinaryDivisionLong { get; }
    public ISignOperator BinaryDivisionUlong { get; }
    public ISignOperator BinaryDivisionFloat { get; }
    public ISignOperator BinaryDivisionDouble { get; }
    public ISignOperator BinaryDivisionDecimal { get; }
    public ISignOperator BinaryRemainderInt { get; }
    public ISignOperator BinaryRemainderUint { get; }
    public ISignOperator BinaryRemainderLong { get; }
    public ISignOperator BinaryRemainderUlong { get; }
    public ISignOperator BinaryRemainderFloat { get; }
    public ISignOperator BinaryRemainderDouble { get; }
    public ISignOperator BinaryRemainderDecimal { get; }
    public ISignOperator BinaryPlusInt { get; }
    public ISignOperator BinaryPlusUint { get; }
    public ISignOperator BinaryPlusLong { get; }
    public ISignOperator BinaryPlusUlong { get; }
    public ISignOperator BinaryPlusFloat { get; }
    public ISignOperator BinaryPlusDouble { get; }
    public ISignOperator BinaryPlusDecimal { get; }
    public ISignOperator BinaryPlusStringString { get; }
    public ISignOperator BinaryPlusStringObject { get; }
    public ISignOperator BinaryPlusObjectString { get; }
    public ISignOperator BinaryMinusInt { get; }
    public ISignOperator BinaryMinusUint { get; }
    public ISignOperator BinaryMinusLong { get; }
    public ISignOperator BinaryMinusUlong { get; }
    public ISignOperator BinaryMinusFloat { get; }
    public ISignOperator BinaryMinusDouble { get; }
    public ISignOperator BinaryMinusDecimal { get; }
    public ISignOperator BinaryLeftShiftInt { get; }
    public ISignOperator BinaryLeftShiftUint { get; }
    public ISignOperator BinaryLeftShiftLong { get; }
    public ISignOperator BinaryLeftShiftUlong { get; }
    public ISignOperator BinaryLeftShiftNativeInteger { get; }
    public ISignOperator BinaryLeftShiftNativeUnsignedInteger { get; }
    public ISignOperator BinaryRightShiftInt { get; }
    public ISignOperator BinaryRightShiftUint { get; }
    public ISignOperator BinaryRightShiftLong { get; }
    public ISignOperator BinaryRightShiftUlong { get; }
    public ISignOperator BinaryRightShiftNativeInteger { get; }
    public ISignOperator BinaryRightShiftNativeUnsignedInteger { get; }
    public ISignOperator BinaryUnsignedRightShiftInt { get; }
    public ISignOperator BinaryUnsignedRightShiftUint { get; }
    public ISignOperator BinaryUnsignedRightShiftLong { get; }
    public ISignOperator BinaryUnsignedRightShiftUlong { get; }
    public ISignOperator BinaryUnsignedRightShiftNativeInteger { get; }
    public ISignOperator BinaryUnsignedRightShiftNativeUnsignedInteger { get; }
    public ISignOperator BinaryEqualityInt { get; }
    public ISignOperator BinaryEqualityUint { get; }
    public ISignOperator BinaryEqualityLong { get; }
    public ISignOperator BinaryEqualityUlong { get; }
    public ISignOperator BinaryEqualityFloat { get; }
    public ISignOperator BinaryEqualityDouble { get; }
    public ISignOperator BinaryEqualityDecimal { get; }
    public ISignOperator BinaryEqualityBool { get; }
    public ISignOperator BinaryEqualityReference { get; }
    public ISignOperator BinaryEqualityNullable { get; }
    public ISignOperator BinaryEqualityDelegate { get; }
    public ISignOperator BinaryEqualityString { get; }
    public ISignOperator BinaryInequalityInt { get; }
    public ISignOperator BinaryInequalityUint { get; }
    public ISignOperator BinaryInequalityLong { get; }
    public ISignOperator BinaryInequalityUlong { get; }
    public ISignOperator BinaryInequalityFloat { get; }
    public ISignOperator BinaryInequalityDouble { get; }
    public ISignOperator BinaryInequalityDecimal { get; }
    public ISignOperator BinaryInequalityBool { get; }
    public ISignOperator BinaryInequalityReference { get; }
    public ISignOperator BinaryInequalityNullable { get; }
    public ISignOperator BinaryInequalityDelegate { get; }
    public ISignOperator BinaryInequalityString { get; }
    public ISignOperator BinaryLessInt { get; }
    public ISignOperator BinaryLessUint { get; }
    public ISignOperator BinaryLessLong { get; }
    public ISignOperator BinaryLessUlong { get; }
    public ISignOperator BinaryLessFloat { get; }
    public ISignOperator BinaryLessDouble { get; }
    public ISignOperator BinaryLessDecimal { get; }
    public ISignOperator BinaryGreaterInt { get; }
    public ISignOperator BinaryGreaterUint { get; }
    public ISignOperator BinaryGreaterLong { get; }
    public ISignOperator BinaryGreaterUlong { get; }
    public ISignOperator BinaryGreaterFloat { get; }
    public ISignOperator BinaryGreaterDouble { get; }
    public ISignOperator BinaryGreaterDecimal { get; }
    public ISignOperator BinaryLessEqualityInt { get; }
    public ISignOperator BinaryLessEqualityUint { get; }
    public ISignOperator BinaryLessEqualityLong { get; }
    public ISignOperator BinaryLessEqualityUlong { get; }
    public ISignOperator BinaryLessEqualityFloat { get; }
    public ISignOperator BinaryLessEqualityDouble { get; }
    public ISignOperator BinaryLessEqualityDecimal { get; }
    public ISignOperator BinaryGreaterEqualityInt { get; }
    public ISignOperator BinaryGreaterEqualityUint { get; }
    public ISignOperator BinaryGreaterEqualityLong { get; }
    public ISignOperator BinaryGreaterEqualityUlong { get; }
    public ISignOperator BinaryGreaterEqualityFloat { get; }
    public ISignOperator BinaryGreaterEqualityDouble { get; }
    public ISignOperator BinaryGreaterEqualityDecimal { get; }
    public ISignOperator BinaryLogicalAndInt { get; }
    public ISignOperator BinaryLogicalAndUint { get; }
    public ISignOperator BinaryLogicalAndLong { get; }
    public ISignOperator BinaryLogicalAndUlong { get; }
    public ISignOperator BinaryLogicalAndBool { get; }
    public ISignOperator BinaryLogicalOrInt { get; }
    public ISignOperator BinaryLogicalOrUint { get; }
    public ISignOperator BinaryLogicalOrLong { get; }
    public ISignOperator BinaryLogicalOrUlong { get; }
    public ISignOperator BinaryLogicalOrBool { get; }
    public ISignOperator BinaryConditionalLogicalAndAlsoBool { get; }
    public ISignOperator BinaryConditionalLogicalOrElseBool { get; }
    public ISignOperator BinaryLogicalXorInt { get; }
    public ISignOperator BinaryLogicalXorUint { get; }
    public ISignOperator BinaryLogicalXorLong { get; }
    public ISignOperator BinaryLogicalXorUlong { get; }
    public ISignOperator BinaryLogicalXorBool { get; }
    private static CSharpPredefined();
    [NotNullAttribute]
public static CSharpPredefined GetInstance(ITreeNode context);
    [NotNullAttribute]
public static CSharpPredefined GetInstance(IPsiModule module);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IProperty[] GetArrayIndexers(IArrayType type, IResolveContext resolveContext, IList`1<ICSharpArgumentInfo> arguments, CSharpLanguageLevel languageLevel);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IProperty GetPointerIndexer(IPointerType type, IResolveContext resolveContext, ICSharpArgumentInfo argument);
    public abstract virtual ISignOperator[] GetBinaryOperators();
    public abstract virtual ISignOperator[] GetUnaryOperators();
    public abstract virtual ISignOperator[] GetBinaryOperatorsByName(string operatorName);
    public abstract virtual ISignOperator[] GetUnaryOperatorsByName(string operatorName);
    public abstract virtual ISignOperator GetBinaryOperator(string name, IType leftType, IType rightType);
    public abstract virtual ISignOperator GetUnaryOperator(string name, IType type);
    public abstract virtual ISignOperator[] GetPointerOperators(IPointerType pointerType);
    public abstract virtual ISignOperator[] GetDelegateOperators(IDelegate delegate, ISubstitution substitution);
    public abstract virtual ISignOperator[] GetEnumOperators(IEnum enum, ISubstitution substitution);
    public abstract virtual bool IsOperatorMeaningfulForUser(ISignOperator signOperator);
    internal abstract virtual bool IsBinaryOperatorName(string name);
    internal abstract virtual bool IsUnaryOperatorName(string name);
    public abstract virtual ISignOperator get_UnaryPlusInt();
    public abstract virtual ISignOperator get_UnaryPlusUint();
    public abstract virtual ISignOperator get_UnaryPlusLong();
    public abstract virtual ISignOperator get_UnaryPlusUlong();
    public abstract virtual ISignOperator get_UnaryPlusFloat();
    public abstract virtual ISignOperator get_UnaryPlusDouble();
    public abstract virtual ISignOperator get_UnaryPlusDecimal();
    public abstract virtual ISignOperator get_UnaryMinusInt();
    public abstract virtual ISignOperator get_UnaryMinusLong();
    public abstract virtual ISignOperator get_UnaryMinusFloat();
    public abstract virtual ISignOperator get_UnaryMinusDouble();
    public abstract virtual ISignOperator get_UnaryMinusDecimal();
    public abstract virtual ISignOperator get_UnaryLogicalNegation();
    public abstract virtual ISignOperator get_UnaryBitwiseComplementInt();
    public abstract virtual ISignOperator get_UnaryBitwiseComplementUint();
    public abstract virtual ISignOperator get_UnaryBitwiseComplementLong();
    public abstract virtual ISignOperator get_UnaryBitwiseComplementUlong();
    public abstract virtual ISignOperator get_UnaryIncrementSbyte();
    public abstract virtual ISignOperator get_UnaryIncrementByte();
    public abstract virtual ISignOperator get_UnaryIncrementShort();
    public abstract virtual ISignOperator get_UnaryIncrementUshort();
    public abstract virtual ISignOperator get_UnaryIncrementInt();
    public abstract virtual ISignOperator get_UnaryIncrementUint();
    public abstract virtual ISignOperator get_UnaryIncrementLong();
    public abstract virtual ISignOperator get_UnaryIncrementUlong();
    public abstract virtual ISignOperator get_UnaryIncrementChar();
    public abstract virtual ISignOperator get_UnaryIncrementFloat();
    public abstract virtual ISignOperator get_UnaryIncrementDouble();
    public abstract virtual ISignOperator get_UnaryIncrementDecimal();
    public abstract virtual ISignOperator get_UnaryDecrementSbyte();
    public abstract virtual ISignOperator get_UnaryDecrementByte();
    public abstract virtual ISignOperator get_UnaryDecrementShort();
    public abstract virtual ISignOperator get_UnaryDecrementUshort();
    public abstract virtual ISignOperator get_UnaryDecrementInt();
    public abstract virtual ISignOperator get_UnaryDecrementUint();
    public abstract virtual ISignOperator get_UnaryDecrementLong();
    public abstract virtual ISignOperator get_UnaryDecrementUlong();
    public abstract virtual ISignOperator get_UnaryDecrementChar();
    public abstract virtual ISignOperator get_UnaryDecrementFloat();
    public abstract virtual ISignOperator get_UnaryDecrementDouble();
    public abstract virtual ISignOperator get_UnaryDecrementDecimal();
    public abstract virtual ISignOperator get_BinaryMultiplicationInt();
    public abstract virtual ISignOperator get_BinaryMultiplicationUint();
    public abstract virtual ISignOperator get_BinaryMultiplicationLong();
    public abstract virtual ISignOperator get_BinaryMultiplicationUlong();
    public abstract virtual ISignOperator get_BinaryMultiplicationFloat();
    public abstract virtual ISignOperator get_BinaryMultiplicationDouble();
    public abstract virtual ISignOperator get_BinaryMultiplicationDecimal();
    public abstract virtual ISignOperator get_BinaryDivisionInt();
    public abstract virtual ISignOperator get_BinaryDivisionUint();
    public abstract virtual ISignOperator get_BinaryDivisionLong();
    public abstract virtual ISignOperator get_BinaryDivisionUlong();
    public abstract virtual ISignOperator get_BinaryDivisionFloat();
    public abstract virtual ISignOperator get_BinaryDivisionDouble();
    public abstract virtual ISignOperator get_BinaryDivisionDecimal();
    public abstract virtual ISignOperator get_BinaryRemainderInt();
    public abstract virtual ISignOperator get_BinaryRemainderUint();
    public abstract virtual ISignOperator get_BinaryRemainderLong();
    public abstract virtual ISignOperator get_BinaryRemainderUlong();
    public abstract virtual ISignOperator get_BinaryRemainderFloat();
    public abstract virtual ISignOperator get_BinaryRemainderDouble();
    public abstract virtual ISignOperator get_BinaryRemainderDecimal();
    public abstract virtual ISignOperator get_BinaryPlusInt();
    public abstract virtual ISignOperator get_BinaryPlusUint();
    public abstract virtual ISignOperator get_BinaryPlusLong();
    public abstract virtual ISignOperator get_BinaryPlusUlong();
    public abstract virtual ISignOperator get_BinaryPlusFloat();
    public abstract virtual ISignOperator get_BinaryPlusDouble();
    public abstract virtual ISignOperator get_BinaryPlusDecimal();
    public abstract virtual ISignOperator get_BinaryPlusStringString();
    public abstract virtual ISignOperator get_BinaryPlusStringObject();
    public abstract virtual ISignOperator get_BinaryPlusObjectString();
    public abstract virtual ISignOperator get_BinaryMinusInt();
    public abstract virtual ISignOperator get_BinaryMinusUint();
    public abstract virtual ISignOperator get_BinaryMinusLong();
    public abstract virtual ISignOperator get_BinaryMinusUlong();
    public abstract virtual ISignOperator get_BinaryMinusFloat();
    public abstract virtual ISignOperator get_BinaryMinusDouble();
    public abstract virtual ISignOperator get_BinaryMinusDecimal();
    public abstract virtual ISignOperator get_BinaryLeftShiftInt();
    public abstract virtual ISignOperator get_BinaryLeftShiftUint();
    public abstract virtual ISignOperator get_BinaryLeftShiftLong();
    public abstract virtual ISignOperator get_BinaryLeftShiftUlong();
    public abstract virtual ISignOperator get_BinaryLeftShiftNativeInteger();
    public abstract virtual ISignOperator get_BinaryLeftShiftNativeUnsignedInteger();
    public abstract virtual ISignOperator get_BinaryRightShiftInt();
    public abstract virtual ISignOperator get_BinaryRightShiftUint();
    public abstract virtual ISignOperator get_BinaryRightShiftLong();
    public abstract virtual ISignOperator get_BinaryRightShiftUlong();
    public abstract virtual ISignOperator get_BinaryRightShiftNativeInteger();
    public abstract virtual ISignOperator get_BinaryRightShiftNativeUnsignedInteger();
    public abstract virtual ISignOperator get_BinaryUnsignedRightShiftInt();
    public abstract virtual ISignOperator get_BinaryUnsignedRightShiftUint();
    public abstract virtual ISignOperator get_BinaryUnsignedRightShiftLong();
    public abstract virtual ISignOperator get_BinaryUnsignedRightShiftUlong();
    public abstract virtual ISignOperator get_BinaryUnsignedRightShiftNativeInteger();
    public abstract virtual ISignOperator get_BinaryUnsignedRightShiftNativeUnsignedInteger();
    public abstract virtual ISignOperator get_BinaryEqualityInt();
    public abstract virtual ISignOperator get_BinaryEqualityUint();
    public abstract virtual ISignOperator get_BinaryEqualityLong();
    public abstract virtual ISignOperator get_BinaryEqualityUlong();
    public abstract virtual ISignOperator get_BinaryEqualityFloat();
    public abstract virtual ISignOperator get_BinaryEqualityDouble();
    public abstract virtual ISignOperator get_BinaryEqualityDecimal();
    public abstract virtual ISignOperator get_BinaryEqualityBool();
    public abstract virtual ISignOperator get_BinaryEqualityReference();
    public abstract virtual ISignOperator get_BinaryEqualityNullable();
    public abstract virtual ISignOperator get_BinaryEqualityDelegate();
    public abstract virtual ISignOperator get_BinaryEqualityString();
    public abstract virtual ISignOperator get_BinaryInequalityInt();
    public abstract virtual ISignOperator get_BinaryInequalityUint();
    public abstract virtual ISignOperator get_BinaryInequalityLong();
    public abstract virtual ISignOperator get_BinaryInequalityUlong();
    public abstract virtual ISignOperator get_BinaryInequalityFloat();
    public abstract virtual ISignOperator get_BinaryInequalityDouble();
    public abstract virtual ISignOperator get_BinaryInequalityDecimal();
    public abstract virtual ISignOperator get_BinaryInequalityBool();
    public abstract virtual ISignOperator get_BinaryInequalityReference();
    public abstract virtual ISignOperator get_BinaryInequalityNullable();
    public abstract virtual ISignOperator get_BinaryInequalityDelegate();
    public abstract virtual ISignOperator get_BinaryInequalityString();
    public abstract virtual ISignOperator get_BinaryLessInt();
    public abstract virtual ISignOperator get_BinaryLessUint();
    public abstract virtual ISignOperator get_BinaryLessLong();
    public abstract virtual ISignOperator get_BinaryLessUlong();
    public abstract virtual ISignOperator get_BinaryLessFloat();
    public abstract virtual ISignOperator get_BinaryLessDouble();
    public abstract virtual ISignOperator get_BinaryLessDecimal();
    public abstract virtual ISignOperator get_BinaryGreaterInt();
    public abstract virtual ISignOperator get_BinaryGreaterUint();
    public abstract virtual ISignOperator get_BinaryGreaterLong();
    public abstract virtual ISignOperator get_BinaryGreaterUlong();
    public abstract virtual ISignOperator get_BinaryGreaterFloat();
    public abstract virtual ISignOperator get_BinaryGreaterDouble();
    public abstract virtual ISignOperator get_BinaryGreaterDecimal();
    public abstract virtual ISignOperator get_BinaryLessEqualityInt();
    public abstract virtual ISignOperator get_BinaryLessEqualityUint();
    public abstract virtual ISignOperator get_BinaryLessEqualityLong();
    public abstract virtual ISignOperator get_BinaryLessEqualityUlong();
    public abstract virtual ISignOperator get_BinaryLessEqualityFloat();
    public abstract virtual ISignOperator get_BinaryLessEqualityDouble();
    public abstract virtual ISignOperator get_BinaryLessEqualityDecimal();
    public abstract virtual ISignOperator get_BinaryGreaterEqualityInt();
    public abstract virtual ISignOperator get_BinaryGreaterEqualityUint();
    public abstract virtual ISignOperator get_BinaryGreaterEqualityLong();
    public abstract virtual ISignOperator get_BinaryGreaterEqualityUlong();
    public abstract virtual ISignOperator get_BinaryGreaterEqualityFloat();
    public abstract virtual ISignOperator get_BinaryGreaterEqualityDouble();
    public abstract virtual ISignOperator get_BinaryGreaterEqualityDecimal();
    public abstract virtual ISignOperator get_BinaryLogicalAndInt();
    public abstract virtual ISignOperator get_BinaryLogicalAndUint();
    public abstract virtual ISignOperator get_BinaryLogicalAndLong();
    public abstract virtual ISignOperator get_BinaryLogicalAndUlong();
    public abstract virtual ISignOperator get_BinaryLogicalAndBool();
    public abstract virtual ISignOperator get_BinaryLogicalOrInt();
    public abstract virtual ISignOperator get_BinaryLogicalOrUint();
    public abstract virtual ISignOperator get_BinaryLogicalOrLong();
    public abstract virtual ISignOperator get_BinaryLogicalOrUlong();
    public abstract virtual ISignOperator get_BinaryLogicalOrBool();
    public abstract virtual ISignOperator get_BinaryConditionalLogicalAndAlsoBool();
    public abstract virtual ISignOperator get_BinaryConditionalLogicalOrElseBool();
    public abstract virtual ISignOperator get_BinaryLogicalXorInt();
    public abstract virtual ISignOperator get_BinaryLogicalXorUint();
    public abstract virtual ISignOperator get_BinaryLogicalXorLong();
    public abstract virtual ISignOperator get_BinaryLogicalXorUlong();
    public abstract virtual ISignOperator get_BinaryLogicalXorBool();
    public static string GetUnaryOperatorName(TokenNodeType tokenType, bool isChecked);
    public static string GetBinaryOperatorName(TokenNodeType tokenType, bool isChecked);
    [CanBeNullAttribute]
public static string GetUncheckedOperatorName(string checkedOperatorName);
    [CanBeNullAttribute]
public static string GetCheckedOperatorName(string uncheckedOperatorName);
}
public static class JetBrains.ReSharper.Psi.CSharp.CSharpPsiFileCachedDataKeys : object {
    [NotNullAttribute]
public static Key`1<Boxed`1<CSharpLanguageLevel>> LANGUAGE_LEVEL;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public static Key`1<Boxed`1<ValueTuple`2<CSharpLanguageLevel, bool>>> LATEST_SUPPORTED_LANGUAGE_LEVEL;
    [NotNullAttribute]
public static Key`1<Boxed`1<bool>> IS_GENERATED;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public static Key`1<Boxed`1<ValueTuple`2<bool, bool>>> NULLABLE_CONTEXT;
    [NotNullAttribute]
public static Key`1<Boxed`1<bool>> PREVIEW_FEATURES_ENABLED;
    private static CSharpPsiFileCachedDataKeys();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.CSharpPsiSourceFilePropertiesExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyCollection`1<string> ParseCSharpCompilerIdList(string value);
    [PureAttribute]
private static bool IsSeparator(char c);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.CSharpRefSafetyRulesVersionLanguageProvider : RefSafetyRulesVersionLanguageProvider {
    public virtual RefSafetyRulesVersion GetRefSafetyRulesVersion(ITreeNode context);
    public static RefSafetyRulesVersion GetCSharpRefSafetyRulesVersion(ICSharpTreeNode context);
}
public class JetBrains.ReSharper.Psi.CSharp.CSharpStatementsRange : object {
    [NotNullAttribute]
public static CSharpStatementsRange Empty;
    [CompilerGeneratedAttribute]
private ITreeRange <TreeRange>k__BackingField;
    public ITreeRange TreeRange { get; }
    public IList`1<IStatement> Statements { get; }
    public CSharpStatementsRange(ITreeRange treeRange);
    public CSharpStatementsRange(ICSharpStatement first, ICSharpStatement last);
    private static CSharpStatementsRange();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeRange get_TreeRange();
    public sealed virtual IList`1<IStatement> get_Statements();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.CSharpTypeArgumentValidationResult : TypeArgumentValidationResult {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.CSharpTypeArgumentValidationResultExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IReadOnlyList`1<TypeArgumentValidationResult> GetNullabilityViolations(TypeArgumentValidationResult validationResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.CSharpTypeConstraintsVerifier : ClrTypeConstraintsVerifier {
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <LanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpTypeConversionRule <TypeConversionRule>k__BackingField;
    public IPsiModule PsiModule { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public ICSharpTypeConversionRule TypeConversionRule { get; }
    public CSharpTypeConstraintsVerifier(IPsiModule psiModule);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpLanguageLevel get_LanguageLevel();
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpTypeConversionRule get_TypeConversionRule();
    public virtual TypeArgumentValidationResult ValidateTypeArgument(ITypeParameter typeParameter, ISubstitution constraintsSubstitution, IType typeArgument, bool isExplicitTypeArgument);
    [PureAttribute]
public sealed virtual TypeArgumentValidationResult ValidateTypeArgument(ITypeParameter typeParameter, ISubstitution constraintsSubstitution, IType typeArgument, bool isExplicitTypeArgument, bool checkNullability);
    [NullableContextAttribute("2")]
public virtual bool SatisfiesUnmanagedTypeConstraint(IDeclaredType typeArgument);
    [NullableContextAttribute("2")]
public virtual bool SatisfiesSuperTypeConstraint(IType typeArgument, IType superType);
    [NullableContextAttribute("2")]
private bool SatisfiesSuperTypeConstraint(IType typeArgument, IType superType, bool checkNullability);
    [PureAttribute]
private static bool SatisfiesSuperTypeConstraint(IType argumentType, IType superType, ICSharpTypeConversionRule typeConversionRule, HashSet`1<IType> visited);
    [PureAttribute]
private static bool SelfOrBaseHasNotImplementedStaticAbstractMembers(IInterface typeArgument, List`1<OverridableMemberInstance> consumer);
    private static IReadOnlyList`1<OverridableMemberInstance> GetNotImplementedStaticAbstractMembers(IInterface interfaceTypeElement);
    [CompilerGeneratedAttribute]
internal static bool <SatisfiesSuperTypeConstraint>g__CheckBuiltInConversion|15_0(<>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static void <SelfOrBaseHasNotImplementedStaticAbstractMembers>g__CheckSuperInterfaces|16_1(IInterface typeElement, <>c__DisplayClass16_0& , <>c__DisplayClass16_1& );
    [CompilerGeneratedAttribute]
internal static bool <SelfOrBaseHasNotImplementedStaticAbstractMembers>g__CheckAllAbstractMembersAreImplemented|16_0(IInterface typeArgumentInterface, List`1<OverridableMemberInstance> consumer);
    [CompilerGeneratedAttribute]
internal static void <SelfOrBaseHasNotImplementedStaticAbstractMembers>g__CollectMostSpecificImplementations|16_2(IInterface typeElement, ISubstitution typeSubstitution, <>c__DisplayClass16_2& );
    [CompilerGeneratedAttribute]
internal static void <SelfOrBaseHasNotImplementedStaticAbstractMembers>g__CheckStaticAbstractMembers|16_3(IInterface typeElement, ISubstitution typeSubstitution, <>c__DisplayClass16_2& );
    [CompilerGeneratedAttribute]
internal static void <SelfOrBaseHasNotImplementedStaticAbstractMembers>g__CheckImplementation|16_4(IOverridableMember overridableMember, ISubstitution substitution, <>c__DisplayClass16_2& );
}
public static class JetBrains.ReSharper.Psi.CSharp.CSharpTypeFactory : object {
    [NotNullAttribute]
private static BidirectionalMapOnDictionary`2<string, IClrTypeName> ourTypeKeywords;
    private static CSharpTypeFactory();
    [NotNullAttribute]
[PureAttribute]
public static IType CreateType(string typeStr, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IType CreateType(IReferenceName referenceName, NullableAnnotation nullableAnnotation);
    [NotNullAttribute]
[PureAttribute]
public static IType CreateType(IReferenceExpression referenceExpression, NullableAnnotation nullableAnnotation);
    [CanBeNullAttribute]
private static IType TryCreateTypeFromAlias(ResolveResultWithInfo resolveResult, NullableAnnotation nullableAnnotation);
    [NotNullAttribute]
[PureAttribute]
public static IDeclaredType CreateFunctionType(ITypeElement typeElement, ISubstitution substitution, NullableAnnotation nullableAnnotation);
    [NotNullAttribute]
[PureAttribute]
public static IType CreateType(ITypeUsage typeUsage);
    [PureAttribute]
private static bool ShouldCreateNullableValueType(IType underlyingType, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
private static IDeclaredType CreateTupleType(ITupleTypeComponentList tupleComponentList);
    [NotNullAttribute]
[PureAttribute]
private static IType CreateFunctionPointerType(IFunctionPointerTypeUsage functionPointerTypeUsage);
    [NotNullAttribute]
[PureAttribute]
internal static IDeclaredType CreateDeclaredTypeByTypeKeyword(IPsiModule module, string typeKeyword, NullableAnnotation nullableAnnotation);
    [NotNullAttribute]
[PureAttribute]
public static string GetShortNameByTypeKeyword(TokenNodeType typeKeyword);
    [NotNullAttribute]
[PureAttribute]
public static string GetShortNameByPredefinedTypeUsage(IPredefinedTypeUsage predefinedTypeUsage);
    [NotNullAttribute]
[PureAttribute]
public static IType CreateType(string fullyQualifiedName, IPsiModule module);
    [CanBeNullAttribute]
[PureAttribute]
public static string GetTypeKeyword(IClrTypeName clrName, IPsiModule module);
    [CanBeNullAttribute]
[PureAttribute]
public static string GetTypeKeyword(ITypeElement typeElement);
    [CanBeNullAttribute]
[PureAttribute]
public static IClrTypeName GetFullyQualifiedNameByKeyword(string keyword, IPsiModule psiModule);
    [CompilerGeneratedAttribute]
internal static IType <TryCreateTypeFromAlias>g__FromAlias|6_0(ISymbolAlias symbolAlias, NullableAnnotation nullableAnnotation);
    [CompilerGeneratedAttribute]
internal static NullableAnnotation <CreateType>g__GetNullableAnnotation|8_0(ITokenNode nullableContextNode);
    [CompilerGeneratedAttribute]
internal static bool <ShouldCreateNullableValueType>g__ContainsNullableTypeParameterUsageInMethodSignature|9_0(IMethodDeclaration methodDeclaration, string typeParameterName);
    [CompilerGeneratedAttribute]
internal static bool <ShouldCreateNullableValueType>g__ContainsNullableTypeParameterUsage|9_1(ITypeUsage typeUsage, string typeParameterName);
    [CompilerGeneratedAttribute]
internal static bool <ShouldCreateNullableValueType>g__IsNullableTypeParameterUsage|9_2(ITreeNode node, string typeParameterName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class JetBrains.ReSharper.Psi.CSharp.DeclaredElements.AliasedSymbol : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEqualityComparer`1<IType> TypeEqualityComparer;
    public static AliasedSymbol Unknown;
    [CompilerGeneratedAttribute]
private INamespace <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public INamespace Namespace { get; }
    public IType Type { get; }
    public bool IsUnknown { get; }
    public bool IsResolved { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private AliasedSymbol(INamespace namespaceElement, IType type);
    public AliasedSymbol(INamespace namespaceElement);
    public AliasedSymbol(IType type);
    private static AliasedSymbol();
    [CompilerGeneratedAttribute]
public INamespace get_Namespace();
    [CompilerGeneratedAttribute]
public IType get_Type();
    public bool get_IsUnknown();
    public bool get_IsResolved();
    [NullableContextAttribute("1")]
private string get_DebuggerDisplay();
    public bool IsNamespaceOrRegularDeclaredType();
    public bool IsRegularDeclaredType(IDeclaredType& declaredType);
    public bool TryResolveNamespaceOrRegularDeclaredType(IClrDeclaredElement& declaredElement, ISubstitution& substitution);
    public bool TryResolveRegularDeclaredType(ITypeElement& declaredElement, ISubstitution& substitution);
    public DeclaredElementInstance ToNamespaceOrRegularDeclaredTypeElementInstance();
    public bool IsEquivalentTo(IDeclaredElement declaredElement);
    public bool IsEquivalentTo(DeclaredElementInstance declaredElementInstance);
    public bool IsEquivalentTo(IType type);
    public bool IsEquivalentTo(AliasedSymbol otherAliasedSymbol);
    public sealed virtual bool Equals(AliasedSymbol other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public AliasedSymbolPointer CreatePointer();
}
public static class JetBrains.ReSharper.Psi.CSharp.DeclaredElements.CSharpDeclaredElementConstants : object {
    public static string DECONSTRUCT_NAME;
    public static string UNMANAGED_NAME;
    public static string NOTNULL_NAME;
    public static string FIXED_PATTERN_METHOD_NAME;
    public static string TOP_LEVEL_CODE_TYPE_NAME;
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.DeclaredElements.CSharpDeclaredElementTextStylesPartService : DeclaredElementTextStylesPartService {
    public virtual Nullable`1<DeclaredElementPresentationPartKind> TryGetPartKind(IDeclaredElement declaredElement);
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.IAlias {
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.IAnonymousMethod {
    public bool IsStatic { get; }
    public abstract virtual bool get_IsStatic();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ICSharpAnonymousTypeProperty {
    [NotNullAttribute]
public ICSharpAnonymousType ContainingType { get; }
    public abstract virtual ICSharpAnonymousType get_ContainingType();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ICSharpBackingField {
    [NotNullAttribute]
public IProperty OwnerProperty { get; }
    public abstract virtual IProperty get_OwnerProperty();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ICSharpLocalVariable {
    public bool IsImplicitlyTyped { get; }
    public bool IsUsedAsNotNullable { get; }
    public bool ContributesAnnotationToTypeInference { get; }
    public abstract virtual bool get_IsImplicitlyTyped();
    public abstract virtual bool get_IsUsedAsNotNullable();
    public abstract virtual bool get_ContributesAnnotationToTypeInference();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ICSharpProperty {
    public bool HasBackingFieldReference { get; }
    public abstract virtual bool get_HasBackingFieldReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ICSharpTypeParameterOfMethod {
    [NotNullAttribute]
public IMethodDeclaration MethodDeclaration { get; }
    public TypeParameterConstraintFlags OwnConstraints { get; }
    public abstract virtual IMethodDeclaration get_MethodDeclaration();
    public abstract virtual TypeParameterConstraintFlags get_OwnConstraints();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.IExternAlias {
    public bool IsGlobal { get; }
    public abstract virtual bool get_IsGlobal();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ILocalFunction {
    public bool IsAsync { get; }
    public bool IsVarArg { get; }
    public bool IsIterator { get; }
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsVarArg();
    public abstract virtual bool get_IsIterator();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.IQueryRangeVariable {
    public IList`1<IQueryDeclaredElement> RelatedDeclaredElements { get; }
    public abstract virtual IList`1<IQueryDeclaredElement> get_RelatedDeclaredElements();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ISymbolAlias {
    public AliasedSymbol AliasedSymbol { get; }
    public bool IsGlobal { get; }
    public bool IsNamespaceOrRegularDeclaredTypeAlias { get; }
    [NullableAttribute("2")]
public string ExternAliasName { get; }
    public abstract virtual AliasedSymbol get_AliasedSymbol();
    public abstract virtual bool get_IsGlobal();
    public abstract virtual bool get_IsNamespaceOrRegularDeclaredTypeAlias();
    [NullableContextAttribute("2")]
public abstract virtual string get_ExternAliasName();
    public abstract virtual HybridCollection`1<IUsingAliasDirective> GetDeclarations();
}
public interface JetBrains.ReSharper.Psi.CSharp.DeclaredElements.ITopLevelEntryPoint {
    [NotNullAttribute]
public IParameter ArgsParameter { get; }
    public bool IsAsync { get; }
    public abstract virtual IParameter get_ArgsParameter();
    public abstract virtual bool get_IsAsync();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ApplicableInvocationCandidate : InvocationCandidate {
    [CompilerGeneratedAttribute]
private IList`1<ArgumentMatch> <MatchResult>k__BackingField;
    [NotNullAttribute]
public IList`1<ArgumentMatch> MatchResult { get; }
    [NotNullAttribute]
public IEnumerable`1<IParameter> MatchedParametersInOrder { get; }
    [NotNullAttribute]
public IEnumerable`1<IParameter> NotMatchedParameters { get; }
    public ApplicableInvocationCandidate(InvocationCandidate candidate);
    public ApplicableInvocationCandidate(InvocationCandidate candidate, IList`1<ArgumentMatch> matchResult);
    [CompilerGeneratedAttribute]
public IList`1<ArgumentMatch> get_MatchResult();
    [NotNullAttribute]
public ApplicableInvocationCandidate ApplySubstitution(ISubstitution substitution);
    public bool MatchResultEndsWithInOrderArgument(ICSharpTreeNode context);
    [CanBeNullAttribute]
public CSharpParameterInstance MatchingParameter(ICSharpArgumentInfo argumentInfo);
    public IEnumerable`1<IParameter> get_MatchedParametersInOrder();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ApplicableInvocationCandidate/<get_NotMatchedParameters>d__11")]
public IEnumerable`1<IParameter> get_NotMatchedParameters();
    public int GetWeight();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpConvertibleToConstraint : ConvertibleToConstraint`1<ICSharpTypeConstraintsVerifier> {
    protected ICSharpTypeConversionRule TypeConversionRule { get; }
    protected CSharpConvertibleToConstraint(IType type, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    protected ICSharpTypeConversionRule get_TypeConversionRule();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpConvertibleToWithTypeInference : ConvertibleToWithTypeInference`2<ICSharpTypeConstraintsVerifier, ICSharpTypeConversionRule> {
    protected ICSharpTypeConversionRule TypeConversionRule { get; }
    public CSharpConvertibleToWithTypeInference(IType targetType, bool isExactType, ISubstitution ownerSubstitution, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    protected virtual ICSharpTypeConversionRule get_TypeConversionRule();
    protected virtual bool IsImplicitlyConvertible(IType type, IType inferredType);
    protected virtual IExpectedTypeConstraint CreateConvertibleFromConstraint(IType type);
    protected virtual IExpectedTypeConstraint CreateConvertibleToConstraint(IType type);
    protected virtual IExpectedTypeConstraint CreateConstraintForArrayElementType(IType elementType);
    protected virtual IExpectedTypeConstraint CreateConstraintForDelegateReturnType(IDelegate delegate, ISubstitution substitution, ReferenceKind& returnKind);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpExpectedTypeForArgumentAnalyzer : object {
    [NotNullAttribute]
private ICSharpArgumentInfo myArgument;
    [NotNullAttribute]
private ICSharpTypeConstraintsVerifier myTypeConstraintsVerifier;
    public CSharpExpectedTypeForArgumentAnalyzer(ICSharpArgumentInfo argument, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    [NotNullAttribute]
public IReadOnlyList`1<ExpectedType> Calc(InvocationCandidatesStrategy strategy);
    [NotNullAttribute]
public IReadOnlyList`1<ExpectedType> CalcWithReturnType(IReadOnlyList`1<ExpectedType> contextExpectedTypes, InvocationCandidatesStrategy strategy);
    [NotNullAttribute]
private static ISubstitution InferFromReturnType(InvocationCandidate candidate, ExpectedType invocationExpectedType);
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> EvaluateExpectedTypesWithReturnType(IList`1<ApplicableInvocationCandidate> candidates, IReadOnlyList`1<ExpectedType> contextExpectedTypes);
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> EvaluateExpectedTypes(IList`1<ApplicableInvocationCandidate> candidates);
    private void EvaluateExpectedTypes(ICSharpArgumentInfo argumentInfo, ApplicableInvocationCandidate candidate, ExpectedTypesCollection result);
    [NotNullAttribute]
private static IReadOnlyList`1<ITypeParameter> IdempotentTypeParameters(ITypeParametersOwner typeParametersOwner, ISubstitution substitution);
    [PureAttribute]
private static HeadType CalcHeadType(ICSharpArgumentInfo argumentInfo, IParameter parameter, IParametersOwner parametersOwner, ExpectedTypeModifiers& modifiers);
    private static bool HasMatchedArgumentsAfterThis(ICSharpArgumentInfo argumentInfo, ICSharpInvocationInfo invocation, ApplicableInvocationCandidate candidate);
    [PureAttribute]
[NotNullAttribute]
private static TailType CalcTailType(ApplicableInvocationCandidate candidate, ICSharpArgumentInfo argumentInfo, IParameter parameter);
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpExpectedTypeForExpressionAnalyzer : object {
    [NotNullAttribute]
private ICSharpExpectedTypesProvider myExpectedTypesProvider;
    [NotNullAttribute]
private ICSharpExpression myExpression;
    [NotNullAttribute]
private ICSharpTypeConversionRule myTypeConversionRule;
    [NotNullAttribute]
private ICSharpTypeConstraintsVerifier myTypeConstraintsVerifier;
    [NotNullAttribute]
private INamingPolicyProvider myNamingPolicyProvider;
    private ExpectedTypeMode myMode;
    [ThreadStaticAttribute]
private static HashSet`1<ICSharpLocalVariable> ourCalcVariableConstraintInProgress;
    [NotNullAttribute]
private CSharpConstantCalculator ConstantCalculator { get; }
    [NotNullAttribute]
private PredefinedType PredefinedType { get; }
    [NotNullAttribute]
private IPsiModule PsiModule { get; }
    public CSharpExpectedTypeForExpressionAnalyzer(ICSharpExpectedTypesProvider expectedTypesProvider, ICSharpExpression expression, ExpectedTypeMode mode, INamingPolicyProvider namingPolicyProvider);
    [NotNullAttribute]
public IReadOnlyList`1<ExpectedType> Calc();
    private InvocationCandidatesStrategy ArgumentInfoStrategy(bool strictArgumentNumber);
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> ArgumentInfo(ICSharpArgumentInfo argumentInfo, bool strictArgumentNumber);
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> ArgumentInfoWithReturnType(ICSharpArgumentInfo argumentInfo, bool strictArgumentNumber, IReadOnlyList`1<ExpectedType> contextExpectedTypes);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ArgumentExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> LocalVariableDeclaration(IVariableInitializer initializer);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> FieldDeclaration(IVariableInitializer initializer);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> EventDeclaration(IVariableInitializer initializer);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> PropertyDeclaration(IVariableInitializer initializer);
    [NotNullAttribute]
private TailType ArrayCreationTailType(IArrayCreationExpression arrayCreationExpression, int dim, int position);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ArrayCreation(IArrayInitializer arrayInitializer, int dim, int position);
    [NotNullAttribute]
private static IArrayInitializer TopmostArrayInitializer(IArrayInitializer arrayInitializer, Int32& dim);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ArrayInitializer(IVariableInitializer initializer);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ExpressionInitializer();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> CollectionExpressionElement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ConstantDeclaration();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> LocalConstantDeclaration();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> EnumMemberDeclaration();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ParameterDeclaration();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ObjectMemberInitializer();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> PropertyAssignment();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> WithInitializerAssignment();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> StringInterpolationInsert();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ReturnStatement();
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> ReturnOwnerDeclaration(ICSharpDeclaration returnOwnerDeclaration, bool refExpressionReturn);
    [NotNullAttribute]
private static string GetExpectedNameForAccessor(IAccessor accessor);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> YieldReturnStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AssignmentExpressionDest();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AssignmentExpressionSource();
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> NullCoalescingExpression(INullCoalescingExpression nullCoalescingExpression, int operandNumber);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> BinaryExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> PostfixExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> PrefixExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> UnaryExpression();
    [CanBeNullAttribute]
private IExpectedTypeConstraint CustomOperatorsConstraint(ApplicableInvocationCandidate candidate, IOperatorExpression operatorExpression, int operandNumber);
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> OperatorExpression(IOperatorExpression operatorExpression, int operandNumber);
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> CompoundAssignmentOperatorExpressionSource(IAssignmentExpression operatorExpression, TailType tailType, IEnumerable`1<NameRoot> nameRoots);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> LambdaBodyExpression();
    [NotNullAttribute]
[PureAttribute]
private IReadOnlyList`1<ExpectedType> UnwrapAsyncAnonymousFunctionReturnType(IExpectedTypeConstraint constraint, TailType tail, ITreeNode context);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ParenthesizedExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> CheckedExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> UncheckedExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AwaitExpression();
    [CanBeNullAttribute]
private IExpectedTypeConstraint CalcTernaryConstraint(ICSharpExpression otherOperand, bool createConvertibleFrom);
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> ThenElseTernaryExpression(IConditionalTernaryExpression ternaryExpression, ICSharpExpression otherOperand, TailType tailType);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ConditionalThenExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ConditionalElseExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> TernaryExpressionCondition();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> SwitchExpressionArm();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> CastExpressionOperand();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AsExpressionOperand();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ArrayDimensionExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ForeachStatementCollection();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ForStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> WhileStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> IfStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ExceptionFilterClause();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> PatternGuardClause();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> DoStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> UsingStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ThrowStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ThrowExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> SwitchStatementCondition();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> SwitchExpressionCondition();
    [NotNullAttribute]
private IExpectedTypeConstraint IntersectExpectedTypes(IEnumerable`1<IReference> references);
    [NotNullAttribute]
private IExpectedTypeConstraint CalcVariableConstraint(ICSharpLocalVariable variable, ICSharpTreeNode declaration, bool isRefVariable);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> Pattern();
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> PatternDeconstruction(IDeconstructionReference deconstructionReference, int componentIndex, string expectedName);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> GotoCaseStatement();
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> ConstantExpectedTypeBySwitchCondition(ICSharpExpression governingExpression, IType governingType, TailType tailType);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> LockStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> QueryFirstFrom();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> QueryParameterPlatform();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> QueryJoinClause();
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> AnonymousFunctionReturnType(IReadOnlyList`1<ExpectedType> lambdaExpectedTypes, Nullable`1<int> parametersCount, TailType tailType, bool isAsync, bool hasReturnRefModifier, ITreeNode context);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ExpressionBodyOwner();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> TupleComponent();
    [CanBeNullAttribute]
private ExpectedType TryGetTypeComponentExpectedType(IType type, int componentIndex, string explicitName, ExpectedTypeModifiers expectedTypeModifiers);
    private CSharpConstantCalculator get_ConstantCalculator();
    private PredefinedType get_PredefinedType();
    private IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
internal static bool <OperatorExpression>g__IsReturnTypeExpected|43_1(InvocationCandidate candidate, IReadOnlyList`1<ExpectedType> expressionExpectedTypes);
    [CompilerGeneratedAttribute]
private void <AwaitExpression>g__AddExpectedGenericTaskType|50_0(IType expectedAwaitType, <>c__DisplayClass50_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpExpectedTypeForTypeUsageAnalyzer : object {
    [NotNullAttribute]
private ICSharpExpectedTypesProvider myExpectedTypesProvider;
    [NotNullAttribute]
private ITypeUsage myTypeUsage;
    [NotNullAttribute]
private ICSharpTypeConversionRule myTypeConversionRule;
    [NotNullAttribute]
private ICSharpTypeConstraintsVerifier myTypeConstraintsVerifier;
    public CSharpExpectedTypeForTypeUsageAnalyzer(ICSharpExpectedTypesProvider expectedTypesProvider, ITypeUsage typeUsage);
    [NotNullAttribute]
public IReadOnlyList`1<ExpectedType> Calc();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ObjectCreationExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ArrayCreationExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ForeachStatement();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> CastExpression();
    [CanBeNullAttribute]
private ExpectedType[] DefaultExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AsExpression();
    [CanBeNullAttribute]
private ExpectedType[] TypeArgument();
    [CompilerGeneratedAttribute]
private ExpectedType <ForeachStatement>b__8_0(IType elementType);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpExpectedTypesProvider : object {
    public sealed virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(IExpression expression, ExpectedTypeMode mode);
    public sealed virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(ICSharpExpression expression, ExpectedTypeMode mode);
    public virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(ICSharpExpression expression, INamingPolicyProvider namingPolicyProvider, ExpectedTypeMode mode);
    public sealed virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(ITypeUsage typeUsage);
}
public static class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpExpectedTypesUtil : object {
    private static TailType IntersectTailTypes(TailType tailType1, TailType tailType2);
    private static TailType _IntersectTailTypes(TailType tailType1, TailType tailType2);
    [PureAttribute]
public static TailType GetCommonTailType(IReadOnlyList`1<ExpectedType> expectedTypes);
    [PureAttribute]
[NotNullAttribute]
public static HeadType GetCommonHeadType(IReadOnlyList`1<ExpectedType> expectedTypes);
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpExplicitlyConvertibleToConstraint : CSharpConvertibleToConstraint {
    public CSharpExplicitlyConvertibleToConstraint(IType type, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    protected virtual IReadOnlyCollection`1<ISubstitution> SolveSubtypingForFrom(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleToConstraint(IType toType);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleFromConstraint(IType fromType);
    protected virtual IExpectedTypeConstraint CreateIdentityConvertibleToConstraint(IType toType);
    public virtual bool Accepts(IType type);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpHeadType : HeadType {
    public static HeadType Ref;
    public static HeadType Out;
    public static HeadType LBrace;
    public static HeadType Await;
    public CSharpHeadType(string name, string text);
    private static CSharpHeadType();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpIdentityConvertibleToConstraint : CSharpConvertibleToConstraint {
    public CSharpIdentityConvertibleToConstraint(IType type, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    protected virtual IReadOnlyCollection`1<ISubstitution> SolveSubtypingForFrom(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleToConstraint(IType toType);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleFromConstraint(IType fromType);
    protected virtual IExpectedTypeConstraint CreateIdentityConvertibleToConstraint(IType toType);
    public virtual bool Accepts(IType type);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpImplicitlyConvertibleFromConstraint : ConvertibleFromConstraint {
    [NotNullAttribute]
private ITypeConversionRule myTypeConversionRule;
    public CSharpImplicitlyConvertibleFromConstraint(IType type, ITypeConversionRule typeConversionRule);
    protected virtual IExpectedTypeConstraint CreateConvertibleFromConstraint(IType fromType);
    public virtual bool Accepts(IType type);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpImplicitlyConvertibleToConstraint : CSharpConvertibleToConstraint {
    public CSharpImplicitlyConvertibleToConstraint(IType type, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    protected virtual IReadOnlyCollection`1<ISubstitution> SolveSubtypingForFrom(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleToConstraint(IType toType);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleFromConstraint(IType fromType);
    protected virtual IExpectedTypeConstraint CreateIdentityConvertibleToConstraint(IType toType);
    public virtual bool Accepts(IType type);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpImplicitlyConvertibleToTupleConstraint : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<ValueTuple`2<string, IExpectedTypeConstraint>> myComponentConstraints;
    private IPsiModule myPsiModule;
    public CSharpImplicitlyConvertibleToTupleConstraint(ITupleExpression tupleExpression, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    public CSharpImplicitlyConvertibleToTupleConstraint(IParenthesizedVariableDesignation parenthesizedVariableDesignation, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    private ValueTuple`2<string, IExpectedTypeConstraint> CreateConstraint(IExpression expression, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    private ValueTuple`2<string, IExpectedTypeConstraint> CreateConstraint(IVariableDesignation variableDesignation, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpIsDisposableConstraint : object {
    private bool myIsAsyncContext;
    [NotNullAttribute]
private ITreeNode myContext;
    private CSharpLanguageLevel myCSharpLanguageLevel;
    private ElementAccessContext myAccessContext;
    public CSharpIsDisposableConstraint(bool isAsyncContext, ITreeNode context);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpLiftedImplicitlyConvertibleToConstraint : CSharpImplicitlyConvertibleToConstraint {
    public CSharpLiftedImplicitlyConvertibleToConstraint(IType type, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    public virtual IType GetDefaultType();
    public virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpSuperTypeConstraint : SuperTypeConstraint {
    [NotNullAttribute]
private ICSharpTypeConstraintsVerifier myTypeConstraintsVerifier;
    public CSharpSuperTypeConstraint(IType type, ICSharpTypeConstraintsVerifier typeConstraintsVerifier);
    protected virtual IExpectedTypeConstraint CreateConvertibleFrom(IType type);
    protected virtual IExpectedTypeConstraint CreateConvertibleTo(IType type);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpTailType : TailType {
    [NotNullAttribute]
public static TailType Assignment;
    [NotNullAttribute]
public static TailType AssignmentBraces;
    [NotNullAttribute]
public static TailType EventSubscription;
    [NotNullAttribute]
public static TailType RightBrace;
    [NotNullAttribute]
public static TailType BracesAndLeaveCaretWithin;
    [NotNullAttribute]
public static TailType Colon;
    [NotNullAttribute]
public static TailType ColonWithSpaces;
    [NotNullAttribute]
public static TailType DoubleColon;
    [NotNullAttribute]
public static TailType Comma;
    [NotNullAttribute]
public static TailType ParenthesesWithCaretAfter;
    [NotNullAttribute]
public static TailType ParenthesesAndLeaveCaretWithin;
    [NotNullAttribute]
public static TailType LeftParenthesis;
    [NotNullAttribute]
public static TailType RightParenthesis;
    [NotNullAttribute]
public static TailType RightParenthesisWithSemicolon;
    [NotNullAttribute]
public static TailType RightAngular;
    [NotNullAttribute]
public static TailType AngularCaretWithin;
    [NotNullAttribute]
public static TailType AsteriskAngularCaretWithin;
    [NotNullAttribute]
public static TailType LeftBracket;
    [NotNullAttribute]
public static TailType BracketsAndLeaveCaretWithin;
    [NotNullAttribute]
public static TailType RightBracket;
    [NotNullAttribute]
public static TailType Semicolon;
    [NotNullAttribute]
public static TailType Space;
    [CanBeNullAttribute]
private TokenNodeType[] myTokens;
    private CSharpTailType(string name);
    private CSharpTailType(string name, TokenNodeType[] tokens);
    private static CSharpTailType();
    public virtual TokenNodeType[] EvaluateTail(ISolution solution, IDocument document);
}
internal class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CSharpTypeArgumentAnalyzer : TypeArgumentAnalyzer`2<ITypeUsage, ITypeArgumentList> {
    private ICSharpExpectedTypesProvider myExpectedTypesProvider;
    public CSharpTypeArgumentAnalyzer(ICSharpExpectedTypesProvider expectedTypesProvider, ITypeUsage typeUsageNode);
    protected virtual IExpectedTypeConstraint CreateConstraint(IType type);
    protected virtual IExpectedTypeConstraint[] GetAdditionalTypes(IType type, IReadOnlyList`1<ITypeParameter> typeParameters);
    [CanBeNullAttribute]
private IExpectedTypeConstraint InferConstraint(IList`1<ICSharpArgumentInfo> arguments, IConstructor constructor, int typeParameterIndex);
    public virtual ITypeArgumentList GetTypeArgumentList(ITypeUsage typeUsage, Int32& index);
    public virtual IReadOnlyList`1<ExpectedType> GetTypeArgumentListContext(ITypeArgumentList typeArgumentList, List`1& types);
    [NotNullAttribute]
protected virtual TailType GetTailType(int index, IReadOnlyList`1<ITypeParameter> typeParameters);
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.CustomAwaitableTypeConstraint : object {
    private bool myExpectNonVoidReturn;
    public CustomAwaitableTypeConstraint(bool expectNonVoidReturn);
    public sealed virtual bool Accepts(IType type);
    [PureAttribute]
private bool CheckGetAwaiterMethod(IMethod method);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ExpectedTypesCollection : object {
    [NotNullAttribute]
private Dictionary`2<string, List`1<ExpectedType>> myCollection;
    private int myCount;
    public void AddExpectedTypeWithConstraint(IExpectedTypeConstraint constraint, string expectedName, ExpectedTypeModifiers modifiers, HeadType headType, TailType tailType);
    public void AddExpectedTypeWithConstraint(IExpectedTypeConstraint constraint, string expectedName, ExpectedTypeModifiers modifiers);
    [NotNullAttribute]
public IReadOnlyList`1<ExpectedType> ToIReadOnlyList();
}
public interface JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ICSharpExpectedTypesProvider {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(ICSharpExpression expression, ExpectedTypeMode mode);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(ICSharpExpression expression, INamingPolicyProvider namingPolicyProvider, ExpectedTypeMode mode);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(ITypeUsage typeUsage);
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.InvocationCandidatesEngine : object {
    private ICSharpInvocationInfo myInvocation;
    private int myArgumentIndex;
    private InvocationCandidatesStrategy myStrategy;
    [CanBeNullAttribute]
private IList`1<InvocationCandidate> myCandidates;
    private IList`1<InvocationCandidate> myFilteredCandidates;
    [CanBeNullAttribute]
private IList`1<ApplicableInvocationCandidate> myApplicableCandidates;
    [NotNullAttribute]
public IList`1<InvocationCandidate> Candidates { get; }
    [NotNullAttribute]
public IList`1<ApplicableInvocationCandidate> ApplicableCandidates { get; }
    [NotNullAttribute]
public IList`1<InvocationCandidate> NotApplicableCandidates { get; }
    [NotNullAttribute]
public IList`1<ApplicableInvocationCandidate> CandidatesWithMatcher { get; }
    public InvocationCandidatesEngine(ICSharpInvocationInfo invocation, int argumentIndex, InvocationCandidatesStrategy strategy);
    public IList`1<InvocationCandidate> get_Candidates();
    public IList`1<ApplicableInvocationCandidate> get_ApplicableCandidates();
    public IList`1<InvocationCandidate> get_NotApplicableCandidates();
    public IList`1<ApplicableInvocationCandidate> get_CandidatesWithMatcher();
    [PureAttribute]
public int GetDefaultCandidateIndex();
    [CanBeNullAttribute]
public InvocationCandidate GetDefaultCandidate();
    [NotNullAttribute]
[PureAttribute]
private IList`1<ICSharpArgumentInfo> Arguments(bool isExtensionInvocationCandidate);
    [PureAttribute]
private int ArgumentIndex(bool isCandidateExtension);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.InvocationCandidatesEngine/<CalculateApplicableCandidates>d__19")]
[NotNullAttribute]
private IEnumerable`1<ApplicableInvocationCandidate> CalculateApplicableCandidates();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.InvocationCandidatesEngine/<CalculateCandidates>d__20")]
[NotNullAttribute]
private IEnumerable`1<InvocationCandidate> CalculateCandidates();
    private InvocationCandidate InferTypeArguments(InvocationCandidate candidate);
    [NotNullAttribute]
private static IArgumentsMatcher CreateArgumentsMatcher(IList`1<ICSharpArgumentInfo> arguments, int iArgument, ProcessInvocationArgs strategy);
    [NotNullAttribute]
private IOverloadResolutionData CreateOverloadResolutionData(IArgumentsMatcher matcher);
    [CompilerGeneratedAttribute]
private ApplicableInvocationCandidate <get_CandidatesWithMatcher>b__14_0(InvocationCandidate candidate);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.InvocationCandidatesStrategy : ValueType {
    [CompilerGeneratedAttribute]
private bool <StrictArgumentNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessInvocationArgs <Applicability>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessInvocationArgs <TypeInference>k__BackingField;
    public bool StrictArgumentNumber { get; }
    public ProcessInvocationArgs Applicability { get; }
    public ProcessInvocationArgs TypeInference { get; }
    public InvocationCandidatesStrategy(ProcessInvocationArgs typeInference, ProcessInvocationArgs applicability, bool strictArgumentNumber);
    [CompilerGeneratedAttribute]
public bool get_StrictArgumentNumber();
    [CompilerGeneratedAttribute]
public ProcessInvocationArgs get_Applicability();
    [CompilerGeneratedAttribute]
public ProcessInvocationArgs get_TypeInference();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ObjectCreationExpressionConstraint : object {
    [NotNullAttribute]
private IExpectedTypeConstraint myBaseConstraint;
    private List`1<IType> mySubTypes;
    public ObjectCreationExpressionConstraint(IExpectedTypeConstraint baseConstraint);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    [NotNullAttribute]
public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ParameterInfoFilter : SimpleSymbolFilter {
    [NotNullAttribute]
private ITreeNode myElement;
    public ResolveErrorType ErrorType { get; }
    public ParameterInfoFilter(ITreeNode element);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.PredefinedOperatorsConstraint : object {
    [NotNullAttribute]
private IList`1<IType> myTypes;
    private IType myDefaultType;
    [NotNullAttribute]
private ICSharpTypeConversionRule myConversionRule;
    public PredefinedOperatorsConstraint(IList`1<IType> types, IType defaultType, ICSharpTypeConversionRule conversionRule);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
public enum JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ProcessInvocationArgs : Enum {
    public int value__;
    public static ProcessInvocationArgs UP_TO;
    public static ProcessInvocationArgs BACK_TO;
    public static ProcessInvocationArgs EXCEPT;
    public static ProcessInvocationArgs ALL;
    public static ProcessInvocationArgs GROUP_BY;
}
public class JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.SwitchConditionTypeConstraint : object {
    [NotNullAttribute]
private IPsiModule myPsiModule;
    [CanBeNullAttribute]
private IReadOnlyList`1<IExpressionType> myCaseTypes;
    public SwitchConditionTypeConstraint(IPsiModule module, IReadOnlyList`1<IExpressionType> caseTypes);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.CSharp.ExtensionMethods.CSharpExtensionMethodsHelper : object {
    [NotNullAttribute]
[PureAttribute]
public static ResolveErrorType IsExtensionMethodApplicable(IMethod method, IArgumentInfo extensionArgument, IList`1<ICSharpArgumentInfo> arguments, IList`1<IType> typeArguments, ICSharpTreeNode context);
    [PureAttribute]
public static ExtensionMethodAccessibility IsExtensionMethodAccessible(IMethod method, IAccessContext accessContext, string qualifyingExternAlias, CSharpLanguageLevel languageLevel);
    [PureAttribute]
public static ExtensionMethodAccessibility IsExtensionMethodAccessible(IMethod method, IPsiSourceFile contextSourceFile, IPsiModule psiModule, string qualifyingExternAlias, CSharpLanguageLevel languageLevel);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.ExtensionMethods.CSharpExtensionMethodsRegistry : object {
    public static CSharpExtensionMethodsRegistry GetInstance(ISolution solution);
    public abstract virtual IExtensionMethodsQuery GetAllExtensionMethods();
}
public class JetBrains.ReSharper.Psi.CSharp.ExternAliasesManager : object {
    public static string GLOBAL_ALIAS_NAME;
    public static IExternAlias GetGlobalAlias(IPsiModule module);
    public static IExternAlias GetAlias(string name, IPsiModule module);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Gen.CSharpParserGenerated : GeneratedParserBase`1<CSharpFilteringLexer> {
    protected ParsingContext myCurrentContext;
    protected bool IsInFollow(TokenNodeType tokenType);
    protected virtual TreeElement Match(TokenNodeType tokenType);
    protected void Skip(CompositeElement parent);
    protected virtual void SkipErrorToken(CompositeElement parent);
    public virtual void ParseDocCRefIdentifierOrKeyword(CompositeElement result);
    public virtual TreeElement ParseAccessorDeclaration();
    protected virtual CompositeElement HandleErrorInAccessorDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseAccessorDeclarations(CompositeElement result);
    public abstract virtual TreeElement ParseAdditiveExpression();
    protected virtual TreeElement ParseAdditiveExpressionInternal();
    public virtual TreeElement ParseAllowsRefStructConstraint();
    public virtual TreeElement ParseAndPattern();
    public abstract virtual TreeElement ParseAnonymousMemberDeclaration();
    protected virtual TreeElement ParseAnonymousMemberDeclarationInternal();
    protected virtual CompositeElement HandleErrorInAnonymousMemberDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAnonymousMethodExpression();
    public virtual TreeElement ParseAnonymousObjectCreationExpression();
    public virtual TreeElement ParseAnonymousObjectInitializer();
    protected virtual CompositeElement HandleErrorInAnonymousObjectInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseArglistExpression();
    public virtual TreeElement ParseArgumentList();
    public virtual void ParseArgumentListAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInArgumentListAux(CompositeElement result, SyntaxError error);
    public virtual void ParseArgumentListAux2(CompositeElement result);
    protected virtual CompositeElement HandleErrorInArgumentListAux2(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseArrayCreationAux(CompositeElement result);
    protected virtual void ParseArrayCreationAuxInternal(CompositeElement result);
    public virtual TreeElement ParseArrayCreationExpression();
    protected virtual CompositeElement HandleErrorInArrayCreationExpression(CompositeElement result, SyntaxError error);
    public virtual void ParseArrayCreationExpressionAux(CompositeElement result, TreeElement newKeyword, TreeElement t);
    public abstract virtual TreeElement ParseArrayInitializer();
    protected virtual TreeElement ParseArrayInitializerInternal();
    protected virtual CompositeElement HandleErrorInArrayInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseArrayTypeUsage();
    public virtual TreeElement ParseArrowExpressionClause();
    public abstract virtual TreeElement ParseAsExpression();
    protected virtual TreeElement ParseAsExpressionInternal();
    public abstract virtual TreeElement ParseAssignmentExpression();
    protected virtual TreeElement ParseAssignmentExpressionInternal();
    public virtual void ParseAssignmentOperatorAux(CompositeElement result);
    public abstract virtual TreeElement ParseAttribute();
    protected virtual TreeElement ParseAttributeInternal();
    public virtual void ParseAttributeArguments(CompositeElement result);
    public abstract virtual TreeElement ParseAttributeList();
    protected virtual TreeElement ParseAttributeListInternal();
    public abstract virtual TreeElement ParseAttributeSection();
    protected virtual TreeElement ParseAttributeSectionInternal();
    public virtual TreeElement ParseAttributeSectionList();
    protected virtual CompositeElement HandleErrorInAttributeSectionList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAwaitExpression();
    public virtual TreeElement ParseBaseExpression();
    public virtual TreeElement ParseBinaryExpression();
    public virtual TreeElement ParseBinaryPattern();
    public abstract virtual TreeElement ParseBitwiseAndExpression();
    protected virtual TreeElement ParseBitwiseAndExpressionInternal();
    public abstract virtual TreeElement ParseBitwiseExclusiveOrExpression();
    protected virtual TreeElement ParseBitwiseExclusiveOrExpressionInternal();
    public abstract virtual TreeElement ParseBitwiseInclusiveOrExpression();
    protected virtual TreeElement ParseBitwiseInclusiveOrExpressionInternal();
    public abstract virtual TreeElement ParseBlock();
    protected virtual TreeElement ParseBlockInternal();
    protected virtual CompositeElement HandleErrorInBlock(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseBlockOrNonParsableBlock(CompositeElement result);
    protected virtual void ParseBlockOrNonParsableBlockInternal(CompositeElement result);
    public virtual void ParseBooleanExpression(CompositeElement result);
    protected virtual CompositeElement HandleErrorInBooleanExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseBreakStatement();
    protected virtual CompositeElement HandleErrorInBreakStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCSharpArgument();
    protected virtual CompositeElement HandleErrorInCSharpArgument(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCSharpExpression();
    protected virtual CompositeElement HandleErrorInCSharpExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCSharpFile();
    public virtual TreeElement ParseCSharpLiteralExpression();
    public virtual TreeElement ParseCSharpNamespaceDeclaration();
    public virtual TreeElement ParseCSharpTypeDeclaration(TreeElement attrs, TreeElement mods);
    protected virtual CompositeElement HandleErrorInCSharpTypeDeclaration(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseCastExpression();
    protected virtual TreeElement ParseCastExpressionInternal();
    public virtual TreeElement ParseCatchClause(TreeElement catchKeyword);
    protected virtual CompositeElement HandleErrorInCatchClause(CompositeElement result, SyntaxError error);
    public virtual void ParseCatchClauses(CompositeElement result);
    protected virtual CompositeElement HandleErrorInCatchClauses(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCatchVariableDeclaration();
    public virtual TreeElement ParseCheckedExpression();
    public virtual TreeElement ParseCheckedStatement();
    protected virtual CompositeElement HandleErrorInCheckedStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseClassBody();
    protected virtual CompositeElement HandleErrorInClassBody(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseClassDeclaration(TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseClassLikeDeclaration(TreeElement attrs, TreeElement mods);
    [ParsingContextAttribute("0")]
public virtual void ParseClassMemberDeclarationAux(CompositeElement result);
    public virtual void ParseClassMemberDeclarationAux1(CompositeElement result, TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseClassMemberDeclarationAuxError(TreeElement attrs, TreeElement mods);
    protected virtual CompositeElement HandleErrorInClassMemberDeclarationAuxError(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCollectionElementInitializer();
    protected virtual CompositeElement HandleErrorInCollectionElementInitializer(CompositeElement result, SyntaxError error);
    public virtual void ParseCollectionElementInitializerAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInCollectionElementInitializerAux(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseCollectionExpression();
    protected virtual TreeElement ParseCollectionExpressionInternal();
    protected virtual CompositeElement HandleErrorInCollectionExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCollectionExpressionElement();
    protected virtual CompositeElement HandleErrorInCollectionExpressionElement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCollectionInitializer();
    protected virtual CompositeElement HandleErrorInCollectionInitializer(CompositeElement result, SyntaxError error);
    public virtual void ParseCompilationUnit(CompositeElement result);
    protected virtual CompositeElement HandleErrorInCompilationUnit(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseConditionalAccessSign();
    public abstract virtual TreeElement ParseConditionalAndExpression();
    protected virtual TreeElement ParseConditionalAndExpressionInternal();
    public abstract virtual TreeElement ParseConditionalOrExpression();
    protected virtual TreeElement ParseConditionalOrExpressionInternal();
    public abstract virtual TreeElement ParseConditionalTernaryExpression();
    protected virtual TreeElement ParseConditionalTernaryExpressionInternal();
    public virtual TreeElement ParseConstantDeclaration();
    public virtual void ParseConstantExpression(CompositeElement result);
    public virtual TreeElement ParseConstantOrTypePattern();
    protected virtual CompositeElement HandleErrorInConstantOrTypePattern(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseConstructorConstraint();
    public virtual TreeElement ParseConstructorDeclaration(TreeElement attrs, TreeElement mods, TreeElement id);
    protected virtual CompositeElement HandleErrorInConstructorDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseConstructorDeclarator(CompositeElement result, TreeElement id);
    public abstract virtual TreeElement ParseConstructorInitializer();
    protected virtual TreeElement ParseConstructorInitializerInternal();
    protected virtual CompositeElement HandleErrorInConstructorInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseContinueStatement();
    protected virtual CompositeElement HandleErrorInContinueStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseConversionOperatorDeclaration(TreeElement attrs, TreeElement mods);
    protected virtual CompositeElement HandleErrorInConversionOperatorDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseConversionOperatorDeclarator(CompositeElement result);
    protected virtual CompositeElement HandleErrorInConversionOperatorDeclarator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCreationExpression();
    public abstract virtual TreeElement ParseCreationExpressionInitializer();
    protected virtual TreeElement ParseCreationExpressionInitializerInternal();
    public virtual TreeElement ParseDeclarationExpression(TreeElement contextKeyword);
    public abstract virtual void ParseDeclarationOrExpressionOrLabelStatement(CompositeElement result);
    protected virtual void ParseDeclarationOrExpressionOrLabelStatementInternal(CompositeElement result);
    public abstract virtual void ParseDeclarationOrExpressionOrLabelStatementError(CompositeElement result, TreeElement elseKeyword);
    protected virtual void ParseDeclarationOrExpressionOrLabelStatementErrorInternal(CompositeElement result, TreeElement elseKeyword);
    public abstract virtual TreeElement ParseDeclarationStatement();
    protected virtual TreeElement ParseDeclarationStatementInternal();
    protected virtual CompositeElement HandleErrorInDeclarationStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseDeconstructionPatternClause();
    public virtual TreeElement ParseDefaultConstraint();
    public virtual TreeElement ParseDefaultExpression();
    public virtual TreeElement ParseDefineDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInDefineDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseDelegateDeclaration(TreeElement attrs, TreeElement mods);
    protected virtual CompositeElement HandleErrorInDelegateDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseDestructorDeclaration(TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseDiscardDesignation();
    public virtual TreeElement ParseDiscardPattern();
    public virtual TreeElement ParseDoStatement();
    protected virtual CompositeElement HandleErrorInDoStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseDocCRefElement();
    protected virtual TreeElement ParseDocCRefElementInternal();
    public virtual void ParseDocCRefElementAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInDocCRefElementAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseDocCRefExpression();
    protected virtual CompositeElement HandleErrorInDocCRefExpression(CompositeElement result, SyntaxError error);
    public virtual void ParseDocCRefGenericsLAngle(CompositeElement result);
    public virtual void ParseDocCRefGenericsRAngle(CompositeElement result);
    public virtual TreeElement ParseDocCRefParameter();
    protected virtual CompositeElement HandleErrorInDocCRefParameter(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseDocCRefParameterType();
    public abstract virtual TreeElement ParseDocCRefParameterTypeName();
    protected virtual TreeElement ParseDocCRefParameterTypeNameInternal();
    public virtual void ParseDocCRefParameterTypeNameAux(CompositeElement result);
    public virtual TreeElement ParseDocCRefSignature();
    public virtual TreeElement ParseDocCRefTypeParameter();
    public virtual TreeElement ParseDocCRefTypeParameterList();
    public abstract virtual TreeElement ParseElementAccessExpression();
    protected virtual TreeElement ParseElementAccessExpressionInternal();
    public virtual TreeElement ParseElifDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInElifDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseElseDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInElseDirective(CompositeElement result, SyntaxError error);
    public virtual void ParseEmbeddedStatementAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInEmbeddedStatementAux(CompositeElement result, SyntaxError error);
    public virtual void ParseEmbeddedStatementNoIdentifier(CompositeElement result);
    public virtual TreeElement ParseEmptyStatement();
    public virtual TreeElement ParseEndRegion(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInEndRegion(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEndifDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInEndifDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEnumBase();
    protected virtual CompositeElement HandleErrorInEnumBase(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseEnumBody();
    protected virtual TreeElement ParseEnumBodyInternal();
    public virtual TreeElement ParseEnumDeclaration(TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseEnumMemberDeclaration();
    [ParsingContextAttribute("1")]
public virtual void ParseEnumMemberDeclarationAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInEnumMemberDeclarationAux(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseEqualityExpression();
    protected virtual TreeElement ParseEqualityExpressionInternal();
    public abstract virtual void ParseErroneousBlock(CompositeElement result);
    protected virtual void ParseErroneousBlockInternal(CompositeElement result);
    public virtual TreeElement ParseErrorDirective(TreeElement sharp);
    public abstract virtual TreeElement ParseErrorElement();
    public virtual void ParseErrorHandlingExpressionBeforeRPar(CompositeElement result);
    protected virtual CompositeElement HandleErrorInErrorHandlingExpressionBeforeRPar(CompositeElement result, SyntaxError error);
    public virtual void ParseErrorHandlingExpressionLockStatement(CompositeElement result);
    protected virtual CompositeElement HandleErrorInErrorHandlingExpressionLockStatement(CompositeElement result, SyntaxError error);
    public virtual void ParseErrorHandlingTypeUsageBeforeRPar(CompositeElement result);
    protected virtual CompositeElement HandleErrorInErrorHandlingTypeUsageBeforeRPar(CompositeElement result, SyntaxError error);
    public virtual void ParseEventAccessorDeclarations(CompositeElement result);
    public virtual TreeElement ParseEventDeclaration();
    protected virtual CompositeElement HandleErrorInEventDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseExceptionDeclaration(CompositeElement result);
    protected virtual CompositeElement HandleErrorInExceptionDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseExceptionFilterClause();
    public virtual TreeElement ParseExpressionElement();
    public virtual TreeElement ParseExpressionInitializer();
    public virtual void ParseExpressionOrInitializerPart(CompositeElement result);
    protected virtual CompositeElement HandleErrorInExpressionOrInitializerPart(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseExpressionStatement();
    protected virtual CompositeElement HandleErrorInExpressionStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseExtendedType();
    public virtual TreeElement ParseExtendsList();
    protected virtual CompositeElement HandleErrorInExtendsList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseExternAliasDirective();
    protected virtual CompositeElement HandleErrorInExternAliasDirective(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseExternAliasDirectivesAux(CompositeElement result);
    protected virtual void ParseExternAliasDirectivesAuxInternal(CompositeElement result);
    public virtual TreeElement ParseFakeMethodDeclaration(TreeElement attrs, TreeElement mods, TreeElement t, TreeElement owner, TreeElement name);
    public virtual void ParseFakeMethodDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t, TreeElement owner, TreeElement name);
    public virtual TreeElement ParseFieldDeclaration(TreeElement id);
    protected virtual CompositeElement HandleErrorInFieldDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseFieldDeclaratorFull(CompositeElement result);
    public virtual void ParseFieldDeclarators(CompositeElement result, TreeElement id);
    public virtual void ParseFinallyClauseAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInFinallyClauseAux(CompositeElement result, SyntaxError error);
    public virtual void ParseFloatingPointType(CompositeElement result);
    public virtual void ParseForCondition(CompositeElement result);
    public virtual void ParseForHeader(CompositeElement result);
    protected virtual CompositeElement HandleErrorInForHeader(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseForInitializer();
    protected virtual TreeElement ParseForInitializerInternal();
    public virtual TreeElement ParseForIterator();
    public virtual TreeElement ParseForStatement();
    protected virtual CompositeElement HandleErrorInForStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseForeachHeader(TreeElement foreachKeyword);
    protected virtual CompositeElement HandleErrorInForeachHeader(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseForeachHeaderAux(CompositeElement result, TreeElement foreachKeyword);
    protected virtual void ParseForeachHeaderAuxInternal(CompositeElement result, TreeElement foreachKeyword);
    protected virtual CompositeElement HandleErrorInForeachHeaderAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseForeachStatement();
    protected virtual CompositeElement HandleErrorInForeachStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseFormalParameterList();
    protected virtual CompositeElement HandleErrorInFormalParameterList(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseFunctionBody(CompositeElement result);
    protected virtual void ParseFunctionBodyInternal(CompositeElement result);
    public virtual TreeElement ParseFunctionPointerCallingConvention();
    public virtual TreeElement ParseFunctionPointerParameter();
    public virtual void ParseFunctionPointerParameterModifier(CompositeElement result);
    public virtual TreeElement ParseFunctionPointerParameterModifiers();
    public virtual TreeElement ParseFunctionPointerTypeUsage();
    public virtual TreeElement ParseGeneralCatchClause(TreeElement catchKeyword);
    protected virtual CompositeElement HandleErrorInGeneralCatchClause(CompositeElement result, SyntaxError error);
    [ParsingContextAttribute("2")]
public abstract virtual void ParseGlobalAttributeSectionAux(CompositeElement result);
    [ParsingContextAttribute("2")]
protected virtual void ParseGlobalAttributeSectionAuxInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInGlobalAttributeSectionAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseGotoCaseStatement(TreeElement gotoKeyword);
    protected virtual CompositeElement HandleErrorInGotoCaseStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseGotoStatement(TreeElement gotoKeyword);
    protected virtual CompositeElement HandleErrorInGotoStatement(CompositeElement result, SyntaxError error);
    public virtual void ParseGotoStatementAux(CompositeElement result);
    public abstract virtual TreeElement ParseIdentifier();
    public virtual TreeElement ParseIfDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInIfDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseIfStatement();
    protected virtual CompositeElement HandleErrorInIfStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseIndexFromEndExpression();
    public virtual TreeElement ParseIndexerDeclaration(TreeElement attrs, TreeElement mods, TreeElement t, TreeElement owner, TreeElement thisKeyword);
    protected virtual CompositeElement HandleErrorInIndexerDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseIndexerDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t);
    public virtual void ParseIndexerDeclarator(CompositeElement result, TreeElement t, TreeElement owner, TreeElement thisKeyword);
    public virtual TreeElement ParseIndexerInitializer();
    protected virtual CompositeElement HandleErrorInIndexerInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseInitializedMemberInitializer();
    public virtual TreeElement ParseInitializerElement();
    public virtual void ParseIntegralType(CompositeElement result);
    public virtual TreeElement ParseInterfaceDeclaration(TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseInterpolatedStringExpression();
    protected virtual CompositeElement HandleErrorInInterpolatedStringExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseInterpolatedStringInsert();
    protected virtual CompositeElement HandleErrorInInterpolatedStringInsert(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseInvalidDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInInvalidDirective(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseInvocationExpression();
    protected virtual TreeElement ParseInvocationExpressionInternal();
    public abstract virtual TreeElement ParseIsExpression();
    protected virtual TreeElement ParseIsExpressionInternal();
    public virtual void ParseIterationStatementAux(CompositeElement result);
    public virtual void ParseJumpStatementAux(CompositeElement result);
    public virtual TreeElement ParseKeyword();
    public virtual TreeElement ParseLabelDeclaration();
    public virtual TreeElement ParseLabelReferenceElement();
    public virtual TreeElement ParseLabelStatement();
    protected virtual CompositeElement HandleErrorInLabelStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLambdaExpression();
    public abstract virtual void ParseLambdaExpressionModifiers(CompositeElement result);
    protected virtual void ParseLambdaExpressionModifiersInternal(CompositeElement result);
    public abstract virtual void ParseLambdaExpressionReturnType(CompositeElement result);
    protected virtual void ParseLambdaExpressionReturnTypeInternal(CompositeElement result);
    public abstract virtual void ParseLambdaParameterAux(CompositeElement result, TreeElement lPar);
    protected virtual void ParseLambdaParameterAuxInternal(CompositeElement result, TreeElement lPar);
    public virtual TreeElement ParseLambdaSignature();
    public virtual TreeElement ParseLineDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInLineDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLineIndicator();
    protected virtual CompositeElement HandleErrorInLineIndicator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseListPattern();
    public virtual TreeElement ParseLocalArglistParameterDeclaration(TreeElement attrs);
    protected virtual CompositeElement HandleErrorInLocalArglistParameterDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLocalConstantDeclaration();
    public virtual TreeElement ParseLocalFormalParameterList();
    protected virtual CompositeElement HandleErrorInLocalFormalParameterList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLocalFunctionDeclaration();
    protected virtual CompositeElement HandleErrorInLocalFunctionDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseLocalFunctionHeader(CompositeElement result);
    public virtual void ParseLocalParameterAux(CompositeElement result);
    public abstract virtual TreeElement ParseLocalRegularParameterDeclaration(TreeElement attrs);
    protected virtual TreeElement ParseLocalRegularParameterDeclarationInternal(TreeElement attrs);
    protected virtual CompositeElement HandleErrorInLocalRegularParameterDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLocalVariableDeclaration();
    protected virtual CompositeElement HandleErrorInLocalVariableDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLockStatement();
    protected virtual CompositeElement HandleErrorInLockStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMakerefExpression();
    public abstract virtual TreeElement ParseMemberInitializer();
    protected virtual TreeElement ParseMemberInitializerInternal();
    public virtual void ParseMemberInitializerAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInMemberInitializerAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMemberOwnerDeclaration(TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseMethodDeclaration(TreeElement attrs, TreeElement mods, TreeElement t, TreeElement owner, TreeElement name);
    protected virtual CompositeElement HandleErrorInMethodDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseMethodHeader(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t, TreeElement owner, TreeElement name);
    public virtual TreeElement ParseMissingDesignation();
    public abstract virtual TreeElement ParseModifiersList();
    protected virtual TreeElement ParseModifiersListInternal();
    public virtual TreeElement ParseMultipleConstantDeclaration(TreeElement attrs, TreeElement mods);
    protected virtual CompositeElement HandleErrorInMultipleConstantDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMultipleEventDeclaration(TreeElement attrs, TreeElement mods);
    protected virtual CompositeElement HandleErrorInMultipleEventDeclaration(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseMultipleEventDeclarationTerminator(CompositeElement result);
    protected virtual void ParseMultipleEventDeclarationTerminatorInternal(CompositeElement result);
    public virtual TreeElement ParseMultipleFieldDeclaration(TreeElement attrs, TreeElement mods, TreeElement t, TreeElement id);
    protected virtual CompositeElement HandleErrorInMultipleFieldDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseMultipleFixedPointerDeclarationAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInMultipleFixedPointerDeclarationAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMultipleLocalConstantDeclaration();
    public virtual TreeElement ParseMultipleLocalVariableDeclaration();
    public abstract virtual TreeElement ParseMultiplicativeExpression();
    protected virtual TreeElement ParseMultiplicativeExpressionInternal();
    public virtual TreeElement ParseNamedMemberInitializer();
    public abstract virtual TreeElement ParseNamespaceBody();
    protected virtual TreeElement ParseNamespaceBodyInternal();
    protected virtual CompositeElement HandleErrorInNamespaceBody(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseNamespaceErroneousBlock(CompositeElement result);
    protected virtual void ParseNamespaceErroneousBlockInternal(CompositeElement result);
    [ParsingContextAttribute("3")]
public virtual void ParseNamespaceMemberDeclarationAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInNamespaceMemberDeclarationAux(CompositeElement result, SyntaxError error);
    public virtual void ParseNamespaceOrTypeName(CompositeElement result);
    public virtual TreeElement ParseNegatedPattern();
    public virtual void ParseNeverCallThis(CompositeElement result);
    protected virtual CompositeElement HandleErrorInNeverCallThis(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseNullCoalescingExpression();
    protected virtual TreeElement ParseNullCoalescingExpressionInternal();
    public abstract virtual TreeElement ParseNullableDirective(TreeElement sharp);
    protected virtual TreeElement ParseNullableDirectiveInternal(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInNullableDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseNullableTypeMark();
    public virtual TreeElement ParseNullableTypeUsage();
    public virtual void ParseNumericType(CompositeElement result);
    public virtual TreeElement ParseObjectCreationExpression();
    public virtual void ParseObjectCreationExpressionAux(CompositeElement result, TreeElement newKeyword, TreeElement t);
    public virtual TreeElement ParseObjectInitializer();
    protected virtual CompositeElement HandleErrorInObjectInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseOrPattern();
    public abstract virtual void ParseOtherStructMemberDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t);
    protected virtual void ParseOtherStructMemberDeclarationAuxInternal(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t);
    public virtual TreeElement ParseOverflowCheckingStatement();
    public abstract virtual TreeElement ParseOwnerQualification(TreeElement id);
    protected virtual TreeElement ParseOwnerQualificationInternal(TreeElement id);
    protected virtual CompositeElement HandleErrorInOwnerQualification(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseOwnerQualificationAux(CompositeElement result);
    protected virtual void ParseOwnerQualificationAuxInternal(CompositeElement result);
    public virtual void ParseParameterAux(CompositeElement result);
    public virtual void ParseParameterModifier(CompositeElement result);
    public virtual TreeElement ParseParameterModifiersList();
    public virtual TreeElement ParseParenthesizedExpression();
    public virtual TreeElement ParseParenthesizedPattern();
    public abstract virtual TreeElement ParseParenthesizedVariableDesignation(TreeElement context);
    protected virtual TreeElement ParseParenthesizedVariableDesignationInternal(TreeElement context);
    protected virtual CompositeElement HandleErrorInParenthesizedVariableDesignation(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePattern();
    public virtual TreeElement ParsePatternGuardClause();
    public virtual TreeElement ParsePointerTypeUsage();
    public abstract virtual void ParsePossiblyRefValue(CompositeElement result);
    protected virtual void ParsePossiblyRefValueInternal(CompositeElement result);
    public abstract virtual TreeElement ParsePostfixOperatorExpression();
    protected virtual TreeElement ParsePostfixOperatorExpressionInternal();
    public virtual TreeElement ParsePragmaDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInPragmaDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePredefinedTypeExpression();
    public virtual TreeElement ParsePredefinedTypeReference();
    public virtual TreeElement ParsePredefinedTypeUsage();
    public virtual TreeElement ParsePrefixOperatorExpression();
    public virtual TreeElement ParsePreprocessorAndExpression();
    public virtual TreeElement ParsePreprocessorConditionalSymbol();
    public virtual TreeElement ParsePreprocessorDirective(TreeElement sharp);
    public abstract virtual void ParsePreprocessorDirectiveAux(CompositeElement result);
    protected virtual void ParsePreprocessorDirectiveAuxInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInPreprocessorDirectiveAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePreprocessorEqualityExpression();
    public virtual TreeElement ParsePreprocessorExpression();
    public virtual TreeElement ParsePreprocessorExpressionOr();
    public virtual TreeElement ParsePreprocessorExpressionAnd();
    public virtual TreeElement ParsePreprocessorExpressionEquality();
    public virtual TreeElement ParsePreprocessorExpressionSimple();
    protected virtual CompositeElement HandleErrorInPreprocessorExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePreprocessorNegation();
    public virtual TreeElement ParsePreprocessorOrExpression();
    public virtual TreeElement ParsePreprocessorParenthesizedExpression();
    public virtual TreeElement ParsePreprocessorPragmaBody();
    public virtual TreeElement ParsePreprocessorUnaryExpression();
    public virtual TreeElement ParsePrimaryConstructorDeclaration();
    protected virtual CompositeElement HandleErrorInPrimaryConstructorDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePrimaryExpression();
    public virtual TreeElement ParsePropertyAssignment();
    protected virtual CompositeElement HandleErrorInPropertyAssignment(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePropertyDeclaration(TreeElement attrs, TreeElement mods, TreeElement t, TreeElement owner, TreeElement name);
    protected virtual CompositeElement HandleErrorInPropertyDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePropertyInitializer();
    protected virtual CompositeElement HandleErrorInPropertyInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePropertyPatternClause();
    public virtual void ParseQueryBody(CompositeElement result);
    protected virtual CompositeElement HandleErrorInQueryBody(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryContinuation();
    protected virtual CompositeElement HandleErrorInQueryContinuation(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryExpression();
    public abstract virtual TreeElement ParseQueryFirstFrom();
    protected virtual TreeElement ParseQueryFirstFromInternal();
    protected virtual CompositeElement HandleErrorInQueryFirstFrom(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseQueryFromClause();
    protected virtual TreeElement ParseQueryFromClauseInternal();
    protected virtual CompositeElement HandleErrorInQueryFromClause(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryGroupClause();
    protected virtual CompositeElement HandleErrorInQueryGroupClause(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseQueryJoinClause();
    protected virtual TreeElement ParseQueryJoinClauseInternal();
    protected virtual CompositeElement HandleErrorInQueryJoinClause(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryLetClause();
    protected virtual CompositeElement HandleErrorInQueryLetClause(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryOrderByClause();
    protected virtual CompositeElement HandleErrorInQueryOrderByClause(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryOrdering();
    protected virtual CompositeElement HandleErrorInQueryOrdering(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryParameterPlatform();
    protected virtual CompositeElement HandleErrorInQueryParameterPlatform(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryRangeVariableDeclaration();
    public virtual TreeElement ParseQuerySelectClause();
    protected virtual CompositeElement HandleErrorInQuerySelectClause(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryWhereClause();
    protected virtual CompositeElement HandleErrorInQueryWhereClause(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseRangeExpression();
    protected virtual TreeElement ParseRangeExpressionInternal();
    public virtual TreeElement ParseRankSpecifier();
    protected virtual CompositeElement HandleErrorInRankSpecifier(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseRecordDeclaration(TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseRecursivePattern();
    public virtual TreeElement ParseRefExpression();
    public abstract virtual TreeElement ParseReferenceExpression();
    protected virtual TreeElement ParseReferenceExpressionInternal();
    public abstract virtual TreeElement ParseReferenceName(TreeElement qualifier);
    protected virtual TreeElement ParseReferenceNameInternal(TreeElement qualifier);
    public virtual TreeElement ParseReferenceTypeConstraint();
    public virtual TreeElement ParseReftypeExpression();
    public virtual TreeElement ParseRefvalueExpression();
    public abstract virtual TreeElement ParseRelationalExpression();
    protected virtual TreeElement ParseRelationalExpressionInternal();
    public virtual TreeElement ParseRelationalPattern();
    public abstract virtual void ParseResourceAcquisition(CompositeElement result);
    protected virtual void ParseResourceAcquisitionInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInResourceAcquisition(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseResourceAcquisitionExpressionsList();
    protected virtual CompositeElement HandleErrorInResourceAcquisitionExpressionsList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseReturnStatement();
    protected virtual CompositeElement HandleErrorInReturnStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseScalarTypeUsage();
    public virtual void ParseSelectionStatementAux(CompositeElement result);
    public abstract virtual TreeElement ParseShiftExpression();
    protected virtual TreeElement ParseShiftExpressionInternal();
    public virtual TreeElement ParseSignOperatorDeclaration(TreeElement attrs, TreeElement mods, TreeElement type, TreeElement owner);
    protected virtual CompositeElement HandleErrorInSignOperatorDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseSignOperatorDeclarator(CompositeElement result, TreeElement t, TreeElement owner);
    protected virtual CompositeElement HandleErrorInSignOperatorDeclarator(CompositeElement result, SyntaxError error);
    public virtual void ParseSignOperatorSign(CompositeElement result);
    public virtual TreeElement ParseSingleVariableDesignation();
    public virtual TreeElement ParseSlicePattern();
    public virtual TreeElement ParseSpecificCatchClause(TreeElement catchKeyword);
    public abstract virtual TreeElement ParseSpreadElement();
    protected virtual TreeElement ParseSpreadElementInternal();
    public virtual TreeElement ParseStackAllocExpression();
    public virtual TreeElement ParseStartRegion(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInStartRegion(CompositeElement result, SyntaxError error);
    [ParsingContextAttribute("4")]
public abstract virtual void ParseStatementAux(CompositeElement result);
    [ParsingContextAttribute("4")]
protected virtual void ParseStatementAuxInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInStatementAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseStatementsOwner();
    public virtual TreeElement ParseStructDeclaration(TreeElement attrs, TreeElement mods);
    public virtual void ParseStructMemberDeclaration(CompositeElement result, TreeElement attrs, TreeElement mods);
    protected virtual CompositeElement HandleErrorInStructMemberDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseStructMemberDeclarationAux(CompositeElement result);
    public virtual TreeElement ParseSubpattern();
    public abstract virtual TreeElement ParseSuppressNullableWarningExpression();
    protected virtual TreeElement ParseSuppressNullableWarningExpressionInternal();
    public virtual TreeElement ParseSwitchBlock();
    protected virtual CompositeElement HandleErrorInSwitchBlock(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseSwitchCaseLabel();
    protected virtual CompositeElement HandleErrorInSwitchCaseLabel(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseSwitchExpression();
    protected virtual TreeElement ParseSwitchExpressionInternal();
    public abstract virtual TreeElement ParseSwitchExpressionArm();
    protected virtual TreeElement ParseSwitchExpressionArmInternal();
    protected virtual CompositeElement HandleErrorInSwitchExpressionArm(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseSwitchGoverningExpression(CompositeElement result);
    protected virtual void ParseSwitchGoverningExpressionInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInSwitchGoverningExpression(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseSwitchSection();
    protected virtual TreeElement ParseSwitchSectionInternal();
    public virtual TreeElement ParseSwitchStatement();
    protected virtual CompositeElement HandleErrorInSwitchStatement(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseTheFMPIDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t);
    protected virtual void ParseTheFMPIDeclarationAuxInternal(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t);
    protected virtual CompositeElement HandleErrorInTheFMPIDeclarationAux(CompositeElement result, SyntaxError error);
    public virtual void ParseTheFMPIDeclarationAuxError(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t, TreeElement id);
    public virtual void ParseTheFMPIODeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods);
    public abstract virtual void ParseTheFMPIOorIdentifierDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods);
    protected virtual void ParseTheFMPIOorIdentifierDeclarationAuxInternal(CompositeElement result, TreeElement attrs, TreeElement mods);
    public virtual void ParseTheMPDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t, TreeElement owner, TreeElement name);
    public virtual void ParseTheMPIDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t, TreeElement id);
    protected virtual CompositeElement HandleErrorInTheMPIDeclarationAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseThisExpression();
    public virtual TreeElement ParseThrowExpression();
    public virtual void ParseThrowOrRefExpression(CompositeElement result);
    public virtual void ParseThrowOrRefExpressionBody(CompositeElement result);
    public virtual TreeElement ParseThrowStatement();
    protected virtual CompositeElement HandleErrorInThrowStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseTopLevelCode();
    protected virtual TreeElement ParseTopLevelCodeInternal();
    protected virtual CompositeElement HandleErrorInTopLevelCode(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTryStatement();
    protected virtual CompositeElement HandleErrorInTryStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseTupleComponent();
    protected virtual TreeElement ParseTupleComponentInternal();
    protected virtual CompositeElement HandleErrorInTupleComponent(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTupleComponentList();
    public virtual TreeElement ParseTupleExpression();
    public virtual TreeElement ParseTupleTypeComponent();
    public virtual TreeElement ParseTupleTypeComponentList();
    protected virtual CompositeElement HandleErrorInTupleTypeComponentList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTupleTypeUsage();
    public virtual TreeElement ParseTypeArgumentList();
    protected virtual CompositeElement HandleErrorInTypeArgumentList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeConstraint();
    public virtual void ParseTypeDeclarationAux(CompositeElement result);
    public virtual void ParseTypeDeclarationAuxError(CompositeElement result, TreeElement attrs, TreeElement mods);
    protected virtual CompositeElement HandleErrorInTypeDeclarationAuxError(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeMemberArglistParameterDeclaration(TreeElement attrs);
    protected virtual CompositeElement HandleErrorInTypeMemberArglistParameterDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseTypeMemberModifier(CompositeElement result);
    public abstract virtual TreeElement ParseTypeMemberRegularParameterDeclaration(TreeElement attrs);
    protected virtual TreeElement ParseTypeMemberRegularParameterDeclarationInternal(TreeElement attrs);
    protected virtual CompositeElement HandleErrorInTypeMemberRegularParameterDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseTypeName(CompositeElement result);
    public virtual TreeElement ParseTypeParameterConstraint();
    public virtual TreeElement ParseTypeParameterConstraintsClause();
    protected virtual CompositeElement HandleErrorInTypeParameterConstraintsClause(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeParameterOfLocalFunctionDeclaration();
    public virtual TreeElement ParseTypeParameterOfLocalFunctionList();
    protected virtual CompositeElement HandleErrorInTypeParameterOfLocalFunctionList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeParameterOfMethodDeclaration();
    public virtual TreeElement ParseTypeParameterOfMethodList();
    protected virtual CompositeElement HandleErrorInTypeParameterOfMethodList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeParameterOfTypeDeclaration();
    public virtual TreeElement ParseTypeParameterOfTypeList();
    protected virtual CompositeElement HandleErrorInTypeParameterOfTypeList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeParameterReference();
    [ParsingContextAttribute("5")]
public virtual TreeElement ParseTypePattern();
    public virtual TreeElement ParseTypeUsage();
    public abstract virtual void ParseTypeUsageInStackAlloc(CompositeElement result);
    protected virtual void ParseTypeUsageInStackAllocInternal(CompositeElement result);
    public virtual TreeElement ParseTypeofExpression();
    public virtual TreeElement ParseUnaryExpression();
    public virtual TreeElement ParseUnaryOperatorExpression();
    public virtual TreeElement ParseUncheckedExpression();
    public virtual TreeElement ParseUncheckedStatement();
    protected virtual CompositeElement HandleErrorInUncheckedStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseUndefDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInUndefDirective(CompositeElement result, SyntaxError error);
    public virtual void ParseUnfinishedLocalVariableDeclaration(CompositeElement result);
    public virtual TreeElement ParseUnsafeCodeAddressOfExpression();
    public virtual TreeElement ParseUnsafeCodeFixedPointerDeclaration();
    protected virtual CompositeElement HandleErrorInUnsafeCodeFixedPointerDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseUnsafeCodeFixedPointerInitializer();
    public virtual TreeElement ParseUnsafeCodeFixedStatement();
    protected virtual CompositeElement HandleErrorInUnsafeCodeFixedStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseUnsafeCodePointer();
    public abstract virtual TreeElement ParseUnsafeCodePointerAccessExpression();
    protected virtual TreeElement ParseUnsafeCodePointerAccessExpressionInternal();
    public virtual TreeElement ParseUnsafeCodePointerIndirectionExpression();
    public virtual TreeElement ParseUnsafeCodeSizeOfExpression();
    public virtual TreeElement ParseUnsafeCodeUnsafeStatement();
    protected virtual CompositeElement HandleErrorInUnsafeCodeUnsafeStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseUserTypeUsage();
    public virtual TreeElement ParseUsingAliasDirective(TreeElement globalKeyword, TreeElement usingKeyword, TreeElement staticKeyword, TreeElement unsafeKeyword);
    public virtual TreeElement ParseUsingDirective(TreeElement globalKeyword, TreeElement usingKeyword, TreeElement staticKeyword, TreeElement unsafeKeyword);
    protected virtual CompositeElement HandleErrorInUsingDirective(CompositeElement result, SyntaxError error);
    public virtual void ParseUsingDirectiveAux(CompositeElement result);
    public virtual void ParseUsingDirectiveAuxError(CompositeElement result, TreeElement globalKeyword, TreeElement usingKeyword, TreeElement staticKeyword, TreeElement unsafeKeyword);
    protected virtual CompositeElement HandleErrorInUsingDirectiveAuxError(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseUsingList();
    public virtual TreeElement ParseUsingStatement();
    protected virtual CompositeElement HandleErrorInUsingStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseUsingSymbolDirective(TreeElement globalKeyword, TreeElement usingKeyword, TreeElement staticKeyword, TreeElement unsafeKeyword);
    protected virtual CompositeElement HandleErrorInUsingSymbolDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseValueTypeConstraint();
    public virtual TreeElement ParseVarDeconstructionPattern();
    public virtual TreeElement ParseVarPattern();
    public abstract virtual TreeElement ParseVariableDesignation(TreeElement context);
    protected virtual TreeElement ParseVariableDesignationInternal(TreeElement context);
    public virtual TreeElement ParseVariableInitializer();
    protected virtual CompositeElement HandleErrorInVariableInitializer(CompositeElement result, SyntaxError error);
    public virtual void ParseVariableReference(CompositeElement result);
    public virtual TreeElement ParseWarningAction();
    public virtual TreeElement ParseWarningDirective(TreeElement sharp);
    public virtual TreeElement ParseWarningList();
    public virtual TreeElement ParseWhileStatement();
    protected virtual CompositeElement HandleErrorInWhileStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseWithExpression();
    protected virtual TreeElement ParseWithExpressionInternal();
    public virtual TreeElement ParseWithInitializerAssignment();
    protected virtual CompositeElement HandleErrorInWithInitializerAssignment(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseYieldStatement();
    protected virtual CompositeElement HandleErrorInYieldStatement(CompositeElement result, SyntaxError error);
    protected abstract virtual TreeElement MatchAllowsKeyword();
    protected abstract virtual bool ExpectAllowsKeyword();
    protected abstract virtual TreeElement MatchAndKeyword();
    protected abstract virtual bool ExpectAndKeyword();
    protected abstract virtual TreeElement MatchAsyncKeyword();
    protected abstract virtual bool ExpectAsyncKeyword();
    protected abstract virtual TreeElement MatchRShiftShiftAssign();
    protected abstract virtual bool ExpectRShiftShiftAssign();
    protected abstract virtual TreeElement MatchRShiftAssign();
    protected abstract virtual bool ExpectRShiftAssign();
    protected abstract virtual TreeElement MatchAwaitKeyword();
    protected abstract virtual bool ExpectAwaitKeyword();
    protected abstract virtual TreeElement MatchScopedKeywordInLocalDeclaration();
    protected abstract virtual bool ExpectScopedKeywordInLocalDeclaration();
    protected abstract virtual TreeElement MatchVarKeyword();
    protected abstract virtual bool ExpectVarKeyword();
    protected abstract virtual TreeElement MatchConditionalSymbolName();
    protected abstract virtual bool ExpectConditionalSymbolName();
    protected abstract virtual TreeElement MatchDelegateTypeKeyword();
    protected abstract virtual bool ExpectDelegateTypeKeyword();
    protected abstract virtual TreeElement MatchWhenKeyword();
    protected abstract virtual bool ExpectWhenKeyword();
    protected abstract virtual TreeElement MatchAliasKeyword();
    protected abstract virtual bool ExpectAliasKeyword();
    protected abstract virtual TreeElement MatchScopedKeywordFunctionPointerParameterModifier();
    protected abstract virtual bool ExpectScopedKeywordFunctionPointerParameterModifier();
    protected abstract virtual TreeElement MatchGreater();
    protected abstract virtual bool ExpectGreater();
    protected abstract virtual TreeElement MatchNotKeyword();
    protected abstract virtual bool ExpectNotKeyword();
    protected abstract virtual TreeElement MatchOrKeyword();
    protected abstract virtual bool ExpectOrKeyword();
    protected abstract virtual TreeElement MatchScopedKeywordRegularParameterModifier();
    protected abstract virtual bool ExpectScopedKeywordRegularParameterModifier();
    protected abstract virtual TreeElement MatchIntoKeyword();
    protected abstract virtual bool ExpectIntoKeyword();
    protected abstract virtual TreeElement MatchFromKeyword();
    protected abstract virtual bool ExpectFromKeyword();
    protected abstract virtual TreeElement MatchGroupKeyword();
    protected abstract virtual bool ExpectGroupKeyword();
    protected abstract virtual TreeElement MatchByKeyword();
    protected abstract virtual bool ExpectByKeyword();
    protected abstract virtual TreeElement MatchJoinKeyword();
    protected abstract virtual bool ExpectJoinKeyword();
    protected abstract virtual TreeElement MatchOnKeyword();
    protected abstract virtual bool ExpectOnKeyword();
    protected abstract virtual TreeElement MatchEqualsKeyword();
    protected abstract virtual bool ExpectEqualsKeyword();
    protected abstract virtual TreeElement MatchLetKeyword();
    protected abstract virtual bool ExpectLetKeyword();
    protected abstract virtual TreeElement MatchOrderByKeyword();
    protected abstract virtual bool ExpectOrderByKeyword();
    protected abstract virtual TreeElement MatchAscendingKeyword();
    protected abstract virtual bool ExpectAscendingKeyword();
    protected abstract virtual TreeElement MatchDescendingKeyword();
    protected abstract virtual bool ExpectDescendingKeyword();
    protected abstract virtual TreeElement MatchSelectKeyword();
    protected abstract virtual bool ExpectSelectKeyword();
    protected abstract virtual TreeElement MatchWhereKeyword();
    protected abstract virtual bool ExpectWhereKeyword();
    protected abstract virtual TreeElement MatchRecordKeyword();
    protected abstract virtual bool ExpectRecordKeyword();
    protected abstract virtual TreeElement MatchRShiftShift();
    protected abstract virtual bool ExpectRShiftShift();
    protected abstract virtual TreeElement MatchRShift();
    protected abstract virtual bool ExpectRShift();
    protected abstract virtual TreeElement MatchPartialKeyword();
    protected abstract virtual bool ExpectPartialKeyword();
    protected abstract virtual TreeElement MatchRequiredKeyword();
    protected abstract virtual bool ExpectRequiredKeyword();
    protected abstract virtual TreeElement MatchFileKeyword();
    protected abstract virtual bool ExpectFileKeyword();
    protected abstract virtual TreeElement MatchScopedKeyword();
    protected abstract virtual bool ExpectScopedKeyword();
    protected abstract virtual TreeElement MatchGlobalKeyword();
    protected abstract virtual bool ExpectGlobalKeyword();
    protected abstract virtual TreeElement MatchWithKeyword();
    protected abstract virtual bool ExpectWithKeyword();
    protected abstract virtual TreeElement MatchYieldKeyword();
    protected abstract virtual bool ExpectYieldKeyword();
    protected abstract virtual bool LookaheadExpression();
    protected abstract virtual bool LookaheadRefExpression();
    protected abstract virtual bool LookaheadThrowOrRefExpression();
}
public class JetBrains.ReSharper.Psi.CSharp.Gen.ErrorMessages : object {
    private static string ourMessage_0;
    private static string ourMessage_1;
    private static string ourMessage_2;
    private static string ourMessage_3;
    private static string ourMessage_4;
    private static string ourMessage_5;
    private static string ourMessage_6;
    private static string ourMessage_7;
    private static string ourMessage_8;
    private static string ourMessage_9;
    private static string ourMessage_10;
    private static string ourMessage_11;
    private static string ourMessage_12;
    private static string ourMessage_13;
    private static string ourMessage_14;
    private static string ourMessage_15;
    private static string ourMessage_16;
    private static string ourMessage_17;
    private static string ourMessage_18;
    private static string ourMessage_19;
    private static string ourMessage_20;
    private static string ourMessage_21;
    private static string ourMessage_22;
    private static string ourMessage_23;
    private static string ourMessage_24;
    private static string ourMessage_25;
    private static string ourMessage_26;
    private static string ourMessage_27;
    private static string ourMessage_28;
    private static string ourMessage_29;
    private static string ourMessage_30;
    private static string ourMessage_31;
    private static string ourMessage_32;
    private static string ourMessage_33;
    private static string ourMessage_34;
    private static string ourMessage_35;
    private static string ourMessage_36;
    private static string ourMessage_37;
    private static string ourMessage_38;
    private static string ourMessage_39;
    private static string ourMessage_40;
    private static string ourMessage_41;
    private static string ourMessage_42;
    private static string ourMessage_43;
    private static string ourMessage_44;
    private static string ourMessage_45;
    private static string ourMessage_46;
    private static string ourMessage_47;
    private static string ourMessage_48;
    private static string ourMessage_49;
    private static string ourMessage_50;
    private static string ourMessage_51;
    private static string ourMessage_52;
    private static string ourMessage_53;
    private static string ourMessage_54;
    private static string ourMessage_55;
    private static string ourMessage_56;
    private static string ourMessage_57;
    private static string ourMessage_58;
    private static string ourMessage_59;
    private static string ourMessage_60;
    private static string ourMessage_61;
    private static string ourMessage_62;
    private static string ourMessage_63;
    private static string ourMessage_64;
    private static string ourMessage_65;
    private static string ourMessage_66;
    private static string ourMessage_67;
    private static string ourMessage_68;
    private static string ourMessage_69;
    private static string ourMessage_70;
    private static string ourMessage_71;
    private static string ourMessage_72;
    private static string ourMessage_73;
    private static string ourMessage_74;
    private static string ourMessage_75;
    private static string ourMessage_76;
    private static string ourMessage_77;
    private static string ourMessage_78;
    private static string ourMessage_79;
    private static string ourMessage_80;
    private static string ourMessage_81;
    private static string ourMessage_82;
    private static string ourMessage_83;
    private static string ourMessage_84;
    private static string ourMessage_85;
    private static string ourMessage_86;
    private static string ourMessage_87;
    private static string ourMessage_88;
    private static string ourMessage_89;
    private static string ourMessage_90;
    private static string ourMessage_91;
    private static string ourMessage_92;
    private static string ourMessage_93;
    private static string ourMessage_94;
    private static string ourMessage_95;
    private static string ourMessage_96;
    private static string ourMessage_97;
    private static string ourMessage_98;
    private static string ourMessage_99;
    private static string ourMessage_100;
    private static string ourMessage_101;
    private static string ourMessage_102;
    private static string ourMessage_103;
    private static string ourMessage_104;
    private static string ourMessage_105;
    private static string ourMessage_106;
    private static string ourMessage_107;
    private static string ourMessage_108;
    private static string ourMessage_109;
    private static string ourMessage_110;
    private static string ourMessage_111;
    private static string ourMessage_112;
    private static string ourMessage_113;
    private static string ourMessage_114;
    private static string ourMessage_115;
    private static string ourMessage_116;
    private static string ourMessage_117;
    private static string ourMessage_118;
    private static string ourMessage_119;
    private static string ourMessage_120;
    private static string ourMessage_121;
    private static string ourMessage_122;
    private static string ourMessage_123;
    private static string ourMessage_124;
    private static string ourMessage_125;
    private static string ourMessage_126;
    private static string ourMessage_127;
    private static string ourMessage_128;
    private static string ourMessage_129;
    private static string ourMessage_130;
    private static string ourMessage_131;
    private static string ourMessage_132;
    private static string ourMessage_133;
    private static string ourMessage_134;
    private static string ourMessage_135;
    private static string ourMessage_136;
    private static string ourMessage_137;
    private static string ourMessage_138;
    private static string ourMessage_139;
    private static string ourMessage_140;
    private static string ourMessage_141;
    private static string ourMessage_142;
    private static string ourMessage_143;
    private static string ourMessage_144;
    private static string ourMessage_145;
    private static string ourMessage_146;
    private static string ourMessage_147;
    private static string ourMessage_148;
    private static string ourMessage_149;
    private static string ourMessage_150;
    private static string ourMessage_151;
    private static string ourMessage_152;
    private static string ourMessage_153;
    private static string ourMessage_154;
    private static string ourMessage_155;
    private static string ourMessage_156;
    private static string ourMessage_157;
    private static string ourMessage_158;
    private static string ourMessage_159;
    private static string ourMessage_160;
    private static string ourMessage_161;
    private static string ourMessage_162;
    private static string ourMessage_163;
    private static string ourMessage_164;
    private static string ourMessage_165;
    private static string ourMessage_166;
    private static string ourMessage_167;
    private static string ourMessage_168;
    private static string ourMessage_169;
    private static string ourMessage_170;
    private static string ourMessage_171;
    private static string ourMessage_172;
    private static string ourMessage_173;
    private static string ourMessage_174;
    private static string ourMessage_175;
    private static string ourMessage_176;
    private static string ourMessage_177;
    private static string ourMessage_178;
    private static string ourMessage_179;
    private static string ourMessage_180;
    private static string ourMessage_181;
    private static string ourMessage_182;
    private static string ourMessage_183;
    private static string ourMessage_184;
    private static string ourMessage_185;
    private static string ourMessage_186;
    private static string ourMessage_187;
    private static string ourMessage_188;
    private static string ourMessage_189;
    private static string ourMessage_190;
    private static string ourMessage_191;
    private static string ourMessage_192;
    private static string ourMessage_193;
    private static string ourMessage_194;
    private static string ourMessage_195;
    private static string ourMessage_196;
    private static string ourMessage_197;
    private static string ourMessage_198;
    private static string ourMessage_199;
    private static string ourMessage_200;
    private static string ourMessage_201;
    private static string ourMessage_202;
    private static string ourMessage_203;
    private static string ourMessage_204;
    private static string ourMessage_205;
    private static string ourMessage_206;
    private static string ourMessage_207;
    private static string ourMessage_208;
    private static string ourMessage_209;
    private static string ourMessage_210;
    private static string ourMessage_211;
    private static string ourMessage_212;
    private static string ourMessage_213;
    private static string ourMessage_214;
    private static string ourMessage_215;
    private static string ourMessage_216;
    private static string ourMessage_217;
    private static string ourMessage_218;
    private static string ourMessage_219;
    private static string ourMessage_220;
    private static string ourMessage_221;
    private static string ourMessage_222;
    private static string ourMessage_223;
    private static string ourMessage_224;
    private static string ourMessage_225;
    private static string ourMessage_226;
    private static string ourMessage_227;
    private static string ourMessage_228;
    private static string ourMessage_229;
    private static string ourMessage_230;
    private static string ourMessage_231;
    private static string ourMessage_232;
    private static string ourMessage_233;
    private static string ourMessage_234;
    private static string ourMessage_235;
    private static string ourMessage_236;
    private static string ourMessage_237;
    private static string ourMessage_238;
    private static string ourMessage_239;
    private static string ourMessage_240;
    private static string ourMessage_241;
    private static string ourMessage_242;
    private static string ourMessage_243;
    private static string ourMessage_244;
    private static string ourMessage_245;
    private static string ourMessage_246;
    private static string ourMessage_247;
    private static string ourMessage_248;
    private static string ourMessage_249;
    private static string ourMessage_250;
    private static string ourMessage_251;
    private static string ourMessage_252;
    private static string ourMessage_253;
    private static string ourMessage_254;
    private static string ourMessage_255;
    private static string ourMessage_256;
    private static string ourMessage_257;
    private static string ourMessage_258;
    private static string ourMessage_259;
    private static string ourMessage_260;
    private static string ourMessage_261;
    private static string ourMessage_262;
    private static string ourMessage_263;
    private static string ourMessage_264;
    private static string ourMessage_265;
    private static string ourMessage_266;
    private static string ourMessage_267;
    private static string ourMessage_268;
    private static string ourMessage_269;
    private static string ourMessage_270;
    private static string ourMessage_271;
    private static string ourMessage_272;
    private static string ourMessage_273;
    private static string ourMessage_274;
    private static string ourMessage_275;
    private static string ourMessage_276;
    public static string GetErrorMessage0();
    public static string GetErrorMessage1();
    public static string GetErrorMessage2();
    public static string GetErrorMessage3();
    public static string GetErrorMessage4();
    public static string GetErrorMessage5();
    public static string GetErrorMessage6();
    public static string GetErrorMessage7();
    public static string GetErrorMessage8();
    public static string GetErrorMessage9();
    public static string GetErrorMessage10();
    public static string GetErrorMessage11();
    public static string GetErrorMessage12();
    public static string GetErrorMessage13();
    public static string GetErrorMessage14();
    public static string GetErrorMessage15();
    public static string GetErrorMessage16();
    public static string GetErrorMessage17();
    public static string GetErrorMessage18();
    public static string GetErrorMessage19();
    public static string GetErrorMessage20();
    public static string GetErrorMessage21();
    public static string GetErrorMessage22();
    public static string GetErrorMessage23();
    public static string GetErrorMessage24();
    public static string GetErrorMessage25();
    public static string GetErrorMessage26();
    public static string GetErrorMessage27();
    public static string GetErrorMessage28();
    public static string GetErrorMessage29();
    public static string GetErrorMessage30();
    public static string GetErrorMessage31();
    public static string GetErrorMessage32();
    public static string GetErrorMessage33();
    public static string GetErrorMessage34();
    public static string GetErrorMessage35();
    public static string GetErrorMessage36();
    public static string GetErrorMessage37();
    public static string GetErrorMessage38();
    public static string GetErrorMessage39();
    public static string GetErrorMessage40();
    public static string GetErrorMessage41();
    public static string GetErrorMessage42();
    public static string GetErrorMessage43();
    public static string GetErrorMessage44();
    public static string GetErrorMessage45();
    public static string GetErrorMessage46();
    public static string GetErrorMessage47();
    public static string GetErrorMessage48();
    public static string GetErrorMessage49();
    public static string GetErrorMessage50();
    public static string GetErrorMessage51();
    public static string GetErrorMessage52();
    public static string GetErrorMessage53();
    public static string GetErrorMessage54();
    public static string GetErrorMessage55();
    public static string GetErrorMessage56();
    public static string GetErrorMessage57();
    public static string GetErrorMessage58();
    public static string GetErrorMessage59();
    public static string GetErrorMessage60();
    public static string GetErrorMessage61();
    public static string GetErrorMessage62();
    public static string GetErrorMessage63();
    public static string GetErrorMessage64();
    public static string GetErrorMessage65();
    public static string GetErrorMessage66();
    public static string GetErrorMessage67();
    public static string GetErrorMessage68();
    public static string GetErrorMessage69();
    public static string GetErrorMessage70();
    public static string GetErrorMessage71();
    public static string GetErrorMessage72();
    public static string GetErrorMessage73();
    public static string GetErrorMessage74();
    public static string GetErrorMessage75();
    public static string GetErrorMessage76();
    public static string GetErrorMessage77();
    public static string GetErrorMessage78();
    public static string GetErrorMessage79();
    public static string GetErrorMessage80();
    public static string GetErrorMessage81();
    public static string GetErrorMessage82();
    public static string GetErrorMessage83();
    public static string GetErrorMessage84();
    public static string GetErrorMessage85();
    public static string GetErrorMessage86();
    public static string GetErrorMessage87();
    public static string GetErrorMessage88();
    public static string GetErrorMessage89();
    public static string GetErrorMessage90();
    public static string GetErrorMessage91();
    public static string GetErrorMessage92();
    public static string GetErrorMessage93();
    public static string GetErrorMessage94();
    public static string GetErrorMessage95();
    public static string GetErrorMessage96();
    public static string GetErrorMessage97();
    public static string GetErrorMessage98();
    public static string GetErrorMessage99();
    public static string GetErrorMessage100();
    public static string GetErrorMessage101();
    public static string GetErrorMessage102();
    public static string GetErrorMessage103();
    public static string GetErrorMessage104();
    public static string GetErrorMessage105();
    public static string GetErrorMessage106();
    public static string GetErrorMessage107();
    public static string GetErrorMessage108();
    public static string GetErrorMessage109();
    public static string GetErrorMessage110();
    public static string GetErrorMessage111();
    public static string GetErrorMessage112();
    public static string GetErrorMessage113();
    public static string GetErrorMessage114();
    public static string GetErrorMessage115();
    public static string GetErrorMessage116();
    public static string GetErrorMessage117();
    public static string GetErrorMessage118();
    public static string GetErrorMessage119();
    public static string GetErrorMessage120();
    public static string GetErrorMessage121();
    public static string GetErrorMessage122();
    public static string GetErrorMessage123();
    public static string GetErrorMessage124();
    public static string GetErrorMessage125();
    public static string GetErrorMessage126();
    public static string GetErrorMessage127();
    public static string GetErrorMessage128();
    public static string GetErrorMessage129();
    public static string GetErrorMessage130();
    public static string GetErrorMessage131();
    public static string GetErrorMessage132();
    public static string GetErrorMessage133();
    public static string GetErrorMessage134();
    public static string GetErrorMessage135();
    public static string GetErrorMessage136();
    public static string GetErrorMessage137();
    public static string GetErrorMessage138();
    public static string GetErrorMessage139();
    public static string GetErrorMessage140();
    public static string GetErrorMessage141();
    public static string GetErrorMessage142();
    public static string GetErrorMessage143();
    public static string GetErrorMessage144();
    public static string GetErrorMessage145();
    public static string GetErrorMessage146();
    public static string GetErrorMessage147();
    public static string GetErrorMessage148();
    public static string GetErrorMessage149();
    public static string GetErrorMessage150();
    public static string GetErrorMessage151();
    public static string GetErrorMessage152();
    public static string GetErrorMessage153();
    public static string GetErrorMessage154();
    public static string GetErrorMessage155();
    public static string GetErrorMessage156();
    public static string GetErrorMessage157();
    public static string GetErrorMessage158();
    public static string GetErrorMessage159();
    public static string GetErrorMessage160();
    public static string GetErrorMessage161();
    public static string GetErrorMessage162();
    public static string GetErrorMessage163();
    public static string GetErrorMessage164();
    public static string GetErrorMessage165();
    public static string GetErrorMessage166();
    public static string GetErrorMessage167();
    public static string GetErrorMessage168();
    public static string GetErrorMessage169();
    public static string GetErrorMessage170();
    public static string GetErrorMessage171();
    public static string GetErrorMessage172();
    public static string GetErrorMessage173();
    public static string GetErrorMessage174();
    public static string GetErrorMessage175();
    public static string GetErrorMessage176();
    public static string GetErrorMessage177();
    public static string GetErrorMessage178();
    public static string GetErrorMessage179();
    public static string GetErrorMessage180();
    public static string GetErrorMessage181();
    public static string GetErrorMessage182();
    public static string GetErrorMessage183();
    public static string GetErrorMessage184();
    public static string GetErrorMessage185();
    public static string GetErrorMessage186();
    public static string GetErrorMessage187();
    public static string GetErrorMessage188();
    public static string GetErrorMessage189();
    public static string GetErrorMessage190();
    public static string GetErrorMessage191();
    public static string GetErrorMessage192();
    public static string GetErrorMessage193();
    public static string GetErrorMessage194();
    public static string GetErrorMessage195();
    public static string GetErrorMessage196();
    public static string GetErrorMessage197();
    public static string GetErrorMessage198();
    public static string GetErrorMessage199();
    public static string GetErrorMessage200();
    public static string GetErrorMessage201();
    public static string GetErrorMessage202();
    public static string GetErrorMessage203();
    public static string GetErrorMessage204();
    public static string GetErrorMessage205();
    public static string GetErrorMessage206();
    public static string GetErrorMessage207();
    public static string GetErrorMessage208();
    public static string GetErrorMessage209();
    public static string GetErrorMessage210();
    public static string GetErrorMessage211();
    public static string GetErrorMessage212();
    public static string GetErrorMessage213();
    public static string GetErrorMessage214();
    public static string GetErrorMessage215();
    public static string GetErrorMessage216();
    public static string GetErrorMessage217();
    public static string GetErrorMessage218();
    public static string GetErrorMessage219();
    public static string GetErrorMessage220();
    public static string GetErrorMessage221();
    public static string GetErrorMessage222();
    public static string GetErrorMessage223();
    public static string GetErrorMessage224();
    public static string GetErrorMessage225();
    public static string GetErrorMessage226();
    public static string GetErrorMessage227();
    public static string GetErrorMessage228();
    public static string GetErrorMessage229();
    public static string GetErrorMessage230();
    public static string GetErrorMessage231();
    public static string GetErrorMessage232();
    public static string GetErrorMessage233();
    public static string GetErrorMessage234();
    public static string GetErrorMessage235();
    public static string GetErrorMessage236();
    public static string GetErrorMessage237();
    public static string GetErrorMessage238();
    public static string GetErrorMessage239();
    public static string GetErrorMessage240();
    public static string GetErrorMessage241();
    public static string GetErrorMessage242();
    public static string GetErrorMessage243();
    public static string GetErrorMessage244();
    public static string GetErrorMessage245();
    public static string GetErrorMessage246();
    public static string GetErrorMessage247();
    public static string GetErrorMessage248();
    public static string GetErrorMessage249();
    public static string GetErrorMessage250();
    public static string GetErrorMessage251();
    public static string GetErrorMessage252();
    public static string GetErrorMessage253();
    public static string GetErrorMessage254();
    public static string GetErrorMessage255();
    public static string GetErrorMessage256();
    public static string GetErrorMessage257();
    public static string GetErrorMessage258();
    public static string GetErrorMessage259();
    public static string GetErrorMessage260();
    public static string GetErrorMessage261();
    public static string GetErrorMessage262();
    public static string GetErrorMessage263();
    public static string GetErrorMessage264();
    public static string GetErrorMessage265();
    public static string GetErrorMessage266();
    public static string GetErrorMessage267();
    public static string GetErrorMessage268();
    public static string GetErrorMessage269();
    public static string GetErrorMessage270();
    public static string GetErrorMessage271();
    public static string GetErrorMessage272();
    public static string GetErrorMessage273();
    public static string GetErrorMessage274();
    public static string GetErrorMessage275();
    public static string GetErrorMessage276();
}
public static class JetBrains.ReSharper.Psi.CSharp.Gen.TokenBitsets : object {
    public static NodeTypeSet TokenBitset_0;
    public static NodeTypeSet TokenBitset_1;
    public static NodeTypeSet TokenBitset_2;
    public static NodeTypeSet TokenBitset_3;
    public static NodeTypeSet TokenBitset_4;
    public static NodeTypeSet TokenBitset_5;
    public static NodeTypeSet TokenBitset_6;
    public static NodeTypeSet TokenBitset_7;
    public static NodeTypeSet TokenBitset_8;
    public static NodeTypeSet TokenBitset_9;
    public static NodeTypeSet TokenBitset_10;
    public static NodeTypeSet TokenBitset_11;
    public static NodeTypeSet TokenBitset_12;
    public static NodeTypeSet TokenBitset_13;
    public static NodeTypeSet TokenBitset_14;
    public static NodeTypeSet TokenBitset_15;
    public static NodeTypeSet TokenBitset_16;
    public static NodeTypeSet TokenBitset_17;
    public static NodeTypeSet TokenBitset_18;
    public static NodeTypeSet TokenBitset_19;
    public static NodeTypeSet TokenBitset_20;
    public static NodeTypeSet TokenBitset_21;
    public static NodeTypeSet TokenBitset_22;
    public static NodeTypeSet TokenBitset_23;
    public static NodeTypeSet TokenBitset_24;
    public static NodeTypeSet TokenBitset_25;
    public static NodeTypeSet TokenBitset_26;
    public static NodeTypeSet TokenBitset_27;
    public static NodeTypeSet TokenBitset_28;
    public static NodeTypeSet TokenBitset_29;
    public static NodeTypeSet TokenBitset_30;
    public static NodeTypeSet TokenBitset_31;
    public static NodeTypeSet TokenBitset_32;
    public static NodeTypeSet TokenBitset_33;
    public static NodeTypeSet TokenBitset_34;
    public static NodeTypeSet TokenBitset_35;
    public static NodeTypeSet TokenBitset_36;
    public static NodeTypeSet TokenBitset_37;
    public static NodeTypeSet TokenBitset_38;
    public static NodeTypeSet TokenBitset_39;
    public static NodeTypeSet TokenBitset_40;
    public static NodeTypeSet TokenBitset_41;
    public static NodeTypeSet TokenBitset_42;
    public static NodeTypeSet TokenBitset_43;
    public static NodeTypeSet TokenBitset_44;
    public static NodeTypeSet TokenBitset_45;
    public static NodeTypeSet TokenBitset_46;
    public static NodeTypeSet TokenBitset_47;
    public static NodeTypeSet TokenBitset_48;
    public static NodeTypeSet TokenBitset_49;
    public static NodeTypeSet TokenBitset_50;
    public static NodeTypeSet TokenBitset_51;
    public static NodeTypeSet TokenBitset_52;
    public static NodeTypeSet TokenBitset_53;
    public static NodeTypeSet TokenBitset_54;
    public static NodeTypeSet TokenBitset_55;
    public static NodeTypeSet TokenBitset_56;
    public static NodeTypeSet TokenBitset_57;
    public static NodeTypeSet TokenBitset_58;
    public static NodeTypeSet TokenBitset_59;
    public static NodeTypeSet ElementBitset_0;
    public static NodeTypeSet ElementBitset_1;
    public static NodeTypeSet ElementBitset_2;
    public static NodeTypeSet ElementBitset_3;
    public static NodeTypeSet ElementBitset_4;
    public static NodeTypeSet ElementBitset_5;
    public static NodeTypeSet ElementBitset_6;
    public static NodeTypeSet ElementBitset_7;
    public static NodeTypeSet ElementBitset_8;
    public static NodeTypeSet ElementBitset_9;
    public static NodeTypeSet ElementBitset_10;
    public static NodeTypeSet ElementBitset_11;
    public static NodeTypeSet ElementBitset_12;
    public static NodeTypeSet ElementBitset_13;
    public static NodeTypeSet ElementBitset_14;
    public static NodeTypeSet ElementBitset_15;
    public static NodeTypeSet ElementBitset_16;
    public static NodeTypeSet ElementBitset_17;
    public static NodeTypeSet ElementBitset_18;
    public static NodeTypeSet ElementBitset_19;
    public static NodeTypeSet ElementBitset_20;
    public static NodeTypeSet ElementBitset_21;
    public static NodeTypeSet ElementBitset_22;
    public static NodeTypeSet ElementBitset_23;
    public static NodeTypeSet ElementBitset_24;
    public static NodeTypeSet ElementBitset_25;
    public static NodeTypeSet ElementBitset_26;
    public static NodeTypeSet ElementBitset_27;
    public static NodeTypeSet ElementBitset_28;
    public static NodeTypeSet ElementBitset_29;
    private static TokenBitsets();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.GeneratedCode.CSharpGeneratedCodeRegionChecker : GeneratedCodeRegionChecker {
    public virtual IGeneratedCodeRegionDetector CreateDetector(IContextBoundSettingsStore settingsStore);
}
internal class JetBrains.ReSharper.Psi.CSharp.GeneratedCode.CSharpGeneratedRegionDetector : object {
    [NotNullAttribute]
private HashSet`1<string> mySkipRegions;
    private int myInGeneratedCode;
    public bool InGeneratedCode { get; }
    public CSharpGeneratedRegionDetector(IContextBoundSettingsStore settingsStore);
    public sealed virtual bool get_InGeneratedCode();
    public sealed virtual void Process(ITreeNode node);
    public sealed virtual void Reset();
    private bool IsRegionToSkip(string regionName);
}
public interface JetBrains.ReSharper.Psi.CSharp.ICSharpAnonymousType {
    [NotNullAttribute]
public IList`1<ICSharpAnonymousTypeProperty> Properties { get; }
    public abstract virtual IList`1<ICSharpAnonymousTypeProperty> get_Properties();
}
public interface JetBrains.ReSharper.Psi.CSharp.ICSharpArgumentInfo {
    [CanBeNullAttribute]
public ICSharpInvocationInfo Invocation { get; }
    [CanBeNullAttribute]
public CSharpParameterInstance MatchingParameter { get; }
    public ParameterKind Kind { get; }
    public bool IsNamedArgument { get; }
    [CanBeNullAttribute]
public string ArgumentName { get; }
    [CanBeNullAttribute]
public IManagedConvertible ManagedConvertible { get; }
    public abstract virtual ICSharpInvocationInfo get_Invocation();
    public abstract virtual CSharpParameterInstance get_MatchingParameter();
    public abstract virtual ParameterKind get_Kind();
    public abstract virtual bool get_IsNamedArgument();
    public abstract virtual string get_ArgumentName();
    public abstract virtual IManagedConvertible get_ManagedConvertible();
    [NotNullAttribute]
public abstract virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo {
    [NotNullAttribute]
public IList`1<ICSharpArgumentInfo> Arguments { get; }
    [NotNullAttribute]
public IList`1<IType> TypeArguments { get; }
    [CanBeNullAttribute]
public ICSharpArgumentInfo ExtensionQualifier { get; }
    [CanBeNullAttribute]
public ICSharpInvocationReference Reference { get; }
    public abstract virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    public abstract virtual IList`1<IType> get_TypeArguments();
    public abstract virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public abstract virtual ICSharpInvocationReference get_Reference();
    public abstract virtual CSharpLanguageLevel GetLanguageVersion();
    public abstract virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    [NotNullAttribute]
public abstract virtual string Dump();
}
public interface JetBrains.ReSharper.Psi.CSharp.ICSharpPsiSourceFileProperties {
    public bool AllowUnsafeCode { get; }
    public int WarningLevel { get; }
    public bool XmlDocGenerationEnabled { get; }
    public bool TreatWarningsAsErrors { get; }
    public bool CheckOverflows { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> SuppressWarnings { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> WarningsAsErrors { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> WarningsNotAsErrors { get; }
    public bool IsNestedPreImportedNamespaces { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> InterceptorsPreviewNamespaces { get; }
    public abstract virtual bool get_AllowUnsafeCode();
    public abstract virtual int get_WarningLevel();
    public abstract virtual bool get_XmlDocGenerationEnabled();
    public abstract virtual bool get_TreatWarningsAsErrors();
    public abstract virtual bool get_CheckOverflows();
    public abstract virtual IReadOnlyCollection`1<string> get_SuppressWarnings();
    public abstract virtual IReadOnlyCollection`1<string> get_WarningsAsErrors();
    public abstract virtual IReadOnlyCollection`1<string> get_WarningsNotAsErrors();
    public abstract virtual bool get_IsNestedPreImportedNamespaces();
    public abstract virtual IReadOnlyCollection`1<string> get_InterceptorsPreviewNamespaces();
}
public interface JetBrains.ReSharper.Psi.CSharp.ICSharpStatementsRange {
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CSharp.ICSharpTypeConstraintsVerifier {
    public IPsiModule PsiModule { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public ICSharpTypeConversionRule TypeConversionRule { get; }
    public abstract virtual IPsiModule get_PsiModule();
    public abstract virtual CSharpLanguageLevel get_LanguageLevel();
    public abstract virtual ICSharpTypeConversionRule get_TypeConversionRule();
    [PureAttribute]
public abstract virtual TypeArgumentValidationResult ValidateTypeArgument(ITypeParameter typeParameter, ISubstitution constraintsSubstitution, IType typeArgument, bool isExplicitTypeArgument, bool checkNullability);
}
public interface JetBrains.ReSharper.Psi.CSharp.IExpressionArgumentInfo {
    [CanBeNullAttribute]
public ICSharpExpression Expression { get; }
    public abstract virtual ICSharpExpression get_Expression();
}
[ZoneDefinitionAttribute]
public interface JetBrains.ReSharper.Psi.CSharp.ILanguageCSharpZone {
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.AnonymousTypeBase : object {
    public IList`1<ICSharpAnonymousTypeProperty> Properties { get; }
    public IList`1<AnonymousTypeDescriptor> TypeDescriptor { get; }
    public bool CaseSensitive { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public abstract virtual IList`1<ICSharpAnonymousTypeProperty> get_Properties();
    public abstract virtual IList`1<AnonymousTypeDescriptor> get_TypeDescriptor();
    public sealed virtual bool get_CaseSensitive();
    public sealed virtual bool get_IsOpenType();
    public sealed virtual TypeClassification get_Classify();
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public abstract virtual ITypePointer CreatePointer();
    public abstract virtual IPsiModule get_Module();
    public virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public abstract virtual IType WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IType WithNullableAnnotation(NullableAnnotation annotation);
    public abstract virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
    public sealed virtual void Accept(TypeVisitor typeVisitor);
    public sealed virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IDeclaredType GetScalarType();
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    private bool IsConvertible(ICSharpAnonymousType otherAnonymousType);
    public sealed virtual bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    [DebuggerStepThroughAttribute]
public sealed virtual IType ToIType();
    public sealed virtual IPsiServices GetPsiServices();
    public virtual bool Equals(object obj);
    public virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public virtual int GetHashCode();
    public abstract virtual IAnonymousType TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual string ToString();
    private string get_DebuggerDisplay();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.AnonymousTypeProperty : AnonymousTypePropertyBase {
    [NotNullAttribute]
private CSharpAnonymousType myAnonymousType;
    private int myIndex;
    public string ShortName { get; }
    public IType Type { get; }
    public ICSharpAnonymousType ContainingType { get; }
    public int Index { get; }
    public AnonymousTypeProperty(CSharpAnonymousType anonymousType, int index);
    public virtual string get_ShortName();
    public virtual IType get_Type();
    public virtual ICSharpAnonymousType get_ContainingType();
    public virtual int get_Index();
    public virtual IAnonymousTypeProperty SetName(string name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.AnonymousTypePropertyBase : object {
    public string ShortName { get; }
    public IType Type { get; }
    public ICSharpAnonymousType ContainingType { get; }
    public int Index { get; }
    public IList`1<AnonymousTypePropertyDescriptor> AnonymousTypePropertyDescriptor { get; }
    private IAnonymousType JetBrains.ReSharper.Psi.IAnonymousTypeProperty.ContainingType { get; }
    public bool CaseSensitiveName { get; }
    [NotNullAttribute]
public string XMLDocId { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual IType get_Type();
    public abstract virtual ICSharpAnonymousType get_ContainingType();
    public abstract virtual int get_Index();
    public sealed virtual IList`1<AnonymousTypePropertyDescriptor> get_AnonymousTypePropertyDescriptor();
    private sealed virtual override IAnonymousType JetBrains.ReSharper.Psi.IAnonymousTypeProperty.get_ContainingType();
    public abstract virtual IAnonymousTypeProperty SetName(string name);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ArglistParameterReference : TreeReferenceBase`1<IArglistExpression> {
    public ArglistParameterReference(IArglistExpression owner);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public virtual string GetName();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.AliasDirectiveCache : SimpleICache`1<Entry> {
    private IPsiFiles myPsiFiles;
    private GlobalUsingsCache myGlobalUsingsCache;
    public AliasDirectiveCache(Lifetime lifetime, IShellLocks locks, IPersistentIndexManager persistentIndexManager, IPsiFiles psiFiles, GlobalUsingsCache globalUsingsCache);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    [PureAttribute]
public sealed virtual IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyDeclaringAlias(string aliasName, Func`2<IPsiSourceFile, bool> sourceFilePredicate);
    [PureAttribute]
public sealed virtual IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyDeclaringAliasesTo(AliasedSymbol aliasedSymbol, Func`2<IPsiSourceFile, bool> sourceFilePredicate);
    public sealed virtual IAliasDirectiveSearcher CreateAliasDirectiveSearcher(ICSharpFile file, bool includeGlobalAliases);
    private static void ProcessScope(ICSharpTypeAndNamespaceHolderDeclaration scope, InfoBuilder& entryBuilder);
    [CompilerGeneratedAttribute]
internal static void <CreateAliasDirectiveSearcher>g__CollectLocalAliases|6_0(ICSharpTypeAndNamespaceHolderDeclaration scope, int level, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <CreateAliasDirectiveSearcher>g__CollectAliasDirective|6_1(IUsingAliasDirective usingAliasDirective, int level, <>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.AliasTable : object {
    [NullableAttribute("2")]
private AliasMap myAliasList;
    public AliasScope StartScope(TreeNodeEnumerable`1<IUsingDirective> imports, ICacheBuilder cacheBuilder);
    public void CollectAliasedTypeNames(string aliasName, FrugalLocalHashSet`1& typeNames);
    private void CollectAliasedTypeNames(AliasMap map, string aliasName, FrugalLocalHashSet`1& typeNames);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.AliasTableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void BuildAttributeNames(AliasTable aliasTable, TreeNodeCollection`1<IAttribute> attributes, FrugalLocalHashSet`1& names);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.AnonymousDelegate : object {
    private static string PARAMETER_NAME_PREFIX;
    [CanBeNullAttribute]
private IReadOnlyList`1<ITypeMember> myMembers;
    [CanBeNullAttribute]
private IMethod myInvokeMethod;
    [NotNullAttribute]
private List`1<AnonymousDelegateParameter> myParameters;
    [NotNullAttribute]
private IType myReturnType;
    private ReferenceKind myReturnKind;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public string XMLDocId { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public ITypeElement ContainingType { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IMethod InvokeMethod { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public AnonymousDelegate(IPsiModule psiModule, ISubstitution substitution, IReadOnlyList`1<IParameter> parameters, IType returnType, ReferenceKind returnKind);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public sealed virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IMethod get_InvokeMethod();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public IType get_ReturnType();
    public ReferenceKind get_ReturnKind();
    public sealed virtual bool Equals(IAnonymousDelegate other, IEqualityComparer`1<IType> typeEqualityComparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.ClassPart : CSharpClassLikeTypePart`1<IClassDeclaration> {
    private MemberPresenceFlag myMembersMask;
    private bool myHasPrimaryConstructor;
    [NotNullAttribute]
private ExtensionMemberInfo[] myExtensionMethodInfos;
    public ExtensionMemberInfo[] ExtensionMemberInfos { get; }
    public IPrimaryConstructor PrimaryConstructor { get; }
    protected CSharpSerializationTag CSharpSerializationTag { get; }
    public ClassPart(IClassDeclaration declaration, AliasTable aliasTable, ICacheBuilder cacheBuilder);
    public ClassPart(IReader reader);
    public virtual ExtensionMemberInfo[] get_ExtensionMemberInfos();
    public virtual HybridCollection`1<ITypeMember> FindExtensionMethod(ExtensionMemberInfo info);
    private static TreeNodeCollection`1<ITypeUsage> GetExtendsList(IClassDeclaration declaration);
    protected virtual void Write(IWriter writer);
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual IDeclaredType GetBaseClassType();
    public sealed virtual IPrimaryConstructor get_PrimaryConstructor();
    public sealed virtual void GetParametersWithSpeculativeFieldsProduced(IList`1<IParameter> parameters, HashSet`1<IParameter> consumer);
    protected virtual CSharpSerializationTag get_CSharpSerializationTag();
    public virtual TypeElement CreateTypeElement();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpAttributesProvider : object {
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IFile ifile);
    public sealed virtual ITreeNode GetAttribute(IAttributeInstance attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpCacheProvider : TreeNodeVisitor {
    private static NodeType[] SPECIAL_NODE_TYPES;
    public string PersistentTreeNodeCacheUniqueId { get; }
    public string TokenCacheUniqueId { get; }
    public string BufferCacheUniqueId { get; }
    public string TreeNodeCacheUniqueId { get; }
    public int NodeTypeCommonShift { get; }
    private static CSharpCacheProvider();
    public sealed virtual Part ReadPart(byte tag, IReader reader);
    public sealed virtual ProjectFilePart LoadProjectFilePart(IPsiSourceFile sourceFile, ProjectFilePartsTree tree, IReader reader);
    [NullableContextAttribute("2")]
public sealed virtual bool NeedCacheUpdate(ITreeNode elementContainingChanges, PsiChangedElementType type);
    public sealed virtual IEnumerable`1<IPsiSourceFile> GetAffectedOnPsiModulePropertiesChange(IPsiModule module);
    public string get_PersistentTreeNodeCacheUniqueId();
    public sealed virtual string get_TokenCacheUniqueId();
    public sealed virtual string get_BufferCacheUniqueId();
    public sealed virtual string get_TreeNodeCacheUniqueId();
    public sealed virtual bool IsShrinkableTreeNode(int childNodeTypeIndex);
    public sealed virtual NodeType GetNodeType(int index);
    public sealed virtual Dictionary`2<int, TokenNodeType> GetIndexToTokenNodeTypeDictionary();
    public sealed virtual Dictionary`2<int, NodeType> GetIndexToNodeTypeDictionary();
    public sealed virtual NodeTypeDictionary`1<int> GetFixedTokenLengthsDictionary();
    public sealed virtual int get_NodeTypeCommonShift();
    public sealed virtual bool IsCacheableInClosedForm(IChameleonNode node);
    public sealed virtual TreeElement CreateClosedChameleonNode(NodeType nodeType, int textLength);
    public sealed virtual TreeElement CreateOpenedChameleonNode(NodeType nodeType);
    public sealed virtual void SerializeMetadata(IFile file, UnsafeWriter bufferWriter);
    public sealed virtual void RestoreMetadata(IFile file, UnsafeReader bufferReader);
    public sealed virtual bool IsInternableToken(TokenNodeType tokenNodeType);
    public sealed virtual bool IsCaseSensitive(IPsiModule module);
    public sealed virtual void BuildCache(IFile file, ICacheBuilder builder);
    public sealed virtual void BuildCache(ISandBox sandBox, ICacheBuilder builder);
    private static ITypeUsage GetThisParameterTypeUsage(IMethodDeclaration methodDeclaration);
    [PureAttribute]
private static int GetExtensionMethodHash(IMethodDeclaration declaration);
    [PureAttribute]
public static bool Matches(ExtensionMemberInfo info, IMethodDeclaration methodDeclaration);
    [PureAttribute]
public static Nullable`1<ExtensionMemberInfo> CalculateExtensionMethodInfo(IMethodDeclaration methodDeclaration, AliasTable aliasTable, TypePart owner);
    [PureAttribute]
private static CandidateType CalculateCandidateType(ITypeUsage typeUsage, ITypeParameterOfMethodList typeParameterOfMethodList, AliasTable aliasTable);
    [PureAttribute]
private static ArrayElementCandidateType GetScalarCandidateType(ITypeUsage typeUsage, ITypeParameterOfMethodList typeParameterOfMethodList, AliasTable aliasTable);
    private static FrugalLocalHashSet`1<string> GetPossibleNames(string shortName, AliasTable aliasTable, bool isNullableTypeUsage);
    [CompilerGeneratedAttribute]
internal static bool <GetPossibleNames>g__TryFindNativeIntegerAlias|38_0(string shortName, String& nativeIntegerAlias);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpClass : Class {
    [NullableAttribute("2")]
public IPrimaryConstructor PrimaryConstructor { get; }
    [NullableContextAttribute("1")]
public CSharpClass(ICSharpClassPart part);
    [NullableContextAttribute("2")]
public sealed virtual IPrimaryConstructor get_PrimaryConstructor();
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyCollection`1<IParameter> GetCapturedParameters(IList`1<IParameter> parameters);
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerable`1<ITypeOwner> JetBrains.ReSharper.Psi.Impl.ITypeElementWithSpeculativeFields.GetOrComputeSpeculativeInstanceFields();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpClassLikeTypePart`1 : CSharpTypePart`1<TClassLikeDeclaration> {
    private String[] myExtendsListShortNames;
    public String[] ExtendsListShortNames { get; }
    protected CSharpClassLikeTypePart`1(TClassLikeDeclaration declaration, TreeNodeCollection`1<ITypeUsage> extendsList, AliasTable aliasTable, ICacheBuilder cacheBuilder);
    protected CSharpClassLikeTypePart`1(IReader reader);
    protected virtual void Write(IWriter writer);
    public sealed virtual String[] get_ExtendsListShortNames();
    public abstract virtual IDeclaredType GetBaseClassType();
    public abstract virtual MemberPresenceFlag GetMemberPresenceFlag();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpClassLikeTypePart`1/<GetTypeMembers>d__8")]
public sealed virtual IEnumerable`1<ITypeMember> GetTypeMembers();
    public sealed virtual IEnumerable`1<IDeclaredType> GetSuperTypes();
    public sealed virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
    protected static MemberPresenceFlag InvestigateMembers(IClassLikeDeclaration declaration, bool isStruct);
    [PureAttribute]
public static bool CanBeRecordCopyConstructor(IConstructorDeclaration constructorDeclaration, Boolean& definitelyCopyConstructor);
    [PureAttribute]
private static bool CheckTypeIs(ITypeUsage typeUsage, TokenNodeType token, IClrTypeName clrName);
    [CompilerGeneratedAttribute]
internal static bool <InvestigateMembers>g__IsNotPublic|11_0(AccessRights accessRights);
    [CompilerGeneratedAttribute]
internal static bool <InvestigateMembers>g__IsOverrideableMember|11_1(ITypeMemberDeclaration typeMemberDeclaration);
    [CompilerGeneratedAttribute]
internal static bool <CanBeRecordCopyConstructor>g__SameTypeParameters|12_0(ITypeArgumentList typeArgumentList, ITypeParameterOfTypeList typeParameterList);
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpCloneableTypeElementPart : object {
    public static int CountCloneableMembers(TreeNodeEnumerable`1<IFieldDeclaration> fieldDeclarations, TreeNodeEnumerable`1<IPropertyDeclaration> propertyDeclarations, TreeNodeEnumerable`1<IEventDeclaration> eventDeclarations);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <CountCloneableMembers>g__MayHaveSideEffects|0_0(IVariableInitializer initializer);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <CountCloneableMembers>g__IsSimpleNameReference|0_1(IReferenceExpression referenceExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpGlobalAliasPart : object {
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CSharpGlobalAliasPart <NextPart>k__BackingField;
    public IPsiSourceFile SourceFile { get; }
    [NullableAttribute("2")]
public CSharpGlobalAliasPart NextPart { get; public set; }
    public CSharpGlobalAliasPart(IPsiSourceFile psiSourceFile);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CSharpGlobalAliasPart get_NextPart();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NextPart(CSharpGlobalAliasPart value);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpInternalsVisibleToProvider : object {
    private static string ShortName;
    public sealed virtual IReadOnlyList`1<string> GetInternalsVisibleToArguments(IFile file);
}
[FlagsAttribute]
internal enum JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpLanguageLevelBorders : Enum {
    public byte value__;
    public static CSharpLanguageLevelBorders None;
    public static CSharpLanguageLevelBorders CSharpBetween8And9;
    public static CSharpLanguageLevelBorders CSharpBetween10And11;
    public static CSharpLanguageLevelBorders All;
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpProjectFilePart : ProjectFilePart {
    private String[] myAttributeNames;
    public String[] AttributeClassNames { get; }
    public CSharpProjectFilePart(ICSharpFile file, AliasTable aliasTable);
    public CSharpProjectFilePart(IPsiSourceFile sourceFile, IReader reader);
    protected virtual void Write(IWriter writer);
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
    public virtual String[] get_AttributeClassNames();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName name);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances();
    [CanBeNullAttribute]
private IFile GetFileForAssemblyAttributesDiscovery();
}
internal enum JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpSerializationTag : Enum {
    public byte value__;
    public static CSharpSerializationTag QUALIFIED_NAMESPACE_PART;
    public static CSharpSerializationTag DECLARED_NAMESPACE_PART;
    public static CSharpSerializationTag CLASS_PART;
    public static CSharpSerializationTag STRUCT_PART;
    public static CSharpSerializationTag ENUM_PART;
    public static CSharpSerializationTag DELEGATE_PART;
    public static CSharpSerializationTag INTERFACE_PART;
    public static CSharpSerializationTag RECORD_PART;
    public static CSharpSerializationTag TOP_LEVEL_CODE_PART;
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpSourceExtensionsMembersIndex : SourceExtensionMembersIndex {
    [NotNullAttribute]
private HashSet`1<IPsiModule> myPsiModules;
    [CanBeNullAttribute]
private GlobalUsingsCache myGlobalUsingsCache;
    public virtual void AddPsiModule(IPsiModule psiModule);
    protected virtual void CollectPossibleNames(ITypeElement typeElement, List`1<string> consumer);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpStruct : Struct {
    [NullableAttribute("2")]
public IPrimaryConstructor PrimaryConstructor { get; }
    [NullableContextAttribute("1")]
public CSharpStruct(ICSharpStructPart part);
    [NullableContextAttribute("2")]
public sealed virtual IPrimaryConstructor get_PrimaryConstructor();
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyCollection`1<IParameter> GetCapturedParameters(IList`1<IParameter> parameters);
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerable`1<ITypeOwner> JetBrains.ReSharper.Psi.Impl.ITypeElementWithSpeculativeFields.GetOrComputeSpeculativeInstanceFields();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpTypePart`1 : TypePartImplBase`1<T> {
    private static int TypeParameterConstraintFlagsLength;
    private static ushort TypeParameterConstraintsMask;
    private MemberDecoration myDecoration;
    private bool myIsPartial;
    [NotNullAttribute]
private String[] myTypeParameterNames;
    [NotNullAttribute]
private UInt16[] myTypeParameterVariancesAndConstraints;
    [NotNullAttribute]
private String[] myAttributeClassNames;
    [CanBeNullAttribute]
private GlobalUsingsCache myGlobalUsingsCache;
    protected byte SerializationTag { get; }
    protected CSharpSerializationTag CSharpSerializationTag { get; }
    public bool CanBePartial { get; }
    public MemberDecoration Modifiers { get; }
    public String[] AttributeClassNames { get; }
    protected CSharpTypePart`1(T declaration, AliasTable aliasTable, ICacheBuilder cacheBuilder);
    protected CSharpTypePart`1(IReader reader);
    protected virtual void Write(IWriter writer);
    protected sealed virtual byte get_SerializationTag();
    protected abstract virtual CSharpSerializationTag get_CSharpSerializationTag();
    public virtual bool get_CanBePartial();
    public sealed virtual MemberDecoration get_Modifiers();
    public sealed virtual String[] get_AttributeClassNames();
    public virtual IDeclaration GetTypeParameterDeclaration(int index);
    [CanBeNullAttribute]
[PureAttribute]
private static ITypeParameterOfTypeDeclaration GetTypeParameterDeclaration(T typeDeclaration, int typeParameterIndex);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName);
    public virtual bool CanHaveAttribute(string shortName);
    public virtual bool HasAttributeInstance(IClrTypeName clrTypeName);
    public virtual IList`1<IAttributeInstance> GetTypeParameterAttributeInstances(int index, IClrTypeName typeName);
    public virtual bool HasTypeParameterAttributeInstance(int index, IClrTypeName typeName);
    [NotNullAttribute]
private static IList`1<IAttributeInstance> GetAttributeInstancesImpl(IAttributesOwnerDeclaration declaration, IClrTypeName typeName, AttributeTarget attributeTarget);
    [PureAttribute]
private static bool HasAttributeInstanceImpl(IAttributesOwnerDeclaration declaration, IClrTypeName typeName, AttributeTarget attributeTarget);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.CSharpTypePart`1/<GetTypeParameterSuperTypes>d__30")]
public virtual IEnumerable`1<IType> GetTypeParameterSuperTypes(int index);
    public virtual string GetTypeParameterName(int index);
    public virtual TypeParameterVariance GetTypeParameterVariance(int index);
    public virtual TypeParameterConstraintFlags GetTypeParameterConstraintFlags(int index);
    public virtual bool IsNullableContextEnabledForTypeParameter(int index);
    [PureAttribute]
private static TypeParameterConstraintFlags GetConstraintFlagsWithResolveCheck(T typeDeclaration, int typeParameterIndex);
    protected virtual void AssignDeclaredElement(ICachedDeclaration2 declaration);
    protected sealed virtual ICachedDeclaration2 FindDeclaration(IFile file, ICachedDeclaration2 candidateDeclaration);
    protected virtual T GetDeclaration();
    public virtual string ToString();
    [PureAttribute]
[NotNullAttribute]
private string BuildTypeParameterString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.DeclaredNamespacePart : NamespacePart {
    protected byte SerializationTag { get; }
    public DeclaredNamespacePart(ICSharpNamespaceDeclaration namespaceDeclaration, ICacheBuilder cacheBuilder);
    public DeclaredNamespacePart(IReader reader);
    protected virtual ICachedDeclaration2 FindDeclaration(IFile file, ICachedDeclaration2 candidateDeclaration);
    public virtual string ToString();
    protected virtual byte get_SerializationTag();
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.DelegatePart : CSharpTypePart`1<IDelegateDeclaration> {
    protected CSharpSerializationTag CSharpSerializationTag { get; }
    public String[] ExtendsListShortNames { get; }
    public IParameter[] Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public DelegatePart(IDelegateDeclaration declaration, AliasTable aliasTable, ICacheBuilder cacheBuilder);
    public DelegatePart(IReader reader);
    protected virtual CSharpSerializationTag get_CSharpSerializationTag();
    public virtual TypeElement CreateTypeElement();
    public virtual String[] get_ExtendsListShortNames();
    public sealed virtual IParameter[] get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.EnumPart : CSharpTypePart`1<IEnumDeclaration> {
    protected CSharpSerializationTag CSharpSerializationTag { get; }
    public IEnumerable`1<IField> Fields { get; }
    public String[] ExtendsListShortNames { get; }
    public EnumPart(IEnumDeclaration declaration, AliasTable aliasTable, ICacheBuilder cacheBuilder);
    public EnumPart(IReader reader);
    protected virtual CSharpSerializationTag get_CSharpSerializationTag();
    public sealed virtual IType GetUnderlyingType();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.EnumPart/<get_Fields>d__6")]
public sealed virtual IEnumerable`1<IField> get_Fields();
    public virtual TypeElement CreateTypeElement();
    public virtual String[] get_ExtendsListShortNames();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.ImplicitBackingFieldPointer : object {
    [NotNullAttribute]
private IDeclaredElementPointer`1<IProperty> myPropertyPointer;
    public ImplicitBackingFieldPointer(CSharpBackingField backingField);
    public sealed virtual CSharpBackingField FindDeclaredElement();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.InterfacePart : CSharpClassLikeTypePart`1<IInterfaceDeclaration> {
    private MemberPresenceFlag myMembersMask;
    protected CSharpSerializationTag CSharpSerializationTag { get; }
    public InterfacePart(IInterfaceDeclaration declaration, AliasTable aliasTable, ICacheBuilder cacheBuilder);
    public InterfacePart(IReader reader);
    protected virtual void Write(IWriter writer);
    protected virtual CSharpSerializationTag get_CSharpSerializationTag();
    public virtual TypeElement CreateTypeElement();
    private static TreeNodeCollection`1<ITypeUsage> GetExtendsList(IInterfaceDeclaration declaration);
    public virtual IDeclaredType GetBaseClassType();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.ParserLanguageLevelDependencyCache : SimpleICache`1<CSharpLanguageLevelBorders> {
    private ISolution mySolution;
    private ChangeManager myChangeManager;
    private IPsiFiles myPsiFiles;
    private static object ourNoBorders;
    private static Dictionary`2<CSharpLanguageLevel, CSharpLanguageLevelBorders> LanguageLevelBorders;
    public ParserLanguageLevelDependencyCache(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, ChangeManager changeManager, IPsiFiles psiFiles);
    private static ParserLanguageLevelDependencyCache();
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    private static CSharpLanguageLevelBorders ComputeBordersCrossed(IFile psiFile);
    public sealed virtual bool IsLanguageLevelBoundCrossed(Nullable`1<CSharpLanguageLevel> before, CSharpLanguageLevel after);
    public sealed virtual void OnLanguageLevelChanged(IPsiModule psiModule, Nullable`1<CSharpLanguageLevel> before, CSharpLanguageLevel after);
    [PureAttribute]
private static CSharpLanguageLevelBorders GetBorderFlags(Nullable`1<CSharpLanguageLevel> before, CSharpLanguageLevel after);
    public sealed virtual object Execute(IChangeMap changeMap);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.QualifiedNamespacePart : NamespacePart {
    protected byte SerializationTag { get; }
    public QualifiedNamespacePart(TreeOffset offset, string shortName);
    public QualifiedNamespacePart(IReader reader);
    public virtual IDeclaration GetDeclaration();
    public virtual string ToString();
    protected virtual byte get_SerializationTag();
    protected virtual ICachedDeclaration2 FindDeclaration(IFile file, ICachedDeclaration2 candidateDeclaration);
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.RecordBase : ClassLikeTypeElement {
    [NullableAttribute("1")]
public IEnumerable`1<string> MemberNames { get; }
    [NullableAttribute("2")]
public IPrimaryConstructor PrimaryConstructor { get; }
    public bool PositionalFieldsAreSupported { get; }
    [NullableContextAttribute("1")]
protected RecordBase(RecordPart part);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<string> get_MemberNames();
    [NullableContextAttribute("1")]
public virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    [NullableContextAttribute("2")]
public sealed virtual IPrimaryConstructor get_PrimaryConstructor();
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyCollection`1<IParameter> GetCapturedParameters(IList`1<IParameter> parameters);
    [NullableContextAttribute("2")]
public virtual IDeclaredType GetBaseClassType();
    public sealed virtual bool get_PositionalFieldsAreSupported();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.RecordBase/<GetPositionalParametersImplementations>d__10")]
public sealed virtual IEnumerable`1<PositionalParameterImplementation> GetPositionalParametersImplementations();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.RecordBase/<GetPositionalPropertiesImpl>d__11")]
[PureAttribute]
protected IEnumerable`1<PositionalParameterImplementation> GetPositionalPropertiesImpl(IList`1<IParameter> positionalParameters, Dictionary`2<string, ITypeMember> thisPositionalMembers, Dictionary`2<string, DeclaredElementInstanceSlim`1<ITypeMember>> baseMembers);
    [NullableContextAttribute("1")]
protected abstract virtual PooledDictionary`2<string, DeclaredElementInstanceSlim`1<ITypeMember>> CollectBaseMembers(IList`1<IParameter> positionalParameters, IDeclaredType baseType, HashSet`1<IClass> baseClassesInProgress, Boolean& hasSealedToString);
    [NullableContextAttribute("1")]
[PureAttribute]
protected static RecordMemberKind CheckExplicitRecordMember(IRecord record, ITypeMember sourceMember);
    public sealed virtual int TryGetCloneableMemberCount();
    public sealed virtual bool HasExplicitConstructorsInSuperTypes();
    protected bool HasInstanceNonCopyConstructor();
    [NullableContextAttribute("1")]
protected virtual IEnumerable`1<IDeclaredType> CalcImplicitSuperTypes();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ITypeMember> <>n__0();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.RecordClass : RecordBase {
    [NullableContextAttribute("1")]
public RecordClass(RecordPart part);
    [NullableContextAttribute("1")]
public virtual DeclaredElementType GetElementType();
    [NullableContextAttribute("1")]
public virtual string ToString();
    protected virtual LocalList`1<IDeclaredType> CalcSuperTypes();
    [NullableContextAttribute("1")]
public virtual IDeclaredType GetBaseClassType();
    [NullableContextAttribute("2")]
public sealed virtual IClass GetSuperClass();
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<ITypeMember> GetMembers();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.RecordClass/<GetRecordMembersNoCycle>d__7")]
internal IEnumerable`1<ITypeMember> GetRecordMembersNoCycle(HashSet`1<IClass> baseClassesInProgress);
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual bool HasImplicitInstanceConstructor();
    [NullableContextAttribute("1")]
protected virtual PooledDictionary`2<string, DeclaredElementInstanceSlim`1<ITypeMember>> CollectBaseMembers(IList`1<IParameter> positionalParameters, IDeclaredType baseType, HashSet`1<IClass> baseClassesInProgress, Boolean& hasSealedToString);
    [NullableContextAttribute("1")]
protected virtual bool AcceptsPart(TypePart part);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ITypeMember> <>n__0();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.RecordPart : CSharpClassLikeTypePart`1<IRecordDeclaration> {
    private MemberPresenceFlag myMembersMask;
    private bool myHasPrimaryConstructor;
    private bool myIsRecordStruct;
    private int myCloneableMemberCount;
    public bool IsStruct { get; }
    public bool IsReadonly { get; }
    public int CloneableMemberCount { get; }
    public ExtensionMemberInfo[] ExtensionMemberInfos { get; }
    protected CSharpSerializationTag CSharpSerializationTag { get; }
    public IPrimaryConstructor PrimaryConstructor { get; }
    public bool PositionalFieldsAreSupported { get; }
    public RecordPart(IRecordDeclaration declaration, AliasTable aliasTable, ICacheBuilder cacheBuilder);
    public RecordPart(IReader reader);
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual int get_CloneableMemberCount();
    public virtual ExtensionMemberInfo[] get_ExtensionMemberInfos();
    public virtual HybridCollection`1<ITypeMember> FindExtensionMethod(ExtensionMemberInfo info);
    private static TreeNodeCollection`1<ITypeUsage> GetExtendsList(IRecordDeclaration declaration);
    protected virtual void Write(IWriter writer);
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual IDeclaredType GetBaseClassType();
    protected virtual CSharpSerializationTag get_CSharpSerializationTag();
    public sealed virtual IPrimaryConstructor get_PrimaryConstructor();
    public sealed virtual bool get_PositionalFieldsAreSupported();
    public sealed virtual bool HasInstanceNotCopyConstructors(IRecord record);
    public virtual TypeElement CreateTypeElement();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordAccessContext : object {
    [NotNullAttribute]
private IRecord myRecord;
    public RecordAccessContext(IRecord record);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordCloneMethod : RecordImplicitMethod {
    [CompilerGeneratedAttribute]
private bool <IsOverride>k__BackingField;
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public string ShortName { get; }
    public bool CanBeDefinedExplicitly { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public RecordCloneMethod(IRecord record);
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public virtual bool get_IsOverride();
    public virtual string get_ShortName();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual bool get_CanBeDefinedExplicitly();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordCopyConstructor : RecordImplicitMember {
    public bool IsDefault { get; }
    public bool IsParameterless { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public string ShortName { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public RecordCopyConstructor(IRecord record);
    public virtual string ToString();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsParameterless();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsValueTypeZeroInit();
    public virtual string get_ShortName();
    public virtual DeclaredElementType GetElementType();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordDeconstructMethod : RecordImplicitMethod {
    [NotNullAttribute]
private IPrimaryConstructor myPrimaryConstructor;
    public string ShortName { get; }
    public bool IsReadonly { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public RecordDeconstructMethod(IRecord record, IPrimaryConstructor primaryConstructor);
    public virtual string get_ShortName();
    public virtual bool IsValid();
    public virtual bool get_IsReadonly();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordEqualityContractProperty : RecordImplicitOverrideableParametersOwner {
    private bool myIsInherited;
    public string ShortName { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public MemberHidePolicy HidePolicy { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public IType Type { get; }
    public IAccessor Getter { get; }
    public IAccessor Setter { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsAuto { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public RecordEqualityContractProperty(IRecord record, bool isInherited);
    public virtual string get_ShortName();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual DeclaredElementType GetElementType();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual AccessRights GetAccessRights();
    public virtual MemberHidePolicy get_HidePolicy();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public sealed virtual IType get_Type();
    public sealed virtual IAccessor get_Getter();
    public sealed virtual IAccessor get_Setter();
    public sealed virtual bool get_IsReadable();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsRequired();
    public sealed virtual string GetDefaultPropertyMetadataName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordEqualityOperator : RecordImplicitOverrideableParametersOwner {
    private bool myIsEquals;
    public string ShortName { get; }
    public bool IsStatic { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public bool IsChecked { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool CanBeDefinedExplicitly { get; }
    public RecordEqualityOperator(IRecord record, bool isEquals);
    public virtual string get_ShortName();
    public virtual bool get_IsStatic();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsChecked();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public virtual bool get_CanBeDefinedExplicitly();
    public virtual DeclaredElementType GetElementType();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordGetHashCodeMethod : RecordImplicitMethod {
    public string ShortName { get; }
    public bool IsReadonly { get; }
    public bool IsOverride { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public RecordGetHashCodeMethod(IRecord record);
    public virtual string get_ShortName();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsOverride();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordImplicitMember : object {
    [CompilerGeneratedAttribute]
private IRecord <Record>k__BackingField;
    [NotNullAttribute]
public IRecord Record { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public bool CanBeDefinedExplicitly { get; }
    public IDeclaredElement ElementThatDeclaresThisMember { get; }
    public string XMLDocId { get; }
    [NotNullAttribute]
public ITypeElement ContainingType { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public MemberHidePolicy HidePolicy { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    protected RecordImplicitMember(IRecord record);
    [CompilerGeneratedAttribute]
public IRecord get_Record();
    public abstract virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public virtual bool get_CanBeDefinedExplicitly();
    public virtual IDeclaredElement get_ElementThatDeclaresThisMember();
    public abstract virtual DeclaredElementType GetElementType();
    [NotNullAttribute]
public abstract virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_XMLDocId();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ITypeElement get_ContainingType();
    [NotNullAttribute]
public sealed virtual ITypeElement GetContainingType();
    [NotNullAttribute]
public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsSealed();
    public virtual bool get_IsStatic();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual MemberHidePolicy get_HidePolicy();
    public abstract virtual AccessRights GetAccessRights();
    public abstract virtual Nullable`1<Hash> CalcHash();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordImplicitMemberPointer`1 : object {
    [NotNullAttribute]
private Func`2<IRecord, RecordImplicitMember> myRestorerFunction;
    [NotNullAttribute]
private IDeclaredElementPointer`1<IRecord> myRecordPointer;
    public RecordImplicitMemberPointer`1(TImplicitMember recordImplicitMember);
    public sealed virtual TImplicitMember FindDeclaredElement();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordImplicitMethod : RecordImplicitOverrideableParametersOwner {
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVarArg { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    protected RecordImplicitMethod(IRecord record);
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordImplicitOverrideableParametersOwner : RecordImplicitMember {
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    protected RecordImplicitOverrideableParametersOwner(IRecord record);
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public abstract virtual IList`1<IParameter> get_Parameters();
    public abstract virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordObjectEqualsMethod : RecordImplicitMethod {
    public string ShortName { get; }
    public bool CanBeDefinedExplicitly { get; }
    public bool IsReadonly { get; }
    public bool IsOverride { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public RecordObjectEqualsMethod(IRecord record);
    public virtual string get_ShortName();
    public virtual bool get_CanBeDefinedExplicitly();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsOverride();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordPositionalProperty : RecordImplicitOverrideableParametersOwner {
    [CompilerGeneratedAttribute]
private IParameter <PrimaryParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOverride>k__BackingField;
    [NotNullAttribute]
public IParameter PrimaryParameter { get; }
    public string ShortName { get; }
    public bool IsOverride { get; }
    public IDeclaredElement ElementThatDeclaresThisMember { get; }
    public MemberHidePolicy HidePolicy { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public IType Type { get; }
    [NotNullAttribute]
public IAccessor Getter { get; }
    [NotNullAttribute]
public IAccessor Setter { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsAuto { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public RecordPositionalProperty(IRecord record, IParameter primaryParameter, bool isOverride);
    [CompilerGeneratedAttribute]
public IParameter get_PrimaryParameter();
    public virtual string get_ShortName();
    [CompilerGeneratedAttribute]
public virtual bool get_IsOverride();
    public virtual IDeclaredElement get_ElementThatDeclaresThisMember();
    public virtual DeclaredElementType GetElementType();
    public virtual bool IsValid();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual AccessRights GetAccessRights();
    public virtual MemberHidePolicy get_HidePolicy();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public sealed virtual IType get_Type();
    public sealed virtual IAccessor get_Getter();
    public sealed virtual IAccessor get_Setter();
    public sealed virtual bool get_IsReadable();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsRequired();
    public sealed virtual string GetDefaultPropertyMetadataName();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    [PureAttribute]
internal bool HasFieldAttributeInstance(IClrTypeName clrName);
    [NotNullAttribute]
internal IList`1<IAttributeInstance> GetFieldAttributeInstances();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordPrintMembersMethod : RecordImplicitMethod {
    private bool myIsInherited;
    public bool IsReadonly { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public string ShortName { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public RecordPrintMembersMethod(IRecord record, bool isInherited);
    public virtual bool get_IsReadonly();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual string get_ShortName();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordToStringMethod : RecordImplicitMethod {
    public string ShortName { get; }
    public bool IsReadonly { get; }
    public bool IsOverride { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public RecordToStringMethod(IRecord record);
    public virtual string get_ShortName();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsOverride();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.Records.RecordTypedEqualsMethod : RecordImplicitMethod {
    [CanBeNullAttribute]
private IType myBaseParameterType;
    public bool IsReadonly { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public string ShortName { get; }
    public bool CanBeDefinedExplicitly { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public RecordTypedEqualsMethod(IRecord record, IType baseParameterType);
    public virtual bool get_IsReadonly();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsSealed();
    public virtual string get_ShortName();
    public virtual bool IsValid();
    public virtual Func`2<IRecord, RecordImplicitMember> GetRestorerFunction();
    public virtual bool get_CanBeDefinedExplicitly();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual AccessRights GetAccessRights();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.RecordStruct : RecordBase {
    protected MemberDecoration Modifiers { get; }
    public bool HasHiddenInstanceFields { get; }
    public bool HasCustomParameterlessConstructor { get; }
    public bool IsReadonly { get; }
    public bool IsByRefLike { get; }
    [NullableContextAttribute("1")]
public RecordStruct(RecordPart part);
    [NullableContextAttribute("1")]
public sealed virtual DeclaredElementType GetElementType();
    [NullableContextAttribute("1")]
public virtual string ToString();
    protected virtual LocalList`1<IDeclaredType> CalcSuperTypes();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.RecordStruct/<GetMembers>d__4")]
public virtual IEnumerable`1<ITypeMember> GetMembers();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    protected virtual MemberDecoration get_Modifiers();
    public sealed virtual bool get_HasHiddenInstanceFields();
    public sealed virtual bool get_HasCustomParameterlessConstructor();
    public virtual bool get_IsReadonly();
    public sealed virtual bool get_IsByRefLike();
    [NullableContextAttribute("1")]
protected virtual PooledDictionary`2<string, DeclaredElementInstanceSlim`1<ITypeMember>> CollectBaseMembers(IList`1<IParameter> positionalParameters, IDeclaredType baseType, HashSet`1<IClass> baseClassesInProgress, Boolean& hasSealedToString);
    [NullableContextAttribute("1")]
protected virtual bool AcceptsPart(TypePart part);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ITypeMember> <>n__0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.SpeculativeFieldsUtil : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Key`1<CachedPsiValue`1<HashSet`1<IParameter>>> ourCapturedPrimaryParametersNames;
    private static ObjectPool`1<PooledHashSet`1<IParameter>> ourParametersSetPool;
    private static ObjectPool`1<PooledHashSet`1<string>> ourParametersNamesPool;
    private static SpeculativeFieldsUtil();
    private static CachedPsiValue`1<HashSet`1<IParameter>> GetCachedPsiValue(IClassLikeDeclaration classLikeDeclaration);
    public static void SetCachedData(IClassLikeDeclaration classLikeDeclaration, HashSet`1<IParameter> capturedParameters);
    public static void SearchFor(IClassLikeDeclaration classLikeDeclaration, IList`1<IParameter> parametersToLookFor, HashSet`1<IParameter> haveFields);
    private static HashSet`1<IParameter> ScanCapturedParameters(IClassLikeDeclaration classLikeDeclaration);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.StructPart : CSharpClassLikeTypePart`1<IStructDeclaration> {
    private MemberPresenceFlag myMembersMask;
    private bool myHasPrimaryConstructor;
    private int myCloneableMemberCount;
    protected CSharpSerializationTag CSharpSerializationTag { get; }
    public bool IsReadonly { get; }
    public bool IsByRefLike { get; }
    public int CloneableMemberCount { get; }
    public IPrimaryConstructor PrimaryConstructor { get; }
    public StructPart(IStructDeclaration declaration, AliasTable aliasTable, ICacheBuilder cacheBuilder);
    public StructPart(IReader reader);
    protected virtual void Write(IWriter writer);
    public virtual IDeclaredType GetBaseClassType();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual TypeElement CreateTypeElement();
    protected virtual CSharpSerializationTag get_CSharpSerializationTag();
    private static TreeNodeCollection`1<ITypeUsage> GetExtendsList(IStructDeclaration declaration);
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsByRefLike();
    public sealed virtual int get_CloneableMemberCount();
    public sealed virtual IPrimaryConstructor get_PrimaryConstructor();
    public sealed virtual void GetParametersWithSpeculativeFieldsProduced(IList`1<IParameter> parameters, HashSet`1<IParameter> consumer);
}
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.TopLevelCodeSymbolsInvalidator : object {
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private TopLevelCodeCache myTopLevelCodeCache;
    [NotNullAttribute]
private ChangeManager myChangeManager;
    public TopLevelCodeSymbolsInvalidator(Lifetime lifetime, ISolution solution, TopLevelCodeCache topLevelCodeCache, ChangeManager changeManager);
    public sealed virtual bool IsLanguageLevelBoundCrossed(Nullable`1<CSharpLanguageLevel> before, CSharpLanguageLevel after);
    public sealed virtual void OnLanguageLevelChanged(IPsiModule psiModule, Nullable`1<CSharpLanguageLevel> before, CSharpLanguageLevel after);
    public sealed virtual object Execute(IChangeMap changeMap);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Cache2.TopLevelCodeTypePart : TypePart {
    protected byte SerializationTag { get; }
    public bool CanBePartial { get; }
    public MemberDecoration Modifiers { get; }
    public String[] ExtendsListShortNames { get; }
    public String[] AttributeClassNames { get; }
    public IPrimaryConstructor PrimaryConstructor { get; }
    public TopLevelCodeTypePart(ITopLevelCode topLevelCode);
    public TopLevelCodeTypePart(IReader reader);
    protected virtual ICachedDeclaration2 FindDeclaration(IFile file, ICachedDeclaration2 candidateDeclaration);
    protected virtual byte get_SerializationTag();
    public virtual bool get_CanBePartial();
    public virtual MemberDecoration get_Modifiers();
    public virtual String[] get_ExtendsListShortNames();
    public virtual String[] get_AttributeClassNames();
    public virtual TypeElement CreateTypeElement();
    public virtual IDeclaration GetTypeParameterDeclaration(int index);
    public virtual string GetTypeParameterName(int index);
    public virtual TypeParameterVariance GetTypeParameterVariance(int index);
    public virtual IEnumerable`1<IType> GetTypeParameterSuperTypes(int index);
    public virtual TypeParameterConstraintFlags GetTypeParameterConstraintFlags(int index);
    public virtual bool IsNullableContextEnabledForTypeParameter(int index);
    public virtual IList`1<IAttributeInstance> GetTypeParameterAttributeInstances(int index, IClrTypeName typeName);
    public virtual bool HasTypeParameterAttributeInstance(int index, IClrTypeName typeName);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName);
    public virtual bool HasAttributeInstance(IClrTypeName clrTypeName);
    public sealed virtual IDeclaredType GetBaseClassType();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual IEnumerable`1<ITypeMember> GetTypeMembers();
    public sealed virtual IEnumerable`1<IDeclaredType> GetSuperTypes();
    public sealed virtual IPrimaryConstructor get_PrimaryConstructor();
    public sealed virtual void GetParametersWithSpeculativeFieldsProduced(IList`1<IParameter> parameters, HashSet`1<IParameter> consumer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeCompletion.CSharpIncludeFieldKeywordSymbolTable : object {
    private ISymbolTable myUnderlying;
    private Nullable`1<bool> myIncludeField;
    private IProperty myProperty;
    [NullableAttribute("2")]
private ISymbolInfo myFieldSymbol;
    private static string FieldKeyword;
    private ISymbolInfo FieldSymbol { get; }
    private CSharpIncludeFieldKeywordSymbolTable(ISymbolTable underlying, IProperty property);
    [PureAttribute]
public static ISymbolTable Create(ISymbolTable symbolTable, ITreeNode referenceNode);
    private ISymbolInfo get_FieldSymbol();
    [PureAttribute]
private bool IncludeField();
    public sealed virtual IEnumerable`1<string> Names();
    public sealed virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public sealed virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public sealed virtual IList`1<ISymbolInfo> GetSymbolInfosConstitutingResolveResult(string name, IResolveInfo& resolveInfo);
    public sealed virtual void ForAllSymbolInfos(Action`1<ISymbolInfo> processor);
    public sealed virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    [NullableContextAttribute("2")]
public sealed virtual ISymbolTableDependencySet GetDependencySet();
    [CompilerGeneratedAttribute]
private bool <IncludeField>g__HasSymbolNamedField|9_0();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpCodeFormattingContext : PossiblyEmbeddedCodeFormatterContext {
    [CompilerGeneratedAttribute]
private ITreeNode <ImagineLineBreakBeforeThis>k__BackingField;
    [CanBeNullAttribute]
private ICSharpCustomFormattingInfoProvider myCustomFormattingInfoProvider;
    private Nullable`1<CSharpLanguageLevel> myLanguageLevel;
    [CompilerGeneratedAttribute]
private HashSet`1<ITreeNode> <NodesWithFormattingInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ITreeNode, object> <AdditionalData>k__BackingField;
    [CanBeNullAttribute]
public ITreeNode ImagineLineBreakBeforeThis { get; public set; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public HashSet`1<ITreeNode> NodesWithFormattingInProgress { get; }
    public Dictionary`2<ITreeNode, object> AdditionalData { get; }
    [NotNullAttribute]
public ICSharpCustomFormattingInfoProvider CustomFormattingInfoProvider { get; }
    public CSharpCodeFormattingContext(ICodeFormatterImpl codeFormatter, IFormatterDebugInfoLogger debugInfoLogger, ICSharpCustomFormattingInfoProvider customFormattingInfoProvider, AdditionalFormatterParameters parameters, int tabWidth, SingleLangChangeAccu changeAccu, FormatTask[] formatTasks);
    [CompilerGeneratedAttribute]
public ITreeNode get_ImagineLineBreakBeforeThis();
    [CompilerGeneratedAttribute]
public void set_ImagineLineBreakBeforeThis(ITreeNode value);
    public CSharpLanguageLevel get_LanguageLevel();
    [CompilerGeneratedAttribute]
public HashSet`1<ITreeNode> get_NodesWithFormattingInProgress();
    [CompilerGeneratedAttribute]
public Dictionary`2<ITreeNode, object> get_AdditionalData();
    public ICSharpCustomFormattingInfoProvider get_CustomFormattingInfoProvider();
    public virtual bool ImagineLineBreakBefore(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpFmtStageContext : FormattingStageContext {
    [DebuggerBrowsableAttribute("0")]
private Func`3<FormattingStageContext, bool, int> myMinLineFeedsCalc;
    [DebuggerBrowsableAttribute("0")]
private Nullable`1<int> myMinLineFeeds;
    public CSharpFmtStageContext(FormattingRange range, Func`3<FormattingStageContext, bool, int> minLineFeedsCalc);
    public int GetMinLineFeeds(bool nearBraces);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpFormatProfile : object {
    private ProfileOptions myMask;
    [CompilerGeneratedAttribute]
private CodeFormatProfile <CodeFormatProfile>k__BackingField;
    public bool Format { get; }
    public bool DontKeepLinebreaks { get; }
    public bool DontForceOptionalSingleline { get; }
    public bool DontForceImportantSingleline { get; }
    public bool DontRemoveExtraBlankLines { get; }
    public bool DontWrap { get; }
    public ProfileOptions Mask { get; }
    public CodeFormatProfile CodeFormatProfile { get; }
    public CSharpFormatProfile(CodeFormatProfile codeFormatProfile, ProfileOptions mask);
    public bool get_Format();
    public bool get_DontKeepLinebreaks();
    public bool get_DontForceOptionalSingleline();
    public bool get_DontForceImportantSingleline();
    public bool get_DontRemoveExtraBlankLines();
    public bool get_DontWrap();
    public ProfileOptions get_Mask();
    [CompilerGeneratedAttribute]
public CodeFormatProfile get_CodeFormatProfile();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpFormatterImplHelper : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<IWhitespaceNode> LeftWhitespaces(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<IWhitespaceNode> RightWhitespaces(ITreeNode node);
    [ExtensionAttribute]
public static int BlankLinesToLineFeeds(int blankLines);
    [ExtensionAttribute]
public static bool HasNewLineBefore(ITreeNode node);
    [ExtensionAttribute]
public static bool HasWhitespaceBefore(ITreeNode node);
    [ExtensionAttribute]
public static bool HasNewLineAfter(ITreeNode node);
    [ExtensionAttribute]
public static bool IsFieldDeclaration(ITreeNode node);
    [ExtensionAttribute]
public static bool IsAutoPropertyDeclaration(ITreeNode node);
    [ExtensionAttribute]
public static bool IsPropertyDeclaration(ITreeNode node);
    [ExtensionAttribute]
public static bool IsInvocableDeclaration(ITreeNode node);
    [ExtensionAttribute]
public static bool IsLocalMethodDeclaration(ITreeNode node);
    [ExtensionAttribute]
public static bool IsEndOfLineComment(ITreeNode node);
    [ExtensionAttribute]
public static bool IsEndOfLineCommentButNotDocComment(ITreeNode node);
    [ExtensionAttribute]
public static bool IsSimpleStatement(ITreeNode singleStatement);
    [ExtensionAttribute]
[PureAttribute]
private static bool ExpressionCanBeStatementSyntactically(ICSharpExpression expression);
    [ExtensionAttribute]
public static bool IsSimpleBlock(IBlock block, bool checkLinebreaks);
    [ExtensionAttribute]
public static bool IsSimpleAnonymousMethod(IAnonymousMethodExpression expression, bool checkLinebreaks);
    [ExtensionAttribute]
public static bool IsSimpleLambdaExpression(ILambdaExpression expression, bool checkLinebreaks);
    [ExtensionAttribute]
public static bool IsSimpleOperand(ICSharpExpression expr);
    public static bool HasSimpleOperand(ICSharpExpression leftOp, ICSharpExpression rightOp);
    [CanBeNullAttribute]
public static ICSharpExpression GetComplexParentExpr(ICSharpExpression leftOp, ICSharpExpression rightOp, ICSharpExpression parentExpr);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpFormattingStage : CSharpStageBase {
    [NotNullAttribute]
private FmtSettingsClassic`1<CSharpFormatSettingsKey> mySettings;
    [NotNullAttribute]
private FormattingVisitor myFmtVisitor;
    [NotNullAttribute]
private Func`3<FormattingStageContext, bool, int> myMinLineFeedsCalc;
    private CSharpFormattingStage(CSharpCodeFormattingContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> settings, CSharpFormatProfile profile);
    public static void DoFormat(CSharpCodeFormattingContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> settings, CSharpFormatProfile profile, IProgressIndicator progress);
    private IEnumerable`1<string> CalcSpaces(CSharpFmtStageContext context);
    private static IEnumerable`1<string> GetCustomProviderSpaces(FormattingVisitor formattingVisitor, CSharpCodeFormattingContext cSharpCodeFormattingContext, CSharpFmtStageContext context);
    private void MakeFormat(FormattingRange range, IEnumerable`1<string> space, CSharpCodeFormattingContext context);
    private static bool KeepExistingLineBreaksAround(ITreeNode node);
    private static int CalcMinLineFeedsBetween(FormattingStageContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> formatSettings, bool nearBraces);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpFormattingStage/<PossibleMinLineFeeds>d__10")]
private static IEnumerable`1<int> PossibleMinLineFeeds(FormattingStageContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> formatSettings, bool nearBraces);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpFormattingStage/<PossibleBlankLines>d__11")]
private static IEnumerable`1<int> PossibleBlankLines(FormattingStageContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> formatSettings, bool nearBraces);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpIndentingStage : CSharpStageBase {
    [NotNullAttribute]
private FmtSettingsClassic`1<CSharpFormatSettingsKey> mySettings;
    private IProgressIndicator myProgressIndicator;
    [NotNullAttribute]
private CSharpCodeFormatter myCSharpCodeFormatter;
    [NotNullAttribute]
private IIndentCache myIndentCache;
    [NotNullAttribute]
private IndentVisitor myIndentVisitor;
    public CSharpIndentingStage(CSharpCodeFormattingContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> settings, IProgressIndicator progressIndicator);
    public static void DoIndent(CSharpCodeFormattingContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> settings, IProgressIndicator progress);
    private void ConvertLineEndings(ITreeNode left, ITreeNode right);
    public void DoIndent(FormattingStageContext context);
    [CanBeNullAttribute]
private string GetCustomLineIndent(ITreeNode node, CustomIndentType indentType);
    [CanBeNullAttribute]
private string CalcIndent(FormattingStageContext context);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpOptimizeUsingsAndReferencesEngine : OptimizeImportsAndReferencesEngine {
    [NotNullAttribute]
private LifetimeDefinition myLifetimeDefinition;
    [CompilerGeneratedAttribute]
private ICSharpFile <File>k__BackingField;
    private ICSharpFile File { get; }
    public CSharpOptimizeUsingsAndReferencesEngine(ICSharpFile file, IRangeMarker rangeMarker);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private ICSharpFile get_File();
    protected virtual IGeneratedCodeRegionDetector CreateGeneratedCodeRegionDetector();
    protected virtual HashSet`1<ITreeNode> GetUsedImports();
    protected virtual void RemoveImportsAndAddMandatory(HashSet`1<ITreeNode> usedImports);
    protected virtual void ReindentImports();
    protected virtual ReferenceOptimizationKind GetReferenceKind(IReference reference, IDeclaredElement target);
    protected virtual void ShortenStaticMemberReferences(Dictionary`2<IReference, IResolveResult> referenceResolveMap);
    protected virtual bool CanRequireImport(IReference reference);
    protected virtual void AddImportForExtensionMethodIfRequired(IReference reference, IMethod extensionMethod);
    private static QualifiedMember GetMemberKind(IDeclaredElement element);
    private IQualifiableReference ShortenStaticMemberReference(IQualifiableReference reference, DeclaredElementInstance target);
    private static bool CheckEqualResolve(TypeMemberInstance instance, IResolveResult result);
    protected virtual IQualifiableReference ShortenReferenceCore(IQualifiableReference reference, DeclaredElementInstance instance);
    private void RemoveImports(HashSet`1<ITreeNode> usedImports);
    private void AddMandatoryImportsTo(ICSharpTypeAndNamespaceHolderDeclaration holderDeclaration, List`1<string> mandatoryImports);
    private static bool IsStatic(IDeclaredElement declaredElement);
    private static bool IsResolvedByExternAlias(IReference reference);
    [CompilerGeneratedAttribute]
internal static DocumentRange <RemoveImports>g__GetImportDocumentRange|18_0(IUsingDirective directive);
    [CompilerGeneratedAttribute]
private void <RemoveImports>g__CollectImportsToRemove|18_1(ICSharpTypeAndNamespaceHolderDeclaration scope, <>c__DisplayClass18_0& );
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpStageBase : object {
    [CompilerGeneratedAttribute]
private CSharpCodeFormattingContext <Context>k__BackingField;
    [NotNullAttribute]
protected CSharpCodeFormattingContext Context { get; }
    protected CSharpStageBase(CSharpCodeFormattingContext context);
    [CompilerGeneratedAttribute]
protected CSharpCodeFormattingContext get_Context();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.CSharpWrappingStage : CSharpStageBase {
    private FmtSettingsClassic`1<CSharpFormatSettingsKey> mySettings;
    [NotNullAttribute]
private WrappingVisitor myWrappingVisitor;
    private CSharpWrappingStage(CSharpCodeFormattingContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> settings);
    public static bool DoWrap(CSharpCodeFormattingContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> settings, IProgressIndicator progress);
    private bool ShouldWrap(FormattingStageContext formattingStageContext, CSharpCodeFormattingContext context);
    private void BreakLines(ITreeNode leftChild, ITreeNode rightChild);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.DummyCSharpCustomFormattingInfoProvider : object {
    [NotNullAttribute]
public static DummyCSharpCustomFormattingInfoProvider Instance;
    public bool NeedsOldEngine { get; }
    private static DummyCSharpCustomFormattingInfoProvider();
    public virtual bool CanWrap(FormattingStageContext context);
    public virtual SpaceType GetInvocationSpaces(CSharpFmtStageContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> formatSettings);
    public virtual FmtSettingsClassic`1<CSharpFormatSettingsKey> AdjustFormattingSettings(FmtSettingsClassic`1<CSharpFormatSettingsKey> settings, ISettingsOptimization settingsOptimization);
    public virtual FmtSettingsHolder`1<CSharpFormatSettingsKey> AdjustFormattingSettings(FmtSettingsHolder`1<CSharpFormatSettingsKey> settings, ISettingsOptimization settingsOptimization);
    public virtual SpaceType GetBlockSpaceType(CSharpFmtStageContext ctx, CSharpCodeFormattingContext context);
    public virtual bool CanModifyInsideNodeRange(CSharpCodeFormattingContext context, ITreeNode leftElement, ITreeNode rightElement);
    public virtual bool CanModifyNode(ITreeNode element);
    public virtual bool AllowDecoration(CSharpCodeFormattingContext context);
    public virtual bool CanDeBlock(IBlock node);
    public virtual ITreeNode GetLChild(CSharpFmtStageContext context);
    public virtual void RunFormatterForEmbeddedLanguages(IFile currentFile, TreeTextRange range, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    public virtual bool get_NeedsOldEngine();
    public virtual bool NeedsOldEngineEx(IContextBoundSettingsStore settingsStore);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpCodeFormatter : CodeFormatterBase`1<CSharpFormatSettingsKey> {
    private IEnumerable`1<CSharpFormatterInfoProviderBase> myProviders;
    private ProjectFileTypeServices myProjectServices;
    [NotNullAttribute]
private Dictionary`2<CodeFormatProfile, CSharpFormatProfile> myFormatProfileTable;
    private ConcurrentDictionary`2<TokenTypePair, bool> myGlueingCache;
    private Func`2<TokenTypePair, bool> myIsTokensGluedDelegate;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICustomIndentHandler> <CustomIndentHandlers>k__BackingField;
    private NodeTypeSet myInterpolatedStringParts;
    public IEnumerable`1<ICustomIndentHandler> CustomIndentHandlers { get; }
    public bool SupportsFormattingWithAccu { get; }
    public bool SupportsSettingsTracking { get; }
    public bool SupportsAdditionalProfiles { get; }
    public bool SupportsWrapping { get; }
    public bool PotentiallySupportsFormatterDaemon { get; }
    public bool SupportsAutoDetect { get; }
    public string OverridenSettingPrefix { get; }
    public CSharpCodeFormatter(Lifetime lifetime, CodeFormatterRequirements requirements, CSharpLanguage language, IEnumerable`1<ICustomIndentHandler> customIndentHandlers, IEnumerable`1<CSharpFormatterInfoProviderBase> providers);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ICustomIndentHandler> get_CustomIndentHandlers();
    public virtual bool IsNewLine(ITreeNode ws);
    public virtual ITreeNode CreateSpace(string spaceText, NodeType replacedOrLeftSiblingType);
    public virtual ITreeNode CreateSpace();
    public virtual ITreeNode CreateNewLine(LineEnding lineEnding, NodeType lineBreakType);
    public virtual bool CanModifyInsideNodeRange(ITreeNode leftElement, ITreeNode rightElement, CodeFormattingContext context);
    public virtual bool CanModifyNode(ITreeNode element, CodeFormattingContext context);
    public virtual IFormatterInfoProvider GetFormatterInfoProvider(IPsiSourceFile sourceFile, AdditionalFormatterParameters parameters);
    [NotNullAttribute]
public CSharpFormatterInfoProviderBase GetCSharpFormatterInfoProvider(IPsiSourceFile sourceFile);
    public virtual void FormatMyLanguageInMultiLanguageFileWithAccu(FormatTask[] formatTasks, FileChangeAccu accu, AdditionalFormatterParameters parameters, IContextBoundSettingsStore settingsStore, IPsiSourceFile sourceFile, LineEnding lineEnding);
    public virtual bool get_SupportsFormattingWithAccu();
    public virtual bool get_SupportsSettingsTracking();
    public virtual bool get_SupportsAdditionalProfiles();
    public virtual bool get_SupportsWrapping();
    public virtual bool get_PotentiallySupportsFormatterDaemon();
    public virtual bool SupportsFormatterDaemon(IFile fileNode, IContextBoundSettingsStore overrideSettingsStore);
    public virtual bool get_SupportsAutoDetect();
    public virtual bool CanBeMultilineToken(ITreeNode node);
    internal void Format(ITreeNode root, CSharpFormatProfile profile, AdditionalFormatterParameters parameters);
    public ICSharpCustomFormattingInfoProvider GetCustomFormattingInfoProvider(ITreeNode node);
    public virtual ITreeRange Format(ITreeNode firstElement, ITreeNode lastElement, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    public virtual bool UseChangeAccu(CachedSettings fmtSettings, IPsiSourceFile sourceFile);
    public virtual bool HasSignificantWhitespaces(ITreeNode node);
    protected virtual bool NeedMultilanguageFormattingWithAccu(IPsiSourceFile sourceFile, CachedSettings settings);
    public sealed virtual Nullable`1<Whitespace> GetIndent(ITreeNode node, Position position, ITreeNode imagineLineBreakBeforeThis, FmtSettingsHolder`1<CSharpFormatSettingsKey> settings);
    public sealed virtual IReadOnlyList`1<VirtualIndent> RunVirtualFormatting(IFile fileNode, bool onlyFixForInlayHints);
    public sealed virtual void FormatWithVirtualSettingsForPreview(ITreeNode node, CodeFormatProfile profile, IProgressIndicator instance, IContextBoundSettingsStore boundSettingsStore);
    public sealed virtual FmtSettingsHolder`1<CSharpFormatSettingsKey> GetFormattingSettings(ITreeNode node, AdditionalFormatterParameters parameters);
    public virtual void Format(FormatTask[] formatTasks, AdditionalFormatterParameters parameters);
    protected virtual Dictionary`2<CodeFormatProfile, ConditionalSettingsChange[]> GetSettingsToChangeForProfileImpl();
    protected virtual void SetKeepArrangementsSettings(FmtSettingsHolder`1<CSharpFormatSettingsKey> formatterSettings, bool value);
    protected virtual FmtSettingsHolder`1<CSharpFormatSettingsKey> OverrideSettingsIfNeeded(FmtSettingsHolder`1<CSharpFormatSettingsKey> settings, FormatTask[] formatTasks, ICustomFormatterInfoProvider customFormatterInfoProvider);
    public virtual string get_OverridenSettingPrefix();
    protected virtual CodeFormattingContext CreateFormatterContext(AdditionalFormatterParameters parameters, ICustomFormatterInfoProvider provider, int tabWidth, SingleLangChangeAccu changeAccu, FormatTask[] formatTasks);
    private void DoFormatWithNewEngine(FmtSettingsHolder`1<CSharpFormatSettingsKey> settings, ICSharpCustomFormattingInfoProvider customProvider, FormatTask[] formatTasks, AdditionalFormatterParameters parameters);
    internal void Format(ITreeNode firstElement, ITreeNode lastElement, CSharpFormatProfile profile, AdditionalFormatterParameters parameters);
    private void DoFormatWithOldEngine(CSharpFormatProfile profile, FmtSettingsClassic`1<CSharpFormatSettingsKey> settings, ICSharpCustomFormattingInfoProvider customProvider, ITreeNode firstNode, ITreeNode lastNode, AdditionalFormatterParameters parameters);
    public sealed virtual void FormatDocComment(IDocCommentBlock docCommentBlock);
    private bool IsTokensGlued(TokenTypePair key);
    public virtual MinimalSeparatorType GetMinimalSeparatorByNodeTypes(TokenNodeType leftTokenType, TokenNodeType rightTokenType);
    public virtual void FormatInsertedNodes(ITreeNode nodeFirst, ITreeNode nodeLast, bool formatSurround, bool indentSurround);
    private int CountStatementsWithExceptions(IBlock blockNode, ITreeNode nodeFirst, ITreeNode nodeLast);
    public virtual ITreeRange FormatInsertedRange(ITreeNode nodeFirst, ITreeNode nodeLast, ITreeRange origin);
    public virtual void FormatReplacedRange(ITreeNode first, ITreeNode last, ITreeRange oldNodes);
    public virtual void FormatDeletedNodes(ITreeNode parent, ITreeNode prevNode, ITreeNode nextNode);
    private bool ShouldIndentSurround(ITreeNode newNode, ITreeNode oldNode);
    private bool ShouldFormatSurround(ITreeNode newNode, ITreeNode oldNode);
    public virtual void FormatReplacedNode(ITreeNode oldNode, ITreeNode newNode);
    public sealed virtual void UpdateAccessorOwnerLayout(IAccessorDeclaration accessor);
    public sealed virtual ValueTuple`2<string, string> SplitWhitespaceBetweenTokens(TokenNodeType leftToken, TokenNodeType rightToken, string whitespace);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProvider : CSharpFormatterInfoProviderBase {
    public int Priority { get; }
    public CSharpFormatterInfoProvider(IThreading threading, Lifetime lifetime, ISettingsSchema settingsSchema, ICalculatedSettingsSchema calculatedSettingsSchema, IEnumerable`1<CSharpFormatterInfoProviderPart> parts);
    public virtual bool IsSuitableForProjectFileType(ProjectFileType projectFileType);
    public virtual int get_Priority();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase : FormatterInfoProviderWithFluentApiAndParts`2<CSharpCodeFormattingContext, CSharpFormatSettingsKey> {
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IncludePrefixCommentInIndentSetting>k__BackingField;
    protected NodeTypeSet Comments;
    protected NodeTypeSet Block;
    protected NodeTypeSet BinaryOperatorSign;
    protected NodeTypeSet BinaryPatternOperatorSign;
    protected NodeTypeSet AssignmentOperatorSign;
    protected NodeTypeSet Initializers;
    protected NodeTypeSet SimpleStatements;
    public static NodeTypeSet ReallySimpleStatements;
    public static NodeTypeSet SingleStatementOwnerStatements;
    public static NodeTypeSet BlockOwnerStatements;
    protected NodeTypeSet BlockOwners;
    protected NodeTypeSet TopLevelAccessorOwners;
    protected NodeTypeSet QueryExpressionElements;
    protected NodeTypeSet TypeMembers;
    public Func`3<VirtNode, CodeFormattingContext, bool> IsEmpty;
    public Func`3<VirtNode, CodeFormattingContext, bool> IsNotEmpty;
    private IScalarSetting`1<bool> myDontRemoveExtraBlankLinesSetting;
    private AlignNestedElementsRule myBinaryExpressionAlignmentRule;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignFieldsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignPropertiesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignMethodsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignParametersSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignVariablesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignAssignmentsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignPropertyPatternsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignNestedTernarySetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignInvocationsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignBinaryExpressionsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignCommentsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignSwitchSectionsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignSwitchExpressionsSetting>k__BackingField;
    public int Priority { get; }
    public IScalarSetting`1<bool> IncludePrefixCommentInIndentSetting { get; private set; }
    public ProjectFileType MainProjectFileType { get; }
    public bool NeedsAdditionalFormatStage { get; }
    public IScalarSetting`1<bool> IntAlignFieldsSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignPropertiesSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignMethodsSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignParametersSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignVariablesSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignAssignmentsSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignPropertyPatternsSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignNestedTernarySetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignInvocationsSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignBinaryExpressionsSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignCommentsSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignSwitchSectionsSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignSwitchExpressionsSetting { get; private set; }
    protected CSharpFormatterInfoProviderBase(IThreading threading, Lifetime lifetime, ISettingsSchema settingsSchema, ICalculatedSettingsSchema calculatedSettingsSchema, IEnumerable`1<CSharpFormatterInfoProviderPart> parts);
    private static CSharpFormatterInfoProviderBase();
    public abstract virtual bool IsSuitableForProjectFileType(ProjectFileType projectFileType);
    public abstract virtual int get_Priority();
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IncludePrefixCommentInIndentSetting();
    [CompilerGeneratedAttribute]
private void set_IncludePrefixCommentInIndentSetting(IScalarSetting`1<bool> value);
    protected virtual void Initialize();
    private bool IsPartOfNestedTernary(ITreeNode node);
    private AutodetectedTernaryStyle DetectNestedTernaryStyle(VirtNode node, CodeFormattingContext checker);
    private void Braces();
    private void Pars();
    private IBuilderWithProvider`3<CSharpCodeFormattingContext, CSharpFormatSettingsKey, ParenthesisRuleWithWrapping> GetParsRuleBuilder();
    [PureAttribute]
public static bool FindBlock(ITreeNode statement);
    public virtual ProjectFileType get_MainProjectFileType();
    public virtual bool get_NeedsAdditionalFormatStage();
    public void CheckHealth();
    public virtual bool IncludePrefixCommentInIndent(IFormatterStageBase`1<CSharpFormatSettingsKey> stage);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<SettingsToIgnoreInAutodetect>d__36")]
public virtual IEnumerable`1<IScalarSetting> SettingsToIgnoreInAutodetect();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<KeepExistingSettings>d__37")]
public virtual IEnumerable`1<IScalarSetting> KeepExistingSettings();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<WrappingSettings>d__38")]
public IEnumerable`1<IScalarSetting> WrappingSettings();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<SettingsForStrictAutodetectMode>d__39")]
public virtual IEnumerable`1<Pair`2<IScalarSetting, object>> SettingsForStrictAutodetectMode();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<AdditionalSettingValuesForAutodetect>d__40")]
public virtual IEnumerable`1<Pair`2<IScalarSetting, object>> AdditionalSettingValuesForAutodetect();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<GetSettingPreferencesForNewLines>d__41")]
public virtual IEnumerable`1<ValueTuple`3<object, int, IScalarSetting[]>> GetSettingPreferencesForNewLines();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<GetSettingPriority>d__42")]
public virtual IEnumerable`1<ValueTuple`2<IScalarSetting, int>> GetSettingPriority();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<GetSettingPreferences>d__43")]
public virtual IEnumerable`1<ValueTuple`3<object, int, IScalarSetting[]>> GetSettingPreferences();
    private void FormatCommon();
    private void BlankLines();
    protected virtual bool AllowedNodesAfterForBlankLineCalculation(VirtNode node, CodeFormattingContext checker);
    protected virtual bool AllowedNodesBeforeForBlankLineCalculation(VirtNode node, CodeFormattingContext codeFormattingContext);
    protected virtual ChildBuilder`2<IBlankWithSinglePattern, NodePatternBlank> GetNodesToGroupForBlankLineCalculation();
    private void Spaces();
    private void ReferenceExpressions();
    private void BreakAroundDotInFluentCalls(bool wrapBeforeFirstMethodCall, bool wrapAfterPropertyInChainedMethodCalls);
    private bool IsInvocationLikeExpression(ITreeNode node);
    private bool IsFluentReference(ITreeNode obj, CodeFormattingContext checker, bool wrapBeforeFirstMethodCall, bool wrapAfterPropertyInChainedMethodCalls);
    private static int CountInvocationsAbove(IReferenceExpression referenceExpression);
    private bool IsTopLevelFluentInvocation(ITreeNode obj, CodeFormattingContext checker);
    private bool IsTopLevelReference(ITreeNode obj, CodeFormattingContext checker);
    private static IReferenceExpression GetMostNestedReferenceExpression(IReferenceExpression referenceExpression);
    private void BinaryExpressions();
    private bool IsTopLevelBinary(ITreeNode obj, CodeFormattingContext checker);
    private bool IsTopLevelBinaryPattern(ITreeNode obj, CodeFormattingContext checker);
    private void SpaceAroundBinaryOp(string name, Expression`1<Func`2<CSharpFormatSettingsKey, object>> setting, NodeType[] expressionType);
    private void ForceChopCompoundExpression(string name, Expression`1<Func`2<CSharpFormatSettingsKey, object>> setting, Func`2<ICSharpExpression, IStatement> getStatement);
    private void TernaryExpression();
    private void NestedTernaryExpandedStyle(string name, Func`3<VirtNode, CodeFormattingContext, bool> predicate, NestedTernaryExpressionStyle style);
    private void NestedTernarySimpleWrap();
    private void NestedTernaryCompactStyle(Func`3<VirtNode, CodeFormattingContext, bool> predicate, NestedTernaryExpressionStyle style, bool colonFirst);
    private void BuildSymmetricTernaryRule(IBuilderWithProvider`3<CSharpCodeFormattingContext, CSharpFormatSettingsKey, FormattingRule> builder);
    private void LinqExpression();
    private void LineBreaks();
    private void InterpolatedStrings();
    private IBuilderWithProvider`3<CSharpCodeFormattingContext, CSharpFormatSettingsKey, OptionTreeBlank> PreferWrapBuilder(IBuilderWithProvider`3<CSharpCodeFormattingContext, CSharpFormatSettingsKey, OptionTreeBlank> obj, IntervalFormatType ift, bool allowConditional);
    private IBuilderWithProvider`3<CSharpCodeFormattingContext, CSharpFormatSettingsKey, OptionTreeBlank> PreferNoWrapBuilder(IBuilderWithProvider`3<CSharpCodeFormattingContext, CSharpFormatSettingsKey, OptionTreeBlank> obj);
    private void WrapRules();
    private void ExprBodied(Expression`1<Func`2<CSharpFormatSettingsKey, object>> placeOnSingeLineSetting, NodeTypeSet parents);
    private void AroundStatements();
    private void SimpleSwitchSection();
    private void EmbeddedStatement(IBuilderAction`1<IBlankWithSinglePattern> builder, Expression`1<Func`2<CSharpFormatSettingsKey, object>> setting);
    private void AttributeSection(string name, NodeTypeSet nodeTypeSet, Expression`1<Func`2<CSharpFormatSettingsKey, object>> setting, int priority, NodeTypeSet& includedSets, PlaceOnSameLineAsOwner defaultValue, NodePatternBlank blank);
    private void Attributes();
    public virtual bool RemoveUserBlankLinesInStrictMode();
    public virtual bool ShouldRemoveExtraBlankLines(IFormatterStageBase`1<CSharpFormatSettingsKey> stage, CSharpCodeFormattingContext context);
    private void Aligning();
    private AlignNestedElementsRule GetBinaryExpressionAlignmentRule();
    private void Indenting();
    private void IndentChildStatements();
    private void IndentPreprocessorDirectives();
    private void IndentSwitchStatement();
    private void AligningInsideTokens();
    public virtual bool CustomReindentInsideMultilineNode(VirtNode node, IndentingStage`2<CSharpCodeFormattingContext, CSharpFormatSettingsKey> indentingStage);
    public virtual void CustomTaskFinished(VirtNode& dontReallyFinishUntilThisNode, CSharpCodeFormattingContext context, VirtNode current);
    public virtual ITreeNode GetPossibleIndentLeftBoundInsideNode(ITreeNode parent);
    public virtual ITreeNode GetPossibleIndentRightBoundInsideNode(ITreeNode parent);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignFieldsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignFieldsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignPropertiesSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignPropertiesSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignMethodsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignMethodsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignParametersSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignParametersSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignVariablesSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignVariablesSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignAssignmentsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignAssignmentsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignPropertyPatternsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignPropertyPatternsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignNestedTernarySetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignNestedTernarySetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignInvocationsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignInvocationsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignBinaryExpressionsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignBinaryExpressionsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignCommentsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignCommentsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignSwitchSectionsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignSwitchSectionsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public IScalarSetting`1<bool> get_IntAlignSwitchExpressionsSetting();
    [CompilerGeneratedAttribute]
private void set_IntAlignSwitchExpressionsSetting(IScalarSetting`1<bool> value);
    public IBuilderWithProvider`3<CSharpCodeFormattingContext, CSharpFormatSettingsKey, OptionTreeBlank> WhenTrueIntAlignInsideParent(string intAlignId, int priority);
    public ITreeNode GoUpRecursiveNodes(ITreeNode parent);
    public IOptionValue CreateIntAlignOptionValueWithParent(string intAlignId, ITreeNode treeNode, CodeFormattingContext context, int priority);
    private void IntAlign(string family, string species, Expression`1<Func`2<CSharpFormatSettingsKey, object>> key, NodeTypeSet rightNodes, NodeTypeSet parentNodes, int priority, string genus, Func`3<VirtNode, CodeFormattingContext, bool> parentChecker);
    private void IntAlignEq(string name, Expression`1<Func`2<CSharpFormatSettingsKey, object>> key, NodeType[] parents);
    private void IntAlignModifiers(string name, Expression`1<Func`2<CSharpFormatSettingsKey, object>> key, NodeType[] parents);
    private void IntAlignType(string name, string genus, Expression`1<Func`2<CSharpFormatSettingsKey, object>> key, NodeType[] parents);
    private void IntAlignComma(string name, string genus, Expression`1<Func`2<CSharpFormatSettingsKey, object>> key, NodeType[] parentNodes);
    private void IntAlignName(string name, string genus, Expression`1<Func`2<CSharpFormatSettingsKey, object>> key, NodeType nodeType, NodeType[] parents);
    private void IntAlignLBraceAndArrow(string name, Expression`1<Func`2<CSharpFormatSettingsKey, object>> key, NodeType[] parents);
    private void IntAligning();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderBase/<PureIntAlignSettings>d__162")]
public virtual IEnumerable`1<IScalarSetting`1<bool>> PureIntAlignSettings();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValueTuple`3<object, int, IScalarSetting[]>> <>n__0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<ValueTuple`3<object, int, IScalarSetting[]>> <>n__1();
    [CompilerGeneratedAttribute]
private bool <ReferenceExpressions>b__53_0(VirtNode node, CodeFormattingContext context);
    [CompilerGeneratedAttribute]
private bool <ReferenceExpressions>b__53_1(VirtNode node, CodeFormattingContext context);
    [CompilerGeneratedAttribute]
private bool <BinaryExpressions>b__61_12(VirtNode node, CodeFormattingContext context);
    [CompilerGeneratedAttribute]
private bool <BinaryExpressions>b__61_17(VirtNode node, CodeFormattingContext context);
    [CompilerGeneratedAttribute]
private bool <TernaryExpression>b__66_4(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <TernaryExpression>b__66_8(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <TernaryExpression>b__66_12(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <TernaryExpression>b__66_13(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <TernaryExpression>b__66_14(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <TernaryExpression>b__66_15(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <TernaryExpression>b__66_16(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <NestedTernarySimpleWrap>b__68_0(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private void <InterpolatedStrings>g__DescribeRules|73_7(Expression`1<Func`2<CSharpFormatSettingsKey, object>> settingAccessor, Func`3<VirtNode, CodeFormattingContext, bool> interpolatedStringPredicate, NodeType[] insertStartTokenTypes, NodeType[] insertEndTokenTypes, NodeType[] formatSpecifierTokenTypes, string ruleSetName);
    [CompilerGeneratedAttribute]
private bool <Aligning>b__85_37(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <Indenting>b__88_5(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <Indenting>b__88_7(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private bool <IntAligning>b__161_39(VirtNode node, CodeFormattingContext checker);
    [CompilerGeneratedAttribute]
private IOptionValue <IntAligning>b__161_44(object ctx, CodeFormattingContext context);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.CSharpFormatterInfoProviderPart : FormatterInfoProviderWithFluentApiPart`2<CSharpCodeFormattingContext, CSharpFormatSettingsKey> {
    public ProjectFileType MainProjectFileType { get; }
    protected CSharpFormatterInfoProviderPart(ISettingsSchema settingsSchema, ICalculatedSettingsSchema calculatedSettingsSchema, IThreading threading, Lifetime lifetime);
    public virtual ProjectFileType get_MainProjectFileType();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Formatter.EditorConfigRoslynCSharpFormatPropertiesConverter : object {
    private CollectionEvents`1<IEditorConfigConverter> myItems;
    public ICollectionEvents`1<IEditorConfigConverter> Items { get; }
    public EditorConfigRoslynCSharpFormatPropertiesConverter(Lifetime lifetime, SettingsSchema schema, IEditorConfigSchema ecSchema);
    public static bool ParseBool(object sourceValue, int index, ISettingsConverterLogger logger, bool defaultValue);
    public sealed virtual ICollectionEvents`1<IEditorConfigConverter> get_Items();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.ICSharpCustomFormattingInfoProvider {
    public abstract virtual bool CanWrap(FormattingStageContext context);
    public abstract virtual SpaceType GetBlockSpaceType(CSharpFmtStageContext ctx, CSharpCodeFormattingContext context);
    public abstract virtual bool CanModifyInsideNodeRange(CSharpCodeFormattingContext context, ITreeNode leftElement, ITreeNode rightElement);
    public abstract virtual bool CanModifyNode(ITreeNode element);
    public abstract virtual bool AllowDecoration(CSharpCodeFormattingContext context);
    public abstract virtual bool CanDeBlock(IBlock node);
    public abstract virtual ITreeNode GetLChild(CSharpFmtStageContext context);
    public abstract virtual void RunFormatterForEmbeddedLanguages(IFile currentFile, TreeTextRange range, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    public abstract virtual bool NeedsOldEngineEx(IContextBoundSettingsStore settingsStore);
    public abstract virtual SpaceType GetInvocationSpaces(CSharpFmtStageContext context, FmtSettingsClassic`1<CSharpFormatSettingsKey> formatSettings);
    public abstract virtual FmtSettingsClassic`1<CSharpFormatSettingsKey> AdjustFormattingSettings(FmtSettingsClassic`1<CSharpFormatSettingsKey> settings, ISettingsOptimization settingsOptimization);
    public abstract virtual FmtSettingsHolder`1<CSharpFormatSettingsKey> AdjustFormattingSettings(FmtSettingsHolder`1<CSharpFormatSettingsKey> settings, ISettingsOptimization settingsOptimization);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Abstract : ModifierConstraintBase {
    [DisplayAttribute]
public string ParameterName { get; }
    public virtual string get_ParameterName();
    protected virtual bool Match(IModifiersOwner element);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Access : object {
    [CompilerGeneratedAttribute]
private AccessModifier <Is>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AccessModifier> <Order>k__BackingField;
    [DefaultValueAttribute("0")]
[DisplayAttribute]
public AccessModifier Is { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[TypeConverterAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Serialization.EnumCollectionTypeConverter`1<JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.AccessModifier>")]
public IList`1<AccessModifier> Order { get; public set; }
    [DisplayAttribute]
public string ParameterName { get; }
    [CompilerGeneratedAttribute]
public AccessModifier get_Is();
    [CompilerGeneratedAttribute]
public void set_Is(AccessModifier value);
    [CompilerGeneratedAttribute]
public IList`1<AccessModifier> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(IList`1<AccessModifier> value);
    [UsedImplicitlyAttribute]
public bool ShouldSerializeOrder();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    private static bool Matches(ITreeNode node, AccessModifier modifier);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    public sealed virtual string get_ParameterName();
    public sealed virtual object GetKey(ITreeNode node);
    public sealed virtual IComparer`1<ITreeNode> GetComparer();
    private IEnumerable`1<AccessModifier> GetSortOrder();
    [CompilerGeneratedAttribute]
private int <GetComparer>b__16_0(ITreeNode x, ITreeNode y);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.AccessModifier : Enum {
    public int value__;
    [DescriptionAttribute("private")]
public static AccessModifier Private;
    [DescriptionAttribute("private protected")]
public static AccessModifier PrivateProtected;
    [DescriptionAttribute("protected")]
public static AccessModifier Protected;
    [DescriptionAttribute("internal")]
public static AccessModifier Internal;
    [DescriptionAttribute("protected internal")]
public static AccessModifier ProtectedInternal;
    [DescriptionAttribute("public")]
public static AccessModifier Public;
    [DescriptionAttribute("file local")]
public static AccessModifier FileLocal;
    [DescriptionAttribute("any")]
[BrowsableAttribute("False")]
public static AccessModifier Any;
}
[ContentPropertyAttribute("Constraints")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.And : object {
    [CompilerGeneratedAttribute]
private IList`1<INodeConstraint> <Constraints>k__BackingField;
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<INodeConstraint> Constraints { get; }
    public And(INodeConstraint[] constraints);
    public And(IEnumerable`1<INodeConstraint> constraints);
    [CompilerGeneratedAttribute]
public IList`1<INodeConstraint> get_Constraints();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.AttributeTarget : Enum {
    public int value__;
    [DescriptionAttribute("Self")]
public static AttributeTarget Self;
    [DescriptionAttribute("Assembly")]
[BrowsableAttribute("False")]
public static AttributeTarget Assembly;
    [DescriptionAttribute("Module")]
[BrowsableAttribute("False")]
public static AttributeTarget Module;
    [DescriptionAttribute("Field")]
public static AttributeTarget Field;
    [DescriptionAttribute("Event")]
public static AttributeTarget Event;
    [DescriptionAttribute("Method")]
public static AttributeTarget Method;
    [DescriptionAttribute("Param")]
[BrowsableAttribute("False")]
public static AttributeTarget Param;
    [DescriptionAttribute("Property")]
public static AttributeTarget Property;
    [DescriptionAttribute("Return")]
public static AttributeTarget Return;
    [DescriptionAttribute("Type")]
public static AttributeTarget Type;
    [DescriptionAttribute("any")]
[BrowsableAttribute("False")]
public static AttributeTarget Any;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Body : SortDescriptor`1<Nullable`1<bool>> {
    [CompilerGeneratedAttribute]
private BodyType <Type>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DisplayAttribute]
public BodyType Type { get; public set; }
    [DisplayAttribute]
public string ParameterName { get; }
    [CompilerGeneratedAttribute]
public BodyType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(BodyType value);
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    private static bool Matches(ITreeNode node, BodyType type);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    public sealed virtual string get_ParameterName();
    private sealed virtual override object JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor.GetKey(ITreeNode node);
    protected virtual Nullable`1<bool> GetSortKey(ITreeNode node);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.BodyType : Enum {
    public int value__;
    [DisplayAttribute]
public static BodyType Block;
    [DisplayAttribute]
public static BodyType Expression;
    [BrowsableAttribute("False")]
public static BodyType Any;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DeclarationKind : Enum {
    public int value__;
    public static DeclarationKind Namespace;
    public static DeclarationKind Type;
    public static DeclarationKind Class;
    public static DeclarationKind Struct;
    public static DeclarationKind Enum;
    public static DeclarationKind Interface;
    public static DeclarationKind Delegate;
    public static DeclarationKind Record;
    public static DeclarationKind Member;
    public static DeclarationKind Method;
    public static DeclarationKind Constructor;
    public static DeclarationKind Destructor;
    public static DeclarationKind Operator;
    public static DeclarationKind Constant;
    public static DeclarationKind Field;
    public static DeclarationKind Property;
    [DescriptionAttribute("Auto-property")]
public static DeclarationKind Autoproperty;
    public static DeclarationKind Indexer;
    public static DeclarationKind Event;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DependencyProperty : GroupBase {
    [NotNullAttribute]
private static IGroupDescriptor[] ourGroupBy;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string DisplayName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public IList`1<IGroupDescriptor> GroupBy { get; }
    private static DependencyProperty();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    public virtual IList`1<IGroupDescriptor> get_GroupBy();
    public virtual INodeGroup CreateNodeGroup();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DependencyPropertyBase : object {
    protected internal static string GetKey(ITreeNode node, DPPart& part);
    private static bool IsOfType(string typeName, IParameter parameter);
    private static string TryGetDPName(IField field, DPPart& part);
    private static IField TryGetDPField(ITreeNode node);
    private static string NotPart(DPPart& dpPart);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DependencyPropertyPart : DependencyPropertyBase {
    [CompilerGeneratedAttribute]
private DPPart <Match>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public DPPart Match { get; public set; }
    [CompilerGeneratedAttribute]
public DPPart get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(DPPart value);
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DPName : DependencyPropertyBase {
    [CompilerGeneratedAttribute]
private SortDirection <Direction>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SortDirection Direction { get; public set; }
    public string ParameterName { get; }
    [CompilerGeneratedAttribute]
public SortDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(SortDirection value);
    public sealed virtual string get_ParameterName();
    private sealed virtual override object JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor.GetKey(ITreeNode node);
    public sealed virtual IComparer`1<ITreeNode> GetComparer();
    public sealed virtual int Compare(ITreeNode x, ITreeNode y);
    private int GetSign();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DPPart : Enum {
    public int value__;
    [BrowsableAttribute("False")]
public static DPPart NotPart;
    public static DPPart Field;
    public static DPPart Key;
    public static DPPart Property;
    public static DPPart Handler;
    public static DPPart Setter;
    public static DPPart Getter;
    [BrowsableAttribute("False")]
public static DPPart Any;
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DropRegions : Enum {
    public int value__;
    [DisplayAttribute]
public static DropRegions None;
    [DisplayAttribute]
public static DropRegions AllExceptGenerated;
    [DisplayAttribute]
public static DropRegions All;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Entry : object {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private INodeConstraint <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ISortDescriptor> <SortBy>k__BackingField;
    [DefaultValueAttribute("50")]
[DisplayAttribute]
public int Priority { get; public set; }
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string DisplayName { get; public set; }
    [DefaultValueAttribute("")]
public INodeConstraint Match { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[DisplayAttribute]
public IList`1<ISortDescriptor> SortBy { get; }
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public INodeConstraint get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(INodeConstraint value);
    [CompilerGeneratedAttribute]
public IList`1<ISortDescriptor> get_SortBy();
    public sealed virtual INodeGroup CreateNodeGroup();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.ErrorTolerantObjectReader : XamlReader {
    private XamlWriter myWriter;
    private XamlObjectReader myInner;
    public XamlNodeType NodeType { get; }
    public bool IsEof { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlType Type { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    public XamlSchemaContext SchemaContext { get; }
    public ErrorTolerantObjectReader(XamlWriter writer, XamlObjectReader inner);
    public virtual XamlNodeType get_NodeType();
    public virtual bool get_IsEof();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlType get_Type();
    public virtual object get_Value();
    public virtual XamlMember get_Member();
    public virtual XamlSchemaContext get_SchemaContext();
    public virtual bool Read();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.ErrorTolerantObjectWriter : XamlWriter {
    private XamlReader myReader;
    private XamlObjectWriter myInner;
    private Stack`1<XamlType> myExpectedTypes;
    public object Result { get; }
    public XamlSchemaContext SchemaContext { get; }
    public ErrorTolerantObjectWriter(XamlReader reader, XamlObjectWriter inner);
    public object get_Result();
    public virtual XamlSchemaContext get_SchemaContext();
    public virtual void WriteGetObject();
    public virtual void WriteStartObject(XamlType type);
    private Type TryFindSubstitute();
    public virtual void WriteEndObject();
    public virtual void WriteStartMember(XamlMember xamlMember);
    public virtual void WriteEndMember();
    public virtual void WriteValue(object value);
    public virtual void WriteNamespace(NamespaceDeclaration namespaceDeclaration);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.EventHandlerMatchingStrategy : Enum {
    public int value__;
    [DisplayAttribute]
public static EventHandlerMatchingStrategy Signature;
    [DisplayAttribute]
public static EventHandlerMatchingStrategy Subscription;
    [DisplayAttribute]
public static EventHandlerMatchingStrategy SubscriptionOrSignature;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Extern : ModifierConstraintBase {
    [DisplayAttribute]
public string ParameterName { get; }
    public virtual string get_ParameterName();
    protected virtual bool Match(IModifiersOwner element);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.FileLayoutPatternSerializer : object {
    private sealed virtual override string JetBrains.Application.UI.Controls.LayoutDesigner.Components.ILayoutDesignerSerializer.Serialize(object value);
    private sealed virtual override object JetBrains.Application.UI.Controls.LayoutDesigner.Components.ILayoutDesignerSerializer.Deserialize(string value);
    public Patterns Deserialize(string serializedValue);
    public string Serialize(Patterns value);
}
[ContentPropertyAttribute("Entries")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.FilePattern : object {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private DropRegions <RemoveRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IReorderableEntry> <Entries>k__BackingField;
    [DefaultValueAttribute("50")]
public int Priority { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public DropRegions RemoveRegions { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<IReorderableEntry> Entries { get; }
    private IEnumerable`1<IReorderableEntry> JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IPattern.Entries { get; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public sealed virtual DropRegions get_RemoveRegions();
    [CompilerGeneratedAttribute]
public void set_RemoveRegions(DropRegions value);
    [CompilerGeneratedAttribute]
public IList`1<IReorderableEntry> get_Entries();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual ITreeRange GetReorderableRange(ITreeNode node);
    private ITreeRange Try(ICSharpFile file);
    public ITreeRange Try(ICSharpNamespaceDeclaration namespace);
    private ITreeRange ThrowInvalidOperation();
    private sealed virtual override IEnumerable`1<IReorderableEntry> JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IPattern.get_Entries();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Group : GroupBase {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string DisplayName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    public virtual INodeGroup CreateNodeGroup();
}
[ContentPropertyAttribute("Entries")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.GroupBase : object {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private INodeConstraint <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IReorderableEntry> <Entries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IGroupDescriptor> <GroupBy>k__BackingField;
    [DefaultValueAttribute("50")]
[DisplayAttribute]
public int Priority { get; public set; }
    [DefaultValueAttribute("")]
public INodeConstraint Match { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<IReorderableEntry> Entries { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<IGroupDescriptor> GroupBy { get; }
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public INodeConstraint get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(INodeConstraint value);
    [CompilerGeneratedAttribute]
public virtual IList`1<IReorderableEntry> get_Entries();
    [CompilerGeneratedAttribute]
public virtual IList`1<IGroupDescriptor> get_GroupBy();
    public abstract virtual INodeGroup CreateNodeGroup();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.HandlesEvent : object {
    [CompilerGeneratedAttribute]
private EventHandlerMatchingStrategy <MatchBy>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DisplayAttribute]
public EventHandlerMatchingStrategy MatchBy { get; public set; }
    [CompilerGeneratedAttribute]
public EventHandlerMatchingStrategy get_MatchBy();
    [CompilerGeneratedAttribute]
public void set_MatchBy(EventHandlerMatchingStrategy value);
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    private bool TryMatchBySignature(IMethod method);
    private bool TryMatchBySubscription(IMethod method);
    private static bool IsSubscribedToEvent(ICSharpExpression expression);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.HasAttribute : object {
    private Regex myRegex;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherited>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeTarget <Target>k__BackingField;
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string Name { get; public set; }
    [DefaultValueAttribute("False")]
[ObsoleteAttribute]
public bool Inherited { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DisplayAttribute]
public AttributeTarget Target { get; public set; }
    protected Regex Regex { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Inherited();
    [CompilerGeneratedAttribute]
public void set_Inherited(bool value);
    [CompilerGeneratedAttribute]
public AttributeTarget get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(AttributeTarget value);
    protected Regex get_Regex();
    public sealed virtual bool Matches(ITreeNode element, INodeMatchingContext ctx);
    private TreeNodeCollection`1<IAttribute> TryGetAttributes(ITreeNode element);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    [CompilerGeneratedAttribute]
internal static AttributeTarget <Matches>g__GetTargetFromAttribute|16_5(IAttribute attr, ITreeNode node);
    [CompilerGeneratedAttribute]
internal static AttributeTarget <Matches>g__GetTargetFromNodeType|16_6(ITreeNode node);
}
[ContentPropertyAttribute("Match")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.HasMember : object {
    [CompilerGeneratedAttribute]
private INodeConstraint <Match>k__BackingField;
    [DefaultValueAttribute("")]
public INodeConstraint Match { get; public set; }
    [CompilerGeneratedAttribute]
public INodeConstraint get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(INodeConstraint value);
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IFileLayoutErrorPresenter {
    public abstract virtual void HandlePatternParsingError(Exception ex);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor {
    public string ParameterName { get; }
    public abstract virtual string get_ParameterName();
    public abstract virtual object GetKey(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.ImplementsInterface : SortDescriptor`1<string> {
    private Regex myRegex;
    [CompilerGeneratedAttribute]
private bool <Immediate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DefaultValueAttribute("False")]
[DisplayAttribute]
public bool Immediate { get; public set; }
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string Name { get; public set; }
    protected Regex Regex { get; }
    [DisplayAttribute]
public string ParameterName { get; }
    [CompilerGeneratedAttribute]
public bool get_Immediate();
    [CompilerGeneratedAttribute]
public void set_Immediate(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    protected Regex get_Regex();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    private static IEnumerable`1<IDeclaredType> GetRootInterfaces(IOverridableMember member);
    private static IEnumerable`1<IDeclaredType> GetImmediateInterfaces(IOverridableMember member);
    private static IEnumerable`1<IDeclaredType> GetSuperInterfaces(ITypeElement typeElement);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    private IDeclaredType GetSuperInterface(IDeclaredElement element);
    public sealed virtual string get_ParameterName();
    public sealed virtual object GetKey(ITreeNode node);
    protected virtual string GetSortKey(ITreeNode node);
    [CompilerGeneratedAttribute]
private bool <Matches>b__12_0(IDeclaredType if);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.InheritsFromType : object {
    private Regex myRegex;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string Name { get; public set; }
    protected Regex Regex { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    protected Regex get_Regex();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    [CompilerGeneratedAttribute]
private bool <Matches>b__8_0(IDeclaredType if);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.InitializedStaticFieldProblem : object {
    public static void DiscoverConstraints(ITreeRange range, IList`1<ReorderConstraint> constraints, StaticFieldReorderingPolicy policy);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.INodeConstraint {
    public abstract virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public abstract virtual Nullable`1<int> Compare(INodeConstraint other);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.INodeGroup {
    public int Priority { get; }
    public INodeConstraint Constraint { get; }
    public abstract virtual int get_Priority();
    public abstract virtual INodeConstraint get_Constraint();
    public abstract virtual bool Accept(ITreeNode node, INodeMatchingContext ctx);
    public abstract virtual IEnumerable`1<ITreeNode> GetArrangedNodes(IPsiModule module);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.INodeGroups {
    public abstract virtual IReadOnlyCollection`1<INodeGroup> InPriorityOrder();
    public abstract virtual IReadOnlyCollection`1<INodeGroup> InDisplayOrder();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.INodeMatchingContext {
    public abstract virtual void Push(object obj);
    public abstract virtual void Pop();
    [CanBeNullAttribute]
public abstract virtual T FindNearest();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IPattern {
    public int Priority { get; }
    public DropRegions RemoveRegions { get; }
    public IEnumerable`1<IReorderableEntry> Entries { get; }
    public abstract virtual int get_Priority();
    public abstract virtual DropRegions get_RemoveRegions();
    public abstract virtual IEnumerable`1<IReorderableEntry> get_Entries();
    public abstract virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public abstract virtual ITreeRange GetReorderableRange(ITreeNode node);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IReorderableEntry {
    public abstract virtual INodeGroup CreateNodeGroup();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.ISortDescriptor {
    public abstract virtual IComparer`1<ITreeNode> GetComparer();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Kind : object {
    [CompilerGeneratedAttribute]
private DeclarationKind <Is>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DeclarationKind> <Order>k__BackingField;
    [DefaultValueAttribute("0")]
[DisplayAttribute]
public DeclarationKind Is { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[TypeConverterAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Serialization.EnumCollectionTypeConverter`1<JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.DeclarationKind>")]
public IList`1<DeclarationKind> Order { get; public set; }
    [DisplayAttribute]
public string ParameterName { get; }
    [CompilerGeneratedAttribute]
public DeclarationKind get_Is();
    [CompilerGeneratedAttribute]
public void set_Is(DeclarationKind value);
    [CompilerGeneratedAttribute]
public IList`1<DeclarationKind> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(IList`1<DeclarationKind> value);
    [UsedImplicitlyAttribute]
public bool ShouldSerializeOrder();
    public sealed virtual bool Matches(ITreeNode element, INodeMatchingContext ctx);
    private static bool Matches(ITreeNode element, DeclarationKind kind);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    public sealed virtual string get_ParameterName();
    private sealed virtual override object JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor.GetKey(ITreeNode node);
    public sealed virtual IComparer`1<ITreeNode> GetComparer();
    public string MacroValue(ITreeNode node);
    [CompilerGeneratedAttribute]
private int <GetComparer>b__16_0(ITreeNode x, ITreeNode y);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.MemberReorderingException : Exception {
    public MemberReorderingException(string message);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.MemberReorderingProcessor : object {
    private JetHashSet`1<string> myKnownGeneratedRegions;
    private Patterns myPatterns;
    public MemberReorderingProcessor(Patterns patterns, JetHashSet`1<string> knownGeneratedRegions);
    public void Process(ITreeNode node);
    private void MoveFilteredNodesInsideFileScopedNamespace(ITreeNode node);
    private static void ReplaceChildRange2(ITreeRange oldRange, ITreeNode[] newNodes);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.MemberReorderingProcessor/<PostOrderTraversal>d__9")]
private static IEnumerable`1<ITreeNode> PostOrderTraversal(ITreeNode node);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.ModifierConstraintBase : SortDescriptor`1<Nullable`1<bool>> {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SortDirection Direction { get; public set; }
    public string ParameterName { get; }
    public virtual SortDirection get_Direction();
    public virtual void set_Direction(SortDirection value);
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    protected virtual Nullable`1<bool> GetSortKey(ITreeNode node);
    public abstract virtual string get_ParameterName();
    private sealed virtual override object JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor.GetKey(ITreeNode node);
    protected abstract virtual bool Match(IModifiersOwner element);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Name : SortDescriptor`1<string> {
    [CompilerGeneratedAttribute]
private string <Is>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string Is { get; public set; }
    [DefaultValueAttribute("False")]
[DisplayAttribute]
public bool IgnoreCase { get; public set; }
    [DisplayAttribute]
public string ParameterName { get; }
    [CompilerGeneratedAttribute]
public string get_Is();
    [CompilerGeneratedAttribute]
public void set_Is(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    public sealed virtual bool Matches(ITreeNode element, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    public sealed virtual string get_ParameterName();
    private sealed virtual override object JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor.GetKey(ITreeNode node);
    protected virtual string GetSortKey(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.NodeGroup : object {
    private string myDisplayName;
    private IEnumerable`1<ISortDescriptor> mySortDescriptors;
    private IList`1<ITreeNode> myNodes;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private INodeConstraint <Constraint>k__BackingField;
    public int Priority { get; }
    public INodeConstraint Constraint { get; }
    public NodeGroup(int priority, string displayName, INodeConstraint constraint, IEnumerable`1<ISortDescriptor> orderBy);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual INodeConstraint get_Constraint();
    public sealed virtual bool Accept(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual IEnumerable`1<ITreeNode> GetArrangedNodes(IPsiModule module);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.NodeGroups : object {
    private IReadOnlyCollection`1<INodeGroup> myGroups;
    public NodeGroups(IEnumerable`1<IReorderableEntry> templates);
    public NodeGroups(IEnumerable`1<INodeGroup> groups);
    public sealed virtual IReadOnlyCollection`1<INodeGroup> InPriorityOrder();
    public sealed virtual IReadOnlyCollection`1<INodeGroup> InDisplayOrder();
    private Nullable`1<int> ByPriority(INodeGroup x, INodeGroup y);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.NodeMatchingContext : object {
    [NotNullAttribute]
private IList`1<object> myStack;
    public sealed virtual void Push(object obj);
    public sealed virtual void Pop();
    public sealed virtual T FindNearest();
    public void Clear();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.NodeMatchingContextExtensions : object {
    [ExtensionAttribute]
public static LocalDisposable`1<INodeMatchingContext> Using(INodeMatchingContext ctx, object obj);
}
[ContentPropertyAttribute("Constraint")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Not : object {
    [CompilerGeneratedAttribute]
private INodeConstraint <Constraint>k__BackingField;
    public INodeConstraint Constraint { get; public set; }
    [CompilerGeneratedAttribute]
public INodeConstraint get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(INodeConstraint value);
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
[ContentPropertyAttribute("Constraints")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Or : object {
    [CompilerGeneratedAttribute]
private IList`1<INodeConstraint> <Constraints>k__BackingField;
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<INodeConstraint> Constraints { get; }
    public Or(INodeConstraint[] constraints);
    public Or(IEnumerable`1<INodeConstraint> constraints);
    [CompilerGeneratedAttribute]
public IList`1<INodeConstraint> get_Constraints();
    public sealed virtual bool Matches(ITreeNode element, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Override : ModifierConstraintBase {
    [DisplayAttribute]
public string ParameterName { get; }
    protected virtual bool Match(IModifiersOwner element);
    public virtual string get_ParameterName();
    private sealed virtual override object JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor.GetKey(ITreeNode node);
}
[ContentPropertyAttribute("Items")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Patterns : object {
    [CompilerGeneratedAttribute]
private IList`1<IPattern> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private StaticFieldReorderingPolicy <StaticFieldReorderingPolicy>k__BackingField;
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<IPattern> Items { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DisplayAttribute]
public StaticFieldReorderingPolicy StaticFieldReorderingPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<IPattern> get_Items();
    [CompilerGeneratedAttribute]
public StaticFieldReorderingPolicy get_StaticFieldReorderingPolicy();
    [CompilerGeneratedAttribute]
public void set_StaticFieldReorderingPolicy(StaticFieldReorderingPolicy value);
    public void Merge(Patterns pattern);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Placeholder : object {
    public static string FILENAME;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Readonly : ModifierConstraintBase {
    [DisplayAttribute]
public string ParameterName { get; }
    public virtual string get_ParameterName();
    protected virtual bool Match(IModifiersOwner element);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.RegexWithSubstitutions : object {
    private static Regex ourRegex;
    private static ConditionalWeakTable`2<object, Regex> ourCache;
    private static Dictionary`2<string, Func`2<ITreeNode, string>> ourVariables;
    private static RegexWithSubstitutions();
    [NotNullAttribute]
public static Regex GetOrCreate(string pattern, bool ignoreCase, ITreeNode node);
    private static RegexOptions Options(bool ignoreCase);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Region : GroupBase {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual INodeGroup CreateNodeGroup();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.ReorderConstraint : object {
    [CompilerGeneratedAttribute]
private ITreeNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Right>k__BackingField;
    public ITreeNode Left { get; }
    public ITreeNode Right { get; }
    public ReorderConstraint(ITreeNode left, ITreeNode right);
    [CompilerGeneratedAttribute]
public ITreeNode get_Left();
    [CompilerGeneratedAttribute]
public ITreeNode get_Right();
    [NotNullAttribute]
public static ReorderConstraint Create(ITreeNode x, ITreeNode y);
    public static IList`1<ReorderConstraint> Discover(ITreeRange range, StaticFieldReorderingPolicy staticFieldReorderingPolicy);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.ReorderConstraintsExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITreeNode> Apply(IEnumerable`1<ITreeNode> nodes, IList`1<ReorderConstraint> constraints);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Sealed : ModifierConstraintBase {
    [DisplayAttribute]
public string ParameterName { get; }
    public virtual string get_ParameterName();
    protected virtual bool Match(IModifiersOwner element);
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.SerializableXmlTypeProblem : object {
    public static void DiscoverConstraints(ITreeRange range, IList`1<ReorderConstraint> constraints);
    private static bool IsConstrainedXmlElement(IAttributesOwner attributeOwner);
    private static IAttributesOwner TryGetAttributesOwner(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Serialization.EnumCollectionTypeConverter`1 : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.SortDescriptor`1 : object {
    [CompilerGeneratedAttribute]
private SortDirection <Direction>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DisplayAttribute]
public SortDirection Direction { get; public set; }
    [CompilerGeneratedAttribute]
public virtual SortDirection get_Direction();
    [CompilerGeneratedAttribute]
public virtual void set_Direction(SortDirection value);
    public sealed virtual IComparer`1<ITreeNode> GetComparer();
    public sealed virtual int Compare(ITreeNode x, ITreeNode y);
    private int GetSign();
    protected abstract virtual T GetSortKey(ITreeNode node);
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.SortDirection : Enum {
    public int value__;
    [DisplayAttribute]
public static SortDirection Ascending;
    [DisplayAttribute]
public static SortDirection Descending;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Static : ModifierConstraintBase {
    public string ParameterName { get; }
    public virtual string get_ParameterName();
    protected virtual bool Match(IModifiersOwner element);
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.StaticFieldReorderingPolicy : Enum {
    public int value__;
    [DisplayAttribute]
public static StaticFieldReorderingPolicy Strict;
    [DisplayAttribute]
public static StaticFieldReorderingPolicy Relaxed;
    [DisplayAttribute]
public static StaticFieldReorderingPolicy Unrestricted;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Type : SortDescriptor`1<string> {
    private Regex myRegex;
    [CompilerGeneratedAttribute]
private string <Is>k__BackingField;
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string Is { get; public set; }
    protected Regex Regex { get; }
    [DisplayAttribute]
public string ParameterName { get; }
    [CompilerGeneratedAttribute]
public string get_Is();
    [CompilerGeneratedAttribute]
public void set_Is(string value);
    protected Regex get_Regex();
    private Regex InitializeRegex();
    private sealed virtual override object JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IGroupDescriptor.GetKey(ITreeNode node);
    public sealed virtual string get_ParameterName();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    protected virtual string GetSortKey(ITreeNode node);
    private IType GetType(ITreeNode node);
}
[ContentPropertyAttribute("Entries")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.TypePattern : object {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private DropRegions <RemoveRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private INodeConstraint <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IReorderableEntry> <Entries>k__BackingField;
    [DefaultValueAttribute("50")]
[DisplayAttribute]
public int Priority { get; public set; }
    [DefaultValueAttribute("")]
[DisplayAttribute]
public string DisplayName { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DisplayAttribute]
public DropRegions RemoveRegions { get; public set; }
    [DefaultValueAttribute("")]
public INodeConstraint Match { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList`1<IReorderableEntry> Entries { get; }
    private IEnumerable`1<IReorderableEntry> JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IPattern.Entries { get; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DropRegions get_RemoveRegions();
    [CompilerGeneratedAttribute]
public void set_RemoveRegions(DropRegions value);
    [CompilerGeneratedAttribute]
public INodeConstraint get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(INodeConstraint value);
    [CompilerGeneratedAttribute]
public IList`1<IReorderableEntry> get_Entries();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual ITreeRange GetReorderableRange(ITreeNode node);
    private sealed virtual override IEnumerable`1<IReorderableEntry> JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.IPattern.get_Entries();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Unconstrained : object {
    [NotNullAttribute]
public static INodeConstraint Instance;
    private static Unconstrained();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
    public virtual string ToString();
}
[EditorBrowsableAttribute("1")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.UnknownConstraint : UnknownElement {
    public UnknownConstraint(XamlNodeQueue queue);
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.UnknownElement : object {
    private XamlNodeQueue myQueue;
    [BrowsableAttribute("False")]
public XamlReader XamlReader { get; }
    protected UnknownElement(XamlNodeQueue queue);
    public XamlReader get_XamlReader();
}
[EditorBrowsableAttribute("1")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.UnknownEntry : UnknownElement {
    public UnknownEntry(XamlNodeQueue queue);
    public sealed virtual INodeGroup CreateNodeGroup();
}
[EditorBrowsableAttribute("1")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.UnknownGroupDescriptor : UnknownElement {
    public string ParameterName { get; }
    public UnknownGroupDescriptor(XamlNodeQueue queue);
    public sealed virtual string get_ParameterName();
    public sealed virtual object GetKey(ITreeNode node);
}
[EditorBrowsableAttribute("1")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.UnknownPattern : UnknownElement {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public int Priority { get; }
    [BrowsableAttribute("False")]
public DropRegions RemoveRegions { get; }
    [BrowsableAttribute("False")]
public IEnumerable`1<IReorderableEntry> Entries { get; }
    public UnknownPattern(XamlNodeQueue queue);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    public sealed virtual DropRegions get_RemoveRegions();
    public sealed virtual IEnumerable`1<IReorderableEntry> get_Entries();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual ITreeRange GetReorderableRange(ITreeNode node);
}
[EditorBrowsableAttribute("1")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.UnknownSortDescriptor : UnknownElement {
    public UnknownSortDescriptor(XamlNodeQueue queue);
    public sealed virtual IComparer`1<ITreeNode> GetComparer();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Unmatchable : object {
    [NotNullAttribute]
public static INodeConstraint Instance;
    private static Unmatchable();
    public sealed virtual bool Matches(ITreeNode node, INodeMatchingContext ctx);
    public sealed virtual Nullable`1<int> Compare(INodeConstraint other);
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Utils.DeclaredElementNavigator : object {
    public static IDeclaredElement GetDeclaredElement(ITreeNode node);
    private static IDeclaredElement Visit(IMultipleDeclaration multi);
    private static IDeclaredElement Visit(IDeclaration declaration);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.MemberReordering.Virtual : ModifierConstraintBase {
    [DisplayAttribute]
public string ParameterName { get; }
    public virtual string get_ParameterName();
    protected virtual bool Match(IModifiersOwner element);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.Qualifiers : object {
    [NotNullAttribute]
private static Key ourIsRedundant;
    private static Qualifiers();
    [ExtensionAttribute]
[PureAttribute]
public static bool IsQualifierRedundant(IReferenceName reference);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsQualifierRedundant(IQualifiableReference reference);
    [ExtensionAttribute]
public static void MarkAsRedundant(IReferenceName reference);
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.CodeStyle.SpaceType : Enum {
    public int value__;
    public static SpaceType Default;
    public static SpaceType NoSpace;
    public static SpaceType Horizontal;
    public static SpaceType Vertical;
    public static SpaceType VerticalNearBrackets;
}
[FlagsAttribute]
internal enum JetBrains.ReSharper.Psi.CSharp.Impl.CollectionExpressionReferenceKinds : Enum {
    public int value__;
    public static CollectionExpressionReferenceKinds None;
    public static CollectionExpressionReferenceKinds Add;
    public static CollectionExpressionReferenceKinds GetEnumerator;
    public static CollectionExpressionReferenceKinds MoveNext;
    public static CollectionExpressionReferenceKinds Current;
    public static CollectionExpressionReferenceKinds CountOrLength;
    public static CollectionExpressionReferenceKinds Create;
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Completion.CompletionUtil : object {
    [NotNullAttribute]
public static ISymbolTable ApplyReferenceExpressionFilters(IAccessContext context, ITreeNode referenceNode, ISymbolTable symbolTable);
    [NotNullAttribute]
public static ISymbolTable ApplyReferenceNameFilters(IAccessContext context, ITreeNode element, ISymbolTable symbolTable);
    [NotNullAttribute]
private static ISymbolFilter GetAttributeArgumentFilter(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Completion.CSharpStaticCompletionFilter : SimpleSymbolInfoFilter {
    [NotNullAttribute]
private IAccessContext myContext;
    public ResolveErrorType ErrorType { get; }
    public CSharpStaticCompletionFilter(IAccessContext context);
    public virtual bool Accepts(ISymbolInfo info);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ConstructorInTargetTypedNewSearcher : ImplicitConstructorUsageSearcherBase {
    private TargetTypedObjectCreationCache myTargetTypedObjectCreationCache;
    public ConstructorInTargetTypedNewSearcher(IDomainSpecificSearcherFactory searchWordsProvider, TargetTypedObjectCreationCache targetTypedObjectCreationCache, GlobalUsingsCache globalUsingsCache, ImplicitObjectCreationSearcherParameters parameters);
    public sealed virtual ValueTuple`2<IDomainSpecificSearcher, ISearchDomain> TryCreateSecondPhaseInfo(SearchDomainFactory searchDomainFactory, ISearchDomain originalSearchDomain, HashSet`1<IPsiSourceFile> processedFiles);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    [PureAttribute]
private ISearchDomain CreateAdditionalSearchDomain(SearchDomainFactory searchDomainFactory, ISearchDomain originalSearchDomain, HashSet`1<IPsiSourceFile> processedFiles);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ProcessElement>g__ShouldProcessTargetTypedObjectCreation|4_0(IObjectCreationExpression objectCreationExpression, <>c__DisplayClass4_0`1& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.AttributeArgumentMultiplexor : CSharpControlFlowMultiplexor {
    [NotNullAttribute]
public ICSharpArgument Argument { get; }
    public AttributeArgumentMultiplexor(ICSharpArgument argument);
    public ICSharpArgument get_Argument();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.BitVector64 : ValueType {
    [DebuggerBrowsableAttribute("0")]
private ulong myVector;
    public static BitVector64 Empty;
    internal ulong Vector { get; }
    internal BitVector64(ulong vector);
    private static BitVector64();
    internal ulong get_Vector();
    [PureAttribute]
public bool GetBit(int index);
    [PureAttribute]
public BitVector64 SetBit(int index);
    [PureAttribute]
public BitVector64 SetBitAndClearOther(int index);
    [PureAttribute]
public BitVector64 Clear();
    [PureAttribute]
public IList`1<int> Bits();
    private int NumberOfSetBits();
    public sealed virtual bool Equals(BitVector64 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(BitVector64 left, BitVector64 right);
    public static bool op_Inequality(BitVector64 left, BitVector64 right);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.BitVectorArray : ValueType {
    private static int VectorItemSize;
    private short myBitsPerItem;
    [NotNullAttribute]
private UInt32[] myVector;
    private int myHashCode;
    public BitVectorArray(short items, short bitsPerItem);
    private BitVectorArray(BitVectorArray other);
    private BitVectorArray(int arraySize, short bitsPerItem);
    [PureAttribute]
public bool GetBit(int item, int bit);
    public bool SetBit(int item, int bit, BitVectorArray& result);
    private bool SetBitInternal(int item, int bit, BitVectorArray& result, bool copyOnChange);
    public bool SetBitAndClearOtherBits(Int32[] items, int bit, BitVectorArray& result);
    public bool SetBitAndClearOtherBits(int item, int bit, BitVectorArray& result);
    public bool SetBitAndClearOtherBitsInternal(int item, int bit, BitVectorArray& result, bool copyOnChange);
    public bool Clear(Int32[] items, BitVectorArray& result);
    public bool Clear(int item, BitVectorArray& result);
    public bool Clear(BitVectorArray& result);
    private bool Clear(int item, BitVectorArray& result, bool copyOnChange);
    public bool Copy(int from, int to, BitVectorArray& result);
    [PureAttribute]
public BitVector64 GetItem64(int item);
    public bool SetItem64(BitVector64 value, int item, BitVectorArray& result);
    public static bool op_Equality(BitVectorArray left, BitVectorArray right);
    public static bool op_Inequality(BitVectorArray left, BitVectorArray right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static int CalculateHashCode(UInt32[] values);
    [PureAttribute]
[NotNullAttribute]
public IList`1<int> Bits(int item);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.BooleanConditionalExpressionExitMultiplexor : CSharpControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private ControlFlowEdgeCondition <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<BooleanConditionalExpressionExitMultiplexor> <AllConditionExitMultiplexors>k__BackingField;
    public ControlFlowEdgeCondition Condition { get; }
    [NotNullAttribute]
public IReadOnlyList`1<BooleanConditionalExpressionExitMultiplexor> AllConditionExitMultiplexors { get; internal set; }
    public BooleanConditionalExpressionExitMultiplexor(IConditionalTernaryExpression conditionalExpression, ControlFlowEdgeCondition condition, IReadOnlyList`1<BooleanConditionalExpressionExitMultiplexor> allConditionExitMultiplexors);
    [CompilerGeneratedAttribute]
public ControlFlowEdgeCondition get_Condition();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<BooleanConditionalExpressionExitMultiplexor> get_AllConditionExitMultiplexors();
    [CompilerGeneratedAttribute]
internal void set_AllConditionExitMultiplexors(IReadOnlyList`1<BooleanConditionalExpressionExitMultiplexor> value);
}
internal enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.BooleanExpression : Enum {
    public int value__;
    public static BooleanExpression NotBoolean;
    public static BooleanExpression IsBoolean;
    public static BooleanExpression IsNullableBoolean;
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ClosureVariablesCollector : ControlFlowVariablesCollectorBase {
    [NotNullAttribute]
private OneToSetMap`2<IClrDeclaredElement, IField> myFieldReadsByStructVariable;
    [NotNullAttribute]
private OneToSetMap`2<IClrDeclaredElement, IField> myFieldWritesByStructVariable;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ILocalFunction> myVisitedLocalFunctions;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ILocalFunction> myLocalFunctionAnalysisStack;
    [NotNullAttribute]
private IResolveContext myResolveContext;
    private bool myPrimaryParametersAreStrict;
    [CompilerGeneratedAttribute]
private HashSet`1<IClrDeclaredElement> <ClosureCandidates>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<IClrDeclaredElement> ClosureCandidates { get; }
    public ClosureVariablesCollector(ICSharpClosure ownerDeclaration, IResolveContext resolveContext, bool primaryParametersAreStrict);
    public virtual bool InteriorShouldBeProcessed(ITreeNode element);
    [CompilerGeneratedAttribute]
public HashSet`1<IClrDeclaredElement> get_ClosureCandidates();
    [NotNullAttribute]
[ItemNotNullAttribute]
public ISet`1<IField> GetReadFields(IClrDeclaredElement declaredElement);
    [NotNullAttribute]
[ItemNotNullAttribute]
public ISet`1<IField> GetWrittenFields(IClrDeclaredElement declaredElement);
    public virtual void VisitReferenceExpression(IReferenceExpression referenceExpression);
    public virtual void VisitQueryExpression(IQueryExpression queryExpression);
    [PureAttribute]
private static bool ShouldTrackAccessToFieldsOf(IClrDeclaredElement qualifierElement, IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ConditionalAccessNullExitMultiplexor : CSharpControlFlowMultiplexor {
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ConditionalInvocationMultiplexor : CSharpControlFlowMultiplexor {
    public ConditionalInvocationMultiplexor(IInvocationExpression expression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ConstantConditionEqualsExpressionExitMultiplexor : CSharpControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private bool <IsTrueExit>k__BackingField;
    public bool IsTrueExit { get; }
    public ConstantConditionEqualsExpressionExitMultiplexor(IEqualityExpression equalityExpression, bool condition);
    [CompilerGeneratedAttribute]
public bool get_IsTrueExit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ConstantConditionIsExpressionExitMultiplexor : CSharpControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private bool <IsExpressionResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowEdgeCondition <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private IsExpressionPatternMatchingExitMultiplexor <ResultMultiplexor>k__BackingField;
    public bool IsExpressionResult { get; }
    public ControlFlowEdgeCondition Condition { get; }
    [NotNullAttribute]
public IIsExpression IsExpression { get; }
    [CanBeNullAttribute]
public IsExpressionPatternMatchingExitMultiplexor ResultMultiplexor { get; }
    public ConstantConditionIsExpressionExitMultiplexor(ControlFlowEdgeCondition condition, IsExpressionPatternMatchingExitMultiplexor resultMultiplexor);
    public ConstantConditionIsExpressionExitMultiplexor(ControlFlowEdgeCondition condition, bool isExpressionResult, IIsExpression isExpression);
    [CompilerGeneratedAttribute]
public bool get_IsExpressionResult();
    [CompilerGeneratedAttribute]
public ControlFlowEdgeCondition get_Condition();
    public IIsExpression get_IsExpression();
    [CompilerGeneratedAttribute]
public IsExpressionPatternMatchingExitMultiplexor get_ResultMultiplexor();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ContractAnnotationApplicator : object {
    [NotNullAttribute]
private IParametersOwner myParametersOwner;
    [NotNullAttribute]
private VariableIndex myVariableIndex;
    [NotNullAttribute]
private Dictionary`2<string, VariableInfo> myVariablesByParameterName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private ValueTuple`2[] myArgumentPoints;
    [NotNullAttribute]
private ISubstitution mySubstitution;
    [NotNullAttribute]
private IReadOnlyList`1<FunctionDefinitionTableRow> myTableDefinitionRows;
    private bool myIsWellFormed;
    [NotNullAttribute]
private ITreeNode myOwnerTreeNode;
    private bool myApplyToExpressionMemoryState;
    public ContractAnnotationApplicator(FunctionDefinitionTable functionDefinitionTable, ControlFlowElement owner, IResolveContext resolveContext, ICSharpArgumentsOwner argumentsOwner, IReference invocationReference, VariableIndex variableIndex);
    public ContractAnnotationApplicator(FunctionDefinitionTable functionDefinitionTable, IResolveContext resolveContext, ICSharpExpression targetExpression, IOperator operator, VariableIndex variableIndex);
    [NotNullAttribute]
public MemorySnapshotHive Apply(CSharpControlFlowContext context, MemorySnapshotHive hive);
    private RowApplicability TryApplyRow(LocalList`1& result, MemorySnapshot snapshot, FunctionDefinitionTableRow row, bool isSingleRow, bool forcePessimistic, CSharpControlFlowContext context);
    private void ApplyRowResults(LocalList`1& result, MemorySnapshot snapshot, FunctionDefinitionTableRow tableRow, CSharpControlFlowVariableValue nullValue);
    private void SetExpressionResultToMethodReturn(LocalList`1& result, MemorySnapshot snapshot, Nullable`1<ContractAnnotationValue> methodReturnValue, CSharpControlFlowVariableValue nullValue);
    private void SetExpressionResultToInvertedMethodReturn(LocalList`1& result, MemorySnapshot snapshot, Nullable`1<ContractAnnotationValue> methodReturnValue, CSharpControlFlowVariableValue nullValue);
    [CanBeNullAttribute]
private ControlFlowHistoryCheckPointInfo FindHistoryCheckPoint(ITreeNode expression, ControlFlowElement owner);
    [PureAttribute]
private Nullable`1<CSharpControlFlowVariableValue> FindArgumentValue(MemorySnapshot snapshot, string parameterName, IList`1<IParameter> parameters, Int32& memorySnapshotIndex);
    [PureAttribute]
private Nullable`1<CSharpControlFlowVariableValue> GetVariableStateByParameterDefaultValue(DefaultValue defaultValue);
    private static RowApplicability IsApplicable(ContractAnnotationValue contractValue, CSharpControlFlowVariableValue variableState);
    [CompilerGeneratedAttribute]
private bool <TryApplyRow>b__13_0(ITreeNode assignmentTreeNode);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowClosureVariableInfo : VariableInfo {
    [CanBeNullAttribute]
private List`1<VariableInfo> myStructFields;
    private bool myIsReadOnly;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourUnknown;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourWeakUnknown;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourCanBeNull;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourNotNull;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourWeakCanBeNull;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpControlFlowVariableValue[] <DefaultNreValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeAssignedFromStructFields>k__BackingField;
    public IType Type { get; }
    public CSharpControlFlowVariableValue[] DefaultNreValue { get; }
    public bool IsWeak { get; }
    public ControlFlowVariableType VariableType { get; }
    public IList`1<VariableInfo> NestedVariableInfos { get; }
    public bool CanBeAssignedFromStructFields { get; }
    public ControlFlowClosureVariableInfo(IClrDeclaredElement element, IType variableType, bool isReadOnly, CSharpControlFlowAnnotationCache annotationCache, bool canBeAssignedFromStructFields, ControlFlowVariableAccessState initialAccessState);
    private static ControlFlowClosureVariableInfo();
    [CompilerGeneratedAttribute]
public virtual IType get_Type();
    [CompilerGeneratedAttribute]
public virtual CSharpControlFlowVariableValue[] get_DefaultNreValue();
    public virtual bool get_IsWeak();
    public virtual ControlFlowVariableType get_VariableType();
    public void AddStructField(ControlFlowClosureVariableInfo info);
    public virtual IList`1<VariableInfo> get_NestedVariableInfos();
    [CompilerGeneratedAttribute]
public virtual bool get_CanBeAssignedFromStructFields();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowElementExtensions : object {
    [ExtensionAttribute]
public static void SetExitsTargetOrPropagate(ControlFlowElement controlFlowElement, IControlFlowElement from, ICSharpControlFlowElement target);
    [ExtensionAttribute]
public static void SetExitTargetOrPropagate(ControlFlowElement controlFlowElement, IControlFlowEdge exit, ICSharpControlFlowElement target);
    [ExtensionAttribute]
public static void SetConditionExitsTargetOrPropagate(ControlFlowElement controlFlowElement, CSharpControlFlowCondition condition, ICSharpControlFlowElement trueBranch, ICSharpControlFlowElement falseBranch);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowHistoryCheckPointInfo : VariableInfo {
    [NotNullAttribute]
private IControlFlowElement myPoint;
    [NotNullAttribute]
private IControlFlowElement myValidityDomain;
    [NotNullAttribute]
private IExpressionType myExpressionType;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [NotNullAttribute]
public IControlFlowElement Point { get; }
    [NotNullAttribute]
public IControlFlowElement ValidityDomain { get; }
    public IType Type { get; }
    public CSharpControlFlowVariableValue[] DefaultNreValue { get; }
    public ControlFlowVariableType VariableType { get; }
    public VariableInfo Parent { get; protected set; }
    public IList`1<VariableInfo> NestedVariableInfos { get; }
    public bool CanBeAssignedFromStructFields { get; }
    public bool IsOfNullableType { get; }
    public bool IsOfValueType { get; }
    public IExpressionType ExpressionType { get; }
    public bool IsWeak { get; }
    public ControlFlowHistoryCheckPointInfo(IControlFlowElement point, IControlFlowElement validityDomain, IExpressionType expressionType);
    public IControlFlowElement get_Point();
    public IControlFlowElement get_ValidityDomain();
    [CompilerGeneratedAttribute]
public virtual IType get_Type();
    public virtual CSharpControlFlowVariableValue[] get_DefaultNreValue();
    public virtual ControlFlowVariableType get_VariableType();
    public virtual VariableInfo get_Parent();
    protected virtual void set_Parent(VariableInfo value);
    public virtual IList`1<VariableInfo> get_NestedVariableInfos();
    public virtual bool get_CanBeAssignedFromStructFields();
    public virtual bool get_IsOfNullableType();
    public virtual bool get_IsOfValueType();
    [PureAttribute]
private TypeFlags CalculateTypeFlags();
    public IExpressionType get_ExpressionType();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool IsInDomain(IControlFlowElement element);
    public virtual bool get_IsWeak();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowIsExpressionUtils : object {
    [ExtensionAttribute]
public static Nullable`1<bool> IsExpressionPatternMatchingResult(IControlFlowElement element);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowStrictVariableInfo : VariableInfo {
    [CanBeNullAttribute]
private List`1<VariableInfo> myNestedVariableInfos;
    private ControlFlowVariableType myVariableType;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourUnknownInitialValue;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourNotNullInitialValue;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourCanBeNullInitialValue;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourWeakUnknownInitialValue;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourWeakNotNullInitialValue;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ourWeakCanBeNullInitialValue;
    private static int UnknownInitialValueIndex;
    private static int NotNullInitialValueIndex;
    private static int CanBeNullInitialValueIndex;
    private static int WeakUnknownInitialValueIndex;
    private static int WeakNotNullInitialValueIndex;
    private static int WeakCanBeNullInitialValueIndex;
    private static int NoCollection;
    private static int CollectionWithUnknownElements;
    private static int CollectionWithPossibleNullElements;
    private static int CollectionWithNotNullElement;
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[][][] ourInitialValues;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    private CSharpControlFlowVariableValue[] myDefaultNreValue;
    [CompilerGeneratedAttribute]
private bool <ShouldBeAssignedUponExit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeAssignedFromStructFields>k__BackingField;
    public IType Type { get; }
    public CSharpControlFlowVariableValue[] DefaultNreValue { get; }
    public ControlFlowVariableType VariableType { get; }
    public bool ShouldBeAssignedUponExit { get; }
    public bool CanBeAssignedFromStructFields { get; }
    public IList`1<VariableInfo> NestedVariableInfos { get; }
    public bool IsWeak { get; }
    private static ControlFlowStrictVariableInfo();
    public ControlFlowStrictVariableInfo(IClrDeclaredElement declaredElement, IType variableType, ControlFlowVariableAccessState initialState, CSharpControlFlowAnnotationCache annotationCache, ValueAnalysisMode valueAnalysisMode, bool shouldBeAssignedUponExit, bool canBeAssignedFromStructFields);
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] GetInitialNreState(bool isContainer, bool isStrictlyControlled, CSharpControlFlowNullReferenceState variableNreState, CSharpControlFlowNullReferenceState containerElementNreState);
    [CompilerGeneratedAttribute]
public virtual IType get_Type();
    [PureAttribute]
private static bool IsByRefVariable(IDeclaredElement declaredElement);
    [NotNullAttribute]
private static CSharpControlFlowVariableValue[] ComputeInitialNreValue(VariableInfo variableInfo, CSharpControlFlowAnnotationCache annotationCache, ValueAnalysisMode valueAnalysisMode);
    public virtual CSharpControlFlowVariableValue[] get_DefaultNreValue();
    public virtual ControlFlowVariableType get_VariableType();
    private void MergeVariableType(ControlFlowVariableType parentType, CSharpControlFlowAnnotationCache annotationsCache, ValueAnalysisMode valueAnalysisMode);
    [CompilerGeneratedAttribute]
public virtual bool get_ShouldBeAssignedUponExit();
    [CompilerGeneratedAttribute]
public virtual bool get_CanBeAssignedFromStructFields();
    public virtual IList`1<VariableInfo> get_NestedVariableInfos();
    public void AddNestedVariableInfo(ControlFlowStrictVariableInfo info, CSharpControlFlowAnnotationCache annotationsCache, ValueAnalysisMode valueAnalysisMode);
    public virtual bool get_IsWeak();
    [CompilerGeneratedAttribute]
internal static CSharpControlFlowNullReferenceState <ComputeInitialNreValue>g__GetNullableAttributeState|26_0(<>c__DisplayClass26_0& );
    [CompilerGeneratedAttribute]
internal static bool <ComputeInitialNreValue>g__IsGenericTaskOrLazy|26_1(<>c__DisplayClass26_0& );
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowVariablesCollectorBase : TreeNodeVisitor {
    [NotNullAttribute]
private Stack`1<ILocalScope> myScopes;
    public bool ProcessingIsFinished { get; }
    public virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public virtual void ProcessBeforeInterior(ITreeNode element);
    protected virtual void AcceptNode(ICSharpTreeNode node);
    public virtual void ProcessAfterInterior(ITreeNode element);
    public virtual void VisitQueryExpression(IQueryExpression queryExpression);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowVariableType : Enum {
    public int value__;
    public static ControlFlowVariableType NONE;
    public static ControlFlowVariableType STRICTLY_CONTROLLED;
    public static ControlFlowVariableType STABLE_VALUE;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ControlFlowWeakVariableInfo : VariableInfo {
    [NotNullAttribute]
private CSharpControlFlowVariableValue[] myDefaultNreState;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpControlFlowVariableValue[] <InitialNreValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IConditionalAccessExpression <AccessExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    public IType Type { get; }
    public CSharpControlFlowVariableValue[] DefaultNreValue { get; }
    public CSharpControlFlowVariableValue[] InitialNreValue { get; }
    public ControlFlowVariableType VariableType { get; }
    public VariableInfo Parent { get; protected set; }
    public IList`1<VariableInfo> NestedVariableInfos { get; }
    public bool CanBeAssignedFromStructFields { get; }
    [CanBeNullAttribute]
public IConditionalAccessExpression AccessExpression { get; }
    public bool IsStatic { get; }
    public bool IsWeak { get; }
    public ControlFlowWeakVariableInfo(TypeMemberInstance typeMember, IConditionalAccessExpression accessExpression, ITreeNode contextTreeNode, CSharpControlFlowVariableValue initialNreValue, CSharpControlFlowVariableValue defaultNreValue, bool isStatic);
    public ControlFlowWeakVariableInfo(IParameter primaryParameter, IConditionalAccessExpression accessExpression, CSharpControlFlowVariableValue initialNreValue, CSharpControlFlowVariableValue defaultNreValue);
    [CompilerGeneratedAttribute]
public virtual IType get_Type();
    public virtual CSharpControlFlowVariableValue[] get_DefaultNreValue();
    [CompilerGeneratedAttribute]
public virtual CSharpControlFlowVariableValue[] get_InitialNreValue();
    public virtual ControlFlowVariableType get_VariableType();
    public virtual VariableInfo get_Parent();
    protected virtual void set_Parent(VariableInfo value);
    public virtual IList`1<VariableInfo> get_NestedVariableInfos();
    public virtual bool get_CanBeAssignedFromStructFields();
    [CompilerGeneratedAttribute]
public IConditionalAccessExpression get_AccessExpression();
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual bool get_IsWeak();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpClosureExecutionBehaviorInspector : ClosureExecutionBehaviorInspectorBase {
    [CompilerGeneratedAttribute]
private CSharpControlFlowAnnotationCache <annotationsCache>P;
    public CSharpClosureExecutionBehaviorInspector(CSharpControlFlowAnnotationCache annotationsCache);
    protected virtual ExecutionBehavior AnalyzeLambdaExecutionContext(ITreeNode closureNode, ITreeNode& contextNode, IMethod& contextMethod);
    protected virtual ExecutionBehavior NextTunnelClauseContext(ITreeNode contextNode, ITreeNode& nextContextNode, IMethod& nextContextMethod);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowAnnotationCache : object {
    private bool myIgnoreNonNullableNRTAnnotationsInValueAnalysis;
    private TerminatesMethodAnnotationProvider myTerminatesMethodAnnotationProvider;
    private AssertionMethodAnnotationProvider myAssertionMethodAnnotationProvider;
    private AssertionConditionAnnotationProvider myAssertionConditionAnnotationProvider;
    private InstantHandleAnnotationProvider myInstantHandleAnnotationProvider;
    private NoEnumerationAnnotationProvider myNoEnumerationAnnotationProvider;
    private LinqTunnelAnnotationProvider myLinqTunnelAnnotationProvider;
    private ContractAnnotationProvider myContractAnnotationProvider;
    private NullnessProvider myNullnessProvider;
    private ContainerElementNullnessProvider myContainerElementNullnessProvider;
    private PureAnnotationProvider myPureAnnotationProvider;
    private ImplicitUseAnnotationProvider myImplicitUseAnnotationProvider;
    public CSharpControlFlowAnnotationCache(CodeAnnotationsCache annotationsCache, bool ignoreNonNullableNRTAnnotationsInValueAnalysis);
    [PureAttribute]
public virtual CSharpControlFlowNullReferenceState GetNullableAttributeState(IAttributesOwner element);
    [PureAttribute]
private static CSharpControlFlowNullReferenceState ConvertAnnotationToNullReferenceState(Nullable`1<CodeAnnotationNullableValue> value);
    public virtual CSharpControlFlowNullReferenceState GetNullableAttributeState(IAttributesOwner element, IType valueType);
    [PureAttribute]
public virtual CSharpControlFlowNullReferenceState GetContainerElementNullableAttributeState(IAttributesOwner element);
    [PureAttribute]
public virtual CSharpControlFlowNullReferenceState GetContainerElementNullableAttributeState(IAttributesOwner element, IType valueType);
    public virtual bool IsTerminatingMethod(IAttributesOwner method);
    public virtual bool IsAssertionMethod(IAttributesOwner method);
    public virtual Nullable`1<AssertionConditionType> GetParameterAssertionCondition(IParameter parameter);
    public virtual bool GetInstantHandle(IParameter parameter);
    public virtual bool GetNoEnumeration(IParameter parameter);
    public virtual bool GetLinqTunnel(IMethod method);
    public virtual FunctionDefinitionTable GetContractAnnotation(IAttributesOwner method);
    public virtual bool IsPureMethod(IMethod method);
    public Nullable`1<ImplicitUseKindFlags> GetImplicitUseFlags(ITypeMember typeMember);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowBlockStatement : CSharpControlFlowStatement {
    [NotNullAttribute]
private List`1<CSharpControlFlowStatement> myStatements;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowBlockStatement(IBlock block, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowBody : ControlFlowElement {
    [NotNullAttribute]
private ICSharpTreeNode myBody;
    [CanBeNullAttribute]
private ICSharpControlFlowElement myBodyGraph;
    [CanBeNullAttribute]
private List`1<IControlFlowElement> myElements;
    [CanBeNullAttribute]
private CSharpControlFlowMultiplexor myImplicitReturn;
    [CanBeNullAttribute]
public ICSharpControlFlowElement ImplicitReturn { get; }
    [NotNullAttribute]
public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowBody(IBlock blockBody, CSharpControlFlowBuilderParams parameters);
    public CSharpControlFlowBody(ITopLevelCode topLevelCode, CSharpControlFlowBuilderParams parameters);
    public CSharpControlFlowBody(ICSharpExpression expressionBody, CSharpControlFlowBuilderParams parameters);
    public CSharpControlFlowBody(IAttribute attribute, CSharpControlFlowBuilderParams parameters);
    public CSharpControlFlowBody(IClassLikeDeclaration typeDeclaration, CSharpControlFlowBuilderParams parameters);
    private void ProcessConstructorInitializer(IConstructorDeclaration constructor, CSharpControlFlowBuilderParams parameters);
    [CanBeNullAttribute]
private ICSharpControlFlowElement ProcessMemberInitializers(IClassLikeDeclaration typeDeclaration, ICSharpControlFlowElement lastElement, CSharpControlFlowBuilderParams parameters, bool isStatic);
    public ICSharpControlFlowElement get_ImplicitReturn();
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    private void ProcessBodyExits(ICSharpControlFlowElement bodyGraph);
    [NotNullAttribute]
private CSharpControlFlowMultiplexor GetOrCreateImplicitReturn();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowBuilderParams : object {
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildExpressions>k__BackingField;
    private Nullable`1<bool> mySupportImprovedDefiniteAssignment;
    [NotNullAttribute]
public IResolveContext ResolveContext { get; }
    public bool BuildExpressions { get; }
    public CSharpControlFlowBuilderParams(IResolveContext resolveContext, bool buildExpressions);
    [CompilerGeneratedAttribute]
public IResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public bool get_BuildExpressions();
    public bool SupportImprovedDefiniteAssignment(ICSharpTreeNode context);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowCheckedStatement : CSharpControlFlowSimpleBlockedStatement {
    public CSharpControlFlowCheckedStatement(ICheckedStatement statement, CSharpControlFlowBuilderParams params);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowCondition : ControlFlowElement {
    [CanBeNullAttribute]
private CSharpControlFlowExpression myExpression;
    [NotNullAttribute]
private List`1<IControlFlowElement> myChildren;
    [NotNullAttribute]
private Dictionary`2<ControlFlowEdgeCondition, CSharpControlFlowMultiplexor> myConditionMultiplexors;
    public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowCondition(ICSharpExpression expression, CSharpControlFlowBuilderParams parameters);
    private CSharpControlFlowMultiplexor CreateConditionMultiplexor(ITreeNode expression, ControlFlowEdgeCondition condition);
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    [NotNullAttribute]
public IList`1<ICSharpControlFlowEdge> GetBooleanExits(ControlFlowEdgeCondition condition);
    [CanBeNullAttribute]
public ICSharpControlFlowEdge GetBooleanExit(ControlFlowEdgeCondition condition);
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowConstructorInitializer : ControlFlowElement {
    [NotNullAttribute]
private ICSharpArgumentsOwner myConstructorInitializer;
    [NotNullAttribute]
private List`1<IControlFlowElement> myChildren;
    [NotNullAttribute]
public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowConstructorInitializer(ICSharpArgumentsOwner constructorInitializer, CSharpControlFlowBuilderParams parameters);
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public sealed virtual bool get_ExecutesCode();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext : object {
    [NotNullAttribute]
private VariableIndex myVariableIndex;
    [NotNullAttribute]
private TypeCompatibilityCache myTypeCompatibilityCache;
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private CSharpControlFlowContextFactory myContextFactory;
    private ControlFlowVariableStateCollection myStates;
    [CanBeNullAttribute]
private MemorySnapshotHive myMemorySnapshotHive;
    [CompilerGeneratedAttribute]
private bool <RecursiveAtAllPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpControlFlowContext <ParentContext>k__BackingField;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> MakeUncheckedStateMutator;
    [CompilerGeneratedAttribute]
private bool <UnreachableByConditional>k__BackingField;
    private static int ExpressionIndex;
    private static Func`2<MemorySnapshot, MemorySnapshot> SplitByExpressionBooleanStateMutator;
    [NotNullAttribute]
private static Func`4<MemorySnapshot, int, CSharpControlFlowVariableValue, MemorySnapshotPair> MakeVariableNullAndNotNullStateMutator;
    [NotNullAttribute]
private static Func`4<MemorySnapshot, int, CSharpControlFlowVariableValue, MemorySnapshot> SetVariableStateMutator;
    [NotNullAttribute]
private static Func`4<MemorySnapshot, int, Func`2<CSharpControlFlowVariableValue, CSharpControlFlowVariableValue>, MemorySnapshot> TransformVariableStateMutator;
    [NotNullAttribute]
private static Func`3<MemorySnapshot, CSharpControlFlowVariableValue, MemorySnapshot> SetExpressionStateMutator;
    [NotNullAttribute]
private static Func`3<MemorySnapshot, CSharpControlFlowVariableValue, MemorySnapshotPair> MakeExpressionNullAndNotNullStateMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetExpressionMemoryStateToDelegatePlusResultMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetExpressionMemoryStateToDelegateMinusResultMutator;
    private static Func`2<MemorySnapshot, MemorySnapshot> SetExpressionMemoryStateToBooleanLogicalNotOperatorResultMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetExpressionMemoryStateToBooleanXORResultMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetExpressionMemoryStateToBooleanANDResultMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetExpressionMemoryStateToBooleanORResultMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshotPair> UnwrapContainerItemExpressionMemoryStateMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshotPair> UnwrapContainerItemExpressionMemoryStateMutatorFromVariable;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetExpressionMemoryStateToLiftedOperatorResultMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetExpressionMemoryStateToLiftedRelationalOperatorResultMutator;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyStrictVariableNullReferenceStateToExpressionStateWithBoxingMutator1;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyStrictVariableNullReferenceStateToExpressionStateWithBoxingMutator2;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyVariableNullReferenceStateToExpressionStateMutator1;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyVariableNullReferenceStateToExpressionStateMutator2;
    private static Func`4<MemorySnapshot, int, CSharpControlFlowVariableValue, MemorySnapshot> ResetVariableNreMutator1;
    private static Func`4<MemorySnapshot, int, CSharpControlFlowVariableValue[], MemorySnapshotPair> ResetVariableNreMutator2;
    private static Func`4<MemorySnapshot, int, CSharpControlFlowVariableValue[], MemorySnapshotPair> ResetVariableNreMutator3;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshotPair> CopyVariableMemoryStateToVariableState1;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyVariableMemoryStateToVariableState2;
    private static Func`4<MemorySnapshot, int, bool, MemorySnapshotPair> CopyExpressionMemoryStateToStrictVariableState1;
    private static Func`4<MemorySnapshot, int, bool, MemorySnapshotPair> CopyExpressionMemoryStateToStrictVariableState2;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyExpressionMemoryStateToVariableState1;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyExpressionMemoryStateToVariableState2;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyExpressionMemoryStateToVariableState3;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> CopyExpressionMemoryStateToVariableState4;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetVariableMemoryStateToDefinitelyBeNotNullMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetVariableMemoryStateToDefinitelyBeNullMutator;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> AddVariableTypeSpecificationMutator;
    private static Func`4<MemorySnapshot, int, int, MemorySnapshot> AddNotTypeSpecificationMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> SetExpressionTypeMutator;
    private static Func`2<MemorySnapshot, MemorySnapshot> ClearExpressionTypeMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> ClearVariableTypeMutator;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> PatchCollectionVariableAfterAssignmentExpressionToElement1;
    private static Func`4<MemorySnapshot, int, CSharpControlFlowVariableValue, MemorySnapshot> PatchCollectionVariableAfterAssignmentExpressionToElement2;
    private static Func`3<MemorySnapshot, int, MemorySnapshot> PatchCollectionVariableAfterAssignmentUnknownToElement1;
    public bool RecursiveAtAllPaths { get; public set; }
    public CSharpControlFlowContext ParentContext { get; }
    [NotNullAttribute]
public VariableIndex VariableIndex { get; }
    public ControlFlowVariableAccessState Item { get; public set; }
    public ExecutionBehavior ExecutionBehavior { get; }
    public bool IsMemorySnapshotComplexityOverflow { get; public set; }
    public bool UnreachableByConditional { get; private set; }
    public int MemorySnapshotHiveCount { get; }
    public CSharpControlFlowContext(CSharpControlFlowContextFactory contextFactory, VariableIndex variableIndex, TypeCompatibilityCache typeCompatibilityCache, ValueAnalysisMode valueAnalysis, IResolveContext resolveContext);
    public CSharpControlFlowContext(CSharpControlFlowContext context);
    public CSharpControlFlowContext(CSharpControlFlowContext context, CSharpControlFlowContext parent);
    public CSharpControlFlowContext(IList`1<CSharpControlFlowContext> contexts);
    private static CSharpControlFlowContext();
    [CompilerGeneratedAttribute]
public bool get_RecursiveAtAllPaths();
    [CompilerGeneratedAttribute]
public void set_RecursiveAtAllPaths(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual CSharpControlFlowContext get_ParentContext();
    public VariableIndex get_VariableIndex();
    public sealed virtual ControlFlowVariableAccessState get_Item(VariableInfo info);
    public sealed virtual void set_Item(VariableInfo info, ControlFlowVariableAccessState value);
    public sealed virtual void SetAccessStates(IEnumerable`1<VariableInfo> infos, Func`2<ControlFlowVariableAccessState, ControlFlowVariableAccessState> mutator);
    public sealed virtual ExecutionBehavior get_ExecutionBehavior();
    [PureAttribute]
private static CSharpControlFlowVariableValue MakeUncheckedState(CSharpControlFlowVariableValue value, bool optimistic);
    public sealed virtual void AddToRecentAssignmentsList(VariableInfo info, ITreeNode element);
    public sealed virtual void AddToRecentUsagesList(VariableInfo info, ITreeNode element);
    public sealed virtual void ClearRecentAssignmentsList(VariableInfo info);
    public sealed virtual IEnumerable`1<ITreeNode> GetRecentAssignmentsList(VariableInfo info);
    public sealed virtual IEnumerable`1<ITreeNode> GetUsagesOfRecentAssignments(VariableInfo info, ITreeNode assignment);
    public sealed virtual IEnumerable`1<ITreeNode> GetRecentAccessInClosure(VariableInfo info);
    public sealed virtual void AddRecentAccessInClosure(VariableInfo info, ITreeNode element);
    public sealed virtual void ClearRecentAccessInClosure(VariableInfo info);
    public bool get_IsMemorySnapshotComplexityOverflow();
    public void set_IsMemorySnapshotComplexityOverflow(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnreachableByConditional();
    [CompilerGeneratedAttribute]
private void set_UnreachableByConditional(bool value);
    public void SetUnreachableByAssertion();
    public int get_MemorySnapshotHiveCount();
    [PureAttribute]
private bool IsStrictlyControlled(VariableInfo info);
    [PureAttribute]
private bool IsWeakAndNotNull(VariableInfo info);
    public void ClearAllMemoryStates();
    public void TransplantMemoryStates(CSharpControlFlowContext otherContext);
    public void SplitByVariableNullableState(VariableInfo info, bool optimistic, CSharpControlFlowContext& isNullContext, CSharpControlFlowContext& isNotNullContext);
    public void SplitByExpressionNullableState(CSharpControlFlowContext& isNullContext, CSharpControlFlowContext& isNotNullContext, bool optimistic);
    public void SplitByVariableBooleanState(VariableInfo info, CSharpControlFlowContext& trueContext, CSharpControlFlowContext& falseContext);
    public void SplitByExpressionBooleanState(CSharpControlFlowContext& trueContext, CSharpControlFlowContext& falseContext);
    public void SplitByVariableToVariableEqualityState(VariableInfo info1, VariableInfo info2, IReference equalityCheckElementReference, CSharpControlFlowContext& equalsContext, CSharpControlFlowContext& notEqualsContext);
    public void SplitByVariableToConstantEqualityState(VariableInfo info, ConstantValue constantValue, CSharpControlFlowContext& equalsContext, CSharpControlFlowContext& notEqualsContext);
    [PureAttribute]
private bool IsBooleanVariable(VariableInfo info);
    public void SplitByVariableToExpressionEqualityState(VariableInfo info, IReference equalityCheckElementReference, CSharpControlFlowContext& equalsContext, CSharpControlFlowContext& notEqualsContext);
    [CanBeNullAttribute]
private MemorySnapshot FilterSnapshotByTypeCompatibility(int index1, int index2, MemorySnapshot snapshot);
    public void SetVariableStateToBothNullAndNonNull(VariableInfo info, CSharpControlFlowVariableValue extraNotNullFlags);
    public void SetVariableMemoryState(VariableInfo info, CSharpControlFlowVariableValue value);
    public void TransformVariableMemoryState(VariableInfo info, Func`2<CSharpControlFlowVariableValue, CSharpControlFlowVariableValue> transform);
    [PureAttribute]
public bool CanVariableBeInState(VariableInfo info, CSharpControlFlowVariableValue value);
    [PureAttribute]
public bool IsVariableDefinitelyInState(VariableInfo info, CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public Nullable`1<CSharpControlFlowVariableValue> GetVariableDefiniteState(VariableInfo info);
    [PureAttribute]
public bool CanExpressionBeInState(CSharpControlFlowVariableValue value);
    [PureAttribute]
public bool IsExpressionDefinitelyInState(CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public bool IsExpressionDefinitelyInStateWithoutContainerFlags(CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public bool IsVariableDefinitelyInStateWithoutContainerFlags(VariableInfo info, CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public Nullable`1<CSharpControlFlowVariableValue> GetExpressionDefiniteState(CSharpControlFlowVariableValue ignoreMask);
    public void SetExpressionMemoryState(CSharpControlFlowVariableValue value);
    public void SetExpressionStateToBothNullAndNonNull(CSharpControlFlowVariableValue extraNotNullFlags);
    public void SetExpressionMemoryStateToDelegateOperatorResult(VariableInfo leftInfo, string opName);
    public void SetExpressionMemoryStateToBooleanLogicalNotOperatorResult();
    public void SetExpressionMemoryStateToSuppressNullableWarningExpressionResult();
    public void SetExpressionMemoryStateToBooleanOperatorResult(VariableInfo historyCheckPoint, string opName);
    public bool UnwrapContainerItemExpressionMemoryState();
    public bool UnwrapContainerItemExpressionMemoryStateFromVariableState(VariableInfo variableInfo);
    public void SetExpressionMemoryStateToLiftedOperatorResult(VariableInfo historyCheckPoint);
    public void SetExpressionMemoryStateToLiftedRelationalOperatorResult(VariableInfo historyCheckPoint);
    public void CopyVariableNullReferenceStateToExpressionState(VariableInfo info, bool copyType);
    public void ResetVariableNreState(VariableInfo info, bool clearTypeSpecification);
    private void SetInitialVariableNreState(VariableInfo info, bool clearTypeSpecification);
    public void ResetWeakVariablesTypeSpecifications();
    public void CopyVariableMemoryStateToVariableState(VariableInfo from, VariableInfo to);
    public void CopyExpressionMemoryStateToHistoryCheckPointState(VariableInfo historyCheckPoint);
    public void CopyExpressionMemoryStateToVariableState(VariableInfo info);
    public void SetVariableMemoryStateToDefinitelyBeNotNull(VariableInfo info);
    public void SetVariableMemoryStateToDefinitelyBeNull(VariableInfo info);
    public void MergeMemorySnapshotFrom(bool includeThis, CSharpControlFlowContextFactory contextFactory, IEnumerable`1<CSharpControlFlowContext> contexts);
    public void AddTypeSpecification(VariableInfo info, IType type);
    public void SetVariableAndExpressionType(VariableInfo info, IType type);
    public void AddNotTypeSpecification(VariableInfo info, IType type);
    [NotNullAttribute]
public IEnumerable`1<IType> GetTypeSpecification(VariableInfo info);
    [NotNullAttribute]
public IEnumerable`1<IType> GetNotTypeSpecification(VariableInfo info);
    [NotNullAttribute]
public IEnumerable`1<IType> GetExpressionTypeSpecification();
    [NotNullAttribute]
public IEnumerable`1<IType> GetExpressionNotTypeSpecification();
    [NotNullAttribute]
private IEnumerable`1<IType> GetTypeSpecification(int variableIndex);
    [NotNullAttribute]
private IEnumerable`1<IType> GetNotTypeSpecification(int variableIndex);
    public void SetExpressionType(IType type);
    public void ClearExpressionType();
    public void ClearVariableType(VariableInfo info);
    public bool CanVariableBeOfGivenType(VariableInfo info, IType type, ICSharpTypeConversionRule conversionRule, bool alwaysOfType);
    private bool CanBeOfGivenTypeInSnapshot(MemorySnapshot snapshot, VariableInfo info, IType type, int typeIndex, ICSharpTypeConversionRule conversionRule);
    private bool AlwaysOfGivenTypeInSnapshot(MemorySnapshot snapshot, VariableInfo info, IType type, int typeIndex, ICSharpTypeConversionRule conversionRule);
    public void SplitExpressionWithVariableCanBeOfGivenType(VariableInfo info, IType variableType, IType isType, ICSharpTypeConversionRule conversionRule, CSharpControlFlowContext& canBeOfType, CSharpControlFlowContext& cannotBeOfType);
    private static bool IsReadonlyField(IClrDeclaredElement declaredElement);
    internal void MergeDefinitelyAssignedStateOnly(CSharpControlFlowContext otherContext);
    internal void ApplyContractAnnotation(FunctionDefinitionTable functionDefinitionTable, ControlFlowElement owner, IResolveContext resolveContext, IInvocationExpression invocationExpression, Dictionary`2<ICSharpExpression, ContractAnnotationApplicator> contractAnnotationApplicatorCache);
    internal void ApplyContractAnnotation(FunctionDefinitionTable functionDefinitionTable, IResolveContext resolveContext, IOperator userDefinedOperator, ICSharpExpression targetExpression, Dictionary`2<ICSharpExpression, ContractAnnotationApplicator> contractAnnotationApplicatorCache);
    [NotNullAttribute]
public CSharpControlFlowContext Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual VariableInfo GetVariableInfoByVariableInfoInChildContext(VariableInfo infoInChildContext);
    public sealed virtual IEnumerable`1<VariableInfo> EnumerateVariables();
    private void MutateAndCheckContextForOverflow(TData data, Func`3<MemorySnapshot, TData, MemorySnapshotPair> mutator);
    private void MutateAndCheckContextForOverflow(TData1 data1, TData2 data2, Func`4<MemorySnapshot, TData1, TData2, MemorySnapshotPair> mutator);
    public void ResetVariablesNreStateAndClearTypeSpecifications(List`1<VariableInfo> variablesToClear, bool clearHistoryCheckPoints);
    public void PatchWeakVariablesNreStateOnQualifierAccess(List`1<VariableInfo> variablesToClear, bool resetNullableState);
    [NotNullAttribute]
private static MemorySnapshot ResetHistoryCheckPointNreStateAndClearTypeSpecificationsInSnapshot(MemorySnapshot snapshot, Int32[] variableIndices, Int32[] historyCheckpoints);
    public void ResetVariablesAndExpressionNreStateAndClearTypeSpecifications(List`1<VariableInfo> variablesToClear);
    public void ResetVariablesState(Int32[] indices);
    public void PatchCollectionVariableAfterAssignmentExpressionToElement(VariableInfo collectionVariableInfo);
    public void PatchCollectionVariableAfterAssignmentExpressionToElement(VariableInfo collectionVariableInfo, CSharpControlFlowVariableValue elementValue);
    public void PatchCollectionVariableAfterAssignmentUnknownValueToElement(VariableInfo collectionVariableInfo);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContext/<GetArrays>d__166")]
public IEnumerable`1<object> GetArrays();
    [PureAttribute]
public static ValueTuple`2<bool, bool> AnalyzeEqualityCheck(IReference reference);
    [CompilerGeneratedAttribute]
private MemorySnapshot <SplitByVariableToVariableEqualityState>b__55_0(MemorySnapshot snapshot, int index1, int index2);
    [CompilerGeneratedAttribute]
private MemorySnapshot <SplitByVariableToExpressionEqualityState>b__58_0(MemorySnapshot snapshot, int index1, int index2);
    [CompilerGeneratedAttribute]
private IType <GetTypeSpecification>b__132_0(int i);
    [CompilerGeneratedAttribute]
private IType <GetNotTypeSpecification>b__133_0(int i);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeEqualityCheck>g__IsReferenceEqualityCheck|167_0(<>c__DisplayClass167_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeEqualityCheck>g__IsTransitiveWithNullCheck|167_1(<>c__DisplayClass167_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContextEx : object {
    [ExtensionAttribute]
public static void SetExpressionMemoryState(CSharpControlFlowContext context, CSharpControlFlowVariableValue[] values);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowNullReferenceState ToExpressionReferenceState(CSharpControlFlowContext context);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowNullReferenceState ToVariableReferenceState(CSharpControlFlowContext context, VariableInfo variableInfo);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowNullReferenceState MergeWith(CSharpControlFlowNullReferenceState state, Nullable`1<CSharpControlFlowNullReferenceState> existingState);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowContextFactory : object {
    private int myMemorySnapshotHiveCountThreshold;
    [NotNullAttribute]
private ICSharpControlFlowGraph myGraph;
    [CanBeNullAttribute]
private CSharpControlFlowContext myInitialControlFlowContext;
    [CanBeNullAttribute]
private CSharpControlFlowAnnotationCache myAnnotationCache;
    [CompilerGeneratedAttribute]
private OneToSetMap`2<IStruct, IField> <AccessedStructFields>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueAnalysisMode <AnalysisMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNonNullableAnnotationsInValueAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionBehavior <ExecutionBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectClosures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrimaryParametersAreStrict>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IParameter> <ExternallyInitializedOutParameters>k__BackingField;
    [ThreadStaticAttribute]
private static bool ourPreventPartInspectorCycles;
    [NotNullAttribute]
public OneToSetMap`2<IStruct, IField> AccessedStructFields { get; }
    [NotNullAttribute]
public IResolveContext ResolveContext { get; }
    public ValueAnalysisMode AnalysisMode { get; }
    public bool IgnoreNonNullableAnnotationsInValueAnalysis { get; }
    public ExecutionBehavior ExecutionBehavior { get; }
    public bool CollectClosures { get; }
    public bool PrimaryParametersAreStrict { get; }
    [CanBeNullAttribute]
public IReadOnlyCollection`1<IParameter> ExternallyInitializedOutParameters { get; }
    [NotNullAttribute]
public VariableIndex VariableIndex { get; }
    [NotNullAttribute]
public CSharpControlFlowAnnotationCache AnnotationCache { get; }
    [NotNullAttribute]
public CSharpControlFlowContext InitialContext { get; public set; }
    public int MaxNumberOfStatesPerGraph { get; }
    public CSharpControlFlowContextFactory(ICSharpControlFlowGraph graph, IResolveContext resolveContext, ValueAnalysisMode analysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis, ExecutionBehavior executionBehavior, OneToSetMap`2<IStruct, IField> accessedStructFields, bool collectClosures, bool primaryParametersAreStrict, IReadOnlyCollection`1<IParameter> externallyInitializedOutParameters);
    [CompilerGeneratedAttribute]
public OneToSetMap`2<IStruct, IField> get_AccessedStructFields();
    [CompilerGeneratedAttribute]
public IResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public ValueAnalysisMode get_AnalysisMode();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNonNullableAnnotationsInValueAnalysis();
    [CompilerGeneratedAttribute]
public ExecutionBehavior get_ExecutionBehavior();
    [CompilerGeneratedAttribute]
public bool get_CollectClosures();
    [CompilerGeneratedAttribute]
public bool get_PrimaryParametersAreStrict();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IParameter> get_ExternallyInitializedOutParameters();
    [NotNullAttribute]
public static CSharpControlFlowContextFactory Build(ICSharpControlFlowGraph graph, ValueAnalysisMode analysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis, Func`2<ITreeNode, ICSharpControlFlowGraph> graphBuilder);
    [CanBeNullAttribute]
private static IReadOnlyCollection`1<IParameter> CollectExternallyInitializedPrimaryConstructorOutParameters(ICSharpControlFlowGraph graph, Func`2<ITreeNode, ICSharpControlFlowGraph> graphBuilder);
    private OneToSetMap`2<IStruct, IField> CollectAccessedStructFields();
    [NotNullAttribute]
internal IList`1<ITreeNode> CollectBodyParts();
    private static bool TryGetMemorySnapshotHiveCount(ICSharpControlFlowGraph graph, Int32& threshold);
    public VariableIndex get_VariableIndex();
    public virtual CSharpControlFlowAnnotationCache get_AnnotationCache();
    public virtual void CheckContextForOverflow(CSharpControlFlowContext context);
    public virtual CSharpControlFlowContext get_InitialContext();
    public virtual void set_InitialContext(CSharpControlFlowContext value);
    public virtual int get_MaxNumberOfStatesPerGraph();
    [NotNullAttribute]
public sealed virtual CSharpControlFlowContext CloneContext(CSharpControlFlowContext context);
    [NotNullAttribute]
public sealed virtual CSharpControlFlowContext Merge(IList`1<CSharpControlFlowContext> contexts);
    [CompilerGeneratedAttribute]
internal static void <CollectAccessedStructFields>g__AddTupleFieldsRecursively|32_1(DecoratedType`1<TupleTypeDecoration> tupleType, OneToSetMap`2<IStruct, IField> accessedStructFields);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowDagElement : ControlFlowElement {
    [CompilerGeneratedAttribute]
private DagTest <DagTest>k__BackingField;
    [NotNullAttribute]
public DagTest DagTest { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowDagElement(DagTest dagTest);
    [CompilerGeneratedAttribute]
public DagTest get_DagTest();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowDeclarationStatement : CSharpControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowDeclarationStatement(IDeclarationStatement statement, CSharpControlFlowBuilderParams params);
    private void AddMultiplexor(ICSharpDeclaration declaration);
    private void SetExitsTo(ICSharpControlFlowElement element);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowDoStatement : CSharpControlFlowLoopStatement {
    private CSharpControlFlowCondition myCondition;
    private CSharpControlFlowStatement myStatement;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowDoStatement(IDoStatement statement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowEdge : ControlFlowEdge {
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private List`1<IDeclaredElement> myExitFromUsings;
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private List`1<ICSharpStatement> myExitFromLoops;
    [CompilerGeneratedAttribute]
private ControlFlowEdgeCondition <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpPassThroughFinallyEdgeInfo <PassThroughFinally>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpExitFromFinallyEdgeInfo <ExitFromFinally>k__BackingField;
    public ICSharpControlFlowElement Source { get; }
    public ICSharpControlFlowElement Target { get; public set; }
    public ControlFlowEdgeCondition Condition { get; }
    public CSharpPassThroughFinallyEdgeInfo PassThroughFinally { get; public set; }
    public CSharpExitFromFinallyEdgeInfo ExitFromFinally { get; public set; }
    public IEnumerable`1<IDeclaredElement> ExitFromUsings { get; }
    public IEnumerable`1<ICSharpStatement> ExitFromLoops { get; }
    public CSharpControlFlowEdge(ControlFlowEdgeType edgeType, IControlFlowElement source);
    public CSharpControlFlowEdge(ControlFlowEdgeType edgeType, IControlFlowElement source, IControlFlowElement target);
    public CSharpControlFlowEdge(ControlFlowEdgeType edgeType, IControlFlowElement source, IControlFlowElement target, ControlFlowEdgeCondition condition);
    public CSharpControlFlowEdge(ControlFlowEdgeType edgeType, IControlFlowElement source, ControlFlowEdgeCondition condition);
    public sealed virtual ICSharpControlFlowElement get_Source();
    public sealed virtual ICSharpControlFlowElement get_Target();
    public sealed virtual void set_Target(ICSharpControlFlowElement value);
    public virtual ITreeNode GetSourceElement();
    [CompilerGeneratedAttribute]
public sealed virtual ControlFlowEdgeCondition get_Condition();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpPassThroughFinallyEdgeInfo get_PassThroughFinally();
    [CompilerGeneratedAttribute]
public void set_PassThroughFinally(CSharpPassThroughFinallyEdgeInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual CSharpExitFromFinallyEdgeInfo get_ExitFromFinally();
    [CompilerGeneratedAttribute]
public void set_ExitFromFinally(CSharpExitFromFinallyEdgeInfo value);
    public sealed virtual IEnumerable`1<IDeclaredElement> get_ExitFromUsings();
    public sealed virtual IEnumerable`1<ICSharpStatement> get_ExitFromLoops();
    public void AddDisposingVariableForExit(IDeclaredElement usingVariable);
    public void AddExitFromLoop(ICSharpStatement loopStatement);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowEmptyStatement : CSharpControlFlowSimpleStatement {
    public bool ExecutesCode { get; }
    public CSharpControlFlowEmptyStatement(IEmptyStatement statement);
    public virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowError : CSharpControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private CSharpControlFlowErrorType <ErrorType>k__BackingField;
    public CSharpControlFlowErrorType ErrorType { get; }
    public CSharpControlFlowError(CSharpControlFlowErrorType errorType, ITreeNode sourceElement);
    [CompilerGeneratedAttribute]
public sealed virtual CSharpControlFlowErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowErrorPatternElement : ControlFlowElement {
    [CompilerGeneratedAttribute]
private IPattern <Pattern>k__BackingField;
    public ITreeNode SourceElement { get; }
    [NotNullAttribute]
public IPattern Pattern { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowErrorPatternElement(IPattern pattern);
    public virtual ITreeNode get_SourceElement();
    [CompilerGeneratedAttribute]
public IPattern get_Pattern();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowExpression : ControlFlowElement {
    [CanBeNullAttribute]
private ICSharpExpression myExpression;
    [CanBeNullAttribute]
private List`1<IControlFlowElement> myChildren;
    public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowExpression(ICSharpExpression expression, CSharpControlFlowBuilderParams parameters);
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowExpressionStatement : CSharpControlFlowStatement {
    private CSharpControlFlowExpression myExpression;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowExpressionStatement(IExpressionStatement statement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowFixedStatement : CSharpControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowFixedStatement(IUnsafeCodeFixedStatement statement, CSharpControlFlowBuilderParams params);
    private void SetExitsTo(ICSharpControlFlowElement initializer);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowForeachStatement : CSharpControlFlowLoopStatement {
    private CSharpControlFlowMultiplexor myStartOfLoopPoint;
    private CSharpControlFlowExpression myCollection;
    private CSharpControlFlowMultiplexor myCollectionIterator;
    private CSharpControlFlowMultiplexor myCollectionMultiplexor;
    private CSharpControlFlowStatement myBody;
    private CSharpControlFlowMultiplexor myStartBodyPoint;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowForeachStatement(IForeachStatement foreachStatement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowForStatement : CSharpControlFlowLoopStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowForStatement(IForStatement forStatement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraph : ControlFlowGraph {
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private CSharpControlFlowMultiplexor myEntryElement;
    [NotNullAttribute]
private CSharpControlFlowBody myBodyElement;
    [CompilerGeneratedAttribute]
private ICSharpTreeNode <OwnerNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpDeclaration <Declaration>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpTreeNode <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <CSharpLanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpTypeConversionRule <ConversionRule>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInstanceStructConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IParameter> <Parameters>k__BackingField;
    public ISolution Solution { get; }
    public IPsiModule PsiModule { get; }
    public ICSharpTreeNode OwnerNode { get; }
    public ICSharpDeclaration Declaration { get; }
    public IControlFlowElement EntryElement { get; }
    public IControlFlowElement BodyElement { get; }
    public ICSharpTreeNode Body { get; }
    public CSharpLanguageLevel CSharpLanguageLevel { get; }
    public ICSharpTypeConversionRule ConversionRule { get; }
    public bool IsInstanceStructConstructor { get; }
    public IList`1<IParameter> Parameters { get; }
    public ICollection`1<ICSharpControlFlowEdge> ReachableExits { get; }
    public bool HasReachableImplicitReturn { get; }
    public IDictionary`2<ITreeNode, CSharpControlFlowErrorType> ControlFlowErrors { get; }
    public ICollection`1<ICSharpStatement> RedundantJumpStatements { get; }
    public CSharpControlFlowGraph(IList`1<IParameter> parameters, ICSharpDeclaration declaration, IBlock blockBody, IResolveContext resolveContext, bool buildExpressions);
    public CSharpControlFlowGraph(IList`1<IParameter> parameters, IClassLikeDeclaration typeDeclaration, IResolveContext resolveContext, bool buildExpressions);
    public CSharpControlFlowGraph(IList`1<IParameter> parameters, ICSharpDeclaration declaration, ICSharpExpression expressionBody, IResolveContext resolveContext);
    public CSharpControlFlowGraph(ITopLevelCode topLevelCode, IResolveContext resolveContext, bool buildExpressions);
    public CSharpControlFlowGraph(IAttribute attribute, IResolveContext resolveContext);
    private static bool IsInStructConstructor(ICSharpFunctionDeclaration functionDeclaration);
    public sealed virtual ISolution get_Solution();
    public sealed virtual IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpTreeNode get_OwnerNode();
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpDeclaration get_Declaration();
    public virtual IControlFlowElement get_EntryElement();
    public virtual IControlFlowElement get_BodyElement();
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpTreeNode get_Body();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpLanguageLevel get_CSharpLanguageLevel();
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpTypeConversionRule get_ConversionRule();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInstanceStructConstructor();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual ICollection`1<ICSharpControlFlowEdge> get_ReachableExits();
    public sealed virtual bool get_HasReachableImplicitReturn();
    public sealed virtual IDictionary`2<ITreeNode, CSharpControlFlowErrorType> get_ControlFlowErrors();
    public sealed virtual ICollection`1<ICSharpStatement> get_RedundantJumpStatements();
    [PureAttribute]
private static bool IsSingleYieldStatement(ICSharpStatement statement);
    private bool CompareControlFlow(ICSharpControlFlowEdge r1, ICSharpControlFlowEdge r2);
    [CanBeNullAttribute]
private static CSharpPassThroughFinallyEdgeInfo GetPassThroughFinally(ICSharpControlFlowEdge edge, HashSet`1<ICSharpControlFlowEdge> visited);
    public void CollectExecutableElements(ICSharpControlFlowEdge edge, Boolean& hasExitFromMethod, HashSet`1<IControlFlowElement> executableElements, HashSet`1<IControlFlowElement> visited);
    public sealed virtual bool IsJumpStatementMandatoryForSwitch(ICSharpStatement statement);
    public sealed virtual bool IsImplicitSwitchBlockImplicitExitEdge(ICSharpControlFlowEdge edge);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector : CommonLanguageControlFlowGraphInspector`3<CSharpControlFlowContextFactory, CSharpControlFlowContext, VariableInfo> {
    [NotNullAttribute]
private Func`2<ITreeNode, ICSharpControlFlowGraph> myGraphBuilder;
    [NotNullAttribute]
private ClosureAnalyzer myClosureAnalyzer;
    [NotNullAttribute]
private LocalFunctionAnalysis myLocalFunctionAnalysis;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, ILocalFunction> myLocalFunctionUsages;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, OneToSetMap`2<DagTempVariable, VariableInfo>> myDagTempVariablesMap;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, OneToSetMap`2<DagEvaluation, DagTempVariable>> myDagVariablesSourceMap;
    [NotNullAttribute]
private HashSet`1<ICSharpExpression> myPossibleNullReferenceAccess;
    [NotNullAttribute]
private HashSet`1<ICSharpExpression> myPossibleInvalidCastExpressions;
    [NotNullAttribute]
private HashSet`1<ITreeNode> myAssignNullToNotNullEntity;
    [NotNullAttribute]
private OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, ICSharpExpression> myPossibleMultipleEnumeration;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, Nullable`1<ConstantExpressionValue>> myConstantConditionExpressions;
    [NotNullAttribute]
private Dictionary`2<ValueTuple`2<ICSharpExpression, ICSharpExpression>, CSharpControlFlowNullReferenceState> myConstantConditionNullCoalescingExpression;
    [NotNullAttribute]
private Dictionary`2<IConditionalAccessExpression, CSharpControlFlowNullReferenceState> myConstantConditionalAccessExpression;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, bool> myNullCoalescingOperatorRightOperandIsNull;
    [NotNullAttribute]
private Dictionary`2<IAsExpression, bool> myAlwaysSuccessTryCastExpressions;
    [NotNullAttribute]
private Dictionary`2<IAssignmentExpression, IParameter> myRefAssignmentsToUnassignedOutParameters;
    [NotNullAttribute]
private Dictionary`2<IAssignmentExpression, bool> myPossibleMeaninglessAssignments;
    [NotNullAttribute]
private HashSet`1<IIsExpression> myHeuristicTrueIsTypeChecks;
    [NotNullAttribute]
private Dictionary`2<ISwitchCaseLabel, bool> myHeuristicUnreachableCaseLabels;
    [NotNullAttribute]
private Dictionary`2<ISwitchExpressionArm, bool> myHeuristicUnreachableSwitchArms;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, bool> myIsPossibleEnumerationCache;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, bool> myLambdaIsKnownLocallyExecuted;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, ContractAnnotationApplicator> myFDTApplicatorCache;
    [NotNullAttribute]
private Dictionary`2<VariableInfo, CSharpControlFlowVariableValue> myLinqWeakVariablesNREStates;
    [NotNullAttribute]
private Dictionary`2<ILoopWithConditionStatement, VariableInfo[]> myLoopVariableInfos;
    [NotNullAttribute]
private OneToSetMap`2<IDeclaredElement, ITreeNode> myEnumerablesAccessInClosure;
    private IParameter myLinqParameter;
    private Nullable`1<CSharpControlFlowVariableValue> myLinqParameterNREState;
    [NotNullAttribute]
private Dictionary`2<IDeclaredElement, CSharpControlFlowNullReferenceState> myNullnessSuggestions;
    [NotNullAttribute]
private Dictionary`2<ICastExpression, CSharpControlFlowNullReferenceState> myCastNullnessSuggestions;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ILocalFunctionDeclaration> myLocalFunctionsWithRecursionOnAllReachableExits;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<IAnonymousFunctionExpression> myReachableAnonymousFunctionExpressions;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<PatternMatchingCandidateData> myPatternMatchingSuggestionsFromClosures;
    [NotNullAttribute]
private Dictionary`2<ValueTuple`2<IDeclaredElement, ITreeNode>, bool> myIsAssignedTypeCouldBePureEnumerableForClosureAssignments;
    [CanBeNullAttribute]
private HashSet`1<ValueTuple`2<IReferenceExpression, IType>> myByRefTypesInAwaitOrYieldClosure;
    [CanBeNullAttribute]
private HashSet`1<IReferenceExpression> myRefLocalsInAwaitOrYieldClosure;
    [CompilerGeneratedAttribute]
private PredefinedType <PredefinedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpControlFlowGraph <ControlFlowGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpControlFlowContext <LocalFunctionReachableExitContext>k__BackingField;
    [NotNullAttribute]
private MemberNotNullAnnotationProvider myMemberNotNullAnnotationProvider;
    private int myNumberOfStatesOnPassSoFar;
    private static HashSet`1<string> ourFilterMethodsFromEnumerable;
    private static HashSet`1<string> ourGetElementMethodsFromEnumerable;
    [NotNullAttribute]
private IResolveContext ResolveContext { get; }
    [NotNullAttribute]
private ICSharpTypeConversionRule TypeConversionRule { get; }
    [NotNullAttribute]
private PredefinedType PredefinedTypes { get; }
    [NotNullAttribute]
private CSharpControlFlowAnnotationCache AnnotationCache { get; }
    [NotNullAttribute]
private ICSharpControlFlowGraph ControlFlowGraph { get; }
    [CanBeNullAttribute]
private CSharpControlFlowContext LocalFunctionReachableExitContext { get; private set; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public ValueAnalysisMode AnalysisMode { get; }
    private bool IsMemorySnapshotCountOverflow { get; }
    public ICollection`1<IDeclaredElement> UsedFieldsWithTrackedAccessState { get; }
    public bool HasTooManyVariables { get; }
    public bool HasComplexityOverflow { get; }
    public bool HasRecursionOnAllReachableExits { get; }
    public HashSet`1<ICSharpExpression> PossibleNullReferenceAccess { get; }
    public HashSet`1<ICSharpExpression> PossibleInvalidCastExpressions { get; }
    public IList`1<IAsExpression> AlwaysSuccessTryCastExpressions { get; }
    public IReadOnlyDictionary`2<IAssignmentExpression, IParameter> RefAssignmentsToUnassignedOutParameters { get; }
    public IDictionary`2<ICSharpExpression, ConstantExpressionValue> ConstantConditionExpressions { get; }
    public IDictionary`2<ValueTuple`2<ICSharpExpression, ICSharpExpression>, CSharpControlFlowNullReferenceState> ConstantConditionNullCoalescingExpression { get; }
    public IDictionary`2<IConditionalAccessExpression, CSharpControlFlowNullReferenceState> ConstantConditionalAccessExpressions { get; }
    public ICollection`1<ICSharpExpression> NullCoalescingOperatorRightOperandIsAlwaysNull { get; }
    public HashSet`1<ITreeNode> AssignNullToNotNullEntity { get; }
    public IEnumerable`1<ILocalFunctionDeclaration> LocalFunctionsWithRecursionOnAllReachableExits { get; }
    public IEnumerable`1<PatternMatchingCandidateData> PatternMatchingSuggestions { get; }
    public IEnumerable`1<ValueTuple`2<IReferenceExpression, IType>> ByRefTypesInAwaitOrYieldClosure { get; }
    public IEnumerable`1<IReferenceExpression> RefLocalsInAwaitOrYieldClosure { get; }
    public CSharpControlFlowNullReferenceState SuggestReturnValueAnnotationAttribute { get; }
    public IDictionary`2<IDeclaredElement, CSharpControlFlowNullReferenceState> InferredNullability { get; }
    public IDictionary`2<ICastExpression, CSharpControlFlowNullReferenceState> InferredCastNullability { get; }
    public ICollection`1<IAssignmentExpression> MeaninglessAssignments { get; }
    public IEnumerable`1<IIsExpression> HeuristicTrueIsExpressions { get; }
    public IEnumerable`1<ISwitchCaseLabel> HeuristicUnreachableCaseLabels { get; }
    public IEnumerable`1<ISwitchExpressionArm> HeuristicUnreachableSwitchArms { get; }
    public ICollection`1<ICSharpStatement> HeuristicUnreachableCode { get; }
    public ICollection`1<ICSharpExpression> LoopVariablesNotChangedInsideLoop { get; }
    public IEnumerable`1<KeyValuePair`2<IDeclaredElement, ISet`1<ITreeNode>>> EnumerablesAccessedInClosure { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<ICollection`1<ITypeMember>, ICollection`1<ITypeMember>> InitializedTypeMembers { get; }
    public ClassInitializationInfo InitializationInfo { get; }
    public OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, ICSharpExpression> PossibleMultipleEnumeration { get; }
    protected CSharpControlFlowGraphInspector(ICSharpControlFlowGraph controlFlowGraph, CSharpControlFlowContextFactory factory, Func`2<ITreeNode, ICSharpControlFlowGraph> graphBuilder);
    private CSharpControlFlowGraphInspector(ICSharpControlFlowGraph controlFlowGraph, CSharpControlFlowContextFactory factory, Func`2<ITreeNode, ICSharpControlFlowGraph> graphBuilder, LocalFunctionAnalysis localFunctionAnalysis);
    private static CSharpControlFlowGraphInspector();
    private IResolveContext get_ResolveContext();
    private ICSharpTypeConversionRule get_TypeConversionRule();
    [CompilerGeneratedAttribute]
private PredefinedType get_PredefinedTypes();
    private CSharpControlFlowAnnotationCache get_AnnotationCache();
    [CompilerGeneratedAttribute]
private ICSharpControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
private CSharpControlFlowContext get_LocalFunctionReachableExitContext();
    [CompilerGeneratedAttribute]
private void set_LocalFunctionReachableExitContext(CSharpControlFlowContext value);
    [CanBeNullAttribute]
internal static ICSharpControlFlowGraph DefaultGraphBuilder(ITreeNode node);
    public virtual void Inspect();
    public sealed virtual CSharpLanguageLevel get_LanguageLevel();
    public sealed virtual ValueAnalysisMode get_AnalysisMode();
    [NotNullAttribute]
[PureAttribute]
public static CSharpControlFlowGraphInspector Inspect(ICSharpControlFlowGraph graph, ValueAnalysisMode analysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis, Func`2<ITreeNode, ICSharpControlFlowGraph> graphBuilder);
    protected virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement element, CSharpControlFlowContext context);
    private bool get_IsMemorySnapshotCountOverflow();
    protected virtual void SetContext(IControlFlowEdge rib, CSharpControlFlowContext context, int timestamp);
    protected virtual IEnumerable`1<VariableInfo> EnumerateVariables();
    public virtual ICollection`1<IDeclaredElement> get_UsedFieldsWithTrackedAccessState();
    protected virtual bool IsForeachVariableDeclaration(IDeclaredElement declaredElement);
    private void OnPatchAccessInfo(IControlFlowElement controlFlowElement, CSharpControlFlowContext context, VariableInfo info, ControlFlowAccessType access, ITreeNode accessExpression);
    private void PatchMemorySnapshotsOnWrite(IControlFlowElement controlFlowElement, CSharpControlFlowContext context, VariableInfo info, ITreeNode accessExpression);
    private IControlFlowElement FindParentControlFlowElementFor(IControlFlowElement element, ITreeNode parentSourceElement);
    private void PatchMemorySnapshotsOnTupleAssignment(IControlFlowElement parentControlFlowElement, CSharpControlFlowContext context, VariableInfo info, DecoratedType`1<TupleTypeDecoration> targetTupleType, ITupleExpression assignmentSource);
    private bool CopyExpressionStateToVariable(IControlFlowElement parentControlFlowElement, CSharpControlFlowContext context, VariableInfo variableInfo, ICSharpExpression initializerExpression);
    private bool CopyVariableStateToVariable(IControlFlowElement parentControlFlowElement, CSharpControlFlowContext context, VariableInfo sourceVariableInfo, VariableInfo destVariableInfo, ICSharpExpression initializerExpression);
    [CanBeNullAttribute]
private IControlFlowElement FindTopmostControlFlowElementForNode(IControlFlowElement parentElement, ITreeNode treeNode);
    [NotNullAttribute]
private static IControlFlowElement FindTopmostElementForSameSourceNode(IControlFlowElement controlFlowElement);
    [CanBeNullAttribute]
private IParameter TryGetDeconstructMethodOutParameterUsed(ICSharpExpression accessExpression);
    [CanBeNullAttribute]
private IParameter TryGetDeconstructMethodOutParameterUsed(IDeconstructionReference deconstructionReference, int componentIndex);
    private void PatchMemorySnapshotsOnUnknownValueWrite(CSharpControlFlowContext context, VariableInfo info, bool clearTypeSpecification);
    [CanBeNullAttribute]
private VariableInfo TryFindParentCollectionVariableInfo(CSharpControlFlowContext context, VariableInfo info);
    [PureAttribute]
private static bool IsPartOfDeconstruction(ITreeNode accessExpression);
    private bool IsUserDefinedConversionOperatorUsed(ITreeNode accessExpression);
    protected virtual bool ShouldInspectSingleLeaf(ControlFlowElement element);
    [CanBeNullAttribute]
private static ControlFlowHistoryCheckPointInfo FindHistoryCheckPoint(ControlFlowElement parentElement, CSharpControlFlowContext context, ITreeNode sourceElement);
    [NotNullAttribute]
private OneToSetMap`2<DagTempVariable, VariableInfo> GetDagTempVariablesMap(ITreeNode dagSource, VariableIndex variableIndex);
    [NotNullAttribute]
private OneToSetMap`2<DagEvaluation, DagTempVariable> GetDagVariablesSourceMap(ITreeNode dagSource, VariableIndex variableIndex);
    public virtual bool get_HasTooManyVariables();
    public sealed virtual bool get_HasComplexityOverflow();
    public sealed virtual bool get_HasRecursionOnAllReachableExits();
    public sealed virtual HashSet`1<ICSharpExpression> get_PossibleNullReferenceAccess();
    public sealed virtual HashSet`1<ICSharpExpression> get_PossibleInvalidCastExpressions();
    public sealed virtual IList`1<IAsExpression> get_AlwaysSuccessTryCastExpressions();
    public sealed virtual IReadOnlyDictionary`2<IAssignmentExpression, IParameter> get_RefAssignmentsToUnassignedOutParameters();
    public sealed virtual IDictionary`2<ICSharpExpression, ConstantExpressionValue> get_ConstantConditionExpressions();
    public sealed virtual IDictionary`2<ValueTuple`2<ICSharpExpression, ICSharpExpression>, CSharpControlFlowNullReferenceState> get_ConstantConditionNullCoalescingExpression();
    public sealed virtual IDictionary`2<IConditionalAccessExpression, CSharpControlFlowNullReferenceState> get_ConstantConditionalAccessExpressions();
    public sealed virtual ICollection`1<ICSharpExpression> get_NullCoalescingOperatorRightOperandIsAlwaysNull();
    public sealed virtual HashSet`1<ITreeNode> get_AssignNullToNotNullEntity();
    public sealed virtual IEnumerable`1<ILocalFunctionDeclaration> get_LocalFunctionsWithRecursionOnAllReachableExits();
    public sealed virtual IEnumerable`1<PatternMatchingCandidateData> get_PatternMatchingSuggestions();
    public sealed virtual IEnumerable`1<ValueTuple`2<IReferenceExpression, IType>> get_ByRefTypesInAwaitOrYieldClosure();
    public sealed virtual IEnumerable`1<IReferenceExpression> get_RefLocalsInAwaitOrYieldClosure();
    public sealed virtual CSharpControlFlowNullReferenceState get_SuggestReturnValueAnnotationAttribute();
    public sealed virtual IDictionary`2<IDeclaredElement, CSharpControlFlowNullReferenceState> get_InferredNullability();
    public IDictionary`2<ICastExpression, CSharpControlFlowNullReferenceState> get_InferredCastNullability();
    public sealed virtual CSharpControlFlowNullReferenceState GetExpressionNullReferenceState(IReferenceExpression expression, bool includeWeakNotNull);
    public sealed virtual CSharpControlFlowNullReferenceState GetVariableStateAt(IControlFlowElement position, IDeclaredElement variable);
    public sealed virtual ControlFlowVariableAccessState GetVariableAccessStateAt(IControlFlowEdge edge, IDeclaredElement variable);
    public sealed virtual IEnumerable`1<ITreeNode> GetRecentAssignmentsList(IControlFlowEdge edge, IDeclaredElement variable);
    public sealed virtual ICollection`1<IAssignmentExpression> get_MeaninglessAssignments();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector/<get_HeuristicTrueIsExpressions>d__141")]
public sealed virtual IEnumerable`1<IIsExpression> get_HeuristicTrueIsExpressions();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector/<get_HeuristicUnreachableCaseLabels>d__143")]
public sealed virtual IEnumerable`1<ISwitchCaseLabel> get_HeuristicUnreachableCaseLabels();
    private bool IsReportOfCodeInvariantViolation(ISwitchSection switchSection);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector/<get_HeuristicUnreachableSwitchArms>d__146")]
public sealed virtual IEnumerable`1<ISwitchExpressionArm> get_HeuristicUnreachableSwitchArms();
    public sealed virtual ICollection`1<ICSharpStatement> get_HeuristicUnreachableCode();
    private bool IsHeuristicallyReachable(ControlFlowElement element);
    private bool IsRequiredForCompilation(ITreeNode sourceElement);
    public sealed virtual ICollection`1<ICSharpExpression> get_LoopVariablesNotChangedInsideLoop();
    public sealed virtual IEnumerable`1<KeyValuePair`2<IDeclaredElement, ISet`1<ITreeNode>>> get_EnumerablesAccessedInClosure();
    private bool IsCheckOfCodeInvariantBody(ICSharpStatement statement);
    public sealed virtual bool IsLambdaKnownToBeExecutedLocally(ITreeNode lambda);
    public virtual ValueTuple`2<ICollection`1<ITypeMember>, ICollection`1<ITypeMember>> get_InitializedTypeMembers();
    public virtual ClassInitializationInfo get_InitializationInfo();
    private CSharpControlFlowNullReferenceState GetVariableStateAt(IControlFlowElement position, VariableInfo info, bool after, bool includeWeakNotNull);
    private CSharpControlFlowNullReferenceState GetVariableStateAt(IControlFlowEdge exit, VariableInfo info, bool includeWeakNotNull);
    private void PostProcessAssignmentTable();
    private static bool CanExpressionBeNull(CSharpControlFlowContext context);
    private void PostValueAnalysis();
    [NotNullAttribute]
private IEnumerable`1<PatternMatchingCandidateData> GetPatternMatchingSuggestions();
    [NotNullAttribute]
private static PatternMatchingCandidateData AnalyzePatternMatchingCandidate(ILocalVariableDeclaration declaration, ICSharpExpression nullCheckExpression, bool isNotEqualsNullCheck);
    private bool IsHeuristicallyUnreachable(ControlFlowElement controlFlowElement);
    private bool ContainsStatementsRequiredForCompilation(ISwitchCaseLabel switchCaseLabel);
    private static bool HasDefaultCase(ISwitchStatement switchStatement);
    private void MergeToReachableExitContext(CSharpControlFlowContext context);
    private void InspectUnreachableClosures();
    private void InspectLocalFunctions();
    private void PostAnalysisExit(ITreeNode returnElement, CSharpControlFlowContext context);
    private void PostAnalysisFunctionReturn(ICSharpDeclaration declaration, CSharpControlFlowContext context, ICSharpExpression returnExpression);
    private void PostAnalysisParameterNullability(CSharpControlFlowContext context);
    private void PostAnalysisClosureExit(ICSharpExpression returnExpression, IType implicitlyConvertedTo, IDeclaredElement returnValueOwner, bool isContainer, CSharpControlFlowContext context);
    private void PostAnalysisAssignment(IAssignmentExpression assignmentExpression, CSharpControlFlowContext context);
    private void PostAnalysisRedundantAssignment(IAssignmentExpression assignmentExpression, ControlFlowElement element, CSharpControlFlowContext context);
    private void PostAnalysisArgument(ICSharpArgument argument, CSharpControlFlowContext context);
    private void PostAnalysisMemberInitializer(IReference memberReference, ICSharpExpression assignedExpression, CSharpControlFlowContext context);
    private void PostAnalysisConditionalAccess(CSharpConditionalAccessMultiplexor conditionalMultiplexor, CSharpControlFlowContext context);
    private void PostAnalysisNullCoalescing(CSharpNullCoalescingMultiplexor nullCoalescingMultiplexor, CSharpControlFlowContext context);
    private void PostAnalysisAsExpression(IAsExpression asExpression, CSharpControlFlowContext context);
    private void PostAnalysisMemberInitializer(ICSharpTypeMemberDeclaration memberDeclaration, CSharpControlFlowContext context);
    private void PostAnalysisVariableInitializer(ILocalVariableDeclaration localVariableDeclaration, CSharpControlFlowContext context);
    private void PostAnalysisCastExpression(ICastExpression castExpression, CSharpControlFlowContext context);
    public sealed virtual OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, ICSharpExpression> get_PossibleMultipleEnumeration();
    public sealed virtual bool IsAssignedTypeCouldBePureEnumerable(IDeclaredElement declaredElement, ITreeNode assignment);
    private Nullable`1<bool> IsAssignedTypeCouldBePureEnumerableFromTypeTracking(IDeclaredElement declaredElement, ITreeNode assignment);
    private void ClearClosureParameterVariableState();
    [ContractAnnotationAttribute("method:null => false")]
private static bool IsMethodFromSystemLinqEnumerable(IMethod method, Int32& itemFromCollectionParameterNumber);
    private bool SkipReportForConstantConditionExpression(ICSharpExpression expression);
    private IEnumerable`1<Pair`2<ICSharpExpression, Nullable`1<ConstantExpressionValue>>> EnumerateConstantExpressionExits(ControlFlowElement element);
    private bool SetExpressionStateByAttributes(IReference reference, CSharpControlFlowContext context);
    private bool SetExpressionStateByAttributes(IDeclaredElement declaredElement, ISubstitution substitution, CSharpControlFlowContext context);
    private void SetDefaultExpressionMemoryState(CSharpControlFlowContext context, IType type);
    private void SetVariableStateByAttributes(IDeclaredElement element, VariableInfo info, CSharpControlFlowContext context);
    private static void ResetNestedVariables(VariableInfo parentInfo, CSharpControlFlowContext context);
    private static void ResetWeakVariablesInExpression(ICSharpExpression qualifierExpression, IDeclaration graphOwnerDeclaration, CSharpControlFlowContext context, bool skipInstanceFields, bool isQualifierAccess);
    private static bool CanVariableChangeOnQualifierChange(ICSharpExpression accessExpression, ICSharpExpression qualifierExpression);
    private void TransformVariableStateAfterPassingToNotNullEntity(IAttributesOwner attributesOwner, VariableInfo info, CSharpControlFlowContext context, bool useContainerAnnotation);
    private CSharpControlFlowVariableValue GetContainerElementNullabilityStateMask(IAttributesOwner attributesOwner);
    private bool IsPossibleEnumeration(CSharpControlFlowContext context, ICSharpExpression expression, VariableInfo info);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector/<GetRecentAccessesInClosure>d__206")]
protected virtual IEnumerable`1<ITreeNode> GetRecentAccessesInClosure(CSharpControlFlowContext context, VariableInfo info);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowGraphInspector/<GetAccessExpressionsThroughLocalFunctionCalls>d__207")]
public IEnumerable`1<ITreeNode> GetAccessExpressionsThroughLocalFunctionCalls(CSharpControlFlowContext context, ITreeNode expression, VariableInfo info, HashSet`1<ITreeNode> visitedNodes);
    [CanBeNullAttribute]
private LocalFunctionInfo GetLocalFunctionInfoFromAccessExpression(ITreeNode expression);
    private void PatchContextBySpecialMethodCall(IInvocationExpression invocationExpression, IControlFlowElement controlFlowElement, CSharpControlFlowContext context);
    private bool PatchContextByNUnitAssertionMethodCall(IInvocationExpression invocationExpression, IResolveResult resolveResult, IControlFlowElement controlFlowElement, CSharpControlFlowContext context);
    private void PatchContextByAnnotatedMethodCall(IInvocationExpression invocationExpression, IResolveResult resolveResult, IControlFlowElement controlFlowElement, CSharpControlFlowContext context);
    private void PatchContextByObsoleteAnnotatedMethodCall(IInvocationExpression invocationExpression, IResolveResult resolveResult, IControlFlowElement controlFlowElement, CSharpControlFlowContext context);
    private void PatchContextByEqualityMethodCall(IInvocationExpression invocationExpression, IMethod method, ControlFlowElement controlFlowElement, CSharpControlFlowContext context);
    private ValueTuple`2<VariableInfo, ICSharpExpression> FindVariableInfoAndExpressionForArgument(ICSharpArgument argument, ControlFlowElement controlFlowElement, CSharpControlFlowContext context);
    public static void ControlFlowElementFinder(ControlFlowElement element, ICollection`1<ControlFlowElement> consumer, TState state, Func`3<ControlFlowElement, TState, bool> predicate);
    private void PatchContextByAssertionMethodCall(ICSharpExpression argumentExpression, AssertionConditionType assertionType, CSharpControlFlowContext context, IControlFlowElement controlFlowElement);
    private bool IsCheckOfCodeInvariant(ICSharpExpression expression);
    private static bool IsCompileTimeConstantExpression(ICSharpExpression expression);
    private bool IsSubjectToNullnessCheck(IControlFlowEdge edge);
    [PureAttribute]
private static bool IsConditionalAccessNullBranch(IControlFlowEdge edge, IConditionalAccessExpression conditionalAccessExpression);
    [CanBeNullAttribute]
[PureAttribute]
private VariableInfo FindInfoByExpression(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private VariableInfo FindInfoByExpression(ICSharpExpression expression, ICSharpExpression& variableAccessExpression);
    [CanBeNullAttribute]
[PureAttribute]
public VariableInfo FindVariableInfo(ILocalVariable variable);
    [CanBeNullAttribute]
[PureAttribute]
public VariableInfo FindVariableInfo(IParameter parameter);
    public sealed virtual ISharedControlFlowAnalysisResult CreateSharedControlFlowAnalysisResult();
    public sealed virtual AnalysisInfo GetStatistics();
    public sealed virtual LocalFunctionInfo GetLocalFunctionInfo(ILocalFunction localFunction);
    private static bool IsFilterCollectionMethod(IMethod method);
    private static bool IsShuffleCollectionMethod(IMethod method);
    private static bool IsListFindAllMethod(IMethod method);
    private static bool IsShuffleMethodFromEnumerableClass(IMethod method);
    private static bool IsFilterMethodFromEnumerableClass(IMethod method);
    private static bool IsGetElementMethodFromEnumerableClass(IMethod method);
    private static bool IsMethodFromEnumerableClass(IMethod method);
    [ContractAnnotationAttribute("null => false")]
private static bool IsLinqSelectMethod(IMethod method);
    [CanBeNullAttribute]
private static CSharpBinaryExpressionIntermediateMultiplexor FindIntermediateMultiplexor(IControlFlowElement controlFlowElement);
    [CanBeNullAttribute]
private static ForEachIteratorMultiplexor FindForEachIteratorMultiplexor(IControlFlowElement controlFlowElement);
    [CompilerGeneratedAttribute]
internal static void <PatchMemorySnapshotsOnWrite>g__ResetNestedVariableStates|72_0(VariableInfo parentInfo, <>c__DisplayClass72_0& );
    [CompilerGeneratedAttribute]
internal static DecisionDag <GetDagTempVariablesMap>g__GetDecisionDag|87_0(ITreeNode dagSource, ICSharpExpression& governingExpression, IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
private bool <get_HeuristicUnreachableSwitchArms>g__IsCheckOfCodeInvariantExpression|146_0(ICSharpExpression expression);
    [CompilerGeneratedAttribute]
internal static ICSharpExpression <GetPatternMatchingSuggestions>g__GetFirstUsage|166_0(IEnumerable`1<ITreeNode> usages);
    [CompilerGeneratedAttribute]
internal static ICSharpExpression <GetPatternMatchingSuggestions>g__TryGetNullCheckExpression|166_1(IReferenceExpression referenceExpression, Boolean& isNotNullCheck);
    [CompilerGeneratedAttribute]
[ItemNotNullAttribute]
internal static LocalHashSet`1<ITreeNode> <GetPatternMatchingSuggestions>g__GetPossibleAssignmentUsagesOnFalseBranch|166_2(PatternMatchingCandidateData patternMatchingData, IEnumerable`1<ITreeNode> assignmentUsages);
    [CompilerGeneratedAttribute]
private void <GetPatternMatchingSuggestions>g__FilterCandidatesUsedWithoutAssignmentsOnFalseBranches|166_3(<>c__DisplayClass166_0& );
    [CompilerGeneratedAttribute]
private bool <GetPatternMatchingSuggestions>g__HasDeclarationAssignmentUsage|166_4(<>c__DisplayClass166_0& , <>c__DisplayClass166_1& , <>c__DisplayClass166_2& );
    [CompilerGeneratedAttribute]
private bool <GetPatternMatchingSuggestions>g__IsDefinitelyAssignedOnAllTargetEntries|166_5(<>c__DisplayClass166_0& , <>c__DisplayClass166_1& , <>c__DisplayClass166_2& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzePatternMatchingCandidate>g__IsNonDynamicPredefinedOperatorUsage|167_0(IBinaryExpression binaryExpression);
    [CompilerGeneratedAttribute]
internal static void <SetVariableStateByAttributes>g__PatchCollectionStateOnElementAssignment|199_0(CSharpControlFlowVariableValue elementState, <>c__DisplayClass199_0& );
    [CompilerGeneratedAttribute]
private bool <IsPossibleEnumeration>g__Calculator|205_0(ICSharpExpression ex, <>c__DisplayClass205_0& );
    [CompilerGeneratedAttribute]
internal static bool <PatchContextByEqualityMethodCall>g__IsStringEqualsOrNullableEquals|213_0(IMethod method, ITypeElement containingType);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowIfStatement : CSharpControlFlowStatement {
    private CSharpControlFlowCondition myCondition;
    private CSharpControlFlowStatement myThenStatement;
    private CSharpControlFlowStatement myElseStatement;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowIfStatement(IIfStatement statement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowInitializer : ControlFlowElement {
    [NotNullAttribute]
private ICreationExpressionInitializer myInitializer;
    [NotNullAttribute]
private List`1<IControlFlowElement> myChildren;
    [NotNullAttribute]
public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowInitializer(ICreationExpressionInitializer initializer, CSharpControlFlowBuilderParams params);
    private void AddExits();
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowInitializerElement : ControlFlowElement {
    [NotNullAttribute]
private IInitializerElement myInitializer;
    [NotNullAttribute]
private List`1<IControlFlowElement> myChildren;
    [NotNullAttribute]
public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowInitializerElement(IInitializerElement initializer, CSharpControlFlowBuilderParams params);
    private void AddExits();
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowInstanceInitializationEndMultiplexor : CSharpControlFlowMultiplexor {
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowJumpStatement : CSharpControlFlowStatement {
    private CSharpControlFlowEdge myPhantomExit;
    public IControlFlowEdge PhantomExit { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowJumpStatement(ICSharpStatement statement);
    public virtual IControlFlowEdge get_PhantomExit();
    public virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowLockStatement : CSharpControlFlowStatement {
    private CSharpControlFlowExpression myMonitor;
    private CSharpControlFlowMultiplexor myMonitorMultiplexor;
    private CSharpControlFlowStatement myBody;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowLockStatement(ILockStatement statement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowLoopStatement : CSharpControlFlowStatement {
    protected CSharpControlFlowMultiplexor myEndOfLoopPoint;
    protected CSharpControlFlowLoopStatement(ICSharpStatement statement);
    protected void ResolveBodyExits(ControlFlowElement body, ICSharpControlFlowElement continue);
    protected void ResolveLoopConditionExits(ICSharpControlFlowElement controlFlowCondition, ICSharpControlFlowElement controlFlowBody);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowMultiplexor : ControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private bool <SkipAccessAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExecutesCode>k__BackingField;
    public bool SkipAccessAnalysis { get; public set; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowMultiplexor(ITreeNode referencedElement, bool executesCode);
    [CompilerGeneratedAttribute]
public bool get_SkipAccessAnalysis();
    [CompilerGeneratedAttribute]
public void set_SkipAccessAnalysis(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExecutesCode();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowMultiplexorExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static CSharpControlFlowMultiplexor AppendControlFlowMultiplexor(ControlFlowElement controlFlowElement, List`1<IControlFlowElement> children, ITreeNode element, bool executesCode, BooleanExpression booleanExpression);
    [ExtensionAttribute]
[NotNullAttribute]
public static CSharpControlFlowMultiplexor AppendControlFlowMultiplexor(ControlFlowElement controlFlowElement, List`1<IControlFlowElement> children, CSharpControlFlowMultiplexor multiplexor, BooleanExpression booleanExpression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowMultiplexorWithPhantomExit : CSharpControlFlowMultiplexor {
    [CanBeNullAttribute]
private ControlFlowEdge myPhantomExit;
    public IControlFlowEdge PhantomExit { get; }
    public CSharpControlFlowMultiplexorWithPhantomExit(ITreeNode referencedElement);
    public void SetPhantomExit(ControlFlowEdge phantomExit);
    public virtual IControlFlowEdge get_PhantomExit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowQueryClause : ControlFlowElement {
    [NotNullAttribute]
private IQueryClause myClause;
    [NotNullAttribute]
private List`1<IControlFlowElement> myChildren;
    [NotNullAttribute]
public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowQueryClause(IQueryClause clause, CSharpControlFlowBuilderParams params);
    private void AddExits();
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowQueryPlatform : CSharpControlFlowMultiplexor {
    public CSharpControlFlowQueryPlatform(IQueryClause clause, IQueryParameterPlatform platform);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowReturnStatement : CSharpControlFlowStatement {
    [CanBeNullAttribute]
private CSharpControlFlowExpression myExpression;
    [CanBeNullAttribute]
private CSharpControlFlowMultiplexorWithPhantomExit myPhantomMultiplexor;
    [CanBeNullAttribute]
private Dictionary`2<ControlFlowEdgeCondition, CSharpControlFlowMultiplexorWithPhantomExit> myMultiplexors;
    [NotNullAttribute]
private CSharpControlFlowEdge myPhantomEdge;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public IControlFlowEdge PhantomExit { get; }
    public CSharpControlFlowReturnStatement(IReturnStatement statement, CSharpControlFlowBuilderParams params);
    private static bool ShouldTrackExitConditionsSeparately(ICSharpExpression returnedExpression, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public virtual IControlFlowEdge get_PhantomExit();
    [CompilerGeneratedAttribute]
internal static bool <ShouldTrackExitConditionsSeparately>g__IsInTryBlockWithFinally|5_0(ICSharpExpression returnedExpression);
    [CompilerGeneratedAttribute]
internal static bool <ShouldTrackExitConditionsSeparately>g__HasConditionalAnnotations|5_1(IDeclaredElement declaredElement, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <ShouldTrackExitConditionsSeparately>g__HasSubFlagSet|5_2(FlowAnalysisAnnotations annotation, FlowAnalysisAnnotations compositeFlag);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowSimpleBlockedStatement : CSharpControlFlowStatement {
    private CSharpControlFlowStatement myStatement;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowSimpleBlockedStatement(ICSharpStatement statement, IBlock block, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowSimpleStatement : CSharpControlFlowStatement {
    public CSharpControlFlowSimpleStatement(ICSharpStatement statement);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowStatement : ControlFlowElement {
    [CanBeNullAttribute]
private ICSharpStatement myStatement;
    public ITreeNode SourceElement { get; }
    public ICSharpStatement Statement { get; }
    public bool ExecutesCode { get; }
    protected CSharpControlFlowStatement(ICSharpStatement statement);
    public virtual ITreeNode get_SourceElement();
    public sealed virtual ICSharpStatement get_Statement();
    [NotNullAttribute]
[PureAttribute]
public static CSharpControlFlowStatement Build(ICSharpStatement statement, CSharpControlFlowBuilderParams parameters);
    [NotNullAttribute]
public static List`1<CSharpControlFlowStatement> BuildControlFlowStatementsForStatementsOwner(IStatementsOwner statementsOwner, ControlFlowElement controlFlowStatementsOwner, CSharpControlFlowBuilderParams params);
    [CanBeNullAttribute]
[PureAttribute]
private static Dictionary`2<ILabel, CSharpControlFlowStatement> CollectLabels(IEnumerable`1<CSharpControlFlowStatement> controlFlowStatements, Dictionary`2<ILabel, CSharpControlFlowStatement> labels);
    public virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowStaticInitializationEndMultiplexor : CSharpControlFlowMultiplexor {
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowSwitchCaseLabel : ControlFlowElement {
    [NotNullAttribute]
private ISwitchCaseLabel mySwitchCaseLabel;
    [NotNullAttribute]
public ISwitchCaseLabel Label { get; }
    public ITreeNode SourceElement { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowSwitchCaseLabel(ISwitchCaseLabel switchCaseLabel, CSharpControlFlowBuilderParams params);
    public ISwitchCaseLabel get_Label();
    public virtual ITreeNode get_SourceElement();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowSwitchExpressionArm : ControlFlowElement {
    [CompilerGeneratedAttribute]
private ISwitchExpressionArm <SwitchExpressionArm>k__BackingField;
    public ISwitchExpressionArm SwitchExpressionArm { get; }
    public bool ExecutesCode { get; }
    public ITreeNode SourceElement { get; }
    public CSharpControlFlowSwitchExpressionArm(ISwitchExpressionArm switchExpressionArm);
    [CompilerGeneratedAttribute]
public ISwitchExpressionArm get_SwitchExpressionArm();
    public sealed virtual bool get_ExecutesCode();
    public virtual ITreeNode get_SourceElement();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowSwitchSection : ControlFlowElement {
    [NotNullAttribute]
private ISwitchSection mySwitchSection;
    [NotNullAttribute]
private List`1<CSharpControlFlowStatement> myStatements;
    [NotNullAttribute]
private ImplicitEndOfCaseSectionMultiplexor myImplicitEndOfCaseSection;
    [NotNullAttribute]
public IReadOnlyList`1<CSharpControlFlowStatement> Statements { get; }
    [NotNullAttribute]
public ISwitchSection SwitchSection { get; }
    public ITreeNode SourceElement { get; }
    public bool ExecutesCode { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowSwitchSection(ISwitchSection switchSection, CSharpControlFlowBuilderParams params);
    public IReadOnlyList`1<CSharpControlFlowStatement> get_Statements();
    public ISwitchSection get_SwitchSection();
    public virtual ITreeNode get_SourceElement();
    public sealed virtual bool get_ExecutesCode();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowSwitchStatement : CSharpControlFlowStatement {
    [NotNullAttribute]
private CSharpControlFlowExpression myConditionExpression;
    [NotNullAttribute]
private SwitchDecisionMultiplexor myDecisionMultiplexor;
    [NotNullAttribute]
private SwitchConditionMultiplexor mySwitchConditionMultiplexor;
    [NotNullAttribute]
private OneToSetMap`2<ISwitchCaseLabel, CSharpControlFlowSwitchCaseLabel> mySwitchLabels;
    [NotNullAttribute]
[ItemNotNullAttribute]
private List`1<CSharpControlFlowSwitchSection> mySwitchSections;
    [NotNullAttribute]
private CSharpControlFlowMultiplexor myEndOfSwitchPoint;
    [CanBeNullAttribute]
private DecisionDagControlFlowElement myDecisionDagControlFlowElement;
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private List`1<CSharpControlFlowCondition> myUnreachableGuardExpressions;
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private List`1<CSharpControlFlowErrorPatternElement> myErrorPatternElements;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowSwitchStatement(ISwitchStatement switchStatement, CSharpControlFlowBuilderParams params);
    private void CreateUnreachableLabelElement(ISwitchStatement switchStatement, CSharpControlFlowBuilderParams params, ISwitchCaseLabel switchCaseLabel, DecisionDag decisionDag, CSharpControlFlowSwitchSection controlFlowSwitchSection);
    [NotNullAttribute]
private ControlFlowElement CreateLabelElementFromItsGuard(ICSharpExpression guardExpression, CSharpControlFlowBuilderParams params);
    private void FixUnreachableEdges(ISwitchStatement switchStatement, bool hasDefaultLabels, DecisionDag constantInputDecisionDag);
    private bool ShouldAddUnreachableDefaultEdge(ISwitchStatement switchStatement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    private void ResolveExits(Dictionary`2<ILabel, CSharpControlFlowStatement> gotoLabels, CSharpControlFlowBuilderParams params, ICSharpControlFlowElement endOfSwitchPoint);
    [CanBeNullAttribute]
[PureAttribute]
private static Dictionary`2<ILabel, CSharpControlFlowStatement> CollectLabels(IEnumerable`1<CSharpControlFlowStatement> controlFlowStatements, Dictionary`2<ILabel, CSharpControlFlowStatement> labels);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowThrowStatement : CSharpControlFlowStatement {
    [CanBeNullAttribute]
private CSharpControlFlowExpression myExpression;
    [NotNullAttribute]
private CSharpControlFlowMultiplexorWithPhantomExit myExitMultiplexor;
    [NotNullAttribute]
private CSharpControlFlowEdge myPhantomExit;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public IControlFlowEdge PhantomExit { get; }
    public CSharpControlFlowThrowStatement(IThrowStatement statement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public virtual IControlFlowEdge get_PhantomExit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowTopLevelCode : ControlFlowElement {
    [NotNullAttribute]
private ITopLevelCode myTopLevelCode;
    [NotNullAttribute]
private List`1<CSharpControlFlowStatement> myStatements;
    public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowTopLevelCode(ITopLevelCode topLevelCode, CSharpControlFlowBuilderParams params);
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowTryStatement : CSharpControlFlowStatement {
    [NotNullAttribute]
private CSharpControlFlowMultiplexor myTryStartPoint;
    [NotNullAttribute]
private CSharpControlFlowBlockStatement myTryBlock;
    [NotNullAttribute]
private CSharpControlFlowMultiplexor myTryRegularEndPoint;
    [NotNullAttribute]
private ThrowEndPoint myTryUnexpectedThrowEndPoint;
    [NotNullAttribute]
private List`1<IControlFlowElement> myCatches;
    [NotNullAttribute]
private List`1<MayThrowInsideCatchMultiplexor> myMayThrowInsideCatchMultiplexors;
    [NotNullAttribute]
private List`1<IControlFlowElement> myExceptionFilters;
    [NotNullAttribute]
private List`1<IControlFlowElement> myAllFinallyBlocks;
    [NotNullAttribute]
private List`1<IControlFlowElement> myAllFinallyEndPoints;
    [NotNullAttribute]
private List`1<IControlFlowElement> myErrors;
    public IReadOnlyList`1<IControlFlowElement> FinallyBlocks { get; }
    [NotNullAttribute]
public CSharpControlFlowBlockStatement TryBlock { get; }
    [NotNullAttribute]
public IList`1<MayThrowInsideCatchMultiplexor> ThrowInsideCatchMultiplexors { get; }
    public IList`1<IControlFlowElement> CatchBlocks { get; }
    public IList`1<IControlFlowElement> ExceptionFilters { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowTryStatement(ITryStatement statement, CSharpControlFlowBuilderParams parameters);
    public IReadOnlyList`1<IControlFlowElement> get_FinallyBlocks();
    private void SetupTryBlockExits(ITryStatement statement, IBlock finallyBlock, CSharpControlFlowBuilderParams parameters);
    [CanBeNullAttribute]
private static IDeclaredType GetExceptionType(ICSharpControlFlowEdge edge, CSharpControlFlowBuilderParams parameters);
    private bool HasGenericCatch(ITryStatement statement);
    public CSharpControlFlowBlockStatement get_TryBlock();
    public IList`1<MayThrowInsideCatchMultiplexor> get_ThrowInsideCatchMultiplexors();
    public IList`1<IControlFlowElement> get_CatchBlocks();
    public IList`1<IControlFlowElement> get_ExceptionFilters();
    private void PassThroughFinally(ICSharpControlFlowEdge edge, IBlock finallyBlock, CSharpControlFlowBuilderParams parameters);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowUncheckedStatement : CSharpControlFlowSimpleBlockedStatement {
    public CSharpControlFlowUncheckedStatement(IUncheckedStatement statement, CSharpControlFlowBuilderParams params);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowUnsafeStatement : CSharpControlFlowSimpleBlockedStatement {
    public CSharpControlFlowUnsafeStatement(IUnsafeCodeUnsafeStatement statement, CSharpControlFlowBuilderParams params);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowUsingStatement : CSharpControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowUsingStatement(IUsingStatement statement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowVariableBindingElement : ControlFlowElement {
    [CompilerGeneratedAttribute]
private WhenDecisionDagNode <WhenDagNode>k__BackingField;
    [CompilerGeneratedAttribute]
private DecisionDagConclusion <DagConclusion>k__BackingField;
    [CanBeNullAttribute]
public WhenDecisionDagNode WhenDagNode { get; }
    public DecisionDagConclusion DagConclusion { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<PatternBinding> Bindings { get; }
    public bool ExecutesCode { get; }
    public CSharpControlFlowVariableBindingElement(WhenDecisionDagNode whenDecisionDagNode);
    public CSharpControlFlowVariableBindingElement(DecisionDagConclusion dagConclusion);
    [CompilerGeneratedAttribute]
public WhenDecisionDagNode get_WhenDagNode();
    [CompilerGeneratedAttribute]
public DecisionDagConclusion get_DagConclusion();
    public IReadOnlyList`1<PatternBinding> get_Bindings();
    public sealed virtual bool get_ExecutesCode();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowVariableValue : Enum {
    public byte value__;
    public static CSharpControlFlowVariableValue UNKNOWN;
    public static CSharpControlFlowVariableValue NULL;
    public static CSharpControlFlowVariableValue SOFT_NULL;
    public static CSharpControlFlowVariableValue NOT_NULL;
    public static CSharpControlFlowVariableValue TRUE;
    public static CSharpControlFlowVariableValue FALSE;
    public static CSharpControlFlowVariableValue CONTAINER;
    public static CSharpControlFlowVariableValue CONTAINER_WITH_UNKNOWN_ELEMENT;
    public static CSharpControlFlowVariableValue CONTAINER_WITH_NOT_NULL_ELEMENT;
    public static CSharpControlFlowVariableValue CONTAINER_WITH_NULL_ELEMENT;
    public static CSharpControlFlowVariableValue WEAK_MIXIN;
    public static CSharpControlFlowVariableValue WEAK_UNKNOWN;
    public static CSharpControlFlowVariableValue WEAK_NOT_NULL;
    public static CSharpControlFlowVariableValue WEAK_CANBENULL;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowVariableValueExt : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsWeak(CSharpControlFlowVariableValue value);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowVariableValue ToControlFlowVariableValueCollectionState(CSharpControlFlowNullReferenceState collectionState);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowVariableValue GetContainerElementInfoFlags(CSharpControlFlowVariableValue value);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowVariableValue GetValueWithoutContainerElementInfoFlags(CSharpControlFlowVariableValue value);
    [ExtensionAttribute]
public static void Deconstruct(CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue& valueWithoutContainerFlags, CSharpControlFlowVariableValue& containerElementInfoFlags);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowVariableValue GetItemStateFromContainerItemInfo(CSharpControlFlowVariableValue containerItemInfo);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowVariableValue ToNullValue(CSharpControlFlowVariableValue value);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowVariableValue ToNullValue(CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue containerElementInfoFlags);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowVariableValue ToNotNullValue(CSharpControlFlowVariableValue value);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpControlFlowVariableValue ToNotNullValue(CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue containerElementInfoFlags);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsStrictNull(CSharpControlFlowVariableValue value);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsStrictNull(Nullable`1<CSharpControlFlowVariableValue> value);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowWhileStatement : CSharpControlFlowLoopStatement {
    private CSharpControlFlowCondition myCondition;
    private CSharpControlFlowStatement myStatement;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public CSharpControlFlowWhileStatement(IWhileStatement statement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpControlFlowYieldStatement : CSharpControlFlowStatement {
    [CanBeNullAttribute]
private IControlFlowElement[] myChildren;
    private CSharpControlFlowEdge myPhantomEdge;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public IControlFlowEdge PhantomExit { get; }
    public CSharpControlFlowYieldStatement(IYieldStatement yieldStatement, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public virtual IControlFlowEdge get_PhantomExit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.CSharpImplicitArrowReturnElement : ControlFlowElement {
    [CanBeNullAttribute]
private ICSharpExpression myExpression;
    [CanBeNullAttribute]
private CSharpControlFlowExpression myReturnExpression;
    [CanBeNullAttribute]
private CSharpControlFlowMultiplexor myExitMultiplexor;
    [CanBeNullAttribute]
private CSharpControlFlowEdge myPhantomEdge;
    public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public IControlFlowEdge PhantomExit { get; }
    public bool ExecutesCode { get; }
    public CSharpImplicitArrowReturnElement(ICSharpExpression returnValueExpression, CSharpControlFlowBuilderParams parameters);
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public virtual IControlFlowEdge get_PhantomExit();
    public sealed virtual bool get_ExecutesCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.DecisionDagControlFlowElement : ControlFlowElement {
    [NotNullAttribute]
[ItemNotNullAttribute]
private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public bool ExecutesCode { get; }
    public DecisionDagControlFlowElement(DecisionDag decisionDag, IReadOnlyDictionary`2<DecisionDagConclusion, ICSharpControlFlowElement> dagConclusionTargets, Func`3<ICSharpExpression, CSharpControlFlowBuilderParams, ControlFlowElement> guardPredecessorFactory, CSharpControlFlowMultiplexor endOfSwitchPoint, CSharpControlFlowBuilderParams params);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public sealed virtual bool get_ExecutesCode();
    private void BuildDecisionDagControlFlow(ControlFlowElement dagEntryMultiplexor, DecisionDag decisionDag, IReadOnlyDictionary`2<DecisionDagConclusion, ICSharpControlFlowElement> dagConclusionTargets, Func`3<ICSharpExpression, CSharpControlFlowBuilderParams, ControlFlowElement> guardPredecessorFactory, Dictionary`2<DecisionDagNode, ICSharpControlFlowElement> dagElements, CSharpControlFlowBuilderParams params, ICSharpControlFlowElement endOfSwitchPoint);
    private void TrySetExitTargetOrPropagate(ICSharpControlFlowEdge exitEdge, ICSharpControlFlowElement target);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ElementAccessMultiplexor : CSharpControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private IElementAccessExpression <ElementAccessExpression>k__BackingField;
    public IElementAccessExpression ElementAccessExpression { get; }
    public ElementAccessMultiplexor(IElementAccessExpression elementAccessExpression);
    [CompilerGeneratedAttribute]
public IElementAccessExpression get_ElementAccessExpression();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfElementEqualityComparerById`1 : object {
    [NotNullAttribute]
public static EfElementEqualityComparerById`1<T> Instance;
    private static EfElementEqualityComparerById`1();
    public sealed virtual bool Equals(EntityFrameworkElementConfigReader`1<T> x, EntityFrameworkElementConfigReader`1<T> y);
    public sealed virtual int GetHashCode(EntityFrameworkElementConfigReader`1<T> obj);
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfElementValidity : Enum {
    public int value__;
    public static EfElementValidity Valid;
    public static EfElementValidity ValidSelf;
    public static EfElementValidity Invalid;
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfEntityKind : Enum {
    public int value__;
    public static EfEntityKind Normal;
    public static EfEntityKind SharedType;
    public static EfEntityKind PropertyBag;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfModelSource : Enum {
    public int value__;
    public static EfModelSource Invalid;
    public static EfModelSource FluentApi;
    public static EfModelSource PreConventions;
    public static EfModelSource Classes;
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfModelUtils : object {
    [PureAttribute]
[CanBeNullAttribute]
internal static IClrTypeName GetClrNameFromType(IType type);
    [PureAttribute]
[CanBeNullAttribute]
internal static IType GetTypeFromInvocationExpressionSubstitution(IInvocationExpression invocationExpression, int typeParameterIndex);
    internal static void AddModelSource(IDictionary`2<T, EfModelSource> collection, T item, EfModelSource newSource);
    internal static void ResetModelSource(IDictionary`2<T, EfModelSource> collection, T item, EfModelSource newSource);
    internal static int CompareModelSources(EfModelSource firstSource, EfModelSource secondSource);
    [CanBeNullAttribute]
[PureAttribute]
internal static IMethodDeclaration GetMethodImplementationWithSingleBuilderParameter(IEnumerable`1<ITypeElement> typeElementsHierarchy, Predicate`1<IMethod> methodsFilter, IParameter& builderParameter);
    [ContractAnnotationAttribute("=> true; => false, property: null")]
internal static bool TryGetPropertyFromExpression(ILambdaExpression lambdaExpression, IProperty& property);
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfResolveResult : Enum {
    public int value__;
    public static EfResolveResult NoChanges;
    public static EfResolveResult TypeUnresolved;
    public static EfResolveResult TypeResolved;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedAnonymousType : EfSerializedTypeWithCachedPresentation`1<IAnonymousType> {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResolved>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, ValueTuple`2<IEfSerializedType, bool>> <TypeDescriptors>k__BackingField;
    public string ShortName { get; protected set; }
    public bool IsResolved { get; protected set; }
    public EfSerializedTypeKind Kind { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public IDictionary`2<string, ValueTuple`2<IEfSerializedType, bool>> TypeDescriptors { get; private set; }
    [CompilerGeneratedAttribute]
public virtual string get_ShortName();
    [CompilerGeneratedAttribute]
protected virtual void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsResolved();
    [CompilerGeneratedAttribute]
protected virtual void set_IsResolved(bool value);
    public virtual EfSerializedTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ValueTuple`2<IEfSerializedType, bool>> get_TypeDescriptors();
    [CompilerGeneratedAttribute]
private void set_TypeDescriptors(IDictionary`2<string, ValueTuple`2<IEfSerializedType, bool>> value);
    [NotNullAttribute]
public static EfSerializedAnonymousType Create(IAnonymousType anonymousType);
    public static void Marshal(UnsafeWriter writer, EfSerializedAnonymousType value);
    public static EfSerializedAnonymousType Unmarshal(UnsafeReader reader);
    public virtual IType CreateType(IPsiModule psiModule);
    protected virtual string GetPresentableString(bool isShortPresentation);
    protected virtual void Initialize(IAnonymousType anonymousType);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedArrayType : EfSerializedTypeWithCachedPresentation`1<IArrayType> {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResolved>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private IEfSerializedType <ElementType>k__BackingField;
    public string ShortName { get; protected set; }
    public bool IsResolved { get; protected set; }
    public EfSerializedTypeKind Kind { get; }
    public int Rank { get; private set; }
    [CanBeNullAttribute]
public IEfSerializedType ElementType { get; private set; }
    [CompilerGeneratedAttribute]
public virtual string get_ShortName();
    [CompilerGeneratedAttribute]
protected virtual void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsResolved();
    [CompilerGeneratedAttribute]
protected virtual void set_IsResolved(bool value);
    public virtual EfSerializedTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public int get_Rank();
    [CompilerGeneratedAttribute]
private void set_Rank(int value);
    [CompilerGeneratedAttribute]
public IEfSerializedType get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(IEfSerializedType value);
    [NotNullAttribute]
public static EfSerializedArrayType Create(IArrayType arrayType);
    public static void Marshal(UnsafeWriter writer, EfSerializedArrayType value);
    public static EfSerializedArrayType Unmarshal(UnsafeReader reader);
    public virtual IType CreateType(IPsiModule psiModule);
    protected virtual string GetPresentableString(bool isShortPresentation);
    protected virtual void Initialize(IArrayType arrayType);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedDeclaredType : EfSerializedTypeWithCachedPresentation`1<IDeclaredType> {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResolved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTypeParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullableValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamicType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnknownType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEfSerializedType> <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IEfSerializedType> <TupleComponents>k__BackingField;
    public string ShortName { get; protected set; }
    public bool IsResolved { get; protected set; }
    public EfSerializedTypeKind Kind { get; }
    public bool IsTypeParameterType { get; private set; }
    public bool IsNullableValueType { get; private set; }
    public bool IsDynamicType { get; private set; }
    public bool IsUnknownType { get; private set; }
    public bool IsTupleType { get; }
    public bool HasSubstitution { get; }
    [NotNullAttribute]
public string ClrTypeName { get; private set; }
    [NotNullAttribute]
public IDictionary`2<string, IEfSerializedType> Substitution { get; private set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<IEfSerializedType> TupleComponents { get; private set; }
    [CompilerGeneratedAttribute]
public virtual string get_ShortName();
    [CompilerGeneratedAttribute]
protected virtual void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsResolved();
    [CompilerGeneratedAttribute]
protected virtual void set_IsResolved(bool value);
    public virtual EfSerializedTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public bool get_IsTypeParameterType();
    [CompilerGeneratedAttribute]
private void set_IsTypeParameterType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNullableValueType();
    [CompilerGeneratedAttribute]
private void set_IsNullableValueType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDynamicType();
    [CompilerGeneratedAttribute]
private void set_IsDynamicType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUnknownType();
    [CompilerGeneratedAttribute]
private void set_IsUnknownType(bool value);
    public bool get_IsTupleType();
    public bool get_HasSubstitution();
    [CompilerGeneratedAttribute]
public string get_ClrTypeName();
    [CompilerGeneratedAttribute]
private void set_ClrTypeName(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IEfSerializedType> get_Substitution();
    [CompilerGeneratedAttribute]
private void set_Substitution(IDictionary`2<string, IEfSerializedType> value);
    [CompilerGeneratedAttribute]
public IList`1<IEfSerializedType> get_TupleComponents();
    [CompilerGeneratedAttribute]
private void set_TupleComponents(IList`1<IEfSerializedType> value);
    [NotNullAttribute]
public static EfSerializedDeclaredType Create(IDeclaredType declaredType);
    public static void Marshal(UnsafeWriter writer, EfSerializedDeclaredType value);
    public static EfSerializedDeclaredType Unmarshal(UnsafeReader reader);
    [NotNullAttribute]
public string ToUnderlyingTypeString();
    public virtual IType CreateType(IPsiModule psiModule);
    protected virtual void Initialize(IDeclaredType declaredType);
    protected virtual string GetPresentableString(bool isShortPresentation);
    private bool ProcessTypeDecorations(IType type);
    private void ProcessSubstitution(ISubstitution substitution);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedFunctionPointerType : EfSerializedTypeWithCachedPresentation`1<IFunctionPointerType> {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResolved>k__BackingField;
    [CompilerGeneratedAttribute]
private IEfSerializedType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <ReturnKind>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<ValueTuple`2<IEfSerializedType, ParameterKind>> <Parameters>k__BackingField;
    public string ShortName { get; protected set; }
    public bool IsResolved { get; protected set; }
    public EfSerializedTypeKind Kind { get; }
    [CanBeNullAttribute]
public IEfSerializedType ReturnType { get; private set; }
    public ReferenceKind ReturnKind { get; private set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public IList`1<ValueTuple`2<IEfSerializedType, ParameterKind>> Parameters { get; private set; }
    [CompilerGeneratedAttribute]
public virtual string get_ShortName();
    [CompilerGeneratedAttribute]
protected virtual void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsResolved();
    [CompilerGeneratedAttribute]
protected virtual void set_IsResolved(bool value);
    public virtual EfSerializedTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public IEfSerializedType get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(IEfSerializedType value);
    [CompilerGeneratedAttribute]
public ReferenceKind get_ReturnKind();
    [CompilerGeneratedAttribute]
private void set_ReturnKind(ReferenceKind value);
    [CompilerGeneratedAttribute]
public IList`1<ValueTuple`2<IEfSerializedType, ParameterKind>> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IList`1<ValueTuple`2<IEfSerializedType, ParameterKind>> value);
    [NotNullAttribute]
public static EfSerializedFunctionPointerType Create(IFunctionPointerType type);
    public static void Marshal(UnsafeWriter writer, EfSerializedFunctionPointerType value);
    public static EfSerializedFunctionPointerType Unmarshal(UnsafeReader reader);
    public virtual IType CreateType(IPsiModule psiModule);
    protected virtual string GetPresentableString(bool isShortPresentation);
    protected virtual void Initialize(IFunctionPointerType functionPointerType);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedMultitype : EfSerializedTypeWithCachedPresentation`1<IMultitype> {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResolved>k__BackingField;
    public string ShortName { get; protected set; }
    public bool IsResolved { get; protected set; }
    public EfSerializedTypeKind Kind { get; }
    [CompilerGeneratedAttribute]
public virtual string get_ShortName();
    [CompilerGeneratedAttribute]
protected virtual void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsResolved();
    [CompilerGeneratedAttribute]
protected virtual void set_IsResolved(bool value);
    public virtual EfSerializedTypeKind get_Kind();
    [NotNullAttribute]
public static EfSerializedMultitype Create(IMultitype multitype);
    public static void Marshal(UnsafeWriter writer, EfSerializedMultitype value);
    public static EfSerializedMultitype Unmarshal(UnsafeReader reader);
    public virtual IType CreateType(IPsiModule psiModule);
    protected virtual string GetPresentableString(bool isShortPresentation);
    protected virtual void Initialize(IMultitype type);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedPointerType : EfSerializedTypeWithCachedPresentation`1<IPointerType> {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResolved>k__BackingField;
    [CompilerGeneratedAttribute]
private IEfSerializedType <ElementType>k__BackingField;
    public string ShortName { get; protected set; }
    public bool IsResolved { get; protected set; }
    public EfSerializedTypeKind Kind { get; }
    [CanBeNullAttribute]
public IEfSerializedType ElementType { get; private set; }
    [CompilerGeneratedAttribute]
public virtual string get_ShortName();
    [CompilerGeneratedAttribute]
protected virtual void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsResolved();
    [CompilerGeneratedAttribute]
protected virtual void set_IsResolved(bool value);
    public virtual EfSerializedTypeKind get_Kind();
    [CompilerGeneratedAttribute]
public IEfSerializedType get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(IEfSerializedType value);
    [NotNullAttribute]
public static EfSerializedPointerType Create(IPointerType pointerType);
    public static void Marshal(UnsafeWriter writer, EfSerializedPointerType value);
    public static EfSerializedPointerType Unmarshal(UnsafeReader reader);
    public virtual IType CreateType(IPsiModule psiModule);
    protected virtual string GetPresentableString(bool isShortPresentation);
    protected virtual void Initialize(IPointerType type);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedSyntheticType : object {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    public string ShortName { get; }
    public bool HasValidTypeElement { get; }
    public bool IsResolved { get; }
    public bool IsNullableAnnotated { get; }
    public EfSerializedTypeKind Kind { get; }
    public EfSerializedSyntheticType(string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public bool get_HasValidTypeElement();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsNullableAnnotated();
    public sealed virtual EfSerializedTypeKind get_Kind();
    public sealed virtual IType CreateType(IPsiModule psiModule);
    public sealed virtual string ToShortString();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedType : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetEntityNameStringWithoutSubstitution(IEfSerializedType serializedType);
    [NotNullAttribute]
[PureAttribute]
public static EfSerializedSyntheticType GetSyntheticFromRawString(string typeName);
    [CanBeNullAttribute]
[PureAttribute]
public static IEfSerializedType GetSerializedType(IType type);
    [CanBeNullAttribute]
[PureAttribute]
public static IEfSerializedType GetSerializedTypeIfResolved(IType type);
    [ExtensionAttribute]
public static bool MatchesClrTypeName(IEfSerializedType serializedType, IClrTypeName clrTypeName, bool acceptNullableValueUnderlyingTypes);
    public static void MarshalBase(UnsafeWriter writer, IEfSerializedType value);
    [PureAttribute]
public static ValueTuple`3<string, bool, bool> UnmarshalBase(UnsafeReader reader);
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedTypeKind : Enum {
    public int value__;
    public static EfSerializedTypeKind Any;
    public static EfSerializedTypeKind DeclaredType;
    public static EfSerializedTypeKind Multitype;
    public static EfSerializedTypeKind ArrayType;
    public static EfSerializedTypeKind PointerType;
    public static EfSerializedTypeKind AnonymousType;
    public static EfSerializedTypeKind FunctionPointerType;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedTypeStringEqualityComparer : object {
    [NotNullAttribute]
public static EfSerializedTypeStringEqualityComparer Instance;
    private static EfSerializedTypeStringEqualityComparer();
    public sealed virtual bool Equals(IEfSerializedType x, IEfSerializedType y);
    public sealed virtual int GetHashCode(IEfSerializedType obj);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EfSerializedTypeWithCachedPresentation`1 : object {
    [CanBeNullAttribute]
private string myCachedPresentation;
    [CompilerGeneratedAttribute]
private bool <IsNullableAnnotated>k__BackingField;
    public string ShortName { get; protected set; }
    public bool IsResolved { get; protected set; }
    public bool IsNullableAnnotated { get; protected set; }
    public EfSerializedTypeKind Kind { get; }
    public abstract virtual string get_ShortName();
    protected abstract virtual void set_ShortName(string value);
    public abstract virtual bool get_IsResolved();
    protected abstract virtual void set_IsResolved(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNullableAnnotated();
    [CompilerGeneratedAttribute]
protected void set_IsNullableAnnotated(bool value);
    public abstract virtual EfSerializedTypeKind get_Kind();
    public virtual string ToString();
    public abstract virtual IType CreateType(IPsiModule psiModule);
    [NotNullAttribute]
protected abstract virtual string GetPresentableString(bool isShortPresentation);
    protected abstract virtual void Initialize(T type);
    public sealed virtual string ToShortString();
    protected void ProcessNullableAnnotation(T type);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkCanonicalFunctionsUtils : object {
    [NotNullAttribute]
private static ClrTypeName ourEfStaticClassClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourQueryableExtensionsClrName;
    [NotNullAttribute]
private static ClrTypeName ourQueryableExtensionsClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourDbFunctionsExtensionsClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourSqlServerDbFunctionsExtensionsClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourNpgsqlDbFunctionsExtensionsClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourMySqlDbFunctionsExtensionsClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourMySqlJsonDbFunctionsExtensionsClrNameCore;
    [NotNullAttribute]
private static ISet`1<ClrTypeName> ourDotNetFrameworkSpatialDataClassesClrNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<ClrTypeName> ourDbFunctionsExtensionTypes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<ClrTypeName> ourServerSideSinceNetCore5DbFunctionsExtensionTypes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourMySqlJsonDbFunctionsNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourCanonicalSimpleClrMethodNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourCanonicalSpatialClrMethodNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourCanonicalQueryableProjectionClrMethodsShortNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourCanonicalOrderingClrMethodsShortNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourCanonicalEqualityComparingClrMethodsShortNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourCanonicalAggregateClrMethodShortNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourCanonicalSimpleQueryableClrMethodShortNames;
    private static EntityFrameworkCanonicalFunctionsUtils();
    public static bool IsServerAndClientSideMethod(IMethod method, EntityFrameworkMajorVersion entityFrameworkMajorVersion);
    public static bool IsPredefinedDbFunctionMethod(IMethod method);
    public static bool IsUserDefinedDbFunction(IMethod method, DbFunctionAnnotationProviderBase dbFunctionAnnotationProvider, Func`2<IEnumerable`1<ITypeElement>, ISet`1<string>> getDbFunctionsFromDbContexts, IEnumerable`1<ITypeElement> dbContexts);
    public static bool MethodIsSupportedByLinqToEntities(IInvocationExpression invocationExpression, IMethod method, PredefinedType predefinedType, bool isInsideQueryExpression);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkClosureContextFactory : EntityFrameworkContextFactory {
    [NotNullAttribute]
private EntityFrameworkContext myInitialContext;
    public EntityFrameworkContext InitialContext { get; }
    public EntityFrameworkClosureContextFactory(EntityFrameworkContext initialContext);
    public virtual EntityFrameworkContext get_InitialContext();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkConfigReaderBase : object {
    private static int MaxAnalysisDepth;
    [CompilerGeneratedAttribute]
private EntityFrameworkVersion <EntityFrameworkVersion>k__BackingField;
    public EntityFrameworkVersion EntityFrameworkVersion { get; }
    [NotNullAttribute]
public IDictionary`2<ITypeOwner, ConstantValue> TypeOwnersConstantValues { get; }
    protected EntityFrameworkConfigReaderBase(EntityFrameworkVersion entityFrameworkVersion);
    [CompilerGeneratedAttribute]
public sealed virtual EntityFrameworkVersion get_EntityFrameworkVersion();
    public abstract virtual IDictionary`2<ITypeOwner, ConstantValue> get_TypeOwnersConstantValues();
    public void ReadConfigMethod(ICSharpDeclaration declaration, IType[] builderTypes);
    public void ReadConfigExpression(ICSharpExpression builderExpression);
    protected virtual void ReadConfigMethodPart(ITreeNode treeNode, ValueTuple`2<ISet`1<ICSharpDeclaration>, int> processedDeclarations, IEnumerable`1<IType> builderTypes);
    protected virtual void ProcessInnerMethodWithoutBuilder(IInvocationExpression invocationExpression, IMethod method);
    protected abstract virtual bool ProcessMethod(string methodName, IInvocationExpression invocationExpression);
    [NotNullAttribute]
[PureAttribute]
protected virtual ConstantValue TryGetConstantValueFromTypeMembersAndLocals(ITypeOwner typeOwner);
    protected void ReadConfigMethod(ICSharpDeclaration declaration, ValueTuple`2<ISet`1<ICSharpDeclaration>, int> processedDeclarations, IType[] builderTypes);
    protected void ReadConfigMethodAssignmentExpression(IAssignmentExpression assignmentExpression);
    protected void ProcessInnerMethodOfSameKind(IInvocationExpression invocationExpression, ValueTuple`2<ISet`1<ICSharpDeclaration>, int> processedDeclarations, IEnumerable`1<IType> builderTypes);
    protected bool ReadConfigMethodInvocationExpression(IInvocationExpression invocationExpression, IEnumerable`1<IType> builderTypes);
    [NotNullAttribute]
[PureAttribute]
protected ConstantValue GetConstantValueFromExpression(ICSharpExpression expression);
    [PureAttribute]
[ContractAnnotationAttribute("=> true; => false, stringValue: null")]
protected bool TryGetNonEmptyStringFromExpression(ICSharpExpression expression, String& stringValue);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkConfigReaderWithChildren`4 : EntityFrameworkElementConfigReader`1<TId> {
    [CompilerGeneratedAttribute]
private bool <HasUnresolvedChildren>k__BackingField;
    [NotNullAttribute]
public EntityFrameworkModelId ModelId { get; }
    public bool HasUnresolvedChildren { get; public set; }
    protected EntityFrameworkConfigReaderWithChildren`4(TId id, EntityFrameworkVersion entityFrameworkVersion, EfElementValidity validity, bool hasUnresolvedChildren);
    public abstract virtual EntityFrameworkModelId get_ModelId();
    [CompilerGeneratedAttribute]
public bool get_HasUnresolvedChildren();
    [CompilerGeneratedAttribute]
public void set_HasUnresolvedChildren(bool value);
    public void InvalidateChild(EntityFrameworkModelCache cache, T child, IDictionary`2<T, EfModelSource> collection);
    [NotNullAttribute]
public TChild GetCreatedOrUpdatedChildFromExpression(TChildId childId, TChildParams childParams, ICSharpExpression expression);
    [NotNullAttribute]
public TChild GetCreatedOrUpdatedChildFromMethod(TChildId childId, TChildParams childParams, ICSharpDeclaration declaration, IType builderType);
    [NotNullAttribute]
public TChild GetNewOrExistingChild(TChildId childId, TChildParams childParams);
    [CanBeNullAttribute]
protected abstract virtual TChild GetExistingChild(TChildId childElementId);
    [NotNullAttribute]
protected abstract virtual TChild GetReaderForNewChild(TChildParams childParams);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkConfigurationReader : EntityFrameworkElementConfigReader`1<EntityFrameworkModelId> {
    [NotNullAttribute]
private static PreConventionData ourEmptyPreConventionData;
    [NotNullAttribute]
private IDictionary`2<string, PreConventionData> myPreConventionDataForTypeNames;
    [NotNullAttribute]
private IDictionary`2<IType, PreConventionData> myPreConventionDataFromBaseTypesCache;
    [CompilerGeneratedAttribute]
private bool <IsLazyLoadingProxiesEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryTrackingBehavior <QueryTrackingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProxyCreationInitiallyEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LazyLoadingInitiallyEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<ITypeOwner, ConstantValue> <TypeOwnersConstantValues>k__BackingField;
    public bool IsLazyLoadingProxiesEnabled { get; private set; }
    public QueryTrackingBehavior QueryTrackingBehavior { get; private set; }
    public bool ProxyCreationInitiallyEnabled { get; private set; }
    public bool LazyLoadingInitiallyEnabled { get; private set; }
    public IDictionary`2<ITypeOwner, ConstantValue> TypeOwnersConstantValues { get; }
    protected ISet`1<IPsiSourceFile> FileSet { get; }
    public EntityFrameworkConfigurationReader(EntityFrameworkModelId dbContextId, EntityFrameworkVersion entityFrameworkVersion, EfElementValidity validity);
    private EntityFrameworkConfigurationReader(EntityFrameworkModelId dbContextId, EntityFrameworkVersion entityFrameworkVersion, bool isLazyLoadingProxiesEnabled, QueryTrackingBehavior queryTrackingBehavior, bool proxyCreationInitiallyEnabled, bool lazyLoadingInitiallyEnabled, IDictionary`2<string, PreConventionData> preConventionDataForTypeNames, EfElementValidity validity);
    private static EntityFrameworkConfigurationReader();
    [CompilerGeneratedAttribute]
public bool get_IsLazyLoadingProxiesEnabled();
    [CompilerGeneratedAttribute]
private void set_IsLazyLoadingProxiesEnabled(bool value);
    [CompilerGeneratedAttribute]
public QueryTrackingBehavior get_QueryTrackingBehavior();
    [CompilerGeneratedAttribute]
private void set_QueryTrackingBehavior(QueryTrackingBehavior value);
    [CompilerGeneratedAttribute]
public bool get_ProxyCreationInitiallyEnabled();
    [CompilerGeneratedAttribute]
private void set_ProxyCreationInitiallyEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_LazyLoadingInitiallyEnabled();
    [CompilerGeneratedAttribute]
private void set_LazyLoadingInitiallyEnabled(bool value);
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<ITypeOwner, ConstantValue> get_TypeOwnersConstantValues();
    protected virtual ISet`1<IPsiSourceFile> get_FileSet();
    [CanBeNullAttribute]
public PreConventionData GetMergedPreConventionDataForType(IEfSerializedType serializedType, IDeclaredType declaredType);
    [CanBeNullAttribute]
public PreConventionData GetMergedPreConventionDataFromSuperTypes(IDeclaredType type);
    internal void CheckDbContextConfigurationSetters(IAssignmentExpression assignmentExpression);
    internal void ReadPotentialConstants(ITypeElement typeElement);
    internal void ReadPreConventions(ICSharpDeclaration configureConventionsMethodDeclaration, IType builderType);
    internal void ClearTemporaryCaches();
    protected virtual void ReadConfigMethodPart(ITreeNode treeNode, ValueTuple`2<ISet`1<ICSharpDeclaration>, int> processedDeclarations, IEnumerable`1<IType> builderTypes);
    protected virtual bool ProcessMethod(string methodName, IInvocationExpression invocationExpression);
    [CanBeNullAttribute]
private PreConventionData GetPreConventionDataForTypeName(string typeName);
    [NotNullAttribute]
private PreConventionData GetOrAddPreConventionDataForSpecificTypeName(string typeName);
    [CanBeNullAttribute]
private PreConventionData GetOrAddPreConventionDataForConcreteType(IType type);
    [NotNullAttribute]
private IList`1<ValueTuple`2<PreConventionData, Source>> GetOrAddPreConventionDataForType(IType type);
    [CompilerGeneratedAttribute]
private void <GetMergedPreConventionDataForType>g__UpdatePreConventionData|26_0(string typeName, <>c__DisplayClass26_0& );
    [CompilerGeneratedAttribute]
private void <ReadPotentialConstants>g__ReadInitializer|29_0(IInitializerOwnerDeclaration declaration, ITypeOwner typeOwner);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContext : object {
    private static int ComplexityThreshold;
    private static int MaxRelationsChainDepth;
    [CompilerGeneratedAttribute]
private InspectionData <InspectorData>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionState <CurrentExpressionState>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<LocalContext> <LocalContexts>k__BackingField;
    [NotNullAttribute]
public InspectionData InspectorData { get; }
    internal ExpressionState CurrentExpressionState { get; internal set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
private ISet`1<LocalContext> LocalContexts { get; private set; }
    public EntityFrameworkContext(InspectionData inspectorData);
    private EntityFrameworkContext(IEnumerable`1<LocalContext> localContexts, InspectionData inspectorData);
    private EntityFrameworkContext(EntityFrameworkContext context, bool isDeepClone);
    [CompilerGeneratedAttribute]
public InspectionData get_InspectorData();
    [CompilerGeneratedAttribute]
internal ExpressionState get_CurrentExpressionState();
    [CompilerGeneratedAttribute]
internal void set_CurrentExpressionState(ExpressionState value);
    [CompilerGeneratedAttribute]
private ISet`1<LocalContext> get_LocalContexts();
    [CompilerGeneratedAttribute]
private void set_LocalContexts(ISet`1<LocalContext> value);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
public static EntityFrameworkContext MergeContexts(IEnumerable`1<EntityFrameworkContext> contexts, InspectionData inspectionData);
    [NotNullAttribute]
public EntityFrameworkContext DeepClone();
    [NotNullAttribute]
public EntityFrameworkContext ShallowClone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [PureAttribute]
public string Dump();
    public void UpdateStateFromContext(EntityFrameworkContext source, bool updateCurrentExpressionState);
    public void ResetCurrentChainData();
    public void ResetVariable(ITypeOwner typeOwner, IReferenceExpression referenceExpression);
    [CanBeNullAttribute]
public Variable AssignChainToVariable(ITypeOwner typeOwner, IReferenceExpression referenceExpression);
    [NotNullAttribute]
public Variable UpdateVariableWithParentReferenceExpression(Variable variable, IReferenceExpression referenceExpression);
    [NotNullAttribute]
public Variable UpdateVariableWithParentTypeOwner(Variable variable, ITypeOwner parentTypeOwner);
    public void SetRelationFromVariableWithoutIssues(ITypeOwner referencedTypeOwner, IReferenceExpression referenceExpression);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<ITypeElement> GetDbContextsForCurrentServerSideChains();
    public void AnalyzeDbContextSetMethod(IInvocationExpression invocationExpression, IType qualifierExpressionType, Variable qualifierVariable);
    public bool AnalyzeReferenceExpression(IReferenceExpression referenceExpression, Variable variable, IType qualifierExpressionType, Variable qualifierVariable, Func`2<NavigationQueryData, NavigationQueryResult> getNavigation, EntityFrameworkQueryInspectorKind inspectorKind, bool isQueryParameter);
    public void AnalyzeTypeMemberWriteOnly(ITypeMember typeMember, ITreeNode currentNode, EntityFrameworkVersion entityFrameworkVersion, IDictionary`2<ITreeNode, OwnerDbContextInfo> lazyLoadingProperties, IDictionary`2<ITreeNode, OwnerDbContextInfo> queryTrackingBehaviorProperties);
    public bool FindInclusionInInvocationExpression(IInvocationExpression invocationExpression, bool shouldProcessNavigationEntry, Func`2<NavigationQueryData, NavigationQueryResult> getNavigation);
    public void AddLazyLoadingOverride(OwnerDbContextInfo dbContextInfo, bool boolValue);
    public void AddQueryTrackingOverride(OwnerDbContextInfo dbContextInfo, QueryTrackingBehavior queryTrackingBehavior);
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public IList`1<RelationsChain> CompileCurrentChains();
    private bool Equals(EntityFrameworkContext other);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkContextFactory : object {
    [CompilerGeneratedAttribute]
private InspectionData <InspectorData>k__BackingField;
    [NotNullAttribute]
public InspectionData InspectorData { get; }
    [NotNullAttribute]
public EntityFrameworkContext InitialContext { get; }
    public EntityFrameworkContextFactory(InspectionData inspectorData);
    [CompilerGeneratedAttribute]
public InspectionData get_InspectorData();
    public virtual EntityFrameworkContext get_InitialContext();
    [NotNullAttribute]
public sealed virtual EntityFrameworkContext CloneContext(EntityFrameworkContext context);
    [NotNullAttribute]
public sealed virtual EntityFrameworkContext Merge(IList`1<EntityFrameworkContext> contexts);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkDependencyFactory : object {
    public static Dependency CreateModelElementDependency(string fileName, EntityFrameworkTypeElementId dbContextId);
    public static Dependency CreateDbContextUsageDependency(string fileName, EntityFrameworkTypeElementId dbContextId);
    private static int GetHashForFileAndDbContext(string fileName, EntityFrameworkTypeElementId dbContextId, int hashMultiplier);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementBasicParameters : object {
    [CompilerGeneratedAttribute]
private EntityFrameworkVersion <EntityFrameworkVersion>k__BackingField;
    public EntityFrameworkVersion EntityFrameworkVersion { get; }
    public EntityFrameworkElementBasicParameters(EntityFrameworkVersion entityFrameworkVersion);
    [CompilerGeneratedAttribute]
public EntityFrameworkVersion get_EntityFrameworkVersion();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementConfigReader`1 : EntityFrameworkConfigReaderBase {
    [CompilerGeneratedAttribute]
private TId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private EfElementValidity <Validity>k__BackingField;
    [NotNullAttribute]
public TId Id { get; }
    public EfElementValidity Validity { get; public set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IPsiSourceFile> Files { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
protected ISet`1<IPsiSourceFile> FileSet { get; }
    protected EntityFrameworkElementConfigReader`1(TId id, EntityFrameworkVersion entityFrameworkVersion, EfElementValidity validity);
    [CompilerGeneratedAttribute]
public TId get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual EfElementValidity get_Validity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Validity(EfElementValidity value);
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_Files();
    protected abstract virtual ISet`1<IPsiSourceFile> get_FileSet();
    public sealed virtual void RemoveFileConnection(IPsiSourceFile sourceFile);
    public sealed virtual void AssignNewSetOfFiles(IEnumerable`1<IPsiSourceFile> files);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementId : object {
    protected EntityFrameworkTypeElementId myModelType;
    [CanBeNullAttribute]
protected IEfSerializedType myEntityType;
    protected EntityFrameworkElementId(EntityFrameworkTypeElementId modelType, IEfSerializedType entityType);
    protected bool Equals(EntityFrameworkElementId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementIdMarshaller : object {
    [NotNullAttribute]
public static EntityFrameworkElementIdMarshaller Instance;
    private static EntityFrameworkElementIdMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, EntityFrameworkElementId value);
    public sealed virtual EntityFrameworkElementId Unmarshal(UnsafeReader reader);
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementMarshaller : object {
    public static void Marshal(UnsafeWriter writer, EntityFrameworkElementConfigReader`1<TId> value, Action`2<UnsafeWriter, TId> marshalId, IPersistentIndexManager persistentIndexManager);
    public static void MarshalWithBaseElements(UnsafeWriter writer, EntityFrameworkInheritableConfigReaderWithChildren`4<TId, TChild, TChildParams, TChildId> value, Action`2<UnsafeWriter, TId> marshalId, IPersistentIndexManager persistentIndexManager);
    [PureAttribute]
public static ValueTuple`4<TId, EntityFrameworkVersion, ICollection`1<IPsiSourceFile>, EfElementValidity> Unmarshal(UnsafeReader reader, Func`2<UnsafeReader, TId> unmarshalId, IPersistentIndexManager persistentIndexManager);
    [PureAttribute]
public static ValueTuple`7<TId, EntityFrameworkVersion, ICollection`1<IPsiSourceFile>, EfElementValidity, IDictionary`2<TId, EfModelSource>, bool, bool> UnmarshalWithBaseElements(UnsafeReader reader, Func`2<UnsafeReader, TId> unmarshalId, IPersistentIndexManager persistentIndexManager);
    public static void MarshalTypeIdModelSourceDictionary(UnsafeWriter writer, IDictionary`2<IEfSerializedType, EfModelSource> dictionary);
    public static void MarshalStringModelSourceDictionary(UnsafeWriter writer, IDictionary`2<string, EfModelSource> dictionary);
    [NotNullAttribute]
[PureAttribute]
public static IDictionary`2<IEfSerializedType, EfModelSource> UnmarshalTypeIdModelSourceDictionary(UnsafeReader reader);
    [NotNullAttribute]
[PureAttribute]
public static IDictionary`2<string, EfModelSource> UnmarshalStringModelSourceDictionary(UnsafeReader reader);
    public static void MarshalCollection(IEnumerable`1<T> collection, UnsafeWriter writer, Action`2<UnsafeWriter, T> marshal);
    public static void MarshalDictionary(IDictionary`2<TKey, TValue> dictionary, UnsafeWriter writer, Action`2<UnsafeWriter, TKey> marshalKey, Action`2<UnsafeWriter, TValue> marshalValue);
    [PureAttribute]
[NotNullAttribute]
public static IList`1<T> UnmarshalCollection(UnsafeReader reader, Func`2<UnsafeReader, T> unmarshal);
    [PureAttribute]
public static IDictionary`2<TKey, TValue> UnmarshalDictionary(UnsafeReader reader, Func`2<UnsafeReader, TKey> unmarshalKey, Func`2<UnsafeReader, TValue> unmarshalValue);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkElementWithFilesParameters : EntityFrameworkElementBasicParameters {
    [CompilerGeneratedAttribute]
private ISet`1<IPsiSourceFile> <Files>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public ISet`1<IPsiSourceFile> Files { get; }
    public EntityFrameworkElementWithFilesParameters(EntityFrameworkVersion entityFrameworkVersion, ISet`1<IPsiSourceFile> files);
    [CompilerGeneratedAttribute]
public ISet`1<IPsiSourceFile> get_Files();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkEntityConfigReader : EntityFrameworkInheritableConfigReaderWithChildren`4<EntityFrameworkEntityId, EntityFrameworkPropertyConfigReader, EntityFrameworkPropertySpecificParameters, string> {
    [NotNullAttribute]
private static IDictionary`2<EntityFrameworkVersion, IDictionary`2<string, Func`3<EntityFrameworkEntityConfigReader, IInvocationExpression, bool>>> ourMethodProcessors;
    [NotNullAttribute]
private EntityFrameworkModelCache myCache;
    [CanBeNullAttribute]
private EntityFrameworkModelConfigReader myModel;
    [CanBeNullAttribute]
private EntityFrameworkConfigurationReader myConfiguration;
    [NotNullAttribute]
private ISet`1<ValueTuple`2<string, string>> myLocalExplicitImplementations;
    [CompilerGeneratedAttribute]
private EfEntityKind <EntityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InjectsLazyLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, EfModelSource> <LocalOwnedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, EntityFrameworkPropertyConfigReader> <LocalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<NavigationParameters, EfModelSource> <LocalNavigations>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, EfModelSource> <LocalIgnoredProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityFrameworkModelId <ModelId>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<IPsiSourceFile> <FileSet>k__BackingField;
    public EfEntityKind EntityKind { get; }
    public bool InjectsLazyLoader { get; private set; }
    public string ShortName { get; }
    [NotNullAttribute]
public IDictionary`2<string, EfModelSource> LocalOwnedProperties { get; }
    [NotNullAttribute]
public IDictionary`2<string, EntityFrameworkPropertyConfigReader> LocalProperties { get; }
    [NotNullAttribute]
public IDictionary`2<NavigationParameters, EfModelSource> LocalNavigations { get; }
    [NotNullAttribute]
public IDictionary`2<string, EfModelSource> LocalIgnoredProperties { get; }
    public EntityFrameworkModelId ModelId { get; }
    public IDictionary`2<ITypeOwner, ConstantValue> TypeOwnersConstantValues { get; }
    protected ISet`1<IPsiSourceFile> FileSet { get; }
    private EntityFrameworkModelConfigReader Model { get; }
    private EntityFrameworkConfigurationReader Configuration { get; }
    public EntityFrameworkEntityConfigReader(string shortName, EfEntityKind entityKind, EntityFrameworkEntityId id, EntityFrameworkVersion entityFrameworkVersion, EntityFrameworkModelCache entityFrameworkModelCache, ISet`1<IPsiSourceFile> files, EfElementValidity validity, IDictionary`2<EntityFrameworkEntityId, EfModelSource> baseEntities, bool hasUnresolvedChildren, bool hasUnresolvedSuperTypes);
    public EntityFrameworkEntityConfigReader(string shortName, EntityFrameworkEntityId id, EntityFrameworkVersion entityFrameworkVersion, bool injectsLazyLoader, EfEntityKind entityKind, IDictionary`2<string, EntityFrameworkPropertyConfigReader> localProperties, IDictionary`2<NavigationParameters, EfModelSource> localOneToOneNavigations, IDictionary`2<string, EfModelSource> localIgnoredProperties, IDictionary`2<string, EfModelSource> localOwnedProperties, IDictionary`2<EntityFrameworkEntityId, EfModelSource> baseEntities, IEnumerable`1<ValueTuple`2<string, string>> localExplicitImplementations, EntityFrameworkModelCache entityFrameworkModelCache, ISet`1<IPsiSourceFile> files, EfElementValidity validity, bool hasUnresolvedChildren, bool hasUnresolvedSuperTypes);
    private static EntityFrameworkEntityConfigReader();
    [CompilerGeneratedAttribute]
public EfEntityKind get_EntityKind();
    [CompilerGeneratedAttribute]
public bool get_InjectsLazyLoader();
    [CompilerGeneratedAttribute]
private void set_InjectsLazyLoader(bool value);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, EfModelSource> get_LocalOwnedProperties();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, EntityFrameworkPropertyConfigReader> get_LocalProperties();
    [CompilerGeneratedAttribute]
public IDictionary`2<NavigationParameters, EfModelSource> get_LocalNavigations();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, EfModelSource> get_LocalIgnoredProperties();
    [CompilerGeneratedAttribute]
public virtual EntityFrameworkModelId get_ModelId();
    public virtual IDictionary`2<ITypeOwner, ConstantValue> get_TypeOwnersConstantValues();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<IPsiSourceFile> get_FileSet();
    private EntityFrameworkModelConfigReader get_Model();
    private EntityFrameworkConfigurationReader get_Configuration();
    protected virtual IList`1<IDeclaredType> CollectSuperTypes();
    protected virtual EntityFrameworkEntityId CreateIdFromType(IType type);
    public bool PropertyIsExplicitImplementation(string shortName, string interfaceFullName);
    [NotNullAttribute]
public IEnumerable`1<ValueTuple`2<NavigationParameters, EfModelSource>> GetAllNavigations(bool getOnlyValid);
    public Nullable`1<NavigationParameters> FindNavigationByShortName(string shortName);
    [NotNullAttribute]
public IEnumerable`1<ValueTuple`2<string, EfModelSource>> GetAllOwnedProperties();
    [CanBeNullAttribute]
public string FindOwnedPropertyByShortName(string shortName);
    [NotNullAttribute]
public IEnumerable`1<ValueTuple`2<string, EntityFrameworkPropertyConfigReader>> GetAllProperties();
    [CanBeNullAttribute]
public EntityFrameworkPropertyConfigReader FindPropertyByShortName(string shortName);
    [NotNullAttribute]
public IEnumerable`1<ValueTuple`2<string, EfModelSource>> GetAllIgnoredProperties();
    [CanBeNullAttribute]
public string FindIgnoredPropertyByShortName(string shortName);
    [PureAttribute]
public bool ModelValidationApplicableForLocalProperty(string shortName, EntityFrameworkPropertyConfigReader& property);
    [PureAttribute]
public bool QualifiesAsEntityInParentModel();
    internal void InvalidateNavigationsForSourceEntities();
    internal bool TryProcessClass(bool processExistingEntities, bool isInitialDbSetProcessing, ICollection`1& additionalEntityTypes, PreConventionData& preConventionDataFromSuperTypes);
    internal void ProcessClassProperties(bool processExistingEntities, ICollection`1<IType> additionalEntityTypes, ISet`1<string> filterForPropertyNames);
    internal void UpdateChildrenResolve(EntityFrameworkModelCache cache);
    protected virtual EntityFrameworkPropertyConfigReader GetExistingChild(string propertyName);
    protected virtual EntityFrameworkPropertyConfigReader GetReaderForNewChild(EntityFrameworkPropertySpecificParameters childParams);
    private static bool ProcessIgnore(EntityFrameworkEntityConfigReader entityConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessHasBaseType(EntityFrameworkEntityConfigReader entityConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessProperty(EntityFrameworkEntityConfigReader entityConfigReader, IInvocationExpression invocationExpression);
    private static void AddProperty(EntityFrameworkEntityConfigReader entityConfigReader, string propertyShortName, IEfSerializedType propertySerializedType, ICSharpExpression expression);
    private static void AddProperty(EntityFrameworkEntityConfigReader entityConfigReader, string propertyShortName, IType propertyType, ICSharpExpression expression);
    private static void AddNavigation(EntityFrameworkEntityConfigReader entityConfigReader, bool toManyRelationship, IInvocationExpression invocationExpression);
    private static void UpdateCollectionsWithNavigation(EntityFrameworkEntityConfigReader entityConfigReader, string navigationName, IType navigationalPropertyType, bool toManyRelationship, IInvocationExpression invocationExpression);
    private static void UpdateCollectionsWithNavigation(EntityFrameworkEntityConfigReader entityConfigReader, string navigationName, IEfSerializedType navigationalSerializedType, bool toManyRelationship, IInvocationExpression invocationExpression);
    private static bool ProcessHasOne(EntityFrameworkEntityConfigReader entityConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessHasMany(EntityFrameworkEntityConfigReader entityConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessNavigation(EntityFrameworkEntityConfigReader entityConfigReader, IInvocationExpression invocationExpression);
    private static bool AddOwnership(EntityFrameworkEntityConfigReader entityConfigReader, IDictionary`2<string, EfModelSource> ownershipCollection, bool toManyRelationship, IInvocationExpression invocationExpression);
    private static void UpdateCollectionsWithOwnership(EntityFrameworkEntityConfigReader entityConfigReader, string navigationName, IType propertyType, IDictionary`2<string, EfModelSource> ownershipCollection, bool toManyRelationship, ICSharpExpression invocationExpression);
    private static bool ProcessOwnsOne(EntityFrameworkEntityConfigReader entityConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessOwnsMany(EntityFrameworkEntityConfigReader entityConfigReader, IInvocationExpression invocationExpression);
    private static bool ShouldProcessProperty(IProperty property);
    protected virtual bool ProcessMethod(string methodName, IInvocationExpression invocationExpression);
    [CanBeNullAttribute]
private IEfSerializedType GetSerializedType(IType type);
    private bool MaybeUsesLazyLoader(IProperty property);
    private void AddPropertyFromFluentApi(EntityFrameworkPropertyConfigReader property);
    [PureAttribute]
private static ValueTuple`2<IType, bool> GetPropertyUnderlyingType(IType propertyType);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkEntityConfigReader/<GetAllProperties>d__81`2")]
[NotNullAttribute]
private IEnumerable`1<ValueTuple`2<TKey, TValue>> GetAllProperties(Func`2<EntityFrameworkEntityConfigReader, IEnumerable`1<KeyValuePair`2<TKey, TValue>>> getProperty, Func`4<EntityFrameworkEntityConfigReader, TKey, TValue, bool> shouldAddProperty, bool getOnlyValid);
    [NotNullAttribute]
[PureAttribute]
private EntityFrameworkPropertySpecificParameters GetParametersForNewPropertyFromFluentApi(string shortName, IEfSerializedType serializedType, IType type);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkEntityId : EntityFrameworkElementId {
    public EntityFrameworkTypeElementId ModelType { get; }
    [NotNullAttribute]
public IEfSerializedType EntityType { get; }
    public EntityFrameworkEntityId(EntityFrameworkTypeElementId modelType, IEfSerializedType entityType);
    public EntityFrameworkTypeElementId get_ModelType();
    public IEfSerializedType get_EntityType();
    public virtual string ToString();
    [NotNullAttribute]
public string ToStringFull();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkEntityIdMarshaller : object {
    [NotNullAttribute]
public static EntityFrameworkEntityIdMarshaller Instance;
    private static EntityFrameworkEntityIdMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, EntityFrameworkEntityId value);
    public sealed virtual EntityFrameworkEntityId Unmarshal(UnsafeReader reader);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkEntitySpecificParameters : EntityFrameworkElementWithFilesParameters {
    [CompilerGeneratedAttribute]
private EntityFrameworkEntityId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private EfEntityKind <EntityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [NotNullAttribute]
public EntityFrameworkEntityId Id { get; }
    [NotNullAttribute]
public string ShortName { get; }
    public EfEntityKind EntityKind { get; }
    [CanBeNullAttribute]
public IType Type { get; }
    public EntityFrameworkEntitySpecificParameters(string shortName, EfEntityKind entityKind, EntityFrameworkEntityId id, IType type, EntityFrameworkVersion entityFrameworkVersion, ISet`1<IPsiSourceFile> files);
    [CompilerGeneratedAttribute]
public EntityFrameworkEntityId get_Id();
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public EfEntityKind get_EntityKind();
    [CompilerGeneratedAttribute]
public IType get_Type();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkInheritableConfigReaderWithChildren`4 : EntityFrameworkConfigReaderWithChildren`4<TId, TChild, TChildParams, TChildId> {
    [CompilerGeneratedAttribute]
private IDeclaredType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<TId, EfModelSource> <BaseElements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnresolvedSuperTypes>k__BackingField;
    [CanBeNullAttribute]
public IDeclaredType Type { get; private set; }
    [CanBeNullAttribute]
public ITypeElement TypeElement { get; private set; }
    public IDictionary`2<TId, EfModelSource> BaseElements { get; private set; }
    public bool HasUnresolvedSuperTypes { get; public set; }
    protected EntityFrameworkInheritableConfigReaderWithChildren`4(TId id, EntityFrameworkVersion entityFrameworkVersion, EfElementValidity validity, bool hasUnresolvedChildren, bool hasUnresolvedSuperTypes, IDictionary`2<TId, EfModelSource> baseElements);
    [CompilerGeneratedAttribute]
public IDeclaredType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(IDeclaredType value);
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
private void set_TypeElement(ITypeElement value);
    [CompilerGeneratedAttribute]
public IDictionary`2<TId, EfModelSource> get_BaseElements();
    [CompilerGeneratedAttribute]
private void set_BaseElements(IDictionary`2<TId, EfModelSource> value);
    [CompilerGeneratedAttribute]
public bool get_HasUnresolvedSuperTypes();
    [CompilerGeneratedAttribute]
public void set_HasUnresolvedSuperTypes(bool value);
    [ContractAnnotationAttribute("=> true, type: notnull, typeElement: notnull; => false, type: null, typeElement: null")]
public bool TryGetTypeIfValid(IDeclaredType& type, ITypeElement& typeElement);
    public EfResolveResult ResolveType(ISymbolCache symbolCache, IPsiModule psiModule);
    public bool CheckAndUpdateSuperTypes(EntityFrameworkModelCache cache, IList`1& filteredSuperTypes);
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
protected abstract virtual IList`1<IDeclaredType> CollectSuperTypes();
    [CanBeNullAttribute]
[PureAttribute]
protected abstract virtual TId CreateIdFromType(IType type);
    protected virtual bool ShouldProcessSuperType(IDeclaredType declaredType);
    protected bool TypeIsValid();
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkInspectorUtils : object {
    [NotNullAttribute]
private static IDictionary`2<EntityFrameworkVersion, IDictionary`2<string, EntityFrameworkQueryMethodKind>> ourMethodsInclusionKinds;
    private static EntityFrameworkInspectorUtils();
    public static bool TryGetLoadedRelations(IInvocationExpression expression, IResolveResult resolveResult, EntityFrameworkVersion entityFrameworkVersion, IType primarySourceType, string propertyName, EntityFrameworkModelCache modelCache, ITypeElement dbContext, RelationsChain chain, IList`1& result, Nullable`1<QueryTrackingBehavior> assignmentOverriddenQueryTrackingBehavior, Func`2<NavigationQueryData, NavigationQueryResult> getNavigation);
    [CanBeNullAttribute]
[PureAttribute]
public static string GetPropertyNameFromLambdaExpression(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkInspectorUtils/<ExpressionChainDeconstructionFromInnermost>d__4")]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IReferenceExpression> ExpressionChainDeconstructionFromInnermost(ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IReferenceExpression> ReverseExpressionChainDeconstructionFromInnermost(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkInspectorUtils/<ReverseExpressionChainDeconstructionFromOutermost>d__6")]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IReferenceExpression> ReverseExpressionChainDeconstructionFromOutermost(ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IReferenceExpression> ExpressionChainDeconstructionFromOutermost(ICSharpExpression expression);
    [PureAttribute]
public static bool SourceTypeIsSubtypeOfDestinationType(IType sourceType, IType destinationType, ITreeNode context);
    [PureAttribute]
public static bool TypesAreInCommonHierarchy(IType firstType, IType secondType, ITreeNode context, bool tryGetUnderlyingTypes);
    [CanBeNullAttribute]
[PureAttribute]
public static string ExtractNameFromStringArgumentExpression(ICSharpExpression argumentExpression);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<LoadedRelation> GetLoadedRelationsFromExpression(ICSharpExpression expression, EntityFrameworkVersion entityFrameworkVersion, ITypeElement dbContextTypeElement, EntityFrameworkModelCache modelCache);
    [PureAttribute]
public static ExpressionState GetNewExpressionStateFromTypeOwner(ITypeOwner typeOwner, ExpressionState previousState);
    [PureAttribute]
public static ExpressionState GetNewExpressionStateFromInvocationExpression(IInvocationExpression invocationExpression, EntityFrameworkVersion entityFrameworkVersion, ExpressionState previousState, EntityFrameworkModelCache modelCache, ITypeElement dbContextTypeElement, PredefinedType predefinedType, RelationsChain currentChain, Boolean& containsInclude, Boolean& reassignsAnchorExpression, IList`1& loadedRelations, Func`2<NavigationQueryData, NavigationQueryResult> getNavigation, Nullable`1<QueryTrackingBehavior> overriddenQueryTrackingBehavior);
    [PureAttribute]
public static ExpressionState GetNewExpressionStateFromInvocationExpression(IInvocationExpression invocationExpression, IMethod method, string propertyName, PredefinedType predefinedType, Boolean& reassignsAnchorExpression, RelationsChain currentChain);
    private static bool TryGetLoadedRelationsFromInclusion(IInvocationExpression expression, IInvocationExpression highlightedExpression, EntityFrameworkVersion entityFrameworkVersion, EntityFrameworkQueryMethodKind queryMethodKind, bool inclusionSupportsProjection, Nullable`1<QueryTrackingBehavior> overriddenQueryTrackingBehavior, EntityFrameworkModelCache modelCache, ITypeElement dbContext, Func`2<NavigationQueryData, NavigationQueryResult> getNavigation, IList`1& loadedRelations);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddToDictIfNotNull|1_0(IEnumerable`1<string> names, EntityFrameworkQueryMethodKind methodKind, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddSingleToDictIfNotNull|1_1(string name, EntityFrameworkQueryMethodKind methodKind, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
internal static IList`1<LoadedRelation> <TryGetLoadedRelationsFromInclusion>g__GetLoadedRelations|15_0(ICSharpExpression argumentExpression, IType previousExpressionType, <>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static void <TryGetLoadedRelationsFromInclusion>g__AnalyzeExpression|15_1(IReferenceExpression innerExpression, <>c__DisplayClass15_0& , <>c__DisplayClass15_1& );
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkMajorVersion : object {
    public static EntityFrameworkMajorVersion Invalid;
    [CompilerGeneratedAttribute]
private EntityFrameworkVersion <FrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MajorVersion>k__BackingField;
    public EntityFrameworkVersion FrameworkVersion { get; }
    public int MajorVersion { get; }
    public EntityFrameworkMajorVersion(EntityFrameworkVersion entityFrameworkVersion, int majorVersionNumber);
    private static EntityFrameworkMajorVersion();
    [CompilerGeneratedAttribute]
public EntityFrameworkVersion get_FrameworkVersion();
    [CompilerGeneratedAttribute]
public int get_MajorVersion();
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelCache : object {
    [NotNullAttribute]
private string myLoggerMessage;
    [NotNullAttribute]
private ReaderWriterLockSlim myCacheLock;
    [NotNullAttribute]
private IPersistentIndexManager myPersistentIndexManager;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<EntityFrameworkModelId, EntityFrameworkModelConfigReader> myModelsCache;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<EntityFrameworkTypeElementId, EntityFrameworkConfigurationReader> myConfigurationsCache;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<string, EntityFrameworkEntityConfigReader[]> myEntitiesCache;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<IPsiSourceFile, ISet`1<EntityFrameworkElementId>> myFileToCachedElementsMap;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<IPsiSourceFile, ISet`1<EntityFrameworkElementId>> myFileToElementUsagesMap;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<EntityFrameworkEntityId, ISet`1<NavigationParameters>> myDestinationToNavigationsMap;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<EntityFrameworkElementId, ISet`1<EntityFrameworkElementId>> myBaseElementsToDescendantsMap;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<EntityFrameworkModelId, ISet`1<EntityFrameworkElementId>> myElementsWithUnresolvedChildren;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<EntityFrameworkModelId, ISet`1<EntityFrameworkElementId>> myElementsWithUnresolvedSuperTypes;
    private int myModificationTimestamp;
    [CompilerGeneratedAttribute]
private ISimpleSignal <ModelChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolCache <SymbolCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeAnnotationsCache <CodeAnnotationsCache>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<EntityFrameworkTypeElementId, ValueTuple`2<IEnumerable`1<IPsiSourceFile>, int>> <DbContextRelatedFilesWithTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClearOnLoad>k__BackingField;
    public ISimpleSignal ModelChanged { get; }
    [NotNullAttribute]
public ISymbolCache SymbolCache { get; }
    [NotNullAttribute]
public CodeAnnotationsCache CodeAnnotationsCache { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private IDictionary`2<EntityFrameworkTypeElementId, ValueTuple`2<IEnumerable`1<IPsiSourceFile>, int>> DbContextRelatedFilesWithTimestamp { get; }
    public string Version { get; }
    public bool ClearOnLoad { get; public set; }
    public string PersistentId { get; }
    public bool HasDirtyFiles { get; }
    public EntityFrameworkModelCache(IPersistentIndexManager persistentIndexManager, ISymbolCache symbolCache, CodeAnnotationsCache codeAnnotationsCache, ILogger logger, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public ISimpleSignal get_ModelChanged();
    [CompilerGeneratedAttribute]
public ISymbolCache get_SymbolCache();
    [CompilerGeneratedAttribute]
public CodeAnnotationsCache get_CodeAnnotationsCache();
    [CompilerGeneratedAttribute]
private IDictionary`2<EntityFrameworkTypeElementId, ValueTuple`2<IEnumerable`1<IPsiSourceFile>, int>> get_DbContextRelatedFilesWithTimestamp();
    [PureAttribute]
internal bool TryGetModel(EntityFrameworkModelId id, EntityFrameworkModelConfigReader& result);
    internal void AddEntity(EntityFrameworkEntityConfigReader newEntity);
    [PureAttribute]
internal bool TryGetEntity(EntityFrameworkEntityId entityId, EntityFrameworkEntityConfigReader& result);
    internal bool RemoveEntity(EntityFrameworkEntityId entityId);
    internal void AddNavigationByDestination(NavigationParameters navigation);
    internal void RemoveNavigationByDestination(NavigationParameters navigation);
    [PureAttribute]
internal bool TryGetNavigationsByDestination(EntityFrameworkEntityId destinationId, ISet`1& result);
    internal void AddDescendantToBaseElement(EntityFrameworkElementId baseElementId, EntityFrameworkElementId descendantId);
    [PureAttribute]
internal bool TryGetDescendantsByBaseElements(EntityFrameworkElementId baseElementId, ISet`1& result);
    internal void AddElementWithUnresolvedChildren(EntityFrameworkModelId modelId, EntityFrameworkElementId elementId);
    internal void AddElementWithUnresolvedSuperTypes(EntityFrameworkModelId modelId, EntityFrameworkElementId elementId);
    internal void RemoveElementWithUnresolvedChildren(EntityFrameworkModelId modelId, EntityFrameworkElementId element);
    internal void RemoveElementWithUnresolvedSuperTypes(EntityFrameworkModelId modelId, EntityFrameworkElementId element);
    [PureAttribute]
internal bool TryGetConfiguration(EntityFrameworkTypeElementId id, EntityFrameworkConfigurationReader& result);
    [CanBeNullAttribute]
public ITypeElement AnalyzePotentialDbContext(ITypeElement typeElement, ITypeElement baseDbContextTypeElement, EntityFrameworkVersion entityFrameworkVersion, IPsiSourceFile psiSourceFile, DependencyStore dependencyStore, ISet`1<ITypeElement> dbContextsCache);
    public bool EnsureModelUpToDate(ITypeElement dbContext, EntityFrameworkVersion entityFrameworkVersion, EntityFrameworkModelId dbContextId);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IPsiSourceFile> GetAllDbContextRelatedFiles(EntityFrameworkModelId dbContextId);
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public IEnumerable`1<IPsiSourceFile> GetFilesWithDbContextUsages(string dbContextClrTypeName);
    [PureAttribute]
public bool TryGetCachedElementsFromFile(IPsiSourceFile psiSourceFile, OneToListMap`2& cachedDeclarations);
    [CanBeNullAttribute]
public string GetMatchingDbSetName(IType containingType, IType innerType, ITypeElement dbContext, EntityFrameworkVersion entityFrameworkVersion, bool ensureModelUpToDate);
    public NavigationQueryResult GetMatchingNavigation(NavigationQueryData navigationQueryData, bool ensureModelUpToDate);
    [NotNullAttribute]
public IList`1<ValueTuple`2<ITypeElement, ISet`1<string>>> GetDbContextsDbFunctions(IEnumerable`1<ITypeElement> dbContexts, EntityFrameworkVersion entityFrameworkVersion, bool ensureModelUpToDate);
    public QueryTrackingBehavior GetDefaultQueryTrackingBehavior(ITypeElement dbContext, EntityFrameworkVersion entityFrameworkVersion, bool ensureModelUpToDate);
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ClearOnLoad();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClearOnLoad(bool value);
    public sealed virtual string get_PersistentId();
    public sealed virtual object Load(IProgressIndicator progress, bool enablePersistence);
    public sealed virtual void MergeLoaded(object data);
    private void Clear();
    public sealed virtual void Save(IProgressIndicator progress, bool enablePersistence);
    public sealed virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public sealed virtual bool get_HasDirtyFiles();
    public sealed virtual bool UpToDate(IPsiSourceFile sourceFile);
    private static bool IsApplicable(IPsiSourceFile sourceFile);
    public sealed virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public sealed virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    public sealed virtual void Drop(IPsiSourceFile sourceFile);
    public sealed virtual void OnPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType type);
    public sealed virtual void OnDocumentChange(IPsiSourceFile sourceFile, ProjectFileDocumentCopyChange change);
    public sealed virtual void SyncUpdate(bool underTransaction);
    public sealed virtual void Dump(TextWriter writer, IPsiSourceFile sourceFile);
    internal void TrackFilesWithCachedElement(IEnumerable`1<IPsiSourceFile> files, EntityFrameworkElementId cachedElementId);
    private static void AddItemToOneToSetMap(TKey key, TValue value, IDictionary`2<TKey, ISet`1<TValue>> map);
    private static void RemoveItemFromOneToSetMap(TKey key, TValue value, IDictionary`2<TKey, ISet`1<TValue>> map);
    [NotNullAttribute]
private static IUnsafeMarshaller`1<ISet`1<T>> CreateSetMarshaller(IUnsafeMarshaller`1<T> elementMarshaller);
    [CanBeNullAttribute]
private EntityFrameworkModelConfigReader BuildAll(ITypeElement dbContextTypeElement, EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
private EntityFrameworkConfigurationReader BuildConfiguration(ITypeElement dbContext, EntityFrameworkModelId modelId, EntityFrameworkVersion entityFrameworkVersion, IList`1<ITypeElement> dbContextSuperTypes);
    [PureAttribute]
private bool TryGetCachedElement(EntityFrameworkElementId id, IEntityFrameworkCacheableElement& result);
    private Nullable`1<bool> CheckModelValidity(EntityFrameworkModelConfigReader model);
    private void SaveModel(EntityFrameworkModelConfigReader model);
    private void TryInvalidateCachedElement(IEntityFrameworkCacheableElement cacheableElement);
    private void TryInvalidateCachedElement(EntityFrameworkElementId id);
    private void InvalidateModel(EntityFrameworkModelConfigReader model);
    private void InvalidateEntity(EntityFrameworkEntityConfigReader entity);
    private void InvalidateDescendants(EntityFrameworkElementId cacheableElementId);
    private bool TryRemoveCachedElement(EntityFrameworkElementId id, bool isRecursiveCall);
    public void DumpContextsStructures(TextWriter writer);
    [NotNullAttribute]
public IList`1<ValueTuple`2<EntityFrameworkModelConfigReader, EntityFrameworkEntityConfigReader>> GetMatchingModelsAndEntities(ITypeElement entityTypeElement);
    public TResult ExecuteLockSafeExecutable(LockSafeExecutable`1<TResult> executable);
    [CompilerGeneratedAttribute]
private bool <EnsureModelUpToDate>g__TryResolveEntityTypeElement|42_0(EntityFrameworkEntityConfigReader entity, IPsiModule psiModule);
    [CompilerGeneratedAttribute]
private void <TryRemoveCachedElement>g__RemoveRelatedElementData|88_0(EntityFrameworkElementId cacheableElementId, EntityFrameworkModelId modelId, IEnumerable`1<IPsiSourceFile> files);
    [CompilerGeneratedAttribute]
internal static string <DumpContextsStructures>g__GetTab|89_0(<>c__DisplayClass89_0& );
    [CompilerGeneratedAttribute]
internal static string <DumpContextsStructures>g__GetTypePresentation|89_1(string typeName);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelConfigReader : EntityFrameworkInheritableConfigReaderWithChildren`4<EntityFrameworkModelId, EntityFrameworkEntityConfigReader, EntityFrameworkEntitySpecificParameters, IEfSerializedType> {
    [NotNullAttribute]
private static IDictionary`2<EntityFrameworkVersion, IDictionary`2<string, Func`3<EntityFrameworkModelConfigReader, IInvocationExpression, bool>>> ourMethodProcessors;
    [NotNullAttribute]
private EntityFrameworkModelCache myCache;
    [CanBeNullAttribute]
private EntityFrameworkConfigurationReader myConfiguration;
    private PsiModulePtr myPsiModulePtr;
    [NotNullAttribute]
private ISet`1<IEfSerializedType> myExplicitlyDeclaredEntityIDs;
    [CompilerGeneratedAttribute]
private int <ModificationTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IEfSerializedType, EfModelSource> <LocalEntityIDs>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IEfSerializedType, EfModelSource> <LocalSharedTypeEntityIDs>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IEfSerializedType, EfModelSource> <LocalIgnoredEntityIDs>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IEfSerializedType, EfModelSource> <LocalOwnedEntityIDs>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <DbFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<EntityFrameworkEntityConfigReader, IType> <DiscoverableThroughFluentApiEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToSetMap`2<EntityFrameworkEntityConfigReader, string> <DiscoverableThroughFluentApiProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<IPsiSourceFile> <FileSet>k__BackingField;
    public EntityFrameworkModelId ModelId { get; }
    public int ModificationTimestamp { get; public set; }
    public IPsiModule PsiModule { get; }
    [NotNullAttribute]
public IDictionary`2<IEfSerializedType, EfModelSource> LocalEntityIDs { get; }
    [NotNullAttribute]
public IDictionary`2<IEfSerializedType, EfModelSource> LocalSharedTypeEntityIDs { get; }
    [NotNullAttribute]
public IDictionary`2<IEfSerializedType, EfModelSource> LocalIgnoredEntityIDs { get; }
    [NotNullAttribute]
public IDictionary`2<IEfSerializedType, EfModelSource> LocalOwnedEntityIDs { get; }
    [NotNullAttribute]
public ISet`1<string> DbFunctions { get; }
    public IDictionary`2<ITypeOwner, ConstantValue> TypeOwnersConstantValues { get; }
    [CanBeNullAttribute]
internal IDictionary`2<EntityFrameworkEntityConfigReader, IType> DiscoverableThroughFluentApiEntities { get; private set; }
    [CanBeNullAttribute]
internal OneToSetMap`2<EntityFrameworkEntityConfigReader, string> DiscoverableThroughFluentApiProperties { get; private set; }
    protected ISet`1<IPsiSourceFile> FileSet { get; }
    private EntityFrameworkConfigurationReader Configuration { get; }
    public EntityFrameworkModelConfigReader(EntityFrameworkModelId dbContextId, EntityFrameworkModelCache cache, ISet`1<IPsiSourceFile> files, EntityFrameworkVersion entityFrameworkVersion, PsiModulePtr psiModulePtr, EfElementValidity validity, IDictionary`2<EntityFrameworkModelId, EfModelSource> baseElements, bool hasUnresolvedChildren, bool hasUnresolvedSuperTypes);
    private EntityFrameworkModelConfigReader(EntityFrameworkModelId dbContextId, EntityFrameworkModelCache cache, IDictionary`2<IEfSerializedType, EfModelSource> entityIDs, IDictionary`2<IEfSerializedType, EfModelSource> sharedTypeEntityIDs, IDictionary`2<IEfSerializedType, EfModelSource> ignoredEntityIds, IDictionary`2<IEfSerializedType, EfModelSource> ownedEntityIDs, IEnumerable`1<string> dbFunctions, IEnumerable`1<IEfSerializedType> explicitlyDeclaredEntityIDs, IDictionary`2<EntityFrameworkModelId, EfModelSource> baseModels, ISet`1<IPsiSourceFile> files, EntityFrameworkVersion entityFrameworkVersion, PsiModulePtr psiModulePtr, EfElementValidity validity, bool hasUnresolvedChildren, bool hasUnresolvedSuperTypes);
    private static EntityFrameworkModelConfigReader();
    public virtual EntityFrameworkModelId get_ModelId();
    [CompilerGeneratedAttribute]
public int get_ModificationTimestamp();
    [CompilerGeneratedAttribute]
public void set_ModificationTimestamp(int value);
    public IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public IDictionary`2<IEfSerializedType, EfModelSource> get_LocalEntityIDs();
    [CompilerGeneratedAttribute]
public IDictionary`2<IEfSerializedType, EfModelSource> get_LocalSharedTypeEntityIDs();
    [CompilerGeneratedAttribute]
public IDictionary`2<IEfSerializedType, EfModelSource> get_LocalIgnoredEntityIDs();
    [CompilerGeneratedAttribute]
public IDictionary`2<IEfSerializedType, EfModelSource> get_LocalOwnedEntityIDs();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_DbFunctions();
    public virtual IDictionary`2<ITypeOwner, ConstantValue> get_TypeOwnersConstantValues();
    [CompilerGeneratedAttribute]
internal IDictionary`2<EntityFrameworkEntityConfigReader, IType> get_DiscoverableThroughFluentApiEntities();
    [CompilerGeneratedAttribute]
private void set_DiscoverableThroughFluentApiEntities(IDictionary`2<EntityFrameworkEntityConfigReader, IType> value);
    [CompilerGeneratedAttribute]
internal OneToSetMap`2<EntityFrameworkEntityConfigReader, string> get_DiscoverableThroughFluentApiProperties();
    [CompilerGeneratedAttribute]
private void set_DiscoverableThroughFluentApiProperties(OneToSetMap`2<EntityFrameworkEntityConfigReader, string> value);
    [CompilerGeneratedAttribute]
protected virtual ISet`1<IPsiSourceFile> get_FileSet();
    private EntityFrameworkConfigurationReader get_Configuration();
    public IEnumerable`1<EntityFrameworkEntityId> GetAllEntityIDs(bool getOnlyValid);
    public bool IsValidEntityId(IEfSerializedType id);
    public IEnumerable`1<EntityFrameworkElementId> GetAllSharedTypeEntityIDs(bool getOnlyValid);
    public bool IsValidSharedTypeEntityId(IEfSerializedType id);
    public IEnumerable`1<EntityFrameworkElementId> GetAllIgnoredEntityIDs();
    public bool IsValidIgnoredEntityId(IEfSerializedType id);
    public IEnumerable`1<EntityFrameworkElementId> GetAllOwnedEntityIDs();
    public bool IsValidOwnedEntityId(IEfSerializedType id);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelConfigReader/<GetDbSetPropertiesMatchingCondition>d__53")]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IProperty> GetDbSetPropertiesMatchingCondition(ITypeElement dbContext, EntityFrameworkVersion entityFrameworkVersion, Predicate`1<IProperty> condition);
    [PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IList`1<IType> GetAllDbSetProperties(ITypeElement dbContextTypeElement, EntityFrameworkVersion entityFrameworkVersion, Boolean& hasUnresolvedTypes);
    [PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<ValueTuple`2<string, EntityFrameworkEntityId>> GetAllPropertyBags(ITypeElement dbContextTypeElement, EntityFrameworkVersion entityFrameworkVersion);
    private static bool ShouldProcessSuperTypeForDbContext(IDeclaredType declaredType, EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[PureAttribute]
internal static EntityFrameworkEntitySpecificParameters GetParametersForNewEntityFromFluentApi(IEfSerializedType serializedType, IType type, EfEntityKind entityKind, EntityFrameworkTypeElementId dbContextId, EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[PureAttribute]
internal static EntityFrameworkEntitySpecificParameters GetParametersForNewSharedTypeEntityFromFluentApi(string name, EfEntityKind entityKind, EntityFrameworkTypeElementId dbContextId, EntityFrameworkVersion entityFrameworkVersion);
    internal void AddEntityFromFluentApi(EntityFrameworkEntityConfigReader entity, IType entityType);
    [CanBeNullAttribute]
internal IEfSerializedType GetSerializedTypeIfValid(IType entityType);
    internal void InvalidateEntityData(IEfSerializedType entityTypeId);
    [CanBeNullAttribute]
[PureAttribute]
public EntityFrameworkEntityConfigReader GetExistingEntityById(IEfSerializedType entityTypeId);
    [PureAttribute]
public bool EntityIsExplicitlyDeclaredInDbContext(IEfSerializedType entityTypeId);
    [NotNullAttribute]
[ItemNotNullAttribute]
internal ISet`1<EntityFrameworkElementId> ProcessEntityClasses(ISet`1<IType> typesToProcess, bool processExistingEntities, bool isInitialDbSetsProcessing, IEnumerable`1<ValueTuple`2<string, EntityFrameworkEntityId>> propertyBags, int depthForRelatedEntitiesProcessing, ILogger logger, string loggerPrefixMessage);
    internal void ResetClassSourcedInfoFromEntity(IEfSerializedType entityType);
    internal void AddIgnoredEntityId(IEfSerializedType ignoredEntityType, EfModelSource source);
    internal void AddOwnedType(IEfSerializedType ownedEntityType, EfModelSource source);
    internal void UpdateChildrenResolve(EntityFrameworkModelCache cache, IEnumerable`1<ITypeElement> superTypeElements);
    internal void BuildOnModelCreating(IEnumerable`1<ITypeElement> superTypeElements);
    internal void BuildModelPart(ITypeElement partTypeElement, bool isBuildFromScratch, Boolean& hasUnresolvedTypes);
    internal void BuildModelSuperTypes(IEnumerable`1<ITypeElement> superTypeElements, bool isBuildFromScratch, Boolean& hasUnresolvedTypes);
    protected virtual void ReadConfigMethodPart(ITreeNode treeNode, ValueTuple`2<ISet`1<ICSharpDeclaration>, int> processedDeclarations, IEnumerable`1<IType> builderTypes);
    protected virtual EntityFrameworkModelId CreateIdFromType(IType type);
    protected virtual IList`1<IDeclaredType> CollectSuperTypes();
    protected virtual bool ShouldProcessSuperType(IDeclaredType declaredType);
    protected virtual EntityFrameworkEntityConfigReader GetExistingChild(IEfSerializedType childElementId);
    protected virtual EntityFrameworkEntityConfigReader GetReaderForNewChild(EntityFrameworkEntitySpecificParameters childParams);
    private static bool ProcessApplyConfiguration(EntityFrameworkModelConfigReader modelConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessApplyConfigurationsFromAssembly(EntityFrameworkModelConfigReader modelConfigReader, IInvocationExpression invocationExpression);
    private static void ProcessEntityConfiguration(EntityFrameworkModelConfigReader modelConfigReader, ITypeElement entityConfigurationTypeElement, IType entityType, bool isOwnedByDefault);
    private static bool ProcessIgnore(EntityFrameworkModelConfigReader modelConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessOwned(EntityFrameworkModelConfigReader modelConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessEntity(EntityFrameworkModelConfigReader modelConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessSharedTypeEntity(EntityFrameworkModelConfigReader modelConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessHasDbFunction(EntityFrameworkModelConfigReader modelConfigReader, IInvocationExpression invocationExpression);
    protected virtual bool ProcessMethod(string methodName, IInvocationExpression invocationExpression);
    protected virtual void ProcessInnerMethodWithoutBuilder(IInvocationExpression invocationExpression, IMethod method);
    private void ApplyPreConventionDataToNewEntity(PreConventionData preConventionData, EntityFrameworkEntityConfigReader entity);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelConfigReader/<GetAllEntities>d__89")]
[NotNullAttribute]
private IEnumerable`1<EntityFrameworkEntityId> GetAllEntities(Func`2<EntityFrameworkModelConfigReader, IEnumerable`1<KeyValuePair`2<IEfSerializedType, EfModelSource>>> getEntity, Predicate`1<IEfSerializedType> shouldAddEntity, bool getOnlyValid);
    [CompilerGeneratedAttribute]
private void <InvalidateEntityData>g__InvalidateEntitySources|61_0(IDictionary`2<IEfSerializedType, EfModelSource> collection, <>c__DisplayClass61_0& );
    [CompilerGeneratedAttribute]
internal static void <ProcessApplyConfigurationsFromAssembly>g__ApplyConfigurationsOfTypeFromAssembly|79_0(IClrTypeName baseConfigurationTypeName, bool isComplexTypeConfiguration, <>c__DisplayClass79_0& );
    [CompilerGeneratedAttribute]
internal static void <ProcessIgnore>g__AddIgnoredEntity|81_0(IType entityType, <>c__DisplayClass81_0& );
    [CompilerGeneratedAttribute]
internal static void <ProcessOwned>g__AddOwnedEntity|82_0(IType entityType, <>c__DisplayClass82_0& );
    [CompilerGeneratedAttribute]
internal static void <ProcessEntity>g__AddEntity|83_0(IType entityType, ICSharpExpression expression, <>c__DisplayClass83_0& );
    [CompilerGeneratedAttribute]
internal static void <ProcessSharedTypeEntity>g__AddSharedTypeEntity|84_0(string name, ICSharpExpression expression, <>c__DisplayClass84_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelId : EntityFrameworkElementId {
    public EntityFrameworkTypeElementId ModelType { get; }
    public EntityFrameworkModelId(string psiModulePersistentId, string clrTypeName);
    public EntityFrameworkModelId(EntityFrameworkTypeElementId modelId);
    public EntityFrameworkTypeElementId get_ModelType();
    public virtual string ToString();
    public string ToStringFull();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkModelIdMarshaller : object {
    [NotNullAttribute]
public static EntityFrameworkModelIdMarshaller Instance;
    private static EntityFrameworkModelIdMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, EntityFrameworkModelId value);
    public sealed virtual EntityFrameworkModelId Unmarshal(UnsafeReader reader);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkPropertyConfigReader : EntityFrameworkConfigReaderBase {
    [NotNullAttribute]
private static IDictionary`2<EntityFrameworkVersion, IDictionary`2<string, Func`3<EntityFrameworkPropertyConfigReader, IInvocationExpression, bool>>> ourMethodProcessors;
    [NotNullAttribute]
private EntityFrameworkModelCache myCache;
    private EntityFrameworkTypeElementId myContainingModelType;
    [CanBeNullAttribute]
private EntityFrameworkConfigurationReader myConfiguration;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`3<bool, EfModelSource, bool> myIsFixedLength;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`3<Nullable`1<int>, EfModelSource, bool> myMaxLength;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<EfValueGenerationStrategy, EfModelSource> myValueGenerationStrategy;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlDataTypeWithSource <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEfSerializedType <SerializedType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesLazyLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitlyDisablesLazyLoading>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOverride>k__BackingField;
    [NotNullAttribute]
public string ShortName { get; }
    public SqlDataTypeWithSource DataType { get; private set; }
    [NotNullAttribute]
public IEfSerializedType SerializedType { get; }
    public bool IsVirtual { get; private set; }
    public bool UsesLazyLoader { get; private set; }
    public bool ExplicitlyDisablesLazyLoading { get; private set; }
    public bool IsFixedLength { get; }
    public Nullable`1<int> MaxLength { get; }
    public EfValueGenerationStrategy ValueGenerationStrategy { get; }
    public bool HasConversion { get; private set; }
    public bool IsAutoInclude { get; private set; }
    public bool IsOverride { get; private set; }
    public bool HasMaxLength { get; }
    public IDictionary`2<ITypeOwner, ConstantValue> TypeOwnersConstantValues { get; }
    private EntityFrameworkConfigurationReader Configuration { get; }
    public EntityFrameworkPropertyConfigReader(EntityFrameworkTypeElementId parentContainingModelType, string shortName, IEfSerializedType serializedType, EntityFrameworkModelCache cache, EntityFrameworkVersion entityFrameworkVersion);
    private EntityFrameworkPropertyConfigReader(EntityFrameworkTypeElementId parentContainingModelType, string shortName, IEfSerializedType serializedType, SqlDataTypeWithSource dataTypeWithSource, EntityFrameworkModelCache cache, EntityFrameworkVersion entityFrameworkVersion, bool isVirtual, bool usesLazyLoader, bool explicitlyDisablesLazyLoading, bool isOverride, bool isAutoInclude, bool hasConversion, ValueTuple`3<bool, EfModelSource, bool> isFixedLength, ValueTuple`3<Nullable`1<int>, EfModelSource, bool> maxLength, ValueTuple`2<EfValueGenerationStrategy, EfModelSource> valueGenerationStrategy);
    private static EntityFrameworkPropertyConfigReader();
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public SqlDataTypeWithSource get_DataType();
    [CompilerGeneratedAttribute]
private void set_DataType(SqlDataTypeWithSource value);
    [CompilerGeneratedAttribute]
public IEfSerializedType get_SerializedType();
    [CompilerGeneratedAttribute]
public bool get_IsVirtual();
    [CompilerGeneratedAttribute]
private void set_IsVirtual(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsesLazyLoader();
    [CompilerGeneratedAttribute]
private void set_UsesLazyLoader(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitlyDisablesLazyLoading();
    [CompilerGeneratedAttribute]
private void set_ExplicitlyDisablesLazyLoading(bool value);
    public bool get_IsFixedLength();
    public Nullable`1<int> get_MaxLength();
    public EfValueGenerationStrategy get_ValueGenerationStrategy();
    [CompilerGeneratedAttribute]
public bool get_HasConversion();
    [CompilerGeneratedAttribute]
private void set_HasConversion(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoInclude();
    [CompilerGeneratedAttribute]
private void set_IsAutoInclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOverride();
    [CompilerGeneratedAttribute]
private void set_IsOverride(bool value);
    public bool get_HasMaxLength();
    public virtual IDictionary`2<ITypeOwner, ConstantValue> get_TypeOwnersConstantValues();
    private EntityFrameworkConfigurationReader get_Configuration();
    public virtual string ToString();
    private static bool ProcessHasColumnType(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessAutoInclude(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessEnableLazyLoading(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessHasConversion(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessValueGeneratedNever(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessValueGeneratedOnAdd(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessValueGeneratedOnUpdate(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessValueGeneratedOnAddOrUpdate(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    public string GetMaxLengthStringPresentation();
    internal void UpdateByConvention(bool isVirtual, bool isOverride, bool usesLazyLoader);
    private static bool ProcessIsFixedLength(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    private static bool ProcessHasMaxLength(EntityFrameworkPropertyConfigReader propertyConfigReader, IInvocationExpression invocationExpression);
    internal void ResetClassSourcedInfo();
    internal void UpdateMaxLength(int maxLength, EfModelSource source, bool isFromDataType);
    internal void UpdateIsFixedLength(bool isFixedLength, EfModelSource source, bool isFromDataType);
    internal void SetHasConversion();
    internal void UpdateDataType(string dataType, EfModelSource modelSource);
    internal void UpdateDataType(SqlDataTypeWithSource newDataType);
    internal void UpdateValueGenerationStrategy(EfValueGenerationStrategy valueGenerationStrategy, EfModelSource source);
    protected virtual bool ProcessMethod(string methodName, IInvocationExpression invocationExpression);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkPropertySpecificParameters : EntityFrameworkElementBasicParameters {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEfSerializedType <SerializedType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [NotNullAttribute]
public string ShortName { get; }
    [NotNullAttribute]
public IEfSerializedType SerializedType { get; }
    [CanBeNullAttribute]
public IType Type { get; }
    public EntityFrameworkPropertySpecificParameters(string shortName, IEfSerializedType serializedType, IType type, EntityFrameworkVersion entityFrameworkVersion);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public IEfSerializedType get_SerializedType();
    [CompilerGeneratedAttribute]
public IType get_Type();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkQueryInspector : ControlFlowGraphInspector`1<EntityFrameworkContext> {
    private static int MaxIterationsForLocalFunctionAnalysis;
    [NotNullAttribute]
private IDictionary`2<ITreeNode, OwnerDbContextInfo> myLazyLoadingProperties;
    [NotNullAttribute]
private IDictionary`2<ITreeNode, OwnerDbContextInfo> myQueryTrackingBehaviorProperties;
    [NotNullAttribute]
private OneToSetMap`2<ITreeNode, Variable> myObjectCreationToPropertyVariables;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private IDictionary`2<ITreeNode, ValueTuple`2<ArgumentKind, ITypeOwner>> myArgumentsDependentOnInvocation;
    [NotNullAttribute]
private IDictionary`2<ILocalFunction, EntityFrameworkContext> myLocalFunctionEntryContexts;
    [NotNullAttribute]
private ISet`1<IControlFlowEdge> myExitEdges;
    [NotNullAttribute]
private IDictionary`2<ValueTuple`2<ITreeNode, EntityFrameworkContext>, EntityFrameworkContext> myAnonymousFunctionCache;
    [NotNullAttribute]
private IDictionary`2<NavigationQueryData, NavigationQueryResult> myNavigationsCache;
    [NotNullAttribute]
private IDictionary`2<ITypeElement, ISet`1<string>> myDbFunctionsCache;
    [NotNullAttribute]
private IDictionary`2<IControlFlowEdge, Func`2<IControlFlowEdge, EntityFrameworkContext>> myContextsWithPotentialIssues;
    [NotNullAttribute]
[ItemNotNullAttribute]
private ISet`1<ICSharpArgument> myArgumentsWithQueryVariables;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IList`1<ITypeElement> myDbContextsForCurrentQuery;
    [NotNullAttribute]
[ItemNotNullAttribute]
private ISet`1<IDeclaredElement> myLocalVariablesForCurrentQuery;
    [CompilerGeneratedAttribute]
private Result <InspectionResult>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityFrameworkQueryInspectorKind <Kind>k__BackingField;
    [NotNullAttribute]
public Result InspectionResult { get; }
    public EntityFrameworkQueryInspectorKind Kind { get; }
    [NotNullAttribute]
private EntityFrameworkContextFactory ContextFactory { get; }
    [NotNullAttribute]
private InspectionData InspectorData { get; }
    public EntityFrameworkQueryInspector(ControlFlowGraph controlFlowGraph, EntityFrameworkContextFactory contextFactory);
    public EntityFrameworkQueryInspector(ControlFlowGraph controlFlowGraph, EntityFrameworkContextFactory contextFactory, EntityFrameworkQueryInspector parentInspector, IList`1<ITypeElement> dbContextsForCurrentQuery, EntityFrameworkQueryInspectorKind inspectorKind, ITypeOwner queryParameter);
    [CompilerGeneratedAttribute]
public Result get_InspectionResult();
    [CompilerGeneratedAttribute]
public EntityFrameworkQueryInspectorKind get_Kind();
    private EntityFrameworkContextFactory get_ContextFactory();
    private InspectionData get_InspectorData();
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static Result PerformInspectionFromAnalyzer(ControlFlowGraph controlFlowGraph, EntityFrameworkMajorVersion entityFrameworkMajorVersion, IPsiModule psiModule, EntityFrameworkModelCache modelCache, bool isOptimisticAnalysis, IEnumerable`1<ITypeElement> dbContexts, IEnumerable`1<ICSharpExpression> collectionModificationExpressions, DbFunctionAnnotationProviderBase dbFunctionAnnotationProvider, Func`2<ITreeNode, IControlFlowGraph> graphBuilder, ILogger logger);
    [NotNullAttribute]
private static IControlFlowElement FindTopmostElementForSameSourceNode(IControlFlowElement controlFlowElement);
    [PureAttribute]
private static bool InputAndOutputTypesAreEqual(IType inputType, IType outputType, ITreeNode context);
    public string DumpEdgeContext(IControlFlowEdge edge);
    protected virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement element, EntityFrameworkContext context);
    protected virtual bool ShouldProcessEdge(IControlFlowEdge edge);
    private void AnalyzeLocalFunctions();
    private void AnalyzePotentialIssues();
    private NavigationQueryResult GetNavigation(NavigationQueryData navigationQueryData);
    [NotNullAttribute]
private ISet`1<string> GetDbFunctions(IEnumerable`1<ITypeElement> dbContexts);
    [CanBeNullAttribute]
private EntityFrameworkContext PerformChildInspection(ITreeNode graphSource, ControlFlowGraph controlFlowGraph, EntityFrameworkContext initialContext, bool isQueryable, bool isTopLevelProjection, bool isNavigationEntryClosure, bool calculateReturnContext, IList`1<ITypeElement> dbContextsForInitialContext, ITypeOwner queryParameter);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IList`1<EntityFrameworkContext> GetContextsFromNode(IControlFlowElement parentElement, ITreeNode nodeToFind);
    private void UpdateContextFromElement(EntityFrameworkContext context, IControlFlowElement parentElement, ITreeNode nodeToFind);
    [CanBeNullAttribute]
private IControlFlowElement FindTopmostControlFlowElementForNode(IControlFlowElement parentElement, ITreeNode treeNode);
    [CompilerGeneratedAttribute]
private void <InspectLeafElementAndSetContextToExits>g__SetContextAndCheckEdge|30_0(IControlFlowEdge edge, EntityFrameworkContext edgeContext);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkQueryInspectorKind : Enum {
    public int value__;
    public static EntityFrameworkQueryInspectorKind Normal;
    public static EntityFrameworkQueryInspectorKind PartOfQuery;
    public static EntityFrameworkQueryInspectorKind NavigationEntryClosure;
    public static EntityFrameworkQueryInspectorKind TopLevelProjection;
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkQueryMethodKind : Enum {
    public int value__;
    public static EntityFrameworkQueryMethodKind Include;
    public static EntityFrameworkQueryMethodKind ThenInclude;
    public static EntityFrameworkQueryMethodKind Load;
    public static EntityFrameworkQueryMethodKind Query;
    public static EntityFrameworkQueryMethodKind All;
    public static EntityFrameworkQueryMethodKind ToList;
    public static EntityFrameworkQueryMethodKind AsTracking;
    public static EntityFrameworkQueryMethodKind AsNoTracking;
    public static EntityFrameworkQueryMethodKind AsNoTrackingWithIdentityResolution;
    public static EntityFrameworkQueryMethodKind IgnoreAutoIncludes;
    public static EntityFrameworkQueryMethodKind Cast;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkTypeElementId : ValueType {
    [CompilerGeneratedAttribute]
private string <PsiModulePersistentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrTypeName>k__BackingField;
    [NotNullAttribute]
public string PsiModulePersistentId { get; }
    [NotNullAttribute]
public string ClrTypeName { get; }
    public EntityFrameworkTypeElementId(string psiModulePersistentId, string clrTypeName);
    [CompilerGeneratedAttribute]
public string get_PsiModulePersistentId();
    [CompilerGeneratedAttribute]
public string get_ClrTypeName();
    public bool Equals(EntityFrameworkTypeElementId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NotNullAttribute]
public string ToStringFull();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkTypeElementIdMarshaller : object {
    [NotNullAttribute]
public static EntityFrameworkTypeElementIdMarshaller Instance;
    private static EntityFrameworkTypeElementIdMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, EntityFrameworkTypeElementId value);
    public sealed virtual EntityFrameworkTypeElementId Unmarshal(UnsafeReader reader);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils : object {
    [NotNullAttribute]
private static string DbContextSetMethodNameCore;
    [NotNullAttribute]
private static string DbContextSetMethodName;
    [NotNullAttribute]
private static string AsTrackingNameCore;
    [NotNullAttribute]
private static string AsNoTrackingNameCore;
    [NotNullAttribute]
private static string AsNoTrackingName;
    [NotNullAttribute]
private static string AsNoTrackingWithIdentityResolutionNameCore;
    [NotNullAttribute]
private static string IgnoreAutoIncludesNameCore;
    [NotNullAttribute]
private static string UseIncludeBuilderClrNameCore;
    [NotNullAttribute]
public static ClrTypeName DbContextClrNameCore;
    [NotNullAttribute]
public static ClrTypeName DbContextClrName;
    [NotNullAttribute]
public static AssemblyNameInfo EntityFrameworkCoreReferenceName;
    [NotNullAttribute]
public static AssemblyNameInfo EntityFrameworkReferenceName;
    [NotNullAttribute]
public static ClrTypeName QueryableClassClrName;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<IClrTypeName> ourSimpleConvertibleToSqlTypeNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<ClrTypeName> ourComplexConvertibleToSqlTypes;
    [NotNullAttribute]
private static ClrTypeName ourILazyLoaderClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourDatabaseGeneratedAttributeClrName;
    [NotNullAttribute]
private static ClrTypeName ourIEntityConfigurationClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourEntityTypeConfigurationClrName;
    [NotNullAttribute]
private static ClrTypeName ourComplexTypeConfigurationClrName;
    [NotNullAttribute]
private static ClrTypeName ourConfigurationRegistrarClrName;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourIncludeNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourIncludeNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourThenIncludeNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourCreateEntityMethodNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourCreateEntityMethodNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourLocalPropertyNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourLocalPropertyNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourNavigationEntryLoadNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourNavigationEntryLoadAsyncNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourNavigationEntryLoadNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourNavigationEntryLoadAsyncNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourNavigationEntryQueryNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourNavigationEntryQueryNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<ClrTypeName> ourNavigationEntryClrNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<ClrTypeName> ourNavigationEntryClrNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourToListToArrayAsyncNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourToListToArrayAsyncNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourQueryableLoadNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourQueryableLoadNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourToListToArrayNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourFromSqlNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<string> ourFromSqlNames;
    [NotNullAttribute]
private static ClrTypeName ourDbSetClrNameCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<ClrTypeName> ourDbSetClrNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourTypeCastingMethodsNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourDbContextEntryMethodNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourDbContextEntryMethodNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourDbSetFindNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourDbSetFindAsyncNamesCore;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourDbSetFindNames;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourDbSetFindAsyncNames;
    [NotNullAttribute]
private static ClrTypeName ourChangeTrackerPropertyClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourDbContextConfigurationPropertyClrName;
    [NotNullAttribute]
private static ClrTypeName ourLazyLoadingEnabledPropertyClrNameCore;
    [NotNullAttribute]
private static ClrTypeName ourLazyLoadingEnabledPropertyClrName;
    [NotNullAttribute]
private static ClrTypeName ourProxyCreationEnabledPropertyClrName;
    [NotNullAttribute]
private static ClrTypeName ourQueryTrackingBehaviorPropertyClrNameCore;
    [CompilerGeneratedAttribute]
private static ISet`1<string> <EntityFrameworkRelatedMethodNames>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public static ISet`1<string> EntityFrameworkRelatedMethodNames { get; }
    private static EntityFrameworkUtils();
    [CompilerGeneratedAttribute]
public static ISet`1<string> get_EntityFrameworkRelatedMethodNames();
    [NotNullAttribute]
public static ClrTypeName GetILazyLoaderClrNameCore();
    [NotNullAttribute]
public static ClrTypeName GetProxyCreationEnabledPropertyClrName();
    [NotNullAttribute]
public static ClrTypeName GetDatabaseGeneratedAttributeClrName();
    [NotNullAttribute]
public static ClrTypeName GetIEntityConfigurationClrNameCore();
    [NotNullAttribute]
public static ClrTypeName GetEntityTypeConfigurationClrName();
    [NotNullAttribute]
public static ClrTypeName GetComplexTypeConfigurationClrName();
    [NotNullAttribute]
public static ClrTypeName GetConfigurationRegistrarClrName();
    public static ClrTypeName GetDbContextClrName(EntityFrameworkVersion entityFrameworkVersion);
    [CanBeNullAttribute]
public static string GetAsTrackingName(EntityFrameworkVersion entityFrameworkVersion);
    public static string GetAsNoTrackingName(EntityFrameworkVersion entityFrameworkVersion);
    [CanBeNullAttribute]
public static string GetAsNoTrackingWithIdentityResolutionName(EntityFrameworkVersion entityFrameworkVersion);
    [CanBeNullAttribute]
public static string GetIgnoreAutoIncludesName(EntityFrameworkVersion entityFrameworkVersion);
    [CanBeNullAttribute]
public static string GetUseIncludeBuilderName(EntityFrameworkVersion entityFrameworkVersion);
    public static bool IsLocalPropertyName(string name, EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<string> GetIncludeNames(EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<string> GetThenIncludeNames(EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<string> GetFromSqlNames(EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<string> GetNavigationEntryLoadNames(EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<string> GetNavigationEntryQueryNames(EntityFrameworkVersion entityFrameworkVersion);
    public static IEnumerable`1<string> GetCreateEntityMethodNames(EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<ClrTypeName> GetNavigationEntryClrNames(EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<string> GetToListToArrayClrNames(EntityFrameworkVersion entityFrameworkVersion);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<string> GetTypeCastingMethodsClrNames();
    public static bool IsTypeCastingMethod(IMethod method);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<string> GetQueryableLoadClrNames(EntityFrameworkVersion entityFrameworkVersion);
    public static ClrTypeName GetDbContextConfigurationPropertyClrName(EntityFrameworkVersion entityFrameworkVersion);
    public static ClrTypeName GetLazyLoadingEnabledPropertyClrName(EntityFrameworkVersion entityFrameworkVersion);
    [CanBeNullAttribute]
public static ClrTypeName GetQueryTrackingBehaviorPropertyClrName(EntityFrameworkVersion entityFrameworkVersion);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkUtils/<GetTypeElementsFromClrNames>d__90")]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<ITypeElement> GetTypeElementsFromClrNames(IEnumerable`1<ClrTypeName> clrNames, IPsiModule psiModule);
    public static bool IsDbSetTypeElement(ITypeElement typeElement, EntityFrameworkVersion entityFrameworkVersion);
    public static bool IsDbContextSetMethod(ITypeMember declaredElement, EntityFrameworkVersion entityFrameworkVersion);
    public static bool IsDbContextEntryMethod(ITypeMember declaredElement, EntityFrameworkVersion entityFrameworkVersion);
    public static bool IsConvertibleToSqlType(IType type, IClrTypeName clrTypeName);
    public static bool IsConvertibleToSqlType(IArrayType arrayType);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type: null => null")]
public static IType GetTypeArgumentTypeByIndex(IType type, int index);
    [PureAttribute]
[ContractAnnotationAttribute("type: null => null; type: notnull => notnull")]
public static IType GetCollectionUnderlyingOrOriginalType(IType type);
    [ContractAnnotationAttribute("typeElement: null => false")]
public static bool IsDescendantOfAny(ITypeElement typeElement, IEnumerable`1<ITypeElement> baseTypeElements);
    [NotNullAttribute]
[PureAttribute]
public static IType GetMeaningfulUnderlyingType(IType originalType, ITreeNode context);
    [PureAttribute]
[ContractAnnotationAttribute("=> false, underlyingType: null; => true, underlyingType: notnull")]
public static bool IsCollectionLikeType(IType type, IType& underlyingType);
    [CanBeNullAttribute]
[PureAttribute]
public static IType GetTypeFromTypeParameterType(IType originalType, ITypeElement derivedTypeElementWithAssignedTypeParameters);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpArgument GetArgumentByMatchingParameter(ICSharpArgumentsOwner argumentsOwner, int parameterIndex);
    [PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static ISet`1<ITypeElement> FindDbContexts(ITreeNode treeNode, EntityFrameworkVersion entityFrameworkVersion, EntityFrameworkModelCache entityFrameworkModelCache, DependencyStore dependencyStore);
    [CanBeNullAttribute]
public static IType GetClassTypeConstraint(ITypeParameter typeParameter);
    [CanBeNullAttribute]
public static IType GetBaseDbContextType(IPsiModule psiModule, EntityFrameworkVersion entityFrameworkVersion);
    public static bool TypeElementCanBeDbContext(ITypeElement typeElement, EntityFrameworkVersion entityFrameworkVersion, ITypeElement baseDbContextTypeElement);
    [NotNullAttribute]
public static string GetTypeMemberFullNameWithoutGenerics(ITypeMember typeMember);
    [ContractAnnotationAttribute("null => true")]
public static bool IsInvalidType(IType type);
    public static bool IsSimpleSqlTypeElement(ITypeElement typeElement);
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityFrameworkVersion : Enum {
    public int value__;
    public static EntityFrameworkVersion EntityFrameworkCore;
    public static EntityFrameworkVersion EntityFramework6;
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityRelation : object {
    [CompilerGeneratedAttribute]
private IType <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPropertyName>k__BackingField;
    [NotNullAttribute]
public IType SourceType { get; }
    [NotNullAttribute]
public IType TargetType { get; }
    [NotNullAttribute]
public string TargetPropertyName { get; }
    public EntityRelation(IType sourceType, IType targetType, string targetPropertyName);
    public EntityRelation(ValueTuple`2<IType, IType> entityTypes, string targetPropertyName);
    [CompilerGeneratedAttribute]
public IType get_SourceType();
    [CompilerGeneratedAttribute]
public IType get_TargetType();
    [CompilerGeneratedAttribute]
public string get_TargetPropertyName();
    public string Dump();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityRelationEqualityComparer : object {
    [NotNullAttribute]
private Func`2<IType, ITypeElement> myTypeElementRetriever;
    [NotNullAttribute]
public static EntityRelationEqualityComparer Instance;
    public EntityRelationEqualityComparer(Func`2<IType, ITypeElement> typeElementRetriever);
    private static EntityRelationEqualityComparer();
    public sealed virtual bool Equals(EntityRelation x, EntityRelation y);
    public sealed virtual int GetHashCode(EntityRelation obj);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityRelationNodeEqualityComparer : object {
    [NotNullAttribute]
private Func`2<IType, ITypeElement> myTypeElementRetriever;
    public EntityRelationNodeEqualityComparer(Func`2<IType, ITypeElement> typeElementRetriever);
    public sealed virtual bool Equals(EntityRelation x, EntityRelation y);
    public sealed virtual int GetHashCode(EntityRelation obj);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityRelationsLoadedTree : object {
    [CompilerGeneratedAttribute]
private int <Complexity>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<EntityRelation> <ExplicitlyLoadedRelationsWithLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<EntityRelation> <RelationsLoadedWithEnumerations>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<EntityRelationNode> <Roots>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityRelationNode <CurrentNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <RootType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnknownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LoadsEverything>k__BackingField;
    public int Complexity { get; private set; }
    [CanBeNullAttribute]
public IInvocationExpression LastInclusionExpression { get; }
    [CanBeNullAttribute]
public ICSharpExpression HighlightedExpression { get; }
    [CanBeNullAttribute]
public LoadedRelation LatestLoadedRelation { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<EntityRelation> ExplicitlyLoadedRelationsWithLoad { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<EntityRelation> RelationsLoadedWithEnumerations { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<EntityRelationNode> Roots { get; }
    [CanBeNullAttribute]
private EntityRelationNode CurrentNode { get; private set; }
    [CanBeNullAttribute]
private IType RootType { get; private set; }
    private bool HasUnknownTypes { get; private set; }
    private bool LoadsEverything { get; private set; }
    private EntityRelationsLoadedTree(EntityRelationsLoadedTree tree);
    private EntityRelationsLoadedTree(IType rootType);
    [CompilerGeneratedAttribute]
public int get_Complexity();
    [CompilerGeneratedAttribute]
private void set_Complexity(int value);
    public IInvocationExpression get_LastInclusionExpression();
    public ICSharpExpression get_HighlightedExpression();
    public LoadedRelation get_LatestLoadedRelation();
    [CompilerGeneratedAttribute]
private HashSet`1<EntityRelation> get_ExplicitlyLoadedRelationsWithLoad();
    [CompilerGeneratedAttribute]
private HashSet`1<EntityRelation> get_RelationsLoadedWithEnumerations();
    [CompilerGeneratedAttribute]
private HashSet`1<EntityRelationNode> get_Roots();
    [CompilerGeneratedAttribute]
private EntityRelationNode get_CurrentNode();
    [CompilerGeneratedAttribute]
private void set_CurrentNode(EntityRelationNode value);
    [CompilerGeneratedAttribute]
private IType get_RootType();
    [CompilerGeneratedAttribute]
private void set_RootType(IType value);
    [CompilerGeneratedAttribute]
private bool get_HasUnknownTypes();
    [CompilerGeneratedAttribute]
private void set_HasUnknownTypes(bool value);
    [CompilerGeneratedAttribute]
private bool get_LoadsEverything();
    [CompilerGeneratedAttribute]
private void set_LoadsEverything(bool value);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static ISet`1<UsedEntityRelation> GetDistinctRelationsNotCovered(EntityRelationsLoadedTree loadedTree, IEnumerable`1<RelationsChain> relationsChains);
    [CanBeNullAttribute]
public static EntityRelationsLoadedTree GetIntersection(IEnumerable`1<EntityRelationsLoadedTree> trees);
    [CanBeNullAttribute]
public static EntityRelationsLoadedTree GetUnion(IEnumerable`1<EntityRelationsLoadedTree> trees);
    private static void FillTree(EntityRelationsLoadedTree resultingTree, IList`1<EntityRelationsLoadedTree> sourceTrees, bool intersect);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityRelationsLoadedTree/<FlattenTree>d__42")]
[NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<LoadedRelation> FlattenTree(Nullable`1<QueryTrackingBehavior> overriddenQueryTrackingBehavior);
    public void AddRelation(LoadedRelation relation);
    [NotNullAttribute]
public EntityRelationsLoadedTree Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected bool Equals(EntityRelationsLoadedTree other);
    [NotNullAttribute]
[ItemNotNullAttribute]
private ISet`1<UsedEntityRelation> GetDistinctRelationsNotCovered(IEnumerable`1<RelationsChain> relationsChains);
    [CompilerGeneratedAttribute]
private bool <GetDistinctRelationsNotCovered>g__RelationIsCoveredByCurrentNode|48_0(HashSet`1<EntityRelationNode> targets, UsedEntityRelation relationToCover, EntityRelationNode& checkedCurrentNode, bool alreadyFailedToCoverWithInclude, <>c__DisplayClass48_0& );
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.EntityRelationWithNavigation : EntityRelation {
    [CompilerGeneratedAttribute]
private NavigationParameters <Navigation>k__BackingField;
    public NavigationParameters Navigation { get; }
    protected EntityRelationWithNavigation(NavigationParameters navigationParameters, IType sourceType, IType targetType);
    protected EntityRelationWithNavigation(NavigationParameters navigationParameters, EntityFrameworkModelCache cache, IPsiModule module);
    protected EntityRelationWithNavigation(IType sourceType, IType targetType, string targetPropertyName);
    [CompilerGeneratedAttribute]
public NavigationParameters get_Navigation();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.IEfSerializedType {
    [NotNullAttribute]
public string ShortName { get; }
    public bool IsResolved { get; }
    public bool IsNullableAnnotated { get; }
    public EfSerializedTypeKind Kind { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual bool get_IsResolved();
    public abstract virtual bool get_IsNullableAnnotated();
    public abstract virtual EfSerializedTypeKind get_Kind();
    [CanBeNullAttribute]
public abstract virtual IType CreateType(IPsiModule psiModule);
    [NotNullAttribute]
public abstract virtual string ToShortString();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.IEntityFrameworkCacheableElement {
    public EntityFrameworkVersion EntityFrameworkVersion { get; }
    [NotNullAttribute]
public EntityFrameworkModelId ModelId { get; }
    public EfElementValidity Validity { get; public set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IPsiSourceFile> Files { get; }
    public abstract virtual EntityFrameworkVersion get_EntityFrameworkVersion();
    public abstract virtual EntityFrameworkModelId get_ModelId();
    public abstract virtual EfElementValidity get_Validity();
    public abstract virtual void set_Validity(EfElementValidity value);
    public abstract virtual IEnumerable`1<IPsiSourceFile> get_Files();
    public abstract virtual void RemoveFileConnection(IPsiSourceFile sourceFile);
    public abstract virtual void AssignNewSetOfFiles(IEnumerable`1<IPsiSourceFile> files);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.LoadedRelation : EntityRelationWithNavigation {
    public static int Complexity;
    [CompilerGeneratedAttribute]
private ICSharpExpression <HighlightingRangeExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IInvocationExpression <InvocationExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityFrameworkQueryMethodKind <QueryMethodKind>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryTrackingBehavior <QueryTrackingBehavior>k__BackingField;
    public bool LoadsValidTypes { get; }
    [NotNullAttribute]
public ICSharpExpression HighlightingRangeExpression { get; }
    [NotNullAttribute]
public IInvocationExpression InvocationExpression { get; }
    public EntityFrameworkQueryMethodKind QueryMethodKind { get; }
    public QueryTrackingBehavior QueryTrackingBehavior { get; }
    public LoadedRelation(IInvocationExpression invocationExpression, ICSharpExpression highlightingRangeExpression, EntityFrameworkQueryMethodKind queryMethodKind, QueryTrackingBehavior queryTrackingBehavior, IType sourceType, IType includedType, string includedPropertyName);
    public LoadedRelation(IInvocationExpression invocationExpression, ICSharpExpression highlightingRangeExpression, EntityFrameworkQueryMethodKind queryMethodKind, QueryTrackingBehavior queryTrackingBehavior, NavigationParameters loadedNavigation, EntityFrameworkModelCache cache, IPsiModule psiModule);
    public LoadedRelation(IInvocationExpression invocationExpression, ICSharpExpression highlightingRangeExpression, EntityFrameworkQueryMethodKind queryMethodKind, QueryTrackingBehavior queryTrackingBehavior, NavigationParameters loadedNavigation, IType sourceType, IType includedType);
    public bool get_LoadsValidTypes();
    [CompilerGeneratedAttribute]
public ICSharpExpression get_HighlightingRangeExpression();
    [CompilerGeneratedAttribute]
public IInvocationExpression get_InvocationExpression();
    [CompilerGeneratedAttribute]
public EntityFrameworkQueryMethodKind get_QueryMethodKind();
    [CompilerGeneratedAttribute]
public QueryTrackingBehavior get_QueryTrackingBehavior();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.LoadedRelationEqualityComparer : object {
    public static LoadedRelationEqualityComparer Instance;
    private static LoadedRelationEqualityComparer();
    public sealed virtual bool Equals(LoadedRelation x, LoadedRelation y);
    public sealed virtual int GetHashCode(LoadedRelation obj);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationEntry : ValueType {
    [CompilerGeneratedAttribute]
private IType <LeftType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <RightType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public IType LeftType { get; }
    [NotNullAttribute]
public IType RightType { get; }
    [NotNullAttribute]
public string Name { get; }
    public NavigationEntry(IType leftType, IType rightType, string name);
    [CompilerGeneratedAttribute]
public IType get_LeftType();
    [CompilerGeneratedAttribute]
public IType get_RightType();
    [CompilerGeneratedAttribute]
public string get_Name();
    public bool Equals(NavigationEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationParameters : ValueType {
    [CompilerGeneratedAttribute]
private EntityFrameworkEntityId <SourceEntityId>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityFrameworkEntityId <TargetEntityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ToManyRelationship>k__BackingField;
    [NotNullAttribute]
public EntityFrameworkEntityId SourceEntityId { get; }
    [NotNullAttribute]
public EntityFrameworkEntityId TargetEntityId { get; }
    [NotNullAttribute]
public string ShortName { get; }
    public bool ToManyRelationship { get; }
    public NavigationParameters(EntityFrameworkEntityId sourceEntityId, EntityFrameworkEntityId targetEntityId, string shortName, bool toManyRelationship);
    [CompilerGeneratedAttribute]
public EntityFrameworkEntityId get_SourceEntityId();
    [CompilerGeneratedAttribute]
public EntityFrameworkEntityId get_TargetEntityId();
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public bool get_ToManyRelationship();
    public static ValueTuple`2<IType, IType> GetEntityTypesFromNavigation(NavigationParameters navigationParameters, EntityFrameworkModelCache cache, IPsiModule psiModule);
    public bool Equals(NavigationParameters other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationPropertyKind : Enum {
    public int value__;
    public static NavigationPropertyKind None;
    public static NavigationPropertyKind EntityToEntityNavigation;
    public static NavigationPropertyKind DbSet;
    public static NavigationPropertyKind Configuration;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryData : ValueType {
    [CompilerGeneratedAttribute]
private IType <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <DbContext>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityFrameworkVersion <EntityFrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IOverridableMember <OverridableMember>k__BackingField;
    [NotNullAttribute]
public IType ContainingType { get; }
    [NotNullAttribute]
public string PropertyName { get; }
    [NotNullAttribute]
public ITypeElement DbContext { get; }
    public EntityFrameworkVersion EntityFrameworkVersion { get; }
    [CanBeNullAttribute]
public IOverridableMember OverridableMember { get; }
    public NavigationQueryData(IType containingType, string propertyName, ITypeElement dbContext, EntityFrameworkVersion entityFrameworkVersion, IOverridableMember overridableMember);
    [CompilerGeneratedAttribute]
public IType get_ContainingType();
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public ITypeElement get_DbContext();
    [CompilerGeneratedAttribute]
public EntityFrameworkVersion get_EntityFrameworkVersion();
    [CompilerGeneratedAttribute]
public IOverridableMember get_OverridableMember();
    public bool Equals(NavigationQueryData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.NavigationQueryResult : ValueType {
    public static NavigationQueryResult None;
    private bool myCanBeLazyLoaded;
    private bool myLazyLoadingInitiallyEnabled;
    [CompilerGeneratedAttribute]
private NavigationPropertyKind <PropertyKind>k__BackingField;
    [CompilerGeneratedAttribute]
private NavigationParameters <NavigationParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoIncluded>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <TargetDbSetType>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryTrackingBehavior <QueryTrackingBehavior>k__BackingField;
    public NavigationPropertyKind PropertyKind { get; }
    public NavigationParameters NavigationParameters { get; }
    public bool CanBeIgnored { get; }
    public bool IsAutoIncluded { get; }
    [CanBeNullAttribute]
public IType TargetDbSetType { get; }
    public QueryTrackingBehavior QueryTrackingBehavior { get; }
    public NavigationQueryResult(NavigationPropertyKind propertyKind, NavigationParameters navigationParameters, bool canBeLazyLoaded, bool lazyLoadingInitiallyEnabled, bool canBeIgnored, bool isAutoIncluded, IType targetDbSetType, QueryTrackingBehavior queryTrackingBehavior);
    private static NavigationQueryResult();
    [CompilerGeneratedAttribute]
public NavigationPropertyKind get_PropertyKind();
    [CompilerGeneratedAttribute]
public NavigationParameters get_NavigationParameters();
    [CompilerGeneratedAttribute]
public bool get_CanBeIgnored();
    [CompilerGeneratedAttribute]
public bool get_IsAutoIncluded();
    [CompilerGeneratedAttribute]
public IType get_TargetDbSetType();
    [CompilerGeneratedAttribute]
public QueryTrackingBehavior get_QueryTrackingBehavior();
    public bool IsLazyLoaded(Nullable`1<bool> lazyLoadingOverride);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.OwnerDbContextInfo : object {
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    [NotNullAttribute]
public ITypeElement TypeElement { get; }
    [CanBeNullAttribute]
public Variable Variable { get; }
    public OwnerDbContextInfo(ITypeElement typeElement, Variable variable);
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public void Deconstruct(ITypeElement& typeElement, Variable& variable);
    protected bool Equals(OwnerDbContextInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.PreConventionData : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<bool, Source> myIsIgnored;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<Nullable`1<bool>, Source> myIsFixedLength;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<Nullable`1<int>, Source> myMaxLength;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<string, Source> myDataTypeString;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<bool, Source> myHasConversion;
    public bool IsIgnored { get; }
    public Nullable`1<bool> IsFixedLength { get; }
    public Nullable`1<int> MaxLength { get; }
    [CanBeNullAttribute]
public string DataTypeString { get; }
    public bool HasConversion { get; }
    public PreConventionData(PreConventionData preConventionData);
    private PreConventionData(ValueTuple`2<bool, Source> isIgnored, ValueTuple`2<Nullable`1<bool>, Source> isFixedLength, ValueTuple`2<Nullable`1<int>, Source> maxLength, ValueTuple`2<string, Source> dataTypeString, ValueTuple`2<bool, Source> hasConversion);
    public bool get_IsIgnored();
    public Nullable`1<bool> get_IsFixedLength();
    public Nullable`1<int> get_MaxLength();
    public string get_DataTypeString();
    public bool get_HasConversion();
    public static PreConventionData Unmarshal(UnsafeReader reader);
    private static ValueTuple`2<T, Source> GetUpdatedValue(ValueTuple`2<T, Source> oldValue, ValueTuple`2<T, Source> newValue);
    public void Marshal(UnsafeWriter writer);
    public void SetIsIgnored(Source source);
    public void UpdateIsFixedLength(bool value, Source source);
    public void UpdateMaxLength(int value, Source source);
    public void UpdateDataTypeString(string value, Source source);
    public void SetHasConversion(Source source);
    public void UpdateFrom(PreConventionData other, Nullable`1<Source> optionalNewSource);
    [CompilerGeneratedAttribute]
internal static Source <Unmarshal>g__ReadSourceEnumValue|18_0(<>c__DisplayClass18_0& );
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.QueryTrackingBehavior : Enum {
    public int value__;
    public static QueryTrackingBehavior TrackAll;
    public static QueryTrackingBehavior NoTracking;
    public static QueryTrackingBehavior NoTrackingWithIdentityResolution;
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.RelationNavigationEqualityComparer : object {
    public static RelationNavigationEqualityComparer Instance;
    private static RelationNavigationEqualityComparer();
    public sealed virtual bool Equals(EntityRelationWithNavigation x, EntityRelationWithNavigation y);
    public sealed virtual int GetHashCode(EntityRelationWithNavigation obj);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.RelationsChain : object {
    [CompilerGeneratedAttribute]
private IList`1<UsedEntityRelation> <Relations>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourcePropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<QueryTrackingBehavior> <OverriddenQueryTrackingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreAutoIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private OwnerDbContextInfo <OwnerDbContext>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityRelationsLoadedTree <LoadedRelationsTree>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpExpression <AnchorExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AnchorExpressionIsPrioritized>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NavigationEntry> <NavigationEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPartiallyClientSide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OriginIsQueryParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDbContextConfiguration>k__BackingField;
    [NotNullAttribute]
public IList`1<UsedEntityRelation> Relations { get; }
    [NotNullAttribute]
public IType SourceType { get; public set; }
    [NotNullAttribute]
public string SourcePropertyName { get; }
    [NotNullAttribute]
public IType LatestAddedType { get; }
    [CanBeNullAttribute]
public Nullable`1<QueryTrackingBehavior> OverriddenQueryTrackingBehavior { get; public set; }
    public bool IgnoreAutoIncludes { get; public set; }
    [NotNullAttribute]
public OwnerDbContextInfo OwnerDbContext { get; }
    [CanBeNullAttribute]
public EntityRelationsLoadedTree LoadedRelationsTree { get; public set; }
    [NotNullAttribute]
public ICSharpExpression AnchorExpression { get; public set; }
    public bool AnchorExpressionIsPrioritized { get; public set; }
    [CanBeNullAttribute]
public Nullable`1<NavigationEntry> NavigationEntry { get; public set; }
    public bool IsPartiallyClientSide { get; public set; }
    public bool OriginIsQueryParameter { get; }
    public bool IsDbContextConfiguration { get; }
    public bool IsEmpty { get; }
    public int Length { get; }
    public RelationsChain(ICSharpExpression lastInclusionExpression, IType sourceType, string sourcePropertyName, Variable contextVariable, ITypeElement contextTypeElement, EntityRelationsLoadedTree loadedRelationsTree);
    public RelationsChain(RelationsChain originalChain, IType originalVariableType, IReferenceExpression referenceExpression, bool originIsQueryParameter, PredefinedType predefinedType);
    private RelationsChain(RelationsChain chain, bool isDeepClone);
    private RelationsChain(ICSharpExpression anchorExpression, string sourcePropertyName, Variable contextVariable, IType contextType, ITypeElement contextTypeElement);
    [CompilerGeneratedAttribute]
public IList`1<UsedEntityRelation> get_Relations();
    [CompilerGeneratedAttribute]
public IType get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(IType value);
    [CompilerGeneratedAttribute]
public string get_SourcePropertyName();
    public IType get_LatestAddedType();
    [CompilerGeneratedAttribute]
public Nullable`1<QueryTrackingBehavior> get_OverriddenQueryTrackingBehavior();
    [CompilerGeneratedAttribute]
public void set_OverriddenQueryTrackingBehavior(Nullable`1<QueryTrackingBehavior> value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreAutoIncludes();
    [CompilerGeneratedAttribute]
public void set_IgnoreAutoIncludes(bool value);
    [CompilerGeneratedAttribute]
public OwnerDbContextInfo get_OwnerDbContext();
    [CompilerGeneratedAttribute]
public EntityRelationsLoadedTree get_LoadedRelationsTree();
    [CompilerGeneratedAttribute]
public void set_LoadedRelationsTree(EntityRelationsLoadedTree value);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_AnchorExpression();
    [CompilerGeneratedAttribute]
public void set_AnchorExpression(ICSharpExpression value);
    [CompilerGeneratedAttribute]
public bool get_AnchorExpressionIsPrioritized();
    [CompilerGeneratedAttribute]
public void set_AnchorExpressionIsPrioritized(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<NavigationEntry> get_NavigationEntry();
    [CompilerGeneratedAttribute]
public void set_NavigationEntry(Nullable`1<NavigationEntry> value);
    [CompilerGeneratedAttribute]
public bool get_IsPartiallyClientSide();
    [CompilerGeneratedAttribute]
public void set_IsPartiallyClientSide(bool value);
    [CompilerGeneratedAttribute]
public bool get_OriginIsQueryParameter();
    [CompilerGeneratedAttribute]
public bool get_IsDbContextConfiguration();
    public bool get_IsEmpty();
    public int get_Length();
    public static RelationsChain GetConfigurationChain(ICSharpExpression anchorExpression, string sourcePropertyName, Variable contextVariable, IType contextType, ITypeElement contextTypeElement);
    [CanBeNullAttribute]
public static RelationsChain TryGetCommonChain(IEnumerable`1<RelationsChain> chains);
    public string Dump();
    [PureAttribute]
public int GetComplexity();
    [NotNullAttribute]
[PureAttribute]
public ICSharpExpression GetLastInclusionExpression();
    [NotNullAttribute]
[PureAttribute]
public ICSharpExpression GetHighlightedExpression();
    public void AddRelation(UsedEntityRelation relation, bool navigationEntryRelation);
    public void AddLoadedRelation(LoadedRelation loadedRelation);
    [NotNullAttribute]
public RelationsChain DeepClone();
    [NotNullAttribute]
public RelationsChain ShallowClone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected bool Equals(RelationsChain other);
    private bool NonRelationsEquals(RelationsChain other);
    private int GetRelationsHashCode();
    private static bool RelationsEqual(IList`1<UsedEntityRelation> relations, IList`1<UsedEntityRelation> otherRelations);
    [CompilerGeneratedAttribute]
internal static void <AddRelation>g__SetRelationAsInverseIfNeeded|63_0(UsedEntityRelation relation, int currentIndex, RelationsChain chain);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.SqlDataTypes : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourPredefinedDataTypes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private static ISet`1<string> ourNonFixedLengthStringDataTypes;
    private static SqlDataTypes();
    public static bool IsPredefinedDataTypeName(string dataTypeName);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.SqlDataTypeWithSource : ValueType {
    [CompilerGeneratedAttribute]
private string <DataTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private EfModelSource <Source>k__BackingField;
    [CanBeNullAttribute]
public string DataTypeName { get; }
    [CanBeNullAttribute]
public Int32[] Arguments { get; }
    public EfModelSource Source { get; }
    public SqlDataTypeWithSource(SqlDataTypeWithSource sqlDataTypeWithSource, EfModelSource additionalSource);
    public SqlDataTypeWithSource(string dataTypeNameString, EfModelSource source);
    private SqlDataTypeWithSource(string dataTypeName, Int32[] arguments, EfModelSource source);
    [CompilerGeneratedAttribute]
public string get_DataTypeName();
    [CompilerGeneratedAttribute]
public Int32[] get_Arguments();
    [CompilerGeneratedAttribute]
public EfModelSource get_Source();
    public static void Marshal(UnsafeWriter writer, SqlDataTypeWithSource value);
    public static SqlDataTypeWithSource Unmarshal(UnsafeReader reader);
    public string ToStringPresentation(Nullable`1<int> maxLengthOverride);
    public virtual string ToString();
    [PureAttribute]
public bool EqualsIgnoreSource(SqlDataTypeWithSource other);
    [PureAttribute]
public bool SupportsNavigation();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.TargetOnlyEntityRelationEqualityComparer : object {
    [NotNullAttribute]
private Func`2<IType, ITypeElement> myTypeElementRetriever;
    public TargetOnlyEntityRelationEqualityComparer(Func`2<IType, ITypeElement> typeElementRetriever);
    public sealed virtual bool Equals(EntityRelation x, EntityRelation y);
    public sealed virtual int GetHashCode(EntityRelation obj);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.UsedEntityRelation : EntityRelationWithNavigation {
    public static int Complexity;
    [CompilerGeneratedAttribute]
private IReferenceExpression <UsageLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <DbContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLazyLoaded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlreadyExistsInQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoIncludedInFluentApi>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInverseRelationInChain>k__BackingField;
    [NotNullAttribute]
public IReferenceExpression UsageLocation { get; }
    [NotNullAttribute]
public ITypeElement DbContext { get; }
    public bool IsLazyLoaded { get; }
    public bool CanBeIgnored { get; }
    public bool AlreadyExistsInQuery { get; public set; }
    public bool IsAutoIncludedInFluentApi { get; }
    public bool IsInverseRelationInChain { get; public set; }
    public UsedEntityRelation(NavigationParameters usedNavigation, IReferenceExpression usageLocation, ITypeElement dbContext, EntityFrameworkModelCache cache, bool isLazyLoaded, bool canBeIgnored, bool existsInQuery, bool isAutoIncludedInFluentApi);
    [CompilerGeneratedAttribute]
public IReferenceExpression get_UsageLocation();
    [CompilerGeneratedAttribute]
public ITypeElement get_DbContext();
    [CompilerGeneratedAttribute]
public bool get_IsLazyLoaded();
    [CompilerGeneratedAttribute]
public bool get_CanBeIgnored();
    [CompilerGeneratedAttribute]
public bool get_AlreadyExistsInQuery();
    [CompilerGeneratedAttribute]
public void set_AlreadyExistsInQuery(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoIncludedInFluentApi();
    [CompilerGeneratedAttribute]
public bool get_IsInverseRelationInChain();
    [CompilerGeneratedAttribute]
public void set_IsInverseRelationInChain(bool value);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EntityFrameworkAnalysis.UsedEntityRelationEqualityComparer : object {
    [NotNullAttribute]
public static UsedEntityRelationEqualityComparer Instance;
    [NotNullAttribute]
private EntityRelationEqualityComparer myEntityRelationEqualityComparer;
    public UsedEntityRelationEqualityComparer(EntityRelationEqualityComparer equalityComparer);
    private static UsedEntityRelationEqualityComparer();
    public sealed virtual bool Equals(UsedEntityRelation x, UsedEntityRelation y);
    public sealed virtual int GetHashCode(UsedEntityRelation obj);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.EqualsExpressionNullConditionalAccessIntermediateMultiplexor : CSharpControlFlowMultiplexor {
    [NotNullAttribute]
public IEqualityExpression EqualityExpression { get; }
    public EqualsExpressionNullConditionalAccessIntermediateMultiplexor(IEqualityExpression equalityExpression);
    public IEqualityExpression get_EqualityExpression();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.ForEachIteratorMultiplexor : CSharpControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private IForeachStatement <ForEachStatement>k__BackingField;
    public IForeachStatement ForEachStatement { get; }
    public ForEachIteratorMultiplexor(IForeachStatement forEachStatement);
    [CompilerGeneratedAttribute]
public IForeachStatement get_ForEachStatement();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IncrementalControlFlowVariablesCollector : ControlFlowVariablesCollectorBase {
    [NotNullAttribute]
private Stack`1<ValueTuple`2<ILocalScope, int>> myScopes;
    [NotNullAttribute]
private ICSharpControlFlowGraph myGraph;
    [NotNullAttribute]
private CSharpControlFlowContextFactory myContextFactory;
    [NotNullAttribute]
private VariableIndex myVariableIndex;
    [NotNullAttribute]
private ElementAccessContext myAccessContext;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private OneToListMap`2<IDeclaredElement, ValueTuple`3<ControlFlowWeakVariableInfo, bool, bool>> myVariablesPerLocal;
    [NotNullAttribute]
private HashSet`1<Pair`2<IField, IType>> myVisitedFields;
    [NotNullAttribute]
private HashSet`1<IDeclaredType> myVisitedInitiallyInitialized;
    [CanBeNullAttribute]
private ClosureVariablesCollector myClosuresCollector;
    [NotNullAttribute]
private IResolveContext ResolveContext { get; }
    [NotNullAttribute]
private CSharpControlFlowAnnotationCache AnnotationCache { get; }
    [NotNullAttribute]
private OneToSetMap`2<IStruct, IField> StructsAccessedFields { get; }
    private ValueAnalysisMode AnalysisMode { get; }
    public IncrementalControlFlowVariablesCollector(ICSharpControlFlowGraph graph, CSharpControlFlowContextFactory contextFactory, VariableIndex variableIndex, IList`1<ValueTuple`3<ControlFlowWeakVariableInfo, bool, bool>> instanceWeakVariables, IList`1<ControlFlowWeakVariableInfo> staticWeakVariables);
    private IResolveContext get_ResolveContext();
    private CSharpControlFlowAnnotationCache get_AnnotationCache();
    private OneToSetMap`2<IStruct, IField> get_StructsAccessedFields();
    private ValueAnalysisMode get_AnalysisMode();
    [CanBeNullAttribute]
private IScope GetTopScope();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IncrementalControlFlowVariablesCollector/<GetLocalVariables>d__19")]
private static IEnumerable`1<IDeclaredElement> GetLocalVariables(ILocalScope localScope);
    public virtual void ProcessBeforeInterior(ITreeNode element);
    private void AddControlFlowVariable(IDeclaredElement localVariable, LocalList`1& variablesInScope, OneToSetMap`2<IStruct, IField> structsAccessedFields, bool isParameterOfAsyncOrIterator);
    public virtual void ProcessAfterInterior(ITreeNode element);
    public virtual void VisitIsExpression(IIsExpression isExpression);
    public virtual void VisitAsExpression(IAsExpression asExpression);
    public virtual void VisitCastExpression(ICastExpression castExpression);
    public virtual void VisitAssignmentExpression(IAssignmentExpression assignmentExpression);
    public virtual void VisitArrayInitializer(IArrayInitializer arrayInitializerParam);
    public virtual void VisitTypePattern(ITypePattern typePatternParam);
    public virtual void VisitRecursivePattern(IRecursivePattern recursivePatternParam);
    public virtual void VisitVarDeconstructionPattern(IVarDeconstructionPattern varDeconstructionPatternParam);
    public virtual void VisitParenthesizedVariableDesignation(IParenthesizedVariableDesignation parenthesizedVariableDesignationParam);
    public virtual void VisitDeconstructionPatternClause(IDeconstructionPatternClause deconstructionPatternClauseParam);
    public virtual void VisitTupleExpression(ITupleExpression tupleExpressionParam);
    private void VisitDeconstructionReference(IDeconstructionReference reference, ITreeNode context);
    public virtual void VisitConstantOrTypePattern(IConstantOrTypePattern constantPattern);
    public virtual void VisitRelationalPattern(IRelationalPattern relationalPattern);
    public virtual void VisitExpressionInitializer(IExpressionInitializer expressionInitializerParam);
    public virtual void VisitForeachStatement(IForeachStatement foreachStatement);
    [NotNullAttribute]
private ControlFlowStrictVariableInfo AddVariableAndStructFields(IClrDeclaredElement element, ControlFlowVariableAccessState access, LocalList`1& variablesInScope, OneToSetMap`2<IStruct, IField> structsAccessedFields, bool shouldBeAssignedUponExit, bool addToAnalysis);
    [NotNullAttribute]
private ControlFlowStrictVariableInfo AddVariableAndStructFieldsImpl(IClrDeclaredElement element, IType elementType, ControlFlowVariableAccessState accessState, LocalList`1& variablesInScope, OneToSetMap`2<IStruct, IField> structsAccessedFields, bool shouldBeAssignedUponExit, bool addToAnalysis);
    private bool AllRequiredFieldsTracked(IStruct structTypeElement, ISet`1<IField> accessedFields);
    private bool IsInitiallyInitialized(IField field);
    private bool IsInitiallyInitialized(IType type, bool checkInitializers);
    [PureAttribute]
private bool HasHiddenFieldsFromFieldLikeEventsOrAutoProperties(IDeclaredType valueType);
    private bool IsInitiallyInitializedImpl(IType type, HashSet`1<IDeclaredType> visited, bool checkInitializers);
    [PureAttribute]
private static bool IsMemberInitializedInline(ITypeMember typeMember);
    private static ControlFlowVariableAccessState GetInitialAccessState(IDeclaredElement declaredElement, Boolean& shouldBeAssignedUponExit, bool isParameterOfAsyncOrIterator);
    private void CreateClosureVariables(HashSet`1<IClrDeclaredElement> closureCandidates, LocalList`1& variableInScope);
    private void MarkMutableClosureCaptures(ICSharpDeclaration closureDeclaration, Dictionary`2<IClrDeclaredElement, bool> captures, ITreeNode topLocalScope);
    private void MarkMutablePrimaryParameters(Dictionary`2<IClrDeclaredElement, bool> captures);
    private void MarkReadOnlyClosuresInLocalFunction(ILocalFunctionDeclaration localFunctionDeclaration, Dictionary`2<IClrDeclaredElement, bool> closure, ITreeNode topLocalScope);
    [NotNullAttribute]
private ControlFlowClosureVariableInfo GetFieldVariableInfoWithStructFields(IClrDeclaredElement root, ICSharpDeclaration closureDeclaration, IClrDeclaredElement declaredElement, IType ownerType, bool isReadOnly, ControlFlowVariableAccessState initialAccessState);
    private void AddVariableToIndexRecursively(VariableInfo variableInfo, LocalList`1& variablesInScope);
    private void VisitStructMembersFromConstructorsPointOfView(LocalList`1& variablesInScope);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static IClassLikeDeclaration <MarkMutablePrimaryParameters>g__TryGetSingleDeclaration|50_0(ITypeElement typeElement);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IndexerInitializerInvocationMultiplexor : CSharpControlFlowMultiplexor {
    public IndexerInitializerInvocationMultiplexor(IIndexerInitializer indexerInitializer);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.InitialContextBuilder : object {
    private static int MAX_VARIABLE_NUMBER;
    [NotNullAttribute]
private ICSharpControlFlowGraph myGraph;
    [NotNullAttribute]
private ICSharpTreeNode myDeclaration;
    [NotNullAttribute]
private CSharpControlFlowContextFactory myContextFactory;
    [NotNullAttribute]
private VariableIndex myVariableIndex;
    [NotNullAttribute]
private IResolveContext ResolveContext { get; }
    [NotNullAttribute]
public CSharpControlFlowContext Context { get; }
    public InitialContextBuilder(ICSharpControlFlowGraph graph, CSharpControlFlowContextFactory contextFactory);
    private void Run();
    private IResolveContext get_ResolveContext();
    public CSharpControlFlowContext get_Context();
    private void ScanWeakVariables(IList`1<ITreeNode> bodyParts, IList`1& staticWeakVariables, IList`1& instanceWeakVariables);
    private bool IsImplicitlyAssigned(ITypeMember member);
    private static bool HasNonNullInitializer(ITypeMember member);
    private static bool IsInNonChainedConstructor(ICSharpTreeNode body, Boolean& isStaticConstructor);
    private bool SkipWeakVariablesUsedOnlyOnce();
    private CSharpControlFlowVariableValue GetInitialNreValue(IAttributesOwner member, IType type);
    private void ScanHistoryCheckPoints();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.InitialContextBuilder/<CollectVariablesFromAnnotations>d__18")]
[NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<ITypeMember> CollectVariablesFromAnnotations(MemberNotNullAnnotationProvider memberNotNullAnnotationProvider, ITypeMember annotationOwnerMember);
    [CompilerGeneratedAttribute]
private void <ScanWeakVariables>g__ProcessInitializedTypeMembers|11_0(TreeNodeEnumerable`1<IInitializerElement> initializerElements, <>c__DisplayClass11_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.InterpolatedStringHandlerExitMultiplexor : CSharpControlFlowMultiplexor {
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public InterpolatedStringHandlerExitMultiplexor(ICSharpExpression expression);
    public ICSharpExpression get_Expression();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.AbstractValue : object {
    public static AbstractValue Zero;
    public static AbstractValue One;
    public static AbstractValue ZeroPunctured;
    public static AbstractValue MinusOnePunctured;
    public static AbstractValue LongFullRange;
    private static int MaxFewValues;
    private static AbstractValue ourNonNegative;
    private static AbstractValue ourPositive;
    public long MinPoint { get; }
    public long MaxPoint { get; }
    public ulong UlongMinPoint { get; }
    public ulong UlongMaxPoint { get; }
    private static AbstractValue();
    public abstract virtual long get_MinPoint();
    public abstract virtual long get_MaxPoint();
    public ulong get_UlongMinPoint();
    public ulong get_UlongMaxPoint();
    public long GetMinPoint(IntegerType type);
    public long GetMaxPoint(IntegerType type);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<LongInterval> GetLongIntervals();
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<UlongInterval> GetUlongIntervals();
    [CanBeNullAttribute]
public abstract virtual AbstractValue EnsureValuesAreInTypeRange(IntegerType type);
    public abstract virtual AbstractValueWithInfo Add(AbstractValue other, bool isCheckedContext, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo Subtract(AbstractValue other, bool isCheckedContext, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo Multiply(AbstractValue other, bool isCheckedContext, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo Divide(AbstractValue divisor, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo LeftShift(AbstractValue other, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo RightShift(AbstractValue other, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo UnsignedRightShift(AbstractValue other, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo BitwiseAnd(AbstractValue other, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo BitwiseOr(AbstractValue other, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo ExclusiveOr(AbstractValue other, IntegerType returnType);
    public AbstractValueWithInfo UnaryNegation(bool isCheckedContext, IntegerType returnType);
    public abstract virtual AbstractValueWithInfo OnesComplement(IntegerType returnType);
    public abstract virtual AbstractValueWithInfo Abs(IntegerType returnType);
    public AbstractValueWithInfo Sign();
    [CanBeNullAttribute]
public abstract virtual AbstractValue TryIntersect(AbstractValue other);
    [NotNullAttribute]
public abstract virtual AbstractValue Complement(IntegerType type);
    public abstract virtual ComparisonResult IsEqual(AbstractValue other);
    public abstract virtual bool Equals(AbstractValue other);
    [PureAttribute]
private bool HasFewValues();
    public AbstractValueWithInfo AddUncheckedInt(AbstractValue other);
    public AbstractValueWithInfo SubtractUncheckedInt(AbstractValue other);
    public AbstractValueWithInfo AddCheckedInt(AbstractValue other);
    public AbstractValueWithInfo SubtractCheckedInt(AbstractValue other);
    public AbstractValueWithInfo MultiplyUncheckedInt(AbstractValue other);
    public AbstractValueWithInfo MultiplyCheckedInt(AbstractValue other);
    public AbstractValueWithInfo Increment(bool isCheckedContext, IntegerType returnType);
    public AbstractValueWithInfo Decrement(bool isCheckedContext, IntegerType returnType);
    public AbstractValueWithInfo Modulus(AbstractValue other, IntegerType returnType);
    public AbstractValue CompareTo(AbstractValue other, IntegerType paramType);
    [PureAttribute]
[NotNullAttribute]
public AbstractValue Merge(AbstractValue other);
    [NotNullAttribute]
public AbstractValue GetAlwaysLessThan(AbstractValue other, IntegerType type);
    [NotNullAttribute]
public AbstractValue GetAlwaysGreaterThan(AbstractValue other, IntegerType type);
    public abstract virtual bool Contains(long point);
    public AbstractValueWithInfo Cast(IntegerType sourceType, IntegerType targetType, bool isCheckedContext);
    private AbstractValueWithInfo CastToType(AbstractValue argument, IntegerType targetType, bool isCheckedContext);
    private AbstractValueWithInfo CastFromUlong(IntegerType targetType, bool isCheckedContext);
    private static AbstractValue Sign(AbstractValue abstractValue);
    public AbstractValue Max(AbstractValue rhs, IntegerType type);
    public AbstractValue Min(AbstractValue rhs, IntegerType type);
    public AbstractValueWithInfo Clamp(AbstractValue min, AbstractValue max, IntegerType type);
    public ComparisonResult GreaterThanOrEqual(AbstractValue rhs, IntegerType type);
    public ComparisonResult GreaterThan(AbstractValue rhs, IntegerType type);
    public ComparisonResult LessThanOrEqual(AbstractValue rhs, IntegerType type);
    public ComparisonResult LessThan(AbstractValue rhs, IntegerType type);
    private static void Add(LongInterval interval, IReadOnlyList`1<LongInterval> intervals, BuilderWithErrorInfo builderWithErrorInfo, bool isCheckedContext, IntegerType returnType);
    private static ValueTuple`2<IReadOnlyList`1<TIntervalType>, bool> Add(TIntervalType lhs, TIntervalType rhs, bool isCheckedContext);
    private static ValueTuple`2<IReadOnlyList`1<TIntervalType>, bool> Subtract(TIntervalType lhs, TIntervalType rhs, bool isCheckedContext);
    private static bool CouldOverflowOverMax(TNumericType lhs);
    private static void Subtract(LongInterval interval, IReadOnlyList`1<LongInterval> intervals, BuilderWithErrorInfo builderWithErrorInfo, bool isCheckedContext, IntegerType returnType);
    private static void Multiply(LongInterval interval, IReadOnlyList`1<LongInterval> intervals, BuilderWithErrorInfo builderWithErrorInfo, bool isCheckedContext, IntegerType returnType);
    private static ValueTuple`2<TIntervalType, bool> Multiply(TIntervalType lhs, TIntervalType rhs, bool isCheckedContext);
    private static void Divide(LongInterval dividend, long divisor, Builder builder, IntegerType returnType);
    private static void Divide(long dividend, LongInterval divisor, Builder builder, IntegerType returnType);
    private static long OnesComplement(long value, IntegerType returnType);
    private static long LeftShift(long value, int factor, IntegerType returnType);
    private static long RightShift(long value, int factor, IntegerType returnType);
    private static long UnsignedRightShift(long value, int factor, IntegerType returnType);
    private static IReadOnlyList`1<TIntervalType> GetResultForIntervalFromEnds(TNumericType minPointResult, bool minPointOverflow, TNumericType maxPointResult, bool maxPointOverflow, bool isCheckedContext);
    [CanBeNullAttribute]
public static AbstractValue NonNegative(IntegerType type);
    [CanBeNullAttribute]
public static AbstractValue Positive(IntegerType type);
    public static EqualityCheckResult CheckEquality(AbstractValue lhs, AbstractValue rhs, IntegerType type);
    public static SplitOperandsInCondition CheckRelationalExpression(AbstractValue lhs, AbstractValue rhs, RelationalOperator relationalOperator, IntegerType operatorType);
    private static ValueTuple`2<AbstractValue, AbstractValue> SplitValueInRelationalExpression(AbstractValue operandValue, AbstractValuesInCondition allowedRanges);
    [PureAttribute]
private static ValueTuple`2<AbstractValuesInCondition, AbstractValuesInCondition> GetAllowedRangesForRelationalExpression(AbstractValue lhs, AbstractValue rhs, RelationalOperator relationalOperator, IntegerType operatorType);
    [CanBeNullAttribute]
private static AbstractValue MakeAbstractValueFromTwoBounds(long leftBound, long rightBound, bool isLeftBoundIncluded, bool isRightBoundIncluded, IntegerType type);
    private static ValueTuple`2<TNumericType, bool> PerformBinaryOperationAndReportOverflow(TNumericType lhs, TNumericType rhs, Func`3<TNumericType, TNumericType, TNumericType> operationChecked, Func`3<TNumericType, TNumericType, TNumericType> operationUnchecked);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<AbstractValue, AbstractValue> <GetAllowedRangesForRelationalExpression>g__GetAllowedLessThan|92_0(AbstractValue lhs, AbstractValue rhs, IntegerType operatorType);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<AbstractValue, AbstractValue> <GetAllowedRangesForRelationalExpression>g__GetAllowedLessThanOrEqual|92_1(AbstractValue lhs, AbstractValue rhs, IntegerType operatorType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.AbstractValueUtils : object {
    private static IntegerTypeInfo sbyteInfo;
    private static IntegerTypeInfo byteInfo;
    private static IntegerTypeInfo shortInfo;
    private static IntegerTypeInfo ushortInfo;
    private static IntegerTypeInfo intInfo;
    private static IntegerTypeInfo uintInfo;
    private static IntegerTypeInfo longInfo;
    private static IntegerTypeInfo ulongInfo;
    private static AbstractValueUtils();
    [ExtensionAttribute]
public static bool IsSigned(IntegerType type);
    [ExtensionAttribute]
public static int GetBits(IntegerType type);
    [ExtensionAttribute]
public static long GetSize(IntegerType type);
    [ExtensionAttribute]
public static LongInterval GetLongRange(IntegerType type);
    [ExtensionAttribute]
public static long MinValue(IntegerType type);
    [ExtensionAttribute]
public static long MaxValue(IntegerType type);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<LongInterval> ReinterpretAsLongIntervals(IReadOnlyList`1<UlongInterval> ulongIntervals);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<UlongInterval> ReinterpretAsUlongIntervals(IReadOnlyList`1<LongInterval> longIntervals);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<LongInterval> ClampToTypeStrict(IReadOnlyList`1<LongInterval> intervals, IntegerType type);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<LongInterval> ClampToLong(IReadOnlyList`1<UlongInterval> ulongIntervals);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static AbstractValue ToAbstractValue(IReadOnlyList`1<LongInterval> intervals);
    [ExtensionAttribute]
public static bool BelongsToTypeRange(IntegerType type, long value);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static Nullable`1<LongInterval> Abs(LongInterval interval, long typeMinValue);
    public static ErrorType GetOverflowErrorType(bool overflow, bool isCheckedContext);
    [ExtensionAttribute]
public static bool LessThan(long lhs, long rhs, IntegerType type);
    [ExtensionAttribute]
public static bool GreaterThan(long lhs, long rhs, IntegerType type);
    [ExtensionAttribute]
public static bool LessThanOrEqual(long lhs, long rhs, IntegerType type);
    [ExtensionAttribute]
public static bool GreaterThanOrEqual(long lhs, long rhs, IntegerType type);
    [ExtensionAttribute]
public static RelationalOperator GetRelationType(ISignOperator signOperator);
    public static IntervalsRelation GetIntersectionInfo(LongInterval lhs, LongInterval rhs);
    public static IntegerType ToIntegerType(IType type);
    public static IntegerType ToIntegerType(IType type, PredefinedType predefinedType);
    public static IntegerType ToIntegerTypeMaybeUntracked(IType type, PredefinedType predefinedType);
    public static AbstractValue GetFullRange(IType type);
    public static bool ShouldTrack(IType type, IntegerType& integerType);
    [PureAttribute]
public static bool ShouldTrack(ConstantValue constantValue, Int64& value);
    public static bool ShouldTrack(IType type, PredefinedType predefinedType);
    public static bool ShouldTrack(IType type, PredefinedType predefinedType, IntegerType& integerType);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.AbstractValueWithInfo : ValueType {
    [CompilerGeneratedAttribute]
private AbstractValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorType <Error>k__BackingField;
    public static AbstractValueWithInfo MultiplyByZeroResultLeft;
    public static AbstractValueWithInfo MultiplyByZeroResultRight;
    public static AbstractValueWithInfo DivisionByZero;
    public static AbstractValueWithInfo UnknownNoError;
    [NotNullAttribute]
public AbstractValue Value { get; }
    public ErrorType Error { get; }
    public AbstractValueWithInfo(AbstractValue value);
    public AbstractValueWithInfo(AbstractValue value, ErrorType error);
    private static AbstractValueWithInfo();
    [CompilerGeneratedAttribute]
public AbstractValue get_Value();
    [CompilerGeneratedAttribute]
public ErrorType get_Error();
    public sealed virtual bool Equals(AbstractValueWithInfo other);
    public void Deconstruct(AbstractValue& abstractValue, ErrorType& errorType);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.BinaryOperationOperands`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Right>k__BackingField;
    public T Left { get; }
    public T Right { get; }
    public T Item { get; }
    public BinaryOperationOperands`1(T leftOperand, T rightOperand);
    [CompilerGeneratedAttribute]
public T get_Left();
    [CompilerGeneratedAttribute]
public T get_Right();
    public T get_Item(int i);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.CSharpIntValuesAnnotationsUtil : object {
    [CanBeNullAttribute]
public static AbstractValue GetAbstractValueFromAnnotation(IAttributesOwner attributesOwner, ValueRangeAnnotationProvider provider);
    [CanBeNullAttribute]
public static AbstractValue GetAbstractValueFromAnnotation(IAttributesOwner attributesOwner);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.ErrorGroupings : object {
    public static HashSet`1<ErrorType> OverflowErrors;
    public static HashSet`1<ErrorType> ExpressionAlwaysSameValueErrors;
    public static HashSet`1<ErrorType> UselessOperationsErrors;
    private static ErrorGroupings();
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.ErrorType : Enum {
    public int value__;
    public static ErrorType Ok;
    public static ErrorType OverflowInCheckedContext;
    public static ErrorType OverflowInUncheckedContext;
    public static ErrorType Overflow;
    public static ErrorType ExpressionAlwaysTrue;
    public static ErrorType ExpressionAlwaysFalse;
    public static ErrorType DivisionByZero;
    public static ErrorType DivisionByOne;
    public static ErrorType DividendIsZero;
    public static ErrorType MultiplicationByZeroLeft;
    public static ErrorType MultiplicationByOneLeft;
    public static ErrorType AddSubtractZeroLeft;
    public static ErrorType MultiplicationByZeroRight;
    public static ErrorType MultiplicationByOneRight;
    public static ErrorType AddSubtractZeroRight;
    public static ErrorType AbsOperandAlwaysNonNegative;
    public static ErrorType SignAlwaysReturnsMinusOne;
    public static ErrorType SignAlwaysReturnsZero;
    public static ErrorType SignAlwaysReturnsPlusOne;
    public static ErrorType MathClampMinGreaterThanMax;
    public static ErrorType UnreachableCase;
    public static ErrorType ContractViolation;
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.IIntValuesAnalysisResults {
    public IEnumerable`1<ICSharpExpression> OverflowsChecked { get; }
    public IEnumerable`1<ICSharpExpression> OverflowsUnchecked { get; }
    public IEnumerable`1<ICSharpExpression> Overflows { get; }
    public IEnumerable`1<ITreeNode> ExpressionAlwaysTrue { get; }
    public IEnumerable`1<ITreeNode> ExpressionAlwaysFalse { get; }
    public IEnumerable`1<ISwitchExpressionArm> UnreachableArms { get; }
    public IEnumerable`1<ISwitchCaseLabel> UnreachableCaseLabels { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<ICSharpExpression, bool>> MultiplicationByZero { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<ICSharpExpression, bool>> MultiplicationByOne { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<ICSharpExpression, bool>> AddSubtractZero { get; }
    public IEnumerable`1<ICSharpExpression> DivisionByOne { get; }
    public IEnumerable`1<ICSharpExpression> DividendIsZero { get; }
    public IEnumerable`1<ICSharpExpression> UselessMathAbs { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<ICSharpExpression, int>> UselessMathSign { get; }
    public IEnumerable`1<ICSharpExpression> MathClampMinGreaterThanMax { get; }
    public IEnumerable`1<ICSharpExpression> DivisionByZero { get; }
    public IEnumerable`1<ICSharpExpression> ContractViolations { get; }
    public abstract virtual IEnumerable`1<ICSharpExpression> get_OverflowsChecked();
    public abstract virtual IEnumerable`1<ICSharpExpression> get_OverflowsUnchecked();
    public abstract virtual IEnumerable`1<ICSharpExpression> get_Overflows();
    public abstract virtual IEnumerable`1<ITreeNode> get_ExpressionAlwaysTrue();
    public abstract virtual IEnumerable`1<ITreeNode> get_ExpressionAlwaysFalse();
    public abstract virtual IEnumerable`1<ISwitchExpressionArm> get_UnreachableArms();
    public abstract virtual IEnumerable`1<ISwitchCaseLabel> get_UnreachableCaseLabels();
    public abstract virtual IEnumerable`1<ValueTuple`2<ICSharpExpression, bool>> get_MultiplicationByZero();
    public abstract virtual IEnumerable`1<ValueTuple`2<ICSharpExpression, bool>> get_MultiplicationByOne();
    public abstract virtual IEnumerable`1<ValueTuple`2<ICSharpExpression, bool>> get_AddSubtractZero();
    public abstract virtual IEnumerable`1<ICSharpExpression> get_DivisionByOne();
    public abstract virtual IEnumerable`1<ICSharpExpression> get_DividendIsZero();
    public abstract virtual IEnumerable`1<ICSharpExpression> get_UselessMathAbs();
    public abstract virtual IEnumerable`1<ValueTuple`2<ICSharpExpression, int>> get_UselessMathSign();
    public abstract virtual IEnumerable`1<ICSharpExpression> get_MathClampMinGreaterThanMax();
    public abstract virtual IEnumerable`1<ICSharpExpression> get_DivisionByZero();
    public abstract virtual IEnumerable`1<ICSharpExpression> get_ContractViolations();
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.IntegerType : Enum {
    public int value__;
    public static IntegerType Sbyte;
    public static IntegerType Byte;
    public static IntegerType Short;
    public static IntegerType Ushort;
    public static IntegerType Int;
    public static IntegerType Uint;
    public static IntegerType Long;
    public static IntegerType Ulong;
    public static IntegerType NotInteger;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.IntegerTypeInfo : ValueType {
    public int Bits;
    public bool Signed;
    public IntegerTypeInfo(int bits, bool signed);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.IntValuesAnalysisContext : object {
    [NotNullAttribute]
private Dictionary`2<IDeclaredElement, AbstractValue> myVariables;
    [NotNullAttribute]
private AbstractValue myCurrentExpressionResult;
    [NotNullAttribute]
private HashSet`1<IDeclaredElement> myCompletelyUnknown;
    private static int VariablesCountLimit;
    [CompilerGeneratedAttribute]
private AssertionConditionInfo <LastAssertionCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReachable>k__BackingField;
    [CanBeNullAttribute]
public AssertionConditionInfo LastAssertionCondition { get; public set; }
    public bool IsReachable { get; private set; }
    private IntValuesAnalysisContext(IntValuesAnalysisContext otherContext);
    [CompilerGeneratedAttribute]
public AssertionConditionInfo get_LastAssertionCondition();
    [CompilerGeneratedAttribute]
public void set_LastAssertionCondition(AssertionConditionInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
    [CompilerGeneratedAttribute]
private void set_IsReachable(bool value);
    public virtual int GetHashCode();
    public void MakeUnreachable();
    public static AssertionConditionInfo CreateAssertionConditionInfo(IInvocationExpression invocationExpression, IntValuesAnalysisContext assertionIsTrueContext, BinaryOperationOperands`1<IDeclaredElement> localElements);
    public void ApplyResultsOfLastAssertion(IInvocationExpression invocationExpression);
    public static IntValuesAnalysisContext MakeInitialContextFromAnnotations(IDeclaredElement graphDeclaredElement);
    private bool Equals(IntValuesAnalysisContext other);
    public virtual bool Equals(object obj);
    public void SetCurrentExpressionResult(AbstractValue value);
    [NotNullAttribute]
public AbstractValue GetCurrentExpressionResult();
    public IntValuesAnalysisContext Clone();
    [NotNullAttribute]
public AbstractValue GetValue(IDeclaredElement element);
    public IReadOnlyDictionary`2<IDeclaredElement, AbstractValue> GetVariableValues();
    public void SetValue(IDeclaredElement element, AbstractValue newValue);
    public void DeleteValue(IDeclaredElement element);
    private bool IsCompletelyUnknown(IDeclaredElement element);
    public void SetCompletelyUnknown(IDeclaredElement element);
    public void SetCompletelyUnknownWithoutDeletingValue(IDeclaredElement element);
    public bool ContainsVariable(IDeclaredElement key);
    [CanBeNullAttribute]
private AbstractValue TryGetValue(IDeclaredElement key);
    public string Dump();
    private void Merge(IntValuesAnalysisContext otherContext);
    [CompilerGeneratedAttribute]
internal static bool <Merge>g__MergeIsReachable|36_0(bool lhs, bool rhs);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IntValuesAnalysis.IntValuesAnalysisInspector : ControlFlowGraphInspector`1<IntValuesAnalysisContext> {
    private IControlFlowContextFactory`1<IntValuesAnalysisContext> myContextFactory;
    internal bool CheckOverflowsInProject;
    private Dictionary`2<IParametersOwner, ClosureInfo> myClosureInfoGraph;
    [NotNullAttribute]
private CSharpControlFlowGraph myControlFlowGraph;
    private Dictionary`2<ITreeNode, SwitchConditionTemporaryLocalVariable> mySwitchConditionTemporaryLocalVariables;
    private AnalysisResults myAnalysisResults;
    private CSharpStronglyConnectedComponentsTarjan myTarjan;
    private InterruptibleLazy`1<Byte[]> myComponentIds;
    private ValueRangeAnnotationProvider myValueRangeAnnotationProvider;
    private AssertionMethodAnnotationProvider myAssertionMethodProvider;
    private AssertionConditionAnnotationProvider myAssertionConditionAnnotationProvider;
    private PredefinedType myPredefinedType;
    public IntValuesAnalysisInspector(CSharpControlFlowGraph controlFlowGraph, IControlFlowContextFactory`1<IntValuesAnalysisContext> contextFactory, bool checkOverflows, PredefinedType predefinedType);
    public IIntValuesAnalysisResults GetAnalysisResults();
    protected virtual bool ShouldInspectSingleLeaf(ControlFlowElement element);
    protected virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement element, IntValuesAnalysisContext currentContext);
    private static void ResetStateOfOutOfScopeVariables(IntValuesAnalysisContext context, IControlFlowEdge edge);
    public string DumpEdgeContext(IControlFlowEdge edge);
    public string DumpElement(IControlFlowElement element);
    [CompilerGeneratedAttribute]
private Byte[] <.ctor>b__20_0();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.IsExpressionPatternMatchingExitMultiplexor : CSharpControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private bool <PatternMatchingResult>k__BackingField;
    [NotNullAttribute]
public IIsExpression IsExpression { get; }
    public bool PatternMatchingResult { get; }
    public IsExpressionPatternMatchingExitMultiplexor(IIsExpression referencedElement, bool patternMatchingResult);
    public IIsExpression get_IsExpression();
    [CompilerGeneratedAttribute]
public bool get_PatternMatchingResult();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.MemorySnapshot : object {
    private static int EXPRESSION_INDEX;
    internal static int MAX_TYPES_NUMBER;
    private CSharpControlFlowVariableValue myExpressionValue;
    [NotNullAttribute]
private CSharpControlFlowVariableValue[] myVariableValues;
    private BitVector64 myExpressionType;
    private BitVectorArray myTypeSpecifications;
    private BitVectorArray myNotTypeSpecifications;
    private int myHashCode;
    public int Length { get; }
    [DebuggerBrowsableAttribute("0")]
public CSharpControlFlowVariableValue ExpressionState { get; }
    private int ExpressionNotTypeIndex { get; }
    public object RawArray { get; }
    public MemorySnapshot(int variablesCount, int typesPerVariable);
    private MemorySnapshot(CSharpControlFlowVariableValue expressionValue, CSharpControlFlowVariableValue[] variableValues, BitVector64 expressionType, BitVectorArray typeSpecifications, BitVectorArray notTypeSpecifications);
    public int get_Length();
    public CSharpControlFlowVariableValue get_ExpressionState();
    public CSharpControlFlowVariableValue GetVariableState(int index);
    public CSharpControlFlowVariableValue GetState(int index);
    [NotNullAttribute]
[PureAttribute]
public MemorySnapshot SetExpressionState(CSharpControlFlowVariableValue value);
    [NotNullAttribute]
[PureAttribute]
public MemorySnapshot SetVariablesStates(int variableIndex1, int variableIndex2, CSharpControlFlowVariableValue value1, CSharpControlFlowVariableValue value2);
    [NotNullAttribute]
[PureAttribute]
public MemorySnapshot SetVariableState(int variableIndex, CSharpControlFlowVariableValue value);
    [NotNullAttribute]
[PureAttribute]
public MemorySnapshot SetState(int index, CSharpControlFlowVariableValue value);
    [NotNullAttribute]
[PureAttribute]
public MemorySnapshot SetVariableStates(Int32[] indices, Func`2<CSharpControlFlowVariableValue, CSharpControlFlowVariableValue> mutator);
    [NotNullAttribute]
public IList`1<int> GetTypeSpecifications(int index);
    [NotNullAttribute]
public IList`1<int> GetVariableTypeSpecifications(int variableNotIndex);
    [NotNullAttribute]
public IList`1<int> GetVariableNotTypeSpecifications(int variableIndex);
    private int get_ExpressionNotTypeIndex();
    public object get_RawArray();
    [NotNullAttribute]
public MemorySnapshot SetExpressionTypeSpecification(int typeIndex, bool clearOtherTypes);
    [NotNullAttribute]
public MemorySnapshot SetVariableTypeSpecification(int variableIndex, int typeIndex, bool clearOtherTypes);
    [NotNullAttribute]
public MemorySnapshot SetVariableNotTypeSpecification(int variableIndex, int typeIndex, bool clearOtherTypes);
    [NotNullAttribute]
public MemorySnapshot ClearExpressionTypeSpecifications();
    [NotNullAttribute]
public MemorySnapshot ClearVariableTypeSpecifications(int variableIndex);
    [NotNullAttribute]
public MemorySnapshot ClearVariableTypeSpecifications(Int32[] variableIndices);
    [NotNullAttribute]
public MemorySnapshot CopyTypeSpecifications(int fromIndex, int toIndex);
    public static bool op_Equality(MemorySnapshot snapshot1, MemorySnapshot snapshot2);
    public static bool op_Inequality(MemorySnapshot snapshot1, MemorySnapshot snapshot2);
    public virtual bool Equals(object obj);
    private int CalculateHashCode();
    public virtual int GetHashCode();
}
[DebuggerDisplayAttribute("MemorySnapshotHive(Snapshots = {Count,nq})")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.MemorySnapshotHive : object {
    [DebuggerBrowsableAttribute("3")]
private HashSet`1<MemorySnapshot> mySnapshots;
    [CompilerGeneratedAttribute]
private int <SnaphotLength>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
public int Count { get; }
    [DebuggerBrowsableAttribute("0")]
public int SnaphotLength { get; }
    private MemorySnapshotHive(int length, int capacity);
    [NotNullAttribute]
public static MemorySnapshotHive CreateInitialHive(int variablesCount, int typesPerVariable);
    [NotNullAttribute]
public static MemorySnapshotHive CreateEmptyHive(int variablesCount);
    [NotNullAttribute]
public static MemorySnapshotHive Create(int length, int capacity, IEnumerable`1<MemorySnapshot> snapshots);
    private void Add(MemorySnapshot snapshot);
    public int get_Count();
    [CompilerGeneratedAttribute]
public int get_SnaphotLength();
    public bool Compare(MemorySnapshotHive otherHive);
    [NotNullAttribute]
public MemorySnapshotHive Mutate(Func`2<MemorySnapshot, MemorySnapshot> mutator);
    [NotNullAttribute]
public MemorySnapshotHive Mutate(TData data, Func`3<MemorySnapshot, TData, MemorySnapshot> mutator);
    [NotNullAttribute]
public MemorySnapshotHive Mutate(TData1 data1, TData2 data2, Func`4<MemorySnapshot, TData1, TData2, MemorySnapshot> mutator);
    [NotNullAttribute]
public MemorySnapshotHive Mutate(TData data, Func`3<MemorySnapshot, TData, MemorySnapshotPair> mutator);
    [NotNullAttribute]
public MemorySnapshotHive Mutate(TData1 data1, TData2 data2, Func`4<MemorySnapshot, TData1, TData2, MemorySnapshotPair> mutator);
    [NotNullAttribute]
public MemorySnapshotHive Mutate(Func`2<MemorySnapshot, HybridCollection`1<MemorySnapshot>> mutator);
    [PureAttribute]
public bool CanVariableBeInState(int variableIndex, CSharpControlFlowVariableValue value);
    [PureAttribute]
public bool HasContainerElementInfo(int variableIndex);
    [PureAttribute]
public bool CanExpressionBeInState(CSharpControlFlowVariableValue value);
    [PureAttribute]
public bool IsExpressionDefinitelyInState(CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public bool IsExpressionDefinitelyIsStateWithoutContainerFlags(CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public Nullable`1<CSharpControlFlowVariableValue> GetExpressionDefiniteState(CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public bool IsVariableDefinitelyInState(int variableIndex, CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public bool IsVariableDefinitelyInStateWithoutContainerFlags(int variableIndex, CSharpControlFlowVariableValue value, CSharpControlFlowVariableValue ignoreMask);
    [PureAttribute]
public Nullable`1<CSharpControlFlowVariableValue> GetVariableDefiniteState(int variableIndex, CSharpControlFlowVariableValue ignoreMask);
    public void SplitByNullCondition(int index, bool optimistic, MemorySnapshotHive& isNull, MemorySnapshotHive& isNotNull);
    public void SplitMutate(MemorySnapshotHive& leftHive, MemorySnapshotHive& rightHive, Action`3<MemorySnapshot, Action`1<MemorySnapshot>, Action`1<MemorySnapshot>> action);
    public void SplitByBooleanCondition(int index, MemorySnapshotHive& trueHive, MemorySnapshotHive& falseHive);
    public void SplitByEquality(int i, int j, bool isReferenceEqualityCheck, bool isTransitiveWithNullCheck, MemorySnapshotHive& equalsHive, MemorySnapshotHive& notEqualsHive);
    public MemorySnapshotHive ResetVariablesState(Int32[] indices);
    public sealed virtual IEnumerator`1<MemorySnapshot> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.MemorySnapshotPair : ValueType {
    public MemorySnapshot Snapshot1;
    public MemorySnapshot Snapshot2;
    public MemorySnapshotPair(MemorySnapshot snapshot);
    public MemorySnapshotPair(MemorySnapshot snapshot1, MemorySnapshot snapshot2);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.AnnotatedAnonymousFunctionType : object {
    [NotNullAttribute]
private CSharpCompilerNullableInspector myParentInspector;
    [NotNullAttribute]
private ICSharpControlFlowGraph myClosureControlFlowGraph;
    [NotNullAttribute]
private IAnonymousFunctionExpression myAnonymousFunctionExpression;
    [NotNullAttribute]
private IAnonymousFunctionTypeImpl myUniversalContextAnonymousFunctionType;
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private NullableContext myNullableContext;
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private IList`1<IExpressionType> myCachedReturnValues;
    private bool myCachedIsRefReturn;
    private bool myITypeIsCached;
    [CanBeNullAttribute]
private IType myIType;
    public ICollection`1<IExpressionType> ReturnValues { get; }
    public bool IsNonCacheable { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public bool IsAsync { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    public IReadOnlyList`1<Pair`2<IType, ParameterKind>> ParameterTypesAndKinds { get; }
    public bool HasParametersList { get; }
    public IType ExplicitReturnType { get; }
    public ReferenceKind ExplicitReturnKind { get; }
    public ITreeNode VerificationScope { get; }
    public AnnotatedAnonymousFunctionType(CSharpCompilerNullableInspector parentInspector, ICSharpControlFlowGraph closureControlFlowGraph, IAnonymousFunctionExpression anonymousFunctionExpression, IResolveContext resolveContext, NullableContext nullableContext);
    private AnnotatedAnonymousFunctionType(AnnotatedAnonymousFunctionType originalFunction, IResolveContext newResolveContext);
    public void UpdateFromClosureInspection(AnnotatedAnonymousFunctionType inspectedFunction);
    [NotNullAttribute]
[ItemNotNullAttribute]
private ICollection`1<IExpressionType> GetGlobalContextReturnTypes(Boolean& isRefReturn);
    public sealed virtual ICollection`1<IExpressionType> get_ReturnValues();
    public sealed virtual bool get_IsNonCacheable();
    public bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual IType ToIType();
    private IType CalculateIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual CSharpLanguageLevel get_LanguageLevel();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsAsync();
    public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    public sealed virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> get_ParameterTypesAndKinds();
    public sealed virtual bool get_HasParametersList();
    public sealed virtual IReadOnlyList`1<IParameter> GetImplicitLambdaParameters();
    public sealed virtual bool HasImplicitLambdaParameters();
    public sealed virtual IType get_ExplicitReturnType();
    public sealed virtual ReferenceKind get_ExplicitReturnKind();
    public sealed virtual bool IsReturnTypeConvertibleTo(IDelegate delegate, ISubstitution substitution);
    public sealed virtual bool IsSignatureConvertibleTo(IDelegate delegate, ISubstitution substitution);
    public sealed virtual IType InferredResultTypeWithoutAsync();
    public sealed virtual IType InferredResultTypeWithoutAsync(bool allowFunctionTypes, Boolean& isRefReturn, ICollection`1& returnValues);
    private ICollection`1<IExpressionType> GetReturnValues(Boolean& isRefReturn);
    public virtual ITreeNode get_VerificationScope();
    public virtual bool VerifyFunctionType(IDelegate delegate, ISubstitution substitution);
    public sealed virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
    [NotNullAttribute]
[ItemNotNullAttribute]
protected virtual IList`1<IExpressionType> CalculateReturnValues(CSharpCompilerNullableInspector closureInspector, Boolean& isRefReturn);
    public void InspectBodyWithNullableAnalysisAndCalculateReturnTypes();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.AnnotatedDeconstructionResolveContext : ScopeAnnotatedResolveContext`1<IDeconstructionReference> {
    public AnnotatedDeconstructionResolveContext(ITupleExpression deconstructionTarget, Dictionary`2<IExpression, IExpressionType> annotatedExpressionTypes);
    public AnnotatedDeconstructionResolveContext(IDeclarationExpression deconstructionTarget, Dictionary`2<IExpression, IExpressionType> annotatedExpressionTypes);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.AnnotatedResolveContext : ResolveContext {
    [NotNullAttribute]
private IReadOnlyDictionary`2<IExpression, IExpressionType> myAnnotatedExpressionTypes;
    public AnnotatedResolveContext(IReference referenceToReResolveWithAnnotations, IReference qualifierReference, IReadOnlyDictionary`2<IExpression, IExpressionType> annotatedExpressionTypes);
    public AnnotatedResolveContext(IReference referenceToReResolveWithAnnotations, IReference qualifierReference, IReference containingArgumentsOwnerReference, ISubstitution containingArgumentsOwnerSubstitution, Dictionary`2<IExpression, IExpressionType> annotatedExpressionTypes);
    private AnnotatedResolveContext(IPsiModule psiModule, IReadOnlyDictionary`2<IExpression, IExpressionType> annotatedExpressionTypes, AnnotatedCalculationProcess calculationProcess);
    public virtual IExpressionType ExpressionType(IManagedExpression expression);
    protected virtual ResolveContext CreateForkedResolveContext(ICalculationProcess forkedCalculationProcess);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.AnnotatedTargetTypedExpressionResolveContext : ResolveContext {
    [NotNullAttribute]
private CSharpCompilerNullableInspector myInspector;
    [NotNullAttribute]
private AnnotatedCalculationProcess myAnnotatedCalculationProcess;
    [NotNullAttribute]
public IReadOnlyDictionary`2<IReference, ISubstitution> ReInferredSubstitutions { get; }
    public AnnotatedTargetTypedExpressionResolveContext(IPsiModule psiModule, CSharpCompilerNullableInspector inspector, IReadOnlyDictionary`2<IReference, ISubstitution> reInferredTargetTypedSubstitutions);
    private AnnotatedTargetTypedExpressionResolveContext(IPsiModule psiModule, CSharpCompilerNullableInspector inspector, AnnotatedCalculationProcess calculationProcess);
    public IReadOnlyDictionary`2<IReference, ISubstitution> get_ReInferredSubstitutions();
    public virtual IExpressionType ExpressionType(IManagedExpression expression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.AnnotatedTypeInferenceResolveContext : ResolveContext {
    [NotNullAttribute]
private Dictionary`2<IExpression, IExpressionType> myAnnotatedExpressionTypes;
    public AnnotatedTypeInferenceResolveContext(IPsiModule psiModule, Dictionary`2<IExpression, IExpressionType> annotatedExpressionTypes);
    private AnnotatedTypeInferenceResolveContext(AnnotatedTypeInferenceResolveContext originalContext, ICalculationProcess calculationProcess);
    public virtual IExpressionType ExpressionType(IManagedExpression expression);
    protected virtual ResolveContext CreateForkedResolveContext(ICalculationProcess forkedCalculationProcess);
    public void UpdateAnnotatedAnonymousFunction(IAnonymousFunctionExpression anonymousFunctionExpression, AnnotatedAnonymousFunctionType annotatedType);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.CastConversionPlaceholder : object {
    [NotNullAttribute]
private ICastExpression myCastExpression;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsConstant { get; }
    public bool IsWritable { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ReferenceKind ReferenceKind { get; }
    public CastConversionPlaceholder(ICastExpression castExpression);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual bool IsValid();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual ReferenceKind get_ReferenceKind();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.ClosureNullableContextFactory : NullableContextFactory {
    private NullableContext myClosureContext;
    private int myFirstClosureSlot;
    public NullableContext InitialContext { get; }
    public ClosureNullableContextFactory(IPsiModule psiModule, NullableContext closureContext, int firstClosureSlot);
    public virtual NullableContext get_InitialContext();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.CSharpCompilerNullableInspector : ControlFlowGraphInspector`1<NullableContext> {
    private static int MaxSlotDepth;
    internal static NullableAnnotation DynamicNotNullableAnnotation;
    internal static NullableAnnotation PossiblyDefaultStructAnnotation;
    [CanBeNullAttribute]
private CSharpCompilerNullableInspector myParentInspector;
    [CanBeNullAttribute]
private JetHashSet`1<int> myVariablesWithWriteAccesses;
    private bool myIsDelayedClosure;
    private Dictionary`2<IDeclaredElement, TypeSymbolWithAnnotations> myVariableTypes;
    internal VariableIdentifier[] VariableBySlot;
    [NotNullAttribute]
internal TrackableStructCache TrackableStructCache;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, DecisionDagInfo> myDagInfoBySourceElement;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, OneToSetMap`2<DagEvaluation, DagTempVariable>> myDagVariablesSourceMap;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, Dictionary`2<DagNonNullTest, NullableAnnotation>> myDagNonNullTestStateMap;
    [NotNullAttribute]
private Dictionary`2<ITryStatement, NonMonotonicStateTransferContext> myTryBlockExceptionContexts;
    [NotNullAttribute]
private Dictionary`2<ICatchClause, NonMonotonicStateTransferContext> myCatchBlockExceptionContexts;
    [NotNullAttribute]
private Dictionary`2<ITryStatement, NonMonotonicStateTransferContext> myFinallyBlockContexts;
    [NotNullAttribute]
private Dictionary`2<ITryStatement, NullableContext> myTryRegularEndpointContexts;
    private int myLastClosureSlot;
    private int myNextVariableSlot;
    [NotNullAttribute]
private Func`2<ITreeNode, ICSharpControlFlowGraph> myGraphBuilder;
    [CanBeNullAttribute]
private ICSharpDeclaration myOwnerDeclaration;
    [NotNullAttribute]
private ICSharpTreeNode myOwnerNode;
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private ICSharpTypeConversionRule myTypeConversionRule;
    [NotNullAttribute]
private ICSharpTypeConversionRule myTypeConversionRuleWithNullability;
    [NotNullAttribute]
private ICSharpTypeConstraintsVerifier myTypeConstraintsVerifier;
    [NotNullAttribute]
private IPsiModule myPsiModule;
    [NotNullAttribute]
private LocalFunctionAnalysis myLocalFunctionAnalysis;
    [NotNullAttribute]
private Dictionary`2<IAnonymousFunctionExpression, JetHashSet`1<int>> myWriteAccessedSlotsInClosures;
    [CanBeNullAttribute]
private Dictionary`2<ITypeMember, NullableAnnotation> myMemberStatesInConstructor;
    private CSharpLanguageLevel myLanguageLevel;
    private ValueAnalysisMode myValueAnalysisMode;
    private bool myIgnoreNonNullableAnnotationsInValueAnalysis;
    [NotNullAttribute]
private CompilerFlowAnnotationProvider myCompilerAnnotationsProvider;
    [NotNullAttribute]
private NullnessProvider myNullnessProvider;
    [NotNullAttribute]
private ContainerElementNullnessProvider myContainerElementNullnessProvider;
    [NotNullAttribute]
private MemberNotNullAnnotationProvider myMemberNotNullAnnotationProvider;
    [NotNullAttribute]
private NotNullIfNotNullAnnotationProvider myNotNullIfNotNullAnnotationProvider;
    [NotNullAttribute]
private ContractAnnotationProvider myContractAnnotationProvider;
    [NotNullAttribute]
private AssertionMethodAnnotationProvider myAssertionMethodAnnotationProvider;
    [NotNullAttribute]
private CSharpClosureExecutionBehaviorInspector myClosureBehaviorInspector;
    [NotNullAttribute]
private Dictionary`2<VariableIdentifier, int> myVariableSlot;
    [NotNullAttribute]
private Dictionary`2<ICreationExpression, ObjectCreationDeclaredElementPlaceholder> myObjectCreationPlaceholders;
    [NotNullAttribute]
private Dictionary`2<ICastExpression, CastConversionPlaceholder> myCastWithTupleConversionPlaceholders;
    [NotNullAttribute]
private Dictionary`2<IWithExpression, WithExpressionDeclaredElementPlaceholder> myWithExpressionPlaceholders;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, PatternMatchingGoverningExpressionDeclaredElementPlaceholder> myPatternMatchingGoverningExpressionPlaceholders;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<IControlFlowElement> myInvestigatedUnreachableControlFlowElements;
    [NotNullAttribute]
[ItemNotNullAttribute]
private JetHashSet`1<ICSharpTreeNode> myAssignmentNullabilityMismatchesCS8600;
    [NotNullAttribute]
[ItemNotNullAttribute]
private JetHashSet`1<ICSharpTreeNode> myAssignmentNullabilityMismatchesCS8601;
    [NotNullAttribute]
[ItemNotNullAttribute]
private JetHashSet`1<ICSharpTreeNode> myAssignmentNullabilityMismatchesCS8625;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private OneToListMap`2<ITreeNode, ValueTuple`2<IExpressionType, IType>> myAssignmentNullabilityMismatchesCS8619;
    [NotNullAttribute]
[ItemNotNullAttribute]
private JetHashSet`1<ICSharpExpression> myPossibleNullValueInThrowExpressionOrStatement;
    [NotNullAttribute]
[ItemNotNullAttribute]
private JetHashSet`1<ICSharpTreeNode> myDisallowNullAttributeForbidsMaybeNullAssignment;
    [NotNullAttribute]
private Dictionary`2<ICSharpTreeNode, MethodGroupConversionParameterWarningInfo> myNullabilityMismatchInParameterTypeOfTargetDelegate;
    [NotNullAttribute]
private Dictionary`2<ICSharpTreeNode, MethodGroupConversionReturnTypeWarningInfo> myNullabilityMismatchInReturnTypeOfTargetDelegate;
    [NotNullAttribute]
private Dictionary`2<ICreationExpressionInitializer, ITypeMember> myPossibleNullReferenceInitializerDereferences;
    [NotNullAttribute]
private JetHashSet`1<IDeclarationExpression> myForEachIterationVariablesPossibleNullInitializations;
    [NotNullAttribute]
private JetHashSet`1<ICSharpTreeNode> myPossibleNullNullableValueAccess;
    [NotNullAttribute]
private JetHashSet`1<ICSharpTreeNode> myPossibleNullUnboxings;
    [NotNullAttribute]
private OneToSetMap`2<ICSharpTreeNode, bool> myPossibleNullDereferences;
    [NotNullAttribute]
private JetHashSet`1<ICSharpExpression> myPossibleNullReturns;
    [NotNullAttribute]
private JetHashSet`1<ICSharpTreeNode> myDoesNotReturnFunctionExits;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, bool>> myPossibleNullArguments;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<IExpressionType, IType, IParameter>> myNullabilityMismatchInArguments;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<ITypeParameter, IType, IReadOnlyList`1<TypeArgumentValidationResult>>> myTypeArgumentsNullabilityViolations;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private OneToSetMap`2<ValueTuple`2<ICSharpExpression, bool>, IParameter> myParameterConditionalDisallowNullMismatches;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private OneToSetMap`2<ValueTuple`2<ICSharpTreeNode, bool>, ITypeMember> myFunctionExitsWithConditionallyDisallowedMemberStates;
    [NotNullAttribute]
private OneToSetMap`2<ICSharpTreeNode, IParameter> myFunctionExitsWithDisallowedParameterStates;
    [NotNullAttribute]
private OneToSetMap`2<ICSharpTreeNode, ITypeMember> myFunctionExitsWithUnconditionalDisallowedMemberStates;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ITypeMember> myUninitializedNotNullableMembers;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private Dictionary`2<ISwitchExpression, ValueTuple`2<bool, string>> mySwitchExpressionsNotExhaustiveOnNull;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, IParameter> myReturnMustBeNotNullBecauseParameterIsNotNull;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, IParameter>> myParameterMustBeNotNullBecauseParameterIsNotNull;
    [NotNullAttribute]
private Dictionary`2<IConditionalAccessExpression, NullableAnnotation> myRedundantConditionalAccessQualifierStates;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ICSharpExpression> myPossibleNullReferenceExceptions;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ICSharpTreeNode> myNullToNotNullableEntityAssignments;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, TypeSymbolWithAnnotations> myAnnotatedExpressionTypes;
    [NotNullAttribute]
private Dictionary`2<IReference, ISubstitution> myInferredSubstitutions;
    [NotNullAttribute]
private Dictionary`2<IReference, ISubstitution> myInferredLongValueTupleSubstitutions;
    [NotNullAttribute]
private Dictionary`2<IReference, ISubstitution> myInferredTargetTypedNewSubstitutions;
    [NotNullAttribute]
private Dictionary`2<IReference, SpecialIndexer> myInferredIndexers;
    [NotNullAttribute]
private Dictionary`2<IReference, IMethod> myInferredAnonymousDelegateInvokeMethods;
    [NotNullAttribute]
private Dictionary`2<IOperatorReference, DelegatePredefinedOperator> myInferredDelegateOperators;
    [NotNullAttribute]
private Dictionary`2<ICSharpClosure, CSharpCompilerNullableInspector> myClosureInspectors;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, IExpressionType> myDagOwnersToInferredGoverningTypes;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, JetHashSet`1<DagEvaluation>> myDagOwnersToAnnotatedNodes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ISuppressNullableWarningExpression> myRedundantSuppressNullableWarningExpressions;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ISwitchExpressionArm> myUnreachableSwitchExpressionArms;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ICSharpExpression> myUnreachableTargetTypedConditionalExpressionBranches;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private Dictionary`2<ILocalFunction, ValueTuple`2<bool, NullableContext>> myLocalFunctionCallContexts;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ITypeOwner> myMustBeNullableLocals;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ITypeOwner> myLocalsContributingAnnotationsToTypeInference;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ITypeOwner> myCanBeMadeNotAnnotatedLocals;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, NullableAnnotation> myNullCoalescingRightOperandWithLeftState;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, NullableAnnotation> myEqualsNullCheckWithCheckedValueState;
    [NotNullAttribute]
private Dictionary`2<ICSharpExpression, NullableAnnotation> myNotNullChecksWithCheckedValueState;
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<ILocalFunction> myLocalFunctionsConvertedToDelegates;
    private bool myReturnTypeCanBeNotAnnotated;
    public IReadOnlySet`1<ICSharpTreeNode> AssignmentNullabilityMismatchesCS8600 { get; }
    public IReadOnlySet`1<ICSharpTreeNode> AssignmentNullabilityMismatchesCS8601 { get; }
    public IReadOnlySet`1<ICSharpTreeNode> AssignmentNullabilityMismatchesCS8625 { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneToListMap`2<ITreeNode, ValueTuple`2<IExpressionType, IType>> AssignmentNullabilityMismatchesCS8619 { get; }
    public IReadOnlySet`1<ICSharpExpression> PossibleNullValueInThrowExpressionOrStatement { get; }
    public IReadOnlySet`1<ICSharpTreeNode> DisallowNullAttributeForbidsMaybeNullAssignment { get; }
    public IReadOnlyDictionary`2<ICSharpTreeNode, MethodGroupConversionParameterWarningInfo> NullabilityMismatchInParameterTypeOfTargetDelegate { get; }
    public IReadOnlyDictionary`2<ICSharpTreeNode, MethodGroupConversionReturnTypeWarningInfo> NullabilityMismatchInReturnTypeOfTargetDelegate { get; }
    public IReadOnlySet`1<IDeclarationExpression> ForEachIterationVariablesPossibleNullInitializations { get; }
    public IReadOnlySet`1<ICSharpTreeNode> PossibleNullNullableValueAccess { get; }
    public IReadOnlySet`1<ICSharpTreeNode> PossibleNullUnboxings { get; }
    public OneToSetMap`2<ICSharpTreeNode, bool> PossibleNullDereferences { get; }
    public IReadOnlySet`1<ICSharpExpression> PossibleNullReturns { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, bool>> PossibleNullArguments { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<IExpressionType, IType, IParameter>> NullabilityMismatchInArguments { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<ITypeParameter, IType, IReadOnlyList`1<TypeArgumentValidationResult>>> TypeArgumentsNullabilityViolations { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneToSetMap`2<ValueTuple`2<ICSharpExpression, bool>, IParameter> ParameterConditionalDisallowNullMismatches { get; }
    public IReadOnlySet`1<ICSharpTreeNode> DoesNotReturnFunctionExits { get; }
    public OneToSetMap`2<ICSharpTreeNode, IParameter> FunctionExitsWithDisallowedParameterStates { get; }
    public OneToSetMap`2<ICSharpTreeNode, ITypeMember> FunctionExitsWithUnconditionalDisallowedMemberStates { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneToSetMap`2<ValueTuple`2<ICSharpTreeNode, bool>, ITypeMember> FunctionExitsWithConditionallyDisallowedMemberStates { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<ISwitchExpression, ValueTuple`2<bool, string>> SwitchExpressionsNotExhaustiveOnNull { get; }
    public IReadOnlyDictionary`2<ICreationExpressionInitializer, ITypeMember> PossibleNullReferenceInitializerDereferences { get; }
    public IReadOnlyDictionary`2<ICSharpExpression, IParameter> ReturnMustBeNotNullBecauseParameterIsNotNull { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, IParameter>> ParameterMustBeNotNullBecauseParameterIsNotNull { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<IConditionalAccessExpression, bool>> RedundantConditionalAccessExpressions { get; }
    public HashSet`1<ICSharpExpression> PossibleNullReferenceExceptions { get; }
    public HashSet`1<ICSharpTreeNode> NullToNotNullableEntityAssignments { get; }
    public HashSet`1<ITypeOwner> CanBeMadeNotAnnotatedLocals { get; }
    public HashSet`1<ITypeMember> UninitializedNotNullableMembers { get; }
    public HashSet`1<ISuppressNullableWarningExpression> RedundantSuppressNullableWarningExpressions { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlySet`1<ValueTuple`2<ICSharpExpression, bool>> UnreachableNullCoalescingOperands { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<ICSharpExpression, ValueTuple`2<ConstantExpressionValue, bool>> ConditionIsAlwaysTrueOrFalseExpressions { get; }
    public IEnumerable`1<IDeclaration> ReturnTypeCanBeNotAnnotated { get; }
    private CSharpCompilerNullableInspector(CSharpCompilerNullableInspector baseInspector, LocalFunctionAnalysis localFunctionAnalysis);
    internal CSharpCompilerNullableInspector(CSharpCompilerNullableInspector baseInspector, ICSharpControlFlowGraph controlFlowGraph, ICSharpClosure closureDeclaration, IResolveContext resolveContext, NullableContext closureContext, bool isDelayedClosure);
    private CSharpCompilerNullableInspector(ICSharpControlFlowGraph controlFlowGraph, IControlFlowContextFactory`1<NullableContext> contextFactory, ValueAnalysisMode valueAnalysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis, IResolveContext resolveContext, Func`2<ITreeNode, ICSharpControlFlowGraph> graphBuilder, LocalFunctionAnalysis localFunctionAnalysis);
    internal static bool CanBePossiblyDefaultStruct(Nullable`1<NullableAnnotation> annotation);
    public sealed virtual IReadOnlySet`1<ICSharpTreeNode> get_AssignmentNullabilityMismatchesCS8600();
    public sealed virtual IReadOnlySet`1<ICSharpTreeNode> get_AssignmentNullabilityMismatchesCS8601();
    public sealed virtual IReadOnlySet`1<ICSharpTreeNode> get_AssignmentNullabilityMismatchesCS8625();
    public sealed virtual OneToListMap`2<ITreeNode, ValueTuple`2<IExpressionType, IType>> get_AssignmentNullabilityMismatchesCS8619();
    public sealed virtual IReadOnlySet`1<ICSharpExpression> get_PossibleNullValueInThrowExpressionOrStatement();
    public sealed virtual IReadOnlySet`1<ICSharpTreeNode> get_DisallowNullAttributeForbidsMaybeNullAssignment();
    public sealed virtual IReadOnlyDictionary`2<ICSharpTreeNode, MethodGroupConversionParameterWarningInfo> get_NullabilityMismatchInParameterTypeOfTargetDelegate();
    public sealed virtual IReadOnlyDictionary`2<ICSharpTreeNode, MethodGroupConversionReturnTypeWarningInfo> get_NullabilityMismatchInReturnTypeOfTargetDelegate();
    public sealed virtual IReadOnlySet`1<IDeclarationExpression> get_ForEachIterationVariablesPossibleNullInitializations();
    public sealed virtual IReadOnlySet`1<ICSharpTreeNode> get_PossibleNullNullableValueAccess();
    public sealed virtual IReadOnlySet`1<ICSharpTreeNode> get_PossibleNullUnboxings();
    public sealed virtual OneToSetMap`2<ICSharpTreeNode, bool> get_PossibleNullDereferences();
    public sealed virtual IReadOnlySet`1<ICSharpExpression> get_PossibleNullReturns();
    public sealed virtual OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, bool>> get_PossibleNullArguments();
    public sealed virtual OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<IExpressionType, IType, IParameter>> get_NullabilityMismatchInArguments();
    public sealed virtual OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<ITypeParameter, IType, IReadOnlyList`1<TypeArgumentValidationResult>>> get_TypeArgumentsNullabilityViolations();
    public sealed virtual OneToSetMap`2<ValueTuple`2<ICSharpExpression, bool>, IParameter> get_ParameterConditionalDisallowNullMismatches();
    public sealed virtual IReadOnlySet`1<ICSharpTreeNode> get_DoesNotReturnFunctionExits();
    public sealed virtual OneToSetMap`2<ICSharpTreeNode, IParameter> get_FunctionExitsWithDisallowedParameterStates();
    public sealed virtual OneToSetMap`2<ICSharpTreeNode, ITypeMember> get_FunctionExitsWithUnconditionalDisallowedMemberStates();
    public sealed virtual OneToSetMap`2<ValueTuple`2<ICSharpTreeNode, bool>, ITypeMember> get_FunctionExitsWithConditionallyDisallowedMemberStates();
    public sealed virtual IReadOnlyDictionary`2<ISwitchExpression, ValueTuple`2<bool, string>> get_SwitchExpressionsNotExhaustiveOnNull();
    public sealed virtual IReadOnlyDictionary`2<ICreationExpressionInitializer, ITypeMember> get_PossibleNullReferenceInitializerDereferences();
    public sealed virtual IReadOnlyDictionary`2<ICSharpExpression, IParameter> get_ReturnMustBeNotNullBecauseParameterIsNotNull();
    public sealed virtual OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, IParameter>> get_ParameterMustBeNotNullBecauseParameterIsNotNull();
    public sealed virtual IEnumerable`1<ValueTuple`2<IConditionalAccessExpression, bool>> get_RedundantConditionalAccessExpressions();
    public sealed virtual HashSet`1<ICSharpExpression> get_PossibleNullReferenceExceptions();
    public sealed virtual HashSet`1<ICSharpTreeNode> get_NullToNotNullableEntityAssignments();
    public sealed virtual HashSet`1<ITypeOwner> get_CanBeMadeNotAnnotatedLocals();
    public sealed virtual HashSet`1<ITypeMember> get_UninitializedNotNullableMembers();
    public sealed virtual HashSet`1<ISuppressNullableWarningExpression> get_RedundantSuppressNullableWarningExpressions();
    public sealed virtual IReadOnlySet`1<ValueTuple`2<ICSharpExpression, bool>> get_UnreachableNullCoalescingOperands();
    public sealed virtual IReadOnlyDictionary`2<ICSharpExpression, ValueTuple`2<ConstantExpressionValue, bool>> get_ConditionIsAlwaysTrueOrFalseExpressions();
    public sealed virtual IEnumerable`1<IDeclaration> get_ReturnTypeCanBeNotAnnotated();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.CSharpCompilerNullableInspector/<IteratePossibleNotAnnotatedLocalFunctions>d__169")]
private IEnumerable`1<IDeclaration> IteratePossibleNotAnnotatedLocalFunctions(bool staticOnly);
    internal VariableIdentifier GetVariableBySlot(int slot);
    [NotNullAttribute]
internal CSharpCompilerNullableInspector GetTopmostInspector();
    [CanBeNullAttribute]
internal IExpressionType TryGetAnnotatedExpressionTypeFromAnyInspector(ICSharpExpression expression);
    [CanBeNullAttribute]
internal ISubstitution TryGetInferredSubstitutionFromAnyInspector(IReference reference);
    [CanBeNullAttribute]
internal IDeclaredElement TryGetInferredDeclaredElementFromAnyInspector(IReference reference);
    [NotNullAttribute]
private static NullableContext ReInspectControlFlowSubgraphWithAnnotation(CSharpCompilerNullableInspector originalInspector, LocalFunctionAnalysis localFunctionAnalysis, NullableContext context, IControlFlowElement rootElement, IControlFlowElement exitElement);
    [NotNullAttribute]
internal static CSharpCompilerNullableInspector Create(ICSharpControlFlowGraph graph, Func`2<ITreeNode, ICSharpControlFlowGraph> graphBuilder, ValueAnalysisMode valueAnalysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis);
    internal void RunAnalysisAndRewriteTypes();
    [CanBeNullAttribute]
internal JetHashSet`1<int> GetParentFunctionSlotsWithWriteAccesses();
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertCurrentProjectModuleReferenceResolveContext();
    private static string DumpOwnerInfo(IPsiModule ownerPsiModule, ITreeNode ownerNode);
    private void ForceLocalFunctionSlots();
    protected virtual bool ShouldInspectSingleLeaf(ControlFlowElement element, ControlFlowEdgesEnumerable controlFlowEdges);
    protected virtual void CollectEntriesContexts(ControlFlowElement element, List`1<NullableContext> consumer);
    public virtual NullableContext GetContext(IControlFlowEdge edge);
    protected virtual bool ShouldProcessEdge(IControlFlowEdge edge);
    protected virtual bool ShouldInspectSingleLeaf(ControlFlowElement element);
    [NotNullAttribute]
private JetHashSet`1<int> CollectSlotsWithWriteAccesses(ICSharpClosure closure);
    [NotNullAttribute]
private JetHashSet`1<int> CollectSlotsWithWriteAccesses(IDeclaration ownerDeclaration, ICSharpTreeNode codeBody);
    [NotNullAttribute]
private static ICSharpExpression GetDecisionDagGoverningExpression(ITreeNode sourceElement);
    private DecisionDagInfo GetDagTempVariablesMap(ITreeNode dagSource);
    [NotNullAttribute]
private OneToSetMap`2<DagEvaluation, DagTempVariable> GetDagVariablesSourceMap(ITreeNode dagSource);
    private void UpdatePatternVariablesTypes(ITreeNode dagSource, NullableContext context);
    [PureAttribute]
private static bool IsConditionalAccessNullBranch(IControlFlowEdge edge, IConditionalAccessExpression conditionalAccessExpression);
    [PureAttribute]
private bool IsSubjectToNullnessCheck(IControlFlowEdge edge);
    private bool IsSubjectToNullnessCheck(ImplicitNullCheckSource nullCheckSource);
    private ImplicitNullCheckSource GetImplicitNullCheckKind(IControlFlowEdge edge);
    private ImplicitNullCheckSource GetImplicitNullCheckKind(IControlFlowEdge edge, ICSharpExpression& implicitlyCheckedExpression);
    private void PostValueAnalysis();
    private void SaveInferredTargetTypedSubstitutions(AnnotatedTargetTypedExpressionResolveContext annotatedResolveContext);
    private void PostProcessNullCheckExpression(ControlFlowElement element, bool isNullCheckedOperand);
    private static FrugalLocalList`1<ICSharpExpression> IterateWithContainingParenthesizedExpressions(ICSharpExpression expression);
    private static bool InitializedMemberCanBeNull(IObjectCreationExpression objectCreationExpression, IDeclaredElement initializedMember, IType memberType, Nullable`1<NullableAnnotation> rValueAnnotationOverride);
    private void ValidateTupleExpressionTypeArguments(ITupleExpression tupleExpression);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertInferredSubstitutionEquality(ISubstitution globalContextSubstitution, ISubstitution inferredSubstitution);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertTypeEqualityUpToNullableAnnotations(IExpressionType originalType, IExpressionType annotatedType);
    private void CheckIsExhaustiveAccordingToNullableFlowAnalysis(ISwitchExpression switchExpression, DecisionDag decisionDag, Dictionary`2<DagNonNullTest, NullableAnnotation> dagNonNullTestStates);
    private static bool IsExhaustiveOnNotNull(DecisionDag decisionDag);
    private void CheckNullabilityInPrefixPostfixOperatorExpression(ControlFlowElement element, IOperatorExpression operatorExpression, ICSharpExpression operand);
    [CanBeNullAttribute]
private static IDeclaredElement TryFindAnnotationSourceForCollectionExpressionElement(ICollectionExpressionElement collectionExpressionElement);
    private FlowAnalysisAnnotations GetAssignmentDestFlowAnnotations(ICSharpExpression assignmentDest);
    private void CheckTrueFalseOperatorsCalledFromShortCircuitOperator(ControlFlowElement element, IOperatorReference operatorReference, ICSharpExpression leftOperand, bool isTrueOperator);
    internal void InspectClosures();
    private void InspectLocalFunctions();
    private void MarkAllCapturedVariablesAsNullable(ICSharpExpression expression);
    private void CheckRequiredNotNullStatesOnReturn(IControlFlowElement returnElement, IReturnValueHolder returnValueHolder, ICSharpExpression returnValue);
    private void CheckNotNullIfNotNull(NullableContext context, IReturnValueHolder returnValueHolder, ICSharpExpression returnValue);
    private void CheckRequiredNotNullParameterStatesOnReturn(NullableContext context, NullableContext alternativeExitContext, ControlFlowEdgeCondition exitCondition, IReturnValueHolder returnValueHolder, ICSharpExpression returnValue);
    private void CheckRequiredMemberNotNullStatesOnReturn(NullableContext context, NullableContext alternativeExitContext, ControlFlowEdgeCondition exitCondition, IReturnValueHolder returnValueHolder, ICSharpExpression returnValue);
    [NotNullAttribute]
private ICSharpTreeNode GetExitNodeForHighlighting(IReturnValueHolder returnValueHolder, ICSharpExpression returnValue);
    private void CheckDoesNotReturnContract(IControlFlowElement returnElement, IReturnValueHolder returnNode);
    private void CheckNullabilityMismatchInTypeMemberExpressionInitializer(ControlFlowElement element, TMemberDeclaration memberDeclaration);
    private static bool ShouldProcessMultiplexorForPostValueAnalysis(CSharpControlFlowMultiplexor multiplexor);
    private bool HasReachableEntries(IControlFlowElement controlFlowElement);
    private void ProcessDeconstructionToTupleExpression(IControlFlowElement controlFlowElement, ICSharpExpression sourceExpression, TypeSymbolWithAnnotations annotatedSourceType, int sourceSlot, ITupleExpression targetTupleExpression, AnnotatedDeconstructionResolveContext annotatedResolveContext, bool isDefaultValue, bool isTopLevelDeconstruction);
    private void ProcessDeconstructionToParenthesizedDesignation(IControlFlowElement controlFlowElement, ICSharpExpression sourceExpression, TypeSymbolWithAnnotations annotatedSourceType, int sourceSlot, IParenthesizedVariableDesignation parenthesizedDesignation, AnnotatedDeconstructionResolveContext annotatedResolveContext, bool isTopLevelDeconstruction);
    [NotNullAttribute]
private static ICSharpExpression GetDeconstructionWarningExpression(IControlFlowElement controlFlowElement, ICSharpExpression sourceExpression);
    private void CheckDeconstructionSourceProblems(IDeconstructionReference deconstructionReference, AnnotatedDeconstructionResolveContext annotatedResolveContext, TypeSymbolWithAnnotations annotatedSourceType, ICSharpExpression warningTargetExpression, bool isTopLevelDeconstruction);
    private void ValidateTypeArguments(ICSharpTreeNode warningTargetNode, ISubstitution substitution, ITypeParametersOwner typeParametersOwner);
    private void CheckNullabilityMismatchInImplicitArgument(ICSharpExpression expression, IParameter targetParameter, ISubstitution substitution, Nullable`1<TypeSymbolWithAnnotations> annotatedSourceType, Nullable`1<bool> nullableWarningsSuppressed, ISuppressNullableWarningExpression suppressNullableWarningExpression);
    private void CheckNullabilityMismatchInDeconstruction(IDeconstructionReference deconstructionReference, ICSharpExpression warningTargetExpression, ICSharpExpression targetExpression, ITupleComponent sourceComponent, int componentIndex, TypeSymbolWithAnnotations destType, TypeSymbolWithAnnotations annotatedSourceComponentType);
    private TypeSymbolWithAnnotations GetDeconstructionComponentTypeInAnnotatedContext(IType targetTypeInAnyContext, IDeconstructionReference deconstructionReference, int componentIndex, bool isSourceExpressionDefaultValue, IResolveContext resolveContext, NullableAnnotation sourceValueAnnotation);
    private static bool IsDefaultValue(ICSharpExpression expression, IType destType);
    private static bool IsStructDefaultConstructorInvocation(IReference constructorReference);
    private bool PostProcessArrayInitializer(ControlFlowElement element, IArrayInitializer arrayInitializer);
    private void CheckArgumentsNullabilityMismatch(IControlFlowElement element, IExpressionElement collectionExpressionElement, IParametersOwner parametersOwner, ISubstitution substitution);
    private void CheckArgumentsNullabilityMismatch(IControlFlowElement element, ICSharpArgumentsOwner argumentsOwner, IParametersOwner parametersOwner, ISubstitution substitution);
    private void CheckArgumentsNullabilityMismatch(IControlFlowElement element, IReadOnlyList`1<ArgumentInfo> arguments, IParametersOwner parametersOwner, ISubstitution substitution, bool isImplicitInvocation);
    private NullableAnnotation GetWorstCaseAnnotation(FlowAnalysisAnnotations flowAnnotations, IType parameterType);
    private static Nullable`1<NullableAnnotation> GetUnconditionalAnnotationOverride(FlowAnalysisAnnotations parameterAnnotations);
    private FlowAnalysisAnnotations CoerceFlowAnnotationsBasedOnArgumentsNullability(Dictionary`2<string, NullableAnnotation> parametersWithAnnotatedArguments, FlowAnalysisAnnotations flowAnnotations, IParameter matchingParameter);
    private bool IsNotNullAccordingToParametersFlowAnnotations(Dictionary`2<string, NullableAnnotation> parametersWithAnnotatedArguments, IAttributesOwner attributesOwner);
    [NotNullAttribute]
private Dictionary`2<string, NullableAnnotation> GetParametersWithAnnotatedArguments(IReadOnlyList`1<ArgumentInfo> arguments, IParametersOwner parametersOwner, ISubstitution inferredSubstitution);
    private NullableContext MergeContextFromEntries(IEnumerable`1<IControlFlowElement> controlFlowElements);
    private void CheckNullabilityInReturnValueHolder(IControlFlowElement element, IReturnValueHolder returnValueHolder);
    private void CheckNullabilityInReturnValueHolder(IControlFlowElement element, ICSharpDeclaration returnOwnerDeclaration, ICSharpExpression returnValue);
    private bool IsDefinitelyNotNullable(IType type, NullableAnnotation annotation);
    private bool IsDefinitelyNotNullable(TypeSymbolWithAnnotations typeWithAnnotations);
    private bool IsDefinitelyNotNullableValueAnnotation(NullableAnnotation annotation);
    private static bool IsNotNullableOrNotAnnotated(IType type, NullableAnnotation annotation);
    private static bool IsNotNullableOrNotAnnotated(TypeSymbolWithAnnotations typeWithAnnotations);
    [CanBeNullAttribute]
private IType ResolveTargetTypeForAssignmentInAnnotatedContext(ICSharpExpression targetExpression);
    private void CheckPossibleNullReceiver(ControlFlowElement element);
    private ValueTuple`2<IDeclaredElement, ISubstitution> ResolveInAnnotatedContext(IReferenceExpression referenceExpression, Nullable`1<TypeSymbolWithAnnotations> qualifierExpressionType);
    private TypeSymbolWithAnnotations ResolveExpressionTypeInAnnotatedContext(ICSharpExpression expressionToResolveWithAnnotations, IControlFlowElement controlFlowElement);
    [NotNullAttribute]
private static IExpressionType GetExpressionTypeForBestCommonTypeCalculation(IExpressionType typeBeforeConversionToBestType, IExpressionType convertedType, bool isFromTupleExpressionType);
    private ValueTuple`2<IDeclaredElement, ISubstitution> InferTypesInAnnotatedContext(IElementAccessExpression elementAccessExpression);
    private Nullable`1<TypeSymbolWithAnnotations> GetBinaryOperatorResultType(IOperatorReference operatorReference, ICSharpExpression leftOperand, ICSharpExpression rightOperand, NullableContext context);
    [NotNullAttribute]
private ISubstitution InferBinaryOperatorTypesInAnnotatedContext(IOperatorReference operatorReference, ICSharpExpression leftOperand, ICSharpExpression rightOperand);
    private void InferDelegatePredefinedOperator(IOperatorReference operatorReference, ICSharpExpression leftOperand, ICSharpExpression rightOperand);
    [NotNullAttribute]
private ISubstitution InferUnaryOperatorTypesInAnnotatedContext(IOperatorReference operatorReference, ICSharpExpression operand);
    [NotNullAttribute]
private ISubstitution InferTypesInAnnotatedContext(IControlFlowElement sourceControlFlowElement, TExpression expressionToResolveWithAnnotations, NullableContext context);
    private void CollectTypeInferenceArgumentTypes(ICSharpInvocationInfo invocationInfo, Dictionary`2<IExpression, IExpressionType> annotatedExpressionTypes, NullableContext context);
    [NotNullAttribute]
private IExpressionType CoalesceTypesForTypeInferenceInUnreachableContext(TypeSymbolWithAnnotations typeWithAnnotations, NullableContext context);
    private TypeSymbolWithAnnotations GetTypeWithTypeInferenceAnnotations(ICSharpExpression expression, bool coalesceUnconstrainedGenericAnnotation);
    internal TypeSymbolWithAnnotations GetTypeWithTypeInferenceAnnotations(ICSharpExpression expression, TypeSymbolWithAnnotations typeInAnnotatedContext, bool coalesceUnconstrainedGenericAnnotation);
    [NotNullAttribute]
private static ISubstitution GetSubstitutionFromAnnotatedExpressionType(ICSharpExpression sourceExpression, IType qualifierType, ITypeElement targetTypeElement, ISubstitution globalContextSubstitution);
    [NotNullAttribute]
private static ISubstitution GetAncestorSubstitutionFromQualifier(ISubstitution qualifierSubstitution, ITypeElement qualifierTypeElement, ITypeElement targetTypeElement, ISubstitution globalContextSubstitution);
    [NotNullAttribute]
protected ISubstitution InferTypesInAnnotatedContext(ICSharpTreeNode invocationExpression, ICSharpInvocationInfo invocationInfo, TParametersOwner parametersOwner, ISubstitution qualifierSubstitution, IResolveContext resolveContextWithAnnotatedArguments);
    [CanBeNullAttribute]
private IExpressionType GetExpressionTypeInAnnotatedContext(ICSharpExpression argumentExpression, bool ignoreNullableWarningSuppression);
    private TypeSymbolWithAnnotations GetAnnotatedExpressionType(ICSharpExpression argumentExpression, bool ignoreNullableWarningSuppression);
    [ContractAnnotationAttribute("argumentExpression: null => notnull")]
private Nullable`1<TypeSymbolWithAnnotations> TryGetAnnotatedExpressionType(ICSharpExpression argumentExpression, bool ignoreNullableWarningSuppression);
    [CanBeNullAttribute]
private IControlFlowElement FindTopmostControlFlowElementForNode(IControlFlowElement parentElement, ITreeNode treeNode);
    [NotNullAttribute]
private static IControlFlowElement FindTopmostElementForSameSourceNode(IControlFlowElement controlFlowElement);
    private void CheckNullabilityMismatchInThrowExpressionOrStatement(ICSharpExpression exceptionExpression, IControlFlowElement element);
    private void CheckRefNullabilityMismatch(IControlFlowElement element, IRefExpression sourceExpression, IType destType, int destSlot, IDeclaredElement assignmentDest);
    private void CheckNullabilityMismatch(IControlFlowElement element, ICSharpExpression sourceExpression, IType destType, FlowAnalysisAnnotations flowAnalysisAnnotations, int destSlot, IDeclaredElement destDeclaredElement, bool isImplicitInvocation, bool isExplicitCastConversion, bool isImplicitConversionCheck);
    private void CheckNullabilityMismatch(ICSharpTreeNode entryNode, int destSlot, IType destType, FlowAnalysisAnnotations destFlowAnnotations, TypeSymbolWithAnnotations sourceTypeWithAnnotations, bool isExplicitCastConversion, bool warningsCanBeSuppressed, bool isImplicitInvocation, IDeclaredElement destDeclaredElement);
    private void CheckNullableAssignmentToJetBrainsNotNull(ICSharpTreeNode warningNode, IType destType, FlowAnalysisAnnotations destFlowAnnotations, IDeclaredElement assignmentDest, bool useLegacyWarnings, ISuppressNullableWarningExpression suppressNullableWarningExpression);
    [CanBeNullAttribute]
private static ISuppressNullableWarningExpression GetConversionNullabilityWarningsSuppression(ICSharpExpression entrySourceExpression, TypeSymbolWithAnnotations sourceTypeWithAnnotations);
    public static bool ShouldReportDisallowNullAttributeAssignment(FlowAnalysisAnnotations flowAnalysisAnnotations, IType assignmentTargetType, NullableAnnotation sourceAnnotationAfterConversion);
    private bool ShouldSkipDefaultValueAssignmentWarningForTypeParameter(IType type);
    private static bool HasNotNullableCounterpart(IType type);
    private NullableAnnotation GetDeclaredTopLevelLValueNullability(ICSharpExpression expression, bool ignoreOverrideByFlowAnnotations);
    private static bool UseLegacyWarningsForAssignmentsTo(IDeclaredElement assignmentDest);
    private bool ReportNullLiteralOrConstantAssignmentToNonNullableType(ICSharpTreeNode sourceNode, IType targetType, ConversionKind conversionKind, bool useLegacyWarnings, ISuppressNullableWarningExpression suppressNullableWarningExpression);
    private static bool IsDefaultLiteralOrConstantNull(ICSharpExpression sourceExpression);
    private static bool RequiresSafetyWarningWhenNullIntroduced(IType type);
    private static bool IsNullableTypeOrTypeParameter(IType type);
    private TypeSymbolWithAnnotations GetAnnotatedSlotType(int slot, ICSharpExpression ownerExpression);
    private TypeSymbolWithAnnotations GetAnnotatedSlotType(int slot, IType ownerExpressionType);
    internal TypeSymbolWithAnnotations GetAnnotatedSlotType(int slot);
    private void UpdateVariableType(IDeclaredElement declaredElement, TypeSymbolWithAnnotations updatedVariableType, int variableSlot, NullableContext context);
    internal TypeSymbolWithAnnotations GetTypeAfterConversion(ICSharpExpression sourceExpression, NullableAnnotation sourceAnnotation, IExpressionType sourceType, IType targetType, bool isExplicitCastConversion);
    private NullableAnnotation ValidateConversionAndInferResultingAnnotation(ICSharpTreeNode sourceNode, NullableAnnotation sourceAnnotation, IExpressionType sourceType, IType targetType, IParameter targetParameter, bool isExplicitCastConversion, bool isDeconstructionSource, bool useLegacyWarnings, ISuppressNullableWarningExpression suppressNullableWarningExpression, Conversion& conversion);
    [ObsoleteAttribute("Should not be used directly; Use either 'GetTypeAfterConversion' to get converted type for annotated context type inference or 'ValidateConversionAndInferResultingAnnotation' to receive top-level annotation after conversion and report warnings from nested conversions")]
private TypeSymbolWithAnnotations ApplyConversion(ICSharpTreeNode sourceNode, NullableAnnotation sourceAnnotation, IExpressionType sourceType, IType targetType, IParameter targetParameter, bool isExplicitCastConversion, bool isDeconstructionSource, bool reportWarnings, bool useLegacyWarnings, ISuppressNullableWarningExpression suppressNullableWarningExpression, Conversion& conversion);
    private static bool DependsOnTypeParameter(ITypeParameter dependantTypeParameter, ITypeParameter dependency, NullableAnnotation typeParameter1Annotation, NullableAnnotation& annotation);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertNoWarningsForSuppressedExpression(bool reportWarnings, bool isDeconstructionSource, IParameter targetParameter, ICSharpExpression sourceExpression);
    private TypeSymbolWithAnnotations ApplyConversionImpl(ICSharpExpression sourceExpression, ICSharpTreeNode warningTarget, NullableAnnotation sourceAnnotation, IExpressionType sourceType, IType targetType, IParameter targetParameter, bool isExplicitCastConversion, bool reportWarnings, bool useLegacyWarnings, ISuppressNullableWarningExpression suppressNullableWarningExpression, Conversion conversion, ISuppressNullableWarningExpression topLevelOnlyWarningsSuppression);
    private static Nullable`1<TypeSymbolWithAnnotations> TryGetDependentTypeParametersConversionState(IExpressionType sourceType, NullableAnnotation sourceAnnotation, IType targetType);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("expression: null => null")]
private static IParameter TryFindMatchingParameterByArgumentExpression(ICSharpExpression expression, Boolean& isExtensionMethodArgument, Boolean& isExpanded);
    private void ReportNullabilityMismatchWithTargetDelegate(IAnonymousFunctionExpression anonymousFunctionExpression, IAnonymousFunctionType anonymousFunctionType, IDeclaredType targetType, ISuppressNullableWarningExpression suppressNullableWarningExpression);
    private void ReportNullabilityMismatchWithTargetDelegate(ICSharpExpression delegateExpression, IDeclaredType targetType, IParametersOwner parametersOwner, ISubstitution methodSubstitution, ISuppressNullableWarningExpression suppressNullableWarningExpression);
    private void ReportNullabilityMismatchWithTargetFunctionPointer(ICSharpExpression delegateExpression, IFunctionPointerType targetFunctionPointer, IParametersOwner parametersOwner, ISubstitution methodSubstitution, ISuppressNullableWarningExpression suppressNullableWarningExpression);
    private bool IsNullabilityMismatch(IType source, IType destination, bool requireIdentity);
    private bool IsNestedNullabilityMismatch(IType source, IType destination, bool requireIdentity);
    private static bool IsNestedNullabilityMismatch(IType source, IType destination, bool requireIdentity, ICSharpTypeConversionRule typeConversionRuleWithNullability);
    public static bool IsTopLevelNullabilityCompatibleWithFlowAnnotations(ParameterKind refKind, IType source, FlowAnalysisAnnotations sourceFlowAnnotations, IType destination, FlowAnalysisAnnotations targetFlowAnnotations, bool forRef);
    protected int VariableSlot(IDeclaredElement symbol, ISubstitution substitution, int containingSlot);
    private void InheritNullableStateOfTrackableType(NullableContext context, NonMonotonicStateTransferContext nonMonotonicContext, Nullable`1<Conversion> conversion, IType targetType, IExpressionType sourceExpressionType, int targetSlot, int valueSlot, int skipSlot, bool canBeUninitializedStructMember);
    private void TrackUnallocatedMemberSlotStates(LocalHashSet`1<IDeclaredElement> processedMembers, NullableContext context, NonMonotonicStateTransferContext nonMonotonicContext, IType targetType, IExpressionType sourceExpressionType, int targetSlot, int valueSlot, int skipSlot, bool canBeUninitializedStructMember);
    internal void InheritNullableStateOfTrackableStruct(NullableContext context, NonMonotonicStateTransferContext nonMonotonicContext, Conversion conversion, IType targetType, IExpressionType sourceExpressionType, int targetSlot, int valueSlot, bool isDefaultValue, bool canBeUninitializedStruct, int skipSlot);
    private void InheritNullableStateOfMember(NullableContext context, NonMonotonicStateTransferContext nonMonotonicContext, int targetContainerSlot, int valueContainerSlot, IDeclaredElement member, ISubstitution targetSubstitution, ISubstitution valueSubstitution, bool isDefaultValue, bool canBeUninitializedStructMember, int skipSlot);
    private bool IsSlotMember(int slot, IDeclaredElement possibleMember, ISubstitution substitution);
    public void InheritDefaultState(NullableContext context, NonMonotonicStateTransferContext nonMonotonicContext, int targetSlot);
    [NotNullAttribute]
private IType GetTypeOrReturnType(IDeclaredElement declaredElement, ISubstitution substitution);
    private int MakeSlot(ICSharpExpression expression, bool calculateSubstitutionFromQualifier);
    private int MakeSlot(ICSharpExpression expression, ICSharpExpression& trackableCastOperand, bool calculateSubstitutionFromQualifier);
    private int MakeSlot(ICSharpExpression expression, ISubstitution substitution);
    private int MakeSlot(ICSharpExpression expression, ISubstitution substitution, ICSharpExpression& trackableCastOperand, bool calculateSubstitutionFromQualifier);
    private int MakeSlot(ICSharpExpression expression, ISubstitution& substitution);
    private int MakeSlot(ICSharpExpression expression, ISubstitution& substitution, ICSharpExpression& trackableCastOperand, bool calculateSubstitutionFromQualifier);
    private int GetOrCreateThisExpressionSlot(ICSharpTreeNode context);
    private int FindTupleComponentSlot(int sourceSlot, int componentIndex);
    private int FindNestedVariable(int containingSlot, string memberName);
    private int GetNullableValueOfTSlot(int containingSlot);
    [PureAttribute]
private int FindRestTupleComponentParentSlot(IReferenceExpression componentReferenceExpression, DecoratedType`1<TupleTypeDecoration> tupleType, int parentSlot, ISubstitution& substitution);
    private int FindRestTupleComponentParentSlot(int componentIndex, DecoratedType`1<TupleTypeDecoration> tupleType, int parentSlot, ISubstitution& substitution);
    public sealed virtual INullableDataFlowAnalysisResult GetClosureAnalysisResult(ICSharpClosure closure);
    public sealed virtual Nullable`1<NullableAnnotation> TryGetNullableAnnotation(int slot, ICSharpControlFlowEdge edge);
    [ObsoleteAttribute]
public int GetOrCreateSlot(IDeclaredElement declaredElement, int containingSlot);
    public sealed virtual int GetOrCreateSlot(IDeclaredElement declaredElement, ISubstitution substitution, int containingSlot);
    private int GetSlotDepth(int slot);
    [NotNullAttribute]
internal IType VariableType(VariableIdentifier variableIdentifier);
    internal void EnterParameters(IParametersOwner parametersOwner);
    private void EnterParameter(IParameter parameter, IType parameterType);
    [NotNullAttribute]
private static ISubstitution GetSubstitutionFromDeclaredType(IType type);
    internal void TrackStructParameterDefaultValueSlots(NullableContext context);
    internal void MakeMemberNotNullSlotsNullable(NullableContext context);
    private LocalHashSet`1<int> CollectMembersRequiringInitializationSlots(Nullable`1<bool> includeMembersInitializedByRequiredSetters);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static HashSet`1<ITypeMember> CollectMembersRequiringInitialization(IConstructorDeclaration constructorDeclaration, Nullable`1<bool> includeMembersInitializedByRequiredSetters, bool includeNonRequiredMembers, bool includeBaseRequiredMembers);
    public static bool IsNotNullableMemberRequiringInitialization(ITypeMember member, CompilerFlowAnnotationProvider flowAnnotationProvider);
    protected virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement element, NullableContext context);
    [NotNullAttribute]
public NullableContext Merge(IList`1<NullableContext> contexts, TypeParameterVariance variance);
    private void Normalize(NullableContext& state, int requiredSlotIndex);
    private void Normalize(NullableContext& state);
    internal NullableAnnotation GetDefaultState(int slot, bool useDeclaredAnnotationForLocalVariables, bool useDeclaredAnnotationForContainingTypeMembers);
    private Nullable`1<NullableAnnotation> GetVariableAnnotationFromMemberInitializer(VariableIdentifier variable);
    private VariableIdentifier CreateVariableIdentifier(IDeclaredElement declaredElement, ISubstitution substitution, int containingSlot);
    internal NullableAnnotation GetRValueAnnotation(ITypeOwner typeOwner, ISubstitution substitution);
    private TypeSymbolWithAnnotations FixUnknownAnnotation(IAttributesOwner attributesOwner, TypeParameterVariance variance, IType compilerType, bool useContainerAnnotation);
    [NotNullAttribute]
private IType FixElementAnnotation(IAttributesOwner attributesOwner, IType compilerType);
    private static FlowAnalysisAnnotations ToInwardAnnotations(FlowAnalysisAnnotations outwardAnnotations);
    private Nullable`1<NullableAnnotation> GetLValueAnnotationOverride(ITypeOwner typeOwner);
    private static Nullable`1<NullableAnnotation> GetLValueAnnotationOverride(FlowAnalysisAnnotations flowAnnotations);
    private static Nullable`1<NullableAnnotation> GetRValueAnnotationOverride(FlowAnalysisAnnotations flowAnnotations);
    private FrugalLocalHashSet`1<int> GetImplicitlyCheckedVariablesFromNullCheckedExpression(ICSharpExpression checkedOperand);
    private FrugalLocalHashSet`1<int> GetImplicitlyCheckedVariablesFromNullCheckedExpression(ICSharpExpression checkedOperand, FrugalLocalHashSet`1& notNullCheckNotImpliesNullCheckSlots);
    private NullableAnnotation GetImplicitlyTypedVariableAnnotation(IType inferredType);
    private NullableAnnotation GetImplicitlyTypedRefVariableAnnotation(IType inferredType, NullableAnnotation initializerAnnotation);
    private bool ShouldTrackMembersThroughConversion(IExpressionType from, IType targetType, bool isExplicitConversion, Int32& destSlot, Int32& sourceSlot);
    private bool ShouldTrackMembersThroughConversion(Conversion conversion, IType targetType, Int32& destSlot, Int32& sourceSlot);
    private void AddLocalFunctionCallContext(ILocalFunction localFunction, bool isDelayedCall, NullableContext context);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public IReadOnlySet`1<int> GetMemberNotNullSlots(int qualifierSlot, IDeclaredElement declaredElement, ControlFlowEdgeCondition condition, bool declaredNotNullForPostConditionCheck);
    private NullableAnnotation GetNullableAnnotationAfterSuppression(TypeSymbolWithAnnotations expressionTypeBeforeSuppression);
    private NullableAnnotation GetNullableAnnotationAfterSuppression(IExpressionType targetType, NullableAnnotation originalAnnotation);
    private protected void CheckIfSuppressionAffectsAnnotation(TypeSymbolWithAnnotations suppressedExpressionType, ISuppressNullableWarningExpression suppressNullableWarningExpressionParam);
    [CanBeNullAttribute]
private static ISuppressNullableWarningExpression GetNullableWarningSuppressionIfAny(ICSharpExpression expression);
    [NotNullAttribute]
private static IReadOnlyList`1<ArgumentInfo> GetArgumentsInfo(ICSharpArgumentsOwner argumentsOwner);
    [NotNullAttribute]
private static IReadOnlyList`1<ArgumentInfo> GetArgumentsInfo(IExpressionElement expressionElement);
    [NotNullAttribute]
public static IReadOnlyList`1<SignatureNullabilityMismatch> CheckValidNullableMethodOverride(IParametersOwner baseMember, ISubstitution baseSubstitution, IParametersOwner overrideMember, ISubstitution overrideSubstitution, ICSharpTypeConversionRule typeConversionRule, CompilerFlowAnnotationProvider compilerAnnotationsProvider, NotNullIfNotNullAnnotationProvider notNullIfNotNullProvider);
    [CompilerGeneratedAttribute]
private bool <get_RedundantConditionalAccessExpressions>b__152_0(KeyValuePair`2<IConditionalAccessExpression, NullableAnnotation> x);
    [CompilerGeneratedAttribute]
private bool <get_ConditionIsAlwaysTrueOrFalseExpressions>g__IsAssertionMethodArgument|166_0(ICSharpExpression expression, bool constantValue);
    [CompilerGeneratedAttribute]
private Nullable`1<ImplicitNullCheckSource> <GetImplicitNullCheckKind>g__GetExtensionMethodQualifierImplicitNullCheckSource|200_0(ICSharpExpression qualifierExpression, ICSharpExpression& implicitlyCheckedExpression);
    [CompilerGeneratedAttribute]
private void <PostValueAnalysis>g__CheckEnumerablePatternMethodNullability|201_0(IReference patternMethodReference, <>c__DisplayClass201_0& , <>c__DisplayClass201_1& , <>c__DisplayClass201_2& );
    [CompilerGeneratedAttribute]
private void <ValidateTupleExpressionTypeArguments>g__ValidateTupleSubstitution|206_0(DecoratedType`1<TupleTypeDecoration> tupleType, Nullable`1<TreeNodeCollection`1<ITupleComponent>> tupleComponents, ICSharpExpression tupleExpression, int componentsOffset);
    [CompilerGeneratedAttribute]
internal static bool <ValidateTupleExpressionTypeArguments>g__HasNonExpressionTypeForEveryComponent|206_1(ITupleExpressionType tupleExpressionType);
    [CompilerGeneratedAttribute]
internal static bool <ValidateTupleExpressionTypeArguments>g__HasExplicitCast|206_2(ICSharpExpression sourceExpression);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<DecisionDagNode> <IsExhaustiveOnNotNull>g__NonNullSuccessors|210_0(DecisionDagNode dagNode);
    [CompilerGeneratedAttribute]
internal static IDeclaredElement <TryFindAnnotationSourceForCollectionExpressionElement>g__TryFindAnnotationSourceForCollectionExpressionElement|212_0(ICSharpExpression expression);
    [CompilerGeneratedAttribute]
private bool <InspectClosures>b__215_1(IAnonymousFunctionExpression x);
    [CompilerGeneratedAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
internal static void <InspectClosures>g__AssertIsDirectClosure|215_2(ICSharpClosure cSharpClosure, ICSharpTreeNode ownerNode);
    [CompilerGeneratedAttribute]
private ValueTuple`2<bool, NullableContext> <InspectLocalFunctions>b__216_4(ILocalFunction x);
    [CompilerGeneratedAttribute]
private bool <CheckNotNullIfNotNull>g__RequiresNotNullState|219_0(IAttributesOwner attributesOwner, IParameter& notNullParameter, <>c__DisplayClass219_0& );
    [CompilerGeneratedAttribute]
private void <CheckRequiredMemberNotNullStatesOnReturn>g__CheckConditionalNotNullMembers|221_0(ControlFlowEdgeCondition condition, <>c__DisplayClass221_0& );
    [CompilerGeneratedAttribute]
private bool <CheckRequiredMemberNotNullStatesOnReturn>g__IsSlotNullable|221_1(int slot, NullableContext context, bool allowNotAnnotatedGenerics, <>c__DisplayClass221_0& );
    [CompilerGeneratedAttribute]
internal static ICSharpTreeNode <GetExitNodeForHighlighting>g__GetLastMeaningfulToken|222_0(ICSharpTreeNode node);
    [CompilerGeneratedAttribute]
private IArrayType <PostProcessArrayInitializer>g__GetTargetArrayType|237_0(<>c__DisplayClass237_0& );
    [CompilerGeneratedAttribute]
private void <CheckArgumentsNullabilityMismatch>g__CheckArgumentNullabilityMismatch|240_0(ICSharpExpression argumentExpression, IParameter parameter, bool isExpanded, ISuppressNullableWarningExpression suppressNullableWarningExpression, <>c__DisplayClass240_0& );
    [CompilerGeneratedAttribute]
private void <CheckArgumentsNullabilityMismatch>g__CheckNestedNullabilityMismatch|240_2(TypeSymbolWithAnnotations destType, <>c__DisplayClass240_0& , <>c__DisplayClass240_1& );
    [CompilerGeneratedAttribute]
private IControlFlowElement <CheckArgumentsNullabilityMismatch>g__FindArgumentControlFlowElement|240_1(ICSharpExpression argumentExpression, Boolean& isInstanceReceiverArgumentToInterpolationHandler, <>c__DisplayClass240_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetParametersWithAnnotatedArguments>g__HasCallerInfoAttribute|245_0(IParameter parameter, <>c__DisplayClass245_0& );
    [CompilerGeneratedAttribute]
internal static void <GetParametersWithAnnotatedArguments>g__SetParameterState|245_1(IParameter parameter, NullableAnnotation annotation, <>c__DisplayClass245_0& );
    [CompilerGeneratedAttribute]
private IPsiModule <ResolveTargetTypeForAssignmentInAnnotatedContext>b__254_1();
    [CompilerGeneratedAttribute]
private IPsiModule <ResolveTargetTypeForAssignmentInAnnotatedContext>b__254_0();
    [CompilerGeneratedAttribute]
private void <ResolveExpressionTypeInAnnotatedContext>g__CollectElementTypesAndMergeNullability|257_2(IVariableInitializer initializer, <>c__DisplayClass257_0& , <>c__DisplayClass257_2& );
    [CompilerGeneratedAttribute]
private IExpressionType <ResolveExpressionTypeInAnnotatedContext>g__ProcessSingleConditionalExpressionBranch|257_4(ICSharpExpression resultExpression, <>c__DisplayClass257_0& , <>c__DisplayClass257_1& , <>c__DisplayClass257_3& );
    [CompilerGeneratedAttribute]
private IType <ResolveExpressionTypeInAnnotatedContext>g__MergeConditionalExpressionBranchAnnotations|257_0(IConditionalTernaryExpression conditionalTernaryExpression, TypeSymbolWithAnnotations annotatedThenType, TypeSymbolWithAnnotations annotatedElseType, IType resultType, <>c__DisplayClass257_0& );
    [CompilerGeneratedAttribute]
private bool <ResolveExpressionTypeInAnnotatedContext>g__HasReachableExits|257_1(ICSharpExpression expression, Boolean& hasUnreachableExits, <>c__DisplayClass257_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetBinaryOperatorResultType>g__IsStringAddition|260_1(<>c__DisplayClass260_0& );
    [CompilerGeneratedAttribute]
private DelegatePredefinedOperator <InferDelegatePredefinedOperator>g__CreatePredefinedDelegateOperator|262_0(IDelegate delegateType, IType parameterType, <>c__DisplayClass262_0& );
    [CompilerGeneratedAttribute]
private ISubstitution <InferTypesInAnnotatedContext>g__InferSubstitutionInAnnotatedContext|264_0(TParametersOwner parametersOwner, ITypeElement containingType, bool isDelegateInvocation, bool shouldUseQualifierAnnotations, bool shouldUseArgumentAnnotations, <>c__DisplayClass264_0`1& , <>c__DisplayClass264_1`1& , <>c__DisplayClass264_2`1& );
    [CompilerGeneratedAttribute]
private void <UpdateVariableType>g__UpdateNestedVariables|295_0(int parentSlot, <>c__DisplayClass295_0& );
    [CompilerGeneratedAttribute]
internal static ISubstitution <UpdateVariableType>g__GetSubstitutionFromAnnotatedType|295_1(IExpressionType annotatedType);
    [CompilerGeneratedAttribute]
internal static IExpressionType <ApplyConversionImpl>g__GetComponentExpressionTypeAfterUserDefinedConversions|301_3(TypeConversionInfo componentConversion, CSharpCompilerNullableInspector inspector);
    [CompilerGeneratedAttribute]
internal static TypeSymbolWithAnnotations <ApplyConversionImpl>g__GetResultForValueTargetType|301_0(<>c__DisplayClass301_0& );
    [CompilerGeneratedAttribute]
internal static ICSharpExpression <ApplyConversionImpl>g__UnwrapSourceExpressionFromDiscardAssignment|301_1(ICSharpExpression sourceExpression);
    [CompilerGeneratedAttribute]
internal static ICSharpExpression <ApplyConversionImpl>g__GetDestIfAssignmentExpression|301_2(ICSharpExpression sourceExpression);
    [CompilerGeneratedAttribute]
private IType <ReportNullabilityMismatchWithTargetDelegate>g__GetNotNullIfNotNullAnnotation|304_0(IType type, IAttributesOwner attributesOwner, <>c__DisplayClass304_0& );
    [CompilerGeneratedAttribute]
private IType <ReportNullabilityMismatchWithTargetDelegate>g__GetNotNullIfNotNullMethodGroupAnnotation|305_0(IType type, IAttributesOwner attributesOwner, <>c__DisplayClass305_0& );
    [CompilerGeneratedAttribute]
private IType <ReportNullabilityMismatchWithTargetFunctionPointer>g__GetNotNullIfNotNullAnnotation|306_0(IType type, IAttributesOwner attributesOwner, <>c__DisplayClass306_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsTopLevelNullabilityCompatibleWithFlowAnnotations>g__CanAssignOutputValueWhen|310_0(bool condition, <>c__DisplayClass310_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsTopLevelNullabilityCompatibleWithFlowAnnotations>g__ShouldReportNullableAssignment|310_1(IType destType, NullableAnnotation sourceAnnotation);
    [CompilerGeneratedAttribute]
internal static bool <IsTopLevelNullabilityCompatibleWithFlowAnnotations>g__IsBadAssignment|310_2(NullableAnnotation sourceValueAnnotation, IType destination, FlowAnalysisAnnotations destinationAnnotations);
    [CompilerGeneratedAttribute]
internal static FlowAnalysisAnnotations <IsTopLevelNullabilityCompatibleWithFlowAnnotations>g__MakeUnconditionalAnnotation|310_3(FlowAnalysisAnnotations annotations, bool condition);
    [CompilerGeneratedAttribute]
internal static FlowAnalysisAnnotations <IsTopLevelNullabilityCompatibleWithFlowAnnotations>g__MakeUnconditionalAnnotationCore|310_4(FlowAnalysisAnnotations annotations, FlowAnalysisAnnotations conditionalAnnotation, FlowAnalysisAnnotations replacementAnnotation);
    [CompilerGeneratedAttribute]
private IPsiModule <GetTypeOrReturnType>b__318_0();
    [CompilerGeneratedAttribute]
private void <MakeMemberNotNullSlotsNullable>g__MakeMemberNotNullSlotsNullable|341_0(int qualifierSlot, ControlFlowEdgeCondition edgeCondition, <>c__DisplayClass341_0& );
    [CompilerGeneratedAttribute]
internal static bool <CollectMembersRequiringInitialization>g__CanContainNullValue|343_1(ITypeElement currentTypeElement, ITypeMember typeMember);
    [CompilerGeneratedAttribute]
internal static bool <IsNotNullableMemberRequiringInitialization>g__ShouldInitializeType|344_0(IType type, <>c__DisplayClass344_0& );
    [CompilerGeneratedAttribute]
internal static bool <FixElementAnnotation>g__CanUpdateTypeArgumentWithContainerAnnotation|354_0(IDeclaredType declaredType, CodeAnnotationNullableValue annotation);
    [CompilerGeneratedAttribute]
private void <GetImplicitlyCheckedVariablesFromNullCheckedExpression>g__ProcessExpressionRecursively|360_0(bool isTopLevelAccess, ICSharpExpression nextExpression, FrugalLocalHashSet`1& result, <>c__DisplayClass360_0& );
    [CompilerGeneratedAttribute]
private void <GetMemberNotNullSlots>g__CollectSlotsFromAnnotations|366_0(ITypeMember typeMember, <>c__DisplayClass366_0& );
    [CompilerGeneratedAttribute]
internal static IType <CheckValidNullableMethodOverride>g__GetNotNullIfNotNullMethodGroupAnnotation|375_0(IType type, IAttributesOwner attributesOwner, <>c__DisplayClass375_0& );
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.ImplicitNullCheckSource : Enum {
    public int value__;
    public static ImplicitNullCheckSource None;
    public static ImplicitNullCheckSource QualifierDereference;
    public static ImplicitNullCheckSource DelegateInvocation;
    public static ImplicitNullCheckSource ElementAccessQualifier;
    public static ImplicitNullCheckSource AwaitSource;
    public static ImplicitNullCheckSource DeconstructionSource;
    public static ImplicitNullCheckSource NotNullableExtensionDeconstructionSource;
    public static ImplicitNullCheckSource LiftedUserDefinedConversion;
    public static ImplicitNullCheckSource NullableUnliftCast;
    public static ImplicitNullCheckSource UnboxingCast;
    public static ImplicitNullCheckSource DelegateCreationArgument;
    public static ImplicitNullCheckSource LockObject;
    public static ImplicitNullCheckSource ForeachCollection;
    public static ImplicitNullCheckSource NotNullableExtensionArgument;
    public static ImplicitNullCheckSource WithExpressionOperand;
    public static ImplicitNullCheckSource UnsafePointerAccess;
    public static ImplicitNullCheckSource CollectionExpressionSpreadSource;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.ImplicitNullCheckSourceExtensions : object {
    [ExtensionAttribute]
public static bool IsRuntimeEnforced(ImplicitNullCheckSource nullCheckSource);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.INullableDataFlowAnalysisResult {
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<ICSharpTreeNode> AssignmentNullabilityMismatchesCS8600 { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<ICSharpTreeNode> AssignmentNullabilityMismatchesCS8601 { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<ICSharpTreeNode> AssignmentNullabilityMismatchesCS8625 { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public OneToListMap`2<ITreeNode, ValueTuple`2<IExpressionType, IType>> AssignmentNullabilityMismatchesCS8619 { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<ICSharpExpression> PossibleNullValueInThrowExpressionOrStatement { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<ICSharpTreeNode> DisallowNullAttributeForbidsMaybeNullAssignment { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<ICSharpTreeNode, MethodGroupConversionParameterWarningInfo> NullabilityMismatchInParameterTypeOfTargetDelegate { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<ICSharpTreeNode, MethodGroupConversionReturnTypeWarningInfo> NullabilityMismatchInReturnTypeOfTargetDelegate { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<IDeclarationExpression> ForEachIterationVariablesPossibleNullInitializations { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<ICSharpTreeNode> PossibleNullNullableValueAccess { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<ICSharpTreeNode> PossibleNullUnboxings { get; }
    [NotNullAttribute]
public OneToSetMap`2<ICSharpTreeNode, bool> PossibleNullDereferences { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlySet`1<ICSharpExpression> PossibleNullReturns { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, bool>> PossibleNullArguments { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<IExpressionType, IType, IParameter>> NullabilityMismatchInArguments { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<ITypeParameter, IType, IReadOnlyList`1<TypeArgumentValidationResult>>> TypeArgumentsNullabilityViolations { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public OneToSetMap`2<ValueTuple`2<ICSharpExpression, bool>, IParameter> ParameterConditionalDisallowNullMismatches { get; }
    [NotNullAttribute]
public IReadOnlySet`1<ICSharpTreeNode> DoesNotReturnFunctionExits { get; }
    [NotNullAttribute]
public OneToSetMap`2<ICSharpTreeNode, IParameter> FunctionExitsWithDisallowedParameterStates { get; }
    [NotNullAttribute]
public OneToSetMap`2<ICSharpTreeNode, ITypeMember> FunctionExitsWithUnconditionalDisallowedMemberStates { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public OneToSetMap`2<ValueTuple`2<ICSharpTreeNode, bool>, ITypeMember> FunctionExitsWithConditionallyDisallowedMemberStates { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<ICreationExpressionInitializer, ITypeMember> PossibleNullReferenceInitializerDereferences { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<ICSharpExpression, IParameter> ReturnMustBeNotNullBecauseParameterIsNotNull { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, IParameter>> ParameterMustBeNotNullBecauseParameterIsNotNull { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ITypeMember> UninitializedNotNullableMembers { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public IReadOnlyDictionary`2<ISwitchExpression, ValueTuple`2<bool, string>> SwitchExpressionsNotExhaustiveOnNull { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public IEnumerable`1<ValueTuple`2<IConditionalAccessExpression, bool>> RedundantConditionalAccessExpressions { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ICSharpExpression> PossibleNullReferenceExceptions { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ICSharpTreeNode> NullToNotNullableEntityAssignments { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ITypeOwner> CanBeMadeNotAnnotatedLocals { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public IReadOnlySet`1<ValueTuple`2<ICSharpExpression, bool>> UnreachableNullCoalescingOperands { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
public IReadOnlyDictionary`2<ICSharpExpression, ValueTuple`2<ConstantExpressionValue, bool>> ConditionIsAlwaysTrueOrFalseExpressions { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public HashSet`1<ISuppressNullableWarningExpression> RedundantSuppressNullableWarningExpressions { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IDeclaration> ReturnTypeCanBeNotAnnotated { get; }
    public abstract virtual IReadOnlySet`1<ICSharpTreeNode> get_AssignmentNullabilityMismatchesCS8600();
    public abstract virtual IReadOnlySet`1<ICSharpTreeNode> get_AssignmentNullabilityMismatchesCS8601();
    public abstract virtual IReadOnlySet`1<ICSharpTreeNode> get_AssignmentNullabilityMismatchesCS8625();
    public abstract virtual OneToListMap`2<ITreeNode, ValueTuple`2<IExpressionType, IType>> get_AssignmentNullabilityMismatchesCS8619();
    public abstract virtual IReadOnlySet`1<ICSharpExpression> get_PossibleNullValueInThrowExpressionOrStatement();
    public abstract virtual IReadOnlySet`1<ICSharpTreeNode> get_DisallowNullAttributeForbidsMaybeNullAssignment();
    public abstract virtual IReadOnlyDictionary`2<ICSharpTreeNode, MethodGroupConversionParameterWarningInfo> get_NullabilityMismatchInParameterTypeOfTargetDelegate();
    public abstract virtual IReadOnlyDictionary`2<ICSharpTreeNode, MethodGroupConversionReturnTypeWarningInfo> get_NullabilityMismatchInReturnTypeOfTargetDelegate();
    public abstract virtual IReadOnlySet`1<IDeclarationExpression> get_ForEachIterationVariablesPossibleNullInitializations();
    public abstract virtual IReadOnlySet`1<ICSharpTreeNode> get_PossibleNullNullableValueAccess();
    public abstract virtual IReadOnlySet`1<ICSharpTreeNode> get_PossibleNullUnboxings();
    public abstract virtual OneToSetMap`2<ICSharpTreeNode, bool> get_PossibleNullDereferences();
    public abstract virtual IReadOnlySet`1<ICSharpExpression> get_PossibleNullReturns();
    public abstract virtual OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, bool>> get_PossibleNullArguments();
    public abstract virtual OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<IExpressionType, IType, IParameter>> get_NullabilityMismatchInArguments();
    public abstract virtual OneToSetMap`2<ICSharpTreeNode, ValueTuple`3<ITypeParameter, IType, IReadOnlyList`1<TypeArgumentValidationResult>>> get_TypeArgumentsNullabilityViolations();
    public abstract virtual OneToSetMap`2<ValueTuple`2<ICSharpExpression, bool>, IParameter> get_ParameterConditionalDisallowNullMismatches();
    public abstract virtual IReadOnlySet`1<ICSharpTreeNode> get_DoesNotReturnFunctionExits();
    public abstract virtual OneToSetMap`2<ICSharpTreeNode, IParameter> get_FunctionExitsWithDisallowedParameterStates();
    public abstract virtual OneToSetMap`2<ICSharpTreeNode, ITypeMember> get_FunctionExitsWithUnconditionalDisallowedMemberStates();
    public abstract virtual OneToSetMap`2<ValueTuple`2<ICSharpTreeNode, bool>, ITypeMember> get_FunctionExitsWithConditionallyDisallowedMemberStates();
    public abstract virtual IReadOnlyDictionary`2<ICreationExpressionInitializer, ITypeMember> get_PossibleNullReferenceInitializerDereferences();
    public abstract virtual IReadOnlyDictionary`2<ICSharpExpression, IParameter> get_ReturnMustBeNotNullBecauseParameterIsNotNull();
    public abstract virtual OneToSetMap`2<ICSharpTreeNode, ValueTuple`2<IParameter, IParameter>> get_ParameterMustBeNotNullBecauseParameterIsNotNull();
    public abstract virtual HashSet`1<ITypeMember> get_UninitializedNotNullableMembers();
    public abstract virtual IReadOnlyDictionary`2<ISwitchExpression, ValueTuple`2<bool, string>> get_SwitchExpressionsNotExhaustiveOnNull();
    public abstract virtual IEnumerable`1<ValueTuple`2<IConditionalAccessExpression, bool>> get_RedundantConditionalAccessExpressions();
    public abstract virtual HashSet`1<ICSharpExpression> get_PossibleNullReferenceExceptions();
    public abstract virtual HashSet`1<ICSharpTreeNode> get_NullToNotNullableEntityAssignments();
    public abstract virtual HashSet`1<ITypeOwner> get_CanBeMadeNotAnnotatedLocals();
    public abstract virtual IReadOnlySet`1<ValueTuple`2<ICSharpExpression, bool>> get_UnreachableNullCoalescingOperands();
    public abstract virtual IReadOnlyDictionary`2<ICSharpExpression, ValueTuple`2<ConstantExpressionValue, bool>> get_ConditionIsAlwaysTrueOrFalseExpressions();
    public abstract virtual HashSet`1<ISuppressNullableWarningExpression> get_RedundantSuppressNullableWarningExpressions();
    public abstract virtual IEnumerable`1<IDeclaration> get_ReturnTypeCanBeNotAnnotated();
    [CanBeNullAttribute]
public abstract virtual INullableDataFlowAnalysisResult GetClosureAnalysisResult(ICSharpClosure closure);
    public abstract virtual Nullable`1<NullableAnnotation> TryGetNullableAnnotation(int slot, ICSharpControlFlowEdge edge);
    public abstract virtual int GetOrCreateSlot(IDeclaredElement declaredElement, ISubstitution substitution, int containingSlot);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.MethodGroupConversionParameterWarningInfo : ValueType {
    [NotNullAttribute]
public IType SourceParameterType;
    [NotNullAttribute]
public IType TargetParameterType;
    [NotNullAttribute]
public IType TargetDelegateType;
    [NotNullAttribute]
public IParameter SourceParameter;
    [CanBeNullAttribute]
public IAnonymousFunctionExpression SourceAnonymousFunction;
    [CanBeNullAttribute]
public IParametersOwner SourceParametersOwner;
    public MethodGroupConversionParameterWarningInfo(IType sourceParameterType, IType targetParameterType, IType targetDelegateType, IParameter sourceParameter, IAnonymousFunctionExpression sourceAnonymousFunction);
    public MethodGroupConversionParameterWarningInfo(IType sourceParameterType, IType targetParameterType, IType targetDelegateType, IParameter sourceParameter, IParametersOwner sourceSourceParametersOwner);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.MethodGroupConversionReturnTypeWarningInfo : ValueType {
    [NotNullAttribute]
public IType ExpectedReturnType;
    [NotNullAttribute]
public IType ActualReturnType;
    [NotNullAttribute]
public IType TargetDelegateType;
    public MethodGroupConversionReturnTypeWarningInfo(IType expectedReturnType, IType actualReturnType, IType targetDelegateType);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.NonMonotonicStateTransferContext : object {
    [CanBeNullAttribute]
private Dictionary`2<int, NullableAnnotation> myNullableAssignments;
    public void SetSlotState(int slot, NullableAnnotation annotation);
    [NotNullAttribute]
public NullableContext PatchContext(CSharpCompilerNullableInspector inspector, NullableContext context);
    public void Merge(NonMonotonicStateTransferContext otherContext);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.NullableContext : object {
    [CanBeNullAttribute]
private Nullable`1[] myState;
    [CanBeNullAttribute]
private JetHashSet`1<int> myHasWritesInClosures;
    private TypeSymbolWithAnnotations myExpressionType;
    private int myLastUnreachableClosureContextSlot;
    [CompilerGeneratedAttribute]
private bool <Reachable>k__BackingField;
    public bool Reachable { get; public set; }
    internal int Capacity { get; }
    internal TypeSymbolWithAnnotations ExpressionType { get; internal set; }
    public NullableAnnotation ExpressionAnnotation { get; public set; }
    internal NullableContext(bool reachable, Nullable`1[] state, int lastUnreachableClosureContextSlot);
    [CompilerGeneratedAttribute]
public bool get_Reachable();
    [CompilerGeneratedAttribute]
public void set_Reachable(bool value);
    internal int get_Capacity();
    internal NullableAnnotation GetSlotStateOrDefault(int slot, CSharpCompilerNullableInspector inspector, bool useDeclaredAnnotationForLocalVariables, bool useDeclaredAnnotationForContainingTypeMembers);
    internal Nullable`1<NullableAnnotation> GetSlotState(int slot, CSharpCompilerNullableInspector inspector);
    private NullableAnnotation CoerceNestedSlotState(int slot, NullableAnnotation state, CSharpCompilerNullableInspector inspector);
    [ContractAnnotationAttribute("state:notnull => notnull; state:null => null")]
private Nullable`1<NullableAnnotation> CoerceNestedSlotState(int slot, Nullable`1<NullableAnnotation> state, CSharpCompilerNullableInspector inspector);
    internal void Trim(int fromSlot);
    internal void SetSlotState(int slot, Nullable`1<NullableAnnotation> value);
    internal Nullable`1<NullableAnnotation> TryGetSlotState(int slot);
    private bool HasWritesInClosures(int slot, CSharpCompilerNullableInspector inspector);
    private bool HasPossiblyDefaultStructParent(VariableIdentifier variableIdentifier, CSharpCompilerNullableInspector inspector);
    internal void SetClosureAccess(int slot);
    internal void MergeClosureWritesFrom(IEnumerable`1<int> source);
    internal void MergeClosureWritesFrom(NullableContext source);
    internal TypeSymbolWithAnnotations get_ExpressionType();
    internal void set_ExpressionType(TypeSymbolWithAnnotations value);
    public NullableAnnotation get_ExpressionAnnotation();
    public void set_ExpressionAnnotation(NullableAnnotation value);
    internal void EnsureCapacity(int capacity);
    [NotNullAttribute]
public NullableContext Clone();
    public virtual bool Equals(object obj);
    private bool Equals(NullableContext other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.NullableContextFactory : object {
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpCompilerNullableInspector <Inspector>k__BackingField;
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    [NotNullAttribute]
public NullableContext InitialContext { get; }
    public CSharpCompilerNullableInspector Inspector { get; public set; }
    public NullableContextFactory(IPsiModule psiModule);
    [CompilerGeneratedAttribute]
public IPsiModule get_PsiModule();
    public virtual NullableContext get_InitialContext();
    [NotNullAttribute]
public sealed virtual NullableContext CloneContext(NullableContext context);
    [CompilerGeneratedAttribute]
public CSharpCompilerNullableInspector get_Inspector();
    [CompilerGeneratedAttribute]
public void set_Inspector(CSharpCompilerNullableInspector value);
    [NotNullAttribute]
public sealed virtual NullableContext Merge(IList`1<NullableContext> contexts);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.ObjectCreationDeclaredElementPlaceholder : object {
    [NotNullAttribute]
private ICreationExpression myObjectCreationExpression;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsConstant { get; }
    public bool IsWritable { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ReferenceKind ReferenceKind { get; }
    public ObjectCreationDeclaredElementPlaceholder(ICreationExpression objectCreationExpression);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual bool IsValid();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual ReferenceKind get_ReferenceKind();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.PatternMatchingGoverningExpressionDeclaredElementPlaceholder : object {
    [NotNullAttribute]
private ITreeNode myPatternMatchingOwner;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsConstant { get; }
    public bool IsWritable { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ReferenceKind ReferenceKind { get; }
    public PatternMatchingGoverningExpressionDeclaredElementPlaceholder(ITreeNode patternMatchingOwner, IType annotatedType);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual bool IsValid();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual ReferenceKind get_ReferenceKind();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.ReferenceTypeNullabilityTypeRewriter : TypeRewriterBase`1<Unit> {
    public static ReferenceTypeNullabilityTypeRewriter UnknownNullability;
    public static ReferenceTypeNullabilityTypeRewriter UnknownFlowUnknownNullability;
    private NullableAnnotation myNullableAnnotation;
    public ReferenceTypeNullabilityTypeRewriter(NullableAnnotation annotation);
    private static ReferenceTypeNullabilityTypeRewriter();
    public virtual IType VisitType(IType type, Unit context);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.Runner.INullableReferenceTypesAnalysisRunner {
    public abstract virtual bool NullableAnalysisIsRequired(ICSharpTreeNode node);
    [CanBeNullAttribute]
public abstract virtual INullableDataFlowAnalysisResult RunNullableAnalysis(ICSharpTreeNode ownerNode, Func`2<ITreeNode, ICSharpControlFlowGraph> customGraphBuilder, ValueAnalysisMode valueAnalysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.Runner.NullableReferenceTypesAnalysisRunner : object {
    public sealed virtual bool NullableAnalysisIsRequired(ICSharpTreeNode node);
    public sealed virtual INullableDataFlowAnalysisResult RunNullableAnalysis(ICSharpTreeNode ownerNode, Func`2<ITreeNode, ICSharpControlFlowGraph> customGraphBuilder, ValueAnalysisMode valueAnalysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.Runner.NullableReferenceTypesDataFlowAnalysisRunSynchronizer : object {
    [CompilerGeneratedAttribute]
private INullableReferenceTypesAnalysisRunner <analysisRunner>P;
    [NotNullAttribute]
private LazyForkedContentModelData`1<ConcurrentDictionary`2<ICSharpTreeNode, INullableAnalysisMarker>> myInspectedNodes;
    public NullableReferenceTypesDataFlowAnalysisRunSynchronizer(INullableReferenceTypesAnalysisRunner analysisRunner);
    [CanBeNullAttribute]
[MustUseReturnValueAttribute]
public INullableDataFlowAnalysisResult RunNullableAnalysisAndGetResults(ICSharpTreeNode treeNode, Func`2<ITreeNode, ICSharpControlFlowGraph> graphBuilder, ValueAnalysisMode valueAnalysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis);
    public sealed virtual void Invalidate(ITreeNode element, PsiChangedElementType elementType);
    [CanBeNullAttribute]
public INullableDataFlowAnalysisResult EnsureNullableAnalysisIsFinished(ICSharpTreeNode treeNode, ValueAnalysisMode valueAnalysisMode);
    internal void EnforceNullableAnalysisRegardlessOfNullableContext(ICSharpTreeNode treeNode, ValueAnalysisMode valueAnalysisMode);
    internal bool IsInspected(ICSharpTreeNode treeNode);
    [CanBeNullAttribute]
private INullableDataFlowAnalysisResult RunOrWaitForInProgressNullableAnalysis(ICSharpTreeNode ownerNode, Func`2<ITreeNode, ICSharpControlFlowGraph> customGraphBuilder, ValueAnalysisMode valueAnalysisMode, bool ignoreNonNullableAnnotationsInValueAnalysis);
    [CanBeNullAttribute]
private static ICSharpTreeNode FindAnalysisOwnerNode(ICSharpTreeNode treeNode);
    [ContractAnnotationAttribute("null => false")]
public static bool IsNullableFlowAnalysisSourceNode(ITreeNode element);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.ScopeAnnotatedResolveContext`1 : ResolveContext {
    [NotNullAttribute]
private Dictionary`2<IExpression, IExpressionType> myAnnotatedExpressionTypes;
    [NotNullAttribute]
private AnnotatedCalculationProcess`1<TReference, TReference> myAnnotatedCalculationProcess;
    [NotNullAttribute]
public IReadOnlyDictionary`2<TReference, ISubstitution> ReInferredSubstitutions { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<TReference, SpecialIndexer> ReInferredIndexers { get; }
    public ScopeAnnotatedResolveContext`1(ITreeNode scope, Dictionary`2<IExpression, IExpressionType> annotatedExpressionTypes);
    private ScopeAnnotatedResolveContext`1(IPsiModule psiModule, Dictionary`2<IExpression, IExpressionType> annotatedExpressionTypes, AnnotatedCalculationProcess`1<TReference, TReference> calculationProcess);
    public IReadOnlyDictionary`2<TReference, ISubstitution> get_ReInferredSubstitutions();
    public IReadOnlyDictionary`2<TReference, SpecialIndexer> get_ReInferredIndexers();
    public virtual IExpressionType ExpressionType(IManagedExpression expression);
    protected virtual ResolveContext CreateForkedResolveContext(ICalculationProcess forkedCalculationProcess);
}
[RequiredMemberAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.SignatureNullabilityMismatch : ValueType {
    [CompilerGeneratedAttribute]
private IType <BaseMemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <OverrideMemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTopLevelAnnotationProblem>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameter <BaseParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameter <OverrideParameter>k__BackingField;
    [RequiredMemberAttribute]
[NotNullAttribute]
public IType BaseMemberType { get; public set; }
    [RequiredMemberAttribute]
[NotNullAttribute]
public IType OverrideMemberType { get; public set; }
    [RequiredMemberAttribute]
public bool IsReturnType { get; public set; }
    [RequiredMemberAttribute]
public bool IsTopLevelAnnotationProblem { get; public set; }
    [CanBeNullAttribute]
public IParameter BaseParameter { get; public set; }
    [CanBeNullAttribute]
public IParameter OverrideParameter { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IType get_BaseMemberType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BaseMemberType(IType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IType get_OverrideMemberType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OverrideMemberType(IType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsReturnType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsReturnType(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsTopLevelAnnotationProblem();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsTopLevelAnnotationProblem(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IParameter get_BaseParameter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BaseParameter(IParameter value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IParameter get_OverrideParameter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OverrideParameter(IParameter value);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.TrackableStructCache : object {
    [NotNullAttribute]
private Dictionary`2<IStruct, bool> myIsEmptyStructCache;
    [NotNullAttribute]
private Dictionary`2<IStruct, bool> myIsTrackableStructCache;
    [ContractAnnotationAttribute("null => false")]
public bool IsEmptyStruct(IType type);
    [ContractAnnotationAttribute("null => false")]
public bool IsTrackableStruct(IType type);
    protected bool IsEmptyStructType(IType type);
    private static bool HasLayoutProblems(IStruct struct);
    private static bool IsEmptyStructImpl(IType type, HashSet`1<IDeclaredType> visitedInitiallyInitialized);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.TypeInferenceRuntimeNullabilityRewriter : TypeRewriterBase`1<Unit> {
    public static TypeInferenceRuntimeNullabilityRewriter Instance;
    private static TypeInferenceRuntimeNullabilityRewriter();
    public virtual IType VisitType(IType type, Unit context);
    public static IType Rewrite(IType type);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.TypeSymbolWithAnnotations : ValueType {
    private object myUnderlyingElement;
    [CompilerGeneratedAttribute]
private NullableAnnotation <NullableAnnotation>k__BackingField;
    [NotNullAttribute]
public IExpressionType UnderlyingType { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsConditionalAccessNullBranchType { get; }
    private TypeSymbolWithAnnotations(ITreeNode treeNode);
    public TypeSymbolWithAnnotations(IType underlyingType);
    public TypeSymbolWithAnnotations(IExpressionType underlyingType, NullableAnnotation annotation);
    public TypeSymbolWithAnnotations(TypeSymbolWithAnnotations underlyingType, NullableAnnotation annotation);
    public static TypeSymbolWithAnnotations CreateConditionalAccessNullBranchType(CSharpConditionalAccessMultiplexor conditionalAccessMultiplexor);
    public static TypeSymbolWithAnnotations CreateConditionalAccessNullBranchType(ConditionalAccessNullExitMultiplexor conditionalAccessMultiplexor, ITreeNode context);
    public static TypeSymbolWithAnnotations UnknownType(ITreeNode context);
    public static TypeSymbolWithAnnotations UnknownType(IPsiModule psiModule);
    public IExpressionType get_UnderlyingType();
    [CompilerGeneratedAttribute]
public NullableAnnotation get_NullableAnnotation();
    public bool get_IsConditionalAccessNullBranchType();
    internal bool IsPossiblyNullableReferenceTypeTypeParameter();
    internal NullableAnnotation GetValueNullableAnnotation();
    [NotNullAttribute]
public IExpressionType ToExpressionType();
    public TypeSymbolWithAnnotations WithAnnotation(NullableAnnotation annotation);
    public TypeSymbolWithAnnotations WithUnknownSubstate();
    public TypeSymbolWithAnnotations WithUnknownSubstate(bool setUnknownSubstate);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay()}")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.VariableIdentifier : ValueType {
    [CanBeNullAttribute]
private DeclaredElementInstance myDeclaredElementInstance;
    public int ContainingSlot;
    public NullableAnnotation DefaultRValueAnnotation;
    public NullableAnnotation DefaultRValueValueAnnotation;
    public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public bool Exists { get; }
    internal VariableIdentifier(IDeclaredElement declaredElement, ISubstitution substitution, int containingSlot);
    public VariableIdentifier(IDeclaredElement declaredElement, ISubstitution substitution, NullableAnnotation defaultRValueAnnotation, NullableAnnotation defaultRValueValueAnnotation, int containingSlot);
    public IDeclaredElement get_DeclaredElement();
    public ISubstitution get_Substitution();
    public bool get_Exists();
    public sealed virtual bool Equals(VariableIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(VariableIdentifier left, VariableIdentifier right);
    public static bool op_Inequality(VariableIdentifier left, VariableIdentifier right);
    internal string GetDebuggerDisplay();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullableAnalysis.WithExpressionDeclaredElementPlaceholder : object {
    [NotNullAttribute]
private IWithExpression myWithExpression;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsConstant { get; }
    public bool IsWritable { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ReferenceKind ReferenceKind { get; }
    public WithExpressionDeclaredElementPlaceholder(IWithExpression withExpression, IType annotatedType);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual bool IsValid();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual ReferenceKind get_ReferenceKind();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.NullCoalescingConstantNullExitMultiplexor : CSharpControlFlowMultiplexor {
    [CompilerGeneratedAttribute]
private ControlFlowEdgeCondition <Condition>k__BackingField;
    public ControlFlowEdgeCondition Condition { get; }
    public NullCoalescingConstantNullExitMultiplexor(ControlFlowEdgeCondition condition);
    [CompilerGeneratedAttribute]
public ControlFlowEdgeCondition get_Condition();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.PatternMatchingCandidateData : object {
    public bool IsNotEqualsNullCheck;
    [NotNullAttribute]
public ILocalVariableDeclaration Declaration;
    [NotNullAttribute]
public ICSharpExpression ParentExpression;
    [CanBeNullAttribute]
public ITreeNode ParentNode;
    [CanBeNullAttribute]
public ITreeNode DefinitelyAssignedScope;
    [NotNullAttribute]
public ICSharpExpression NullCheckExpression;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<ICSharpExpression> ExpressionsExecutedBeforeCheck;
    [NotNullAttribute]
public ILocalVariable Variable { get; }
    private PatternMatchingCandidateData(ICSharpExpression parentExpression, IReadOnlyList`1<ICSharpExpression> expressionsExecutedBeforeCheck, ILocalVariableDeclaration declaration, ICSharpExpression nullCheckExpression, bool isNotEqualsNullCheck);
    private PatternMatchingCandidateData(ICSharpExpression parentExpression, ITreeNode parentNode, ITreeNode definitelyAssignedScope, IReadOnlyList`1<ICSharpExpression> expressionsExecutedBeforeCheck, ILocalVariableDeclaration declaration, ICSharpExpression nullCheckExpression, bool isNotEqualsNullCheck);
    public ILocalVariable get_Variable();
    [NotNullAttribute]
public static PatternMatchingCandidateData Create(ICSharpExpression topmostExpression, ILocalVariableDeclaration declaration, ICSharpExpression nullCheckExpression, IReadOnlyList`1<ICSharpExpression> expressionsExecutedBeforeCheck, bool isAssignedOnTrueBranch, bool isNotEqualsNullCheck);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.PredictiveDebuggerUtils : object {
    [ExtensionAttribute]
public static bool IsArgumentMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsConditionBranchMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsCatchBlockRegularEndpointMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsFinallyEndPointMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsControlFlowImplicitReturn(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsElementAccessMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsCSharpConditionalAccessMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsTryRegularEndPointMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsCSharpControlFlowMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsThrowEndPoint(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsMayThrowInsideCatchMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsWithExpressionInitializerEntryMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsCSharpControlFlowUsingStatement(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsInterpolatedStringHandlerConstructorMultiplexor(IControlFlowElement element);
    [ExtensionAttribute]
public static bool IsNullCoalescingConstantNullExitMultiplexor(IControlFlowElement element);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.SwitchConditionMultiplexor : CSharpControlFlowMultiplexor {
    private IType myGoverningType;
    public SwitchConditionMultiplexor(ISwitchStatement switchStatement, CSharpControlFlowBuilderParams params);
    public SwitchConditionMultiplexor(ISwitchExpression switchExpression, CSharpControlFlowBuilderParams params);
    public IType GetGoverningType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.SwitchDecisionMultiplexor : CSharpControlFlowMultiplexor {
    public SwitchDecisionMultiplexor(ITreeNode referencedElement);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.SwitchExpressionEndpointMultiplexor : CSharpControlFlowMultiplexor {
    public SwitchExpressionEndpointMultiplexor(ITreeNode referencedElement);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.SwitchExpressionNormalExitMultiplexor : CSharpControlFlowMultiplexor {
    public SwitchExpressionNormalExitMultiplexor(ITreeNode referencedElement);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.TypeCompatibilityCache : object {
    private VariableIndex myVariableIndex;
    private ICSharpTypeConversionRule myTypeConversionRule;
    private Nullable`1[0...,0...] myTypeCompatibilityMap;
    public TypeCompatibilityCache(VariableIndex index, ICSharpTypeConversionRule typeConversionRule);
    public bool ExistsTypeWhichIsBoth(IList`1<int> it1, IList`1<int> it2);
    public bool ExistsTypeWhichIsBoth(int it1, int it2);
    private bool CalcExistsTypeWhichIsBoth(IType t1, IType t2);
    private bool IsConvertiblePredefined(IType t1, IType t2);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex : object {
    private int myMaxVariableNumber;
    private ICSharpTypeConversionRule myConversionRule;
    private List`1<VariableInfo> myAllVariables;
    private List`1<ControlFlowWeakVariableInfo> myThisClassWeakVariables;
    private OneToListMap`2<IDeclaredElement, VariableInfo> myVariablesByElement;
    private Dictionary`2<ICSharpExpression, VariableInfo> myInfoByExpressionCache;
    private Dictionary`2<IDeclaredElement, IList`1<VariableInfo>> myHasVariableInQualifierCache;
    private Dictionary`2<ICSharpExpression, IList`1<VariableInfo>> myHasExpressionInQualifierCache;
    private Dictionary`2<IControlFlowElement, ControlFlowHistoryCheckPointInfo> myCheckPoints;
    private OneToSetMap`2<IControlFlowElement, ControlFlowHistoryCheckPointInfo> myHistoryCheckPointsOverElement;
    private Dictionary`2<IType, int> myTypeIndex;
    private List`1<IType> myTypeIndexList;
    private Dictionary`2<Pair`2<int, int>, bool> myImplicitReferenceConversionCache;
    private Dictionary`2<Pair`2<int, int>, bool> myImplicitPredefinedConversionCache;
    private OneToListMap`2<IScope, VariableInfo> myVariablesPerLocalScope;
    private Dictionary`2<IScope, int> myLastVariableIndexInLocalScope;
    private int mySimultaneousHistoryCheckPoints;
    private int myMaxSimultaneousVariables;
    [CompilerGeneratedAttribute]
private ControlFlowStrictVariableInfo <This>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountVariablesForAccessStateAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NextValueAnalysisIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueAnalysisMode <ValueAnalysisMode>k__BackingField;
    [CanBeNullAttribute]
public ControlFlowStrictVariableInfo This { get; public set; }
    public int CountVariablesForAccessStateAnalysis { get; private set; }
    internal int NextValueAnalysisIndex { get; internal set; }
    public int CountVariablesForValueAnalysis { get; }
    public ValueAnalysisMode ValueAnalysisMode { get; }
    internal bool HasTooManyVariables { get; }
    public int TotalTypes { get; }
    public VariableIndex(ValueAnalysisMode valueAnalysisMode, int maxVariableNumber, ICSharpTypeConversionRule conversionRule);
    [CompilerGeneratedAttribute]
public ControlFlowStrictVariableInfo get_This();
    [CompilerGeneratedAttribute]
public void set_This(ControlFlowStrictVariableInfo value);
    [CompilerGeneratedAttribute]
public int get_CountVariablesForAccessStateAnalysis();
    [CompilerGeneratedAttribute]
private void set_CountVariablesForAccessStateAnalysis(int value);
    [CompilerGeneratedAttribute]
internal int get_NextValueAnalysisIndex();
    [CompilerGeneratedAttribute]
internal void set_NextValueAnalysisIndex(int value);
    public int get_CountVariablesForValueAnalysis();
    [CompilerGeneratedAttribute]
public ValueAnalysisMode get_ValueAnalysisMode();
    internal bool get_HasTooManyVariables();
    public void AddVariable(VariableInfo info, bool addToValueAnalysis, bool addToAccessAnalysis);
    public void EnsureAnalyzed(VariableInfo info);
    public void AddType(IType type);
    public int GetTypeIndex(IType type);
    [NotNullAttribute]
public IType GetTypeByIndex(int index);
    public int get_TotalTypes();
    [CanBeNullAttribute]
public ControlFlowHistoryCheckPointInfo GetHistoryCheckPoint(IControlFlowElement element);
    [CanBeNullAttribute]
public VariableInfo FindMemberVariableInfo(VariableInfo parentVariableInfo, IDeclaredElement memberElement);
    [NotNullAttribute]
public IList`1<ControlFlowHistoryCheckPointInfo> GetInvalidatedHistoryCheckPoints(IControlFlowElement from, IControlFlowElement to);
    [CanBeNullAttribute]
[PureAttribute]
private VariableInfo FindCheckedVariableInfo(ICSharpExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
private static VariableInfo FindRestTupleComponentParentVariableInfo(IReferenceExpression componentReferenceExpression, DecoratedType`1<TupleTypeDecoration> tupleType, VariableInfo tupleVariableInfo);
    [CanBeNullAttribute]
[PureAttribute]
public VariableInfo FindLocalOrClosureVariable(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
[PureAttribute]
public VariableInfo FindVariableFromAnotherContext(VariableInfo variableInfo);
    [CanBeNullAttribute]
[PureAttribute]
public VariableInfo FindWeakStaticVariable(IDeclaredElement element);
    [CanBeNullAttribute]
[PureAttribute]
public VariableInfo FindWeakThisInstanceVariable(IDeclaredElement element);
    [CanBeNullAttribute]
[PureAttribute]
private VariableInfo FindByExpression(ICSharpExpression expression);
    [NotNullAttribute]
public IEnumerable`1<VariableInfo> HasInQualifier(ICSharpExpression expression);
    public IEnumerable`1<VariableInfo> HasInQualifier(IDeclaredElement element);
    private static bool FindReferenceToElement(IDeclaredElement element, ICSharpExpression qualifier);
    public Enumerator<VariableInfo> GetEnumerator();
    private sealed virtual override IEnumerator`1<VariableInfo> System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CanBeNullAttribute]
public VariableInfo Find(ICSharpExpression expression, IResolveContext resolveContext);
    [CanBeNullAttribute]
public VariableInfo Find(ICSharpExpression expression, IResolveContext resolveContext, ICSharpExpression& variableAccessExpression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableIndex/<EnumerateHistoryCheckpointIndices>d__63")]
[NotNullAttribute]
public IEnumerable`1<int> EnumerateHistoryCheckpointIndices();
    public bool ImplicitReferenceConversionExists(int fromTypeIndex, int toTypeIndex);
    public bool IsImplicitlyConvertiblePredefined(int fromTypeIndex, int toTypeIndex);
    [CanBeNullAttribute]
public VariableInfo FindVariableInfo(IPropertyInitializer propertyInitializer);
    [CanBeNullAttribute]
public VariableInfo FindVariableInfo(IWithInitializerAssignment initializerAssignment);
    internal void AddVariablesInScope(IScope scope, IReadOnlyList`1<VariableInfo> variableInfos);
    [NotNullAttribute]
internal IEnumerable`1<VariableInfo> GetVariablesInScope(IScope localScope);
    internal int GetLastVariableIndexInLocalScope(IScope localScope);
    public static bool IsActiveScopeForControlFlow(IScope scope);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.VariableInfo : object {
    [CanBeNullAttribute]
private VariableIndex myVariableIndex;
    private VariableInfo myParent;
    [CompilerGeneratedAttribute]
private IClrDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowVariableAccessState <InitialAccessState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPureEnumerable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AccessStateIndex>k__BackingField;
    private bool myHashCodeIsCalculated;
    private int myMemorySnapshotIndex;
    protected TypeFlags myTypeFlags;
    public VariableInfo Parent { get; protected set; }
    public IClrDeclaredElement DeclaredElement { get; }
    public ControlFlowVariableAccessState InitialAccessState { get; protected set; }
    public bool ShouldBeAssignedUponExit { get; }
    public ControlFlowVariableType VariableType { get; }
    public bool IsWeak { get; }
    [NotNullAttribute]
public CSharpControlFlowVariableValue[] DefaultNreValue { get; }
    [NotNullAttribute]
public CSharpControlFlowVariableValue[] InitialNreValue { get; }
    public bool IsPureEnumerable { get; protected set; }
    public int AccessStateIndex { get; public set; }
    public int MemorySnapshotIndex { get; public set; }
    public bool IsOfNullableType { get; }
    public bool IsOfValueType { get; }
    [NotNullAttribute]
public IType Type { get; }
    public IList`1<VariableInfo> NestedVariableInfos { get; }
    public bool CanBeAssignedFromStructFields { get; }
    public bool IsTrackedInValueAnalysis { get; }
    public bool IsTrackedInAccessStateAnalysis { get; }
    protected VariableInfo(IClrDeclaredElement element);
    public virtual VariableInfo get_Parent();
    protected virtual void set_Parent(VariableInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual IClrDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public sealed virtual ControlFlowVariableAccessState get_InitialAccessState();
    [CompilerGeneratedAttribute]
protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InitialAccessState(ControlFlowVariableAccessState value);
    public virtual bool get_ShouldBeAssignedUponExit();
    public abstract virtual ControlFlowVariableType get_VariableType();
    public abstract virtual bool get_IsWeak();
    public abstract virtual CSharpControlFlowVariableValue[] get_DefaultNreValue();
    public virtual CSharpControlFlowVariableValue[] get_InitialNreValue();
    [CompilerGeneratedAttribute]
public bool get_IsPureEnumerable();
    [CompilerGeneratedAttribute]
protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsPureEnumerable(bool value);
    [CompilerGeneratedAttribute]
public int get_AccessStateIndex();
    [CompilerGeneratedAttribute]
public void set_AccessStateIndex(int value);
    public int get_MemorySnapshotIndex();
    public void set_MemorySnapshotIndex(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool get_IsOfNullableType();
    public virtual bool get_IsOfValueType();
    [PureAttribute]
private TypeFlags CalculateTypeFlags();
    public abstract virtual IType get_Type();
    public abstract virtual IList`1<VariableInfo> get_NestedVariableInfos();
    public abstract virtual bool get_CanBeAssignedFromStructFields();
    [PureAttribute]
protected static bool IsDescendantOfEnumerable(IType type);
    [CanBeNullAttribute]
[PureAttribute]
public VariableInfo FindChildStructFieldVariableInfo(string fieldName, bool caseSensitive);
    internal void AssignOwnerVariableIndex(VariableIndex variableIndex);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
internal void AssertOwnership(CSharpControlFlowContext context);
    public sealed virtual bool get_IsTrackedInValueAnalysis();
    public sealed virtual bool get_IsTrackedInAccessStateAnalysis();
    protected static bool ShouldTrackEnumerationAccess(IDeclaredElement declaredElement);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ControlFlow.WithExpressionInitializerEntryMultiplexor : CSharpControlFlowMultiplexor {
    [NotNullAttribute]
public IWithExpression WithExpression { get; }
    public WithExpressionInitializerEntryMultiplexor(IWithExpression withExpression);
    public IWithExpression get_WithExpression();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpAnonymousTypeSearcher : object {
    private IList`1<AnonymousTypeDescriptor> myTypeDescription;
    private bool myCaseSensitive;
    public CSharpAnonymousTypeSearcher(IList`1<AnonymousTypeDescriptor> typeDescription, bool caseSensitive);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    private bool EqualsDescriptor(IList`1<AnonymousTypeDescriptor> descriptor);
}
[DebuggerDisplayAttribute("CSharpAttributeInstance({myAttribute.Name.ShortName})")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpAttributeInstance : object {
    [NotNullAttribute]
private IAttribute myAttribute;
    [NotNullAttribute]
public IAttribute Attribute { get; }
    public IConstructor Constructor { get; }
    public int PositionParameterCount { get; }
    private int JetBrains.ReSharper.Psi.IAttributeInstance.NamedParameterCount { get; }
    public CSharpAttributeInstance(IAttribute attribute);
    public IAttribute get_Attribute();
    public sealed virtual IDeclaredType GetAttributeType();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual string GetAttributeShortName();
    public sealed virtual IConstructor get_Constructor();
    [NotNullAttribute]
private static AttributeValue GetAttributeValue(ICSharpExpression value, IType targetType);
    public sealed virtual int get_PositionParameterCount();
    public sealed virtual AttributeValue PositionParameter(int paramIndex);
    [CanBeNullAttribute]
private AttributeValue[] GetPositionalParameters();
    public sealed virtual IEnumerable`1<AttributeValue> PositionParameters();
    [NotNullAttribute]
private static AttributeValue GetAttributeValue(IPropertyAssignment propertyAssignment);
    [NotNullAttribute]
private static AttributeValue GetAttributeValue(ICSharpArgument argument);
    private sealed virtual override int JetBrains.ReSharper.Psi.IAttributeInstance.get_NamedParameterCount();
    public sealed virtual AttributeValue NamedParameter(string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CSharpAttributeInstance/<NamedParameters>d__20")]
public sealed virtual IEnumerable`1<Pair`2<string, AttributeValue>> NamedParameters();
    [NotNullAttribute]
public AttributeValue NamedParameter(ITypeMember typeMember);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpCodeAnnotationProvider : object {
    public sealed virtual Nullable`1<CodeAnnotationNullableValue> GetNullableAttribute(IDeclaredElement element);
    public sealed virtual Nullable`1<CodeAnnotationNullableValue> GetContainerElementNullableAttribute(IDeclaredElement element);
    public sealed virtual ICollection`1<IAttributeInstance> GetSpecialAttributeInstances(IClrDeclaredElement element, AttributeInstanceCollection attributeInstanceCollection);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpConstructorSpecialReferenceSearcher : object {
    [NotNullAttribute]
private HashSet`1<IConstructor> myConstructors;
    public CSharpConstructorSpecialReferenceSearcher(IEnumerable`1<IConstructor> constructors);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
}
[DeclaredElementIconProviderAttribute("0", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpDeclaredElementImageProvider : object {
    public sealed virtual IconId GetImageId(IDeclaredElement declaredElement, PsiLanguageType languageType, Boolean& canApplyExtensions);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpDeclaredElementPresenter : object {
    [NotNullAttribute]
public static CSharpDeclaredElementPresenter Instance { get; }
    public static CSharpDeclaredElementPresenter get_Instance();
    public virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement declaredElement, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    [NotNullAttribute]
[PureAttribute]
public static string AccessorName(IAccessor accessor);
    [NotNullAttribute]
[PureAttribute]
public static string AccessorName(CSharpAccessorKind accessorKind);
    [NotNullAttribute]
public virtual string Format(ParameterKind parameterKind);
    [NotNullAttribute]
public virtual string Format(AccessRights accessRights);
    private static bool ShowParameterList(IDeclaredElement element, DeclaredElementPresenterStyle style);
    [NotNullAttribute]
private RichText FormatAnonymousMethod(DeclaredElementPresenterStyle style, IAnonymousMethod anonymousMethod, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    private RichText FormatAliasedSymbol(DeclaredElementPresenterStyle style, ISymbolAlias symbolAlias, DeclaredElementPresenterMarking& marking, Boolean& isTypeAlias);
    private RichText GetAliasedSymbolRichText(DeclaredElementPresenterStyle style, ISymbolAlias symbolAlias);
    [NotNullAttribute]
private static RichText GetQualifiedNameRichText(DeclaredElementPresenterStyle style, ITypeElement typeElement, ISubstitution substitution, bool appendOwnTypeParameters, TextRange& containerRange);
    [NotNullAttribute]
private static RichText GetNestedTypeNameRichText(DeclaredElementPresenterStyle presenter, ITypeElement typeElement, ISubstitution substitution, bool appendOwnTypeParameters);
    [NotNullAttribute]
private static RichText GetTypeParametersRichText(DeclaredElementPresenterStyle presenter, IList`1<ITypeParameter> typeParameters, ISubstitution substitution, int currentLength, TextRange[]& typeParameterRanges);
    private static bool CheckIsMember(IDeclaredElement declaredElement);
    private static bool CheckIsType(IDeclaredElement declaredElement);
    private static bool CheckIsNamespace(IDeclaredElement element);
    private static TextRange AppendString(RichText sb, string substr, TextStyle textStyle);
    private static TextRange AppendRichText(RichText sb, RichText substr);
    public virtual string GetEntityKind(IDeclaredElement declaredElement);
    [NotNullAttribute]
private static RichText GetElementNameRichText(IDeclaredElement declaredElement, DeclaredElementPresenterStyle style);
    [CanBeNullAttribute]
public static string GetSignOperatorName(ISignOperator signOperator);
    [NotNullAttribute]
[PureAttribute]
public static string ParameterKindText(ParameterKind parameterKind, bool appendSpaceIfByRef);
    [NotNullAttribute]
[PureAttribute]
public static string ReturnKindText(ReferenceKind referenceKind, bool appendSpaceIfByRef);
    [NotNullAttribute]
private static RichText GetConstantValueStr(IDeclaredElement element, ISubstitution substitution, TypePresentationStyle typePresentationStyle);
    [CanBeNullAttribute]
private static IType GetElementType(IDeclaredElement declaredElement, ISubstitution substitution, DeclaredElementPresenterStyle style);
    [NotNullAttribute]
private static string GetParameterBrackets(IDeclaredElement element);
    [NotNullAttribute]
private static string GetParameterKindStr(IParameter parameter);
    [NotNullAttribute]
private static RichText GetTypeRichText(DeclaredElementPresenterStyle presenter, IType type, TextRange& scalarRange);
    [NotNullAttribute]
private static RichText GetElementTypeRichText(DeclaredElementPresenterStyle style, IDeclaredElement declaredElement, ISubstitution substitution, TextRange& scalarRange);
    private static void FormatInvocableParameter(DeclaredElementPresenterStyle style, IParameter param, RichText richText, ISubstitution substitution, Parameter range);
    [NotNullAttribute]
private static RichText GetParameterDefaultValueRichText(DeclaredElementPresenterStyle presenter, IParameter parameter, ISubstitution substitution);
    [NotNullAttribute]
private static RichText GetParametersListRichText(DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, Parameter[]& ranges);
    [NotNullAttribute]
private RichText GetContainerRichText(DeclaredElementPresenterStyle style, IDeclaredElement declaredElement, ISubstitution substitution, TextRange& containerNameRange);
    [NotNullAttribute]
private static IList`1<ITypeParameter> GetTypeParameters(IDeclaredElement declaredElement);
    private static bool HasTypeParameters(ITypeElement element);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpDeclaredElementType : DeclaredElementTypeBase {
    public static DeclaredElementType EXTERN_ALIAS;
    public static DeclaredElementType NAMESPACE_OR_TYPE_ALIAS;
    public static DeclaredElementType ANONYMOUS_METHOD;
    public static DeclaredElementType LOCAL_FUNCTION;
    public static DeclaredElementType TOP_LEVEL_ENTRY_POINT;
    public static DeclaredElementType RECORD;
    public static DeclaredElementType RECORD_STRUCT;
    protected IDeclaredElementPresenter DefaultPresenter { get; }
    private CSharpDeclaredElementType(string name, IconId imageName);
    private static CSharpDeclaredElementType();
    protected virtual IDeclaredElementPresenter get_DefaultPresenter();
    public virtual bool IsPresentable(PsiLanguageType language);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpElementFactoryImpl : CSharpElementFactory {
    [CanBeNullAttribute]
private ICSharpCodeFormatter myCodeFormatter;
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private static LanguageService LanguageService { get; }
    internal CSharpElementFactoryImpl(IPsiModule module, bool applyCodeFormatter);
    private static LanguageService get_LanguageService();
    private static ICSharpParser CreateParser(string text);
    private bool ReplaceTypeUsageNode(ITreeNode node, IType type, TypePresentationOptions options);
    [CanBeNullAttribute]
private static ITreeNode FindNodeAtRangeByType(ITreeNode node, Type type);
    [NotNullAttribute]
private ITreeNode SubstituteNodes(ITreeNode root, IReadOnlyList`1<ParameterMarker> markers, Object[] args);
    private void SubstituteWithTypeUsage(ITypeUsage typeUsage, int index, ITreeNode node);
    private void SubstituteWithType(IType type, int index, ITreeNode node, ITreeNode root);
    private static void SubstituteWithDeclaredElementInstance(DeclaredElementInstance instance, ITreeNode node);
    [CanBeNullAttribute]
private TTreeNode ExtractNode(TTreeNode element);
    protected virtual ICSharpFile CreateFileImpl(string format, Object[] args);
    public virtual IBlock CreateBlock(string format, Object[] args);
    public virtual ITopLevelCode CreateTopLevelCode();
    public virtual ICSharpExpression CreateExpressionAsIs(string format, bool applyCodeFormatter);
    public virtual ICSharpExpression CreateExpressionAsIs(string format);
    public virtual ICSharpExpression CreateExpression(string format, Object[] args);
    public virtual IThrowExpression CreateThrowExpression(string format, Object[] args);
    public virtual IDeclarationExpression CreateDeclarationExpression(string format, Object[] args);
    public virtual ICSharpTypeMemberDeclaration CreateTypeMemberDeclaration(string format, Object[] args);
    public virtual ICSharpStatement CreateStatement(string format, Object[] args);
    public virtual IUsingDirective CreateUsingDirective(string format, Object[] args);
    public virtual IUsingDirective CreateUsingStaticDirective(string format, Object[] args);
    public virtual IExternAliasDirective CreateExternAliasDirective(string externAlias);
    public virtual IBlock CreateEmptyBlock();
    public virtual IReferenceExpression CreateReferenceExpression(string expr, Object[] args);
    public virtual IReferenceName CreateReferenceName(string name, Object[] args);
    public virtual ICSharpNamespaceDeclaration CreateNamespaceDeclaration(string name, bool isFileScoped);
    public virtual ICSharpParameterDeclaration CreateParameterDeclaration(IParametersOwnerDeclaration ownerDeclaration, ParameterKind kind, bool isParams, bool isVarArg, IType type, string name, ICSharpExpression defaultValue);
    public virtual ICSharpParameterDeclaration CreateTypeMemberParameterDeclaration(ParameterKind kind, bool isParams, bool isVarArg, IType type, string name, ICSharpExpression defaultValue);
    public virtual ICSharpArgument CreateArgument(ParameterKind kind, ICSharpExpression arg);
    public virtual ICSharpArgument CreateArgument(ParameterKind kind, string name, ICSharpExpression arg);
    public virtual ITupleComponent CreateTupleComponent(ICSharpExpression arg);
    public virtual ITupleComponent CreateTupleComponent(string name, ICSharpExpression arg);
    public virtual IVariableDesignation CreateVariableDesignation(string template, Object[] args);
    public virtual IDiscardDesignation CreateDiscardDesignation();
    public virtual IPattern CreatePattern(string template, Object[] args);
    public virtual IDiscardPattern CreateDiscardPattern();
    public virtual ISwitchExpression CreateEmptySwitchExpression();
    public virtual IPropertyAssignment CreatePropertyAssignment(string name, ICSharpExpression arg);
    public virtual IAccessorDeclaration CreateAccessorDeclaration(AccessorKind kind, bool withBody);
    public virtual IAccessorDeclaration CreateAccessorDeclaration(CSharpAccessorKind kind, bool withBody);
    public virtual IAccessorDeclaration CreateAccessorDeclaration(string format, Object[] args);
    public virtual IConstructorInitializer CreateThisConstructorInitializer();
    public virtual IConstructorInitializer CreateBaseConstructorInitializer();
    public virtual IConstructorDeclaration CreateConstructorDeclaration();
    public virtual IDestructorDeclaration CreateDestructorDeclaration();
    public virtual ITypeParameterOfLocalFunctionDeclaration CreateTypeParameterOfLocalFunctionDeclaration(string name);
    public virtual ITypeParameterOfTypeDeclaration CreateTypeParameterOfTypeDeclaration(string name);
    public virtual ITypeParameterOfMethodDeclaration CreateTypeParameterOfMethodDeclaration(string name);
    public virtual ITypeParameterConstraintsClause CreateTypeParameterConstraintsClause(ITypeParameter typeParameter, ISubstitution substitution, string parameterName);
    public virtual IArrayCreationExpression CreateArrayCreationExpression(IArrayType arrayType, IArrayInitializer arrayInitializer);
    public virtual IAttribute CreateAttribute(IAttributeInstance instance);
    public virtual IAttribute CreateAttribute(ITypeElement attributeClass, AttributeValue[] fixedArguments, Pair`2[] namedArguments);
    public virtual IWhitespaceNode[] CreateWhitespaces(string whitespaces);
    public virtual ICSharpCommentNode CreateComment(string text);
    private static void FormatAttributeValue(FactoryArgumentsBuilder& builder, AttributeValue value);
    public virtual ITypeUsage CreateTypeUsage(string typeUsageText);
    public virtual ITypeUsage CreateTypeUsage(string typeUsage, Object[] args);
    [CanBeNullAttribute]
[PureAttribute]
private IType PatchTypeForBuilder(IType type);
    public virtual ITypeUsage CreateTypeUsage(IType type, ITreeNode context, Nullable`1<TypePresentationOptions> options);
    [PureAttribute]
[NotNullAttribute]
private ITypeUsage CreateTypeUsageFromType(IType type, ITreeNode context, TypePresentationOptions options);
    [NotNullAttribute]
private IFunctionPointerTypeUsage CreateFunctionPointerTypeUsageFromType(IFunctionPointerType functionPointerType, ITreeNode context, TypePresentationOptions options);
    [NotNullAttribute]
private ITypeUsage CreateArrayTypeUsageFromType(IArrayType arrayType, ITreeNode context, TypePresentationOptions options);
    [NotNullAttribute]
private ITypeUsage CreateTupleTypeUsageFromType(IReadOnlyList`1<TupleTypeComponent> tupleComponents, ITreeNode context, TypePresentationOptions options);
    [CanBeNullAttribute]
private ICSharpExpression CreateTypeParsedAsExpression(string typeName);
    [CanBeNullAttribute]
private ICSharpExpression CreateTypeParsedAsExpression(IDeclaredType type);
    public virtual ICSharpLiteralExpression CreateStringLiteralExpression(string value);
    public virtual ICSharpExpression CreateExpressionByDefaultValue(DefaultValue value, ITreeNode context);
    public virtual ICSharpExpression CreateExpressionByConstantValue(ConstantValue value);
    public virtual ICSharpExpression CreateExpressionByConstantValue(ConstantValue value, bool safeConstantValueExactType, int qualifierDepth);
    public virtual IDocCommentBlock CreateDocCommentBlock(string text);
    public virtual IDocCommentNode CreateDocComment(string text, bool useMultiline);
    public virtual IAnonymousMemberDeclaration CreateAnonymousMemberDeclaration(string name, ICSharpExpression expression);
    public virtual IAnonymousMemberDeclaration CreateAnonymousMemberDeclaration(ICSharpExpression expression);
    public virtual Pair`2<IStartRegion, IEndRegion> CreateRegionDirective(string name);
    public virtual INullableDirective CreateNullableDirective(NullableDirectiveSettingKind settingKind, Nullable`1<NullableDirectiveTargetKind> targetKind);
    public virtual IPreprocessorDirective CreatePreprocessorDirectiveAsIs(string directive);
    public virtual IObjectInitializer CreateObjectInitializer();
    public virtual ICollectionInitializer CreateCollectionInitializer();
    public virtual IPropertyInitializer CreateObjectPropertyInitializer(string propertyName, ICSharpExpression expression);
    public virtual ICollectionElementInitializer CreateCollectionElementInitializer(ICSharpExpression[] expressions);
    public virtual IExpressionElement CreateCollectionExpressionElement(ICSharpExpression expression);
    public virtual ISpreadElement CreateCollectionExpressionSpread(ICSharpExpression collectionExpression);
    public virtual IExpressionInitializer CreateExpressionInitializer(ICSharpExpression expression);
    public virtual IQueryClause CreateQueryClause(string clause, Object[] args);
    public virtual IQueryRangeVariableDeclaration CreateRangeVariableDeclaration(string name, IType type);
    public virtual IQueryParameterPlatform CreateQueryPlatform(ICSharpExpression e);
    public virtual IPropertyDeclaration CreatePropertyDeclaration(IType type, string name);
    public virtual IIndexerDeclaration CreateIndexerDeclaration(IType type);
    public virtual IFieldDeclaration CreateFieldDeclaration(IType type, string name);
    public virtual ILocalRegularParameterDeclaration CreateLocalRegularParameterDeclaration(IType parameterType, string parameterName, ParameterKind kind, bool isParams, ICSharpExpression defaultValue);
    public virtual ILocalArglistParameterDeclaration CreateLocalArglistParameterDeclaration();
    public virtual IDelegateDeclaration CreateDelegateDeclaration();
    public virtual IEnumMemberDeclaration CreateEnumMemberDeclaration(string enumMemberName);
    public virtual IEventDeclaration CreateEventDeclaration(IDeclaredType eventType, string name);
    public virtual IConstantDeclaration CreateConstDeclaration(IDeclaredType type, string name, string value);
    public virtual ITupleTypeComponent CreateTupleTypeComponent(IType type, string name);
    public virtual ISwitchSection CreateEmptySwitchSection();
    public virtual ISwitchCaseLabel CreateSwitchCaseLabel(string caseTemplate, Object[] args);
    public virtual ISwitchExpressionArm CreateSwitchExpressionArm(string armTemplate, Object[] args);
    [NotNullAttribute]
[PureAttribute]
private static string GetArgumentModifierText(ParameterKind argumentKind);
    [NotNullAttribute]
[PureAttribute]
private static string GetParameterModifierText(ParameterKind parameterKind, bool isParams);
    [CompilerGeneratedAttribute]
private ITypeUsage <CreateTypeUsageFromType>g__WrapToNullableIfNeeded|63_0(ITypeUsage typeUsage, <>c__DisplayClass63_0& );
    [CompilerGeneratedAttribute]
internal static string <CreateNullableDirective>g__MakeFormat|78_0(<>c__DisplayClass78_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpEventAccessTypeProvider : EventAccessTypeProvider {
    public virtual EventAccessType GetEventAccessType(IReference reference);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpGeneratedFilesCacheProvider : object {
    private static string AutoGeneratedPrefix;
    public sealed virtual bool IsGeneratedFile(IPsiSourceFile sourceFile);
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpImplicitlyConvertedToTypeUtil : object {
    [NotNullAttribute]
[PureAttribute]
[DebuggerStepThroughAttribute]
internal static IType ExpressionImplicitlyConvertedToType(IResolveContext resolveContext, ICSharpExpression expression, IExpressionType preCalculatedExpressionType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpImplUtil : object {
    public static void ReplaceIdentifier(ICSharpIdentifier node, string name);
    public static void ReplaceIdentifier(ITreeNode parent, ICSharpIdentifier node, string name);
    [PureAttribute]
public static string MakeSafeName(string name, ITreeNode context);
    [NotNullAttribute]
public static string MakeSafeQualifiedName(string name, ITreeNode context);
    [NotNullAttribute]
public static string MakeClrName(ICSharpTypeDeclaration declaration);
    [NotNullAttribute]
[PureAttribute]
public static string DeclaredName(IOwnerQualification ownerQualification, ICSharpIdentifier identifier);
    [NotNullAttribute]
public static string DeclaredName(ICSharpIdentifier identifier);
    [PureAttribute]
public static TreeTextRange GetNameRange(ICSharpIdentifier identifier);
    [PureAttribute]
public static TreeNodeCollection`1<IClassMemberDeclaration> GetClassMemberDeclarations(IClassLikeDeclaration classLikeDeclaration);
    [ContractAnnotationAttribute("qualification:null => null; qualification:notnull => notnull")]
public static IReferenceName SetInterfaceQualificationReference(IInterfaceQualificationOwner owner, IReferenceName qualification);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool ContainsYieldStatement(IBlock bodyBlock);
    [PureAttribute]
public static bool ContainsFieldKeywordReference(CSharpCodeBody body);
    [PureAttribute]
[CanBeNullAttribute]
public static IPropertyDeclaration IsReferenceExpressionInFieldKeywordContext(ITreeNode context);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool CanContainTargetTypedObjectCreation(IChameleonNode chameleonNode);
    [PureAttribute]
public static bool CanContainTargetTypedObjectCreation(ILexer lexer);
    [NotNullAttribute]
[PureAttribute]
public static IList`1<IAttributeInstance> GetAttributeInstances(IList`1<IAttribute> attributes);
    [NotNullAttribute]
[PureAttribute]
public static IList`1<IAttributeInstance> GetAttributeInstances(IList`1<IAttribute> attributes, IClrTypeName clrName);
    [PureAttribute]
public static bool HasAttributeInstance(IList`1<IAttribute> attributes, IClrTypeName clrName);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IAttributeInstance GetAttributeInstance(IAttribute attribute);
    [NotNullAttribute]
private static HashSet`1<string> BuildAttributeNameAliases(ITreeNode element, IClrTypeName clrName);
    private static bool HasAttributeName(ICollection`1<string> names, IAttribute attribute);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<TElement> ToDeclaredElements(TreeNodeCollection`1<TDeclaration> declarations);
    [CanBeNullAttribute]
public static IDocCommentBlock GetDocCommentBlock(ICSharpDeclaration declaration);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpDeclaration GetOwnerDeclaration(IAttributeSectionList attribute);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IDeclaration GetOwnerDeclaration(IAttribute attribute);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpDeclaration GetOwnerDeclaration(IModifiersListOwner modifiersListOwner);
    public static ValueTuple`2<string, IReadOnlyList`1<ParameterMarker>> ParseFormatString(string format, Object[] args);
    [CompilerGeneratedAttribute]
internal static bool <ContainsYieldStatement>g__ContainsYieldStatementFast|10_0(ProjectedLexer lexer);
    [CompilerGeneratedAttribute]
internal static bool <ContainsFieldKeywordReference>g__ContainsFieldIdentifierFast|11_0(ILexer lexer);
    [CompilerGeneratedAttribute]
internal static void <BuildAttributeNameAliases>g__ProcessUsingDirective|19_0(IUsingDirective usingDirective, <>c__DisplayClass19_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpInterLineAdornmentIndentProvider : object {
    private CSharpCodeFormatter myCodeFormatter;
    public CSharpInterLineAdornmentIndentProvider(CSharpCodeFormatter codeFormatter);
    public sealed virtual bool TryGetIndentWidthInCharacters(ITreeNode node, bool isAboveLine, Int32& indentWidthInCharacters);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpInvocableSignatureComparer : object {
    [NotNullAttribute]
public static ISignatureComparer Override;
    [NotNullAttribute]
public static ISignatureComparer Overload;
    private static CSharpInvocableSignatureComparer();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageLevelHelper : RoslynBasedLanguageLevelHelper`1<CSharpLanguageLevel> {
    public string LanguageName { get; }
    public CSharpLanguageLevelHelper(ILogger logger, ISolutionToolset solutionToolset);
    public virtual string get_LanguageName();
    public bool IsAvailable(CSharpLanguageVersion languageVersion);
    public bool IsAvailable(CSharpLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
private bool IsAvailableCore(CSharpLanguageVersion languageVersion, CSharpLanguageLevel convertedLanguageLevel, CSharpLanguageLevel latestAvailableLanguageLevel);
    public CSharpLanguageLevel GetLatestAvailableLanguageLevelImpl();
    public CSharpLanguageLevel GetLatestAvailableLanguageLevelImpl(IProject project, TargetFrameworkId targetFrameworkId);
    public CSharpLanguageLevel ConvertToLanguageLevel(CSharpLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    public CSharpLanguageLevel ConvertToLanguageLevel(CSharpLanguageVersion languageVersion, ICSharpProjectConfiguration configuration);
    public virtual CSharpLanguageLevel GetLanguageLevelByToolsetVersion(Version2 toolsetVersion);
    public virtual Nullable`1<VersionMapping<CSharpLanguageLevel>> GetLanguageLevelByCompilerVersion(Version2 roslynVersion);
    public string GetPresentation(CSharpLanguageVersion languageVersion, LanguageVersionPresentationOptions options);
    public string GetPresentation(CSharpLanguageVersion languageVersion, LanguageVersionPresentationOptions options, IProject project, TargetFrameworkId targetFrameworkId);
    private string GetPresentationInner(CSharpLanguageVersion languageVersion, LanguageVersionPresentationOptions options, string defaultDescription);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageLevelProjectProperty : OverridableLanguageLevelProjectProperty`2<CSharpLanguageLevel, CSharpLanguageVersion> {
    [NotNullAttribute]
private IPsiModules myPsiModules;
    [NotNullAttribute]
private CSharpLanguageLevelHelper myHelper;
    [NotNullAttribute]
private IJetReadonlyList`1<ILanguageLevelChangeHandler`1<CSharpLanguageLevel>> myLanguageLevelChangeHandlers;
    [CanBeNullAttribute]
public Version2 ToolsetVersion { get; }
    [NotNullAttribute]
public ILogger Logger { get; }
    public IComparer`1<CSharpLanguageLevel> LanguageLevelComparer { get; }
    public string LanguageName { get; }
    public CSharpLanguageLevelProjectProperty(Lifetime lifetime, ILogger logger, ISettingsStore settingsStore, IShellLocks locks, ProjectSettingsStorageComponent projectSettings, ProjectPropertiesListener projectPropertiesListener, PersistentProjectItemProperties persistentProjectItemProperties, ISolutionToolset solutionToolset, IPsiModules psiModules, IJetReadonlyList`1<ILanguageLevelChangeHandler`1<CSharpLanguageLevel>> languageLevelChangeHandlers);
    public Version2 get_ToolsetVersion();
    public ILogger get_Logger();
    public virtual CSharpLanguageVersion GetLanguageVersion(IProject project, TargetFrameworkId targetFrameworkId);
    public virtual IComparer`1<CSharpLanguageLevel> get_LanguageLevelComparer();
    public virtual CSharpLanguageVersion ConvertToLanguageVersion(CSharpLanguageLevel languageLevel);
    public virtual Nullable`1<CSharpLanguageVersion> TryParseCompilationOption(string languageVersion);
    public virtual string ConvertToCompilationOption(CSharpLanguageVersion languageVersion);
    protected virtual void HandleLanguageLevelChange(IProject project, LanguageLevelsPerTargetFramework<CSharpLanguageLevel, CSharpLanguageVersion> oldValues, LanguageLevelsPerTargetFramework<CSharpLanguageLevel, CSharpLanguageVersion> newValues);
    public virtual CSharpLanguageLevel GetDefaultLanguageLevel(IProject project, TargetFrameworkId targetFrameworkId);
    protected virtual CSharpLanguageLevel GetLatestAvailableLanguageLevelImpl(IProject project, TargetFrameworkId targetFrameworkId);
    public virtual CSharpLanguageLevel GetLatestAvailableLanguageLevel(VirtualFileSystemPath compilerDirectoryPath);
    public virtual bool IsAvailable(CSharpLanguageLevel languageLevel, IProject project, TargetFrameworkId targetFrameworkId);
    public virtual bool IsAvailable(CSharpLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    public virtual CSharpLanguageLevel ConvertToLanguageLevel(CSharpLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
public CSharpLanguageLevel ConvertToLanguageLevel(CSharpLanguageVersion languageVersion, VirtualFileSystemPath compilerDirectoryPath);
    protected virtual Nullable`1<CSharpLanguageLevel> GetOverriddenLanguageLevelFromSettings(IContextBoundSettingsStore settingsStore);
    protected virtual void SetOverridenLanguageLevelInSettings(IContextBoundSettingsStore settingsStore, Nullable`1<CSharpLanguageLevel> languageLevel);
    protected virtual bool IsApplicableToProject(IProject project);
    public virtual string get_LanguageName();
    public virtual string GetPresentation(CSharpLanguageVersion languageVersion, LanguageVersionPresentationOptions options, IProject project, TargetFrameworkId targetFrameworkId);
}
[SolutionFeaturePartAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageLevelProvider : CSharpLanguageLevelProviderForAnyModule {
    [CompilerGeneratedAttribute]
private CSharpLanguageLevelProjectProperty <ProjectProperty>k__BackingField;
    [CanBeNullAttribute]
private Lazy`1<ILanguageVersionModifier`1<CSharpLanguageVersion>> myLanguageVersionModifierLazy;
    [CompilerGeneratedAttribute]
private ILanguageLevelOverrider`1<CSharpLanguageLevel> <LanguageLevelOverrider>k__BackingField;
    [NotNullAttribute]
public CSharpLanguageLevelProjectProperty ProjectProperty { get; }
    public ILanguageVersionModifier`1<CSharpLanguageVersion> LanguageVersionModifier { get; }
    public ILanguageLevelOverrider`1<CSharpLanguageLevel> LanguageLevelOverrider { get; }
    public CSharpLanguageLevelProvider(CSharpLanguageLevelProjectProperty projectProperty, Lazy`1<ILanguageVersionModifier`1<CSharpLanguageVersion>> languageVersionModifier);
    [CompilerGeneratedAttribute]
public CSharpLanguageLevelProjectProperty get_ProjectProperty();
    public virtual bool IsApplicable(IPsiModule psiModule);
    public virtual CSharpLanguageLevel GetLanguageLevel(IPsiModule psiModule);
    public virtual Nullable`1<CSharpLanguageVersion> TryGetLanguageVersion(IPsiModule psiModule);
    public virtual bool IsAvailable(CSharpLanguageLevel languageLevel, IPsiModule psiModule);
    public virtual bool IsAvailable(CSharpLanguageVersion languageVersion, IPsiModule psiModule);
    public virtual CSharpLanguageLevel ConvertToLanguageLevel(CSharpLanguageVersion languageVersion, IPsiModule psiModule);
    [PureAttribute]
public virtual CSharpLanguageLevel GetLatestAvailableLanguageLevel(IPsiModule psiModule);
    public virtual ILanguageVersionModifier`1<CSharpLanguageVersion> get_LanguageVersionModifier();
    [CompilerGeneratedAttribute]
public virtual ILanguageLevelOverrider`1<CSharpLanguageLevel> get_LanguageLevelOverrider();
}
[SolutionFeaturePartAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageLevelProviderForAnyModule : object {
    public ILanguageVersionModifier`1<CSharpLanguageVersion> LanguageVersionModifier { get; }
    public ILanguageLevelOverrider`1<CSharpLanguageLevel> LanguageLevelOverrider { get; }
    public virtual bool IsApplicable(IPsiModule psiModule);
    public virtual CSharpLanguageLevel GetLanguageLevel(IPsiModule psiModule);
    public virtual Nullable`1<CSharpLanguageVersion> TryGetLanguageVersion(IPsiModule psiModule);
    public virtual bool IsAvailable(CSharpLanguageLevel languageLevel, IPsiModule psiModule);
    public virtual bool IsAvailable(CSharpLanguageVersion languageVersion, IPsiModule psiModule);
    public virtual CSharpLanguageLevel ConvertToLanguageLevel(CSharpLanguageVersion languageVersion, IPsiModule psiModule);
    public virtual CSharpLanguageVersion ConvertToLanguageVersion(CSharpLanguageLevel languageLevel);
    public virtual CSharpLanguageLevel GetLatestAvailableLanguageLevel(IPsiModule psiModule);
    public virtual ILanguageVersionModifier`1<CSharpLanguageVersion> get_LanguageVersionModifier();
    public virtual ILanguageLevelOverrider`1<CSharpLanguageLevel> get_LanguageLevelOverrider();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeInspectionSettings", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CLanguageSettingsSettingDescription")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageProjectSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CLanguageLevelSettingDescription")]
public ReSharperSettingsCSharpLanguageLevel LanguageLevel;
    [NotNullAttribute]
public static Expression`1<Func`2<CSharpLanguageProjectSettings, ReSharperSettingsCSharpLanguageLevel>> LanguageLevelSelector;
    private static CSharpLanguageProjectSettings();
}
[ProjectSettingsUpgraderAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageProjectSettingsUpgrader : object {
    private IContextBoundSettingsStore myStore;
    public sealed virtual void Upgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime);
    private sealed virtual override void JetBrains.Application.Configuration.IXmlReadable.ReadFromXml(XmlElement element);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageService : LanguageService {
    [NotNullAttribute]
private ICSharpCodeFormatter myCodeFormatter;
    [NotNullAttribute]
private CommonIdentifierIntern myCommonIdentifierIntern;
    [CanBeNullAttribute]
private IDeclaredElementPresenter myPresenter;
    private static string MEMBER_DECLARATION_CAPABILITY;
    private static string STATEMENT_CAPABILITY;
    private static string EXPRESSION_CAPABILITY;
    internal static NodeTypeSet WHITESPACE_OR_COMMENT;
    public static NodeTypeSet PREPROCESSOR_TOKENS;
    [CompilerGeneratedAttribute]
private ILanguageCacheProvider <CacheProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypePresenter <TypePresenter>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IPsiModificationService> <ModificationServices>k__BackingField;
    public bool IsCaseSensitive { get; }
    [NotNullAttribute]
public ILanguageCacheProvider CacheProvider { get; }
    public bool SupportTypeMemberCache { get; }
    [NotNullAttribute]
public ICodeFormatter CodeFormatter { get; }
    public ITypePresenter TypePresenter { get; }
    public IDeclaredElementPresenter DeclaredElementPresenter { get; }
    public IReadOnlyList`1<IPsiModificationService> ModificationServices { get; }
    public CSharpLanguageService(CSharpLanguage language, IConstantValueService constantValueService, ICSharpCodeFormatter codeFormatter, CommonIdentifierIntern commonIdentifierIntern, ILanguageCacheProvider cacheProvider);
    private static CSharpLanguageService();
    public virtual ILexerFactory GetPrimaryLexerFactory();
    public virtual ILexer CreateFilteringLexer(ILexer lexer);
    public virtual bool IsValidName(DeclaredElementType elementType, string name);
    [NotNullAttribute]
public virtual IParser CreateParser(ILexer lexer, IPsiModule module, IPsiSourceFile sourceFile);
    [NotNullAttribute]
public ICSharpParser CreateParser(ILexer lexer, IEnumerable`1<PreProcessingDirective> defines, CSharpLanguageLevel languageLevel);
    public virtual IEnumerable`1<string> EnumerateParserCapabilities();
    public virtual ITreeNode ParseUsingCapability(string text, string capability, IPsiModule psiModule);
    public virtual bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public virtual ILanguageCacheProvider get_CacheProvider();
    public virtual bool get_SupportTypeMemberCache();
    public virtual ICodeFormatter get_CodeFormatter();
    public virtual void OptimizeImportsAndRefs(IFile file, IRangeMarker rangeMarker, bool optimizeUsings, bool shortenReferences, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public virtual IReferenceContextCodec CreateReferenceContextCodec();
    [NotNullAttribute]
public virtual ITypeConversionRule GetTypeConversionRule(ITreeNode context, bool useStrict);
    [CompilerGeneratedAttribute]
public virtual ITypePresenter get_TypePresenter();
    public virtual IDeclaredElementPresenter get_DeclaredElementPresenter();
    public virtual bool IsTypeMemberVisible(ITypeMember member);
    public virtual ReferenceAccessType GetReferenceAccessType(IDeclaredElement target, IReference reference);
    private static ReferenceAccessType GetAccessTypeForReferenceInExpression(ICSharpExpression expression, IDeclaredElement target);
    public virtual IDeclaredElementPointer`1<TDeclaredElement> CreateElementPointer(TDeclaredElement declaredElement);
    public virtual PreProcessingDirectivesInFile GetUsedConditionalSymbols(IPsiSourceFile sourceFile);
    public virtual bool CanContainCachableDeclarations(ITreeNode node);
    public virtual IEnumerable`1<ITypeDeclaration> FindTypeDeclarations(IFile file);
    public virtual bool SupportsNativeNumericTypes(IProjectPsiModule projectPsiModule);
    public virtual SourceExtensionMembersIndex CreateSourceExtensionMethodsIndex();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<IPsiModificationService> get_ModificationServices();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageService/<EnumerateTypeDeclarations>d__47")]
private static IEnumerable`1<ITypeDeclaration> EnumerateTypeDeclarations(ICSharpTypeAndNamespaceHolderDeclaration typeAndNamespaceHolderDeclaration);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CSharpLanguageService/<EnumerateTypeDeclarations>d__48")]
private static IEnumerable`1<ITypeDeclaration> EnumerateTypeDeclarations(ICSharpTypeDeclaration cSharpTypeDeclaration);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpMethodsReferencedByDelegateSearcher : object {
    private IDelegate myDelegate;
    public CSharpMethodsReferencedByDelegateSearcher(IDelegate delegate);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpMoveCommentHandler : MoveCommentHandlerBase {
    public virtual bool IsEndOfLineComment(IComment comment);
    public virtual bool IsSyntheticComment(IComment comment);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpNamedArgumentsCacheProvider : object {
    [NullableContextAttribute("1")]
public sealed virtual String[] GetPossibleNamedArguments(IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpNameManglingService : object {
    [NotNullAttribute]
public static CSharpNameManglingService Instance;
    private PsiModificationServicePriority JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.Priority { get; }
    private static CSharpNameManglingService();
    private sealed virtual override PsiModificationServicePriority JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.get_Priority();
    private sealed virtual override bool JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.IsApplicable(ITreeNode originalNode, bool fromPhysicalTree, ITreeNode insertedCopyNode, bool toPhysicalTree);
    private sealed virtual override object JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.CreateContext(ITreeNode originalNode, IReferenceContextCodec referenceContextCodec, ITreeNode insertedCopyNode);
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.Apply(ITreeNode node, object context);
    private sealed virtual override bool JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.ShouldApplyToDescendants(ITreeNode node, object context);
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.CleanupContext(ITreeNode node, object context);
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.OnCopyWithResolve(ITreeNode node, ITreeNode copy);
    [PureAttribute]
public bool HasVerbatimPrefix(string name);
    [NotNullAttribute]
[PureAttribute]
public string RemoveVerbatimPrefix(string name);
    [NotNullAttribute]
[PureAttribute]
public string AddVerbatimPrefixIfNecessary(string name, ITreeNode usageContext, bool necessaryInUnknownContext);
    [NotNullAttribute]
public ICSharpIdentifier RemoveVerbatimPrefix(ICSharpIdentifier identifier);
    [PureAttribute]
public bool HasRedundantVerbatimPrefix(ICSharpIdentifier identifier, bool onlyIfReservedName, String& unmangledName);
    [PureAttribute]
private bool IsVerbatimPrefixRedundant(ICSharpIdentifier identifier, string unmangledName);
    [PureAttribute]
private bool IsVerbatimIdentifierUsedToDisambiguateAttribute(ICSharpIdentifier identifier);
    [PureAttribute]
private static NameContext GetNameContext(ITreeNode context, bool strict);
    [CompilerGeneratedAttribute]
internal static bool <AddVerbatimPrefixIfNecessary>g__IsInContext|11_0(NameContext context, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static bool <AddVerbatimPrefixIfNecessary>g__IsAttributeTargetContext|11_1(<>c__DisplayClass11_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpObjectCreationSearchService : object {
    [CompilerGeneratedAttribute]
private IWordIndex <wordIndex>P;
    [CompilerGeneratedAttribute]
private GlobalUsingsCache <globalUsingsCache>P;
    [CompilerGeneratedAttribute]
private TargetTypedObjectCreationCache <targetTypedObjectCreationCache>P;
    public CSharpObjectCreationSearchService(IWordIndex wordIndex, GlobalUsingsCache globalUsingsCache, TargetTypedObjectCreationCache targetTypedObjectCreationCache);
    public sealed virtual bool IsApplicable(IPsiSourceFile sourceFile);
    public sealed virtual bool CanContainConstructorInvocation(IPsiSourceFile sourceFile, IConstructor constructor);
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpOperatorSearchProcessor`1 : object {
    public static FindExecution Run(ITreeNode treeNode, IFindResultConsumer`1<TResult> resultConsumer, IEnumerable`1<IConversionOperator> operators);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpParameterSearchLanguageService : object {
    [NullableContextAttribute("1")]
public sealed virtual HybridCollection`1<IPsiSourceFile> GetScope(IParameter parameter);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpPredefinedImpl : CSharpPredefined {
    [NotNullAttribute]
private PredefinedType myPredefinedType;
    [NotNullAttribute]
private ICSharpTypeConversionRule myConversionRule;
    private Dictionary`2<string, Dictionary`2<object, ISignOperator>> myBinaryOperators;
    private Dictionary`2<string, Dictionary`2<object, ISignOperator>> myUnaryOperators;
    private IType[] myCommonTypeSet;
    private IType[] myNumericTypeSet;
    private ISignOperator[] myBinaryOperatorsTable;
    private ISignOperator[] myUnaryOperatorsTable;
    private Dictionary`2<string, ISignOperator[]> myBinaryOperatorsTableByName;
    private Dictionary`2<string, ISignOperator[]> myUnaryOperatorsTableByName;
    private HashSet`1<ISignOperator> myMeaningfulOperators;
    private IPsiModule Module { get; }
    public ISignOperator UnaryPlusInt { get; }
    public ISignOperator UnaryPlusUint { get; }
    public ISignOperator UnaryPlusLong { get; }
    public ISignOperator UnaryPlusUlong { get; }
    public ISignOperator UnaryPlusFloat { get; }
    public ISignOperator UnaryPlusDouble { get; }
    public ISignOperator UnaryPlusDecimal { get; }
    public ISignOperator UnaryMinusInt { get; }
    public ISignOperator UnaryMinusLong { get; }
    public ISignOperator UnaryMinusFloat { get; }
    public ISignOperator UnaryMinusDouble { get; }
    public ISignOperator UnaryMinusDecimal { get; }
    public ISignOperator UnaryLogicalNegation { get; }
    public ISignOperator UnaryBitwiseComplementInt { get; }
    public ISignOperator UnaryBitwiseComplementUint { get; }
    public ISignOperator UnaryBitwiseComplementLong { get; }
    public ISignOperator UnaryBitwiseComplementUlong { get; }
    public ISignOperator UnaryIncrementSbyte { get; }
    public ISignOperator UnaryIncrementByte { get; }
    public ISignOperator UnaryIncrementShort { get; }
    public ISignOperator UnaryIncrementUshort { get; }
    public ISignOperator UnaryIncrementInt { get; }
    public ISignOperator UnaryIncrementUint { get; }
    public ISignOperator UnaryIncrementLong { get; }
    public ISignOperator UnaryIncrementUlong { get; }
    public ISignOperator UnaryIncrementChar { get; }
    public ISignOperator UnaryIncrementFloat { get; }
    public ISignOperator UnaryIncrementDouble { get; }
    public ISignOperator UnaryIncrementDecimal { get; }
    public ISignOperator UnaryDecrementSbyte { get; }
    public ISignOperator UnaryDecrementByte { get; }
    public ISignOperator UnaryDecrementShort { get; }
    public ISignOperator UnaryDecrementUshort { get; }
    public ISignOperator UnaryDecrementInt { get; }
    public ISignOperator UnaryDecrementUint { get; }
    public ISignOperator UnaryDecrementLong { get; }
    public ISignOperator UnaryDecrementUlong { get; }
    public ISignOperator UnaryDecrementChar { get; }
    public ISignOperator UnaryDecrementFloat { get; }
    public ISignOperator UnaryDecrementDouble { get; }
    public ISignOperator UnaryDecrementDecimal { get; }
    public ISignOperator BinaryMultiplicationInt { get; }
    public ISignOperator BinaryMultiplicationUint { get; }
    public ISignOperator BinaryMultiplicationLong { get; }
    public ISignOperator BinaryMultiplicationUlong { get; }
    public ISignOperator BinaryMultiplicationFloat { get; }
    public ISignOperator BinaryMultiplicationDouble { get; }
    public ISignOperator BinaryMultiplicationDecimal { get; }
    public ISignOperator BinaryDivisionInt { get; }
    public ISignOperator BinaryDivisionUint { get; }
    public ISignOperator BinaryDivisionLong { get; }
    public ISignOperator BinaryDivisionUlong { get; }
    public ISignOperator BinaryDivisionFloat { get; }
    public ISignOperator BinaryDivisionDouble { get; }
    public ISignOperator BinaryDivisionDecimal { get; }
    public ISignOperator BinaryRemainderInt { get; }
    public ISignOperator BinaryRemainderUint { get; }
    public ISignOperator BinaryRemainderLong { get; }
    public ISignOperator BinaryRemainderUlong { get; }
    public ISignOperator BinaryRemainderFloat { get; }
    public ISignOperator BinaryRemainderDouble { get; }
    public ISignOperator BinaryRemainderDecimal { get; }
    public ISignOperator BinaryPlusInt { get; }
    public ISignOperator BinaryPlusUint { get; }
    public ISignOperator BinaryPlusLong { get; }
    public ISignOperator BinaryPlusUlong { get; }
    public ISignOperator BinaryPlusFloat { get; }
    public ISignOperator BinaryPlusDouble { get; }
    public ISignOperator BinaryPlusDecimal { get; }
    public ISignOperator BinaryPlusStringString { get; }
    public ISignOperator BinaryPlusStringObject { get; }
    public ISignOperator BinaryPlusObjectString { get; }
    public ISignOperator BinaryMinusInt { get; }
    public ISignOperator BinaryMinusUint { get; }
    public ISignOperator BinaryMinusLong { get; }
    public ISignOperator BinaryMinusUlong { get; }
    public ISignOperator BinaryMinusFloat { get; }
    public ISignOperator BinaryMinusDouble { get; }
    public ISignOperator BinaryMinusDecimal { get; }
    public ISignOperator BinaryLeftShiftInt { get; }
    public ISignOperator BinaryLeftShiftUint { get; }
    public ISignOperator BinaryLeftShiftLong { get; }
    public ISignOperator BinaryLeftShiftUlong { get; }
    public ISignOperator BinaryLeftShiftNativeInteger { get; }
    public ISignOperator BinaryLeftShiftNativeUnsignedInteger { get; }
    public ISignOperator BinaryRightShiftInt { get; }
    public ISignOperator BinaryRightShiftUint { get; }
    public ISignOperator BinaryRightShiftLong { get; }
    public ISignOperator BinaryRightShiftUlong { get; }
    public ISignOperator BinaryRightShiftNativeInteger { get; }
    public ISignOperator BinaryRightShiftNativeUnsignedInteger { get; }
    public ISignOperator BinaryUnsignedRightShiftInt { get; }
    public ISignOperator BinaryUnsignedRightShiftUint { get; }
    public ISignOperator BinaryUnsignedRightShiftLong { get; }
    public ISignOperator BinaryUnsignedRightShiftUlong { get; }
    public ISignOperator BinaryUnsignedRightShiftNativeInteger { get; }
    public ISignOperator BinaryUnsignedRightShiftNativeUnsignedInteger { get; }
    public ISignOperator BinaryEqualityInt { get; }
    public ISignOperator BinaryEqualityUint { get; }
    public ISignOperator BinaryEqualityLong { get; }
    public ISignOperator BinaryEqualityUlong { get; }
    public ISignOperator BinaryEqualityFloat { get; }
    public ISignOperator BinaryEqualityDouble { get; }
    public ISignOperator BinaryEqualityDecimal { get; }
    public ISignOperator BinaryEqualityBool { get; }
    public ISignOperator BinaryEqualityReference { get; }
    public ISignOperator BinaryEqualityDelegate { get; }
    public ISignOperator BinaryEqualityNullable { get; }
    public ISignOperator BinaryEqualityString { get; }
    public ISignOperator BinaryInequalityInt { get; }
    public ISignOperator BinaryInequalityUint { get; }
    public ISignOperator BinaryInequalityLong { get; }
    public ISignOperator BinaryInequalityUlong { get; }
    public ISignOperator BinaryInequalityFloat { get; }
    public ISignOperator BinaryInequalityDouble { get; }
    public ISignOperator BinaryInequalityDecimal { get; }
    public ISignOperator BinaryInequalityBool { get; }
    public ISignOperator BinaryInequalityReference { get; }
    public ISignOperator BinaryInequalityDelegate { get; }
    public ISignOperator BinaryInequalityNullable { get; }
    public ISignOperator BinaryInequalityString { get; }
    public ISignOperator BinaryLessInt { get; }
    public ISignOperator BinaryLessUint { get; }
    public ISignOperator BinaryLessLong { get; }
    public ISignOperator BinaryLessUlong { get; }
    public ISignOperator BinaryLessFloat { get; }
    public ISignOperator BinaryLessDouble { get; }
    public ISignOperator BinaryLessDecimal { get; }
    public ISignOperator BinaryGreaterInt { get; }
    public ISignOperator BinaryGreaterUint { get; }
    public ISignOperator BinaryGreaterLong { get; }
    public ISignOperator BinaryGreaterUlong { get; }
    public ISignOperator BinaryGreaterFloat { get; }
    public ISignOperator BinaryGreaterDouble { get; }
    public ISignOperator BinaryGreaterDecimal { get; }
    public ISignOperator BinaryLessEqualityInt { get; }
    public ISignOperator BinaryLessEqualityUint { get; }
    public ISignOperator BinaryLessEqualityLong { get; }
    public ISignOperator BinaryLessEqualityUlong { get; }
    public ISignOperator BinaryLessEqualityFloat { get; }
    public ISignOperator BinaryLessEqualityDouble { get; }
    public ISignOperator BinaryLessEqualityDecimal { get; }
    public ISignOperator BinaryGreaterEqualityInt { get; }
    public ISignOperator BinaryGreaterEqualityUint { get; }
    public ISignOperator BinaryGreaterEqualityLong { get; }
    public ISignOperator BinaryGreaterEqualityUlong { get; }
    public ISignOperator BinaryGreaterEqualityFloat { get; }
    public ISignOperator BinaryGreaterEqualityDouble { get; }
    public ISignOperator BinaryGreaterEqualityDecimal { get; }
    public ISignOperator BinaryLogicalAndInt { get; }
    public ISignOperator BinaryLogicalAndUint { get; }
    public ISignOperator BinaryLogicalAndLong { get; }
    public ISignOperator BinaryLogicalAndUlong { get; }
    public ISignOperator BinaryLogicalAndBool { get; }
    public ISignOperator BinaryLogicalOrInt { get; }
    public ISignOperator BinaryLogicalOrUint { get; }
    public ISignOperator BinaryLogicalOrLong { get; }
    public ISignOperator BinaryLogicalOrUlong { get; }
    public ISignOperator BinaryLogicalOrBool { get; }
    public ISignOperator BinaryConditionalLogicalAndAlsoBool { get; }
    public ISignOperator BinaryConditionalLogicalOrElseBool { get; }
    public ISignOperator BinaryLogicalXorInt { get; }
    public ISignOperator BinaryLogicalXorUint { get; }
    public ISignOperator BinaryLogicalXorLong { get; }
    public ISignOperator BinaryLogicalXorUlong { get; }
    public ISignOperator BinaryLogicalXorBool { get; }
    public CSharpPredefinedImpl(IPsiModule module);
    private IPsiModule get_Module();
    public virtual IProperty[] GetArrayIndexers(IArrayType type, IResolveContext resolveContext, IList`1<ICSharpArgumentInfo> arguments, CSharpLanguageLevel languageLevel);
    public virtual IProperty GetPointerIndexer(IPointerType type, IResolveContext resolveContext, ICSharpArgumentInfo argument);
    private void CreateOperatorTable();
    private void CreateUnaryOperatorTable();
    private void CreateBinaryOperatorTable();
    private void CreateBinaryRelationalNameTable(IEnumerable`1<string> names, ICollection`1<IType> types);
    private void CreateBinaryShiftNameTable(IEnumerable`1<string> names, ICollection`1<IType> types);
    private static void CreateOperatorNameTable(Dictionary`2<string, Dictionary`2<object, ISignOperator>> operatorTable, IEnumerable`1<string> names, ICollection`1<IType> types, int parameterNumber);
    private void CreateUnaryNameTable(string name, IType[] types);
    private void CreateUnaryNameTable(String[] names, IType[] types);
    private void CreateBinaryNameTable(String[] names, IType[] types);
    private void CreateOperatorCaches();
    private void CreateOperatorsByNameCache();
    private static ISignOperator[] GetAllOperators(Dictionary`2<string, Dictionary`2<object, ISignOperator>> operators);
    public virtual ISignOperator[] GetBinaryOperators();
    public virtual ISignOperator[] GetUnaryOperators();
    public virtual ISignOperator[] GetBinaryOperatorsByName(string name);
    public virtual ISignOperator[] GetUnaryOperatorsByName(string name);
    public virtual ISignOperator[] GetDelegateOperators(IDelegate delegate, ISubstitution substitution);
    public virtual ISignOperator[] GetEnumOperators(IEnum enum, ISubstitution substitution);
    public virtual ISignOperator[] GetPointerOperators(IPointerType pointerType);
    public virtual bool IsOperatorMeaningfulForUser(ISignOperator signOperator);
    public virtual ISignOperator get_UnaryPlusInt();
    public virtual ISignOperator get_UnaryPlusUint();
    public virtual ISignOperator get_UnaryPlusLong();
    public virtual ISignOperator get_UnaryPlusUlong();
    public virtual ISignOperator get_UnaryPlusFloat();
    public virtual ISignOperator get_UnaryPlusDouble();
    public virtual ISignOperator get_UnaryPlusDecimal();
    public virtual ISignOperator get_UnaryMinusInt();
    public virtual ISignOperator get_UnaryMinusLong();
    public virtual ISignOperator get_UnaryMinusFloat();
    public virtual ISignOperator get_UnaryMinusDouble();
    public virtual ISignOperator get_UnaryMinusDecimal();
    public virtual ISignOperator get_UnaryLogicalNegation();
    public virtual ISignOperator get_UnaryBitwiseComplementInt();
    public virtual ISignOperator get_UnaryBitwiseComplementUint();
    public virtual ISignOperator get_UnaryBitwiseComplementLong();
    public virtual ISignOperator get_UnaryBitwiseComplementUlong();
    public virtual ISignOperator get_UnaryIncrementSbyte();
    public virtual ISignOperator get_UnaryIncrementByte();
    public virtual ISignOperator get_UnaryIncrementShort();
    public virtual ISignOperator get_UnaryIncrementUshort();
    public virtual ISignOperator get_UnaryIncrementInt();
    public virtual ISignOperator get_UnaryIncrementUint();
    public virtual ISignOperator get_UnaryIncrementLong();
    public virtual ISignOperator get_UnaryIncrementUlong();
    public virtual ISignOperator get_UnaryIncrementChar();
    public virtual ISignOperator get_UnaryIncrementFloat();
    public virtual ISignOperator get_UnaryIncrementDouble();
    public virtual ISignOperator get_UnaryIncrementDecimal();
    public virtual ISignOperator get_UnaryDecrementSbyte();
    public virtual ISignOperator get_UnaryDecrementByte();
    public virtual ISignOperator get_UnaryDecrementShort();
    public virtual ISignOperator get_UnaryDecrementUshort();
    public virtual ISignOperator get_UnaryDecrementInt();
    public virtual ISignOperator get_UnaryDecrementUint();
    public virtual ISignOperator get_UnaryDecrementLong();
    public virtual ISignOperator get_UnaryDecrementUlong();
    public virtual ISignOperator get_UnaryDecrementChar();
    public virtual ISignOperator get_UnaryDecrementFloat();
    public virtual ISignOperator get_UnaryDecrementDouble();
    public virtual ISignOperator get_UnaryDecrementDecimal();
    public virtual ISignOperator get_BinaryMultiplicationInt();
    public virtual ISignOperator get_BinaryMultiplicationUint();
    public virtual ISignOperator get_BinaryMultiplicationLong();
    public virtual ISignOperator get_BinaryMultiplicationUlong();
    public virtual ISignOperator get_BinaryMultiplicationFloat();
    public virtual ISignOperator get_BinaryMultiplicationDouble();
    public virtual ISignOperator get_BinaryMultiplicationDecimal();
    public virtual ISignOperator get_BinaryDivisionInt();
    public virtual ISignOperator get_BinaryDivisionUint();
    public virtual ISignOperator get_BinaryDivisionLong();
    public virtual ISignOperator get_BinaryDivisionUlong();
    public virtual ISignOperator get_BinaryDivisionFloat();
    public virtual ISignOperator get_BinaryDivisionDouble();
    public virtual ISignOperator get_BinaryDivisionDecimal();
    public virtual ISignOperator get_BinaryRemainderInt();
    public virtual ISignOperator get_BinaryRemainderUint();
    public virtual ISignOperator get_BinaryRemainderLong();
    public virtual ISignOperator get_BinaryRemainderUlong();
    public virtual ISignOperator get_BinaryRemainderFloat();
    public virtual ISignOperator get_BinaryRemainderDouble();
    public virtual ISignOperator get_BinaryRemainderDecimal();
    public virtual ISignOperator get_BinaryPlusInt();
    public virtual ISignOperator get_BinaryPlusUint();
    public virtual ISignOperator get_BinaryPlusLong();
    public virtual ISignOperator get_BinaryPlusUlong();
    public virtual ISignOperator get_BinaryPlusFloat();
    public virtual ISignOperator get_BinaryPlusDouble();
    public virtual ISignOperator get_BinaryPlusDecimal();
    public virtual ISignOperator get_BinaryPlusStringString();
    public virtual ISignOperator get_BinaryPlusStringObject();
    public virtual ISignOperator get_BinaryPlusObjectString();
    public virtual ISignOperator get_BinaryMinusInt();
    public virtual ISignOperator get_BinaryMinusUint();
    public virtual ISignOperator get_BinaryMinusLong();
    public virtual ISignOperator get_BinaryMinusUlong();
    public virtual ISignOperator get_BinaryMinusFloat();
    public virtual ISignOperator get_BinaryMinusDouble();
    public virtual ISignOperator get_BinaryMinusDecimal();
    public virtual ISignOperator get_BinaryLeftShiftInt();
    public virtual ISignOperator get_BinaryLeftShiftUint();
    public virtual ISignOperator get_BinaryLeftShiftLong();
    public virtual ISignOperator get_BinaryLeftShiftUlong();
    public virtual ISignOperator get_BinaryLeftShiftNativeInteger();
    public virtual ISignOperator get_BinaryLeftShiftNativeUnsignedInteger();
    public virtual ISignOperator get_BinaryRightShiftInt();
    public virtual ISignOperator get_BinaryRightShiftUint();
    public virtual ISignOperator get_BinaryRightShiftLong();
    public virtual ISignOperator get_BinaryRightShiftUlong();
    public virtual ISignOperator get_BinaryRightShiftNativeInteger();
    public virtual ISignOperator get_BinaryRightShiftNativeUnsignedInteger();
    public virtual ISignOperator get_BinaryUnsignedRightShiftInt();
    public virtual ISignOperator get_BinaryUnsignedRightShiftUint();
    public virtual ISignOperator get_BinaryUnsignedRightShiftLong();
    public virtual ISignOperator get_BinaryUnsignedRightShiftUlong();
    public virtual ISignOperator get_BinaryUnsignedRightShiftNativeInteger();
    public virtual ISignOperator get_BinaryUnsignedRightShiftNativeUnsignedInteger();
    public virtual ISignOperator get_BinaryEqualityInt();
    public virtual ISignOperator get_BinaryEqualityUint();
    public virtual ISignOperator get_BinaryEqualityLong();
    public virtual ISignOperator get_BinaryEqualityUlong();
    public virtual ISignOperator get_BinaryEqualityFloat();
    public virtual ISignOperator get_BinaryEqualityDouble();
    public virtual ISignOperator get_BinaryEqualityDecimal();
    public virtual ISignOperator get_BinaryEqualityBool();
    public virtual ISignOperator get_BinaryEqualityReference();
    public virtual ISignOperator get_BinaryEqualityDelegate();
    public virtual ISignOperator get_BinaryEqualityNullable();
    public virtual ISignOperator get_BinaryEqualityString();
    public virtual ISignOperator get_BinaryInequalityInt();
    public virtual ISignOperator get_BinaryInequalityUint();
    public virtual ISignOperator get_BinaryInequalityLong();
    public virtual ISignOperator get_BinaryInequalityUlong();
    public virtual ISignOperator get_BinaryInequalityFloat();
    public virtual ISignOperator get_BinaryInequalityDouble();
    public virtual ISignOperator get_BinaryInequalityDecimal();
    public virtual ISignOperator get_BinaryInequalityBool();
    public virtual ISignOperator get_BinaryInequalityReference();
    public virtual ISignOperator get_BinaryInequalityDelegate();
    public virtual ISignOperator get_BinaryInequalityNullable();
    public virtual ISignOperator get_BinaryInequalityString();
    public virtual ISignOperator get_BinaryLessInt();
    public virtual ISignOperator get_BinaryLessUint();
    public virtual ISignOperator get_BinaryLessLong();
    public virtual ISignOperator get_BinaryLessUlong();
    public virtual ISignOperator get_BinaryLessFloat();
    public virtual ISignOperator get_BinaryLessDouble();
    public virtual ISignOperator get_BinaryLessDecimal();
    public virtual ISignOperator get_BinaryGreaterInt();
    public virtual ISignOperator get_BinaryGreaterUint();
    public virtual ISignOperator get_BinaryGreaterLong();
    public virtual ISignOperator get_BinaryGreaterUlong();
    public virtual ISignOperator get_BinaryGreaterFloat();
    public virtual ISignOperator get_BinaryGreaterDouble();
    public virtual ISignOperator get_BinaryGreaterDecimal();
    public virtual ISignOperator get_BinaryLessEqualityInt();
    public virtual ISignOperator get_BinaryLessEqualityUint();
    public virtual ISignOperator get_BinaryLessEqualityLong();
    public virtual ISignOperator get_BinaryLessEqualityUlong();
    public virtual ISignOperator get_BinaryLessEqualityFloat();
    public virtual ISignOperator get_BinaryLessEqualityDouble();
    public virtual ISignOperator get_BinaryLessEqualityDecimal();
    public virtual ISignOperator get_BinaryGreaterEqualityInt();
    public virtual ISignOperator get_BinaryGreaterEqualityUint();
    public virtual ISignOperator get_BinaryGreaterEqualityLong();
    public virtual ISignOperator get_BinaryGreaterEqualityUlong();
    public virtual ISignOperator get_BinaryGreaterEqualityFloat();
    public virtual ISignOperator get_BinaryGreaterEqualityDouble();
    public virtual ISignOperator get_BinaryGreaterEqualityDecimal();
    public virtual ISignOperator get_BinaryLogicalAndInt();
    public virtual ISignOperator get_BinaryLogicalAndUint();
    public virtual ISignOperator get_BinaryLogicalAndLong();
    public virtual ISignOperator get_BinaryLogicalAndUlong();
    public virtual ISignOperator get_BinaryLogicalAndBool();
    public virtual ISignOperator get_BinaryLogicalOrInt();
    public virtual ISignOperator get_BinaryLogicalOrUint();
    public virtual ISignOperator get_BinaryLogicalOrLong();
    public virtual ISignOperator get_BinaryLogicalOrUlong();
    public virtual ISignOperator get_BinaryLogicalOrBool();
    public virtual ISignOperator get_BinaryConditionalLogicalAndAlsoBool();
    public virtual ISignOperator get_BinaryConditionalLogicalOrElseBool();
    public virtual ISignOperator get_BinaryLogicalXorInt();
    public virtual ISignOperator get_BinaryLogicalXorUint();
    public virtual ISignOperator get_BinaryLogicalXorLong();
    public virtual ISignOperator get_BinaryLogicalXorUlong();
    public virtual ISignOperator get_BinaryLogicalXorBool();
    internal virtual bool IsBinaryOperatorName(string name);
    internal virtual bool IsUnaryOperatorName(string name);
    public virtual ISignOperator GetBinaryOperator(string name, IType leftType, IType rightType);
    public virtual ISignOperator GetUnaryOperator(string name, IType type);
    [CanBeNullAttribute]
[PureAttribute]
private static IMethod GetRuntimeHelpersGetSubArrayMethod(PredefinedType predefinedType, IPsiModule sourceModule);
    [CompilerGeneratedAttribute]
private IProperty[] <GetArrayIndexers>g__GetAvailableIndexers|14_0(<>c__DisplayClass14_0& );
}
[SolutionComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpPredefinedManager : object {
    [NotNullAttribute]
private IPsiModules myPsiModules;
    [NotNullAttribute]
private ConcurrentDictionary`2<IPsiModule, CSharpPredefined> myPredefined;
    public CSharpPredefinedManager(Lifetime lifetime, IPsiModules psiModules, ChangeManager changeManager);
    public CSharpPredefined GetPredefined(IPsiModule module);
    private void OnSomethingChanged(ChangeEventArgs changeEventArgs);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0();
}
[ProjectFileTypeAttribute("JetBrains.ProjectModel.CSharpProjectFileType", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpProjectFileCustomPsiPropertiesProvider : object {
    public sealed virtual T GetCustomProperties(IPsiSourceFile sourceFile);
}
[ProjectFileTypeAttribute("JetBrains.ProjectModel.CSharpProjectFileType", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpProjectFileLanguageService : object {
    [NotNullAttribute]
private CSharpProjectFileType myCSharpProjectFileType;
    public ProjectFileType LanguageType { get; }
    public IconId Icon { get; }
    public CSharpProjectFileLanguageService(CSharpProjectFileType csharpProjectFileType);
    public sealed virtual ProjectFileType get_LanguageType();
    public sealed virtual IconId get_Icon();
    public sealed virtual PsiLanguageType GetPsiLanguageType(IProjectFile projectFile);
    public sealed virtual PsiLanguageType GetPsiLanguageType(IPsiSourceFile sourceFile);
    public sealed virtual PsiLanguageType GetPsiLanguageType(ProjectFileType languageType);
    public sealed virtual ILexerFactory GetMixedLexerFactory(ISolution solution, IBuffer buffer, IPsiSourceFile sourceFile);
    public sealed virtual PreProcessingDirective[] GetPreprocessorDefines(IProject project, TargetFrameworkId targetFrameworkId);
    [NotNullAttribute]
public sealed virtual IPsiSourceFileProperties GetPsiProperties(IProjectFile projectFile, IPsiSourceFile sourceFile, IsCompileService isCompileService);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceBindingUtil : object {
    [ExtensionAttribute]
private static bool IsGoodResolveResult(ResolveErrorType result);
    private static bool CheckResolvedTo(IReference reference, IDeclaredElement target);
    private static bool CheckNameofMethodResolvedTo(IReference reference, IDeclaredElement target, IResolveResult resolveResult);
    private static bool CheckResolvedTo(IReference reference, IDeclaredElement target, ISubstitution targetSubstitution);
    private static bool CheckNameofMethodResolvedTo(IReference reference, ResolveResultWithInfo resultWithInfo, IDeclaredElement target, ISubstitution targetSubstitution);
    private static bool CheckElement(IReference reference, IDeclaredElement resolved, IDeclaredElement target);
    private static bool CheckAmongCandidates(IReference reference, ICollection`1<DeclaredElementInstance> targets);
    private static void RemovePairedUnknownTypes(ISubstitution& substitution1, ISubstitution& substitution2);
    private static bool CheckAmongCandidates(IReference reference, ICollection`1<IClrDeclaredElement> targets);
    private static bool CheckElement(IReference reference, IDeclaredElement resolved, ISubstitution resolvedSubstitution, IDeclaredElement target, ISubstitution targetSubstitution);
    [PureAttribute]
private static bool CheckResolvedToEquivalentAlias(IReference reference, DeclaredElementInstance resolvedInstance, DeclaredElementInstance targetInstance);
    [PureAttribute]
private static bool CheckResolvedToEquivalentAlias(IReference reference, IDeclaredElement resolved, IDeclaredElement target);
    [NotNullAttribute]
private static ISubstitution EraseIdentitySubstitution(IDeclaredElement declaredElement, ISubstitution substitution);
    [NotNullAttribute]
private static string GetQualifiedName(IClrDeclaredElement element);
    [CanBeNullAttribute]
public static string GetQualifiedExternAlias(IReference reference);
    private static bool FullyQualifiedWithGlobal(IReference reference);
    [StringFormatMethodAttribute("format")]
[PureAttribute]
[NotNullAttribute]
private static string SafeFormat(ITreeNode context, string format, String[] arguments);
    private static bool IsSupportableReference(IReference reference);
    [CanBeNullAttribute]
private static ITypeArgumentList GetTypeArgumentsList(ITreeNode element);
    private static void SetTypeArgumentsList(ITreeNode element, ITypeArgumentList typeArgumentList);
    private static int GetTypeArgumentsNumber(ITreeNode element);
    [NotNullAttribute]
private static string GetDelimiter(IReference reference);
    private static bool IsConditionalAccessReference(IReference reference);
    [CanBeNullAttribute]
public static IQualifiableReference ReplaceReferenceElement(ITreeNode element, string refTo, bool keepExistingTypeArguments);
    [CanBeNullAttribute]
private static IQualifiableReference QualifyReferenceTo(IQualifiableReference reference, ITypeElement target, Func`2<IQualifiableReference, bool> predicate);
    [CanBeNullAttribute]
private static IQualifiableReference TryBindWithAlias(IQualifiableReference reference, ICSharpTypeAndNamespaceHolderDeclaration scope, string aliasName, ITypeElement target, Func`2<IQualifiableReference, bool> predicate);
    [NotNullAttribute]
private static IQualifiableReference TryBindWithNontrivialAlias(IQualifiableReference reference, ITypeElement target, Func`2<IQualifiableReference, bool> predicate);
    private static IQualifiableReference BindToTypeElementNoImport(IQualifiableReference reference, ITypeElement target, Nullable`1<bool> allowNewAlias, Func`2<IQualifiableReference, bool> predicate);
    [CanBeNullAttribute]
private static IQualifiableReference BindToTypeElement(IQualifiableReference reference, ITypeElement target, Func`2<IQualifiableReference, bool> predicate);
    [NotNullAttribute]
private static string GetShortName(ITypeElement target);
    [NotNullAttribute]
private static IQualifiableReference BindToNestedTypeElement(IQualifiableReference& reference, ITypeElement containingType, ITypeElement target);
    [NotNullAttribute]
private static IQualifiableReference BindToTypeMemberWithImport(IQualifiableReference reference, DeclaredElementInstance importTarget, ITypeMember target, ICSharpTypeAndNamespaceHolderDeclaration scope, Func`2<IQualifiableReference, bool> predicate, Boolean& hasSameNameConflicts);
    [CanBeNullAttribute]
[PureAttribute]
public static string GetRequiredExternAlias(IPsiModule sourceModule, IClrDeclaredElement target);
    [CanBeNullAttribute]
[PureAttribute]
public static String[] GetPossibleExternAliases(IPsiModule sourceModule, IClrDeclaredElement target);
    [NotNullAttribute]
public static IEnumerable`1<string> GetExternAliasesToTry(IPsiModule sourceModule, IClrDeclaredElement target);
    public static bool RebindConflictedReferences(IReference originalReference, IEnumerable`1<Conflict> allConflicts);
    [CanBeNullAttribute]
private static IQualifiableReference BindToTypeElementWithSubstitution(IQualifiableReference reference, ITypeElement target, ISubstitution substitution, Func`2<IQualifiableReference, bool> predicate);
    private static bool HasInDomain(ISubstitution substitution, ITypeParameter typeParameter);
    private static void ReconstructTypeParameters(ITreeNode element, ISubstitution substitution, ITypeParametersOwner target);
    [NotNullAttribute]
private static IQualifiableReference UseExistingAlias(IQualifiableReference reference, Func`2<IQualifiableReference, bool> predicate);
    [NotNullAttribute]
private static IQualifiableReference UseExistingAlias(IQualifiableReference reference, ITypeElement typeElement, ISubstitution substitution, Func`2<IQualifiableReference, bool> predicate);
    [CanBeNullAttribute]
private static IQualifiableReference BindToNamespace(IQualifiableReference reference, INamespace target, Func`2<IQualifiableReference, bool> predicate);
    [CanBeNullAttribute]
private static IQualifiableReference BindToSymbolAlias(IQualifiableReference reference, ISymbolAlias symbolAlias, Func`2<IQualifiableReference, bool> predicate);
    [NotNullAttribute]
private static IQualifiableReference BindToAliasedSymbol(IQualifiableReference reference, AliasedSymbol aliasedSymbol);
    [CanBeNullAttribute]
private static ICSharpExpression ExtractQualifierObject(IQualifiableReference reference);
    [CanBeNullAttribute]
private static ICSharpExpression ExtractQualifierObject(ITreeNode element);
    [CanBeNullAttribute]
private static ICSharpExpression ExtractQualifierExpression(ICSharpExpression qualifierExpression);
    [CanBeNullAttribute]
private static IQualifiableReference SetQualifier(IQualifiableReference reference, ICSharpExpression qualifier);
    [CanBeNullAttribute]
private static IQualifiableReference BindToVariableTypeMember(IQualifiableReference reference, IClrDeclaredElement target, Func`2<IQualifiableReference, bool> predicate);
    [NotNullAttribute]
private static IQualifiableReference BindToStaticVariableTypeMember(IQualifiableReference reference, IClrDeclaredElement target, ITypeElement targetContainingType, Func`2<IQualifiableReference, bool> predicate);
    [NotNullAttribute]
private static IQualifiableReference BindToConstantUnderIsConstantPattern(IQualifiableReference reference, ITreeNode& treeNode);
    private static void TransformArgumentToParamsCollection(ICSharpArgument arg, IType parameterType, ISubstitution substitution);
    private static void CastArgument(ICSharpArgument arg, IType parameterType, ISubstitution substitution);
    [CanBeNullAttribute]
private static IList`1<ICSharpArgument> FindInvocationArguments(IReference reference);
    public static void BindSignature(IReference reference, IList`1<ICSharpArgument> invocationArguments, IParametersOwner target, ISubstitution substitution);
    private static bool IsImmediateSuperType(ITypeElement subType, ITypeElement superType);
    private static bool CanBindToInstanceTypeMember(IQualifiableReference reference, ITypeElement targetTypeElement);
    private static bool CanAccessStaticMembersOf(ICSharpExpression qualifierExpression, ITypeElement targetTypeElement);
    [CanBeNullAttribute]
private static IQualifiableReference SafeQualifierCast(IQualifiableReference reference, ITypeElement targetType, bool fullyQualifiedCast);
    private static IQualifiableReference BindToExtensionMethodAsStaticCall(IQualifiableReference reference, IMethod method, Func`2<IQualifiableReference, bool> predicate, bool canUseNamespaceImport);
    private static void BindToTypeElement(IQualifiableReference reference, ITypeElement target, bool canUseNamespaceImport, Func`2<IQualifiableReference, bool> predicate);
    private static void BindToTypeElement(IQualifiableReference reference, ITypeElement target, bool canUseNamespaceImport);
    [NotNullAttribute]
public static ICSharpTypeAndNamespaceHolderDeclaration GetImportScope(IReference reference);
    [NotNullAttribute]
public static ICSharpTypeAndNamespaceHolderDeclaration GetReferenceScope(IReference reference);
    public static IQualifiableReference BindToExtensionMethod(IQualifiableReference reference, IMethod method, Func`2<IQualifiableReference, bool> predicate);
    private static IQualifiableReference BindToInvocableTypeMember(IQualifiableReference reference, IParametersOwner target, Func`2<IQualifiableReference, bool> predicate);
    public static IReference BindToIndexer(IReference reference, IProperty target, ISubstitution substitution);
    private static void BindReferenceInCast(IQualifiableReference reference, ITypeElement targetTypeElement);
    [NotNullAttribute]
private static IQualifiableReference BindToTypeMember(IQualifiableReference reference, ITypeMember target);
    private static IQualifiableReference BindToStaticTypeMemberWithSubstitution(IQualifiableReference reference, ITypeMember typeMember, ISubstitution substitution, Func`2<IQualifiableReference, bool> predicate);
    private static IQualifiableReference BindToInstanceMethodWithSubstitution(IQualifiableReference reference, IMethod target, ISubstitution substitution, Func`2<IQualifiableReference, bool> predicate);
    private static IQualifiableReference BindToLocalFunctionWithSubstitution(IQualifiableReference reference, ILocalFunction target, ISubstitution substitution, Func`2<IQualifiableReference, bool> predicate);
    private static IQualifiableReference DecorateReferenceAccordingCodeStyle(IQualifiableReference reference, Func`2<IQualifiableReference, bool> predicate);
    public static IQualifiableReference BindReferenceTo(IQualifiableReference reference, IClrDeclaredElement element);
    public static IQualifiableReference BindReferenceTo(IQualifiableReference reference, ICollection`1<IClrDeclaredElement> elements);
    private static IQualifiableReference BindReferenceTo(IQualifiableReference reference, IClrDeclaredElement element, Func`2<IQualifiableReference, bool> predicate);
    [NotNullAttribute]
public static TReference FakeBindTo(TReference reference, IDeclaredElement element, ISubstitution substitution);
    public static IQualifiableReference BindReferenceTo(IQualifiableReference reference, IClrDeclaredElement element, ISubstitution substitution);
    public static IQualifiableReference BindReferenceTo(IQualifiableReference reference, ICollection`1<DeclaredElementInstance> elements);
    private static IQualifiableReference BindReferenceTo(IQualifiableReference reference, IClrDeclaredElement element, ISubstitution substitution, Func`2<IQualifiableReference, bool> predicate);
    public static TReference BindInvocationReferenceTo(TReference reference, IClrDeclaredElement target);
    public static TReference BindInvocationReferenceTo(TReference reference, IClrDeclaredElement target, ISubstitution substitution);
    private static TReference BindReferenceToExtensionMethod(TReference reference, IClrDeclaredElement target);
    private static TReference BindReferenceToExtensionMethod(TReference reference, IClrDeclaredElement target, ISubstitution substitution);
    public static IReference BindUsingDirectiveReferenceTo(IQualifiableReference reference, INamespace nameSpace);
    private static void PatchElementName(IQualifiableReference reference, IClrDeclaredElement element);
    private static bool IsRazorCodeBehindSyntheticRef(IReference reference, IClrDeclaredElement declaredElement);
    [CanBeNullAttribute]
[PureAttribute]
private static IQualifiableReference ExtractQualifierReference(IReference reference);
    [NotNullAttribute]
[PureAttribute]
public static string SuggestShortReferenceName(IQualifiableReference reference, IClrDeclaredElement target);
    [CompilerGeneratedAttribute]
internal static bool <CheckResolvedToEquivalentAlias>g__IsEquivalentTo|10_0(IReference reference, ISymbolAlias symbolAlias, DeclaredElementInstance declaredElementInstance);
    [CompilerGeneratedAttribute]
internal static bool <CheckResolvedToEquivalentAlias>g__IsEquivalentTo|11_0(IReference reference, ISymbolAlias symbolAlias, IDeclaredElement declaredElement);
    [CompilerGeneratedAttribute]
internal static bool <BindToSymbolAlias>g__TryImportAliasDirective|42_0(ICSharpTypeAndNamespaceHolderDeclaration importScope, IUsingAliasDirective usingAliasDirective, <>c__DisplayClass42_0& );
    [CompilerGeneratedAttribute]
internal static bool <SafeQualifierCast>g__IsNullableAnnotationRequired|58_0(ITypeElement typeElement, ITreeNode context);
    [CompilerGeneratedAttribute]
internal static IQualifiableReference <DecorateReferenceAccordingCodeStyle>g__RemoveAttributeSuffix|72_0(IQualifiableReference ref, <>c__DisplayClass72_0& );
    [CompilerGeneratedAttribute]
internal static IQualifiableReference <DecorateReferenceAccordingCodeStyle>g__DecorateWithThis|72_1(IQualifiableReference ref, <>c__DisplayClass72_0& );
    [CompilerGeneratedAttribute]
internal static IQualifiableReference <DecorateReferenceAccordingCodeStyle>g__QualifyStaticMember|72_2(IQualifiableReference ref, <>c__DisplayClass72_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceContextCodec : ReferenceContextCodec {
    public virtual IEnumerable`1<IReference> ExtractBindableReferences(ITreeNode element);
    protected virtual ReferenceCollection FindDependentReferences(IReference reference, bool strict);
    public virtual IReference MakeSafeReference(IReference reference);
    [CompilerGeneratedAttribute]
internal static bool <ExtractBindableReferences>g__FilterBindableReference|0_0(IReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ReferenceProviderFactoryAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceProviderFactory : object {
    private ISolution mySolution;
    [NullableAttribute("2")]
private IPsiServices myPsiServices;
    private CSharpReferenceProvider myReferenceProvider;
    private Lazy`1<NotifyPropertyChangedAnnotationProvider> myNotifyPropertyChangedAnnotationProvider;
    private Lazy`1<InvokerParameterNameAnnotationProvider> myInvokerParameterNameAnnotationProvider;
    [CompilerGeneratedAttribute]
private ISignal`1<IReferenceProviderFactory> <Changed>k__BackingField;
    public IPsiServices PsiServices { get; }
    public ISignal`1<IReferenceProviderFactory> Changed { get; }
    public CSharpReferenceProviderFactory(ISolution solution, CodeAnnotationsCache codeAnnotationsCache);
    public IPsiServices get_PsiServices();
    public sealed virtual IReferenceFactory CreateFactory(IPsiSourceFile sourceFile, IFile file, IWordIndex wordIndexForChecks);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<IReferenceProviderFactory> get_Changed();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpReferenceSearcher : object {
    [NotNullAttribute]
private GlobalUsingsCache myGlobalUsingsCache;
    [NotNullAttribute]
private IDeclaredElementsSet myElements;
    [NotNullAttribute]
private ReferenceSearcherParameters myReferenceSearcherParameters;
    [NotNullAttribute]
private HashSet`1<string> myNames;
    private bool mySearchForLateBound;
    private bool myHasUnnamedElement;
    public CSharpReferenceSearcher(IDomainSpecificSearcherFactory searchWordsProvider, GlobalUsingsCache globalUsingsCache, IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters, bool searchForLateBound);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    private bool CanContainReferencesTo(IPsiSourceFile sourceFile);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    [NotNullAttribute]
private HashSet`1<string> GetPossibleNames(ITreeNode element);
    private bool CanContainReferencesTo(IPsiSourceFile sourceFile, IDeclaredElement element);
}
[PsiComponentAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpSearcherFactory : DomainSpecificSearcherFactoryBase {
    [NotNullAttribute]
private SearchDomainFactory mySearchDomainFactory;
    [NotNullAttribute]
private TargetTypedObjectCreationCache myTargetTypedObjectCreationCache;
    [NotNullAttribute]
private CollectionExpressionCache myCollectionExpressionCache;
    [NotNullAttribute]
private GlobalUsingsCache myGlobalUsingsCache;
    [CompilerGeneratedAttribute]
private static IReadOnlyCollection`1<string> <NoName>k__BackingField;
    [NotNullAttribute]
private static IReadOnlyCollection`1<string> NoName { get; }
    public CSharpSearcherFactory(SearchDomainFactory searchDomainFactory, TargetTypedObjectCreationCache targetTypedObjectCreationCache, CollectionExpressionCache collectionExpressionCache, GlobalUsingsCache globalUsingsCache);
    private static CSharpSearcherFactory();
    [CompilerGeneratedAttribute]
private static IReadOnlyCollection`1<string> get_NoName();
    public virtual IEnumerable`1<string> GetAllPossibleWordsInFile(IDeclaredElement element);
    private static bool IsCorrectParametersNumberForQueryPatternMethod(IMethod method, int expectedParameters);
    public virtual bool IsCompatibleWithLanguage(PsiLanguageType languageType);
    public virtual IDomainSpecificSearcher CreateConstructorSpecialReferenceSearcher(ICollection`1<IConstructor> constructors);
    public virtual IDomainSpecificSearcher CreateMethodsReferencedByDelegateSearcher(IDelegate delegate);
    public virtual IDomainSpecificSearcher CreateReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    public virtual IEnumerable`1<ITwoPhaseDomainSpecificSearcher> CreateImplicitUsageSearchers(SearchPattern searchPattern, ICollection`1<IDeclaredElement> declaredElements);
    public virtual IDomainSpecificSearcher CreateTextOccurrenceSearcher(IDeclaredElementsSet elements);
    public virtual IDomainSpecificSearcher CreateTextOccurrenceSearcher(string subject);
    public virtual IDomainSpecificSearcher CreateLateBoundReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    public virtual IDomainSpecificSearcher CreateAnonymousTypeSearcher(IList`1<AnonymousTypeDescriptor> typeDescription, bool caseSensitive);
    public virtual IDomainSpecificSearcher CreateConstantExpressionSearcher(ConstantValue constantValue, bool onlyLiteralExpression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CSharpSearcherFactory/<GetRelatedDeclaredElements>d__20")]
public virtual IEnumerable`1<RelatedDeclaredElement> GetRelatedDeclaredElements(IDeclaredElement element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CSharpSearcherFactory/<GetRelatedFindResults>d__21")]
public virtual IEnumerable`1<FindResult> GetRelatedFindResults(IDeclaredElement element);
    public virtual NavigateTargets GetNavigateToTargets(IDeclaredElement element);
    public virtual ISearchDomain GetDeclaredElementSearchDomain(IDeclaredElement declaredElement);
    private void AddSearcherOfConstructorInTargetTypedNew(SearchPattern searchPattern, ICollection`1<IDeclaredElement> declaredElements, LocalList`1& searchers);
    private void AddSearchersForCollectionExpressionReferences(SearchPattern searchPattern, ICollection`1<IDeclaredElement> declaredElements, LocalList`1& searchers);
    [PureAttribute]
private static bool IsClassOrStructImplementingIEnumerable(ITypeElement typeElement);
    [PureAttribute]
private static bool IsCountOrLengthMemberUsableFromSpreadElement(IDeclaredElement declaredElement);
    [PureAttribute]
private static bool IsCollectionBuilderCreateMethodCandidate(IDeclaredElement declaredElement);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static IScope <GetDeclaredElementSearchDomain>g__GetContainingVariablesScope|23_0(ITreeNode treeNode);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpSharedImplUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static string GetQualifiedName(ICSharpDeclaration declaration);
    public static bool PreferQualifiedReference(IReference reference, IDeclaredElement targetElement);
    public static void RemoveListItemAndEmptyList(ITreeNode holder, short listRole, short elementRole, short sepRole, ITreeNode item);
    public static void RemoveListItem(ITreeNode holder, short listRole, short elementRole, short separatorRole, ITreeNode element);
    internal static void RemoveListItem(CompositeElement list, short elementRole, short separatorRole, ITreeNode element);
    [NotNullAttribute]
public static TTreeNode AddListItemAfter(ITreeNode holder, short listRole, short elementRole, TokenNodeType separator, TTreeNode element, ITreeNode anchor);
    [NotNullAttribute]
internal static TTreeNode AddListItemAfter(CompositeElement list, short elementRole, TokenNodeType separator, TTreeNode element, ITreeNode anchor, ITreeNode leftBorder);
    [NotNullAttribute]
public static ITypeParameterOfTypeDeclaration AddTypeParameterOfTypeBefore(ITypeDeclaration typeDeclaration, short listChildRole, ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    [NotNullAttribute]
public static ITypeParameterOfTypeDeclaration AddTypeParameterOfTypeAfter(ITypeDeclaration typeDeclaration, short listChildRole, ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    [NotNullAttribute]
public static ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(IClassLikeDeclaration typeDeclaration, IExtendsList extendsList, ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    [NotNullAttribute]
public static ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(IClassLikeDeclaration typeDeclaration, IExtendsList extendsList, ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    [NotNullAttribute]
public static TTreeNode AddListItemBefore(ITreeNode holder, short listRole, short elementRole, TokenNodeType separator, TTreeNode element, ITreeNode anchor);
    [NotNullAttribute]
internal static TTreeNode AddListItemBefore(CompositeElement list, short elementRole, TokenNodeType separator, TTreeNode element, ITreeNode anchor, ITreeNode rightBorder);
    [ContractAnnotationAttribute("body: null => null; body: notnull => notnull")]
public static IBlock SetFunctionBody(ICSharpFunctionDeclaration declaration, IBlock body);
    [ContractAnnotationAttribute("body: null => null; body: notnull => notnull")]
public static IBlock SetLocalFunctionBody(ILocalFunctionDeclaration declaration, IBlock body);
    [CanBeNullAttribute]
private static IBlock SetFunctionBodyInternal(CompositeElement holder, IBlock body);
    [ContractAnnotationAttribute("expression: null => null; expression: notnull => notnull")]
public static ICSharpExpression SetFunctionBodyExpression(IExpressionBodyOwnerDeclaration declaration, ICSharpExpression expression, bool removeSemicolon);
    [CanBeNullAttribute]
private static IErrorElement FindLastChildErrorElement(ITreeNode node);
    public static void EraseAccessors(IAccessorOwnerDeclaration declaration);
    [NotNullAttribute]
public static IAccessorDeclaration AddAccessorDeclarationBefore(IAccessorOwnerDeclaration parent, IAccessorDeclaration accessor, IAccessorDeclaration anchor);
    [NotNullAttribute]
public static IAccessorDeclaration AddAccessorDeclarationAfter(IAccessorOwnerDeclaration parent, IAccessorDeclaration accessor, IAccessorDeclaration anchor);
    public static void RemoveAccessorDeclaration(IAccessorOwnerDeclaration parent, IAccessorDeclaration accessor);
    [NotNullAttribute]
public static IAttribute AddAttributeAfter(IAttributesOwnerDeclaration parent, IAttribute attribute, IAttribute anchor, string explicitSectionTargetName);
    [NotNullAttribute]
public static IAttribute AddAttributeBefore(IAttributesOwnerDeclaration parent, IAttribute attribute, IAttribute anchor, string explicitSectionTargetName);
    [PureAttribute]
private static TreeNodeCollection`1<IAttribute> GetAttributesInExplicitSectionOrAllIfNoExplicitSpecified(IAttributesOwnerDeclaration parent, string explicitSectionName);
    [NotNullAttribute]
public static IAttribute CreateAttributeInSection(IAttributesOwnerDeclaration parent, string sectionTarget, IAttribute anchor, bool beforeAnchor);
    public static ITreeNode LowLevelAddChildBeforeAndFormatToTheRight(ITreeNode anchorFromRight, ITreeNode[] nodesToInsert);
    public static ITreeNode AddChildAndFormatToRight(ITreeNode parent, ITreeNode[] nodesToInsert);
    [PureAttribute]
private static bool CanInsertAttributeToTheSameSection(IAttribute anchorAttribute, string sourceAttributeTarget);
    [NotNullAttribute]
public static IAttribute ReplaceAttribute(IAttributesOwnerDeclaration parent, IAttribute attribute, IAttribute newAttribute, string explicitSectionTargetName);
    public static void RemoveAttribute(IAttributesOwnerDeclaration parent, IAttribute attribute);
    public static void RemoveChildWithWhitespaceFromRight(ITreeNode nodeToRemove);
    [PureAttribute]
public static bool IsReadonlyMemberWriteable(ITypeMember typeMember, ICSharpTreeNode writeUsage);
    [PureAttribute]
public static bool IsGetOnlyAutoPropertyWriteable(IProperty typeMember, ICSharpTreeNode writeUsage);
    [PureAttribute]
public static bool IsInitOnlySetAllowed(IAccessor initOnlySetter, ICSharpTreeNode writeUsage, IResolveContext resolveContext);
    [PureAttribute]
public static ExpressionClassification ClassifyThisExpression(ICSharpTreeNode usageContext);
    [PureAttribute]
public static ExpressionClassification ClassifyThisExpression(ICSharpTreeNode usageContext, ICSharpModifiersOwnerDeclaration& readonlyModifierSource);
    [PureAttribute]
public static bool IsUsageFromConstructorWithinSameType(ITypeMember typeMember, ICSharpTreeNode usage);
    [PureAttribute]
public static bool IsUsageFromConstructorOrInitOnlySetterWithinSameType(ITypeMember typeMember, ICSharpTreeNode usage);
    [PureAttribute]
private static bool IsUsageFromConstructorOrInitOnlySetterWithinSameType(ITypeMember typeMember, ICSharpTreeNode usage, bool allowInitOnly);
    [PureAttribute]
public static bool IsStructAccessExpressionQualifierNotClassifiedAsVariable(IConditionalAccessExpression memberAccessExpression, IDeclaredElement typeMemberLike, ICSharpExpression& problematicQualifierAccessExpression, IResolveContext resolveContext, bool possibleStruct, bool readOnlyAccess);
    [PureAttribute]
private static bool IsValueTypeMemberAccess(IType qualifierType, ITreeNode context, bool possibleStruct);
    [NotNullAttribute]
[PureAttribute]
public static IExpressionType ComputeExpressionTypeByCandidates(IResolveResult resolveResult, IList`1<IDeclaredElement> candidates, IPsiModule psiModule);
    [CanBeNullAttribute]
[PureAttribute]
public static TreeElement GetNextFilteredPreprocessorChild(ITreeNode parent, ITreeNode child);
    [PureAttribute]
public static TreeTextRange GetPreprocessorMessageNameStart(ITokenNode messageToken);
    [CanBeNullAttribute]
[PureAttribute]
public static IPreprocessorDirective FindCorrespondingDirective(IPreprocessorDirective directive, TokenNodeType thisDirectiveToken, TokenNodeType correspondingDirectiveToken, Func`2<ITokenNode, ITokenNode> advance);
    [PureAttribute]
public static ParameterKind ParameterModifiers2ParameterKind(IParameterModifiersList parameterModifiersList);
    [PureAttribute]
public static TypeParameterConstraintFlags GetTypeParameterConstraintFlags(ITypeParameterDeclaration typeParameterDeclaration, TreeNodeEnumerable`1<ITypeParameterConstraint> constraints, bool checkResolve);
    public static void SetExtendsType(IClassLikeDeclaration declaration, IExtendsList extendsList, Func`2<IExtendsList, IExtendsList> setExtendsList, IDeclaredType superType);
    public static void AddSuperInterface(IClassLikeDeclaration declaration, IExtendsList extendsList, Func`2<IExtendsList, IExtendsList> setExtendsList, IDeclaredType interfaceType, bool before);
    public static void RemoveSuperInterface(IExtendsList extendsList, IDeclaredType interfaceType);
    [NotNullAttribute]
public static IExtendsList GetOrCreateExtendsList(IClassLikeDeclaration declaration, IExtendsList extendsList, Func`2<IExtendsList, IExtendsList> setExtendsList);
    [CanBeNullAttribute]
[PureAttribute]
public static IType TryGetRealReturnType(IType inferredReturnType, bool isAsync, PredefinedType predefinedType);
    [PureAttribute]
[NotNullAttribute]
public static ICollection`1<IExpressionType> GetRidOfVoidReturnsIfMany(ICollection`1<IExpressionType> returnTypes);
    public static ScopedKind GetEffectiveDeclarationScope(IParameter parameter, ScopedKind declaredScope);
    public static bool HasUnscopedRefAttribute(IParameter parameter);
    public static void SetGlobal(IUsingDirective usingDirective, bool isGlobal);
    public static void SetStatic(IUsingDirective usingDirective, bool isStatic);
    public static void SetUnsafe(IUsingDirective usingDirective, bool isUnsafe);
    public static bool IsParameterArray(ICSharpRegularParameterDeclaration parameterDeclaration);
    public static bool IsParameterCollection(ICSharpRegularParameterDeclaration parameterDeclaration);
    [CompilerGeneratedAttribute]
internal static bool <IsInitOnlySetAllowed>g__IsUsageInSameOrDerivedContainingType|34_0(<>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUsageFromConstructorOrInitOnlySetterWithinSameType>g__SameContainingType|39_0(<>c__DisplayClass39_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetRidOfVoidReturnsIfMany>g__IsVoidExpressionType|53_0(IExpressionType type);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTextOccurrenceSearcher : TextOccurrenceSearcherBase`1<CSharpLanguage> {
    protected Predicate`1<ITreeNode> Predicate { get; }
    public CSharpTextOccurrenceSearcher(IEnumerable`1<IDeclaredElement> elements);
    public CSharpTextOccurrenceSearcher(string subject);
    protected virtual Predicate`1<ITreeNode> get_Predicate();
    private sealed virtual override bool JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcher.ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTopLevelCodeCacheProvider : object {
    public sealed virtual bool HasTopLevelCode(IFile psiFile);
    public sealed virtual IDeclaredElement TryGetTopLevelEntryPoint(IFile psiFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTreeRange : TreeRange {
    public CSharpTreeRange(ITreeNode first, ITreeNode last);
    [PureAttribute]
public static TreeRange BuildByTextRange(ITreeRange nodes, TreeTextRange textRange);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTreeRange/<GetPlainNodes>d__2")]
private static IEnumerable`1<ITreeNode> GetPlainNodes(ITreeRange nodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTypeBindingUtil : object {
    public static ITreeNode BindTypeUsageToType(ITypeUsage typeUsage, IType type);
    public static void BindSymbolAliasReferenceToType(IReference reference, IType aliasedType);
    private static TypePresentationOptions GetTypePresenatationOptions(ITypeUsage typeUsage);
    [PureAttribute]
private static bool ShouldUseNamedComponents(ITypeUsage typeUsage, DecoratedType`1<TupleTypeDecoration> tupleType);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTypeConversionRule : object {
    private static Byte[0...,0...] ourSimpleConversionKind;
    [ThreadStaticAttribute]
private static int ourCurrentRecursionDepth;
    private static int MaximumRecursionDepth;
    [NotNullAttribute]
private IPsiModule myModule;
    [CanBeNullAttribute]
private CSharpTypeConversionRule myOtherNullabilityConversionRule;
    [CompilerGeneratedAttribute]
private bool <IncludeNullability>k__BackingField;
    [NotNullAttribute]
private static ObjectPool`1<PooledStack`1<ITypeParameter>> ourTypeParameterStackPool;
    [NotNullAttribute]
private static ObjectPool`1<PooledHashSet`1<ITypeParameter>> ourTypeParameterVisitedPool;
    public bool IncludeNullability { get; }
    public IEqualityComparer`1<IType> EqualityComparer { get; }
    private static CSharpTypeConversionRule();
    internal CSharpTypeConversionRule(IPsiModule module, bool includeNullability);
    private static Nullable`1<int> TypeToIndex(IType type);
    private static ConversionKind ClassifySimpleConversion(IType from, IType to);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeNullability();
    public sealed virtual CSharpTypeConversionRule WithNullability(bool includeNullability);
    internal static bool IsEquivalent(IExpressionType expressionType1, IExpressionType expressionType2);
    public sealed virtual IType BestCommonType(ICollection`1<TExpressionType> types);
    public sealed virtual IType BestCommonType(ICollection`1<TExpressionType> types, bool allowFunctionTypes);
    private bool IsBetter(IType better, IExpressionType worse);
    [CanBeNullAttribute]
private IType BestCommonType(IType type1, IExpressionType candidate, Nullable`1& languageLevel);
    public sealed virtual Conversion ClassifyImplicitConversionFromExpression(IExpressionType from, IType to);
    public sealed virtual bool ImplicitReferenceConversionExist(IType from, IType to);
    public sealed virtual IEqualityComparer`1<IType> get_EqualityComparer();
    public sealed virtual bool IsImplicitlyConvertibleTo(IType from, IType to);
    public sealed virtual bool IsImplicitlyConvertiblePredefined(IType from, IType to);
    public sealed virtual bool HasStandardImplicitConversion(IType from, IType to);
    public sealed virtual bool HasExtensionMethodThisArgumentConversion(IType from, IType to, ParameterKind thisParameterKind);
    public sealed virtual Conversion ClassifyImplicitConversion(IType from, IType to);
    public sealed virtual Conversion ClassifyImplicitExtensionMethodThisArgumentConversion(IExpressionType fromExpressionType, IType to);
    public sealed virtual bool HasIdentityConversion(IType from, IType to);
    private Conversion ClassifyStandardImplicitConversion(IExpressionType fromExpressionType, IType from, IType to);
    private Conversion ClassifyImplicitBuiltInConversionFromExpression(IExpressionType from, IType fromType, IType to);
    private Conversion GetSwitchExpressionConversion(IExpressionType expressionType, IType to);
    private Conversion GetConditionalExpressionConversion(IExpressionType expressionType, IType to);
    private Conversion GetStackAllocConversion(IStackAllocExpressionType stackAllocExpressionType, IType to);
    private Conversion GetInterpolatedStringConversion(IExpressionType fromExpressionType, IType to);
    private Conversion GetCollectionExpressionConversion(ICollectionExpressionType collectionExpressionType, IType to);
    private Conversion GetMethodGroupConversion(IMethodGroupType methodGroupType, IType to);
    private Conversion GetAddressOfMethodGroupConversion(IAddressOfMethodGroupType addressOfMethodGroupType, IType to);
    public static bool IsAnonymousFunctionCompatibleWithType(IAnonymousFunctionType anonymousFunctionType, IType to);
    private static bool IsAnonymousFunctionCompatibleWithExpressionTree(IAnonymousFunctionType anonymousFunctionType, IType to);
    private static bool IsAnonymousFunctionCompatibleWithDelegate(IAnonymousFunctionType anonymousFunctionType, DeclaredElementInstance`1<IDelegate> delegateInstance);
    private static Conversion ClassifyNullLiteralConversion(IExpressionType from, IType to);
    private static Conversion ClassifyImplicitConstantExpressionConversion(IExpressionType from, IType to);
    private static bool HasImplicitConstantExpressionConversion(IExpressionType from, IType to);
    private static bool HasImplicitEnumerationConversion(IExpressionType from, IType to);
    private static bool HasImplicitDynamicConversionFromExpression(IType fromExpressionType, IType to);
    private static bool ImplicitNumericConversionExist(IType from, IType to);
    public sealed virtual bool HasTopLevelNullabilityIdentityConversion(IType source, IType destination);
    public sealed virtual bool HasTopLevelNullabilityImplicitConversion(IExpressionType source, IType destination);
    private bool HasTopLevelNullabilityImplicitConversion(IType source, IType destination);
    public sealed virtual bool HasImplicitTypeParameterConversion(IType fromTypeParameterType, IType to);
    private static bool TypeParameterDependsOn(ITypeParameter typeParameter1, ITypeParameter typeParameter2);
    private bool ImplicitReferenceConversionWithNullabilityExist(IType from, IType to);
    private bool ImplicitReferenceConversionExistImpl(IType from, IType to);
    private bool IsBoxingConversion(IType from, IType to);
    private bool HasImplicitBoxingTypeParameterConversion(IType from, IType to);
    private bool HasImplicitEffectiveInterfaceSetConversion(ITypeParameter from, IType to);
    private bool HasVarianceCompatibleInterfaceInEffectiveInterfaceSet(ITypeParameter from, IType to);
    private bool HasInterfaceVarianceConversion(IType from, IType to);
    private bool HasVariantConversion(IDeclaredType from, IDeclaredType to);
    private Nullable`1<bool> HasVariantConversionQuick(IDeclaredType from, IDeclaredType to);
    private bool HasVariantConversionNoCycleCheck(IDeclaredType from, IDeclaredType to);
    private Conversion ClassifyImplicitConversionImpl(IType from, IType to);
    private bool HasImplicitEffectiveBaseConversion(ITypeParameter from, IType to);
    private Conversion ClassifyImplicitBuiltInConversionSlow(IType from, IType to);
    private static bool HasImplicitPointerToVoidConversion(IType from, IType to);
    private bool HasImplicitPointerConversion(IType from, IType to);
    private bool HasImplicitConversionToInterface(IType from, IType to);
    private bool HasAnyBaseInterfaceConversion(IType derivedType, IType baseType);
    private bool ImplementsVarianceCompatibleInterface(IType derivedType, IType baseType);
    public sealed virtual bool ImplementsVarianceCompatibleInterface(IDeclaredType derivedType, IType baseType);
    public sealed virtual bool HasImplicitConversionToOrImplementsVarianceCompatibleInterface(IType typeToCheck, IDeclaredType targetInterfaceType, Boolean& needSupportForRefStructInterfaces);
    private bool IsRefLikeOrAllowsRefLikeTypeImplementingVarianceCompatibleInterface(IType typeToCheck, IDeclaredType targetInterfaceType);
    public sealed virtual bool HasImplicitConversionToOrImplementsVarianceCompatibleInterface(IExpressionType expressionTypeToCheck, IDeclaredType targetInterfaceType, Boolean& needSupportForRefStructInterfaces);
    private bool HasImplicitConversionFromArray(IType from, IType to);
    private bool HasArrayConversionToInterface(IArrayType from, IType to);
    private bool HasIdentityOrImplicitReferenceConversion(IType from, IType to);
    private static bool IsPossibleArrayGenericInterface(IType interfaceType);
    private bool HasCovariantArrayConversion(IType from, IType to);
    private bool HasImplicitConversionFromDelegate(IType from, IType to);
    private bool HasDelegateVarianceConversion(IType from, IType to);
    private bool HasImplicitReferenceTypeParameterConversion(ITypeParameter from, IType to);
    private Conversion ClassifyImplicitNullableConversion(IType from, IType to);
    public sealed virtual Conversion ClassifyConversionFromExpression(IExpressionType fromExpressionType, IType to, bool isChecked);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType from, IType to);
    public sealed virtual bool IsImplicitlyConvertibleTo(IExpressionType from, IType to);
    public sealed virtual bool IsExplicitlyConvertibleTo(IExpressionType from, IType to);
    public sealed virtual Conversion ClassifyConversionFromType(IType from, IType to, bool isChecked);
    private bool HasImplicitFunctionTypeConversion(IType fromFunctionType, IType to);
    internal bool IsValidFunctionTypeConversionTarget(IType to);
    public sealed virtual bool IsExplicitlyConvertiblePredefined(IType from, IType to);
    public sealed virtual Conversion ClassifyBuiltInConversion(IType from, IType to);
    private Conversion ClassifyConversionFromExpressionForCast(IExpressionType fromExpressionType, IType to, bool isChecked);
    private Conversion ClassifyExplicitOnlyConversionFromExpression(IExpressionType fromExpressionType, IType to, bool isChecked, bool fallbackToImplicitIfAmbiguous);
    private static bool ExplicitNumericConversionExist(IType from, IType to);
    private Conversion ClassifyConversionFromExpressionImpl(IExpressionType fromExpressionType, IType to, bool isChecked, bool fallbackToImplicitIfAmbiguous);
    private Conversion ClassifyStandardConversion(IExpressionType fromExpressionType, IType from, IType to);
    private Conversion ClassifyConversionFromTypeImpl(IType from, IType to, bool isChecked, bool fallbackToImplicitIfAmbiguous);
    private Conversion ClassifyConversionFromTypeForCast(IType from, IType to, bool isChecked);
    private static bool ExplicitConversionMayDifferFromImplicit(Conversion implicitConversion);
    private bool ExplicitReferenceConversionExist(IType from, IType to);
    private bool IsUnboxingConversion(IType from, IType to);
    private bool HasUnboxingTypeParameterConversion(IType from, IType to);
    private Conversion ClassifyBuiltInConversionImpl(IType from, IType to, bool implicitOnly);
    private static Conversion FastClassifyConversion(IType from, IType to);
    private Conversion ClassifyStandardImplicitConversion(IType from, IType to);
    private Conversion DeriveStandardExplicitFromOppositeStandardImplicitConversion(IType from, IType to);
    private Conversion ClassifyExplicitBuiltInOnlyConversion(IType from, IType to, bool isChecked, bool fallbackToImplicitIfAmbiguous);
    private Conversion ClassifyExplicitNullableConversion(IType from, IType to, bool isChecked, bool fallbackToImplicitIfAmbiguous);
    private bool HasSpecialIntPtrConversion(IType from, IType to);
    private bool HasExplicitArrayConversion(IType from, IType to);
    private bool HasExplicitDelegateConversion(IType from, IType to);
    private bool HasExplicitReferenceTypeParameterConversion(IType from, IType to);
    private bool HasIdentityOrReferenceConversion(IType from, IType to);
    private static bool HasExplicitDynamicConversion(IType from, IType to);
    private static bool HasExplicitEnumerationConversion(IType from, IType to);
    private static bool HasPointerToPointerConversion(IType from, IType to);
    private static bool HasPointerToIntegerConversion(IType from, IType to);
    private static bool HasIntegerToPointerConversion(IType from, IType to);
    private Conversion GetImplicitUserDefinedConversion(IExpressionType fromExpressionType, IType from, IType to);
    private Conversion GetExplicitUserDefinedConversion(IExpressionType fromExpressionType, IType from, IType to, bool isChecked);
    public ValueTuple`2<UserDefinedConversionResult, IList`1<UserDefinedConversionAnalysis>> GetCustomImplicitOperator(IExpressionType expressionType, IType source, IType target);
    internal ValueTuple`2<UserDefinedConversionResult, IList`1<UserDefinedConversionAnalysis>> ResolveMultipleImplicitOperators(IList`1<UserDefinedConversionAnalysis> operators, IExpressionType source, IType target);
    public ValueTuple`2<UserDefinedConversionResult, IList`1<UserDefinedConversionAnalysis>> GetCustomExplicitOperator(IExpressionType sourceExpressionType, IType source, IType target, bool isChecked);
    [CanBeNullAttribute]
private UserDefinedConversionAnalysis IsExplicitlyConvertibleUsingConversionOperator(IExpressionType sourceExpressionType, IType source, IType target, OperatorInfo conversionOperator);
    [CanBeNullAttribute]
internal UserDefinedConversionAnalysis IsImplicitlyConvertibleUsingConversionOperator(IExpressionType sourceExpressionType, IType source, IType target, OperatorInfo conversionOperator);
    private bool CheckTupleTypeConversionConsistence(ITupleExpressionType tupleExpressionType, IType convertsFrom);
    private ValueTuple`2<UserDefinedConversionResult, IList`1<UserDefinedConversionAnalysis>> ResolveMultipleExplicitOperators(IList`1<UserDefinedConversionAnalysis> operators, IType source, IType target);
    private static ValueTuple`2<UserDefinedConversionResult, IList`1<UserDefinedConversionAnalysis>> SelectMostSpecificOperator(IList`1<UserDefinedConversionAnalysis> operators, IType sx, IType tx);
    private Conversion EncompassingExplicitConversion(IExpressionType fromExpressionType, IType from, IType to);
    private Conversion EncompassingImplicitConversion(IExpressionType fromExpressionType, IType from, IType to);
    private static bool IsEncompassingImplicitConversionKind(ConversionKind kind);
    private static bool IsImplicitTupleComponentConversionKind(TupleComponentConversionKind conversionKind);
    private static TupleComponentConversionKind GetExplicitTupleComponentConversionKind(bool fallbackToImplicitIfAmbiguous);
    private Conversion ClassifyTupleConversion(IType from, IType to, TupleComponentConversionKind conversionKind, bool isChecked);
    private Conversion ClassifyTupleLiteralConversion(ITupleExpressionType from, IType to, TupleComponentConversionKind conversionKind, bool isChecked);
    private Conversion GetTupleLiteralConversion(ITupleExpressionType from, IType to, TupleComponentConversionKind conversionKind, bool isChecked);
    private Conversion GetTupleLiteralComponentConversion(IExpressionType componentExpressionType, IType targetComponentType, TupleComponentConversionKind conversionKind, bool isChecked);
    private Conversion GetTupleComponentConversion(IType componentType, IType targetComponentType, TupleComponentConversionKind conversionKind, bool isChecked);
    private static Conversion ClassifyWithMultitype(IType from, IType to, Func`3<IType, IType, Conversion> classifyFunc);
    private static Conversion ClassifyWithMultitype(IExpressionType from, IType to, Func`3<IExpressionType, IType, Conversion> classifyFunc);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static IType <BestCommonType>g__NullOrUnwrapFunctionType|15_0(IType type, <>c__DisplayClass15_0`1& );
    [CompilerGeneratedAttribute]
private Conversion <ImplicitReferenceConversionExist>g__Classify|19_0(IType type1, IType type2);
    [CompilerGeneratedAttribute]
private Conversion <IsImplicitlyConvertiblePredefined>g__ClassifyFunc|23_0(IType type1, IType type2);
    [CompilerGeneratedAttribute]
private bool <HasImplicitPointerConversion>g__HasConversion|68_0(ReferenceKind refKind, IType sourceType, IType destinationType);
    [CompilerGeneratedAttribute]
private Conversion <IsExplicitlyConvertiblePredefined>g__ClassifyFunc|92_0(IType type1, IType type2);
    [CompilerGeneratedAttribute]
private Conversion <GetTupleLiteralComponentConversion>g__ClassifyComponentConversion|140_0(IExpressionType componentExpressionType, IType targetComponentType, <>c__DisplayClass140_0& );
    [CompilerGeneratedAttribute]
private Conversion <GetTupleComponentConversion>g__ClassifyComponentConversion|141_0(IType componentType, IType targetComponentType, <>c__DisplayClass141_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.CSharpTypePresenter : object {
    [NotNullAttribute]
private static TypePresenter ourPresenterFunc;
    [NotNullAttribute]
public static CSharpLanguage Language { get; }
    private static CSharpTypePresenter();
    public static CSharpLanguage get_Language();
    public sealed virtual RichText GetPresentableName(IType type, TypePresentationStyle typePresentationStyle);
    public sealed virtual RichText GetUnresolvedScalarTypePresentation(string name, ICollection`1<IType> typeArguments, NullableAnnotation nullableAnnotation, TypePresentationStyle typePresentationStyle);
    private static void BuildPresentableName(IType type, RichText richText, TypePresentationStyle typePresentationStyle);
    private static void BuildAnonymousTypeString(ICSharpAnonymousType anonymousType, RichText builder, TypePresentationStyle typePresentationStyle, TypePresenter presenter);
    private static void BuildPointerTypeString(IPointerType pointerType, RichText builder, TypePresentationStyle typePresentationStyle, TypePresenter presenter);
    private static void BuildFunctionPointerTypeString(IFunctionPointerType functionPointerType, RichText builder, TypePresentationStyle typePresentationStyle, TypePresenter presenter);
    private static void BuildArrayTypeString(IArrayType arrayType, RichText builder, TypePresentationStyle typePresentationStyle, TypePresenter presenter);
    private static void BuildDeclaredTypePresentableName(IDeclaredType declaredType, RichText builder, TypePresentationStyle typePresentationStyle);
    private static string ShortName(string name);
    private static void AppendNullableAnnotation(IType annotatedType, RichText builder, TypePresentationStyle typePresentationStyle);
    private static void BuildTypeArgumentList(ITypeElement element, ISubstitution substitution, RichText builder, TypePresentationStyle typePresentationStyle, TypePresenter presenter);
    private static void BuildAnonymousDelegate(AnonymousDelegate anonymousDelegate, RichText builder, TypePresentationStyle typePresentationStyle, TypePresenter presenter);
    [CompilerGeneratedAttribute]
internal static void <BuildFunctionPointerTypeString>g__AppendKeyword|9_0(string keyword, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static void <BuildFunctionPointerTypeString>g__AppendCallingConventions|9_1(CallingConvention callingConvention, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static bool <BuildArrayTypeString>g__ShouldAddNullableAnnotation|10_0(IType type, <>c__DisplayClass10_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.CustomHandlers.CSharpCustomModificationHandlerDummy : object {
    [NotNullAttribute]
public static ICSharpCustomModificationHandler Instance;
    public bool CanUseAliases { get; }
    public bool CanUseStaticImport { get; }
    public bool CanOmitBraces { get; }
    private static CSharpCustomModificationHandlerDummy();
    public sealed virtual bool IsToAddImportsToDeepestScope(ITreeNode context, IContextBoundSettingsStore settingsStore);
    public sealed virtual bool IsQualifiedUsingAtNestedScope(ITreeNode context, IContextBoundSettingsStore settingsStore);
    public sealed virtual ThisQualifierSettingsKey GetThisQualifierStyle(ITreeNode context, IContextBoundSettingsStore settingsStore);
    public sealed virtual bool CanRemoveUsing(IDocument document, IUsingDirective usingDirective);
    public sealed virtual bool get_CanUseAliases();
    public sealed virtual bool get_CanUseStaticImport();
    public sealed virtual bool get_CanOmitBraces();
    public sealed virtual void HandleRemoveStatementsRange(IPsiServices psiServices, ITreeRange treeRange, Action action);
    public sealed virtual ICSharpStatementsRange HandleAddStatementsRange(IPsiServices psiServices, Func`2<ITreeNode, ICSharpStatementsRange> addAction, IStatementsOwner block, ITreeNode anchor, bool before, bool strict);
    public sealed virtual void HandleChangeExpressionInStatement(IPsiServices psiServices, IStatement statement, Action changeAction);
    public sealed virtual void HandleRemoveImport(IPsiServices psiServices, ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective, Action action);
    public sealed virtual IUsingDirective HandleAddImport(IPsiServices psiServices, Func`1<IUsingDirective> action, ITreeNode generatedAnchor, bool before, IFile generatedFile);
    public sealed virtual ITreeNode HandleAddTypeMember(IPsiServices psiServices, Func`1<ITreeNode> action, IFile generatedFile);
    public sealed virtual void HandleRemoveTypeMember(IPsiServices psiServices, ITreeNode node, Action action);
    public sealed virtual ITreeNode FixupAnchorForAddingTypeMember(IPsiServices psiServices, IFile generatedFile, ITreeNode anchor, bool willInsertBefore, ITreeNode classDeclaration);
    public sealed virtual ITreeNode HandleSuperClassChange(IPsiServices psiServices, Func`1<ITreeNode> action, ITreeNode classDeclaration);
    public sealed virtual IBlock GetMethodBodyVisibleForUser(ICSharpFunctionDeclaration method);
    public sealed virtual bool PreferQualifiedReference(IQualifiableReference reference, IDeclaredElement targetElement);
    public sealed virtual string GetSpecialMethodType(DeclaredElementPresenterStyle presenter, IMethod method, ISubstitution substitution);
    public sealed virtual ITreeRange HandleChangeStatements(IPsiServices psiServices, ITreeRange rangeBeforeChange, Func`1<ITreeRange> changeAction, bool strict);
    public sealed virtual IList`1<ITreeRange> GetHolderBlockRanges(ITreeNode treeNode);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.CustomHandlers.ICSharpCustomModificationHandler {
    public bool CanUseAliases { get; }
    public bool CanUseStaticImport { get; }
    public bool CanOmitBraces { get; }
    [NotNullAttribute]
public abstract virtual ThisQualifierSettingsKey GetThisQualifierStyle(ITreeNode context, IContextBoundSettingsStore settingsStore);
    public abstract virtual bool IsToAddImportsToDeepestScope(ITreeNode context, IContextBoundSettingsStore settingsStore);
    public abstract virtual bool IsQualifiedUsingAtNestedScope(ITreeNode context, IContextBoundSettingsStore settingsStore);
    public abstract virtual bool CanRemoveUsing(IDocument document, IUsingDirective usingDirective);
    public abstract virtual bool get_CanUseAliases();
    public abstract virtual bool get_CanUseStaticImport();
    public abstract virtual bool get_CanOmitBraces();
    public abstract virtual ICSharpStatementsRange HandleAddStatementsRange(IPsiServices psiServices, Func`2<ITreeNode, ICSharpStatementsRange> addAction, IStatementsOwner block, ITreeNode anchor, bool before, bool strict);
    public abstract virtual void HandleRemoveStatementsRange(IPsiServices psiServices, ITreeRange treeRange, Action action);
    public abstract virtual ITreeRange HandleChangeStatements(IPsiServices psiServices, ITreeRange rangeBeforeChange, Func`1<ITreeRange> changeAction, bool strict);
    public abstract virtual void HandleChangeExpressionInStatement(IPsiServices psiServices, IStatement statement, Action changeAction);
    public abstract virtual void HandleRemoveImport(IPsiServices psiServices, ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective, Action action);
    public abstract virtual IUsingDirective HandleAddImport(IPsiServices psiServices, Func`1<IUsingDirective> action, ITreeNode generatedAnchor, bool before, IFile generatedFile);
    public abstract virtual ITreeNode HandleAddTypeMember(IPsiServices psiServices, Func`1<ITreeNode> action, IFile generatedFile);
    public abstract virtual void HandleRemoveTypeMember(IPsiServices psiServices, ITreeNode node, Action action);
    public abstract virtual ITreeNode FixupAnchorForAddingTypeMember(IPsiServices psiServices, IFile generatedFile, ITreeNode anchor, bool willInsertBefore, ITreeNode classDeclaration);
    public abstract virtual ITreeNode HandleSuperClassChange(IPsiServices psiServices, Func`1<ITreeNode> action, ITreeNode classDeclaration);
    public abstract virtual IBlock GetMethodBodyVisibleForUser(ICSharpFunctionDeclaration method);
    public abstract virtual bool PreferQualifiedReference(IQualifiableReference reference, IDeclaredElement targetElement);
    public abstract virtual string GetSpecialMethodType(DeclaredElementPresenterStyle presenter, IMethod method, ISubstitution substitution);
    [NotNullAttribute]
public abstract virtual IList`1<ITreeRange> GetHolderBlockRanges(ITreeNode treeNode);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DebuggerDisplayReference : CheckedReferenceBase`1<ICSharpLiteralExpression> {
    [CanBeNullAttribute]
private DebuggerDisplayReference myQualifier;
    private TextRange myValueRange;
    private TextRange myParenthesesRange;
    private static string DebuggerDisplayRegex;
    private static string DebuggerExprHoleRegex;
    private static RegexOptions DebuggerDisplayRegexOptions;
    public bool ShouldResolveInGlobalTable { get; }
    public bool IsQualified { get; }
    public bool Resolved { get; }
    private DebuggerDisplayReference(ICSharpLiteralExpression literal, DebuggerDisplayReference qualifier, TextRange valueRange, TextRange parenthesesRange);
    public virtual string GetName();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public sealed virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    public sealed virtual bool get_ShouldResolveInGlobalTable();
    public sealed virtual ISymbolTable GetCompletionSymbolTable();
    public sealed virtual bool get_IsQualified();
    public sealed virtual IQualifier GetQualifier();
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public virtual ISymbolFilter[] GetSymbolFilters();
    public virtual IAccessContext GetAccessContext();
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IReference BindTo(IDeclaredElement element);
    public static ReferenceCollection TryCreate(ICSharpLiteralExpression literalExpression, string literalValue, StringBuilder suffix);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DeclarationsRange : object {
    [CompilerGeneratedAttribute]
private ITreeRange <TreeRange>k__BackingField;
    public ITreeRange TreeRange { get; }
    public IDeclaration[] Declarations { get; }
    public DeclarationsRange(ITreeRange treeRange);
    [CompilerGeneratedAttribute]
public sealed virtual ITreeRange get_TreeRange();
    public sealed virtual IDeclaration[] get_Declarations();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpAccessor : CSharpOverridableMember`1<AccessorDeclaration> {
    [CanBeNullAttribute]
private ValueVariable modreq(System.Runtime.CompilerServices.IsVolatile) myValueVariable;
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public bool IsIterator { get; }
    public bool IsExtensionMethod { get; }
    public bool IsVarArg { get; }
    public bool IsAsync { get; }
    public IOverridableMember OwnerMember { get; }
    public AccessorKind Kind { get; }
    public bool IsAuto { get; }
    public bool IsInitOnly { get; }
    public bool IsReadonly { get; }
    public IParameter ValueVariable { get; }
    public bool IsStatic { get; }
    public bool IsUnsafe { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsExtern { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public CSharpAccessor(AccessorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    protected virtual IOwnerQualification GetOwnerQualificationNode();
    public virtual bool get_IsExplicitImplementation();
    public virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsAsync();
    public sealed virtual IOverridableMember get_OwnerMember();
    public sealed virtual AccessorKind get_Kind();
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsInitOnly();
    public virtual bool get_IsReadonly();
    public sealed virtual IParameter get_ValueVariable();
    public virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    public virtual AccessRights GetAccessRights();
    public virtual string ToString();
    public virtual bool get_IsStatic();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsExtern();
    public virtual bool get_IsVolatile();
    public virtual string get_XMLDocId();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpArglistParameter : CSharpParameterBase`1<TypeMemberArglistParameterDeclaration> {
    public IType Type { get; }
    public ParameterKind Kind { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public ScopedKind Scope { get; }
    public CSharpArglistParameter(TypeMemberArglistParameterDeclaration declaration);
    protected virtual IList`1<IAttribute> GetOurAttributes();
    public virtual IType get_Type();
    public virtual ParameterKind get_Kind();
    public virtual bool get_IsOptional();
    public virtual bool get_IsVarArg();
    public virtual bool get_IsParams();
    public virtual bool get_IsParameterArray();
    public virtual bool get_IsParameterCollection();
    public virtual DefaultValue GetDefaultValue();
    public virtual ScopedKind get_Scope();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpBackingField : object {
    [NotNullAttribute]
private IProperty myProperty;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public ConstantValue ConstantValue { get; }
    public IProperty OwnerProperty { get; }
    public IType Type { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ITypeElement ContainingType { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public MemberHidePolicy HidePolicy { get; }
    public CSharpBackingField(IProperty semiAutoProperty);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual IProperty get_OwnerProperty();
    public sealed virtual IType get_Type();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpByIndexIndexer : SpecialIndexer {
    [NotNullAttribute]
private PredefinedType myPredefinedType;
    [NotNullAttribute]
private IType myOwnerType;
    [CompilerGeneratedAttribute]
private IProperty <ByIntegerIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty <LengthProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccessor <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccessor <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <ReturnKind>k__BackingField;
    [NotNullAttribute]
public IType OwnerType { get; }
    [CanBeNullAttribute]
public IProperty ByIntegerIndexer { get; }
    [CanBeNullAttribute]
public IProperty LengthProperty { get; }
    public IAccessor Getter { get; }
    public IAccessor Setter { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public IPsiModule Module { get; }
    public IList`1<IParameter> Parameters { get; }
    [NotNullAttribute]
private IParameter Parameter { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public CSharpByIndexIndexer(PredefinedType predefinedTypesOfUsageContext, IType ownerType, IType returnType, ReferenceKind returnKind);
    public CSharpByIndexIndexer(PredefinedType predefinedTypesOfUsageContext, IDeclaredType ownerType, IProperty byIntegerIndexer, IProperty lengthProperty);
    public IType get_OwnerType();
    [CompilerGeneratedAttribute]
public IProperty get_ByIntegerIndexer();
    [CompilerGeneratedAttribute]
public IProperty get_LengthProperty();
    [CompilerGeneratedAttribute]
public virtual IAccessor get_Getter();
    [CompilerGeneratedAttribute]
public virtual IAccessor get_Setter();
    public virtual bool get_IsReadable();
    public virtual bool get_IsWritable();
    public virtual AccessRights GetAccessRights();
    public virtual IPsiServices GetPsiServices();
    public virtual bool IsValid();
    public virtual IPsiModule get_Module();
    public virtual ITypeElement GetContainingType();
    public virtual ITypeMember GetContainingTypeMember();
    public virtual IList`1<IParameter> get_Parameters();
    private IParameter get_Parameter();
    [CompilerGeneratedAttribute]
public virtual IType get_ReturnType();
    [CompilerGeneratedAttribute]
public virtual ReferenceKind get_ReturnKind();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual string ToString();
    private bool Equals(CSharpByIndexIndexer other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpByRangeIndexer : SpecialIndexer {
    [NotNullAttribute]
private PredefinedType myPredefinedType;
    [NotNullAttribute]
private IType myOwnerType;
    [CompilerGeneratedAttribute]
private IMethod <SliceMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty <LengthProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <ReturnKind>k__BackingField;
    [CanBeNullAttribute]
public IMethod SliceMethod { get; }
    [CanBeNullAttribute]
public IProperty LengthProperty { get; }
    public bool IsWritable { get; }
    public IPsiModule Module { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public CSharpByRangeIndexer(PredefinedType predefinedTypesOfUsageContext, IType ownerType, IType returnType, ReferenceKind returnKind);
    public CSharpByRangeIndexer(PredefinedType predefinedTypesOfUsageContext, IDeclaredType ownerType, IMethod sliceMethod, IProperty lengthProperty);
    [CompilerGeneratedAttribute]
public IMethod get_SliceMethod();
    [CompilerGeneratedAttribute]
public IProperty get_LengthProperty();
    public virtual bool get_IsWritable();
    public virtual AccessRights GetAccessRights();
    public virtual IPsiServices GetPsiServices();
    public virtual bool IsValid();
    public virtual IPsiModule get_Module();
    public virtual ITypeElement GetContainingType();
    public virtual ITypeMember GetContainingTypeMember();
    public virtual IList`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public virtual IType get_ReturnType();
    [CompilerGeneratedAttribute]
public virtual ReferenceKind get_ReturnKind();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual string ToString();
    private bool Equals(CSharpByRangeIndexer other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpConstant : CSharpTypeMember`1<ConstantDeclaration> {
    private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    [ThreadStaticAttribute]
private static JetHashSet`1<CSharpConstant> ourConstantCalculationsInProgress;
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public ConstantValue ConstantValue { get; }
    public IType Type { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public CSharpConstant(ConstantDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual IType get_Type();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    protected virtual bool IsOurAttributeTarget(AttributeTarget target);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpConstructor : CSharpTypeMember`1<ConstructorDeclaration> {
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsIterator { get; }
    public bool IsDefault { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public bool IsParameterless { get; }
    public bool IsOverride { get; }
    public CSharpConstructor(ConstructorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsValueTypeZeroInit();
    public sealed virtual bool get_IsParameterless();
    public virtual bool get_IsOverride();
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    public virtual string ToString();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpConversionOperator : CSharpOperator`1<ConversionOperatorDeclaration> {
    public bool IsExplicitCast { get; }
    public bool IsImplicitCast { get; }
    public CSharpConversionOperator(ConversionOperatorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsExplicitCast();
    public sealed virtual bool get_IsImplicitCast();
    public virtual string ToString();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpDeclaredElement`1 : CachedTypeMemberBase {
    [NotNullAttribute]
public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    protected CSharpDeclaredElement`1(TDeclaration declaration);
    [CanBeNullAttribute]
public TDeclaration GetDeclaration();
    protected virtual bool CanBindTo(IDeclaration declaration);
    public virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public abstract virtual DeclaredElementType GetElementType();
    public virtual bool IsSynthetic();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpDestructor : CSharpOverridableMember`1<DestructorDeclaration> {
    public bool IsExtensionMethod { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    public bool IsVarArg { get; }
    public IList`1<IParameter> Parameters { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsOverride { get; }
    public CSharpDestructor(DestructorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    public virtual bool get_IsOverride();
    protected virtual IOwnerQualification GetOwnerQualificationNode();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpEnumMember : CSharpTypeMember`1<EnumMemberDeclaration> {
    [NotNullAttribute]
private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    [ThreadStaticAttribute]
private static HashSet`1<CSharpEnumMember> ourConstantCalculationsInProgress;
    public IType Type { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    internal bool IsConstantValueCalculated { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public CSharpEnumMember(EnumMemberDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IType get_Type();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    internal bool get_IsConstantValueCalculated();
    public sealed virtual ConstantValue get_ConstantValue();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    public virtual AccessRights GetAccessRights();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpEvent : CSharpOverridableMember`1<EventDeclaration> {
    [CanBeNullAttribute]
private IAccessor myImplicitAdder;
    [CanBeNullAttribute]
private IAccessor myImplicitRemover;
    private bool myIsFieldLikeEvent;
    public IType Type { get; }
    public IAccessor Adder { get; }
    public IAccessor Remover { get; }
    public IAccessor Raiser { get; }
    public bool IsFieldLikeEvent { get; }
    public CSharpEvent(EventDeclaration declaration);
    protected virtual bool CanBindTo(IDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    protected virtual IOwnerQualification GetOwnerQualificationNode();
    public sealed virtual IType get_Type();
    public sealed virtual IAccessor get_Adder();
    public sealed virtual IAccessor get_Remover();
    public sealed virtual IAccessor get_Raiser();
    public sealed virtual bool get_IsFieldLikeEvent();
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    [NotNullAttribute]
internal IList`1<IAttributeInstance> GetFieldAttributeInstances();
    [PureAttribute]
internal bool HasFieldAttributeInstance(IClrTypeName clrName);
    [NotNullAttribute]
private IList`1<IAttribute> GetFieldAttributes();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
    [CompilerGeneratedAttribute]
private bool <.ctor>g__HasImplicitAccessors|3_0(<>c__DisplayClass3_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpField : CSharpTypeMember`1<FieldDeclaration> {
    public ConstantValue ConstantValue { get; }
    public IType Type { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsRequired { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public CSharpField(FieldDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual IType get_Type();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual bool get_IsRequired();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpGlobalUsingAlias : object {
    private IPsiModule myPsiModule;
    private CSharpGlobalAliasPart myParts;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    public bool HasParts { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsGlobal { get; }
    public bool IsNamespaceOrRegularDeclaredTypeAlias { get; }
    public AliasedSymbol AliasedSymbol { get; }
    public string ExternAliasName { get; }
    public CSharpGlobalUsingAlias(string aliasName, IPsiModule psiModule);
    public void AddPart(IPsiSourceFile psiSourceFile);
    public void RemoveParts(IPsiSourceFile sourceFile);
    public bool get_HasParts();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual HybridCollection`1<IUsingAliasDirective> GetDeclarations();
    private sealed virtual override IList`1<IDeclaration> JetBrains.ReSharper.Psi.IDeclaredElement.GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    private void CollectAllDeclarations(LocalList`1& declarations);
    private void CollectDeclarationsInFile(LocalList`1& declarations, IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public void MergePartsFrom(CSharpGlobalUsingAlias symbolAlias);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual bool get_IsGlobal();
    public sealed virtual bool get_IsNamespaceOrRegularDeclaredTypeAlias();
    public sealed virtual AliasedSymbol get_AliasedSymbol();
    public sealed virtual string get_ExternAliasName();
    public bool IsAccessableFrom(ITreeNode context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ISymbolAlias CreateInstance(UsingAliasDirective usingAliasDirective);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpIndexer : CSharpPropertyBase`1<IndexerDeclaration> {
    public string ShortName { get; }
    public bool IsAuto { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public IType Type { get; }
    public IList`1<IParameter> Parameters { get; }
    public CSharpIndexer(IndexerDeclaration declaration);
    public virtual string get_ShortName();
    public virtual bool get_IsAuto();
    public virtual bool get_IsDefault();
    public virtual bool get_IsRequired();
    public virtual string GetDefaultPropertyMetadataName();
    public virtual IType get_Type();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpMethod : CSharpOverridableMember`1<MethodDeclaration> {
    private int myHashCode;
    private MethodFlags myFlags;
    public IList`1<IParameter> Parameters { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsExtensionMethod { get; }
    public bool IsVarArg { get; }
    public bool IsPartial { get; }
    public bool IsPartialWithAccessRights { get; }
    public CSharpMethod(MethodDeclaration declaration);
    protected virtual bool CanBindTo(IDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsync();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    protected virtual IOwnerQualification GetOwnerQualificationNode();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public virtual ISubstitution get_IdSubstitution();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsVarArg();
    public bool get_IsPartial();
    public bool get_IsPartialWithAccessRights();
    public virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    [NotNullAttribute]
private IList`1<IDeclaration> GetPartialDeclarations(IPsiSourceFile sourceFile);
    public virtual IList`1<IDeclaration> GetDeclarations();
    public virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    protected virtual IList`1<IAttribute> GetOurAttributes();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Nullable`1<Hash> CalcHash();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
    [CompilerGeneratedAttribute]
internal static bool <CalcHash>g__IsMemberWithBodyOrExternMethod|44_0(IDeclaration declaration);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpOperator`1 : CSharpOverridableMember`1<TOperatorDeclaration> {
    public bool IsIterator { get; }
    public bool IsChecked { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IList`1<IParameter> Parameters { get; }
    protected CSharpOperator`1(TOperatorDeclaration declaration);
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsChecked();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    protected virtual IOwnerQualification GetOwnerQualificationNode();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpOverridableMember`1 : CSharpTypeMember`1<TTypeMemberDeclaration> {
    private bool myRetrievingInheritedXMLDoc;
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    protected CSharpOverridableMember`1(TTypeMemberDeclaration declaration);
    [CanBeNullAttribute]
protected abstract virtual IOwnerQualification GetOwnerQualificationNode();
    public virtual bool get_IsExplicitImplementation();
    public virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual XmlNode GetXMLDoc(bool inherit);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpParameterBase`1 : CSharpDeclaredElement`1<TParameterDeclaration> {
    public ISubstitution IdSubstitution { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public bool IsValueVariable { get; }
    public IType Type { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    protected CSharpParameterBase`1(TParameterDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual bool get_IsValueVariable();
    [NotNullAttribute]
protected abstract virtual IList`1<IAttribute> GetOurAttributes();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public abstract virtual IType get_Type();
    public abstract virtual ParameterKind get_Kind();
    public abstract virtual bool get_IsParams();
    public abstract virtual bool get_IsParameterArray();
    public abstract virtual bool get_IsParameterCollection();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsVarArg();
    public abstract virtual DefaultValue GetDefaultValue();
    public abstract virtual ScopedKind get_Scope();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpPrimaryConstructor : CSharpDeclaredElement`1<PrimaryConstructorDeclaration> {
    public bool IsDefault { get; }
    public bool IsParameterless { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public CSharpPrimaryConstructor(PrimaryConstructorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsParameterless();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsValueTypeZeroInit();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    [NotNullAttribute]
private IList`1<IAttribute> GetConstructorAttributes();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpProperty : CSharpPropertyBase`1<PropertyDeclaration> {
    public IType Type { get; }
    public IList`1<IParameter> Parameters { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public bool IsAuto { get; }
    public bool HasBackingFieldReference { get; }
    public MemberHidePolicy HidePolicy { get; }
    public CSharpProperty(PropertyDeclaration declaration);
    public virtual IType get_Type();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual bool get_IsDefault();
    public virtual bool get_IsRequired();
    public virtual string GetDefaultPropertyMetadataName();
    public virtual bool get_IsAuto();
    public sealed virtual bool get_HasBackingFieldReference();
    public virtual MemberHidePolicy get_HidePolicy();
    [NotNullAttribute]
internal IList`1<IAttributeInstance> GetFieldAttributeInstances();
    [PureAttribute]
internal bool HasFieldAttributeInstance(IClrTypeName clrName);
    [NotNullAttribute]
private IList`1<IAttribute> GetFieldAttributes();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpPropertyBase`1 : CSharpOverridableMember`1<TDeclaration> {
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType Type { get; }
    public IAccessor Getter { get; }
    public IAccessor Setter { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsAuto { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public string XMLDocId { get; }
    protected CSharpPropertyBase`1(TDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    protected virtual IOwnerQualification GetOwnerQualificationNode();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public abstract virtual IList`1<IParameter> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public abstract virtual IType get_Type();
    public sealed virtual IAccessor get_Getter();
    public sealed virtual IAccessor get_Setter();
    public sealed virtual bool get_IsReadable();
    public sealed virtual bool get_IsWritable();
    public abstract virtual bool get_IsAuto();
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool get_IsRequired();
    public abstract virtual string GetDefaultPropertyMetadataName();
    protected virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    public virtual string get_XMLDocId();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpRegularParameter : CSharpParameterBase`1<TypeMemberRegularParameterDeclaration> {
    public IType Type { get; }
    public ParameterKind Kind { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public CSharpRegularParameter(TypeMemberRegularParameterDeclaration declaration);
    protected virtual IList`1<IAttribute> GetOurAttributes();
    [NotNullAttribute]
internal IList`1<IAttributeInstance> GetPropertyAttributeInstances();
    [PureAttribute]
internal bool HasPropertyAttributeInstance(IClrTypeName clrName);
    [NotNullAttribute]
internal IList`1<IAttributeInstance> GetFieldAttributeInstances();
    [PureAttribute]
internal bool HasFieldAttributeInstance(IClrTypeName clrName);
    [NotNullAttribute]
private IList`1<IAttribute> GetImplicitUnderlyingElementAttributes(AttributeTarget attributeTarget);
    private static void CollectParameterAttributes(ITypeMemberRegularParameterDeclaration parameterDeclaration, LocalList`1& attributes);
    private static void CollectAttributesFromPartialParameters(IMethodDeclaration partialMethodDeclaration, ITypeMemberRegularParameterDeclaration parameterDeclaration, LocalList`1& attributes);
    public virtual IType get_Type();
    public virtual ParameterKind get_Kind();
    public virtual bool get_IsOptional();
    public virtual bool get_IsVarArg();
    public virtual DefaultValue GetDefaultValue();
    public virtual ScopedKind get_Scope();
    public virtual bool get_IsParams();
    public virtual bool get_IsParameterArray();
    public virtual bool get_IsParameterCollection();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpSignOperator : CSharpOperator`1<SignOperatorDeclaration> {
    public CSharpSignOperator(SignOperatorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public virtual string ToString();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpTopLevelEntryPointParameter : object {
    [NotNullAttribute]
private ITopLevelCode myTopLevelCode;
    public IType Type { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public bool IsValueVariable { get; }
    public CSharpTopLevelEntryPointParameter(ITopLevelCode topLevelCode);
    public sealed virtual IType get_Type();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual bool get_IsValueVariable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpTypeMember`1 : CSharpDeclaredElement`1<TDeclaration> {
    public bool IsPredefined { get; }
    [NotNullAttribute]
public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsSealed { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public ISubstitution IdSubstitution { get; }
    public string XMLDocId { get; }
    protected CSharpTypeMember`1(TDeclaration declaration);
    public sealed virtual bool get_IsPredefined();
    protected abstract virtual bool IsOurAttributeTarget(AttributeTarget attributeTarget);
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    [NotNullAttribute]
protected virtual IList`1<IAttribute> GetOurAttributes();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual AccessRights GetAccessRights();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsSealed();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public virtual MemberHidePolicy get_HidePolicy();
    public virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public virtual string get_XMLDocId();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpTypeParameterOfMethod : CSharpDeclaredElement`1<TypeParameterOfMethodDeclaration> {
    [ThreadStaticAttribute]
[CanBeNullAttribute]
[ItemNotNullAttribute]
private static JetHashSet`1<CSharpTypeParameterOfMethod> ourComputing;
    public ITypeParametersOwner Owner { get; }
    public ITypeElement OwnerType { get; }
    public IParametersOwner OwnerFunction { get; }
    public IMethod OwnerMethod { get; }
    public IMethodDeclaration MethodDeclaration { get; }
    public int Index { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public TypeParameterVariance Variance { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsUnmanagedType { get; }
    public bool HasDefaultConstructor { get; }
    public bool IsNotNullableValueOrReferenceType { get; }
    public bool AllowsByRefLikeType { get; }
    public TypeParameterNullability Nullability { get; }
    public bool HasTypeConstraints { get; }
    public IList`1<IType> TypeConstraints { get; }
    public TypeParameterConstraintFlags Constraints { get; }
    public TypeParameterConstraintFlags OwnConstraints { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public CSharpTypeParameterOfMethod(TypeParameterOfMethodDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeParametersOwner get_Owner();
    public sealed virtual ITypeElement get_OwnerType();
    public sealed virtual IParametersOwner get_OwnerFunction();
    public sealed virtual IMethod get_OwnerMethod();
    public sealed virtual IMethodDeclaration get_MethodDeclaration();
    public sealed virtual int get_Index();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    [CanBeNullAttribute]
private static XmlNode GetTypeParameterSummary(IMethod method, int index);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsUnmanagedType();
    public sealed virtual bool get_HasDefaultConstructor();
    public sealed virtual bool get_IsNotNullableValueOrReferenceType();
    public sealed virtual bool get_AllowsByRefLikeType();
    public sealed virtual TypeParameterNullability get_Nullability();
    public sealed virtual TypeParameterNullability GetNullability(ISubstitution explicitInheritorSubstitution);
    public sealed virtual bool get_HasTypeConstraints();
    public sealed virtual IList`1<IType> get_TypeConstraints();
    public sealed virtual TypeParameterConstraintFlags get_Constraints();
    public sealed virtual TypeParameterConstraintFlags get_OwnConstraints();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [PureAttribute]
[ItemNotNullAttribute]
private TreeNodeEnumerable`1<ITypeParameterConstraint> EnumerateAllConstraints();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.CSharpTypeParameterOfMethod/<EnumerateSuperTypes>d__81")]
[PureAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<IType> EnumerateSuperTypes();
    [CanBeNullAttribute]
[PureAttribute]
private DeclaredElementInstance`1<ITypeParameter> FindInheritedTypeParameter();
    private T ExecuteWithRecursionGuard(RefAction`1<T> execute);
    private static void ExecuteWithRecursionGuard(RefAction`1<T> execute, CSharpTypeParameterOfMethod self, T& state);
    private sealed virtual override IPsiSourceFile JetBrains.ReSharper.Psi.ITypeElement.GetSingleOrDefaultSourceFile();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
    [CompilerGeneratedAttribute]
internal static bool <get_Constraints>g__ShouldInspectInheritedTypeParameter|75_1(TypeParameterConstraintFlags flags, <>c__DisplayClass75_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.TypeParameterOfLocalFunction : object {
    private WeakReference`1<ITypeParameterOfLocalFunctionDeclaration> myWeakDeclaration;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    public ITypeParameterOfLocalFunctionDeclaration WeakDeclaration { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public int Index { get; }
    public TypeParameterVariance Variance { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool HasDefaultConstructor { get; }
    public bool IsUnmanagedType { get; }
    public bool IsNotNullableValueOrReferenceType { get; }
    public bool AllowsByRefLikeType { get; }
    public TypeParameterNullability Nullability { get; }
    public bool HasTypeConstraints { get; }
    public IList`1<IType> TypeConstraints { get; }
    public TypeParameterConstraintFlags Constraints { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public ITypeParametersOwner Owner { get; }
    public ITypeElement OwnerType { get; }
    public IParametersOwner OwnerFunction { get; }
    public IMethod OwnerMethod { get; }
    public TypeParameterOfLocalFunction(ITypeParameterOfLocalFunctionDeclaration typeParameterOfLocalFunctionDeclaration);
    private IPsiSourceFile GetSourceFile();
    public ITypeParameterOfLocalFunctionDeclaration get_WeakDeclaration();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public sealed virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    public sealed virtual int get_Index();
    public sealed virtual TypeParameterVariance get_Variance();
    [PureAttribute]
[ItemNotNullAttribute]
private TreeNodeEnumerable`1<ITypeParameterConstraint> EnumerateAllConstraints();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_HasDefaultConstructor();
    public sealed virtual bool get_IsUnmanagedType();
    public sealed virtual bool get_IsNotNullableValueOrReferenceType();
    public sealed virtual bool get_AllowsByRefLikeType();
    public sealed virtual TypeParameterNullability get_Nullability();
    public sealed virtual TypeParameterNullability GetNullability(ISubstitution explicitInheritorSubstitution);
    public sealed virtual bool get_HasTypeConstraints();
    public sealed virtual IList`1<IType> get_TypeConstraints();
    public sealed virtual TypeParameterConstraintFlags get_Constraints();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual ITypeParametersOwner get_Owner();
    public sealed virtual ITypeElement get_OwnerType();
    public sealed virtual IParametersOwner get_OwnerFunction();
    public sealed virtual IMethod get_OwnerMethod();
    public virtual string ToString();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredElement.TypeParameterOfLocalFunction/<EnumerateSuperTypes>d__98")]
[PureAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<IType> EnumerateSuperTypes();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DeclaredTypeFromReferenceName : DeclaredTypeBase {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IPsiModule myPsiModule;
    [NotNullAttribute]
private IResolveResult myResolveResult;
    [CanBeNullAttribute]
private string myUnresolvedPresentation;
    [CanBeNullAttribute]
private IList`1<IType> myUnresolvedPresentationTypeArgs;
    [DebuggerBrowsableAttribute("0")]
public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public TypeClassification Classify { get; }
    public DeclaredTypeFromReferenceName(IReferenceName referenceName, IResolveResult result);
    public DeclaredTypeFromReferenceName(IReferenceExpression referenceExpression, IResolveResult result);
    public virtual IPsiModule get_Module();
    public virtual TypeDecorationSet get_TypeDecorations();
    public virtual IPsiServices GetPsiServices();
    protected virtual IResolveResult ResolveNoRetargeting();
    public virtual bool IsValid();
    protected virtual ITypeElement GetTypeElement(IModuleReferenceResolveContext resolveContext);
    protected virtual ITypeElement GetTypeElementNoRetargeting();
    protected virtual IResolveResult Resolve(IModuleReferenceResolveContext resolveContext);
    public virtual TypeClassification get_Classify();
    protected virtual RichText GetUnresolvedPresentation(NullableAnnotation nullableAnnotation, ITypePresenter presenter, TypePresentationStyle typePresentationStyle);
    private sealed virtual override string JetBrains.ReSharper.Psi.Impl.Types.ISimplifiedIdTypeInfo.GetShortName();
    private sealed virtual override IType[] JetBrains.ReSharper.Psi.Impl.Types.ISimplifiedIdTypeInfo.GetTypeArguments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DefaultConstructorInCollectionExpressionSearcher : ImplicitConstructorUsageSearcherBase {
    private CollectionExpressionCache myCollectionExpressionCache;
    public DefaultConstructorInCollectionExpressionSearcher(IDomainSpecificSearcherFactory searchWordsProvider, CollectionExpressionCache collectionExpressionCache, GlobalUsingsCache globalUsingsCache, ImplicitObjectCreationSearcherParameters parameters);
    public sealed virtual ValueTuple`2<IDomainSpecificSearcher, ISearchDomain> TryCreateSecondPhaseInfo(SearchDomainFactory searchDomainFactory, ISearchDomain originalSearchDomain, HashSet`1<IPsiSourceFile> processedFiles);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    [PureAttribute]
private ISearchDomain CreateAdditionalSearchDomain(SearchDomainFactory searchDomainFactory, ISearchDomain originalSearchDomain, HashSet`1<IPsiSourceFile> processedFiles);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ProcessElement>g__ShouldProcessCollectionExpression|4_0(ICollectionExpression collectionExpression, <>c__DisplayClass4_0`1& );
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DelegateEqualityOperator : PredefinedOperator {
    [NotNullAttribute]
private PredefinedType myPredefinedType;
    public DelegateEqualityOperator(PredefinedType predefined, string name);
    private static bool NonApplicableTypes(IEnumerable`1<IExpressionType> argumentTypes);
    public sealed virtual ApplicableCandidate IsApplicable(IResolveContext resolveContext, ISubstitution substitution, IList`1<ICSharpArgumentInfo> arguments, IList`1<IExpressionType> argumentTypes, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, IPsiModule module, CandidateWithResolveContext& candidate);
    public sealed virtual bool IsApplicable(ISubstitution substitution, IList`1<IExpressionType> argumentTypes, IPsiModule module);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DelegatePredefinedOperator : PredefinedOperator {
    [CompilerGeneratedAttribute]
private IDelegate <Delegate>k__BackingField;
    public IDelegate Delegate { get; }
    public DelegatePredefinedOperator(IDelegate delegate, string name, IType type, int parameterNumber);
    public DelegatePredefinedOperator(IDelegate delegate, string name, IType returnType, IType[] parameterTypes);
    [CompilerGeneratedAttribute]
public IDelegate get_Delegate();
}
[PolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Dependencies.CSharpUsingsInfo : object {
    private string myFileName;
    private string myHeadText;
    private string myTailText;
    private string myText;
    private List`1<string> myShortNames;
    [UsedImplicitlyAttribute]
public static ReadDelegate`1<object> ReadDelegate;
    [UsedImplicitlyAttribute]
public static WriteDelegate`1<object> WriteDelegate;
    private string Text { get; }
    public List`1<string> ShortNames { get; public set; }
    public string FileName { get; }
    public CSharpUsingsInfo(string fileName);
    private static CSharpUsingsInfo();
    public static CSharpUsingsInfo Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, CSharpUsingsInfo info);
    public void AddUsings(ICSharpTypeAndNamespaceHolderDeclaration holder);
    public void AddNamespaceDeclaration(ICSharpNamespaceDeclaration namespaceDeclaration);
    public CSharpUsingsInfo Clone();
    public virtual int GetHashCode();
    private string get_Text();
    public virtual bool Equals(object obj);
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual List`1<string> get_ShortNames();
    public sealed virtual void set_ShortNames(List`1<string> value);
    public sealed virtual Hash GetHash();
    public sealed virtual string get_FileName();
    public virtual string ToString();
    public sealed virtual void TestDump(TextWriter builder);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.BaseCSharpDocCommentReference : UserDataHolder {
    private ICommentNode myCommentNode;
    private TreeTextRange myLocalRange;
    private CachedPsiValue`1<ResolveResultWithInfo> myResolveCache;
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    public ICommentNode CommentNode { get; public set; }
    public bool HasMultipleNames { get; }
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    public string TagName { get; }
    public TreeOffset LocalOffset { get; public set; }
    public TreeTextRange LocalRange { get; public set; }
    protected DocCommentBlock DocCommentBlock { get; }
    protected BaseCSharpDocCommentReference(ICommentNode commentNode, TreeTextRange range, string tagName);
    public sealed virtual ICommentNode get_CommentNode();
    public sealed virtual void set_CommentNode(ICommentNode value);
    public sealed virtual ITreeNode GetTreeNode();
    public virtual string GetName();
    public sealed virtual bool get_HasMultipleNames();
    public sealed virtual HybridCollection`1<string> GetAllNames();
    public sealed virtual TreeTextRange GetTreeTextRange();
    public DocumentRange GetDocumentRange();
    public sealed virtual bool IsValid();
    public sealed virtual ResolveResultWithInfo get_CurrentResolveResult();
    public sealed virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    public sealed virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual TreeTextRange GetSignatureRange();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TagName();
    public sealed virtual TreeOffset get_LocalOffset();
    public sealed virtual void set_LocalOffset(TreeOffset value);
    public TreeTextRange get_LocalRange();
    public void set_LocalRange(TreeTextRange value);
    protected DocCommentBlock get_DocCommentBlock();
    public abstract virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public abstract virtual ResolveResultWithInfo Resolve();
    public abstract virtual IReference BindTo(IDeclaredElement element);
    public abstract virtual IAccessContext GetAccessContext();
    public abstract virtual ISymbolTable GetCompletionSymbolTable();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.CompiledReference : BaseCSharpDocCommentReference {
    public CompiledReference(ICommentNode commentNode, TreeTextRange localRange, string tagName);
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual ResolveResultWithInfo Resolve();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IAccessContext GetAccessContext();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
    public virtual ISymbolTable GetCompletionSymbolTable();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.CSharpDocCommentElementFactory : ClrDocCommentElementFactoryImpl {
    protected Key`1<object> XmlResolveKey { get; }
    public CSharpDocCommentElementFactory(IDocCommentXmlPsi xmlPsi);
    protected virtual Key`1<object> get_XmlResolveKey();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.CSharpDocCommentXmlPsi : ClrDocCommentXmlPsi`1<ICSharpDocCommentBlock> {
    [NotNullAttribute]
public static Key`1<object> XmlResolveKey;
    private CSharpDocCommentXmlPsi(InjectedPsiHolderNode docCommentsHolder, ICSharpDocCommentBlock docCommentBlock, IXmlFile xmlFile, bool isShifted);
    private static CSharpDocCommentXmlPsi();
    [NotNullAttribute]
public static CSharpDocCommentXmlPsi BuildPsi(DocCommentBlock block);
    [NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<string> GetCommentLines(DocCommentBlock block);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.CSharpDocCommentXmlPsi/<CommentNodeToLines>d__4")]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
private static IEnumerable`1<string> CommentNodeToLines(ICSharpCommentNode commentNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.CSharpDocCommentXmlPsi/<GetMultilineCommentLinesStartOffsets>d__5")]
[PureAttribute]
[NotNullAttribute]
private static IEnumerable`1<int> GetMultilineCommentLinesStartOffsets(ICSharpCommentNode commentNode, bool isShifted);
    [CanBeNullAttribute]
[PureAttribute]
private static string GetCommonLinesIndent(String[] multilineDocCommentLines);
    protected virtual IReadOnlyList`1<ITreeNode> GetDocCommentNodes();
    protected virtual string GetDocCommentStartText(ITreeNode commentNode);
    protected virtual IEnumerable`1<int> GetCommentLinesStartOffsets(ITreeNode commentNode);
    public virtual void SubTreeChanged();
    [CompilerGeneratedAttribute]
internal static string <GetCommonLinesIndent>g__GetStartIndent|6_0(string line);
    [CompilerGeneratedAttribute]
private void <SubTreeChanged>g__CreateMultilineDocComment|10_1(<>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
private string <SubTreeChanged>g__GetIndentText|10_3();
    [CompilerGeneratedAttribute]
private void <SubTreeChanged>g__CreateDocCommentPerLine|10_2(<>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
private bool <SubTreeChanged>g__UseMultilineComment|10_0();
}
[LanguageDefinitionAttribute("CSHARP_XMLDOC")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.CSharpXmlDocLanguage : XmlDocLanguage {
    public static string Name;
    [CompilerGeneratedAttribute]
private static CSharpXmlDocLanguage <Instance>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static CSharpXmlDocLanguage Instance { get; private set; }
    [CompilerGeneratedAttribute]
public static CSharpXmlDocLanguage get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(CSharpXmlDocLanguage value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.DocCommentBlockNodeType : CSharpCompositeNodeType {
    public static int NODE_TYPE_INDEX;
    public static CompositeNodeType Instance;
    private static DocCommentBlockNodeType();
    public virtual CompositeElement Create();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.ParameterReference : BaseCSharpDocCommentReference {
    public ParameterReference(ICommentNode commentNode, TreeTextRange localRange, string tagName);
    [NotNullAttribute]
private IList`1<IParameter> GetAvailableParameters();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual ResolveResultWithInfo Resolve();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IAccessContext GetAccessContext();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public virtual ISymbolTable GetCompletionSymbolTable();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.ReplaceCRefAction : object {
    private DocCommentBlock myAffectedElement;
    private ITreeNode myOldNode;
    private ITreeNode myNewNode;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public ReplaceCRefAction(DocCommentBlock affectedElement, ITreeNode oldNode, ITreeNode newNode);
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual void RollBack();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.TypeParameterReference : BaseCSharpDocCommentReference {
    public TypeParameterReference(ICommentNode commentNode, TreeTextRange localRange, string tagName);
    private IList`1<ITypeParameter> GetTypeParameters();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual ResolveResultWithInfo Resolve();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IAccessContext GetAccessContext();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public virtual ISymbolTable GetCompletionSymbolTable();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.XmlDocLexer : object {
    private DocCommentBlock myDocCommentBlock;
    public XmlTokenTypes XmlTokenTypes;
    private XmlLexerGenerated myLexer;
    private IDocCommentNode myCurrentCommentNode;
    public IDocCommentNode CurrentCommentNode { get; }
    public object CurrentPosition { get; public set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    public XmlDocLexer(DocCommentBlock docCommentBlock);
    private void RestartLexer(ITreeNode child, UInt32 state);
    public IDocCommentNode get_CurrentCommentNode();
    public sealed virtual void Start();
    public sealed virtual void Advance();
    public sealed virtual object get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(object value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.DocComments.XmlDocParser : XmlDocParser {
    private XmlDocLexer myLexer;
    private DocCommentBlock myOwner;
    public XmlDocParser(DocCommentBlock owner, XmlDocLexer lexer);
    protected virtual void VisitCRef(string tagName);
    protected virtual void VisitTypeParamReference(string tagName);
    protected virtual void VisitParamReference(string tagName);
    private void VisitParamOrTypeParamRef(string tagName);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.EditorConfigIsGeneratedCodeProperty : object {
    private static string PropertyName;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private PersistentProjectItemProperties myPersistentProjectItemProperties;
    [NotNullAttribute]
private ISettingsStore mySettingsStore;
    [NotNullAttribute]
private IPsiFilesCache myPsiFilesCache;
    [NotNullAttribute]
private IConfigFileCache myConfigFileCache;
    [NotNullAttribute]
private IWordIndex myWordIndex;
    [NotNullAttribute]
private AsyncItemsProcessor`1<Action> myUpdateProjectFileProcessor;
    public EditorConfigIsGeneratedCodeProperty(ISolution solution, IShellLocks locks, ILogger logger, PersistentProjectItemProperties persistentProjectItemProperties, ISettingsStore settingsStore, IPsiFilesCache psiFilesCache, IConfigFileCache configFileCache, IWordIndex wordIndex, ISolutionLoadTasksScheduler solutionLoadTasksScheduler);
    private void OnEditorConfigFileChange(VirtualFileSystemPath configFilePath);
    [PureAttribute]
private bool CanContainGeneratedCodeProperty(VirtualFileSystemPath configFilePath);
    [PureAttribute]
public bool IsGenerated(IProjectFile projectFile);
    [PureAttribute]
private bool GetEditorConfigProperty(IProjectFile projectFile);
    public static void InvalidateNullableContextCacheIfSettingsChanged(ICSharpFile csharpFile);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(VirtualFileSystemPath configFilePath);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.ExternAliases.ExternAlias : object {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    public string ShortName { get; }
    public bool IsGlobal { get; }
    public bool CaseSensitiveName { get; }
    public ISubstitution IdSubstitution { get; }
    public IPsiModule Module { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public ExternAlias(IPsiModule psiModule, string name);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public sealed virtual bool get_IsGlobal();
    public bool Equals(ExternAlias obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ISubstitution get_IdSubstitution();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ExternAliasUtil : object {
    [NotNullAttribute]
public static IExternAliasDirective AddExternAliasAfter(ICSharpTypeAndNamespaceHolderDeclaration scope, IExternAliasDirective externAliasDirective, IExternAliasDirective anchor);
    [NotNullAttribute]
public static IExternAliasDirective AddExternAliasBefore(ICSharpTypeAndNamespaceHolderDeclaration scope, IExternAliasDirective externAliasDirective, IExternAliasDirective anchor);
    public static void RemoveExternAlias(ICSharpTypeAndNamespaceHolderDeclaration scope, IExternAliasDirective externAlias);
    [NotNullAttribute]
public static IExternAliasDirective EnsureHasExternAlias(ICSharpTypeAndNamespaceHolderDeclaration scope, string externAlias);
    [CanBeNullAttribute]
public static string GetExternAlias(IReferenceName referenceName);
    [CanBeNullAttribute]
public static string GetExternAlias(IReferenceExpression referenceExpression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.IImplicitConversionSearcherProvider {
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<ImplicitConversionSourceInfo> GetImplicitConversions(ITreeNode treeNode, bool onlyUserDefinedConversions, bool processInnerTreeNodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.ImplicitConstructorUsageSearcherBase : object {
    protected IDomainSpecificSearcherFactory mySearchWordsProvider;
    protected GlobalUsingsCache myGlobalUsingsCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected HashSet`1<string> myPossibleNames;
    protected ImplicitObjectCreationSearcherParameters myParameters;
    protected ImplicitConstructorUsageSearcherBase(IDomainSpecificSearcherFactory searchWordsProvider, GlobalUsingsCache globalUsingsCache, ImplicitObjectCreationSearcherParameters parameters);
    protected void ProcessConstructorReferences(ITreeNode element, IFindResultConsumer`1<TResult> consumer, IReadOnlyList`1<IReference> references);
    protected String[] TryGetPossibleAliasesInFile(ITreeNode element);
    [CompilerGeneratedAttribute]
private FindExecution <ProcessConstructorReferences>g__Process|5_0(IReference reference, IDeclaredElement declaredElement, <>c__DisplayClass5_0`1& );
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ImplicitConversionSourceInfo : ValueType {
    [CompilerGeneratedAttribute]
private TypeConversionInfo <TypeConversionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <ContainingTreeNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <ConversionSourceExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionType <BaseConversionSourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <BaseConversionTargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInnerConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNestedConversions>k__BackingField;
    public TypeConversionInfo TypeConversionInfo { get; }
    [NotNullAttribute]
public ITreeNode ContainingTreeNode { get; }
    [NotNullAttribute]
public IExpression ConversionSourceExpression { get; }
    [CanBeNullAttribute]
public IExpressionType BaseConversionSourceType { get; }
    [CanBeNullAttribute]
public IType BaseConversionTargetType { get; }
    public bool IsInnerConversion { get; }
    public bool HasNestedConversions { get; }
    public ImplicitConversionSourceInfo(TypeConversionInfo typeConversionInfo, ITreeNode containingTreeNode, IExpression conversionSourceExpression, IExpressionType baseConversionSourceType, IType baseConversionTargetType, bool isInnerConversion, bool hasNestedConversions);
    [CompilerGeneratedAttribute]
public TypeConversionInfo get_TypeConversionInfo();
    [CompilerGeneratedAttribute]
public ITreeNode get_ContainingTreeNode();
    [CompilerGeneratedAttribute]
public IExpression get_ConversionSourceExpression();
    [CompilerGeneratedAttribute]
public IExpressionType get_BaseConversionSourceType();
    [CompilerGeneratedAttribute]
public IType get_BaseConversionTargetType();
    [CompilerGeneratedAttribute]
public bool get_IsInnerConversion();
    [CompilerGeneratedAttribute]
public bool get_HasNestedConversions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[RequiredMemberAttribute]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ImplicitObjectCreationSearcherParameters : ValueType {
    [CompilerGeneratedAttribute]
private HashSet`1<IConstructor> <Constructors>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ITypeElement> <TypeElements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindCandidates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRunningOnFilesContainingTypeName>k__BackingField;
    [RequiredMemberAttribute]
public HashSet`1<IConstructor> Constructors { get; public set; }
    [RequiredMemberAttribute]
public HashSet`1<ITypeElement> TypeElements { get; public set; }
    [RequiredMemberAttribute]
public bool FindCandidates { get; public set; }
    [RequiredMemberAttribute]
public bool IsRunningOnFilesContainingTypeName { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<IConstructor> get_Constructors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Constructors(HashSet`1<IConstructor> value);
    [CompilerGeneratedAttribute]
public HashSet`1<ITypeElement> get_TypeElements();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeElements(HashSet`1<ITypeElement> value);
    [CompilerGeneratedAttribute]
public bool get_FindCandidates();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FindCandidates(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRunningOnFilesContainingTypeName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsRunningOnFilesContainingTypeName(bool value);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.InterpolatedStringConcatenationOperator : PredefinedOperator {
    public InterpolatedStringConcatenationOperator(IPsiModule module);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.LiftedOperator : object {
    [NotNullAttribute]
private ISignOperator myOperator;
    [CanBeNullAttribute]
private IParameter[] myParameters;
    [CanBeNullAttribute]
private IType myReturnType;
    [NotNullAttribute]
public ISignOperator BaseOperator { get; }
    public IList`1<IParameter> Parameters { get; }
    public bool IsChecked { get; }
    public ISubstitution IdSubstitution { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsIterator { get; }
    public bool IsPredefined { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public string XMLDocId { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public LiftedOperator(ISignOperator operator);
    public ISignOperator get_BaseOperator();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual bool get_IsChecked();
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
private IParameter[] CreateLiftedOperatorParameters();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.MembersReferencedInCollectionExpressionSearcher : object {
    private CollectionExpressionCache myCollectionExpressionCache;
    private HashSet`1<IDeclaredElement> myDeclaredElements;
    private bool myFindCandidates;
    private bool myIsFirstPass;
    private CollectionExpressionReferenceKinds myReferenceKinds;
    public MembersReferencedInCollectionExpressionSearcher(CollectionExpressionCache collectionExpressionCache, HashSet`1<IDeclaredElement> declaredElements, CollectionExpressionReferenceKinds referenceKinds, bool findCandidates, bool isFirstPass);
    public sealed virtual ValueTuple`2<IDomainSpecificSearcher, ISearchDomain> TryCreateSecondPhaseInfo(SearchDomainFactory searchDomainFactory, ISearchDomain originalSearchDomain, HashSet`1<IPsiSourceFile> processedFiles);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    private void AddReferencesFrom(ICollectionExpression collectionExpression, LocalList`1& references);
    private void AddReferencesFrom(ICollectionExpressionElement collectionExpressionElement, LocalList`1& references);
    private void ProcessReferences(ITreeNode element, IFindResultConsumer`1<TResult> consumer, IReadOnlyList`1<IReference> references);
    [PureAttribute]
private ISearchDomain CreateAdditionalSearchDomain(SearchDomainFactory searchDomainFactory, ISearchDomain originalSearchDomain, HashSet`1<IPsiSourceFile> processedFiles);
    [CompilerGeneratedAttribute]
private FindExecution <ProcessReferences>g__Process|11_0(IReference reference, IDeclaredElement declaredElement, <>c__DisplayClass11_0`1& );
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.ModifiersOrderFixer : object {
    private Dictionary`2<string, String[]> myFixedModifierOrders;
    private object myLock;
    private String[] myDefaultModifierOrder;
    private Dictionary`2<string, int> myDefaultModifierOrderMap;
    public String[] ParseAndFix(string modifiersOrder);
    private String[] FixModifiersOrder(string modifiersOrder);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ModifiersUtil : object {
    private static NodeTypeSet ourModifiers;
    [NotNullAttribute]
public static IReadOnlyDictionary`2<TokenNodeType, TokenNodeType[]> IncompatibleAccessModifiers;
    private static ModifiersUtil();
    private static void SetSourceModifiers(IModifiersListOwner modifiersListOwner, ICollection`1<TokenNodeType> modifiersToAdd, ICollection`1<TokenNodeType> modifiersToRemove);
    private static void AddRemoveModifier(IModifiersListOwner node, bool bAdd, TokenNodeType modifier);
    [PureAttribute]
public static AccessRights GetAccessRightsModifiers(IModifiersList node);
    [PureAttribute]
public static AccessRights GetAccessRightsModifiers(IModifiersListOwner node);
    public static void SetAccessRightsModifiers(IModifiersListOwner node, AccessRights rights);
    [PureAttribute]
public static bool GetAbstract(IModifiersListOwner node);
    public static void SetAbstract(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetSealed(IModifiersListOwner node);
    public static void SetSealed(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetVirtual(IModifiersListOwner node);
    public static void SetVirtual(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetOverride(IModifiersListOwner node);
    public static void SetOverride(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetStatic(IModifiersListOwner node);
    public static void SetStatic(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetReadonly(IModifiersListOwner node);
    public static void SetReadonly(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetExtern(IModifiersListOwner node);
    public static void SetExtern(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetNew(IModifiersListOwner node);
    public static void SetNew(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetUnsafe(IModifiersListOwner node);
    public static void SetUnsafe(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetVolatile(IModifiersListOwner node);
    public static void SetVolatile(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetRequired(IModifiersListOwner node);
    public static void SetRequired(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetPartial(IModifiersListOwner node);
    public static void SetPartial(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetAsync(IModifiersListOwner node);
    public static void SetAsync(IModifiersListOwner node, bool value);
    [PureAttribute]
public static bool GetRef(IModifiersListOwner node);
    public static void SetRef(IModifiersListOwner node, bool value);
    [PureAttribute]
public static ReferenceKind GetReferenceKind(IModifiersListOwner node);
    public static void SetReferenceKind(IModifiersListOwner modifiersListOwner, ReferenceKind value);
    [PureAttribute]
public static bool GetOverridable(IModifiersListOwner modifiersListOwner);
    [PureAttribute]
public static MemberDecoration GetDecoration(IModifiersListOwner modifiersListOwner);
    [PureAttribute]
public static MemberDecoration GetDecoration(IModifiersList modifiersList);
    [PureAttribute]
public static int CompareModifierOrder(IModifiersListOwner modifiersListOwner, ITokenNode modifier1, ITokenNode modifier2, String[] modifiersOrderStrings);
    [PureAttribute]
private static Nullable`1<int> GetSpecialModifierPriority(IModifiersListOwner modifiersListOwner, ITokenNodeType nodeType);
    [PureAttribute]
public static bool HasAccessRightsModifiers(ITreeNode element);
    [PureAttribute]
public static AccessRights GetDefaultAccessRights(ITreeNode element);
    [PureAttribute]
public static AccessRights GetSemanticAccessRights(ITreeNode element);
    [PureAttribute]
public static Nullable`1<AccessRights> GetAccessRightsWithValidation(IModifiersList modifiersList);
    public static void SetAccessRights(ITreeNode element, AccessRights rights);
    public static void SortModifiers(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration, string modifiersOrderString);
    public static String[] SplitModifiersSortOrder(string modifiersOrderString);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.MultipleDeclarationUtil : object {
    public static void ExtractDeclaration(IMultipleDeclarationMember declarationMember);
    public static bool SplitDeclarationBefore(IMultipleDeclarationMember declarationMember);
    public static bool SplitDeclarationAfter(IMultipleDeclarationMember declarationMember);
    [NotNullAttribute]
private static IMultipleDeclaration CopyMultiDeclaration(IMultipleDeclarationMember declarationMember, bool insertBefore);
    public static void RemoveDeclaration(IMultipleDeclarationMember declarationMember);
    public static void RemoveFixedPointerDeclaration(IUnsafeCodeFixedPointerDeclaration declaration);
    [NotNullAttribute]
private static ITreeNode GetDealingNode(IMultipleDeclarationMember declarationMember);
    [CanBeNullAttribute]
[PureAttribute]
private static ITreeNode FindCommaForward(ITreeNode treeNode);
    [CanBeNullAttribute]
[PureAttribute]
private static ITreeNode FindCommaBackward(ITreeNode treeNode);
    public static IMultipleDeclarationMember CreateCopyInternalImpl(IMultipleDeclarationMember declarationMember, TreeNodeCopyContext context);
    [NotNullAttribute]
public static TMultipleDeclarationMember AddDeclaratorBefore(IMultipleDeclaration root, TMultipleDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    [NotNullAttribute]
public static TMultipleDeclarationMember AddDeclaratorAfter(IMultipleDeclaration root, TMultipleDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.NullableAnnotationCleaningService : object {
    [NotNullAttribute]
public static NullableAnnotationCleaningService Instance;
    [NotNullAttribute]
private static NodeTypeSet PREDEFINED_VALUE_TYPE_KEYWORDS;
    private PsiModificationServicePriority JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.Priority { get; }
    private static NullableAnnotationCleaningService();
    private sealed virtual override PsiModificationServicePriority JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.get_Priority();
    private sealed virtual override bool JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.IsApplicable(ITreeNode originalNode, bool fromPhysicalTree, ITreeNode insertedCopyNode, bool toPhysicalTree);
    private sealed virtual override object JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.CreateContext(ITreeNode originalNode, IReferenceContextCodec referenceContextCodec, ITreeNode insertedCopyNode);
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.Apply(ITreeNode node, object context);
    public sealed virtual bool ShouldApplyToDescendants(ITreeNode node, object context);
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.CleanupContext(ITreeNode node, object context);
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService.OnCopyWithResolve(ITreeNode node, ITreeNode copy);
    public static void RemoveDisallowedNullableAnnotations(ITypeUsage typeUsage);
    [NotNullAttribute]
private static ITypeUsage ProcessTypeUsage(ITypeUsage typeUsage);
    [PureAttribute]
private static bool IsJaggedArrayTypeUsage(ITypeUsage typeUsage);
    [NotNullAttribute]
[PureAttribute]
private static ITypeUsage GetContainingJaggedArrayTypeUsageOrSelf(ITypeUsage typeUsage);
    [NotNullAttribute]
private static IReferenceTypeConstraint ProcessReferenceTypeConstraint(IReferenceTypeConstraint referenceTypeConstraint);
    [PureAttribute]
private static bool HasNullableTypeUsagesWithoutAnnotationsContext(ITypeUsage typeUsage);
    [PureAttribute]
private static bool IsNullableTypeUsageWithoutAnnotationsContext(ITreeNode node);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.NullableContextProjectProperty : object {
    private NullableContextKind myOverriddenNullableContextKind;
    private int myOverridesCount;
    public NullableContextProjectProperty(Lifetime lifetime, IShellLocks locks, ILogger logger, ProjectPropertiesListener projectPropertiesListener);
    [MustUseReturnValueAttribute]
public sealed virtual NullableContextKind GetNullableContextKind(IProject project, TargetFrameworkId targetFrameworkId);
    public void OverrideNullableContext(Lifetime lifetime, IProject project, NullableContextKind nullableContextKind);
}
[SolutionFeaturePartAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.NullableContextProvider : NullableContextProviderForAnyModule {
    [NotNullAttribute]
private NullableContextProjectProperty myNullableContextProjectProperty;
    [CanBeNullAttribute]
private Lazy`1<INullableContextModifier> myNullableContextModifier;
    public INullableContextModifier NullableContextModifier { get; }
    public NullableContextProvider(NullableContextProjectProperty nullableContextProjectProperty, Lazy`1<INullableContextModifier> nullableContextModifier);
    public virtual INullableContextModifier get_NullableContextModifier();
    public virtual bool IsApplicable(IPsiModule psiModule);
    public virtual NullableContextKind GetNullableContextKind(IPsiModule psiModule);
}
[SolutionFeaturePartAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.NullableContextProviderForAnyModule : object {
    public INullableContextModifier NullableContextModifier { get; }
    public virtual bool IsApplicable(IPsiModule psiModule);
    public virtual NullableContextKind GetNullableContextKind(IPsiModule psiModule);
    public virtual INullableContextModifier get_NullableContextModifier();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.NullableEqualityOperator : PredefinedOperator {
    internal NullableEqualityOperator(PredefinedType predefined, string name);
    public sealed virtual ApplicableCandidate IsApplicable(IResolveContext resolveContext, ISubstitution substitution, IList`1<ICSharpArgumentInfo> arguments, IList`1<IExpressionType> argumentTypes, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, IPsiModule module, CandidateWithResolveContext& candidate);
    public sealed virtual bool IsApplicable(ISubstitution substitution, IList`1<IExpressionType> argumentTypes, IPsiModule module);
    private bool IsApplicable(IList`1<IExpressionType> argumentTypes, ISubstitution& substitution);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Occurrences.CSharpOccerrencesFinder : OccurrencesFinderImplBase {
    public virtual IDeclaredElement GetOriginalElement(IDeclaredElement element);
    public virtual bool CompareLeafNodex(ITreeNode node1, ITreeNode node2);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Occurrences.FindResultInitializer : FindResult {
    [CompilerGeneratedAttribute]
private ITreeNode <Declaration>k__BackingField;
    [NotNullAttribute]
public ITreeNode Declaration { get; }
    public FindResultInitializer(ITreeNode declaration);
    [CompilerGeneratedAttribute]
public ITreeNode get_Declaration();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ParenthesesUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanUseAssociativityToRemoveParentheses(IParenthesizedExpression parenthesizedExpression);
    private static bool CheckSimilarTypes(IType oldRightOperandType, IType newRightOperandType);
    [PureAttribute]
private static bool CheckBinaryOperatorsSameSign(IOperatorExpression left, IOperatorExpression right);
    [PureAttribute]
private static bool CheckBinaryOperatorsEquivalent(IOperatorExpression left, IOperatorExpression right);
    [PureAttribute]
private static bool CheckBinaryOperatorAssociative(IBinaryExpression binaryExpression);
    [NotNullAttribute]
private static ICSharpExpression RemoveParenthesesUsingAssociativity(IParenthesizedExpression parenthesized);
    [NotNullAttribute]
public static ICSharpExpression RemoveParentheses(IParenthesizedExpression parenthesizedExpression);
    [NotNullAttribute]
public static ICSharpExpression ClarifyPrecedenceWithParentheses(IBinaryExpression binaryExpression);
    [PureAttribute]
public static bool IsLikelyFromBrokenLanguageConstruct(IParenthesizedExpression parenthesizedExpression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.PointerPredefinedOperator : PredefinedOperator {
    [CompilerGeneratedAttribute]
private IPointerType <PointerType>k__BackingField;
    public IPointerType PointerType { get; }
    public PointerPredefinedOperator(IPointerType pointerType, string name, IType returnType, IType[] parameterTypes);
    public PointerPredefinedOperator(IPointerType pointerType, string name, IType type, int parameterNumber);
    [CompilerGeneratedAttribute]
public IPointerType get_PointerType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.PsiSourceFiles.CompileItemsProjectPsiModuleHandlerAndDecorator : DelegatingProjectPsiModuleHandler {
    private IProject myProject;
    private DocumentManager myDocumentManager;
    private PsiSourceFilePropertiesManager myPsiSourceFilePropertiesManager;
    private Dictionary`2<IProjectFile, IPsiSourceFile> mySourceFiles;
    public CompileItemsProjectPsiModuleHandlerAndDecorator(IProject project, IProjectPsiModuleHandler handler, DocumentManager documentManager, PsiSourceFilePropertiesManager psiSourceFilePropertiesManager);
    public virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFilesFor(IProjectFile projectFile);
    public virtual void OnProjectFileChanged(IProjectFile projectFile, VirtualFileSystemPath oldLocation, ChangeType changeType, PsiModuleChangeBuilder changeBuilder);
    private void AddNewFile(IProjectFile projectFile, PsiModuleChangeBuilder changeBuilder);
    private bool IsProjectFileOfDifferentLanguageWithBuildActionCompile(IProjectFile projectFile);
    public sealed virtual IEnumerable`1<IPsiModuleReference> OverrideModuleReferences(IEnumerable`1<IPsiModuleReference> references);
    public sealed virtual IEnumerable`1<IPsiSourceFile> OverrideSourceFiles(IEnumerable`1<IPsiSourceFile> files);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.PsiSourceFiles.CompileItemsProjectPsiModuleProviderFilter : object {
    private DocumentManager myDocumentManager;
    private PsiSourceFilePropertiesManager myPsiSourceFilePropertiesManager;
    public CompileItemsProjectPsiModuleProviderFilter(DocumentManager documentManager, PsiSourceFilePropertiesManager psiSourceFilePropertiesManager);
    public sealed virtual Tuple`2<IProjectPsiModuleHandler, IPsiModuleDecorator> OverrideHandler(Lifetime lifetime, IProject project, IProjectPsiModuleHandler handler);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.CastReference : QueryReferenceBase`1<IQueryCastReferenceProvider> {
    private static string CAST;
    protected IType[] TypeArguments { get; }
    private IList`1<IType> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.TypeArguments { get; }
    public IQueryCastReferenceProvider Provider { get; }
    public CastReference(IQueryCastReferenceProvider owner);
    protected virtual IType[] get_TypeArguments();
    public virtual ICSharpArgumentInfo[] GetArguments();
    private sealed virtual override IList`1<IType> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_TypeArguments();
    public virtual string GetName();
    public virtual bool IsValid();
    public virtual TreeTextRange GetTreeTextRange();
    protected virtual bool TryGetQualifier(IQueryReference& reference, ICSharpExpression& expression);
    public sealed virtual IQueryCastReferenceProvider get_Provider();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Query.ExtensionQueryInfo : SimpleArgumentInfoBase {
    [NotNullAttribute]
private IQueryReference myExtensionReference;
    public bool IsExtensionInvocationQualifier { get; }
    public ExtensionQueryInfo(ICSharpInvocationInfo invocation, IQueryReference extensionReference);
    public virtual bool get_IsExtensionInvocationQualifier();
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual DocumentRange GetDocumentRange();
    public virtual bool IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.GeneratedLambdaExpressionType : GeneratedLambdaExpressionTypeBase {
    [NotNullAttribute]
private IGeneratedQueryArgument myArgument;
    public ITreeNode VerificationScope { get; }
    private GeneratedLambdaExpressionType(IResolveContext resolveContext, IGeneratedQueryArgument argument);
    public static IAnonymousFunctionType Create(IResolveContext resolveContext, IGeneratedQueryArgument argument);
    public virtual IList`1<IExpressionType> CalculateReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    public virtual bool IsImplicitReturnReachable(IResolveContext resolveContext);
    public virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
    public virtual ITreeNode get_VerificationScope();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Query.GeneratedLambdaExpressionTypeBase : LambdaExpressionTypeBase {
    protected bool IsAsync { get; }
    protected GeneratedLambdaExpressionTypeBase(IPsiModule psiModule, IResolveContext resolveContext, IReadOnlyList`1<IParameter> parameters, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    protected virtual bool get_IsAsync();
    public virtual IType GetFunctionType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.GeneratedQueryArgument : object {
    [NotNullAttribute]
private IQueryChainReference myReference;
    [NotNullAttribute]
private IQueryVariable[] myParameters;
    public IPsiModule Module { get; }
    public CSharpParameterInstance MatchingParameter { get; }
    private DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.MatchingParameter { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public bool IsNamedArgument { get; }
    public string ArgumentName { get; }
    public IPsiModule PsiModule { get; }
    [NotNullAttribute]
public ICSharpInvocationInfo Invocation { get; }
    public ParameterKind Kind { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public IManagedConvertible ManagedConvertible { get; }
    public GeneratedQueryArgument(IQueryChainReference reference, IScheme[] schemas);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual IReadOnlyList`1<IQueryVariable> GetVariables();
    public sealed virtual IList`1<IQueryAnonymousTypeProperty> GetGeneratedProperties();
    public sealed virtual IQueryAnonymousType GetAnonymousType();
    public sealed virtual IQueryAnonymousType GetAnonymousType(IResolveContext resolveContext);
    public sealed virtual CSharpParameterInstance get_MatchingParameter();
    private sealed virtual override DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.get_MatchingParameter();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual bool get_IsNamedArgument();
    public sealed virtual string get_ArgumentName();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    public sealed virtual DocumentRange GetDocumentRange();
    public sealed virtual bool IsValid();
    protected bool Equals(GeneratedQueryArgument argument);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.Query.IQueryAnonymousType {
    [NotNullAttribute]
public IList`1<IQueryAnonymousTypeProperty> QueryProperties { get; }
    public abstract virtual IList`1<IQueryAnonymousTypeProperty> get_QueryProperties();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.LambdaExpressionTypeForCastReference : GeneratedLambdaExpressionTypeBase {
    [NotNullAttribute]
private IQueryCastReference myCastReference;
    public ITreeNode VerificationScope { get; }
    private LambdaExpressionTypeForCastReference(IResolveContext resolveContext, IReadOnlyList`1<IParameter> parameters, IQueryCastReference castReference);
    public static IAnonymousFunctionType Create(IResolveContext resolveContext, IReadOnlyList`1<IParameter> parameters, IQueryCastReference castReference);
    public virtual IList`1<IExpressionType> CalculateReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    public virtual bool IsImplicitReturnReachable(IResolveContext resolveContext);
    public virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
    public virtual ITreeNode get_VerificationScope();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.LambdaExpressionTypeForLetClause : GeneratedLambdaExpressionTypeBase {
    [NotNullAttribute]
private IQueryLetClause myLetClause;
    public ITreeNode VerificationScope { get; }
    private LambdaExpressionTypeForLetClause(IResolveContext resolveContext, IQueryLetClause letClause);
    public static IAnonymousFunctionType Create(IResolveContext resolveContext, IQueryLetClause letClause);
    public virtual IList`1<IExpressionType> CalculateReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    public virtual bool IsImplicitReturnReachable(IResolveContext resolveContext);
    public virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
    public virtual ITreeNode get_VerificationScope();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryAccessContext : object {
    [NotNullAttribute]
private IQueryReference myReference;
    [NotNullAttribute]
private IResolveContext myResolveContext;
    public QueryAccessContext(IQueryReference queryReference, IResolveContext resolveContext);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryAnonymousType : AnonymousTypeBase {
    [NotNullAttribute]
private IPsiModule myPsiModule;
    [NotNullAttribute]
private QueryAnonymousTypeProperty[] myProperties;
    [CanBeNullAttribute]
private IList`1<AnonymousTypeDescriptor> myTypeDescriptor;
    public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public IList`1<ICSharpAnonymousTypeProperty> Properties { get; }
    public IList`1<AnonymousTypeDescriptor> TypeDescriptor { get; }
    public IList`1<IQueryAnonymousTypeProperty> QueryProperties { get; }
    public QueryAnonymousType(IPsiModule module, IList`1<ValueTuple`3<IQueryRangeVariableDeclaration, IType, string>> properties);
    public QueryAnonymousType(IPsiModule module, IResolveContext resolveContext, IQueryVariable[] variables);
    public virtual ITypePointer CreatePointer();
    public virtual IPsiModule get_Module();
    public virtual TypeDecorationSet get_TypeDecorations();
    public virtual IType WithTypeDecorations(TypeDecorationSet typeDecorations);
    public virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    public virtual IList`1<ICSharpAnonymousTypeProperty> get_Properties();
    public virtual IList`1<AnonymousTypeDescriptor> get_TypeDescriptor();
    public sealed virtual IList`1<IQueryAnonymousTypeProperty> get_QueryProperties();
    public virtual bool Equals(object obj);
    public virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public virtual int GetHashCode();
    public virtual IAnonymousType TryTranslateToCurrentFork(IContentModelForkTranslator translator);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryAnonymousTypeProperty : AnonymousTypePropertyBase {
    [NotNullAttribute]
private QueryAnonymousType myContainingType;
    [NotNullAttribute]
private IType myType;
    [CanBeNullAttribute]
private IQueryRangeVariableDeclaration myDeclaration;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public string ShortName { get; }
    public IType Type { get; }
    public ICSharpAnonymousType ContainingType { get; }
    public int Index { get; }
    public IQueryRangeVariableDeclaration Declaration { get; }
    public QueryAnonymousTypeProperty(QueryAnonymousType containingType, IQueryRangeVariableDeclaration declaration, IType type, string name, int index);
    public QueryAnonymousTypeProperty(QueryAnonymousType containingType, IQueryVariable variable, IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
public virtual string get_ShortName();
    public virtual IType get_Type();
    public virtual ICSharpAnonymousType get_ContainingType();
    [CompilerGeneratedAttribute]
public virtual int get_Index();
    public sealed virtual IQueryRangeVariableDeclaration get_Declaration();
    public virtual IAnonymousTypeProperty SetName(string name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryCastArgumentInfo : SimpleArgumentInfoBase {
    [NotNullAttribute]
private IQueryCastReference myCastReference;
    private DocumentRange myArgumentRange;
    public bool IsExtensionInvocationQualifier { get; }
    public QueryCastArgumentInfo(ICSharpInvocationInfo invocation, IQueryCastReference castReference, DocumentRange argumentRange);
    public virtual DocumentRange GetDocumentRange();
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool get_IsExtensionInvocationQualifier();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryChainReferenceBase`1 : QueryReferenceBase`1<TQueryClause> {
    protected QueryChainReferenceBase`1(TQueryClause owner);
    protected virtual bool TryGetQualifier(IQueryReference& reference, ICSharpExpression& expression);
    public sealed virtual IQueryClause GetElement();
    public virtual TreeTextRange GetTreeTextRange();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryQualifier : object {
    private IQueryReference myQualifierReference;
    private IResolveContext myResolveContext;
    public bool Resolved { get; }
    public QueryQualifier(IQueryReference qualifierReference, IResolveContext resolveContext);
    public sealed virtual bool get_Resolved();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryReferenceBase`1 : ManagedOnePhaseReferenceImplBase`1<TOwnerNode> {
    public bool IsQualified { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    private IList`1<IType> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.TypeArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    [NotNullAttribute]
private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public ICSharpInvocationInfo Invocation { get; }
    [NotNullAttribute]
protected IType[] TypeArguments { get; }
    protected QueryReferenceBase`1(TOwnerNode owner);
    public virtual bool get_IsQualified();
    protected abstract virtual bool TryGetQualifier(IQueryReference& reference, ICSharpExpression& expression);
    public virtual IQualifier GetQualifier(IResolveContext resolveContext);
    [NotNullAttribute]
public IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public virtual string Dump();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    [NotNullAttribute]
protected ICSharpArgumentInfo Argument(IGeneratedQueryArgument argument);
    [NotNullAttribute]
protected ICSharpArgumentInfo Argument(IQueryParameterPlatform platform);
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
public abstract virtual ICSharpArgumentInfo[] GetArguments();
    private sealed virtual override IList`1<IType> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_TypeArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    protected virtual IType[] get_TypeArguments();
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryVariable : QueryVariableBase {
    [CanBeNullAttribute]
private IQueryRangeVariableDeclaration myDeclaration;
    [NotNullAttribute]
private string myName;
    public string ShortName { get; }
    public bool IsTransparent { get; }
    public IQueryRangeVariableDeclaration Declaration { get; }
    public QueryVariable(IQueryRangeVariableDeclaration declaration, IQueryParameterPlatform platform);
    public QueryVariable(IGeneratedQueryArgument argumentInfo, IQueryClause element, IQueryRangeVariableDeclaration declaration);
    public virtual string get_ShortName();
    public virtual bool get_IsTransparent();
    public virtual IQueryRangeVariableDeclaration get_Declaration();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryVariableBase : object {
    [ThreadStaticAttribute]
private static JetHashSet`1<IQueryVariable> ourTypeCalculationsInProgress;
    [NotNullAttribute]
private ICSharpTreeNode myElement;
    [NotNullAttribute]
private IQueryArgumentInfo myArgumentInfo;
    [NotNullAttribute]
private IPsiServices myPsiServices;
    private CachedPsiValue`1<IType> myCachedType;
    public IType Type { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsValueVariable { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public bool IsTransparent { get; }
    public ICSharpTreeNode Element { get; }
    public IQueryRangeVariableDeclaration Declaration { get; }
    public bool IsImplicitlyTyped { get; }
    protected QueryVariableBase(IQueryArgumentInfo argumentInfo, ICSharpTreeNode queryClause);
    public sealed virtual IType get_Type();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public abstract virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public abstract virtual bool get_IsTransparent();
    public sealed virtual ICSharpTreeNode get_Element();
    public abstract virtual IQueryRangeVariableDeclaration get_Declaration();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    private bool EqualsArgumentInfo(ICSharpArgumentInfo info);
    protected bool Equals(QueryVariableBase queryVariableBase);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool get_IsImplicitlyTyped();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Query.QueryVariableElementPointer : object {
    [NotNullAttribute]
private IQueryVariable myQueryVariable;
    [NotNullAttribute]
private ITreeNodePointer`1<IQueryParameterPlatform> myPlatformPointer;
    [NotNullAttribute]
private ITreeNodePointer`1<IQueryRangeVariableDeclaration> myDeclarationPointer;
    public QueryVariableElementPointer(IQueryVariable queryVariable);
    public sealed virtual IQueryVariable FindDeclaredElement();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Query.TransparentVariable : QueryVariableBase {
    [NotNullAttribute]
private Scheme myScheme;
    public string ShortName { get; }
    public bool IsTransparent { get; }
    public IQueryRangeVariableDeclaration Declaration { get; }
    public Scheme Scheme { get; }
    public TransparentVariable(IQueryParameterPlatform platform, Scheme scheme);
    public TransparentVariable(IGeneratedQueryArgument argumentInfo, IQueryClause element, Scheme scheme);
    public virtual string get_ShortName();
    public virtual bool get_IsTransparent();
    public virtual IQueryRangeVariableDeclaration get_Declaration();
    public sealed virtual Scheme get_Scheme();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.RecordSynthesizedMembers : object {
    public static string EqualityContract;
    public static string PrintMembers;
    public static string Clone;
    public static string CloneMetadata;
    public static string Deconstruct;
    public static string Equals;
    public static string GetHashCode;
    public static string ToString;
    [ItemNotNullAttribute]
public static String[] RECORD_MEMBER_NAMES;
    private static RecordSynthesizedMembers();
    [PureAttribute]
public static bool IsCopyConstructorSignature(ITypeElement record, IConstructor constructor);
    [PureAttribute]
public static bool IsDeconstructSignature(IRecord record, IMethod method);
    [PureAttribute]
public static bool IsEqualityContractSignature(IProperty property);
    [PureAttribute]
public static bool IsTypedEqualsSignature(IRecord record, IMethod method);
    [PureAttribute]
public static bool IsGetHashCodeSignature(IMethod method);
    [PureAttribute]
public static bool IsPrintMembersSignature(IMethod method);
    [PureAttribute]
public static bool IsToStringSignature(IMethod method);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.ReferenceEqualityOperator : PredefinedOperator {
    [NotNullAttribute]
private PredefinedType myPredefinedType;
    public ReferenceEqualityOperator(PredefinedType predefined, string name);
    public sealed virtual ApplicableCandidate IsApplicable(IResolveContext resolveContext, ISubstitution substitution, IList`1<ICSharpArgumentInfo> arguments, IList`1<IExpressionType> argumentTypes, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, IPsiModule module, CandidateWithResolveContext& candidate);
    public sealed virtual bool IsApplicable(ISubstitution substitution, IList`1<IExpressionType> argumentTypes, IPsiModule module);
    private static bool HasClassConstraint(IType type);
    private bool CheckTypeParameterCase(IExpressionType leftExpressionType, IType leftType, IExpressionType rightExpressionType, IType rightType);
    private bool SpecialTypeParameterCase(IType type);
}
public enum JetBrains.ReSharper.Psi.CSharp.Impl.ReSharperSettingsCSharpLanguageLevel : Enum {
    public int value__;
    public static ReSharperSettingsCSharpLanguageLevel Default;
    public static ReSharperSettingsCSharpLanguageLevel CSharp20;
    public static ReSharperSettingsCSharpLanguageLevel CSharp30;
    public static ReSharperSettingsCSharpLanguageLevel CSharp40;
    public static ReSharperSettingsCSharpLanguageLevel CSharp50;
    public static ReSharperSettingsCSharpLanguageLevel CSharp60;
    public static ReSharperSettingsCSharpLanguageLevel CSharp70;
    public static ReSharperSettingsCSharpLanguageLevel CSharp71;
    public static ReSharperSettingsCSharpLanguageLevel CSharp72;
    public static ReSharperSettingsCSharpLanguageLevel CSharp73;
    public static ReSharperSettingsCSharpLanguageLevel CSharp80;
    public static ReSharperSettingsCSharpLanguageLevel CSharp90;
    public static ReSharperSettingsCSharpLanguageLevel CSharp100;
    public static ReSharperSettingsCSharpLanguageLevel CSharp110;
    public static ReSharperSettingsCSharpLanguageLevel CSharp120;
    public static ReSharperSettingsCSharpLanguageLevel CSharp130;
    public static ReSharperSettingsCSharpLanguageLevel Latest;
    public static ReSharperSettingsCSharpLanguageLevel Experimental;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.ReSharperSettingsCSharpLanguageLevelExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<CSharpLanguageLevel> ToPsiLanguageLevel(ReSharperSettingsCSharpLanguageLevel languageLevel);
    [ExtensionAttribute]
[PureAttribute]
public static ReSharperSettingsCSharpLanguageLevel ToSettingsLanguageLevel(CSharpLanguageLevel languageLevel);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.BadArgumentInfo : SimpleArgumentInfoBase {
    public bool IsExtensionInvocationQualifier { get; }
    public BadArgumentInfo(ICSharpInvocationInfo invocation);
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool get_IsExtensionInvocationQualifier();
    public virtual DocumentRange GetDocumentRange();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpExtensionSymbolInfo : CSharpSymbolInfo {
    public CSharpExtensionSymbolInfo(IUsingDirective usingDirective, IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ISymbolInfo ReplaceSubstitution(ISubstitution composedSubstitution);
    public virtual ISymbolInfo ReplaceLevel(int level);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpOperatorResolver : object {
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private CSharpPredefined myPredefined;
    private CSharpLanguageLevel myLanguageLevel;
    private CSharpLanguageLevel myLatestSupportedLanguageLevel;
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
private string myPredefinedName;
    [NotNullAttribute]
private IList`1<ICSharpArgumentInfo> myArguments;
    private bool myCircularOperatorForm;
    [ItemCanBeNullAttribute]
[NotNullAttribute]
private IType[] myTypes;
    [NotNullAttribute]
private IExpressionType[] myExpressionTypes;
    [NotNullAttribute]
private OverloadResolutionEngine myEngine;
    private bool myCheckedContext;
    [NotNullAttribute]
private static ObjectPool`1<PooledHashSet`1<IDeclaredType>> ourVisitedPool;
    [NotNullAttribute]
private static ObjectPool`1<PooledHashSet`1<IClass>> ourCyclesPool;
    public CSharpOperatorResolver(IResolveContext resolveContext, ITreeNode context, string name, IList`1<ICSharpArgumentInfo> arguments, bool circularOperatorForm);
    private CSharpOperatorResolver(string name, IList`1<ICSharpArgumentInfo> arguments, CSharpOperatorResolver parentResolver);
    private CSharpOperatorResolver(IResolveContext resolveContext, IPsiModule psiModule, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, string name, IList`1<ICSharpArgumentInfo> arguments, bool checkedContext, bool circularOperatorForm);
    private static CSharpOperatorResolver();
    [CanBeNullAttribute]
private ApplicableCandidate IsApplicable(IOperator operator, ISubstitution substitution, CandidateWithResolveContext& candidate);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> GetApplicableOperators(string name, IEnumerable`1<ISignOperator> operators, ISubstitution substitution, bool checkedContext, IList`1& candidates);
    private static bool HasMatchedCheckedOperator(InvocableSignature signature, LocalList`1<InvocableSignature> checkedOperatorSignatures);
    private bool CheckTypes();
    [NotNullAttribute]
public ResolveResultWithInfo Resolve();
    [NotNullAttribute]
private static string GetPredefinedOperatorResolveName(string name);
    [NotNullAttribute]
public IList`1<ApplicableCandidate> GetApplicableUserDefinedOperators(string name, bool checkedContext, IList`1& candidates);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> GetApplicableOperatorsInType(string name, HashSet`1<IDeclaredType> visited, HashSet`1<IDeclaredType> hierarchyCycles, HashSet`1<IClass> classCycles, IType type, bool checkedContext, IList`1& candidates);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> GetApplicableSpecialOperators(string name, bool checkedContext, IList`1& candidates);
    [NotNullAttribute]
private IList`1<ISignOperator> CollectSpecialOperators(string name);
    [NotNullAttribute]
[PureAttribute]
private IReadOnlyList`1<ISignOperator> GetAdditionalPredefinedOperators(IType expressionType, JetHashSet`1<IType> visited);
    [PureAttribute]
private ApplicableCandidate TryResolveToReferenceOperator(string name, IType type, CandidateWithResolveContext& candidate);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> ResolveReferenceOperatorsFirst(string name, IList`1& candidates);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> GetApplicablePredefinedOperators(string name, IList`1& candidates, bool skipNativeIntegerOperators);
    private ISignOperator[] GetPredefinedOperators(string name);
    [CanBeNullAttribute]
private NullableEqualityOperator GetNullableEqualityOperator(string name);
    [CanBeNullAttribute]
private ReferenceEqualityOperator GetReferenceEqualityOperator(string name);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
private ResolveResultWithInfo TryResolveSpecialApplicabilityOperator(ICSharpSpecialApplicabilityOperator operator);
    [CanBeNullAttribute]
private ResolveResultWithInfo TryResolveTupleEqualityOperator(string name);
    [NotNullAttribute]
private static ICSharpArgumentInfo GetTupleComponentArgumentInfo(IReadOnlyList`1<ITupleComponent> components, IReadOnlyList`1<IExpressionType> componentTypes, int index);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<ITupleComponent> GetTupleComponentExpressions(int index);
    [CanBeNullAttribute]
[ItemCanBeNullAttribute]
private IReadOnlyList`1<string> GetTupleEqualityComponentNames(IReadOnlyList`1<ITupleComponent> leftTupleComponents, IReadOnlyList`1<ITupleComponent> rightTupleComponents);
    [CanBeNullAttribute]
private ResolveResultWithInfo TryResolveInterpolatedStringConcatenation(string name);
    [CanBeNullAttribute]
private ResolveResultWithInfo TryResolveUtf8StringConcatenation(string name);
    [NotNullAttribute]
private IResolveResult CreateResolveResult(IList`1<CandidateWithResolveContext> candidates);
    [NotNullAttribute]
private IResolveResult CreateResolveResult(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
private static IResolveResult CreateResolveResultImpl(IList`1<T> infos);
    [NotNullAttribute]
public ISymbolTable GetOperatorsSymbolTable();
    public static ValueTuple`2<ISignOperator, ISignOperator> FindTrueFalseOperators(IType type);
    [CompilerGeneratedAttribute]
internal static IReadOnlyList`1<IConversionOperator> <TryResolveTupleEqualityOperator>g__GetConversionOperatorsUsedForParameter|36_0(IExpressionType componentType, IParameter parameter, <>c__DisplayClass36_0& , <>c__DisplayClass36_1& );
    [CompilerGeneratedAttribute]
internal static Nullable`1<DecoratedType`1<TupleTypeDecoration>> <GetTupleEqualityComponentNames>g__GetTupleType|39_1(IExpressionType expressionType);
    [CompilerGeneratedAttribute]
private bool <TryResolveUtf8StringConcatenation>g__IsValidOperand|41_0(ICSharpExpression expression);
    [CompilerGeneratedAttribute]
private ISymbolTable <GetOperatorsSymbolTable>b__45_1(IType type);
}
[ShellComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpOperatorTable : object {
    private bool myIsInitialized;
    private static Pair`2<string, string> EMPTY;
    private Dictionary`2<string, Dictionary`2<Pair`2<string, string>, Pair`2<string, string>>> myBinaryOperatorsCache;
    private Dictionary`2<string, Dictionary`2<Pair`2<string, string>, Pair`2<string, string>>> myBinaryConstantIntOperatorsCache;
    private Dictionary`2<string, Dictionary`2<Pair`2<string, string>, Pair`2<string, string>>> myBinaryConstantLongOperatorsCache;
    private Dictionary`2<string, Dictionary`2<string, string>> myUnaryOperatorsCache;
    [CanBeNullAttribute]
public static CSharpOperatorTable Instance { get; }
    private static CSharpOperatorTable();
    public static CSharpOperatorTable get_Instance();
    private void InitializeOnDemand();
    private static bool IsSpecialConstantType(ICSharpConstantType constantType);
    private IResolveResult GetReferenceEqualityInequalityOperatorResult(IPsiModule module, string operatorName);
    private IResolveResult GetCachedBinaryResolution(IPsiModule module, string operatorName, IExpressionType leftExpressionType, IExpressionType rightExpressionType);
    private static string GetTypeKeyword(IType type);
    private static bool IsCircularOperatorForm(string operatorName);
    private bool UnliftTypes(IType& leftType, IType& rightType);
    [CanBeNullAttribute]
private IResolveResult GetCachedUnaryResolution(IPsiModule psiModule, string operatorName, IExpressionType expressionType);
    [CanBeNullAttribute]
public IResolveResult GetOperatorsResolution(IPsiModule module, string operatorName, IList`1<IExpressionType> operandTypes);
    private void Init_BinaryPlus();
    private void Init_ConstantIntBinaryPlus();
    private void Init_ConstantLongBinaryPlus();
    private void Init_BinaryMinus();
    private void Init_ConstantIntBinaryMinus();
    private void Init_ConstantLongBinaryMinus();
    private void Init_BinaryMultiply();
    private void Init_ConstantIntBinaryMultiply();
    private void Init_ConstantLongBinaryMultiply();
    private void Init_BinaryDivision();
    private void Init_ConstantIntBinaryDivision();
    private void Init_ConstantLongBinaryDivision();
    private void Init_BinaryMod();
    private void Init_ConstantIntBinaryMod();
    private void Init_ConstantLongBinaryMod();
    private void Init_BinaryEquality();
    private void Init_ConstantIntBinaryEquality();
    private void Init_ConstantLongBinaryEquality();
    private void Init_BinaryInequality();
    private void Init_ConstantIntBinaryInequality();
    private void Init_ConstantLongBinaryInequality();
    private void Init_BinaryLessThan();
    private void Init_ConstantIntBinaryLessThan();
    private void Init_ConstantLongBinaryLessThan();
    private void Init_BinaryGreaterThan();
    private void Init_ConstantIntBinaryGreaterThan();
    private void Init_ConstantLongBinaryGreaterThan();
    private void Init_BinaryLessOrEq();
    private void Init_ConstantIntBinaryLessOrEq();
    private void Init_ConstantLongBinaryLessOrEq();
    private void Init_BinaryGreaterOrEq();
    private void Init_ConstantIntBinaryGreaterOrEq();
    private void Init_ConstantLongBinaryGreaterOrEq();
    private void Init_BinaryLeftShift();
    private void Init_ConstantIntBinaryLeftShift();
    private void Init_ConstantLongBinaryLeftShift();
    private void Init_BinaryRightShift();
    private void Init_ConstantIntBinaryRightShift();
    private void Init_ConstantLongBinaryRightShift();
    private void Init_BinaryUnsignedRightShift();
    private void Init_ConstantIntBinaryUnsignedRightShift();
    private void Init_ConstantLongBinaryUnsignedRightShift();
    private void Init_BinaryAnd();
    private void Init_ConstantIntBinaryAnd();
    private void Init_ConstantLongBinaryAnd();
    private void Init_BinaryOr();
    private void Init_ConstantIntBinaryOr();
    private void Init_ConstantLongBinaryOr();
    private void Init_BinaryXor();
    private void Init_ConstantIntBinaryXor();
    private void Init_ConstantLongBinaryXor();
    private void Init_BinaryAndAlso();
    private void Init_ConstantIntBinaryAndAlso();
    private void Init_ConstantLongBinaryAndAlso();
    private void Init_BinaryOrElse();
    private void Init_ConstantIntBinaryOrElse();
    private void Init_ConstantLongBinaryOrElse();
    private void InitBinaryOperatorCaches();
    private void Init_UnaryPlus();
    private void Init_UnaryMinus();
    private void Init_UnaryNot();
    private void Init_UnaryComplement();
    private void Init_UnaryIncrement();
    private void Init_UnaryDecrement();
    private void InitUnaryOperatorsResolutionCache();
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpQualifierSymbolTableUtil : object {
    private static ISymbolFilter[] ourStaticAbstractInterfaceMembersFilter;
    private static CSharpQualifierSymbolTableUtil();
    [NotNullAttribute]
public static ISymbolTable GetQualifierSymbolTableForUntypedElements(IPsiModule psiModule, IResolveResult result, SymbolTableMode mode);
    [NotNullAttribute]
public static ISymbolTable GetQualifierSymbolTableForUntypedElements(IPsiModule psiModule, IDeclaredElement element, ISubstitution substitution, SymbolTableMode mode);
    private static ISymbolTable GetAliasedTypeSymbolTable(IPsiModule psiModule, IType type, ISubstitution substitution, SymbolTableMode mode);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpResolveUtil : object {
    public static ISymbolFilter[] NonQualifiedReferenceExpressionPreFilters;
    private static CSharpResolveUtil();
    [NotNullAttribute]
public static ISymbolTable AddNamespaceSymbols(IPsiModule psiModule, IUsingDirective directive, INamespace nameSpace, int level, ISymbolScope cachedSymbolScope);
    [NotNullAttribute]
public static ISymbolTable AddExternAliases(IPsiModule module, IExternAlias globalAlias, TreeNodeEnumerable`1<IExternAliasDirective> externAliases, int level);
    [NotNullAttribute]
public static ISymbolTable AddExternAliases(IPsiModule module, IExternAlias globalAlias, IReadOnlyCollection`1<string> externAliases, int level);
    [NotNullAttribute]
public static ISymbolTable AddImportedSymbols(IPsiModule psiModule, IEnumerable`1<IUsingDirective> imports, IEnumerable`1<INamespace> defaultImports, int level, SymbolTableMode mode);
    private static ResolveResultWithInfo ResolveImportSymbolName(IReferenceName importedSymbolName);
    public static ResolveResultWithInfo ResolveConstructor(IResolveContext resolveContext, ISymbolTable table, IAccessContext accessContext, IList`1<ICSharpArgumentInfo> arguments, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, IPsiModule module, bool isConstructorInitializer, bool filterOutRecordCopyConstructor);
    public static ResolveResultWithInfo ResolveDefaultConstructor(IDeclaredType type, ITreeNode context);
    public static ResolveResultWithInfo ResolveAddMethodAllowingAnyParameterType(IDeclaredType type, ITreeNode context, bool allowExtension);
    [NotNullAttribute]
public static ISymbolFilter[] InvocationFilters(IResolveContext resolveContext, ITreeNode element, string name, IAccessContext context, int typeParametersNumber);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolFilter[] ReferenceNameResolveFilters(string referenceName, bool canBeAttribute, ISymbolFilter accessRightsFilter, ITypeArgumentsOwnerElement owner, IAccessContext accessContext, string qualifyingAlias);
    public static Refers DynamicRefersEvaluator(IResolveResult result, IDeclaredElement element, Func`2<IDeclaredElement, Refers> pureDynamicEvaluator);
    public static Refers DynamicRefersEvaluator(ILateBoundReference reference, IDeclaredElement element, Func`2<IDeclaredElement, Refers> pureDynamicEvaluator);
    [ExtensionAttribute]
[NotNullAttribute]
public static ResolveResultWithInfo GetCSharpResolveResult(ISymbolTable symbolTable, string name);
    [NotNullAttribute]
[PureAttribute]
public static string ReferenceName(string identifierName);
    [PureAttribute]
private static bool IsSimpleIdentifier(string identifier);
    [NotNullAttribute]
private static string ComputeNonTrivialIdentifier(string identifier);
    [PureAttribute]
private static int GetHexNumber(string text, int index, int length);
    [NotNullAttribute]
public static IType GetType(IResolveContext resolveContext, IClrDeclaredElement declaredElement, ISubstitution substitution);
    public static bool ShouldApplyEmbeddedComInteropTypeRule(ITypeMember typeMember, Func`1<IPsiModule> fSourceModule);
    [ExtensionAttribute]
public static bool ShouldApplyEmbeddedComInteropTypeRule(IResolveResult resolveResult, Func`1<IPsiModule> fSourceModule);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IUsingDirective GetUsing(ISymbolInfo symbolInfo);
    [PureAttribute]
public static bool IsEnclosingVarOutVariable(IDeclaredElement declaredElement, ITreeNode usage);
    [PureAttribute]
public static bool IsEnclosingVarLocalVariable(IDeclaredElement declaredElement, ITreeNode usage);
    [PureAttribute]
private static bool IsUsageInEnclosingVarLocalVariable(ITreeNode usage, ITreeNode declarationNode);
    [CanBeNullAttribute]
public static IReference GetReferenceQualifiedByExpression(ICSharpExpression qualifierExpression);
    [ExtensionAttribute]
public static IResolveInfo ChangeResolveErrorType(IResolveInfo originalInfo, ResolveErrorType errorType);
    [NotNullAttribute]
public static IEnumerable`1<INamespace> GetDefaultImports(ICSharpFile file, bool isTopLevel);
    public static void ScanVariablesInExpression(ITreeNode rootNode, LocalList`1& consumer);
    public static void ScanVariablesInStatementOwner(CSharpCompositeElement statementsOwner, LocalList`1& consumer, bool includeLabels);
    [PureAttribute]
public static bool IsStatementInEmbeddedStatementScope(CSharpCompositeElement statement);
    public static void AddPrimaryParameters(ICSharpTreeNode context, LocalList`1& variables);
    public static void AddPrimaryParameters(ICSharpTypeDeclaration typeDeclaration, LocalList`1& variables);
    [NotNullAttribute]
public static ISymbolTable GetIndexersSymbolTable(IType qualifierType, ITreeNode context);
    [NotNullAttribute]
public static ISymbolTable GetIndexersSymbolTable(IType qualifierType, IResolveContext resolveContext, IAccessContext accessContext, IPsiModule psiModule, CSharpLanguageLevel languageLevel);
    [NotNullAttribute]
[PureAttribute]
public static ResolveResultWithInfo ResolveIndexer(IType qualifierType, IResolveContext resolveContext, IAccessContext accessContext, IList`1<ICSharpArgumentInfo> arguments, IPsiModule psiModule, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [NotNullAttribute]
[PureAttribute]
public static ResolveResultWithInfo ResolveIndexer(IType qualifierType, ISymbolTable symbolTable, IResolveContext resolveContext, IAccessContext accessContext, IList`1<ICSharpArgumentInfo> arguments, IPsiModule psiModule, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [NotNullAttribute]
[PureAttribute]
public static ResolveResultWithInfo ResolveIndexer(IType qualifierType, ISymbolTable symbolTable, IResolveContext resolveContext, IAccessContext accessContext, IList`1<ICSharpArgumentInfo> arguments, IPsiModule psiModule, ISymbolFilter[] symbolFilters, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [NotNullAttribute]
[PureAttribute]
private static ResolveResultWithInfo ResolveIndexerNonArrayNonPointer(IType qualifierType, ISymbolTable symbolTable, IResolveContext resolveContext, IAccessContext accessContext, IOverloadResolutionData overloadResolutionData, ISymbolFilter[] symbolFilters);
    [NotNullAttribute]
public static ResolveResultWithInfo ResolveLengthOrCountProperty(IType patternType, IPsiModule psiModule, IAccessContext accessContext);
    [NotNullAttribute]
internal static ISymbolFilter[] GetIndexerFilters(IAccessContext accessContext, CSharpLanguageLevel languageLevel);
    [NotNullAttribute]
internal static ISymbolFilter[] GetCollectionExpressionAddFilters(IAccessContext accessContext);
    [NotNullAttribute]
internal static ISymbolFilter[] GetLengthOrCountPropertyFilters(IAccessContext accessContext);
    public static IOperator TryGetOperator(IPsiModule module, string operatorName, IList`1<IExpressionType> operandTypes);
    [PureAttribute]
private static PatternIndexers GetPatternIndexers(IDeclaredType qualifierType, IList`1<ISymbolInfo> regularIndexers, ISymbolTable symbolTable, IAccessContext accessContext, IPsiModule psiModule);
    [CompilerGeneratedAttribute]
internal static void <ComputeNonTrivialIdentifier>g__ParseUnicodeEscaping|22_0(StringBuilder sb, string identifier, int index, int length);
    [CompilerGeneratedAttribute]
internal static bool <ComputeNonTrivialIdentifier>g__IsFormattingChar|22_1(char ch);
    [CompilerGeneratedAttribute]
internal static void <ScanVariablesInStatementOwner>g__AddLocalVariables|35_0(StatementBase declarationStatement, LocalList`1& consumer);
    [CompilerGeneratedAttribute]
internal static bool <ResolveIndexerNonArrayNonPointer>g__ShouldConsiderPatternIndexers|44_0(ResolveErrorType resolveErrorType);
    [CompilerGeneratedAttribute]
internal static ResolveResultWithInfo <ResolveLengthOrCountProperty>g__MakeResolveResult|45_0(IList`1<ISymbolInfo> candidates, IResolveInfo resolveInfo);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IProperty, ISubstitution> <GetPatternIndexers>g__FindLengthProperty|50_0(<>c__DisplayClass50_0& );
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IMethod, ISubstitution> <GetPatternIndexers>g__FindSliceMethod|50_1(<>c__DisplayClass50_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpSymbolInfo : SymbolInfo {
    [CompilerGeneratedAttribute]
private IUsingDirective <UsingDirective>k__BackingField;
    [CanBeNullAttribute]
public IUsingDirective UsingDirective { get; }
    public CSharpSymbolInfo(IUsingDirective usingDirective, string aliasName, IDeclaredElement declaredElement, ISubstitution substitution, int importLevel, Nullable`1<int> inheritanceLevel);
    [CompilerGeneratedAttribute]
public IUsingDirective get_UsingDirective();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual ISymbolInfo ReplaceSubstitution(ISubstitution composedSubstitution);
    public virtual ISymbolInfo ReplaceLevel(int level);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.CSharpSymbolInfoExt : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExtensionMethod(ISymbolInfo info);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExpressionArgumentInfo : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpInvocationInfo <Invocation>k__BackingField;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public ICSharpInvocationInfo Invocation { get; }
    public CSharpParameterInstance MatchingParameter { get; }
    private DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.MatchingParameter { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public bool IsNamedArgument { get; }
    public string ArgumentName { get; }
    public IPsiModule PsiModule { get; }
    public ParameterKind Kind { get; }
    public bool IsExtensionInvocationQualifier { get; }
    [NotNullAttribute]
public IManagedConvertible ManagedConvertible { get; }
    public ExpressionArgumentInfo(ICSharpInvocationInfo invocation, ICSharpExpression expression);
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpInvocationInfo get_Invocation();
    public sealed virtual CSharpParameterInstance get_MatchingParameter();
    private sealed virtual override DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.get_MatchingParameter();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual bool get_IsNamedArgument();
    public sealed virtual string get_ArgumentName();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual DocumentRange GetDocumentRange();
    public sealed virtual bool IsValid();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExtensionArgumentInfo : SimpleArgumentInfoBase {
    [NotNullAttribute]
private ICSharpExpression myExpression;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public ExtensionArgumentInfo(ICSharpInvocationInfo invocation, ICSharpExpression expression);
    public sealed virtual ICSharpExpression get_Expression();
    public virtual bool get_IsExtensionInvocationQualifier();
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual DocumentRange GetDocumentRange();
    public virtual bool IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExtensionMethods.CSharpExtensionMethodsRegistryImpl : CSharpExtensionMethodsRegistry {
    [NotNullAttribute]
private ISolution mySolution;
    public CSharpExtensionMethodsRegistryImpl(ISolution solution);
    public virtual IExtensionMethodsQuery GetAllExtensionMethods();
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExtensionMethods.CSharpExtensionMethodsUtil : object {
    public static bool ExtensionMethodsExists(string shortName, ISolution solution);
    [NotNullAttribute]
public static IList`1<MethodInstance> EnumerateExtensionMethods(string name, IType qualifierType, IAccessContext accessContext, ITreeNode context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExtensionMethods.CSharpExtensionMethodsUtil/<EnumerateExtensionMethods>d__2")]
[NotNullAttribute]
public static IEnumerable`1<IMethod> EnumerateExtensionMethods(ITypeElement typeElement, string shortName);
    internal static void AddSolutionAnalysisDependencies(string shortName, ITreeNode context);
    internal static void AddSolutionAnalysisDependencies(string shortName, IEnumerable`1<ExtensionsImport> extensionsImports, IPsiModule psiModule);
    private static void AddSolutionAnalysisDependencies(string shortName, IEnumerable`1<ExtensionsImport> extensionsImports, DependencyStore dependencyStore, IPsiModule psiModule);
    [NotNullAttribute]
public static IReadOnlyList`1<IReadOnlyList`1<ExtensionsImport>> AllExtensionMethodsProviders(ITreeNode context);
    [NotNullAttribute]
private static IReadOnlyList`1<ExtensionsImport> CollectUsingListImports(ICSharpTypeAndNamespaceHolderDeclaration declaration);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExtensionMethods.CSharpRequest : object {
    [NotNullAttribute]
public static IRequest Empty;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <ForModule>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<INamespace> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITypeElement> <Types>k__BackingField;
    [CanBeNullAttribute]
private IReadOnlyList`1<IType> myBaseTypes;
    public string Name { get; }
    public IPsiModule ForModule { get; }
    public IType ExpressionType { get; }
    public IReadOnlyList`1<INamespace> Namespaces { get; }
    public IReadOnlyList`1<ITypeElement> Types { get; }
    public bool IsCaseSensitive { get; }
    public IReadOnlyList`1<IType> BaseExpressionTypes { get; }
    private CSharpRequest(string name, IType expressionType, IReadOnlyList`1<INamespace> namespaces, IReadOnlyList`1<ITypeElement> types, IPsiModule forModule, IReadOnlyList`1<IType> baseTypes);
    private static CSharpRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_ForModule();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpressionType();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<INamespace> get_Namespaces();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ITypeElement> get_Types();
    public sealed virtual bool get_IsCaseSensitive();
    public sealed virtual IReadOnlyList`1<IType> get_BaseExpressionTypes();
    public sealed virtual IRequest WithName(string newName);
    public sealed virtual IRequest WithExpressionType(IType newType);
    public sealed virtual IRequest WithModule(IPsiModule psiModule);
    public sealed virtual IRequest WithNamespaces(IReadOnlyList`1<INamespace> newNamespaces);
    public sealed virtual IRequest WithTypes(IReadOnlyList`1<ITypeElement> newTypes);
    [NotNullAttribute]
private static IType RemoveArray(IArrayType arrayType);
    private static void CollectNonArrayBases(IType type, HashSet`1<IType> consumer);
    [NotNullAttribute]
[PureAttribute]
private List`1<IType> GetBaseTypes();
    private static void CollectBaseTypes(IType type, HashSet`1<IType> consumer);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExtensionMethods.ExtensionsImport : ValueType {
    [NotNullAttribute]
private IClrDeclaredElement mySource;
    [CompilerGeneratedAttribute]
private IUsingSymbolDirective <UsingDirective>k__BackingField;
    [CanBeNullAttribute]
public INamespace ImportedNamespace { get; }
    [CanBeNullAttribute]
public ITypeElement ImportedType { get; }
    [CanBeNullAttribute]
public IUsingSymbolDirective UsingDirective { get; }
    public ExtensionsImport(ITypeElement typeElement, IUsingSymbolDirective usingDirective);
    public ExtensionsImport(INamespace nameSpace, IUsingSymbolDirective usingDirective);
    public INamespace get_ImportedNamespace();
    public ITypeElement get_ImportedType();
    [CompilerGeneratedAttribute]
public IUsingSymbolDirective get_UsingDirective();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExtensionMethodsSymbolTableBuilder : object {
    [NotNullAttribute]
private IType myType;
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IReadOnlyList`1<IReadOnlyList`1<ExtensionsImport>> myExtensionImports;
    [NotNullAttribute]
private IExtensionMethodsQuery myQuery;
    [NotNullAttribute]
private IDependencyStore myDependencyStore;
    private CSharpLanguageLevel myLanguageLevel;
    [CanBeNullAttribute]
private IPsiSourceFile myPsiSourceFile;
    public ExtensionMethodsSymbolTableBuilder(ITreeNode element, IType type);
    [NotNullAttribute]
public ISymbolTable GetExtensionMethods();
    public void AddSolutionAnalysisDependencies(string shortName);
    public bool HasExtensionMethod(string shortName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ExtensionMethodsSymbolTableBuilder/<EnumerateExtensionMethods>d__11")]
[NotNullAttribute]
public IEnumerable`1<ISymbolTable> EnumerateExtensionMethods(string shortName);
    [CanBeNullAttribute]
private static string GetQualifyingExternAlias(IUsingDirective directive);
    [PureAttribute]
private bool IsExtensionMethodAccessible(IMethod method, string qualifyingExternAlias);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.AttributeConstantArgumentFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static AttributeConstantArgumentFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.BestFunctionMemberFilter : BetterMembersSelector`1<ApplicableCandidate> {
    private IPsiModule myModule;
    private IResolveContext myResolveContext;
    private CSharpLanguageLevel myLanguageLevel;
    private CSharpLanguageLevel myLatestSupportedLanguageLevel;
    internal BestFunctionMemberFilter(IPsiModule module, IResolveContext resolveContext, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    protected virtual OrderValues<ApplicableCandidate> IsBetterCandidate(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.BestOperatorFilter : BetterMembersSelector`1<ApplicableCandidate> {
    private IPsiModule myModule;
    private IResolveContext myResolveContext;
    private CSharpLanguageLevel myLanguageLevel;
    private CSharpLanguageLevel myLatestSupportedLanguageLevel;
    public BestOperatorFilter(IPsiModule module, IResolveContext resolveContext, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    protected virtual OrderValues<ApplicableCandidate> IsBetterCandidate(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private int IsBetterOperator(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private int NotLiftedOperatorIsBetter(IParametersOwner candidate1, IParametersOwner candidate2);
    [CompilerGeneratedAttribute]
internal static int <IsBetterOperator>g__TryGetPriority|6_0(ApplicableCandidate candidate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.BumpPrimaryParametersAboveMembersFilter : object {
    private static ISymbolFilter ourBumpParametersFilter;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static BumpPrimaryParametersAboveMembersFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
    [PureAttribute]
public static ISymbolFilter GetIfNeeded(ITreeNode ownerExpression);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CollectionAddFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    private static CollectionAddFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CollectionElementInitializerFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    private static CollectionElementInitializerFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.ConstantOrContainsConstantSymbolsCompletionFilter : SimpleSymbolFilter {
    private bool myInAttribute;
    [NotNullAttribute]
public static SimpleSymbolFilter InAttribute;
    [NotNullAttribute]
public static SimpleSymbolFilter InConstants;
    public ResolveErrorType ErrorType { get; }
    private ConstantOrContainsConstantSymbolsCompletionFilter(bool inAttribute);
    private static ConstantOrContainsConstantSymbolsCompletionFilter();
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    [PureAttribute]
public static bool IsConstantMember(IDeclaredElement declaredElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpAttributeFilter : object {
    public static ISymbolFilter Instance;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static CSharpAttributeFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpConstructorAccessRightsFilter : AccessRightsFilter {
    public CSharpConstructorAccessRightsFilter(IAccessContext context);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpDestructorsFilter : SimpleSymbolFilter {
    public static CSharpDestructorsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static CSharpDestructorsFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpInitializerReferenceFilter : InitializerReferenceFilter {
    public CSharpInitializerReferenceFilter(IAccessContext context, ITreeNode element);
    protected virtual IDeclaredElement GetInitializerOwner(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpMemberFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static CSharpMemberFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static CSharpMemberFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpMethodGroupConvertibleFilter : SimpleSymbolFilter {
    [NotNullAttribute]
private DeclaredElementInstance`1<IDelegate> myExpectedDelegate;
    [NotNullAttribute]
private ITreeNode myNode;
    public ResolveErrorType ErrorType { get; }
    public CSharpMethodGroupConvertibleFilter(DeclaredElementInstance`1<IDelegate> expectedType, ITreeNode node);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpPropertyExpectedFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static CSharpPropertyExpectedFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static CSharpPropertyExpectedFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpTypeOrNamespaceFilter : object {
    public static CSharpTypeOrNamespaceFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static CSharpTypeOrNamespaceFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.CSharpValidNamesFilter : ValidNamesFilter {
    [NotNullAttribute]
public static CSharpValidNamesFilter INSTANCE;
    private static CSharpValidNamesFilter();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.EliminateIndexerFilter : SimpleSymbolFilter {
    public static EliminateIndexerFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static EliminateIndexerFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.EnumInitializerFilter : object {
    [CompilerGeneratedAttribute]
private IEnum <enumType>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public EnumInitializerFilter(IEnum enumType);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.EventInitializerFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static EventInitializerFilter Instance;
    public ResolveErrorType ErrorType { get; }
    private static EventInitializerFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.EventOrBackingFieldFilter : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICSharpExpression <accessExpression>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    [NullableContextAttribute("2")]
public EventOrBackingFieldFilter(ICSharpExpression accessExpression);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    private static ISymbolInfo FindEvent(List`1<ISymbolInfo> data);
    private static ISymbolInfo FindBackingField(List`1<ISymbolInfo> data);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.ExactAttributeNameFilter : SimpleSymbolInfoFilter {
    [CompilerGeneratedAttribute]
private string <name>P;
    [NotNullAttribute]
private string myAttributeName;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    public ExactAttributeNameFilter(string name);
    public virtual bool Accepts(ISymbolInfo info);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.ExcludeParametersFilter : SimpleSymbolFilter {
    [CompilerGeneratedAttribute]
private IParametersOwner <containingParametersOwner>P;
    public ResolveErrorType ErrorType { get; }
    public ExcludeParametersFilter(IParametersOwner containingParametersOwner);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.ExcludeRecordCopyConstructor : SimpleSymbolFilter {
    [CompilerGeneratedAttribute]
private static ISymbolFilter <Instance>k__BackingField;
    [NotNullAttribute]
public static ISymbolFilter Instance { get; }
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static ExcludeRecordCopyConstructor();
    [CompilerGeneratedAttribute]
public static ISymbolFilter get_Instance();
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.ExplicitTypeArgumentsFilter : object {
    [CompilerGeneratedAttribute]
private IList`1<IType> <typeArguments>P;
    [CompilerGeneratedAttribute]
private Func`2<ITypeParametersOwner, bool> <elementAccepted>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ExplicitTypeArgumentsFilter(IList`1<IType> typeArguments, Func`2<ITypeParametersOwner, bool> elementAccepted);
    public ExplicitTypeArgumentsFilter(IList`1<IType> typeArguments);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.ExternAliasFilter : SimpleSymbolInfoFilter {
    [CompilerGeneratedAttribute]
private IPsiModule <module>P;
    private string myQualifyingAlias;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    public ExternAliasFilter(IPsiModule module, string qualifyingAliasName);
    private static bool CheckModuleReference(IPsiModuleReference moduleReference, string alias, bool isGlobal);
    public virtual bool Accepts(ISymbolInfo info);
    [CanBeNullAttribute]
private static string GetQualifyingAliasFromUsingDirective(ISymbolInfo symbolInfo);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
    [CompilerGeneratedAttribute]
private IPsiModuleReference <Accepts>b__4_0(IAssemblyPsiModule m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.FileLocalTypesCompletionFilter : object {
    [CompilerGeneratedAttribute]
private IPsiSourceFile <sourceFile>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public FileLocalTypesCompletionFilter(IPsiSourceFile sourceFile);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.FileLocalTypesFilter : object {
    [CompilerGeneratedAttribute]
private IPsiSourceFile <sourceFile>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public FileLocalTypesFilter(IPsiSourceFile sourceFile);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.GenericSimpleFilter`1 : object {
    public bool MustRun { get; }
    public ResolveErrorType ErrorType { get; }
    public virtual bool get_MustRun();
    public IList`1<T> FilterArray(IList`1<T> data);
    public abstract virtual bool Accepts(T candidate);
    public abstract virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.HasNonExtensionParametersFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static HasNonExtensionParametersFilter();
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.ImportedElementsForUnqualifiedReferenceExpressionFilter : object {
    [NotNullAttribute]
private IResolveContext myResolveContext;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ImportedElementsForUnqualifiedReferenceExpressionFilter(IResolveContext resolveContext);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    [PureAttribute]
internal static bool IsInsideVariableInitializer(IDeclaredElement variable, ITreeNode expression);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IndexedPropertyWithAllOptionalParametersFilter : SimpleSymbolFilter {
    public static IndexedPropertyWithAllOptionalParametersFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static IndexedPropertyWithAllOptionalParametersFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IndexerThatCanBeInitializerFilter : SimpleSymbolFilter {
    [NotNullAttribute]
private ITreeNode myContext;
    public ResolveErrorType ErrorType { get; }
    public IndexerThatCanBeInitializerFilter(ITreeNode context);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsAliasFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static IsAliasFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static IsAliasFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsByRangeIndexerFilter : SimpleSymbolFilter {
    public static IsByRangeIndexerFilter INSTANCE;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    private static IsByRangeIndexerFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsCSharpPropertyFilter : SimpleSymbolFilter {
    public static IsCSharpPropertyFilter INSTANCE;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    private static IsCSharpPropertyFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsFunctionMemberFilter : SimpleSymbolFilter {
    private IResolveContext myResolveContext;
    private bool myPreOverrideByName;
    private ITreeNode myElement;
    public ResolveErrorType ErrorType { get; }
    public IsFunctionMemberFilter(IResolveContext resolveContext, bool preOverrideByName, ITreeNode element);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    private bool IsEnclosingVarVariable(IDeclaredElement declaredElement);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsGlobalAliasFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static IsGlobalAliasFilter INSTANCE;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    private static IsGlobalAliasFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsIndexerFilter : SimpleSymbolFilter {
    private CSharpLanguageLevel myLanguageLevel;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public IsIndexerFilter(CSharpLanguageLevel languageLevel);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsLabelFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static IsLabelFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsNamedElementFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static IsNamedElementFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static IsNamedElementFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsNotGlobalAliasFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static IsNotGlobalAliasFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static IsNotGlobalAliasFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsNotLabelFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static IsNotLabelFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsNotTransparentSymbolAliasFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static IsNotTransparentSymbolAliasFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static IsNotTransparentSymbolAliasFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.IsSignOperatorFilter : SimpleSymbolFilter {
    public static IsSignOperatorFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static IsSignOperatorFilter();
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.LiftedOperatorsFilter : object {
    public static LiftedOperatorsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public bool MustRun { get; }
    private static LiftedOperatorsFilter();
    public IList`1<ApplicableCandidate> FilterArray(IList`1<ApplicableCandidate> candidates);
    public ResolveErrorType get_ErrorType();
    public bool get_MustRun();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.MethodAmbiguityFilter : object {
    public static MethodAmbiguityFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static MethodAmbiguityFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.NameofInvocableMemberFilter : SimpleSymbolFilter {
    private static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static NameofInvocableMemberFilter();
    [NotNullAttribute]
public static ISymbolFilter Create(string name, IAccessContext accessContext);
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.OperatorHalfApplicableFilter : GenericSimpleFilter`1<CandidateWithResolveContext> {
    private ITypeConversionRule myTypeConversionRule;
    public ResolveErrorType ErrorType { get; }
    public OperatorHalfApplicableFilter(ITypeConversionRule typeConversionRule);
    public virtual bool Accepts(CandidateWithResolveContext candidate);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.PatternMemberCompletionFilter : SimpleSymbolFilter {
    [NotNullAttribute]
private Predicate`1<ITypeElement> myTypeCheckPredicate;
    [NotNullAttribute]
private Predicate`1<ITypeMember> myConstantPredicate;
    public ResolveErrorType ErrorType { get; }
    public PatternMemberCompletionFilter(IType dispatchType);
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    [NotNullAttribute]
private static Predicate`1<ITypeElement> GetHaveCommonSubtypePredicate(IType type);
    [NotNullAttribute]
private static Predicate`1<ITypeMember> GetConstantMemberPredicate(IType type);
    [NotNullAttribute]
private static Predicate`1<ITypeElement> GetHaveCommonSubtypePredicate(ITypeElement typeElement, bool arrayElementTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.PredefinedOperatorFilter : GenericSimpleFilter`1<CandidateWithResolveContext> {
    private CSharpPredefined myPredefined;
    public ResolveErrorType ErrorType { get; }
    public PredefinedOperatorFilter(IPsiModule psiModule);
    public virtual bool Accepts(CandidateWithResolveContext candidate);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.PrimaryParametersFilter : object {
    private static ISymbolFilter ourMembersHidePrimaryParametersFilter;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static PrimaryParametersFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
    [PureAttribute]
public static ISymbolFilter Create(ITreeNode referenceNode);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.PropertyAssignmentFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter Instance;
    public ResolveErrorType ErrorType { get; }
    private static PropertyAssignmentFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.PropertyBetterThanIndexedProperty : object {
    public static PropertyBetterThanIndexedProperty INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static PropertyBetterThanIndexedProperty();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.PropertyInitializerFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static PropertyInitializerFilter Instance;
    public ResolveErrorType ErrorType { get; }
    private static PropertyInitializerFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.PropertyThatCanBeInitializedFilter : SimpleSymbolFilter {
    [NotNullAttribute]
private ICSharpTreeNode myContext;
    public ResolveErrorType ErrorType { get; }
    public PropertyThatCanBeInitializedFilter(ITreeNode context);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.ReferenceExpressionMemberFilter : CSharpMemberFilter {
    [NotNullAttribute]
public static ReferenceExpressionMemberFilter INSTANCE;
    private static ReferenceExpressionMemberFilter();
    [NotNullAttribute]
public static CSharpMemberFilter Create(CSharpLanguageLevel languageLevel);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.RemovePrimaryParametersFilter : object {
    [CompilerGeneratedAttribute]
private static ISymbolFilter <Instance>k__BackingField;
    public static ISymbolFilter Instance { get; }
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static RemovePrimaryParametersFilter();
    [CompilerGeneratedAttribute]
public static ISymbolFilter get_Instance();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.RemovePrimaryParametersFilterFromContainingTypes : object {
    private HashSet`1<IParameter> myContainingPrimaryParameters;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private RemovePrimaryParametersFilterFromContainingTypes(HashSet`1<IParameter> containingPrimaryParameters);
    public static ISymbolFilter Create(ITreeNode usageContext);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.StaticScopeLocalVariableFilter : SimpleSymbolFilter {
    [CompilerGeneratedAttribute]
private ICSharpClosure <staticScope>P;
    public ResolveErrorType ErrorType { get; }
    public StaticScopeLocalVariableFilter(ICSharpClosure staticScope);
    public static ISymbolFilter CreateOrEmpty(ITreeNode context);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.SubpatternMemberFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter Instance;
    public ResolveErrorType ErrorType { get; }
    private static SubpatternMemberFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.SubpatternPreferParameterFilter : object {
    public static ISymbolFilter Instance;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static SubpatternPreferParameterFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.TypeOrNamespaceOrAliasFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static TypeOrNamespaceOrAliasFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static TypeOrNamespaceOrAliasFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.UnnamedElementsFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static UnnamedElementsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static UnnamedElementsFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.UseLocalVariableBeforeDeclarationFilter : UseLocalVariableBeforeDeclarationFilterBase {
    protected bool IsCaseSensitive { get; }
    public ResolveErrorType ErrorType { get; }
    public UseLocalVariableBeforeDeclarationFilter(ITreeNode usage);
    protected virtual bool get_IsCaseSensitive();
    protected virtual ITreeNode GetDeclarationNode(IDeclaredElement element);
    protected virtual bool UsedBeforeDeclaration(ITreeNode declaration, PooledList`1& usagePathToRoot, PooledList`1& declarationPathToRoot);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.UseParametersBeforeMemberBodyFilter : SimpleSymbolFilter {
    private UsageInfo myUsageInfo;
    public ResolveErrorType ErrorType { get; }
    public UseParametersBeforeMemberBodyFilter(ITreeNode usage);
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.WithInitializerAssignmentMemberFilter : SimpleSymbolFilter {
    private bool myAllowAnonymousProperties;
    private static ISymbolFilter ourInstance90;
    private static ISymbolFilter ourInstance100;
    public ResolveErrorType ErrorType { get; }
    private WithInitializerAssignmentMemberFilter(bool allowAnonymousProperties);
    private static WithInitializerAssignmentMemberFilter();
    [PureAttribute]
public static ISymbolFilter GetForLanguage(CSharpLanguageLevel languageLevel);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Filters.WithInitializerAssignmentMemberThatCanBeInitializedFilter : SimpleSymbolFilter {
    [NotNullAttribute]
private IAccessContext myAccessContext;
    public ResolveErrorType ErrorType { get; }
    public WithInitializerAssignmentMemberThatCanBeInitializedFilter(IAccessContext accessContext);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
internal interface JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.ICSharpSpecialApplicabilityOperator {
    [CanBeNullAttribute]
public abstract virtual ApplicableCandidate IsApplicable(IResolveContext resolveContext, ISubstitution substitution, IList`1<ICSharpArgumentInfo> arguments, IList`1<IExpressionType> argumentTypes, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, IPsiModule module, CandidateWithResolveContext& candidate);
    public abstract virtual bool IsApplicable(ISubstitution substitution, IList`1<IExpressionType> argumentTypes, IPsiModule module);
}
[RequiredMemberAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Invocation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccessContext <AccessContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolFilter[] <PreInvocationFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolTable <SymbolTable>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IType> <TypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpArgumentInfo <ExtensionArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IList`1<ICSharpArgumentInfo>, IArgumentsMatcher> <ArgumentsMatcherCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectionExpressionAddResolve>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolFilter[] <AdditionalExtensionSymbolFilters>k__BackingField;
    [RequiredMemberAttribute]
[NotNullAttribute]
public string Name { get; public set; }
    [RequiredMemberAttribute]
[NotNullAttribute]
public IResolveContext ResolveContext { get; public set; }
    [RequiredMemberAttribute]
[NotNullAttribute]
public ITreeNode Context { get; public set; }
    [RequiredMemberAttribute]
[NotNullAttribute]
public IAccessContext AccessContext { get; public set; }
    [RequiredMemberAttribute]
[NotNullAttribute]
public ISymbolFilter[] PreInvocationFilters { get; public set; }
    [RequiredMemberAttribute]
[NotNullAttribute]
public ISymbolTable SymbolTable { get; public set; }
    [RequiredMemberAttribute]
[NotNullAttribute]
public IList`1<IType> TypeArguments { get; public set; }
    [RequiredMemberAttribute]
[NotNullAttribute]
public IList`1<ICSharpArgumentInfo> Arguments { get; public set; }
    [CanBeNullAttribute]
public ICSharpArgumentInfo ExtensionArgument { get; public set; }
    [CanBeNullAttribute]
public Func`2<IList`1<ICSharpArgumentInfo>, IArgumentsMatcher> ArgumentsMatcherCreator { get; public set; }
    public bool CollectionExpressionAddResolve { get; public set; }
    public ISymbolFilter[] AdditionalExtensionSymbolFilters { get; public set; }
    private bool IsDynamicDispatch { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public IResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResolveContext(IResolveContext value);
    [CompilerGeneratedAttribute]
public ITreeNode get_Context();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Context(ITreeNode value);
    [CompilerGeneratedAttribute]
public IAccessContext get_AccessContext();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AccessContext(IAccessContext value);
    [CompilerGeneratedAttribute]
public ISymbolFilter[] get_PreInvocationFilters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreInvocationFilters(ISymbolFilter[] value);
    [CompilerGeneratedAttribute]
public ISymbolTable get_SymbolTable();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SymbolTable(ISymbolTable value);
    [CompilerGeneratedAttribute]
public IList`1<IType> get_TypeArguments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeArguments(IList`1<IType> value);
    [CompilerGeneratedAttribute]
public IList`1<ICSharpArgumentInfo> get_Arguments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Arguments(IList`1<ICSharpArgumentInfo> value);
    [CompilerGeneratedAttribute]
public ICSharpArgumentInfo get_ExtensionArgument();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtensionArgument(ICSharpArgumentInfo value);
    [CompilerGeneratedAttribute]
public Func`2<IList`1<ICSharpArgumentInfo>, IArgumentsMatcher> get_ArgumentsMatcherCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ArgumentsMatcherCreator(Func`2<IList`1<ICSharpArgumentInfo>, IArgumentsMatcher> value);
    [CompilerGeneratedAttribute]
public bool get_CollectionExpressionAddResolve();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollectionExpressionAddResolve(bool value);
    [CompilerGeneratedAttribute]
public ISymbolFilter[] get_AdditionalExtensionSymbolFilters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AdditionalExtensionSymbolFilters(ISymbolFilter[] value);
    private bool get_IsDynamicDispatch();
    [NotNullAttribute]
public ResolveResultWithInfo Resolve();
    private bool CheckForArrayLength(string name, ResolveResultWithInfo& resolveResult);
    private ResolveResultWithInfo ResolveExtensionMethodPossibly(OverloadResolutionResult overloadResolutionResult);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.LambdaUtil : object {
    public static IType GetLambdaParameterMultitype(IPsiModule module, IType targetDelegateType, int parameterIndex);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.MethodChooser : object {
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private MethodGroupResolveResult myMethodGroup;
    [NotNullAttribute]
private ResolveErrorType myPreResolveError;
    [NotNullAttribute]
private string myShortName;
    [CanBeNullAttribute]
private ICSharpArgumentInfo myExtensionArgument;
    [NotNullAttribute]
private IAccessContext myAccessContext;
    private IList`1<IType> myTypeArguments;
    [NotNullAttribute]
private ITreeNode myContext;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <LanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <LatestSupportedLanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNaturalType>k__BackingField;
    public bool IsNonCacheableChooser { get; }
    public string MethodShortName { get; }
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public CSharpLanguageLevel LatestSupportedLanguageLevel { get; }
    public bool HasNaturalType { get; }
    public MethodChooser(IResolveContext resolveContext, MethodGroupResolveResult methodGroup, ResolveErrorType preResolveError, string shortName, ICSharpArgumentInfo extensionArgument, IAccessContext accessContext, IList`1<IType> typeArguments, ITreeNode context, bool hasNaturalType);
    public bool get_IsNonCacheableChooser();
    [NotNullAttribute]
public ResolveResultWithInfo Choose(IDelegate delegate, ISubstitution substitution);
    [NotNullAttribute]
public ResolveResultWithInfo Choose(IFunctionPointerType functionPointerType);
    [NotNullAttribute]
public ResolveResultWithInfo Choose(IList`1<ICSharpArgumentInfo> arguments);
    [NotNullAttribute]
public ISymbolTable GetMethodSymbolTable();
    public bool IsValid();
    public bool HasApplicableMethod(IDelegate delegate, ISubstitution substitution);
    public bool HasApplicableMethod(IFunctionPointerType functionPointerType);
    private bool HasApplicableMethod(IList`1<ICSharpArgumentInfo> arguments, Func`2<IList`1<ICSharpArgumentInfo>, IArgumentsMatcher> argumentsMatcherFactory);
    [NotNullAttribute]
[PureAttribute]
public ResolveResultWithInfo ConvertToSystemDelegate();
    [NotNullAttribute]
[PureAttribute]
private ResolveResultWithInfo ConvertToSystemDelegate_CSharp10();
    private bool VerifyTypeArgumentConstraints(ICSharpTypeConstraintsVerifier& typeConstraintsVerifier, ITypeParametersOwner typeParametersOwner, ISubstitution substitution);
    public string get_MethodShortName();
    [NotNullAttribute]
public IPsiServices GetPsiServices();
    public IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public CSharpLanguageLevel get_LanguageLevel();
    [CompilerGeneratedAttribute]
public CSharpLanguageLevel get_LatestSupportedLanguageLevel();
    [CompilerGeneratedAttribute]
public bool get_HasNaturalType();
    [CompilerGeneratedAttribute]
private IArgumentsMatcher <Choose>b__13_0(IList`1<ICSharpArgumentInfo> args);
    [CompilerGeneratedAttribute]
private void <ConvertToSystemDelegate_CSharp10>g__AppendReducedExtensionMethods|20_1(BestDeclaredElementCandidate& bestCandidate, PooledDeclaredElementCandidates& candidates, PooledDeclaredElementCandidates& candidatesWithWrongArity, <>c__DisplayClass20_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.MethodGroupResolveResult : object {
    [CompilerGeneratedAttribute]
private IList`1<ISymbolInfo> <SymbolInfos>k__BackingField;
    public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public IList`1<IDeclaredElement> Candidates { get; }
    public IList`1<ISubstitution> CandidateSubstitutions { get; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
public IList`1<ISymbolInfo> SymbolInfos { get; }
    public MethodGroupResolveResult(IMethod method, ISubstitution substitution);
    public MethodGroupResolveResult(ILocalFunction localFunction, ISubstitution substitution);
    public MethodGroupResolveResult(IList`1<ISymbolInfo> symbolInfos);
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual ISubstitution get_Substitution();
    public sealed virtual IList`1<IDeclaredElement> get_Candidates();
    public sealed virtual IList`1<ISubstitution> get_CandidateSubstitutions();
    public sealed virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public sealed virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
    public sealed virtual bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public IList`1<ISymbolInfo> get_SymbolInfos();
    public sealed virtual bool IsValid();
    public sealed virtual string Dump();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.NamedTypeArgumentInfo : TypeArgumentInfo {
    [CompilerGeneratedAttribute]
private string <ArgumentName>k__BackingField;
    public bool IsNamedArgument { get; }
    [NotNullAttribute]
public string ArgumentName { get; }
    public NamedTypeArgumentInfo(string argumentName, IExpressionType parameterType, ParameterKind parameterKind, bool isExtension, ICSharpInvocationInfo invocation);
    public virtual bool get_IsNamedArgument();
    [CompilerGeneratedAttribute]
public virtual string get_ArgumentName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.OperatorProcessor : object {
    [NotNullAttribute]
public static IOverloadResolutionData GetInstance(IList`1<ICSharpArgumentInfo> arguments, IPsiModule module, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.OverloadResolutionUtil : object {
    public static IReadOnlyList`1<IType> GetParameterTypesFromDelegate(IDelegate delegate, ISubstitution substitution);
    public static List`1<ValueTuple`2<IManagedVariable, IType>> BuildAssumptions(IPsiModule module, IReadOnlyList`1<IType> parameterTypes, IReadOnlyList`1<IParameter> implicitLambdaParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.PatternAccessContext : object {
    private ITreeNode myContext;
    private IType myDispatchType;
    public PatternAccessContext(ITreeNode context, IType dispatchType);
    [NullableContextAttribute("2")]
public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    [NullableContextAttribute("2")]
public sealed virtual IPsiSourceFile GetSourceFile();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    [NullableContextAttribute("2")]
public sealed virtual ITypeElement GetQualifierTypeElement();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.PatternPropertyOrClassPartialResult : ResolveResultWithSubstitution {
    private ResolveResultWithInfo myVariableResult;
    [NotNullAttribute]
private ResolveResultWithInfo myClassOrNmspResult;
    public PatternPropertyOrClassPartialResult(ResolveResultWithInfo variableResult, ResolveResultWithInfo classOrNmspResult);
    public ResolveResultWithInfo GetClassResult();
    [NotNullAttribute]
[PureAttribute]
public ResolveResultWithInfo GetVariableResult();
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.PropertyOrClassPartialResult : ResolveResultWithSubstitution {
    [NotNullAttribute]
private ResolveResultWithInfo myClassResult;
    public PropertyOrClassPartialResult(IDeclaredElement variable, ISubstitution substitution, ResolveResultWithInfo classResult);
    [NotNullAttribute]
[PureAttribute]
public ResolveResultWithInfo GetClassResult();
    [NotNullAttribute]
[PureAttribute]
public IResolveResult GetVariableResult();
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.SimpleArgumentInfoBase : object {
    [NotNullAttribute]
private ICSharpInvocationInfo myInvocation;
    public CSharpParameterInstance MatchingParameter { get; }
    private DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.MatchingParameter { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public bool IsNamedArgument { get; }
    public string ArgumentName { get; }
    public IPsiModule PsiModule { get; }
    public ICSharpInvocationInfo Invocation { get; }
    public ParameterKind Kind { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public IManagedConvertible ManagedConvertible { get; }
    protected SimpleArgumentInfoBase(ICSharpInvocationInfo invocation);
    public sealed virtual CSharpParameterInstance get_MatchingParameter();
    private sealed virtual override DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.get_MatchingParameter();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual bool get_IsNamedArgument();
    public sealed virtual string get_ArgumentName();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public sealed virtual ParameterKind get_Kind();
    public abstract virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public abstract virtual DocumentRange GetDocumentRange();
    public virtual bool IsValid();
    public abstract virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.TupleEqualityResolveUtil : object {
    [CanBeNullAttribute]
[ItemNotNullAttribute]
public static IReadOnlyList`1<IExpressionType> GetTupleComponentTypes(IExpressionType expressionType);
    [PureAttribute]
public static ValueTuple`2<IReadOnlyList`1<IExpressionType>, IReadOnlyList`1<IExpressionType>> GetTupleComponentTypes(IExpressionType leftOperand, IExpressionType rightOperand);
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<IExpressionType> InferDefaultLiteralComponentTypes(IReadOnlyList`1<IExpressionType> otherOperandComponentTypes);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.TypeArgumentInfo : object {
    [NotNullAttribute]
private IExpressionType myParameterType;
    [CanBeNullAttribute]
private ICSharpInvocationInfo myInvocation;
    private ParameterKind myParameterKind;
    private bool myIsExtension;
    public ParameterKind Kind { get; }
    public IManagedConvertible ManagedConvertible { get; }
    public CSharpParameterInstance MatchingParameter { get; }
    private DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.MatchingParameter { get; }
    public ICSharpInvocationInfo Invocation { get; }
    public bool IsNamedArgument { get; }
    public string ArgumentName { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public IPsiModule PsiModule { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public TypeArgumentInfo(IExpressionType parameterType, ParameterKind parameterKind, bool isExtension, ICSharpInvocationInfo invocation);
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual CSharpParameterInstance get_MatchingParameter();
    private sealed virtual override DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.get_MatchingParameter();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public virtual bool get_IsNamedArgument();
    public virtual string get_ArgumentName();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual DocumentRange GetDocumentRange();
    public sealed virtual bool IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.AccessorAvailabilityVerifier : object {
    [NotNullAttribute]
private static object PROBLEM;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static AccessorAvailabilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    public static Result Verify(ICSharpTreeNode propertyAccessNode, IManagedReference reference, IResolveContext resolveContext);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.AnonymousFunctionSignatureCompatibilityVerifier : object {
    private static object SCOPED_PARAMETER_MISMATCH;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static AnonymousFunctionSignatureCompatibilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ArrayInitializerTypeCompatibilityVerifier : TypeCompatibilityVerifier {
    public IEnumerable`1<NodeType> Nodes { get; }
    public virtual IEnumerable`1<NodeType> get_Nodes();
    public virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.AsExpressionVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static AsExpressionVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.AssignmentTypeCompatibilityVerifier : TypeCompatibilityVerifier {
    public IEnumerable`1<NodeType> Nodes { get; }
    public virtual IEnumerable`1<NodeType> get_Nodes();
    public virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.AwaitVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static AwaitVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.CastExpressionVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static CastExpressionVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.CollectionExpressionCreationVerifier : object {
    private static object PROBLEM;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static CollectionExpressionCreationVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ConditionalTernaryExpressionVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ConditionalTernaryExpressionVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ConditionExpressionVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ConditionExpressionVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    [PureAttribute]
[CanBeNullAttribute]
private static ICSharpExpression GetCondition(ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.DeconstructionPatternClauseVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static DeconstructionPatternClauseVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ExtensionMethodsAvailabilityVerifier : object {
    private static object VALUE_TYPE_QUALIFIER;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ExtensionMethodsAvailabilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.FieldMutabilityVerifier : object {
    [NotNullAttribute]
private static object PROBLEM;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static FieldMutabilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    [CanBeNullAttribute]
private static object Verify(IReferenceExpression referenceExpression, IResolveContext resolveContext);
    [CanBeNullAttribute]
private static object Verify(IPropertyInitializer propertyInitializer, IResolveContext resolveContext);
    [CanBeNullAttribute]
private static object Verify(IWithInitializerAssignment withInitializerAssignment, IResolveContext resolveContext, bool doNotCheckResolve);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ForeachStatementVerifier : TypeCompatibilityVerifier {
    public IEnumerable`1<NodeType> Nodes { get; }
    public virtual IEnumerable`1<NodeType> get_Nodes();
    public virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    private object VerifyReferences(IResolveContext resolveContext, IForeachStatement foreachStatement);
    private object VerifyIterationVariableTypeCompatibilityWithCollection(IForeachStatement foreachStatement, IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ImplicitVariableDeclarationVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ImplicitVariableDeclarationVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.IndexerInitializerTypeCompatibilityVerifier : TypeCompatibilityVerifier {
    public IEnumerable`1<NodeType> Nodes { get; }
    public virtual IEnumerable`1<NodeType> get_Nodes();
    public virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.IndexFromEndExpressionVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static IndexFromEndExpressionVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.InterpolatedStringExpressionVerifier : object {
    private static object NOT_RESOLVED;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static InterpolatedStringExpressionVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.InvocationResolveVerifier : object {
    private static object NOT_RESOLVED;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static InvocationResolveVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ListPatternVerifier : object {
    private static object PROBLEM;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ListPatternVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.LockStatementVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static LockStatementVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ObjectCreationExpressionVerifier : object {
    [NotNullAttribute]
private static object PROBLEM;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ObjectCreationExpressionVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ObjectInitializerTypeCompatibilityVerifier : TypeCompatibilityVerifier {
    public IEnumerable`1<NodeType> Nodes { get; }
    public virtual IEnumerable`1<NodeType> get_Nodes();
    public virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ParenthesizedVariableDesignationVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ParenthesizedVariableDesignationVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ParenthesizeLambdaExpressionIsNotVoidVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ParenthesizeLambdaExpressionIsNotVoidVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VerifierAttribute("16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.PatternTypeCompatibilityVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static PatternTypeCompatibilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    [CompilerGeneratedAttribute]
internal static object <Verify>g__AnalyzeTypeCheck|3_0(IResolveContext resolveContext, IPattern typeCheckPattern);
    [CompilerGeneratedAttribute]
internal static object <Verify>g__AnalyzeConstantCheck|3_1(IResolveContext resolveContext, ConstantValue constantValue, IPattern constantPattern);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static object <Verify>g__Check|3_2(TypeCheckStaticAnalysisResult analysisResult);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.RangeExpressionVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static RangeExpressionVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    [CompilerGeneratedAttribute]
internal static object <Verify>g__VerifyOperandConversion|3_0(ICSharpExpression operand, <>c__DisplayClass3_0& );
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ReferenceExpressionResolveVerifier : object {
    private static object NOT_RESOLVED;
    private static object MULTITYPE;
    private static object SCOPED_MISMATCH;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ReferenceExpressionResolveVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.SatisfyConstraintsVerifier : object {
    public IEnumerable`1<NodeType> Nodes { get; }
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.SlicePatternVerifier : object {
    private static object PROBLEM;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static SlicePatternVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.StaticVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static StaticVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.ThrowVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ThrowVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    [CanBeNullAttribute]
[PureAttribute]
private static ICSharpExpression GetException(ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.TupleExpressionVerifier : TypeCompatibilityVerifier {
    public IEnumerable`1<NodeType> Nodes { get; }
    public virtual IEnumerable`1<NodeType> get_Nodes();
    public virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    [CompilerGeneratedAttribute]
internal static IType <Verify>g__GetSingleVariableDesignationType|2_0(ITupleComponent tupleComponent, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <Verify>g__CheckCompatibilityWithTupleType|2_1(DecoratedType`1<TupleTypeDecoration> tupleType, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <Verify>g__CheckCompatibilityWithTupleExpressionType|2_2(ITupleExpressionType tupleExpressionType, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <Verify>g__CheckCompatibilityWithParameters|2_3(IMethod deconstructMethod, <>c__DisplayClass2_0& );
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.TypeCompatibilityVerifier : object {
    protected static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static TypeCompatibilityVerifier();
    public abstract virtual IEnumerable`1<NodeType> get_Nodes();
    public abstract virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    protected static object Check(IType leftType, IExpressionType rightType, ICSharpTreeNode node);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.UsingVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static UsingVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.VariableDeclarationTypeCompatibilityVerifier : TypeCompatibilityVerifier {
    public IEnumerable`1<NodeType> Nodes { get; }
    public virtual IEnumerable`1<NodeType> get_Nodes();
    public virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.WithAvailabilityVerifier : object {
    private static object PROBLEM;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static WithAvailabilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
    public static bool CheckOperandType(IWithExpression withExpression, IResolveContext resolveContext);
}
[VerifierAttribute("16")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Resolve.Verification.WithInitializerAssignmentTypeCompatibilityVerifier : TypeCompatibilityVerifier {
    public IEnumerable`1<NodeType> Nodes { get; }
    public virtual IEnumerable`1<NodeType> get_Nodes();
    public virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AccessorDeclaration : AccessorDeclarationStub {
    public virtual IBlock SetBody(IBlock param);
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AccessorDeclarationStub : ProperTypeMemberDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short IDENTIFIER;
    public static short CSHARP_BLOCK;
    public static short ARROW_CLAUSE;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IBlock Body { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IModifiersList OwnModifiersList { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public string DeclaredName { get; }
    private IAccessor JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public int LevelDelta { get; }
    public bool IsAuto { get; }
    public AccessorKind Kind { get; }
    public CSharpAccessorKind CSharpKind { get; }
    public bool IsInitOnly { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    [NotNullAttribute]
private ICSharpTypeMemberDeclaration OwnerDeclaration { get; }
    public bool IsStatic { get; }
    public bool IsUnsafe { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsExtern { get; }
    public bool IsVolatile { get; }
    public IModifiersList ModifiersList { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IBlock get_Body();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IModifiersList get_OwnModifiersList();
    public virtual ITokenNode get_Semicolon();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IBlock SetBody(IBlock param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IModifiersList SetOwnModifiersList(IModifiersList param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    private sealed virtual override IAccessor JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    protected internal virtual string GetShortNameOfDeclaredElement();
    [NotNullAttribute]
internal string ConstructName(string propertyName);
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual bool get_IsAuto();
    public sealed virtual AccessorKind get_Kind();
    public sealed virtual CSharpAccessorKind get_CSharpKind();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsync();
    public virtual void SetAbstract(bool value);
    public virtual void SetSealed(bool value);
    public virtual void SetVirtual(bool value);
    public virtual void SetOverride(bool value);
    public virtual void SetStatic(bool value);
    public virtual void SetExtern(bool value);
    public virtual void SetUnsafe(bool value);
    public virtual void SetVolatile(bool value);
    private ICSharpTypeMemberDeclaration get_OwnerDeclaration();
    public virtual AccessRights GetAccessRights();
    public virtual bool get_IsStatic();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsExtern();
    public virtual bool get_IsVolatile();
    public sealed virtual IModifiersList SetModifiersList(IModifiersList modifiersList);
    public sealed virtual IModifiersList get_ModifiersList();
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AdditiveExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AddReferenceBase`1 : ManagedCheckedReferenceBase`1<T> {
    private static string NAME;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public ICSharpInvocationInfo Invocation { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    public ICSharpInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    protected AddReferenceBase`1(T owner);
    public abstract virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    public abstract virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public virtual ISymbolFilter[] GetSymbolFilters(IResolveContext resolveContext);
    protected ResolveResultWithInfo ResolveImpl(IResolveContext resolveContext, IType targetType);
    public virtual string GetName();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual TreeTextRange GetTreeTextRange();
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AllowsRefStructConstraint : CSharpCompositeElement {
    public static short KEYWORD;
    public static short REF_KEYWORD;
    public static short STRUCT_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode AllowsKeyword { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode StructKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AllowsKeyword();
    public virtual ITokenNode get_RefKeyword();
    public virtual ITokenNode get_StructKeyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AndPattern : CSharpCompositeElement {
    public static short PATTERN_OP1;
    public static short AND_KEYWORD;
    public static short PATTERN_OP2;
    public NodeType NodeType { get; }
    public ITokenNode AndKeyword { get; }
    public IPattern LeftPattern { get; }
    public IPattern RightPattern { get; }
    private ITokenNode JetBrains.ReSharper.Psi.CSharp.Tree.IBinaryPattern.Keyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AndKeyword();
    public virtual IPattern get_LeftPattern();
    public virtual IPattern get_RightPattern();
    public virtual IPattern SetLeftPattern(IPattern param);
    public virtual IPattern SetRightPattern(IPattern param);
    public virtual string ToString();
    private sealed virtual override ITokenNode JetBrains.ReSharper.Psi.CSharp.Tree.IBinaryPattern.get_Keyword();
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AnonymousMemberDeclaration : CSharpCompositeElement {
    public static short CSHARP_REFERENCE;
    public static short CSHARP_EQ;
    public static short CSHARP_OP2;
    [CanBeNullAttribute]
private MyReference modreq(System.Runtime.CompilerServices.IsVolatile) myReference;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    public ICSharpIdentifier NameIdentifierInternal { get; }
    public ITokenNode Operator { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IReference ReferenceToProperty { get; }
    public bool IsProjectionInitializer { get; }
    [CanBeNullAttribute]
private ICSharpIdentifier ProjectedIdentifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ICSharpIdentifier get_NameIdentifierInternal();
    public virtual ITokenNode get_Operator();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IReference get_ReferenceToProperty();
    public sealed virtual bool get_IsProjectionInitializer();
    private ICSharpIdentifier get_ProjectedIdentifier();
    public sealed virtual TreeTextRange GetNameTextRange();
    public sealed virtual DocumentRange GetNameDocumentRange();
    public sealed virtual IAnonymousMemberDeclaration ReplaceBy(IAnonymousMemberDeclaration newMember);
    public sealed virtual string GetName();
    public sealed virtual void SetName(string name);
    [CanBeNullAttribute]
public sealed virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier newIdentifier);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AnonymousMethodExpression : CSharpExpressionBase {
    public static short ASYNC;
    public static short STATIC;
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public static short CSHARP_BLOCK;
    private CachedPsiValue`1<IType> myCachedAnnotatedInferredReturnType;
    public NodeType NodeType { get; }
    public ITokenNode AsyncKeyword { get; }
    public IBlock Body { get; }
    public ITokenNode DelegateKeyword { get; }
    public ITokenNode LPar { get; }
    public ILocalFormalParameterList ParameterList { get; }
    public ITokenNode RPar { get; }
    public ITokenNode StaticKeyword { get; }
    public TreeNodeCollection`1<ILocalParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public bool IsAsync { get; }
    public bool IsStatic { get; }
    public IType InferredReturnType { get; }
    private IType JetBrains.ReSharper.Psi.IParametersOwner.ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    private TreeNodeEnumerable`1<ICSharpParameterDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.ParameterDeclarationsEnumerable { get; }
    private TreeNodeCollection`1<ICSharpParameterDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.ParameterDeclarations { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.Tree.IDeclaration.DeclaredElement { get; }
    public IParametersOwner DeclaredElement { get; }
    public string DeclaredName { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType AnnotatedInferredReturnType { get; public set; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsyncKeyword();
    public virtual IBlock get_Body();
    public virtual ITokenNode get_DelegateKeyword();
    public virtual ITokenNode get_LPar();
    public virtual ILocalFormalParameterList get_ParameterList();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_StaticKeyword();
    public virtual TreeNodeCollection`1<ILocalParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ILocalParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IBlock SetBody(IBlock param);
    public virtual ILocalFormalParameterList SetParameterList(ILocalFormalParameterList param);
    public virtual string ToString();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual IType GetInferredReturnType(IResolveContext resolveContext);
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IType get_InferredReturnType();
    private sealed virtual override IType JetBrains.ReSharper.Psi.IParametersOwner.get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    private sealed virtual override TreeNodeEnumerable`1<ICSharpParameterDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_ParameterDeclarationsEnumerable();
    private sealed virtual override TreeNodeCollection`1<ICSharpParameterDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_ParameterDeclarations();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.Tree.IDeclaration.get_DeclaredElement();
    public sealed virtual IParametersOwner get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool IsSynthetic();
    public sealed virtual ILocalParameterDeclaration AddParameterDeclarationBefore(ILocalParameterDeclaration parameterDeclaration, ILocalParameterDeclaration anchor);
    public sealed virtual ILocalParameterDeclaration AddParameterDeclarationAfter(ILocalParameterDeclaration parameterDeclaration, ILocalParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual void RemoveParameterDeclaration(ILocalParameterDeclaration parameterDeclaration);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual void SetAsync(bool value);
    public sealed virtual void SetStatic(bool value);
    public sealed virtual IType get_AnnotatedInferredReturnType();
    public sealed virtual void set_AnnotatedInferredReturnType(IType value);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AnonymousObjectCreationExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short CSHARP_INITIALIZER;
    public NodeType NodeType { get; }
    public IAnonymousObjectInitializer AnonymousInitializer { get; }
    public ITokenNode NewKeyword { get; }
    public ICreationExpressionInitializer Initializer { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAnonymousObjectInitializer get_AnonymousInitializer();
    public virtual ITokenNode get_NewKeyword();
    public virtual IAnonymousObjectInitializer SetAnonymousInitializer(IAnonymousObjectInitializer param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual IList`1<AnonymousTypeDescriptor> GetTypeDescriptor();
    public sealed virtual IList`1<AnonymousTypeDescriptor> GetTypeDescriptor(IResolveContext resolveContext);
    public sealed virtual ICreationExpressionInitializer get_Initializer();
    public sealed virtual IType ExplicitType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AnonymousObjectInitializer : CreationExpressionInitializerBase {
    public static short CSHARP_LBRACE;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IAnonymousMemberDeclaration> MemberInitializers { get; }
    public TreeNodeEnumerable`1<IAnonymousMemberDeclaration> MemberInitializersEnumerable { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<IInitializerElement> InitializerElements { get; }
    public TreeNodeEnumerable`1<IInitializerElement> InitializerElementsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IAnonymousMemberDeclaration> get_MemberInitializers();
    public virtual TreeNodeEnumerable`1<IAnonymousMemberDeclaration> get_MemberInitializersEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual string ToString();
    public sealed virtual IAnonymousMemberDeclaration AddMemberInitializerAfter(IAnonymousMemberDeclaration memberDeclaration, IAnonymousMemberDeclaration anchor);
    public sealed virtual IAnonymousMemberDeclaration AddMemberInitializerBefore(IAnonymousMemberDeclaration param, IAnonymousMemberDeclaration anchor);
    public sealed virtual void RemoveMemberInitializer(IAnonymousMemberDeclaration memberDeclaration);
    public sealed virtual TreeNodeCollection`1<IInitializerElement> get_InitializerElements();
    public sealed virtual TreeNodeEnumerable`1<IInitializerElement> get_InitializerElementsEnumerable();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AnyArgumentAddReferenceBase`1 : ManagedCheckedReferenceBase`1<T> {
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public ICSharpInvocationInfo Invocation { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    protected AnyArgumentAddReferenceBase`1(T owner);
    public abstract virtual ICSharpArgumentInfo get_ExtensionQualifier();
    protected ResolveResultWithInfo ResolveImpl(IResolveContext resolveContext, IType type);
    public virtual ISymbolFilter[] GetSymbolFilters(IResolveContext resolveContext);
    public virtual string GetName();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ArglistExpression : CSharpExpressionBase {
    public static short ARGLIST_KEYWORD;
    public static short CSHARP_LPAR;
    public static short ARGUMENT_LIST;
    public static short CSHARP_RPAR;
    [CanBeNullAttribute]
private IReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode ArglistKeyword { get; }
    public IArgumentList ArgumentList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    [NotNullAttribute]
private IReference ArglistReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ArglistKeyword();
    public virtual IArgumentList get_ArgumentList();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    private IReference get_ArglistReference();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ArgumentList : CSharpCompositeElement {
    public static short CSHARP_ARGUMENT;
    public static short CSHARP_COMMA;
    private MyParamsDefaultConstructorReference myParamsDefaultConstructorReference;
    private MyParamsCreateMethodReference myParamsCreateMethodReference;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IConstructorInitializer ConstructorInitializerInternal { get; }
    public IElementAccessExpression ElementAccessExpressionInternal { get; }
    public IInvocationExpression InvocationExpressionInternal { get; }
    public IObjectCreationExpression ObjectCreationExpressionInternal { get; }
    public bool IntroducesScope { get; }
    public IReference ParamsDefaultConstructorReference { get; }
    public IReference ParamsCreateMethodReference { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual IConstructorInitializer get_ConstructorInitializerInternal();
    public virtual IElementAccessExpression get_ElementAccessExpressionInternal();
    public virtual IInvocationExpression get_InvocationExpressionInternal();
    public virtual IObjectCreationExpression get_ObjectCreationExpressionInternal();
    public virtual string ToString();
    public sealed virtual bool get_IntroducesScope();
    public virtual ReferenceCollection GetFirstClassReferences();
    protected virtual void PreInit();
    public sealed virtual IReference get_ParamsDefaultConstructorReference();
    public sealed virtual IReference get_ParamsCreateMethodReference();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    private static bool IsIgnoredParamsCollectionCreation(IArgumentList argumentList, IResolveContext resolveContext);
    private static TreeTextRange GetParamsTreeRange(IArgumentList argumentList);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ArrayCreationExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short CSHARP_TYPE;
    public static short CSHARP_LBRACKET;
    public static short EXPR;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACKET;
    public static short DIMENSION;
    public static short CSHARP_INITIALIZER;
    public NodeType NodeType { get; }
    public IArrayInitializer ArrayInitializer { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> DimInits { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> DimInitsEnumerable { get; }
    public TreeNodeCollection`1<IRankSpecifier> Dims { get; }
    public TreeNodeEnumerable`1<IRankSpecifier> DimsEnumerable { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode NewKeyword { get; }
    public ITokenNode RBracket { get; }
    public ITypeUsage TypeUsage { get; }
    public IReferenceName TypeName { get; }
    public bool IsImplicitlyTypedArray { get; }
    public Int32[] Dimensions { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] DimensionsWithNullableAnnotations { get; }
    public IList`1<ICSharpExpression> Sizes { get; }
    public ICreationExpressionInitializer Initializer { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayInitializer get_ArrayInitializer();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ICSharpExpression> get_DimInits();
    public virtual TreeNodeEnumerable`1<ICSharpExpression> get_DimInitsEnumerable();
    public virtual TreeNodeCollection`1<IRankSpecifier> get_Dims();
    public virtual TreeNodeEnumerable`1<IRankSpecifier> get_DimsEnumerable();
    public virtual ITokenNode get_LBracket();
    public virtual ITokenNode get_NewKeyword();
    public virtual ITokenNode get_RBracket();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IArrayInitializer SetArrayInitializer(IArrayInitializer param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IReferenceName get_TypeName();
    public sealed virtual bool get_IsImplicitlyTypedArray();
    public sealed virtual IType GetElementType();
    public sealed virtual IType GetElementType(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual Int32[] get_Dimensions();
    private ValueTuple`2[] get_DimensionsWithNullableAnnotations();
    public sealed virtual IList`1<ICSharpExpression> get_Sizes();
    public sealed virtual void SetArrayType(IArrayType arrayType);
    public sealed virtual void SetElementType(IType elementType);
    public sealed virtual void SetImplicitType();
    public sealed virtual ICreationExpressionInitializer get_Initializer();
    public sealed virtual IType ExplicitType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ArrayInitializer : CreationExpressionInitializerBase {
    public static short CSHARP_LBRACE;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IVariableInitializer> ElementInitializers { get; }
    public TreeNodeEnumerable`1<IVariableInitializer> ElementInitializersEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public TreeNodeCollection`1<IInitializerElement> InitializerElements { get; }
    public TreeNodeEnumerable`1<IInitializerElement> InitializerElementsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IVariableInitializer> get_ElementInitializers();
    public virtual TreeNodeEnumerable`1<IVariableInitializer> get_ElementInitializersEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual string ToString();
    public sealed virtual bool get_IntroducesScope();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    private static void CollectElementTypes(IResolveContext resolveContext, IArrayInitializer initializer, bool strict, List`1<IExpressionType> consumer);
    public sealed virtual IType GetElementType(bool strict);
    public sealed virtual IType GetElementType(IResolveContext resolveContext, bool strict);
    public sealed virtual IVariableInitializer AddElementInitializerAfter(IVariableInitializer initializer, IVariableInitializer anchor);
    public sealed virtual IVariableInitializer AddElementInitializerBefore(IVariableInitializer initializer, IVariableInitializer anchor);
    public sealed virtual void RemoveElementInitializer(IVariableInitializer initializer);
    public sealed virtual TreeNodeCollection`1<IInitializerElement> get_InitializerElements();
    public sealed virtual TreeNodeEnumerable`1<IInitializerElement> get_InitializerElementsEnumerable();
    public virtual IType GetConstructedType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ArrayTypeUsage : CSharpCompositeElement {
    public static short ELEMENT_TYPE;
    public static short RANK;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IRankSpecifier> ArrayRanks { get; }
    public TreeNodeEnumerable`1<IRankSpecifier> ArrayRanksEnumerable { get; }
    public ITypeUsage ElementType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IRankSpecifier> get_ArrayRanks();
    public virtual TreeNodeEnumerable`1<IRankSpecifier> get_ArrayRanksEnumerable();
    public virtual ITypeUsage get_ElementType();
    public virtual ITypeUsage SetElementType(ITypeUsage param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ArrowExpressionClause : CSharpCompositeElement {
    public static short LAMBDA_ARROW;
    public static short EXPR;
    private int myModificationStamp;
    public NodeType NodeType { get; }
    public ITokenNode BodyArrow { get; }
    public ICSharpExpression Expression { get; }
    private ITokenNode JetBrains.ReSharper.Psi.CSharp.Tree.IReturnValueHolder.ReturnKeyword { get; }
    private ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IReturnValueHolder.Value { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    private int JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope.LevelDelta { get; }
    private Nullable`1<int> JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.ModificationStamp { get; private set; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_BodyArrow();
    public virtual ICSharpExpression get_Expression();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    private sealed virtual override ITokenNode JetBrains.ReSharper.Psi.CSharp.Tree.IReturnValueHolder.get_ReturnKeyword();
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IReturnValueHolder.get_Value();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    private sealed virtual override int JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope.get_LevelDelta();
    private sealed virtual override Nullable`1<int> JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.get_ModificationStamp();
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.set_ModificationStamp(Nullable`1<int> value);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AsExpression : CSharpExpressionBase {
    public static short OP;
    public static short OP_SIGN;
    public static short CSHARP_OPERAND_TYPE;
    public NodeType NodeType { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public ITypeUsage TypeOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Operand();
    public virtual ITokenNode get_OperatorSign();
    public virtual ITypeUsage get_TypeOperand();
    public virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public virtual ITypeUsage SetTypeOperand(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AssignmentExpression : CSharpExpressionBase {
    public static short CSHARP_OP1;
    public static short ASSN_SIGN;
    public static short CSHARP_OP2;
    private BinaryOperatorReference myReference;
    public NodeType NodeType { get; }
    public ICSharpExpression Dest { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression Source { get; }
    public bool IsRefAssignment { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public IManagedReference Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public IOperatorReference OperatorReference { get; }
    public IList`1<ICSharpExpression> OperatorOperands { get; }
    public bool IsCompoundAssignment { get; }
    private bool IsRegularOrNullCoalesceAssignment { get; }
    public AssignmentType AssignmentType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Dest();
    public virtual ITokenNode get_OperatorSign();
    public virtual ICSharpExpression get_Source();
    public virtual ICSharpExpression SetDest(ICSharpExpression param);
    public virtual ICSharpExpression SetSource(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual bool get_IsRefAssignment();
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    protected virtual void PreInit();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
private ICSharpArgumentInfo[] GetArguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IOperatorReference get_OperatorReference();
    public sealed virtual IList`1<ICSharpExpression> get_OperatorOperands();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    [NotNullAttribute]
private IExpressionType GetNullCoalescingAssignmentExpressionType(ICSharpExpression leftExpression, ICSharpExpression rightExpression, IResolveContext resolveContext);
    public sealed virtual bool get_IsCompoundAssignment();
    private bool get_IsRegularOrNullCoalesceAssignment();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual AssignmentType get_AssignmentType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.Attribute : AttributeStub {
    public virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public virtual void RemoveArgument(ICSharpArgument argument);
    public virtual IPropertyAssignment AddPropertyAssignmentBefore(IPropertyAssignment propertyAssignment, IPropertyAssignment anchor);
    public virtual IPropertyAssignment AddPropertyAssignmentAfter(IPropertyAssignment propertyAssignment, IPropertyAssignment anchor);
    public virtual void RemovePropertyAssignment(IPropertyAssignment propertyAssignment);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AttributeList : CSharpCompositeElement {
    public static short ATTRIBUTE;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual string ToString();
    public sealed virtual IAttribute AddAttributeBefore(IAttribute param, IAttribute anchor);
    public sealed virtual IAttribute AddAttributeAfter(IAttribute param, IAttribute anchor);
    public sealed virtual void RemoveAttribute(IAttribute param);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AttributeSection : CSharpCompositeElement {
    public static short CSHARP_LBRACKET;
    public static short CSHARP_NAME;
    public static short CSHARP_COLON;
    public static short ATTRIBUTE_LIST;
    public static short CSHARP_RBRACKET;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public ITokenNode Colon { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ICSharpIdentifier TargetIdentifier { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public AttributeTarget Target { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual ITokenNode get_Colon();
    public virtual ITokenNode get_LBracket();
    public virtual ITokenNode get_RBracket();
    public virtual ICSharpIdentifier get_TargetIdentifier();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual ICSharpIdentifier SetTargetIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    public sealed virtual void RemoveAttribute(IAttribute attribute);
    public sealed virtual AttributeTarget get_Target();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AttributeSectionList : CSharpCompositeElement {
    public static short ATTRIBUTE_SECTION;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IAttributeSection> Sections { get; }
    public TreeNodeEnumerable`1<IAttributeSection> SectionsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IAttributeSection> get_Sections();
    public virtual TreeNodeEnumerable`1<IAttributeSection> get_SectionsEnumerable();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IAttributeSection AddSectionBefore(IAttributeSection section, IAttributeSection anchor);
    public sealed virtual IAttributeSection AddSectionAfter(IAttributeSection section, IAttributeSection anchor);
    public sealed virtual void RemoveSection(IAttributeSection section);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AttributesOwnerDeclarationBase : CSharpDeclarationBase {
    [NotNullAttribute]
public virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    [NotNullAttribute]
public virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    [NotNullAttribute]
public virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public virtual void RemoveAttribute(IAttribute attribute);
    public virtual bool IsSynthetic();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AttributeStub : CSharpCompositeElement {
    public static short CSHARP_REFERENCE;
    public static short CSHARP_LPAR;
    public static short CSHARP_ARGUMENT;
    public static short CSHARP_COMMA;
    public static short SPECIAL_ARGUMENT;
    public static short CSHARP_RPAR;
    private MyConstructorReference myReference;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public IReferenceName Name { get; }
    public TreeNodeCollection`1<IPropertyAssignment> PropertyAssignments { get; }
    public TreeNodeEnumerable`1<IPropertyAssignment> PropertyAssignmentsEnumerable { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ICSharpExpression> ConstructorArgumentExpressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ConstructorArgumentExpressionsEnumerable { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    public IReference ConstructorReference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public IReference TypeReference { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public AttributeTarget Target { get; }
    public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual IReferenceName get_Name();
    public virtual TreeNodeCollection`1<IPropertyAssignment> get_PropertyAssignments();
    public virtual TreeNodeEnumerable`1<IPropertyAssignment> get_PropertyAssignmentsEnumerable();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<ICSharpExpression> get_ConstructorArgumentExpressions();
    public virtual TreeNodeEnumerable`1<ICSharpExpression> get_ConstructorArgumentExpressionsEnumerable();
    public virtual IReferenceName SetName(IReferenceName param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual string Dump();
    public sealed virtual IManagedReference get_Reference();
    public sealed virtual IReference get_ConstructorReference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IReference get_TypeReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public abstract virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public abstract virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public abstract virtual void RemoveArgument(ICSharpArgument argument);
    public Hash AddToHash(Hash hash);
    public sealed virtual AttributeTarget get_Target();
    public abstract virtual IPropertyAssignment AddPropertyAssignmentBefore(IPropertyAssignment propertyAssignment, IPropertyAssignment anchor);
    public abstract virtual IPropertyAssignment AddPropertyAssignmentAfter(IPropertyAssignment propertyAssignment, IPropertyAssignment anchor);
    public abstract virtual void RemovePropertyAssignment(IPropertyAssignment propertyAssignment);
    public sealed virtual IList`1<ITokenNode> get_Delimiters();
    public sealed virtual ITokenNode get_LBound();
    public sealed virtual ITokenNode get_RBound();
    public sealed virtual void SetTarget(AttributeTarget target);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AwaiterGetResultReferenceBase`1 : InvocableAwaitReferenceBase`1<TAwaitReferencesOwner> {
    protected AwaiterGetResultReferenceBase`1(TAwaitReferencesOwner owner);
    public virtual string GetName();
    protected virtual IType GetQualifierType(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AwaiterIsCompletedReferenceBase`1 : AwaitReferenceBase`1<TAwaitReferencesOwner> {
    protected AwaiterIsCompletedReferenceBase`1(TAwaitReferencesOwner owner);
    public virtual string GetName();
    protected virtual ResolveResultWithInfo CoreResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    protected virtual IType GetQualifierType(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AwaiterOnCompletedReferenceBase`1 : InvocableAwaitReferenceBase`1<TAwaitReferencesOwner> {
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    protected AwaiterOnCompletedReferenceBase`1(TAwaitReferencesOwner owner);
    public virtual string GetName();
    public virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    protected virtual IType GetQualifierType(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    [CanBeNullAttribute]
private static DeclaredElementInstance FindMethodImplementation(ITypeElement typeElement, ISubstitution substitution, IInterface interface);
    [CanBeNullAttribute]
private static IDeclaredType GetBaseClassType(ITypeElement typeElement);
    private static bool ThisTypeElementImplementsInterface(ITypeElement typeElement, IInterface interface);
    [CanBeNullAttribute]
private static IMethod FindMethodImplementationInThisTypeElement(ITypeElement typeElement, ISubstitution substitution, IInterface interface);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AwaitExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short EXPRESSION;
    private MyGetAwaiterReference myGetAwaiterReference;
    private MyAwaiterGetResultReference myAwaiterGetResultReference;
    private MyAwaiterOnCompletedReference myAwaiterOnCompletedReference;
    private MyAwaiterIsCompletedReference myAwaiterIsCompletedReference;
    public NodeType NodeType { get; }
    public ITokenNode AwaitKeyword { get; }
    public IUnaryExpression Task { get; }
    public bool IsAwait { get; }
    public TreeTextRange AwaitRange { get; }
    private bool IsWellFormedAwaitConstruct { get; }
    public IManagedReference GetAwaiterReference { get; }
    public IManagedReference AwaiterGetResultReference { get; }
    public IManagedReference AwaiterOnCompletedReference { get; }
    public IManagedReference AwaiterIsCompletedReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AwaitKeyword();
    public virtual IUnaryExpression get_Task();
    public virtual IUnaryExpression SetTask(IUnaryExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual bool get_IsAwait();
    public sealed virtual TreeTextRange get_AwaitRange();
    private bool get_IsWellFormedAwaitConstruct();
    public sealed virtual IManagedReference get_GetAwaiterReference();
    public sealed virtual IManagedReference get_AwaiterGetResultReference();
    public sealed virtual IManagedReference get_AwaiterOnCompletedReference();
    public sealed virtual IManagedReference get_AwaiterIsCompletedReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.AwaitReferenceBase`1 : ManagedOnePhaseReferenceImplBase`1<TAwaitReferencesOwner> {
    protected bool IsWellFormedAwaitConstruct { get; }
    public bool IsQualified { get; }
    protected AwaitReferenceBase`1(TAwaitReferencesOwner owner);
    protected abstract virtual bool get_IsWellFormedAwaitConstruct();
    [CanBeNullAttribute]
[PureAttribute]
protected abstract virtual IType GetQualifierType(IResolveContext resolveContext);
    [NotNullAttribute]
protected abstract virtual ResolveResultWithInfo CoreResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    [PureAttribute]
private bool IsDynamic(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    public virtual bool get_IsQualified();
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual IQualifier GetQualifier(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual Refers RefersToDeclaredElement(IDeclaredElement declaredElement);
    [NotNullAttribute]
protected virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.BaseExpression : CSharpExpressionBase {
    public static short BASE;
    public NodeType NodeType { get; }
    public ITokenNode Base { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Base();
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.BinaryExpressionBase : CSharpExpressionBase {
    private BinaryOperatorReference myReference;
    public IPsiModule PsiModule { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public ITokenNode OperatorSign { get; }
    [NotNullAttribute]
public IOperatorReference OperatorReference { get; }
    public IList`1<ICSharpExpression> OperatorOperands { get; }
    private ICSharpExpression LeftOperand { get; }
    private ICSharpExpression RightOperand { get; }
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
private ICSharpArgumentInfo[] GetArguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ITokenNode get_OperatorSign();
    public sealed virtual IOperatorReference get_OperatorReference();
    public sealed virtual IList`1<ICSharpExpression> get_OperatorOperands();
    private ICSharpExpression get_LeftOperand();
    private ICSharpExpression get_RightOperand();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual IType Type(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    [CompilerGeneratedAttribute]
internal static bool <CalculateExpressionTypeAux>g__IsInterpolatedStringConcatenation|30_0(IAdditiveExpression additiveExpression, IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.BinaryOperatorReference : ManagedNonQualifiableReferenceBase`1<IOperatorExpression> {
    private bool myIsAssignment;
    public ICSharpInvocationInfo Invocation { get; }
    public BinaryOperatorReference(IOperatorExpression owner, bool isAssignment);
    public virtual string GetName();
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    private bool IsCircular();
    public sealed virtual Refers RefersToDeclaredElement(IDeclaredElement declaredElement);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    [CanBeNullAttribute]
private ResolveResultWithInfo TryResolveToEventSubscription(IResolveContext resolveContext, ICSharpExpression leftOperand, ICSharpExpression rightOperand);
    [NotNullAttribute]
private static ResolveErrorType CheckResolveResultSpecial(ISignOperator binaryOperator, ISubstitution substitution);
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
private Refers <RefersToDeclaredElement>b__9_0(IDeclaredElement element);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.BitwiseAndExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.BitwiseExclusiveOrExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.BitwiseInclusiveOrExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.Block : StatementBase {
    public static short CSHARP_LBRACE;
    public static short STATEMENT;
    public static short CSHARP_RBRACE;
    private TreeNodeCollection`1<ICSharpStatement> myCachedStatements;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedStatementsValid;
    private int myModificationStamp;
    public NodeType NodeType { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<IYieldStatement> StatementsInternal { get; }
    public TreeNodeEnumerable`1<IYieldStatement> StatementsInternalEnumerable { get; }
    public TreeNodeCollection`1<ICSharpStatement> Statements { get; }
    protected TreeNodeCollection`1<ICSharpStatement> _Statements { get; }
    public TreeNodeEnumerable`1<ICSharpStatement> StatementsEnumerable { get; }
    public int LevelDelta { get; }
    private Nullable`1<int> JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.ModificationStamp { get; private set; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<IYieldStatement> get_StatementsInternal();
    public virtual TreeNodeEnumerable`1<IYieldStatement> get_StatementsInternalEnumerable();
    public sealed virtual TreeNodeCollection`1<ICSharpStatement> get_Statements();
    protected virtual TreeNodeCollection`1<ICSharpStatement> get__Statements();
    public virtual TreeNodeEnumerable`1<ICSharpStatement> get_StatementsEnumerable();
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public sealed virtual ICSharpStatementsRange GetAllStatementsRange();
    public sealed virtual void RemoveStatementsRange(ICSharpStatementsRange range);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange range, ICSharpStatement anchor);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange range, ICSharpStatement anchor);
    private void EnsureRBrace();
    public sealed virtual ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange range, ICSharpStatementsRange anchor);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange range, ICSharpStatementsRange anchor);
    [NotNullAttribute]
private static ICSharpStatementsRange CreateStatementsRange(ICSharpStatement statement);
    public sealed virtual TStatement AddStatementBeforeRange(TStatement param, ICSharpStatementsRange anchor);
    public sealed virtual TStatement AddStatementAfterRange(TStatement param, ICSharpStatementsRange anchor);
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    private sealed virtual override Nullable`1<int> JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.get_ModificationStamp();
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.set_ModificationStamp(Nullable`1<int> value);
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual TStatement AddStatementAfter(TStatement param, ICSharpStatement anchor);
    public sealed virtual TStatement AddStatementBefore(TStatement param, ICSharpStatement anchor);
    public sealed virtual void RemoveStatement(ICSharpStatement param);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.BreakStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ITokenNode BreakKeyword { get; }
    public ITokenNode Semicolon { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_BreakKeyword();
    public virtual ITokenNode get_Semicolon();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CastExpression : CSharpExpressionBase {
    public static short CSHARP_LPAR;
    public static short CSHARP_OPERAND_TYPE;
    public static short CSHARP_RPAR;
    public static short OP;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public ICSharpExpression Op { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TargetType { get; }
    public IReferenceName ScalarTypeName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual ICSharpExpression get_Op();
    public virtual ITokenNode get_RPar();
    public virtual ITypeUsage get_TargetType();
    public virtual ICSharpExpression SetOp(ICSharpExpression param);
    public virtual ITypeUsage SetTargetType(ITypeUsage param);
    public virtual string ToString();
    public IReferenceName get_ScalarTypeName();
    [NotNullAttribute]
[PureAttribute]
private IType GetTargetType();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CatchVariableDeclaration : LocalVariableDeclarationBase {
    public static short CSHARP_NAME;
    public NodeType NodeType { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public string DeclaredName { get; }
    private ILocalVariable JetBrains.ReSharper.Psi.CSharp.Tree.ICatchVariableDeclaration.DeclaredElement { get; }
    protected IType ExplicitlyDeclaredType { get; }
    public bool IsWritable { get; }
    public ScopedKind Scope { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string get_DeclaredName();
    private sealed virtual override ILocalVariable JetBrains.ReSharper.Psi.CSharp.Tree.ICatchVariableDeclaration.get_DeclaredElement();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    protected virtual IType get_ExplicitlyDeclaredType();
    public virtual bool get_IsWritable();
    public virtual ScopedKind get_Scope();
    public virtual void SetType(IType type);
    protected virtual IType GetImplicitType(IResolveContext resolveContext);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ChameleonArrayInitializer : ArrayInitializer {
    [NotNullAttribute]
private object mySyncObject;
    private bool myOpened;
    public bool IsOpened { get; }
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public ChameleonArrayInitializer(ClosedChameleonElement closedChameleonElement);
    public ChameleonArrayInitializer(int length);
    public ChameleonArrayInitializer(IBuffer buffer, TreeOffset startOffset, int length);
    internal ChameleonArrayInitializer(CompositeElement arrayInitializer);
    public sealed virtual bool get_IsOpened();
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    protected virtual TreeElement DeepClone(TreeNodeCopyContext context);
    private void OpenChameleon();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertChameleonAndErrorChildren();
    private void OpenChameleonFrom(ITreeNode chameleon);
    public virtual string ToString();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual ITreeNode FindNodeAt(TreeTextRange treeRange);
    public virtual void FindNodesAtInternal(TreeTextRange relativeRange, List`1<ITreeNode> result, bool includeContainingNodes);
    public sealed virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    [CompilerGeneratedAttribute]
private ITreeNode <OpenChameleon>b__17_0(IParser parser);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ChameleonBlock : Block {
    [NotNullAttribute]
private object mySyncObject;
    private bool myOpened;
    public bool IsOpened { get; }
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public ChameleonBlock(ClosedChameleonElement closedChameleonElement);
    public ChameleonBlock(int length);
    public ChameleonBlock(IBuffer buffer, TreeOffset startOffset, int length);
    internal ChameleonBlock(CompositeElement block);
    public sealed virtual bool get_IsOpened();
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    protected virtual TreeElement DeepClone(TreeNodeCopyContext context);
    private void OpenChameleon();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertSingleChild();
    private void OpenChameleonFrom(ITreeNode chameleon);
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual ITreeNode FindNodeAt(TreeTextRange treeRange);
    public virtual void FindNodesAtInternal(TreeTextRange relativeRange, List`1<ITreeNode> result, bool includeContainingNodes);
    public sealed virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    [CompilerGeneratedAttribute]
private ITreeNode <OpenChameleon>b__17_0(IParser parser);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ChameleonCollectionExpression : CollectionExpression {
    private object mySyncObject;
    private bool myOpened;
    public bool IsOpened { get; }
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public ChameleonCollectionExpression(ClosedChameleonElement closedChameleonElement);
    public ChameleonCollectionExpression(int length);
    private ChameleonCollectionExpression(IBuffer buffer, TreeOffset startOffset, int length);
    internal ChameleonCollectionExpression(CompositeElement collectionExpression);
    public sealed virtual bool get_IsOpened();
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    protected virtual TreeElement DeepClone(TreeNodeCopyContext context);
    private void OpenChameleon();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertChameleonAndErrorChildren();
    private void OpenChameleonFrom(ITreeNode chameleon);
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual ITreeNode FindNodeAt(TreeTextRange treeRange);
    public virtual void FindNodesAtInternal(TreeTextRange relativeRange, List`1<ITreeNode> result, bool includeContainingNodes);
    public sealed virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private ITreeNode <OpenChameleon>b__17_0(IParser parser);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CheckedExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short OP;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode CheckedKeyword { get; }
    public ITokenNode LPar { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_CheckedKeyword();
    public virtual ITokenNode get_LPar();
    public virtual ICSharpExpression get_Operand();
    public virtual ITokenNode get_RPar();
    public virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CheckedStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public IBlock Body { get; }
    public ITokenNode CheckedKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Body();
    public virtual ITokenNode get_CheckedKeyword();
    public virtual IBlock SetBody(IBlock param);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ChildRole : object {
    public static short NONE;
    public static short CSHARP_NAME;
    public static short CSHARP_LABEL_NAME;
    public static short CSHARP_BLOCK;
    public static short CSHARP_LBRACE;
    public static short CSHARP_RBRACE;
    public static short CSHARP_LPAR;
    public static short CSHARP_RPAR;
    public static short CSHARP_LBRACKET;
    public static short CSHARP_RBRACKET;
    public static short CSHARP_LANGLE;
    public static short CSHARP_RANGLE;
    public static short CSHARP_COMMA;
    public static short CSHARP_TILDE;
    public static short CSHARP_COLON;
    public static short CSHARP_QUEST;
    public static short CSHARP_BASE;
    public static short CSHARP_SEMICOLON;
    public static short CSHARP_SEMICOLON2;
    public static short CSHARP_TYPE;
    public static short CSHARP_OPERAND_TYPE;
    public static short CSHARP_BODY;
    public static short CSHARP_THEN;
    public static short CSHARP_ELSE;
    public static short CSHARP_EQ;
    public static short CSHARP_REFERENCE;
    public static short CSHARP_LABEL_REFERENCE;
    public static short CSHARP_NAMESPACE_OR_TYPE;
    public static short CSHARP_REFERENCE_DELIMITER;
    public static short CSHARP_PARAMETER;
    public static short CSHARP_ARGUMENT;
    public static short CSHARP_OP1;
    public static short CSHARP_OP2;
    public static short CSHARP_OP3;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_CONSTANT_EXPRESSION;
    public static short CSHARP_CONDITION;
    public static short CSHARP_ATTRIBUTES;
    public static short CSHARP_QUALIFIER;
    public static short CSHARP_KEYWORD;
    public static short CSHARP_CONDITIONAL_SIGN;
    public static short CSHARP_PATTERN;
    public static short LAST;
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ClassBody : CSharpCompositeElement {
    public static short CSHARP_LBRACE;
    public static short DESTRUCTOR;
    public static short CONSTANT;
    public static short EVENT;
    public static short OPERATOR;
    public static short TYPE;
    public static short INDEXER;
    public static short METHOD;
    public static short PROPERTY;
    public static short FIELD;
    public static short CONSTRUCTOR;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IMultipleConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> Constructors { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorsEnumerable { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> Destructors { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorsEnumerable { get; }
    public TreeNodeCollection`1<IMultipleEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMultipleFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IIndexerDeclaration> Indexers { get; }
    public TreeNodeEnumerable`1<IIndexerDeclaration> IndexersEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IMethodDeclaration> Methods { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodsEnumerable { get; }
    public TreeNodeCollection`1<IOperatorDeclaration> Operators { get; }
    public TreeNodeEnumerable`1<IOperatorDeclaration> OperatorsEnumerable { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> Properties { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertiesEnumerable { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> TypeDeclarationsEnumerable { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IMultipleConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IMultipleConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_Constructors();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorsEnumerable();
    public virtual TreeNodeCollection`1<IDestructorDeclaration> get_Destructors();
    public virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorsEnumerable();
    public virtual TreeNodeCollection`1<IMultipleEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IMultipleEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IMultipleFieldDeclaration> get_FieldDeclarations();
    public virtual TreeNodeEnumerable`1<IMultipleFieldDeclaration> get_FieldDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IIndexerDeclaration> get_Indexers();
    public virtual TreeNodeEnumerable`1<IIndexerDeclaration> get_IndexersEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_Methods();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodsEnumerable();
    public virtual TreeNodeCollection`1<IOperatorDeclaration> get_Operators();
    public virtual TreeNodeEnumerable`1<IOperatorDeclaration> get_OperatorsEnumerable();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_Properties();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertiesEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_TypeDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_TypeDeclarationsEnumerable();
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ClassDeclaration : ClassDeclarationStub {
    [NotNullAttribute]
public virtual IClassBody SetBody(IClassBody param);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ClassDeclarationStub : ClassLikeDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short KEYWORD;
    public static short CSHARP_NAME;
    public static short TYPE_PARAMETERS_LIST;
    public static short CONSTRUCTOR;
    public static short CSHARP_BASE;
    public static short CONSTRAINTS;
    public static short CSHARP_BLOCK;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IClassBody Body { get; }
    public ITokenNode ClassKeyword { get; }
    public IExtendsList ExtendsList { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IPrimaryConstructorDeclaration PrimaryConstructorDeclaration { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IClassBody BodyInternal { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> DestructorDeclarations { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IIndexerDeclaration> IndexerDeclarations { get; }
    public TreeNodeEnumerable`1<IIndexerDeclaration> IndexerDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> InheritedTypeUsages { get; }
    public TreeNodeEnumerable`1<ITypeUsage> InheritedTypeUsagesEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IOperatorDeclaration> OperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IOperatorDeclaration> OperatorDeclarationsEnumerable { get; }
    public ICSharpNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParametersEnumerable { get; }
    public ITokenNode TypeDeclarationKeyword { get; }
    public IReadOnlyList`1<ITypeDeclaration> TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    private ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.DeclaredElement { get; }
    private IClass JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IMemberOwnerBody JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration.Body { get; }
    public TreeNodeCollection`1<IClassMemberDeclaration> ClassMemberDeclarations { get; }
    public string DeclaredName { get; }
    public TreeNodeCollection`1<ITypeUsage> SuperTypeUsageNodes { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IClassBody get_Body();
    public virtual ITokenNode get_ClassKeyword();
    public virtual IExtendsList get_ExtendsList();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IPrimaryConstructorDeclaration get_PrimaryConstructorDeclaration();
    public virtual ITokenNode get_Semicolon();
    public virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public virtual ITypeParameterOfTypeList get_TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IClassBody get_BodyInternal();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IDestructorDeclaration> get_DestructorDeclarations();
    public virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IFieldDeclaration> get_FieldDeclarations();
    public virtual TreeNodeEnumerable`1<IFieldDeclaration> get_FieldDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IIndexerDeclaration> get_IndexerDeclarations();
    public virtual TreeNodeEnumerable`1<IIndexerDeclaration> get_IndexerDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeUsage> get_InheritedTypeUsages();
    public virtual TreeNodeEnumerable`1<ITypeUsage> get_InheritedTypeUsagesEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_NestedTypeDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IOperatorDeclaration> get_OperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IOperatorDeclaration> get_OperatorDeclarationsEnumerable();
    public virtual ICSharpNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParametersEnumerable();
    public virtual IClassBody SetBody(IClassBody param);
    public virtual IExtendsList SetExtendsList(IExtendsList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IPrimaryConstructorDeclaration SetPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public sealed virtual ITokenNode get_TypeDeclarationKeyword();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    public sealed virtual bool CanBindTo(ITypeElement typeElement);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.get_DeclaredElement();
    private sealed virtual override IClass JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IMemberOwnerBody JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration.get_Body();
    public virtual TreeNodeCollection`1<IClassMemberDeclaration> get_ClassMemberDeclarations();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual string ToString();
    public sealed virtual IExtendsList GetOrCreateExtendsList();
    public virtual TreeNodeCollection`1<ITypeUsage> get_SuperTypeUsageNodes();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration typeParameterDeclaration);
    public sealed virtual void SetSuperClass(IDeclaredType classType);
    public sealed virtual void AddSuperInterface(IDeclaredType interfaceType, bool before);
    public sealed virtual void RemoveSuperInterface(IDeclaredType interfaceType);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ClassLikeDeclarationBase : MemberOwnerDeclarationBase {
    public TreeNodeCollection`1<IClassMemberDeclaration> ClassMemberDeclarations { get; }
    public TreeNodeCollection`1<ICSharpTypeMemberDeclaration> MemberDeclarations { get; }
    public TreeNodeCollection`1<ITypeUsage> SuperTypeUsageNodes { get; }
    [NotNullAttribute]
public IEnumerable`1<IDeclaredType> SuperTypes { get; }
    public abstract virtual TreeNodeCollection`1<IClassMemberDeclaration> get_ClassMemberDeclarations();
    public virtual TreeNodeCollection`1<ICSharpTypeMemberDeclaration> get_MemberDeclarations();
    public abstract virtual TreeNodeCollection`1<ITypeUsage> get_SuperTypeUsageNodes();
    public sealed virtual IEnumerable`1<IDeclaredType> get_SuperTypes();
    private TClassMemberDeclaration DoAddClassMemberDeclarationAfter(TClassMemberDeclaration declaration, ITreeNode anchor);
    public sealed virtual TClassMemberDeclaration AddClassMemberDeclarationAfter(TClassMemberDeclaration declaration, IClassMemberDeclaration anchor);
    private TClassMemberDeclaration DoAddClassMemberDeclarationBefore(TClassMemberDeclaration declaration, ITreeNode anchor);
    public sealed virtual TClassMemberDeclaration AddClassMemberDeclarationBefore(TClassMemberDeclaration param, IClassMemberDeclaration anchor);
    public sealed virtual TClassMemberDeclaration AddClassMemberDeclaration(TClassMemberDeclaration declaration);
    public sealed virtual TClassMemberDeclaration InsertAtSpecificPosition(TClassMemberDeclaration param, ITreeNode anchor);
    [NotNullAttribute]
public sealed virtual TClassMemberDeclaration ReplaceClassMemberDeclaration(IClassMemberDeclaration oldDeclaration, TClassMemberDeclaration newDeclaration);
    [CanBeNullAttribute]
private static ITreeNode FixupAnchor(ITreeNode anchor, bool willInsertBefore);
    private void FixupAddedTypeMember(ITreeNode result);
    public sealed virtual void RemoveClassMemberDeclaration(IClassMemberDeclaration param);
    [NotNullAttribute]
public sealed virtual IDeclarationsRange GetAllDeclarationsRange();
    [NotNullAttribute]
public sealed virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange textRange);
    [NotNullAttribute]
public sealed virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    [NotNullAttribute]
public sealed virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    [NotNullAttribute]
public sealed virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    [NotNullAttribute]
private static ITreeRange FixupDeclarationsRange(IDeclarationsRange range);
    protected virtual Hash CalculateHashInternal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CollectionElementInitializer : CSharpCompositeElement {
    public static short CSHARP_OP2;
    public static short CSHARP_LBRACE;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    private CollectionInitializerAddMethodReference myReference;
    private MyParamsDefaultConstructorReference myParamsDefaultConstructorReference;
    private MyParamsCreateMethodReference myParamsCreateMethodReference;
    [NullableAttribute("0")]
public NodeType NodeType { get; }
    [NullableAttribute("0")]
public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    [NullableAttribute("0")]
public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    [NullableAttribute("0")]
public TreeNodeCollection`1<ITokenNode> Comma { get; }
    [NullableAttribute("0")]
public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    [NullableAttribute("0")]
public ITokenNode LBrace { get; }
    [NullableAttribute("0")]
public ITokenNode RBrace { get; }
    public IManagedReference Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public IReference ParamsDefaultConstructorReference { get; }
    public IReference ParamsCreateMethodReference { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    [NullableAttribute("2")]
private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    [NullableAttribute("2")]
public ICSharpArgumentInfo ExtensionQualifier { get; }
    public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    [NullableContextAttribute("0")]
public virtual NodeType get_NodeType();
    [NullableContextAttribute("0")]
public virtual void Accept(TreeNodeVisitor visitor);
    [NullableContextAttribute("0")]
public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    [NullableContextAttribute("0")]
public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    [NullableContextAttribute("0")]
public virtual short GetChildRole(TreeElement child);
    [NullableContextAttribute("0")]
public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    [NullableContextAttribute("0")]
public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    [NullableContextAttribute("0")]
public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    [NullableContextAttribute("0")]
public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    [NullableContextAttribute("0")]
public virtual ITokenNode get_LBrace();
    [NullableContextAttribute("0")]
public virtual ITokenNode get_RBrace();
    [NullableContextAttribute("0")]
public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IManagedReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual string Dump();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IReference get_ParamsDefaultConstructorReference();
    public sealed virtual IReference get_ParamsCreateMethodReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    [NullableContextAttribute("2")]
public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    [NullableContextAttribute("2")]
public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual void RemoveArgument(ICSharpArgument argument);
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    [NullableContextAttribute("2")]
private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    [NullableContextAttribute("2")]
public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IList`1<ITokenNode> get_Delimiters();
    public sealed virtual ITokenNode get_LBound();
    public sealed virtual ITokenNode get_RBound();
    private static bool IsIgnoredParamsCollectionCreation(ICollectionElementInitializer initializer, IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CollectionExpression : CSharpExpressionBase {
    public static short CSHARP_LBRACKET;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACKET;
    [NullableAttribute("1")]
private CachedPsiValue`1<CollectionExpressionTargetTypeInfo> myCachedTargetTypeInfo;
    [NullableAttribute("1")]
private MyCollectionCreateMethodReference myCollectionCreateMethodReference;
    [NullableAttribute("1")]
private MyDefaultConstructorReference myDefaultConstructorReference;
    [NullableAttribute("1")]
private MyAddReference myAddReference;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ICollectionExpressionElement> CollectionElements { get; }
    public TreeNodeEnumerable`1<ICollectionExpressionElement> CollectionElementsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    [NullableAttribute("1")]
public IReference CollectionCreateMethodReference { get; }
    [NullableAttribute("1")]
public IReference DefaultConstructorReference { get; }
    [NullableAttribute("1")]
public IReference AddReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ICollectionExpressionElement> get_CollectionElements();
    public virtual TreeNodeEnumerable`1<ICollectionExpressionElement> get_CollectionElementsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LBracket();
    public virtual ITokenNode get_RBracket();
    public virtual string ToString();
    protected virtual void PreInit();
    [NullableContextAttribute("1")]
public sealed virtual IReference get_CollectionCreateMethodReference();
    [NullableContextAttribute("1")]
public sealed virtual IReference get_DefaultConstructorReference();
    [NullableContextAttribute("1")]
public sealed virtual IReference get_AddReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    [NullableContextAttribute("1")]
public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual CollectionExpressionTargetTypeInfo GetTargetTypeInfo();
    public void ResetTargetTypeInfo();
    [NullableContextAttribute("1")]
public sealed virtual CollectionExpressionTargetTypeInfo GetTargetTypeInfo(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
public sealed virtual CollectionExpressionTargetTypeInfo GetTargetTypeInfo(IType targetType);
    [NullableContextAttribute("1")]
public sealed virtual ICollectionExpressionElement AddCollectionElementAfter(ICollectionExpressionElement element, ICollectionExpressionElement anchor);
    [NullableContextAttribute("1")]
public sealed virtual ICollectionExpressionElement AddCollectionElementBefore(ICollectionExpressionElement element, ICollectionExpressionElement anchor);
    [NullableContextAttribute("1")]
public sealed virtual void RemoveCollectionElement(ICollectionExpressionElement element);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CollectionInitializer : CreationExpressionInitializerBase {
    public static short CSHARP_LBRACE;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICollectionElementInitializer> ElementInitializers { get; }
    public TreeNodeEnumerable`1<ICollectionElementInitializer> ElementInitializersEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<IInitializerElement> InitializerElements { get; }
    public TreeNodeEnumerable`1<IInitializerElement> InitializerElementsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ICollectionElementInitializer> get_ElementInitializers();
    public virtual TreeNodeEnumerable`1<ICollectionElementInitializer> get_ElementInitializersEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual string ToString();
    public sealed virtual ICollectionElementInitializer AddElementInitializerAfter(ICollectionElementInitializer elementInitializer, ICollectionElementInitializer anchor);
    public sealed virtual ICollectionElementInitializer AddElementInitializerBefore(ICollectionElementInitializer elementInitializer, ICollectionElementInitializer anchor);
    public sealed virtual TreeNodeCollection`1<IInitializerElement> get_InitializerElements();
    public sealed virtual TreeNodeEnumerable`1<IInitializerElement> get_InitializerElementsEnumerable();
    public sealed virtual void RemoveElementInitializer(ICollectionElementInitializer elementInitializer);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.Comment : CSharpGenericToken {
    public CommentType CommentType { get; }
    public string CommentText { get; }
    public bool IsOpened { get; }
    public Comment(TokenNodeType nodeType, string text);
    public sealed virtual CommentType get_CommentType();
    public virtual bool IsFiltered();
    public sealed virtual ICSharpCommentNode ReplaceBy(ICSharpCommentNode commentNode);
    public sealed virtual string get_CommentText();
    public sealed virtual TreeTextRange GetCommentRange();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    public sealed virtual bool get_IsOpened();
    [CompilerGeneratedAttribute]
internal static string <get_CommentText>g__GetMultilineCommentText|6_0(int startFrom, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
private TreeTextRange <GetCommentRange>g__GetMultilineComment|7_0(int startFrom, <>c__DisplayClass7_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConditionalAccessSign : CSharpCompositeElement {
    public static short CSHARP_QUEST;
    public NodeType NodeType { get; }
    public ITokenNode Quest { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Quest();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConditionalAndExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConditionalOrExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConditionalTernaryExpression : CSharpExpressionBase {
    public static short CSHARP_OP1;
    public static short CSHARP_QUEST;
    public static short CSHARP_OP2;
    public static short CSHARP_COLON;
    public static short CSHARP_OP3;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public ICSharpExpression ConditionOperand { get; }
    public ICSharpExpression ElseResult { get; }
    public ITokenNode Question { get; }
    public ICSharpExpression ThenResult { get; }
    public bool IsRefConditional { get; }
    public IEnumerable`1<ICSharpExpression> TargetTypedExpressions { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Colon();
    public virtual ICSharpExpression get_ConditionOperand();
    public virtual ICSharpExpression get_ElseResult();
    public virtual ITokenNode get_Question();
    public virtual ICSharpExpression get_ThenResult();
    public virtual ICSharpExpression SetConditionOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetElseResult(ICSharpExpression param);
    public virtual ICSharpExpression SetThenResult(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual bool get_IsRefConditional();
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    [NotNullAttribute]
private IExpressionType GetNonConstantExpressionType(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConditionalTernaryExpression/<get_TargetTypedExpressions>d__33")]
public sealed virtual IEnumerable`1<ICSharpExpression> get_TargetTypedExpressions();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConstantDeclaration : ProperTypeMemberDeclarationBase {
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short CSHARP_CONSTANT_EXPRESSION;
    public NodeType NodeType { get; }
    public ITokenNode EquivalenceSign { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ICSharpExpression ValueExpression { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IMultipleConstantDeclaration DeclarationInternal { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IMultipleDeclaration MultipleDeclaration { get; }
    public ITypeUsage TypeUsage { get; }
    public IType Type { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsVolatile { get; }
    public bool IsUnsafe { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsExtern { get; }
    public string DeclaredName { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    private IField JetBrains.ReSharper.Psi.CSharp.Tree.IConstantDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EquivalenceSign();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpExpression get_ValueExpression();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IMultipleConstantDeclaration get_DeclarationInternal();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual IMultipleDeclaration get_MultipleDeclaration();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public sealed virtual IType get_Type();
    public sealed virtual void SetType(IType type);
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsVolatile();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsExtern();
    public virtual AccessRights GetAccessRights();
    public virtual AccessRights GetSemanticAccessRights();
    public virtual void SetStatic(bool value);
    public virtual void SetReadonly(bool value);
    public virtual void SetVolatile(bool value);
    public virtual void SetAccessRights(AccessRights rights);
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    [NotNullAttribute]
public ConstantValue CalculateConstantValue();
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IConstantDeclaration.SetValueExpression(ICSharpExpression param);
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    protected virtual IDeclaredElement CreateDeclaredElement();
    private sealed virtual override IField JetBrains.ReSharper.Psi.CSharp.Tree.IConstantDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    public virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    public virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public virtual void RemoveAttribute(IAttribute attribute);
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConstantOrTypePattern : CSharpCompositeElement {
    public static short CSHARP_CONSTANT_EXPRESSION;
    private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    public ConstantValue ConstantValue { get; }
    public ConstantValue CachedConstantValue { get; public set; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    [CanBeNullAttribute]
[PureAttribute]
private IReferenceExpression TryGetTypePatternReferenceExpression();
    public sealed virtual ConstantOrTypePatternKind GetKind(IResolveContext resolveContext, Nullable`1<bool> unresolvedIsType);
    [PureAttribute]
private bool IsUnresolvedReferenceIsType(Nullable`1<bool> unresolvedIsType);
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual ConstantValue get_CachedConstantValue();
    public sealed virtual void set_CachedConstantValue(ConstantValue value);
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConstructorConstraint : CSharpCompositeElement {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public ITokenNode NewKeyword { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_NewKeyword();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConstructorDeclaration : ConstructorDeclarationStub {
    protected virtual IDeclaredElement CreateDeclaredElement();
    public virtual IBlock SetBody(IBlock param);
    protected virtual Hash CalculateHashInternal();
    public virtual void SetAbstract(bool value);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConstructorDeclarationStub : ProperTypeMemberDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short CSHARP_NAME;
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_BLOCK;
    public static short ARROW_CLAUSE;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IBlock Body { get; }
    public IConstructorInitializer Initializer { get; }
    public ITokenNode LPar { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon { get; }
    public ICSharpIdentifier TypeName { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public string DeclaredName { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IConstructor JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IBlock get_Body();
    public virtual IConstructorInitializer get_Initializer();
    public virtual ITokenNode get_LPar();
    public virtual IFormalParameterList get_Params();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Semicolon();
    public virtual ICSharpIdentifier get_TypeName();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IBlock SetBody(IBlock param);
    public virtual IConstructorInitializer SetInitializer(IConstructorInitializer param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IFormalParameterList SetParams(IFormalParameterList param);
    public virtual ICSharpIdentifier SetTypeName(ICSharpIdentifier param);
    public virtual string ToString();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public virtual string get_DeclaredName();
    protected internal virtual string GetShortNameOfDeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IConstructor JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsync();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConstructorInitializer : CSharpCompositeElement {
    public static short CSHARP_COLON;
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short ARGUMENT_LIST;
    public static short CSHARP_RPAR;
    [NotNullAttribute]
private ConstructorInitializerReference myReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public ITokenNode Colon { get; }
    public ITokenNode Instance { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public IDeclaredType ConstructedType { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    [NotNullAttribute]
private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer.Reference { get; }
    public ConstructorInitializerKind Kind { get; }
    public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual ITokenNode get_Colon();
    public virtual ITokenNode get_Instance();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IDeclaredType get_ConstructedType();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual string Dump();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer.get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ConstructorInitializerKind get_Kind();
    public sealed virtual IList`1<ITokenNode> get_Delimiters();
    public sealed virtual ITokenNode get_LBound();
    public sealed virtual ITokenNode get_RBound();
    public sealed virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual void RemoveArgument(ICSharpArgument argument);
    public sealed virtual void SetKind(ConstructorInitializerKind kind);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConstructorReference : ManagedNonQualifiableReferenceBase`1<ObjectCreationExpressionStub> {
    private static ClrTypeName CoClassAttributeName;
    public ICSharpInvocationInfo Invocation { get; }
    public ConstructorReference(ObjectCreationExpressionStub objectCreationExpression);
    private static ConstructorReference();
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual string GetName();
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual TreeTextRange GetTreeTextRange();
    private bool CheckDelegateConstructor(IList`1<ICSharpArgument> arguments, IResolveContext resolveContext, IResolveResult resolve);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ContinueStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ITokenNode ContinueKeyword { get; }
    public ITokenNode Semicolon { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ContinueKeyword();
    public virtual ITokenNode get_Semicolon();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConversionOperatorDeclaration : ConversionOperatorDeclarationStub {
    protected virtual IDeclaredElement CreateDeclaredElement();
    public virtual IBlock SetBody(IBlock param);
    [CanBeNullAttribute]
public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ConversionOperatorDeclarationStub : OperatorDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short MODIFIER;
    public static short CSHARP_QUALIFIER;
    public static short OPERATOR_KEYWORD;
    public static short CHECKED_KEYWORD;
    public static short CSHARP_TYPE;
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public static short CSHARP_BLOCK;
    public static short ARROW_CLAUSE;
    public static short CSHARP_SEMICOLON;
    private IOwnerQualification myCachedInterfaceQualification;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedInterfaceQualificationValid;
    public NodeType NodeType { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IBlock Body { get; }
    public ITokenNode CheckedKeyword { get; }
    public IOwnerQualification InterfaceQualification { get; }
    protected IOwnerQualification _InterfaceQualification { get; }
    public ITokenNode LPar { get; }
    public ITokenNode Modifier { get; }
    public ITokenNode OperatorKeyword { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IReferenceName InterfaceQualificationReference { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public bool IsImplicit { get; }
    public bool IsChecked { get; }
    public string DeclaredName { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public bool IsIterator { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IBlock get_Body();
    public virtual ITokenNode get_CheckedKeyword();
    public sealed virtual IOwnerQualification get_InterfaceQualification();
    protected virtual IOwnerQualification get__InterfaceQualification();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_Modifier();
    public virtual ITokenNode get_OperatorKeyword();
    public virtual IFormalParameterList get_Params();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Semicolon();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IReferenceName get_InterfaceQualificationReference();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IBlock SetBody(IBlock param);
    public virtual IOwnerQualification SetInterfaceQualification(IOwnerQualification param);
    public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IFormalParameterList SetParams(IFormalParameterList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public virtual TreeTextRange GetNameRange();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsChecked();
    public virtual string get_DeclaredName();
    protected internal virtual string GetShortNameOfDeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual void SetName(string name);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(int index);
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    public sealed virtual bool get_IsIterator();
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CreateMethodReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<T> {
    protected CreateMethodReferenceBase`1(T owner);
    protected abstract virtual IType GetTargetType(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    protected ResolveResultWithInfo ResolveImpl(IType collectionType);
    public virtual string GetName();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    [NullableContextAttribute("2")]
private bool ReadCollectionBuilderAttribute(ITypeElement targetTypeElement, String& methodName, IType& builderType);
    private DeclaredElementInstance`1<IMethod> TryGetCollectionCreateMethod(IType targetType);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ResolveImpl>g__CheckConstraints|3_0(<>c__DisplayClass3_0& );
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CreationExpressionInitializerBase : CSharpCompositeElement {
    public virtual IType GetConstructedType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpArgument : CSharpArgumentStub {
    public virtual ICSharpExpression SetValue(ICSharpExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpArgumentStub : CSharpCompositeElement {
    public static short PARAMETER_NAME;
    public static short CSHARP_COLON;
    public static short VALUE;
    public static short MODE;
    private MyParameterNameReference modreq(System.Runtime.CompilerServices.IsVolatile) myParameterNameReference;
    private MyParamsAddReference modreq(System.Runtime.CompilerServices.IsVolatile) myParamsAddReference;
    private CachedPsiValue`1<CSharpParameterInstance> myCachedMatchedParameter;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public ITokenNode Mode { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ICSharpExpression Value { get; }
    public IArgumentList ContainingArgumentList { get; }
    public ParameterKind Kind { get; }
    public CSharpParameterInstance MatchingParameter { get; }
    private DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.MatchingParameter { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public IPsiModule PsiModule { get; }
    public bool IsExtensionInvocationQualifier { get; }
    [NotNullAttribute]
public IManagedConvertible ManagedConvertible { get; }
    private ICSharpExpression JetBrains.ReSharper.Psi.CSharp.IExpressionArgumentInfo.Expression { get; }
    public IReference ParameterNameReference { get; }
    public IReference ParamsAddReference { get; }
    public bool IsNamedArgument { get; }
    public string ArgumentName { get; }
    public ICSharpInvocationInfo Invocation { get; }
    private IExpression JetBrains.ReSharper.Psi.Tree.IArgument.Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Colon();
    public virtual ITokenNode get_Mode();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpExpression get_Value();
    public virtual IArgumentList get_ContainingArgumentList();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ICSharpExpression SetValue(ICSharpExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual ParameterKind get_Kind();
    public sealed virtual CSharpParameterInstance get_MatchingParameter();
    private sealed virtual override DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.get_MatchingParameter();
    public void InvalidateMatchingParameter();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.IExpressionArgumentInfo.get_Expression();
    public sealed virtual IReference get_ParameterNameReference();
    public sealed virtual IReference get_ParamsAddReference();
    public sealed virtual bool get_IsNamedArgument();
    public sealed virtual string get_ArgumentName();
    public sealed virtual void SetKind(ParameterKind parameterKind);
    public sealed virtual ICSharpArgument ReplaceBy(ICSharpArgument argument);
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    private sealed virtual override IExpression JetBrains.ReSharper.Psi.Tree.IArgument.get_Expression();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    private sealed virtual override DocumentRange JetBrains.ReSharper.Psi.IArgumentInfo.GetDocumentRange();
    protected virtual void ClearCachedData();
    public sealed virtual void SetArgumentName(string name);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpCheckedInfo : object {
    [NotNullAttribute]
public static ICalculationInfo Checked;
    [NotNullAttribute]
public static ICalculationInfo Unchecked;
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    public bool IsChecked { get; }
    private CSharpCheckedInfo(bool info);
    private static CSharpCheckedInfo();
    [CompilerGeneratedAttribute]
public bool get_IsChecked();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpCompositeElement : CompositeElement {
    public PsiLanguageType Language { get; }
    [NotNullAttribute]
public PsiLanguageType PresentationLanguage { get; }
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    [CanBeNullAttribute]
public sealed virtual ICSharpStatement GetContainingStatement();
    public virtual PsiLanguageType get_Language();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpDeclarationBase : CSharpCompositeElement {
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public abstract virtual bool IsSynthetic();
    public abstract virtual IDeclaredElement get_DeclaredElement();
    public abstract virtual string get_DeclaredName();
    public abstract virtual void SetName(string name);
    public abstract virtual TreeTextRange GetNameRange();
    [NotNullAttribute]
protected internal virtual string GetShortNameOfDeclaredElement();
    public virtual XmlNode GetXMLDoc(bool inherit);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpExpressionBase : CSharpCompositeElement {
    private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    private CachedPsiValue`1<IExpressionType> myCachedExpressionType;
    public ConstantValue CachedConstantValue { get; public set; }
    public IExpressionType CachedExpressionType { get; public set; }
    public ConstantValue ConstantValue { get; }
    public bool IsClassifiedAsVariable { get; }
    public bool IsLValue { get; }
    protected virtual void PreInit();
    public virtual IType Type();
    public virtual IType Type(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    [NotNullAttribute]
public abstract virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual IType GetImplicitlyConvertedTo();
    public sealed virtual IType GetImplicitlyConvertedTo(IResolveContext resolveContext);
    public sealed virtual ICSharpExpression GetContainingExpression();
    public virtual bool IsConstantValue();
    public virtual bool IsConstantValue(IResolveContext resolveContext);
    protected bool IsContextChecked(ICalculationInfo info);
    public sealed virtual ConstantValue get_CachedConstantValue();
    public sealed virtual void set_CachedConstantValue(ConstantValue value);
    public sealed virtual IExpressionType get_CachedExpressionType();
    public sealed virtual void set_CachedExpressionType(IExpressionType value);
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public sealed virtual ExpressionAccessType GetAccessType();
    public sealed virtual ExpressionAccessType GetAccessType(IResolveContext resolveContext);
    [PureAttribute]
private ExpressionAccessType GetArgumentExpressionAccessType(ICSharpArgument argument, IResolveContext resolveContext);
    [PureAttribute]
private ExpressionAccessType GetTupleComponentExpressionAccessType(ITupleExpression tupleExpression, IResolveContext resolveContext);
    [PureAttribute]
private static ExpressionAccessType GetReferenceExpressionAccessType(IReferenceExpression referenceExpression, IResolveContext resolveContext);
    [PureAttribute]
private static ExpressionAccessType GetElementAccessExpressionAccessType(IElementAccessExpression elementAccessExpression, IResolveContext resolveContext);
    public sealed virtual TExpression ReplaceBy(TExpression expression);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    [PureAttribute]
protected ExpressionClassification MemberReturnKind2Classification(ReferenceKind referenceKind);
    public sealed virtual bool get_IsClassifiedAsVariable();
    public sealed virtual bool get_IsLValue();
    [NotNullAttribute]
public sealed virtual string Dump();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    [NotNullAttribute]
public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
[PureAttribute]
private bool <Type>g__PreferTargetType|2_0(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
private IType <Type>g__ReturnTargetType|2_1(<>c__DisplayClass2_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpFile : CSharpFileElement {
    public static short IMPORTS_LIST;
    public static short ATTRIBUTE_SECTION;
    public static short TOP_LEVEL_CODE;
    public static short NAMESPACE;
    public static short TYPE;
    [CanBeNullAttribute]
internal PreProcessingDirectivesInFile myPreprocessorConditionals;
    [CanBeNullAttribute]
internal NullableContextCache myNullableContextCache;
    private GlobalUsingsCache myGlobalUsingsCache;
    public NodeType NodeType { get; }
    public IUsingList ImportsList { get; }
    public TreeNodeCollection`1<ICSharpNamespaceDeclaration> NamespaceDeclarationNodes { get; }
    public TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> NamespaceDeclarationNodesEnumerable { get; }
    public TreeNodeCollection`1<IAttributeSection> Sections { get; }
    public TreeNodeEnumerable`1<IAttributeSection> SectionsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IExternAliasDirective> ExternAliases { get; }
    public TreeNodeEnumerable`1<IExternAliasDirective> ExternAliasesEnumerable { get; }
    public TreeNodeCollection`1<IUsingDirective> Imports { get; }
    public TreeNodeEnumerable`1<IUsingDirective> ImportsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpNamespaceDeclaration> NamespaceDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> NamespaceDeclarationsEnumerable { get; }
    public ITopLevelCode TopLevelCodeInternal { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> TypeDeclarationsEnumerable { get; }
    public int LevelDelta { get; }
    private ITypeAndNamespaceHolderDeclaration JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration.ContainingTypeAndNamespaceHolder { get; }
    public ICSharpTypeAndNamespaceHolderDeclaration ContainingTypeAndNamespaceHolder { get; }
    public ITopLevelCode TopLevelCode { get; }
    private IReadOnlyList`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.NamespaceDeclarations { get; }
    private IEnumerable`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.NamespaceDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarationsEnumerable { get; }
    private IEnumerable`1<ModuleProperty> JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies.ModulePropertyDependencies { get; }
    public PsiLanguageType Language { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IUsingList get_ImportsList();
    public virtual TreeNodeCollection`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationNodes();
    public virtual TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationNodesEnumerable();
    public virtual TreeNodeCollection`1<IAttributeSection> get_Sections();
    public virtual TreeNodeEnumerable`1<IAttributeSection> get_SectionsEnumerable();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IExternAliasDirective> get_ExternAliases();
    public virtual TreeNodeEnumerable`1<IExternAliasDirective> get_ExternAliasesEnumerable();
    public virtual TreeNodeCollection`1<IUsingDirective> get_Imports();
    public virtual TreeNodeEnumerable`1<IUsingDirective> get_ImportsEnumerable();
    public virtual TreeNodeCollection`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationsEnumerable();
    public virtual ITopLevelCode get_TopLevelCodeInternal();
    public virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_TypeDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_TypeDeclarationsEnumerable();
    public virtual IUsingList SetImportsList(IUsingList param);
    public virtual string ToString();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpFile/<GetEffectiveUsingDirectives>d__52")]
public sealed virtual IEnumerable`1<IUsingDirective> GetEffectiveUsingDirectives();
    internal TreeNodeEnumerable`1<IUsingDirective> GetGlobalUsings();
    public sealed virtual int get_LevelDelta();
    private sealed virtual override ITypeAndNamespaceHolderDeclaration JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration.get_ContainingTypeAndNamespaceHolder();
    public sealed virtual ICSharpTypeAndNamespaceHolderDeclaration get_ContainingTypeAndNamespaceHolder();
    public sealed virtual ITopLevelCode get_TopLevelCode();
    public sealed virtual ITopLevelCode SetTopLevelCode(ITopLevelCode topLevelCode);
    public sealed virtual IDeclarationsRange GetAllDeclarationsRange();
    [NotNullAttribute]
private ITreeNode GetDeclarationsAnchor();
    public sealed virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange textRange);
    public sealed virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    public sealed virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
    private sealed virtual override IReadOnlyList`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.get_NamespaceDeclarations();
    private sealed virtual override IEnumerable`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.get_NamespaceDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarationsEnumerable();
    public sealed virtual IUsingDirective AddImportAfter(IUsingDirective usingDirective, IUsingDirective anchor);
    public sealed virtual IUsingDirective AddImportBefore(IUsingDirective usingDirective, IUsingDirective anchor);
    public sealed virtual IUsingDirective AddImport(IUsingDirective usingDirective, bool saveUsingListPosition);
    public sealed virtual void RemoveImport(IUsingDirective usingDirective);
    public sealed virtual ICSharpNamespaceDeclaration AddNamespaceDeclarationAfter(ICSharpNamespaceDeclaration namespaceDeclaration, ICSharpNamespaceDeclaration anchor);
    public sealed virtual ICSharpNamespaceDeclaration AddNamespaceDeclarationBefore(ICSharpNamespaceDeclaration namespaceDeclaration, ICSharpNamespaceDeclaration anchor);
    public sealed virtual void RemoveNamespaceDeclaration(ICSharpNamespaceDeclaration namespaceDeclaration);
    public sealed virtual ICSharpTypeDeclaration AddTypeDeclarationAfter(ICSharpTypeDeclaration typeDeclaration, ICSharpTypeDeclaration anchor);
    public sealed virtual ICSharpTypeDeclaration AddTypeDeclarationBefore(ICSharpTypeDeclaration typeDeclaration, ICSharpTypeDeclaration anchor);
    public sealed virtual void RemoveTypeDeclaration(ICSharpTypeDeclaration typeDeclaration);
    public sealed virtual IExternAliasDirective AddExternAliasAfter(IExternAliasDirective externAlias, IExternAliasDirective anchor);
    public sealed virtual IExternAliasDirective AddExternAliasBefore(IExternAliasDirective externAlias, IExternAliasDirective anchor);
    public sealed virtual void RemoveExternAlias(IExternAliasDirective externAlias);
    private sealed virtual override IEnumerable`1<Pair`2<object, IUsingsInfo>> JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies.GetTopLevelHashableEntities();
    private sealed virtual override ICollection`1<string> JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies.GetEmptyNamespaceDeclarations();
    private sealed virtual override IEnumerable`1<ModuleProperty> JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies.get_ModulePropertyDependencies();
    private static void AddEmptyNamespaceDeclarations(ICSharpTypeAndNamespaceHolderDeclaration holder, ICollection`1<string> list);
    [NotNullAttribute]
private IEnumerable`1<Pair`2<object, IUsingsInfo>> EnumerateTypeDeclarationsAndUsings(ICSharpTypeAndNamespaceHolderDeclaration holder, CSharpUsingsInfo currentUsings);
    public sealed virtual IHashableEntityInfo[] CalcAllEntityHashes(object hashableEntity, string parentQualifiedName, String& qualifiedName);
    public sealed virtual IEnumerable EntityChildren(object hashableEntity);
    public sealed virtual bool IsEntityInternal(object hashableEntity);
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    public sealed virtual PreProcessingDirectivesInFile GetPreprocessorConditionals();
    public sealed virtual NullableContextCache GetNullableContextCache();
    public sealed virtual void InvalidateNullableContextCache();
    public sealed virtual void RemoveAttribute(IAttribute attribute);
    public sealed virtual void AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public virtual PsiLanguageType get_Language();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpFileElement : FileElementBase {
    public abstract virtual void Accept(TreeNodeVisitor visitor);
    public abstract virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public abstract virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpGenericToken : CSharpTokenBase {
    [NotNullAttribute]
private TokenNodeType myNodeType;
    [NotNullAttribute]
private string myText;
    public NodeType NodeType { get; }
    public CSharpGenericToken(TokenNodeType nodeType, string text);
    public virtual NodeType get_NodeType();
    public virtual int GetTextLength();
    public virtual string GetText();
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpHashableEntityUtil : object {
    public static Hash PutGetterSetter(Hash hash, IAccessorOwnerDeclaration declaration);
    public static Hash PutParameters(Hash hash, ICSharpParametersOwnerDeclaration declaration);
    public static Hash PutTypeParameters(Hash hash, IList`1<T> typeParameters, IList`1<ITypeParameterConstraintsClause> constraintsClauses);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpLiteralExpression : CSharpExpressionBase {
    public static short LITERAL;
    [NullableAttribute("1")]
private static Char[] DigitSeparatorChars;
    public NodeType NodeType { get; }
    public ITokenNode Literal { get; }
    [NullableAttribute("1")]
private IList`1<ITokenNode> JetBrains.ReSharper.Psi.CSharp.Tree.IStringLiteralOwner.StringLiterals { get; }
    private static CSharpLiteralExpression();
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Literal();
    [NullableContextAttribute("1")]
public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    [NullableContextAttribute("1")]
[PureAttribute]
private static ConstantValue ParseFloatLiteral(string text, IPsiModule psiModule);
    [NullableContextAttribute("1")]
private static ConstantValue ParseIntegerLiteral(string text, IPsiModule psiModule);
    public virtual bool IsConstantValue();
    [NullableContextAttribute("1")]
public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
private sealed virtual override IList`1<ITokenNode> JetBrains.ReSharper.Psi.CSharp.Tree.IStringLiteralOwner.get_StringLiterals();
    [NullableContextAttribute("1")]
private sealed virtual override void JetBrains.ReSharper.Psi.CSharp.Tree.IStringLiteralOwner.SetText(string literalText);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpNamespaceDeclaration : CSharpNamespaceDeclarationStub {
    protected virtual void PreInit();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpNamespaceDeclarationStub : CSharpDeclarationBase {
    public static short CSHARP_KEYWORD;
    public static short CSHARP_QUALIFIER;
    public static short CSHARP_NAME;
    public static short CSHARP_BLOCK;
    public static short CSHARP_SEMICOLON;
    private IOwnerQualification myCachedNamespaceQualification;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedNamespaceQualificationValid;
    [CompilerGeneratedAttribute]
private IDeclaredElement <JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.CacheDeclaredElement>k__BackingField;
    public NodeType NodeType { get; }
    public INamespaceBody Body { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode NamespaceKeyword { get; }
    public IOwnerQualification NamespaceQualification { get; }
    protected IOwnerQualification _NamespaceQualification { get; }
    public ITokenNode Semicolon { get; }
    public ICSharpNamespaceDeclaration ContainingNamespace { get; }
    public TreeNodeCollection`1<IExternAliasDirective> ExternAliases { get; }
    public TreeNodeEnumerable`1<IExternAliasDirective> ExternAliasesEnumerable { get; }
    public TreeNodeCollection`1<IUsingDirective> Imports { get; }
    public TreeNodeEnumerable`1<IUsingDirective> ImportsEnumerable { get; }
    public IUsingList ImportsList { get; }
    public TreeNodeCollection`1<ICSharpNamespaceDeclaration> NamespaceDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> NamespaceDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> TypeDeclarationsEnumerable { get; }
    private INamespace JetBrains.ReSharper.Psi.Tree.INamespaceDeclaration.DeclaredElement { get; }
    public IDeclaredElement DeclaredElement { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.CacheDeclaredElement { get; private set; }
    public string QualifiedName { get; }
    public bool IsFileScoped { get; }
    public string DeclaredName { get; }
    public string ShortName { get; }
    public ICSharpTypeAndNamespaceHolderDeclaration ContainingTypeAndNamespaceHolder { get; }
    private ITypeAndNamespaceHolderDeclaration JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration.ContainingTypeAndNamespaceHolder { get; }
    private IReadOnlyList`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.NamespaceDeclarations { get; }
    private IEnumerable`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.NamespaceDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual INamespaceBody get_Body();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_NamespaceKeyword();
    public sealed virtual IOwnerQualification get_NamespaceQualification();
    protected virtual IOwnerQualification get__NamespaceQualification();
    public virtual ITokenNode get_Semicolon();
    public virtual ICSharpNamespaceDeclaration get_ContainingNamespace();
    public virtual TreeNodeCollection`1<IExternAliasDirective> get_ExternAliases();
    public virtual TreeNodeEnumerable`1<IExternAliasDirective> get_ExternAliasesEnumerable();
    public virtual TreeNodeCollection`1<IUsingDirective> get_Imports();
    public virtual TreeNodeEnumerable`1<IUsingDirective> get_ImportsEnumerable();
    public virtual IUsingList get_ImportsList();
    public virtual TreeNodeCollection`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_TypeDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_TypeDeclarationsEnumerable();
    public virtual INamespaceBody SetBody(INamespaceBody param);
    public virtual IUsingList SetImportsList(IUsingList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IOwnerQualification SetNamespaceQualification(IOwnerQualification param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    private sealed virtual override INamespace JetBrains.ReSharper.Psi.Tree.INamespaceDeclaration.get_DeclaredElement();
    public virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.get_CacheDeclaredElement();
    [CompilerGeneratedAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.set_CacheDeclaredElement(IDeclaredElement value);
    public sealed virtual string get_QualifiedName();
    public sealed virtual bool get_IsFileScoped();
    public virtual bool IsSynthetic();
    public sealed virtual DocumentRange GetDeclaredNameDocumentRange();
    public virtual string get_DeclaredName();
    public sealed virtual string get_ShortName();
    public virtual void SetName(string name);
    public sealed virtual void SetQualifiedName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ICSharpTypeAndNamespaceHolderDeclaration get_ContainingTypeAndNamespaceHolder();
    private sealed virtual override ITypeAndNamespaceHolderDeclaration JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration.get_ContainingTypeAndNamespaceHolder();
    public sealed virtual IDeclarationsRange GetAllDeclarationsRange();
    public sealed virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange textRange);
    public sealed virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    public sealed virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
    private sealed virtual override IReadOnlyList`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.get_NamespaceDeclarations();
    private sealed virtual override IEnumerable`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.get_NamespaceDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarationsEnumerable();
    public sealed virtual ICSharpNamespaceDeclaration ReplaceBy(ICSharpNamespaceDeclaration namespaceDeclaration);
    public sealed virtual IUsingDirective AddImportAfter(IUsingDirective usingDirective, IUsingDirective anchor);
    public sealed virtual IUsingDirective AddImportBefore(IUsingDirective usingDirective, IUsingDirective anchor);
    public sealed virtual IUsingDirective AddImport(IUsingDirective usingDirective, bool saveUsingListPosition);
    public sealed virtual void RemoveImport(IUsingDirective usingDirective);
    public sealed virtual ICSharpNamespaceDeclaration AddNamespaceDeclarationAfter(ICSharpNamespaceDeclaration namespaceDeclaration, ICSharpNamespaceDeclaration anchor);
    public sealed virtual ICSharpNamespaceDeclaration AddNamespaceDeclarationBefore(ICSharpNamespaceDeclaration namespaceDeclaration, ICSharpNamespaceDeclaration anchor);
    public sealed virtual void RemoveNamespaceDeclaration(ICSharpNamespaceDeclaration namespaceDeclaration);
    public sealed virtual ICSharpTypeDeclaration AddTypeDeclarationAfter(ICSharpTypeDeclaration typeDeclaration, ICSharpTypeDeclaration anchor);
    public sealed virtual ICSharpTypeDeclaration AddTypeDeclarationBefore(ICSharpTypeDeclaration typeDeclaration, ICSharpTypeDeclaration anchor);
    public sealed virtual void RemoveTypeDeclaration(ICSharpTypeDeclaration typeDeclaration);
    public sealed virtual IExternAliasDirective AddExternAliasAfter(IExternAliasDirective externAlias, IExternAliasDirective anchor);
    public sealed virtual IExternAliasDirective AddExternAliasBefore(IExternAliasDirective externAlias, IExternAliasDirective anchor);
    public sealed virtual void RemoveExternAlias(IExternAliasDirective externAlias);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpNamespaceDeclarationStub/<GetDeclaredNamespaces>d__106")]
public sealed virtual IEnumerable`1<INamespace> GetDeclaredNamespaces();
    public sealed virtual IEnumerable`1<IUsingDirective> GetEffectiveUsingDirectives();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpNonCachedDeclarationBase : CSharpDeclarationBase {
    public ISubstitution IdSubstitution { get; }
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public bool CaseSensitiveName { get; }
    public string ShortName { get; }
    public IPsiModule Module { get; }
    public virtual ISubstitution get_IdSubstitution();
    public virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public virtual string get_ShortName();
    public abstract virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiModule get_Module();
    public virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public virtual bool IsSynthetic();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CSharpTokenBase : LeafElementBase {
    public PsiLanguageType Language { get; }
    public virtual PsiLanguageType get_Language();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TResult Accept(TreeNodeVisitor`2<TContext, TResult> visitor, TContext context);
    [DebuggerStepThroughAttribute]
public sealed virtual TokenNodeType GetTokenType();
    public virtual string ToString();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.CurrentReferenceBase`1 : ForeachReferenceBase`1<TForeachReferencesOwner> {
    protected CurrentReferenceBase`1(TForeachReferencesOwner owner);
    public virtual string GetName();
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DeclarationExpression : CSharpExpressionBase {
    public static short SCOPED_KEYWORD;
    public static short BYREF;
    public static short READONLY;
    public static short VAR_KEYWORD;
    public static short CSHARP_TYPE;
    public static short VARIABLE_DESIGNATION;
    public NodeType NodeType { get; }
    public IVariableDesignation Designation { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode RefReadonlyKeyword { get; }
    public ITokenNode ScopedKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public ITokenNode VarKeyword { get; }
    public ITreeNode TypeDesignator { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsVar { get; }
    private bool JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.IsLValue { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVariableDesignation get_Designation();
    public virtual ITokenNode get_RefKeyword();
    public virtual ITokenNode get_RefReadonlyKeyword();
    public virtual ITokenNode get_ScopedKeyword();
    public virtual ITypeUsage get_TypeUsage();
    public virtual ITokenNode get_VarKeyword();
    public virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    private bool CanHaveExplicitType();
    public sealed virtual ITreeNode get_TypeDesignator();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual bool get_IsVar();
    public sealed virtual void SetVar();
    public sealed virtual void SetScoped(bool addScopedKeyword);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    public sealed virtual IType GetDesignationType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IExpressionType GetDesignationExpressionType(IVariableDesignation designation, IResolveContext resolveContext);
    private sealed virtual override bool JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.get_IsLValue();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DeclarationStatement : StatementBase {
    public static short DECL;
    public static short CSHARP_SEMICOLON;
    public static short METHOD_DECL;
    public NodeType NodeType { get; }
    public IMultipleDeclaration Declaration { get; }
    public ILocalFunctionDeclaration LocalFunctionDeclaration { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ILocalConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ILocalVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public bool CanBeEmbedded { get; }
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IMultipleDeclaration get_Declaration();
    public virtual ILocalFunctionDeclaration get_LocalFunctionDeclaration();
    public virtual ITokenNode get_Semicolon();
    public virtual TreeNodeCollection`1<ILocalConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<ILocalConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ILocalVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<ILocalVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IMultipleDeclaration SetDeclaration(IMultipleDeclaration param);
    public virtual ILocalFunctionDeclaration SetLocalFunctionDeclaration(ILocalFunctionDeclaration param);
    public virtual string ToString();
    public sealed virtual void RemoveConstantDeclaration(ILocalConstantDeclaration param);
    public sealed virtual void RemoveVariableDeclaration(ILocalVariableDeclaration param);
    public virtual bool get_CanBeEmbedded();
    public sealed virtual bool get_IntroducesScope();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DeconstructionPatternClause : CSharpCompositeElement {
    public static short CSHARP_LPAR;
    public static short CSHARP_PATTERN;
    public static short CSHARP_COMMA;
    public static short CSHARP_RPAR;
    private DeconstructionPatternClauseDeconstructionReference myDeconstructionReference;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<ISubpattern> Patterns { get; }
    public TreeNodeEnumerable`1<ISubpattern> PatternsEnumerable { get; }
    public ITokenNode RPar { get; }
    public IDeconstructionReference DeconstructionReference { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    [NotNullAttribute]
public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IType> TypeArguments { get; }
    public ICSharpInvocationReference Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual TreeNodeCollection`1<ISubpattern> get_Patterns();
    public virtual TreeNodeEnumerable`1<ISubpattern> get_PatternsEnumerable();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IDeconstructionReference get_DeconstructionReference();
    public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual IType GetSubpatternType(ISubpattern subpattern, IResolveContext resolveContext);
    public sealed virtual int IndexOfSubpattern(ISubpattern subpattern);
    private sealed virtual override ReferenceCollection JetBrains.ReSharper.Psi.Tree.ITreeNode.GetFirstClassReferences();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IType> get_TypeArguments();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual string Dump();
    public sealed virtual ISubpattern AddSubpatternAfter(ISubpattern subpattern, ISubpattern anchor);
    public sealed virtual ISubpattern AddSubpatternBefore(ISubpattern subpattern, ISubpattern anchor);
    public sealed virtual void RemoveSubpattern(ISubpattern subpattern);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DeconstructionReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<TTreeNode> {
    public ICSharpInvocationInfo Invocation { get; }
    protected DeconstructionReferenceBase`1(TTreeNode owner);
    public virtual string GetName();
    [PureAttribute]
public abstract virtual IExpressionType GetDeconstructionSourceExpressionType(IResolveContext resolveContext);
    [PureAttribute]
public virtual bool CanResolveIntoITuple();
    [NotNullAttribute]
[PureAttribute]
public ICSharpArgumentInfo[] GetArguments();
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    [PureAttribute]
private static bool IsVoidMethodWithoutOptionalParams(IDeclaredElement declaredElement, int expectedParametersCount);
    public abstract virtual int GetDeconstructionComponentsCount();
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    [CompilerGeneratedAttribute]
internal static ResolveResultWithInfo <Resolve>g__CheckValueTupleCardinality|6_0(int actualComponentsCount, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static bool <Resolve>g__CheckParameterKinds|6_1(IDeclaredElement declaredElement);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DefaultConstraint : CSharpCompositeElement {
    public static short KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode Keyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Keyword();
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DefaultConstructorReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<T> {
    public ICSharpInvocationInfo Invocation { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public ICSharpInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    protected DefaultConstructorReferenceBase`1(T owner);
    protected ResolveResultWithInfo ResolveImpl(IResolveContext resolveContext, IDeclaredType type);
    public virtual string GetName();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DefaultExpression : CSharpExpressionBase {
    public static short CSHARP_LPAR;
    public static short CSHARP_TYPE;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITypeUsage get_TypeName();
    public virtual ITypeUsage SetTypeName(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DefineDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short CSHARP_NAME;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode Name { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public string SymbolName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_Name();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public sealed virtual string get_SymbolName();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DelegateDeclaration : TypeElementDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short KEYWORD;
    public static short BYREF;
    public static short READONLY;
    public static short CSHARP_TYPE;
    public static short CSHARP_NAME;
    public static short TYPE_PARAMETERS_LIST;
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public static short CONSTRAINTS;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public ITokenNode Keyword { get; }
    public ITokenNode LPar { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode RefReadonlyKeyword { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public ICSharpNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParametersEnumerable { get; }
    public ITokenNode TypeDeclarationKeyword { get; }
    public string DeclaredName { get; }
    private IDelegate JetBrains.ReSharper.Psi.CSharp.Tree.IDelegateDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IProperTypeDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration.DeclaredElement { get; }
    private ITypeElement JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public IReadOnlyList`1<ITypeDeclaration> TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    public IReadOnlyList`1<ITypeDeclaration> NestedTypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    public IReadOnlyList`1<ITypeMemberDeclaration> MemberDeclarations { get; }
    private TreeNodeCollection`1<ICSharpTypeMemberDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration.MemberDeclarations { get; }
    public IType Type { get; }
    public IEnumerable`1<IDeclaredType> SuperTypes { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<ICSharpHashableDeclaration> Children { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual ITokenNode get_Keyword();
    public virtual ITokenNode get_LPar();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IFormalParameterList get_Params();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_RefKeyword();
    public virtual ITokenNode get_RefReadonlyKeyword();
    public virtual ITokenNode get_Semicolon();
    public virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public virtual ITypeParameterOfTypeList get_TypeParameterList();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual ICSharpNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParametersEnumerable();
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IFormalParameterList SetParams(IFormalParameterList param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual ITokenNode get_TypeDeclarationKeyword();
    public virtual string get_DeclaredName();
    public sealed virtual bool CanBindTo(ITypeElement typeElement);
    private sealed virtual override IDelegate JetBrains.ReSharper.Psi.CSharp.Tree.IDelegateDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IProperTypeDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual void SetStatic(bool value);
    public virtual TreeTextRange GetNameRange();
    public virtual void SetName(string name);
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_NestedTypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    public sealed virtual IReadOnlyList`1<ITypeMemberDeclaration> get_MemberDeclarations();
    private sealed virtual override TreeNodeCollection`1<ICSharpTypeMemberDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration.get_MemberDeclarations();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration typeParameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IEnumerable`1<IDeclaredType> get_SuperTypes();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual void SetReturnKind(ReferenceKind referenceKind);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public virtual int get_LevelDelta();
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public virtual IEnumerable`1<ICSharpHashableDeclaration> get_Children();
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override IClassLikeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.IProperTypeDeclaration.GetContainingClassLikeDeclaration();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DestructorDeclaration : DestructorDeclarationStub {
    protected virtual IDeclaredElement CreateDeclaredElement();
    public virtual IBlock SetBody(IBlock param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DestructorDeclarationStub : ProperTypeMemberDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short CSHARP_TILDE;
    public static short CSHARP_NAME;
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public static short CSHARP_BLOCK;
    public static short ARROW_CLAUSE;
    public static short CSHARP_SEMICOLON;
    private static string TILDE_CHAR;
    public NodeType NodeType { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IBlock Body { get; }
    public ITokenNode LPar { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode Tilde { get; }
    public ICSharpIdentifier TypeName { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public string DeclaredName { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    public int LevelDelta { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public bool IsOverride { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public IParametersOwner DeclaredParametersOwner { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IBlock get_Body();
    public virtual ITokenNode get_LPar();
    public virtual IFormalParameterList get_Params();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_Tilde();
    public virtual ICSharpIdentifier get_TypeName();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IBlock SetBody(IBlock param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IFormalParameterList SetParams(IFormalParameterList param);
    public virtual ICSharpIdentifier SetTypeName(ICSharpIdentifier param);
    public virtual string ToString();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public virtual string get_DeclaredName();
    protected internal virtual string GetShortNameOfDeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public virtual bool get_IsOverride();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsync();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public sealed virtual IParametersOwner get_DeclaredParametersOwner();
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DiscardDesignation : CSharpCompositeElement {
    public static short CSHARP_NAME;
    public NodeType NodeType { get; }
    public ICSharpIdentifier UnderscoreIdentifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_UnderscoreIdentifier();
    public virtual ICSharpIdentifier SetUnderscoreIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DiscardPattern : CSharpCompositeElement {
    public static short CSHARP_NAME;
    public NodeType NodeType { get; }
    public ICSharpIdentifier Underscore { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_Underscore();
    public virtual ICSharpIdentifier SetUnderscore(ICSharpIdentifier param);
    public virtual string ToString();
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DisposeAsyncAwaiterGetResultReferenceBase`1 : AwaiterGetResultReferenceBase`1<TOwner> {
    protected DisposeAsyncAwaiterGetResultReferenceBase`1(TOwner owner);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DisposeAsyncGetAwaiterReferenceBase`1 : GetAwaiterReferenceBase`1<TOwner> {
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    protected DisposeAsyncGetAwaiterReferenceBase`1(TOwner owner);
    protected virtual IType GetQualifierType(IResolveContext resolveContext);
    public virtual ICSharpArgumentInfo get_ExtensionQualifier();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DisposeMethodReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<TDisposeMethodReferenceOwner> {
    protected bool IsAsyncContext { get; }
    protected DisposeMethodReferenceBase`1(TDisposeMethodReferenceOwner owner);
    public abstract virtual IExpressionType GetResourceExpressionType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetResourceExpressionType();
    protected abstract virtual bool get_IsAsyncContext();
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public virtual string GetName();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    private sealed virtual override Staticness JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetStaticness();
    private sealed virtual override QualifierKind JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetQualifierKind();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocComment : Comment {
    public DocComment(TokenNodeType nodeType, string text);
    public virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    public sealed virtual IDocCommentNode ReplaceBy(IDocCommentNode docCommentNode);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCommentBlock : CSharpCompositeElement {
    [CompilerGeneratedAttribute]
private List`1<ICSharpDocCommentReference> <MajorReferences>k__BackingField;
    private int myInLocalBind;
    [CanBeNullAttribute]
private CSharpDocCommentXmlPsi myDocCommentXmlPsi;
    [CanBeNullAttribute]
internal List`1<ICSharpDocCommentReference> MajorReferences { get; private set; }
    public TreeNodeCollection`1<IDocCommentNode> DocComments { get; }
    public NodeType NodeType { get; }
    private bool IsInLocalBind { get; }
    [CompilerGeneratedAttribute]
internal List`1<ICSharpDocCommentReference> get_MajorReferences();
    [CompilerGeneratedAttribute]
private void set_MajorReferences(List`1<ICSharpDocCommentReference> value);
    public sealed virtual TreeNodeCollection`1<IDocCommentNode> get_DocComments();
    public virtual bool IsFiltered();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    public sealed virtual IDocCommentNode AddDocCommentBefore(IDocCommentNode nodeToAdd, IDocCommentNode anchor);
    public sealed virtual IDocCommentNode AddDocCommentAfter(IDocCommentNode nodeToAdd, IDocCommentNode anchor);
    public sealed virtual void RemoveDocComment(IDocCommentNode docCommentNode);
    protected virtual void PreInit();
    public sealed virtual IDocCommentXmlPsi GetXmlPsi();
    public virtual NodeType get_NodeType();
    private bool get_IsInLocalBind();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual ReferenceCollection GetFirstClassReferences();
    private static void ScanForReferences(ITreeNode node, ICollection`1<IReference> references);
    public sealed virtual IReadOnlyCollection`1<DocCommentError> GetErrors();
    internal bool IsValid(DocCRefExpression expression);
    private static void ScanForErrors(ITreeNode node, ICollection`1<DocCommentError> errors);
    protected virtual void ClearCachedData();
    private void Parse();
    [NotNullAttribute]
private ICommentNode ReplaceSubText(ITokenNode comment, TreeTextRange oldRange, string text);
    public void BindReferenceToParameter(ParameterReference reference, IDeclaredElement target);
    public void BindReferenceToTypeParameter(TypeParameterReference reference, IDeclaredElement target);
    internal IDocCommentReference BindReferenceTo(CompiledReference reference, IDeclaredElement target);
    internal DocCRefReferenceBase BindReferenceTo(DocCRefReferenceBase reference, DeclaredElementInstance instance);
    [NotNullAttribute]
private static string GetSignatureText(IParametersOwner parametersOwner, ISubstitution substitution);
    [NotNullAttribute]
public DocCRefExpression ParseCRefExpression(string str);
    [NotNullAttribute]
private DocCRefParameterTypeName ParseCRefParameterTypeName(string str);
    [NotNullAttribute]
private string BuildNamespaceQualification(IDocCommentReference reference, INamespace target);
    [NotNullAttribute]
private string BuildTypeElementQualification(IDocCommentReference reference, ITypeElement target, ISubstitution substitution);
    private bool TryImportNamespace(IDocCommentReference reference, INamespace containingNamespace, IDeclaredElement target, ISubstitution substitution);
    private IDeclaredElement ResolveString(string str);
    [NotNullAttribute]
private string BuildTypeMemberQualification(IDocCommentReference reference, ITypeMember target, ISubstitution substitution);
    public sealed virtual XmlNode GetXML(ITypeMember element);
    private void CompileXmlNode(XmlNode node);
    private void CompileCRefReference(XmlAttribute crefAttribute);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefElement : DocCRefReferenceBase {
    public static short QUALIFIER;
    public static short CSHARP_REFERENCE_DELIMITER;
    public static short NAME;
    public static short TYPE_PARAMETER_LIST;
    public static short LPAR;
    public static short SIGNATURE;
    public static short RPAR;
    public static short THIS_KEYWORD;
    public static short OPERATOR_KEYWORD;
    public static short CHECKED_KEYWORD;
    public static short OPERATOR_SIGN;
    public static short IMPLICIT_KEYWORD;
    public static short EXPLICIT_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode CheckedKeyword { get; }
    public ITokenNode Delimiter { get; }
    public ITokenNode ExplicitKeyword { get; }
    public ITokenNode ImplicitKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode Name { get; }
    public ITokenNode OperatorKeyword { get; }
    public ITokenNode OperatorSign { get; }
    public IDocCRefElement Qualifier { get; }
    public ITokenNode RPar { get; }
    public IDocCRefSignature Signature { get; }
    public ITokenNode ThisKeyword { get; }
    public IDocCRefTypeParameterList TypeParameterList { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_CheckedKeyword();
    public virtual ITokenNode get_Delimiter();
    public virtual ITokenNode get_ExplicitKeyword();
    public virtual ITokenNode get_ImplicitKeyword();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_Name();
    public virtual ITokenNode get_OperatorKeyword();
    public virtual ITokenNode get_OperatorSign();
    public virtual IDocCRefElement get_Qualifier();
    public virtual ITokenNode get_RPar();
    public virtual IDocCRefSignature get_Signature();
    public virtual ITokenNode get_ThisKeyword();
    public virtual IDocCRefTypeParameterList get_TypeParameterList();
    public virtual IDocCRefElement SetQualifier(IDocCRefElement param);
    public virtual IDocCRefSignature SetSignature(IDocCRefSignature param);
    public virtual IDocCRefTypeParameterList SetTypeParameterList(IDocCRefTypeParameterList param);
    public virtual string ToString();
    public virtual TreeTextRange GetSignatureRange();
    protected virtual TreeTextRange GetReferenceLocalTreeTextRange();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefElement/<GetAllTypeParameters>d__52")]
public IEnumerable`1<ITypeParameter> GetAllTypeParameters();
    protected virtual int GetTypeParametersLength();
    protected virtual string GetNameForResolve();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    [NotNullAttribute]
protected virtual ISymbolFilter[] ResolveFilters(string name);
    public virtual IQualifier GetQualifier();
    public virtual ITokenNode GetQualifierDelimiter();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefExpression : CSharpCompositeElement {
    public static short ELEMENT;
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommentNode <CommentNode>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeTranslator <LocalTranslator>k__BackingField;
    public NodeType NodeType { get; }
    public IDocCRefElement Element { get; }
    internal string TagName { get; internal set; }
    internal ICommentNode CommentNode { get; internal set; }
    internal RangeTranslator LocalTranslator { get; internal set; }
    [NotNullAttribute]
internal DocCommentBlock DocCommentBlock { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IDocCRefElement get_Element();
    public virtual IDocCRefElement SetElement(IDocCRefElement param);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal string get_TagName();
    [CompilerGeneratedAttribute]
internal void set_TagName(string value);
    [CompilerGeneratedAttribute]
internal ICommentNode get_CommentNode();
    [CompilerGeneratedAttribute]
internal void set_CommentNode(ICommentNode value);
    [CompilerGeneratedAttribute]
internal RangeTranslator get_LocalTranslator();
    [CompilerGeneratedAttribute]
internal void set_LocalTranslator(RangeTranslator value);
    public TreeTextRange GetCommentRange(TreeTextRange localRange);
    public TreeTextRange GetGlobalRange(TreeTextRange localRange);
    internal DocCommentBlock get_DocCommentBlock();
    public sealed virtual IPsiModule GetPsiModule();
    public virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefParameter : CSharpCompositeElement {
    public static short REF_KEYWORD;
    public static short READONLY_KEYWORD;
    public static short OUT_KEYWORD;
    public static short IN_KEYWORD;
    public static short PARAMTYPE;
    public NodeType NodeType { get; }
    public ITokenNode InKeyword { get; }
    public ITokenNode OutKeyword { get; }
    public IDocCRefParameterType ParameterType { get; }
    public ITokenNode ReadonlyKeyword { get; }
    public ITokenNode RefKeyword { get; }
    public IType Type { get; }
    public ParameterKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_InKeyword();
    public virtual ITokenNode get_OutKeyword();
    public virtual IDocCRefParameterType get_ParameterType();
    public virtual ITokenNode get_ReadonlyKeyword();
    public virtual ITokenNode get_RefKeyword();
    public virtual IDocCRefParameterType SetParameterType(IDocCRefParameterType param);
    public virtual string ToString();
    public IType get_Type();
    public ParameterKind get_Kind();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefParameterType : CSharpCompositeElement {
    public static short TYPE_NAME;
    public static short NULLABLE;
    public static short POINTER;
    public static short RANK;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IRankSpecifier> ArrayRanks { get; }
    public TreeNodeEnumerable`1<IRankSpecifier> ArrayRanksEnumerable { get; }
    public INullableTypeMark NullableMark { get; }
    public TreeNodeCollection`1<IUnsafeCodePointer> PointerMarks { get; }
    public TreeNodeEnumerable`1<IUnsafeCodePointer> PointerMarksEnumerable { get; }
    public IDocCRefParameterTypeName TypeName { get; }
    public IType Type { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IRankSpecifier> get_ArrayRanks();
    public virtual TreeNodeEnumerable`1<IRankSpecifier> get_ArrayRanksEnumerable();
    public virtual INullableTypeMark get_NullableMark();
    public virtual TreeNodeCollection`1<IUnsafeCodePointer> get_PointerMarks();
    public virtual TreeNodeEnumerable`1<IUnsafeCodePointer> get_PointerMarksEnumerable();
    public virtual IDocCRefParameterTypeName get_TypeName();
    public virtual INullableTypeMark SetNullableMark(INullableTypeMark param);
    public virtual IDocCRefParameterTypeName SetTypeName(IDocCRefParameterTypeName param);
    public virtual string ToString();
    public IType get_Type();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefParameterTypeName : DocCRefReferenceBase {
    public static short QUALIFIER;
    public static short CSHARP_REFERENCE_DELIMITER;
    public static short NAME;
    public static short TYPE_ARGUMENT;
    public static short COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode Delimiter { get; }
    public ITokenNode Name { get; }
    public IDocCRefParameterTypeName Qualifier { get; }
    public TreeNodeCollection`1<IDocCRefParameterType> TypeArguments { get; }
    public TreeNodeEnumerable`1<IDocCRefParameterType> TypeArgumentsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_Delimiter();
    public virtual ITokenNode get_Name();
    public virtual IDocCRefParameterTypeName get_Qualifier();
    public virtual TreeNodeCollection`1<IDocCRefParameterType> get_TypeArguments();
    public virtual TreeNodeEnumerable`1<IDocCRefParameterType> get_TypeArgumentsEnumerable();
    public virtual IDocCRefParameterTypeName SetQualifier(IDocCRefParameterTypeName param);
    public virtual string ToString();
    protected virtual int GetTypeParametersLength();
    public virtual TreeTextRange GetSignatureRange();
    protected virtual TreeTextRange GetReferenceLocalTreeTextRange();
    protected virtual string GetNameForResolve();
    public virtual IQualifier GetQualifier();
    public virtual ITokenNode GetQualifierDelimiter();
    protected virtual ISymbolTable PatchSymbolTable(ISymbolTable table);
    public virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    private static IList`1<ITypeParameter> GetTypeParameters(IDeclaredElement declaredElement);
    protected virtual ISymbolFilter[] ResolveFilters(string name);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefReferenceBase : CSharpCompositeElement {
    private static Func`2<DocCRefReferenceBase, ResolveResultWithInfo> ResolveWithoutCacheFunc;
    private LocalUserDataHolder myUserDataHolder;
    private CachedPsiValue`1<ResolveResultWithInfo> myResolveCache;
    public DocCRefExpression DocCRefExpression { get; }
    [CanBeNullAttribute]
private ITypeElement ContainingTypeElement { get; }
    private ITypeDeclaration ContainingTypeDeclaration { get; }
    public ICommentNode CommentNode { get; public set; }
    public TreeOffset LocalOffset { get; public set; }
    public string TagName { get; }
    public bool HasMultipleNames { get; }
    public bool ShouldResolveInGlobalTable { get; }
    public bool IsQualified { get; }
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    public bool Resolved { get; }
    private static DocCRefReferenceBase();
    public DocCRefExpression get_DocCRefExpression();
    private ITypeElement get_ContainingTypeElement();
    private ITypeDeclaration get_ContainingTypeDeclaration();
    public virtual ISymbolTable GetCompletionSymbolTable();
    public sealed virtual ICommentNode get_CommentNode();
    public sealed virtual void set_CommentNode(ICommentNode value);
    public sealed virtual TreeOffset get_LocalOffset();
    public sealed virtual void set_LocalOffset(TreeOffset value);
    public abstract virtual TreeTextRange GetSignatureRange();
    public sealed virtual string get_TagName();
    private sealed virtual override TreeTextRange JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeTextRange();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public sealed virtual ResolveResultWithInfo Resolve();
    public sealed virtual IReference BindTo(IDeclaredElement element);
    public sealed virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual IAccessContext GetAccessContext();
    public virtual bool IsValid();
    public sealed virtual ITreeNode GetTreeNode();
    public sealed virtual string GetName();
    public sealed virtual bool get_HasMultipleNames();
    public sealed virtual HybridCollection`1<string> GetAllNames();
    public virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    public sealed virtual bool get_ShouldResolveInGlobalTable();
    public sealed virtual bool get_IsQualified();
    public abstract virtual IQualifier GetQualifier();
    public abstract virtual ITokenNode GetQualifierDelimiter();
    protected abstract virtual string GetNameForResolve();
    protected virtual void PreInit();
    public sealed virtual void PutData(Key`1<T> key, T val);
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public sealed virtual ResolveResultWithInfo get_CurrentResolveResult();
    public sealed virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    protected abstract virtual int GetTypeParametersLength();
    protected abstract virtual TreeTextRange GetReferenceLocalTreeTextRange();
    protected virtual ISymbolFilter[] ResolveFilters(string name);
    [NotNullAttribute]
protected virtual ISymbolTable PatchSymbolTable(ISymbolTable table);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefSignature : CSharpCompositeElement {
    public static short PARAMETER;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IDocCRefParameter> Parameters { get; }
    public TreeNodeEnumerable`1<IDocCRefParameter> ParametersEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IDocCRefParameter> get_Parameters();
    public virtual TreeNodeEnumerable`1<IDocCRefParameter> get_ParametersEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefTypeParameter : CSharpCompositeElement {
    public static short NAME;
    public NodeType NodeType { get; }
    public ITokenNode Name { get; }
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public IPsiModule Module { get; }
    [CanBeNullAttribute]
private DocCRefElement DocCRefElement { get; }
    public int Index { get; }
    public TypeParameterVariance Variance { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsUnmanagedType { get; }
    public bool HasDefaultConstructor { get; }
    public bool IsNotNullableValueOrReferenceType { get; }
    public bool AllowsByRefLikeType { get; }
    public TypeParameterNullability Nullability { get; }
    public ITypeParametersOwner Owner { get; }
    public ITypeElement OwnerType { get; }
    public IParametersOwner OwnerFunction { get; }
    public IMethod OwnerMethod { get; }
    public TypeParameterConstraintFlags Constraints { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool HasTypeConstraints { get; }
    public IList`1<IType> TypeConstraints { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public ISubstitution IdSubstitution { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Name();
    public virtual string ToString();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IPsiModule get_Module();
    private DocCRefElement get_DocCRefElement();
    public sealed virtual int get_Index();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsUnmanagedType();
    public sealed virtual bool get_HasDefaultConstructor();
    public sealed virtual bool get_IsNotNullableValueOrReferenceType();
    public sealed virtual bool get_AllowsByRefLikeType();
    public sealed virtual TypeParameterNullability get_Nullability();
    public sealed virtual ITypeParametersOwner get_Owner();
    public sealed virtual ITypeElement get_OwnerType();
    public sealed virtual IParametersOwner get_OwnerFunction();
    public sealed virtual IMethod get_OwnerMethod();
    public sealed virtual TypeParameterConstraintFlags get_Constraints();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public sealed virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual TypeParameterNullability GetNullability(ISubstitution explicitInheritorSubstitution);
    public sealed virtual bool get_HasTypeConstraints();
    public sealed virtual IList`1<IType> get_TypeConstraints();
    public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DocCRefTypeParameterList : CSharpCompositeElement {
    public static short TYPE_PARAMETER;
    public static short COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IDocCRefTypeParameter> TypeParameters { get; }
    public TreeNodeEnumerable`1<IDocCRefTypeParameter> TypeParametersEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IDocCRefTypeParameter> get_TypeParameters();
    public virtual TreeNodeEnumerable`1<IDocCRefTypeParameter> get_TypeParametersEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DoStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_BODY;
    public static short KEYWORD2;
    public static short CSHARP_LPAR;
    public static short CSHARP_CONDITION;
    public static short CSHARP_RPAR;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ICSharpStatement Body { get; }
    public ICSharpExpression Condition { get; }
    public ITokenNode DoKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode WhileKeyword { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpStatement get_Body();
    public virtual ICSharpExpression get_Condition();
    public virtual ITokenNode get_DoKeyword();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_WhileKeyword();
    public virtual ICSharpStatement SetBody(ICSharpStatement param);
    public virtual ICSharpExpression SetCondition(ICSharpExpression param);
    public virtual string ToString();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.DynamicDeclaredTypeUsage : object {
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ElementAccessExpression : CSharpExpressionBase {
    public static short OP;
    public static short CSHARP_OP1;
    public static short CSHARP_LBRACKET;
    public static short ARGUMENT_LIST;
    public static short CSHARP_RBRACKET;
    private ElementAccessExpressionReference myReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode LBracket { get; }
    public IPrimaryExpression Operand { get; }
    public ITokenNode RBracket { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    private IElementAccessExpressionReference JetBrains.ReSharper.Psi.CSharp.Tree.IElementAccessExpression.ElementAccessReference { get; }
    private IElementAccessExpressionReference JetBrains.ReSharper.Psi.CSharp.Tree.IElementAccessExpression.Reference { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    public bool HasConditionalAccessSign { get; }
    public ICSharpExpression ConditionalQualifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual IConditionalAccessSign get_ConditionalAccessSign();
    public virtual ITokenNode get_LBracket();
    public virtual IPrimaryExpression get_Operand();
    public virtual ITokenNode get_RBracket();
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public virtual IPrimaryExpression SetOperand(IPrimaryExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    private sealed virtual override IElementAccessExpressionReference JetBrains.ReSharper.Psi.CSharp.Tree.IElementAccessExpression.get_ElementAccessReference();
    private sealed virtual override IElementAccessExpressionReference JetBrains.ReSharper.Psi.CSharp.Tree.IElementAccessExpression.get_Reference();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IList`1<ITokenNode> get_Delimiters();
    public sealed virtual ITokenNode get_LBound();
    public sealed virtual ITokenNode get_RBound();
    public sealed virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual void RemoveArgument(ICSharpArgument argument);
    public sealed virtual bool get_HasConditionalAccessSign();
    public sealed virtual ICSharpExpression get_ConditionalQualifier();
    public sealed virtual ICSharpExpression SetConditionalQualifier(ICSharpExpression expression);
    public sealed virtual void SetConditionalAccessSign(bool value);
    public sealed virtual IExpressionType UnliftedExpressionType();
    [CompilerGeneratedAttribute]
private bool <Classify>g__IsStructMemberIsClassifiedAsVariable|32_0(ITypeMember typeMember, <>c__DisplayClass32_0& );
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ElementAccessReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<TArgumentsOwner> {
    public ICSharpInvocationInfo Invocation { get; }
    protected ElementAccessReferenceBase`1(TArgumentsOwner owner);
    [CanBeNullAttribute]
protected abstract virtual IType GetQualifierType(IResolveContext resolveContext);
    protected abstract virtual QualifierKind GetQualifierKind();
    public sealed virtual Refers RefersToDeclaredElement(IDeclaredElement declaredElement);
    public virtual string GetName();
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    protected virtual ISymbolTable GetSymbolTableForResolve(IType qualifierType, IResolveContext resolveContext);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public abstract virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    protected ISymbolTable GetIndexerSymbolTable();
    [CompilerGeneratedAttribute]
private Refers <RefersToDeclaredElement>b__3_0(IDeclaredElement element);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ElementBitsets : object {
    public static NodeTypeSet ACCESSOR_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet ATTRIBUTES_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet BINARY_EXPRESSION_BIT_SET;
    public static NodeTypeSet BINARY_PATTERN_BIT_SET;
    public static NodeTypeSet C_SHARP_ARGUMENTS_OWNER_BIT_SET;
    public static NodeTypeSet C_SHARP_DECLARATION_BIT_SET;
    public static NodeTypeSet C_SHARP_EXPRESSION_BIT_SET;
    public static NodeTypeSet C_SHARP_FUNCTION_DECLARATION_BIT_SET;
    public static NodeTypeSet C_SHARP_MODIFIERS_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet C_SHARP_PARAMETER_DECLARATION_BIT_SET;
    public static NodeTypeSet C_SHARP_PARAMETERS_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet C_SHARP_REGULAR_PARAMETER_DECLARATION_BIT_SET;
    public static NodeTypeSet C_SHARP_STATEMENT_BIT_SET;
    public static NodeTypeSet C_SHARP_TYPE_AND_NAMESPACE_HOLDER_DECLARATION_BIT_SET;
    public static NodeTypeSet C_SHARP_TYPE_DECLARATION_BIT_SET;
    public static NodeTypeSet C_SHARP_TYPE_MEMBER_DECLARATION_BIT_SET;
    public static NodeTypeSet CATCH_CLAUSE_BIT_SET;
    public static NodeTypeSet CLASS_LIKE_DECLARATION_BIT_SET;
    public static NodeTypeSet CLASS_MEMBER_DECLARATION_BIT_SET;
    public static NodeTypeSet COLLECTION_EXPRESSION_ELEMENT_BIT_SET;
    public static NodeTypeSet CREATION_EXPRESSION_BIT_SET;
    public static NodeTypeSet CREATION_EXPRESSION_INITIALIZER_BIT_SET;
    public static NodeTypeSet EXPRESSION_BODY_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet INITIALIZED_MEMBER_INITIALIZER_BIT_SET;
    public static NodeTypeSet INITIALIZER_ELEMENT_BIT_SET;
    public static NodeTypeSet INTERFACE_QUALIFICATION_OWNER_BIT_SET;
    public static NodeTypeSet LOCAL_PARAMETER_DECLARATION_BIT_SET;
    public static NodeTypeSet MEMBER_INITIALIZER_BIT_SET;
    public static NodeTypeSet MEMBER_OWNER_BODY_BIT_SET;
    public static NodeTypeSet MEMBER_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet MULTIPLE_DECLARATION_BIT_SET;
    public static NodeTypeSet MULTIPLE_DECLARATION_MEMBER_BIT_SET;
    public static NodeTypeSet NAMED_MEMBER_INITIALIZER_BIT_SET;
    public static NodeTypeSet OPERATOR_DECLARATION_BIT_SET;
    public static NodeTypeSet OPERATOR_EXPRESSION_BIT_SET;
    public static NodeTypeSet OVERFLOW_CHECKING_STATEMENT_BIT_SET;
    public static NodeTypeSet PATTERN_BIT_SET;
    public static NodeTypeSet PREPROCESSOR_BIT_SET;
    public static NodeTypeSet PREPROCESSOR_DIRECTIVE_BIT_SET;
    public static NodeTypeSet PREPROCESSOR_EXPRESSION_BIT_SET;
    public static NodeTypeSet PREPROCESSOR_UNARY_EXPRESSION_BIT_SET;
    public static NodeTypeSet PRIMARY_EXPRESSION_BIT_SET;
    public static NodeTypeSet QUERY_CLAUSE_BIT_SET;
    public static NodeTypeSet QUERY_CLAUSES_HOLDER_BIT_SET;
    public static NodeTypeSet SCALAR_TYPE_USAGE_BIT_SET;
    public static NodeTypeSet STATEMENTS_OWNER_BIT_SET;
    public static NodeTypeSet TYPE_PARAMETER_CONSTRAINT_BIT_SET;
    public static NodeTypeSet TYPE_PARAMETER_DECLARATION_BIT_SET;
    public static NodeTypeSet TYPE_USAGE_BIT_SET;
    public static NodeTypeSet UNARY_EXPRESSION_BIT_SET;
    public static NodeTypeSet USING_DIRECTIVE_BIT_SET;
    public static NodeTypeSet VARIABLE_DECLARATION_BIT_SET;
    public static NodeTypeSet VARIABLE_DESIGNATION_BIT_SET;
    public static NodeTypeSet VARIABLE_INITIALIZER_BIT_SET;
    private static ElementBitsets();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ElementType : object {
    public static CompositeNodeType ERROR_ELEMENT;
    public static int ERROR_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ACCESSOR_DECLARATION;
    public static int ACCESSOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType ADDITIVE_EXPRESSION;
    public static int ADDITIVE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ALLOWS_REF_STRUCT_CONSTRAINT;
    public static int ALLOWS_REF_STRUCT_CONSTRAINT_NODE_TYPE_INDEX;
    public static CompositeNodeType AND_PATTERN;
    public static int AND_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType ANONYMOUS_MEMBER_DECLARATION;
    public static int ANONYMOUS_MEMBER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType ANONYMOUS_METHOD_EXPRESSION;
    public static int ANONYMOUS_METHOD_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ANONYMOUS_OBJECT_CREATION_EXPRESSION;
    public static int ANONYMOUS_OBJECT_CREATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ANONYMOUS_OBJECT_INITIALIZER;
    public static int ANONYMOUS_OBJECT_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType ARGLIST_EXPRESSION;
    public static int ARGLIST_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ARGUMENT_LIST;
    public static int ARGUMENT_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType ARRAY_CREATION_EXPRESSION;
    public static int ARRAY_CREATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ARRAY_INITIALIZER;
    public static int ARRAY_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType ARRAY_TYPE_USAGE;
    public static int ARRAY_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType ARROW_EXPRESSION_CLAUSE;
    public static int ARROW_EXPRESSION_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType AS_EXPRESSION;
    public static int AS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ASSIGNMENT_EXPRESSION;
    public static int ASSIGNMENT_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ATTRIBUTE;
    public static int ATTRIBUTE_NODE_TYPE_INDEX;
    public static CompositeNodeType ATTRIBUTE_LIST;
    public static int ATTRIBUTE_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType ATTRIBUTE_SECTION;
    public static int ATTRIBUTE_SECTION_NODE_TYPE_INDEX;
    public static CompositeNodeType ATTRIBUTE_SECTION_LIST;
    public static int ATTRIBUTE_SECTION_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType AWAIT_EXPRESSION;
    public static int AWAIT_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType BASE_EXPRESSION;
    public static int BASE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType BITWISE_AND_EXPRESSION;
    public static int BITWISE_AND_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType BITWISE_EXCLUSIVE_OR_EXPRESSION;
    public static int BITWISE_EXCLUSIVE_OR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType BITWISE_INCLUSIVE_OR_EXPRESSION;
    public static int BITWISE_INCLUSIVE_OR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType BLOCK;
    public static int BLOCK_NODE_TYPE_INDEX;
    public static CompositeNodeType BREAK_STATEMENT;
    public static int BREAK_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType C_SHARP_ARGUMENT;
    public static int C_SHARP_ARGUMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType C_SHARP_FILE;
    public static int C_SHARP_FILE_NODE_TYPE_INDEX;
    public static CompositeNodeType C_SHARP_LITERAL_EXPRESSION;
    public static int C_SHARP_LITERAL_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType C_SHARP_NAMESPACE_DECLARATION;
    public static int C_SHARP_NAMESPACE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType CAST_EXPRESSION;
    public static int CAST_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType CATCH_VARIABLE_DECLARATION;
    public static int CATCH_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType CHECKED_EXPRESSION;
    public static int CHECKED_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType CHECKED_STATEMENT;
    public static int CHECKED_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType CLASS_BODY;
    public static int CLASS_BODY_NODE_TYPE_INDEX;
    public static CompositeNodeType CLASS_DECLARATION;
    public static int CLASS_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType COLLECTION_ELEMENT_INITIALIZER;
    public static int COLLECTION_ELEMENT_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType COLLECTION_EXPRESSION;
    public static int COLLECTION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType COLLECTION_INITIALIZER;
    public static int COLLECTION_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType CONDITIONAL_ACCESS_SIGN;
    public static int CONDITIONAL_ACCESS_SIGN_NODE_TYPE_INDEX;
    public static CompositeNodeType CONDITIONAL_AND_EXPRESSION;
    public static int CONDITIONAL_AND_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONDITIONAL_OR_EXPRESSION;
    public static int CONDITIONAL_OR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONDITIONAL_TERNARY_EXPRESSION;
    public static int CONDITIONAL_TERNARY_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONSTANT_DECLARATION;
    public static int CONSTANT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONSTANT_OR_TYPE_PATTERN;
    public static int CONSTANT_OR_TYPE_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType CONSTRUCTOR_CONSTRAINT;
    public static int CONSTRUCTOR_CONSTRAINT_NODE_TYPE_INDEX;
    public static CompositeNodeType CONSTRUCTOR_DECLARATION;
    public static int CONSTRUCTOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONSTRUCTOR_INITIALIZER;
    public static int CONSTRUCTOR_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType CONTINUE_STATEMENT;
    public static int CONTINUE_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType CONVERSION_OPERATOR_DECLARATION;
    public static int CONVERSION_OPERATOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType DECLARATION_EXPRESSION;
    public static int DECLARATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType DECLARATION_STATEMENT;
    public static int DECLARATION_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType DECONSTRUCTION_PATTERN_CLAUSE;
    public static int DECONSTRUCTION_PATTERN_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType DEFAULT_CONSTRAINT;
    public static int DEFAULT_CONSTRAINT_NODE_TYPE_INDEX;
    public static CompositeNodeType DEFAULT_EXPRESSION;
    public static int DEFAULT_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType DEFINE_DIRECTIVE;
    public static int DEFINE_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType DELEGATE_DECLARATION;
    public static int DELEGATE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType DESTRUCTOR_DECLARATION;
    public static int DESTRUCTOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType DISCARD_DESIGNATION;
    public static int DISCARD_DESIGNATION_NODE_TYPE_INDEX;
    public static CompositeNodeType DISCARD_PATTERN;
    public static int DISCARD_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType DO_STATEMENT;
    public static int DO_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType DOC_C_REF_ELEMENT;
    public static int DOC_C_REF_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType DOC_C_REF_EXPRESSION;
    public static int DOC_C_REF_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType DOC_C_REF_PARAMETER;
    public static int DOC_C_REF_PARAMETER_NODE_TYPE_INDEX;
    public static CompositeNodeType DOC_C_REF_PARAMETER_TYPE;
    public static int DOC_C_REF_PARAMETER_TYPE_NODE_TYPE_INDEX;
    public static CompositeNodeType DOC_C_REF_PARAMETER_TYPE_NAME;
    public static int DOC_C_REF_PARAMETER_TYPE_NAME_NODE_TYPE_INDEX;
    public static CompositeNodeType DOC_C_REF_SIGNATURE;
    public static int DOC_C_REF_SIGNATURE_NODE_TYPE_INDEX;
    public static CompositeNodeType DOC_C_REF_TYPE_PARAMETER;
    public static int DOC_C_REF_TYPE_PARAMETER_NODE_TYPE_INDEX;
    public static CompositeNodeType DOC_C_REF_TYPE_PARAMETER_LIST;
    public static int DOC_C_REF_TYPE_PARAMETER_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType ELEMENT_ACCESS_EXPRESSION;
    public static int ELEMENT_ACCESS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ELIF_DIRECTIVE;
    public static int ELIF_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType ELSE_DIRECTIVE;
    public static int ELSE_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType EMPTY_STATEMENT;
    public static int EMPTY_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType END_REGION;
    public static int END_REGION_NODE_TYPE_INDEX;
    public static CompositeNodeType ENDIF_DIRECTIVE;
    public static int ENDIF_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType ENUM_BASE;
    public static int ENUM_BASE_NODE_TYPE_INDEX;
    public static CompositeNodeType ENUM_BODY;
    public static int ENUM_BODY_NODE_TYPE_INDEX;
    public static CompositeNodeType ENUM_DECLARATION;
    public static int ENUM_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType ENUM_MEMBER_DECLARATION;
    public static int ENUM_MEMBER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType EQUALITY_EXPRESSION;
    public static int EQUALITY_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ERROR_DIRECTIVE;
    public static int ERROR_DIRECTIVE_NODE_TYPE_INDEX;
    public static NodeType _ERROR_ELEMENT;
    public static int _ERROR_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType EVENT_DECLARATION;
    public static int EVENT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType EXCEPTION_FILTER_CLAUSE;
    public static int EXCEPTION_FILTER_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType EXPRESSION_ELEMENT;
    public static int EXPRESSION_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType EXPRESSION_INITIALIZER;
    public static int EXPRESSION_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType EXPRESSION_STATEMENT;
    public static int EXPRESSION_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType EXTENDED_TYPE;
    public static int EXTENDED_TYPE_NODE_TYPE_INDEX;
    public static CompositeNodeType EXTENDS_LIST;
    public static int EXTENDS_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType EXTERN_ALIAS_DIRECTIVE;
    public static int EXTERN_ALIAS_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType FIELD_DECLARATION;
    public static int FIELD_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType FOR_INITIALIZER;
    public static int FOR_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType FOR_ITERATOR;
    public static int FOR_ITERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType FOR_STATEMENT;
    public static int FOR_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType FOREACH_HEADER;
    public static int FOREACH_HEADER_NODE_TYPE_INDEX;
    public static CompositeNodeType FOREACH_STATEMENT;
    public static int FOREACH_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType FORMAL_PARAMETER_LIST;
    public static int FORMAL_PARAMETER_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType FUNCTION_POINTER_CALLING_CONVENTION;
    public static int FUNCTION_POINTER_CALLING_CONVENTION_NODE_TYPE_INDEX;
    public static CompositeNodeType FUNCTION_POINTER_PARAMETER;
    public static int FUNCTION_POINTER_PARAMETER_NODE_TYPE_INDEX;
    public static CompositeNodeType FUNCTION_POINTER_PARAMETER_MODIFIERS;
    public static int FUNCTION_POINTER_PARAMETER_MODIFIERS_NODE_TYPE_INDEX;
    public static CompositeNodeType FUNCTION_POINTER_TYPE_USAGE;
    public static int FUNCTION_POINTER_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType GENERAL_CATCH_CLAUSE;
    public static int GENERAL_CATCH_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType GOTO_CASE_STATEMENT;
    public static int GOTO_CASE_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType GOTO_STATEMENT;
    public static int GOTO_STATEMENT_NODE_TYPE_INDEX;
    public static NodeType _IDENTIFIER;
    public static int _IDENTIFIER_NODE_TYPE_INDEX;
    public static CompositeNodeType IF_DIRECTIVE;
    public static int IF_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType IF_STATEMENT;
    public static int IF_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType INDEX_FROM_END_EXPRESSION;
    public static int INDEX_FROM_END_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType INDEXER_DECLARATION;
    public static int INDEXER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType INDEXER_INITIALIZER;
    public static int INDEXER_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType INTERFACE_DECLARATION;
    public static int INTERFACE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType INTERPOLATED_STRING_EXPRESSION;
    public static int INTERPOLATED_STRING_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType INTERPOLATED_STRING_INSERT;
    public static int INTERPOLATED_STRING_INSERT_NODE_TYPE_INDEX;
    public static CompositeNodeType INVALID_DIRECTIVE;
    public static int INVALID_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType INVOCATION_EXPRESSION;
    public static int INVOCATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType IS_EXPRESSION;
    public static int IS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType KEYWORD;
    public static int KEYWORD_NODE_TYPE_INDEX;
    public static CompositeNodeType LABEL_DECLARATION;
    public static int LABEL_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LABEL_REFERENCE_ELEMENT;
    public static int LABEL_REFERENCE_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType LABEL_STATEMENT;
    public static int LABEL_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType LAMBDA_EXPRESSION;
    public static int LAMBDA_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType LAMBDA_SIGNATURE;
    public static int LAMBDA_SIGNATURE_NODE_TYPE_INDEX;
    public static CompositeNodeType LINE_DIRECTIVE;
    public static int LINE_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType LINE_INDICATOR;
    public static int LINE_INDICATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType LIST_PATTERN;
    public static int LIST_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_ARGLIST_PARAMETER_DECLARATION;
    public static int LOCAL_ARGLIST_PARAMETER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_CONSTANT_DECLARATION;
    public static int LOCAL_CONSTANT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_FORMAL_PARAMETER_LIST;
    public static int LOCAL_FORMAL_PARAMETER_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_FUNCTION_DECLARATION;
    public static int LOCAL_FUNCTION_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_REGULAR_PARAMETER_DECLARATION;
    public static int LOCAL_REGULAR_PARAMETER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_VARIABLE_DECLARATION;
    public static int LOCAL_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCK_STATEMENT;
    public static int LOCK_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType MAKEREF_EXPRESSION;
    public static int MAKEREF_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType METHOD_DECLARATION;
    public static int METHOD_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MISSING_DESIGNATION;
    public static int MISSING_DESIGNATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MODIFIERS_LIST;
    public static int MODIFIERS_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLE_CONSTANT_DECLARATION;
    public static int MULTIPLE_CONSTANT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLE_EVENT_DECLARATION;
    public static int MULTIPLE_EVENT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLE_FIELD_DECLARATION;
    public static int MULTIPLE_FIELD_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLE_LOCAL_CONSTANT_DECLARATION;
    public static int MULTIPLE_LOCAL_CONSTANT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLE_LOCAL_VARIABLE_DECLARATION;
    public static int MULTIPLE_LOCAL_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLICATIVE_EXPRESSION;
    public static int MULTIPLICATIVE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType NAMESPACE_BODY;
    public static int NAMESPACE_BODY_NODE_TYPE_INDEX;
    public static CompositeNodeType NEGATED_PATTERN;
    public static int NEGATED_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType NULL_COALESCING_EXPRESSION;
    public static int NULL_COALESCING_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType NULLABLE_DIRECTIVE;
    public static int NULLABLE_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType NULLABLE_TYPE_MARK;
    public static int NULLABLE_TYPE_MARK_NODE_TYPE_INDEX;
    public static CompositeNodeType NULLABLE_TYPE_USAGE;
    public static int NULLABLE_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType OBJECT_CREATION_EXPRESSION;
    public static int OBJECT_CREATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType OBJECT_INITIALIZER;
    public static int OBJECT_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType OR_PATTERN;
    public static int OR_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType OWNER_QUALIFICATION;
    public static int OWNER_QUALIFICATION_NODE_TYPE_INDEX;
    public static CompositeNodeType PARAMETER_MODIFIERS_LIST;
    public static int PARAMETER_MODIFIERS_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType PARENTHESIZED_EXPRESSION;
    public static int PARENTHESIZED_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PARENTHESIZED_PATTERN;
    public static int PARENTHESIZED_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType PARENTHESIZED_VARIABLE_DESIGNATION;
    public static int PARENTHESIZED_VARIABLE_DESIGNATION_NODE_TYPE_INDEX;
    public static CompositeNodeType PATTERN_GUARD_CLAUSE;
    public static int PATTERN_GUARD_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType POINTER_TYPE_USAGE;
    public static int POINTER_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType POSTFIX_OPERATOR_EXPRESSION;
    public static int POSTFIX_OPERATOR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PRAGMA_DIRECTIVE;
    public static int PRAGMA_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType PREDEFINED_TYPE_EXPRESSION;
    public static int PREDEFINED_TYPE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PREDEFINED_TYPE_REFERENCE;
    public static int PREDEFINED_TYPE_REFERENCE_NODE_TYPE_INDEX;
    public static CompositeNodeType PREDEFINED_TYPE_USAGE;
    public static int PREDEFINED_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType PREFIX_OPERATOR_EXPRESSION;
    public static int PREFIX_OPERATOR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PREPROCESSOR_AND_EXPRESSION;
    public static int PREPROCESSOR_AND_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PREPROCESSOR_CONDITIONAL_SYMBOL;
    public static int PREPROCESSOR_CONDITIONAL_SYMBOL_NODE_TYPE_INDEX;
    public static CompositeNodeType PREPROCESSOR_EQUALITY_EXPRESSION;
    public static int PREPROCESSOR_EQUALITY_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PREPROCESSOR_NEGATION;
    public static int PREPROCESSOR_NEGATION_NODE_TYPE_INDEX;
    public static CompositeNodeType PREPROCESSOR_OR_EXPRESSION;
    public static int PREPROCESSOR_OR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PREPROCESSOR_PARENTHESIZED_EXPRESSION;
    public static int PREPROCESSOR_PARENTHESIZED_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PREPROCESSOR_PRAGMA_BODY;
    public static int PREPROCESSOR_PRAGMA_BODY_NODE_TYPE_INDEX;
    public static CompositeNodeType PRIMARY_CONSTRUCTOR_DECLARATION;
    public static int PRIMARY_CONSTRUCTOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType PROPERTY_ASSIGNMENT;
    public static int PROPERTY_ASSIGNMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType PROPERTY_DECLARATION;
    public static int PROPERTY_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType PROPERTY_INITIALIZER;
    public static int PROPERTY_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType PROPERTY_PATTERN_CLAUSE;
    public static int PROPERTY_PATTERN_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_CONTINUATION;
    public static int QUERY_CONTINUATION_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_EXPRESSION;
    public static int QUERY_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_FIRST_FROM;
    public static int QUERY_FIRST_FROM_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_FROM_CLAUSE;
    public static int QUERY_FROM_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_GROUP_CLAUSE;
    public static int QUERY_GROUP_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_JOIN_CLAUSE;
    public static int QUERY_JOIN_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_LET_CLAUSE;
    public static int QUERY_LET_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_ORDER_BY_CLAUSE;
    public static int QUERY_ORDER_BY_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_ORDERING;
    public static int QUERY_ORDERING_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_PARAMETER_PLATFORM;
    public static int QUERY_PARAMETER_PLATFORM_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_RANGE_VARIABLE_DECLARATION;
    public static int QUERY_RANGE_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_SELECT_CLAUSE;
    public static int QUERY_SELECT_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_WHERE_CLAUSE;
    public static int QUERY_WHERE_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType RANGE_EXPRESSION;
    public static int RANGE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType RANK_SPECIFIER;
    public static int RANK_SPECIFIER_NODE_TYPE_INDEX;
    public static CompositeNodeType RECORD_DECLARATION;
    public static int RECORD_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType RECURSIVE_PATTERN;
    public static int RECURSIVE_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType REF_EXPRESSION;
    public static int REF_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType REFERENCE_EXPRESSION;
    public static int REFERENCE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType REFERENCE_NAME;
    public static int REFERENCE_NAME_NODE_TYPE_INDEX;
    public static CompositeNodeType REFERENCE_TYPE_CONSTRAINT;
    public static int REFERENCE_TYPE_CONSTRAINT_NODE_TYPE_INDEX;
    public static CompositeNodeType REFTYPE_EXPRESSION;
    public static int REFTYPE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType REFVALUE_EXPRESSION;
    public static int REFVALUE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType RELATIONAL_EXPRESSION;
    public static int RELATIONAL_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType RELATIONAL_PATTERN;
    public static int RELATIONAL_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType RESOURCE_ACQUISITION_EXPRESSIONS_LIST;
    public static int RESOURCE_ACQUISITION_EXPRESSIONS_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType RETURN_STATEMENT;
    public static int RETURN_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType SHIFT_EXPRESSION;
    public static int SHIFT_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType SIGN_OPERATOR_DECLARATION;
    public static int SIGN_OPERATOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType SINGLE_VARIABLE_DESIGNATION;
    public static int SINGLE_VARIABLE_DESIGNATION_NODE_TYPE_INDEX;
    public static CompositeNodeType SLICE_PATTERN;
    public static int SLICE_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType SPECIFIC_CATCH_CLAUSE;
    public static int SPECIFIC_CATCH_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType SPREAD_ELEMENT;
    public static int SPREAD_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType STACK_ALLOC_EXPRESSION;
    public static int STACK_ALLOC_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType START_REGION;
    public static int START_REGION_NODE_TYPE_INDEX;
    public static CompositeNodeType STRUCT_DECLARATION;
    public static int STRUCT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType SUBPATTERN;
    public static int SUBPATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType SUPPRESS_NULLABLE_WARNING_EXPRESSION;
    public static int SUPPRESS_NULLABLE_WARNING_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType SWITCH_BLOCK;
    public static int SWITCH_BLOCK_NODE_TYPE_INDEX;
    public static CompositeNodeType SWITCH_CASE_LABEL;
    public static int SWITCH_CASE_LABEL_NODE_TYPE_INDEX;
    public static CompositeNodeType SWITCH_EXPRESSION;
    public static int SWITCH_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType SWITCH_EXPRESSION_ARM;
    public static int SWITCH_EXPRESSION_ARM_NODE_TYPE_INDEX;
    public static CompositeNodeType SWITCH_SECTION;
    public static int SWITCH_SECTION_NODE_TYPE_INDEX;
    public static CompositeNodeType SWITCH_STATEMENT;
    public static int SWITCH_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType THIS_EXPRESSION;
    public static int THIS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType THROW_EXPRESSION;
    public static int THROW_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType THROW_STATEMENT;
    public static int THROW_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType TOP_LEVEL_CODE;
    public static int TOP_LEVEL_CODE_NODE_TYPE_INDEX;
    public static CompositeNodeType TRY_STATEMENT;
    public static int TRY_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_COMPONENT;
    public static int TUPLE_COMPONENT_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_COMPONENT_LIST;
    public static int TUPLE_COMPONENT_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_EXPRESSION;
    public static int TUPLE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_TYPE_COMPONENT;
    public static int TUPLE_TYPE_COMPONENT_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_TYPE_COMPONENT_LIST;
    public static int TUPLE_TYPE_COMPONENT_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_TYPE_USAGE;
    public static int TUPLE_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_ARGUMENT_LIST;
    public static int TYPE_ARGUMENT_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_CONSTRAINT;
    public static int TYPE_CONSTRAINT_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_MEMBER_ARGLIST_PARAMETER_DECLARATION;
    public static int TYPE_MEMBER_ARGLIST_PARAMETER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_MEMBER_REGULAR_PARAMETER_DECLARATION;
    public static int TYPE_MEMBER_REGULAR_PARAMETER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_CONSTRAINTS_CLAUSE;
    public static int TYPE_PARAMETER_CONSTRAINTS_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_LOCAL_FUNCTION_DECLARATION;
    public static int TYPE_PARAMETER_OF_LOCAL_FUNCTION_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_LOCAL_FUNCTION_LIST;
    public static int TYPE_PARAMETER_OF_LOCAL_FUNCTION_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_METHOD_DECLARATION;
    public static int TYPE_PARAMETER_OF_METHOD_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_METHOD_LIST;
    public static int TYPE_PARAMETER_OF_METHOD_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_TYPE_DECLARATION;
    public static int TYPE_PARAMETER_OF_TYPE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_TYPE_LIST;
    public static int TYPE_PARAMETER_OF_TYPE_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_REFERENCE;
    public static int TYPE_PARAMETER_REFERENCE_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PATTERN;
    public static int TYPE_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPEOF_EXPRESSION;
    public static int TYPEOF_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNARY_OPERATOR_EXPRESSION;
    public static int UNARY_OPERATOR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNCHECKED_EXPRESSION;
    public static int UNCHECKED_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNCHECKED_STATEMENT;
    public static int UNCHECKED_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType UNDEF_DIRECTIVE;
    public static int UNDEF_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_ADDRESS_OF_EXPRESSION;
    public static int UNSAFE_CODE_ADDRESS_OF_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_FIXED_POINTER_DECLARATION;
    public static int UNSAFE_CODE_FIXED_POINTER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_FIXED_POINTER_INITIALIZER;
    public static int UNSAFE_CODE_FIXED_POINTER_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_FIXED_STATEMENT;
    public static int UNSAFE_CODE_FIXED_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_POINTER;
    public static int UNSAFE_CODE_POINTER_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_POINTER_ACCESS_EXPRESSION;
    public static int UNSAFE_CODE_POINTER_ACCESS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_POINTER_INDIRECTION_EXPRESSION;
    public static int UNSAFE_CODE_POINTER_INDIRECTION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_SIZE_OF_EXPRESSION;
    public static int UNSAFE_CODE_SIZE_OF_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNSAFE_CODE_UNSAFE_STATEMENT;
    public static int UNSAFE_CODE_UNSAFE_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType USER_TYPE_USAGE;
    public static int USER_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType USING_ALIAS_DIRECTIVE;
    public static int USING_ALIAS_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType USING_LIST;
    public static int USING_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType USING_STATEMENT;
    public static int USING_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType USING_SYMBOL_DIRECTIVE;
    public static int USING_SYMBOL_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType VALUE_TYPE_CONSTRAINT;
    public static int VALUE_TYPE_CONSTRAINT_NODE_TYPE_INDEX;
    public static CompositeNodeType VAR_DECONSTRUCTION_PATTERN;
    public static int VAR_DECONSTRUCTION_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType VAR_PATTERN;
    public static int VAR_PATTERN_NODE_TYPE_INDEX;
    public static CompositeNodeType WARNING_ACTION;
    public static int WARNING_ACTION_NODE_TYPE_INDEX;
    public static CompositeNodeType WARNING_DIRECTIVE;
    public static int WARNING_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType WARNING_LIST;
    public static int WARNING_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType WHILE_STATEMENT;
    public static int WHILE_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType WITH_EXPRESSION;
    public static int WITH_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType WITH_INITIALIZER_ASSIGNMENT;
    public static int WITH_INITIALIZER_ASSIGNMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType YIELD_STATEMENT;
    public static int YIELD_STATEMENT_NODE_TYPE_INDEX;
    private static ElementType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ElifDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short CSHARP_OP1;
    public NodeType NodeType { get; }
    public IPreprocessorExpression Condition { get; }
    public ITokenNode Directive { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPreprocessorExpression get_Condition();
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_NumberSign();
    public virtual IPreprocessorExpression SetCondition(IPreprocessorExpression param);
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ElseDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EmptyStatement : StatementBase {
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ITokenNode Semicolon { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Semicolon();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EndifDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EndRegion : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short MESSAGE;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode Message { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public string Name { get; }
    public IStartRegion StartRegion { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_Message();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public sealed virtual string get_Name();
    public sealed virtual IStartRegion get_StartRegion();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EnumBase : CSharpCompositeElement {
    public static short CSHARP_COLON;
    public static short CSHARP_TYPE;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public ITypeUsage UnderlyingType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Colon();
    public virtual ITypeUsage get_UnderlyingType();
    public virtual ITypeUsage SetUnderlyingType(ITypeUsage param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EnumBody : CSharpCompositeElement {
    public static short CSHARP_LBRACE;
    public static short MEMBER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IEnumMemberDeclaration> Members { get; }
    public TreeNodeEnumerable`1<IEnumMemberDeclaration> MembersEnumerable { get; }
    public ITokenNode RBrace { get; }
    public IEnumDeclaration Owner { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IEnumMemberDeclaration> get_Members();
    public virtual TreeNodeEnumerable`1<IEnumMemberDeclaration> get_MembersEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual IEnumDeclaration get_Owner();
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EnumDeclaration : EnumDeclarationStub {
    private Dictionary`2<IEnumMemberDeclaration, Hash> myCachedMemberHashes;
    public Dictionary`2<IEnumMemberDeclaration, Hash> CachedMemberHashes { get; }
    protected virtual void ClearCachedData();
    protected virtual void PreInit();
    public Dictionary`2<IEnumMemberDeclaration, Hash> get_CachedMemberHashes();
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EnumDeclarationStub : MemberOwnerDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short KEYWORD;
    public static short CSHARP_NAME;
    public static short TYPE_PARAMETERS_LIST;
    public static short CSHARP_BASE;
    public static short CONSTRAINTS;
    public static short CSHARP_BLOCK;
    public static short CSHARP_SEMICOLON;
    private TreeNodeCollection`1<IEnumMemberDeclaration> myCachedEnumMemberDeclarations;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedEnumMemberDeclarationsValid;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IEnumBody EnumBody { get; }
    public IEnumBase ExtendedIntegralTypeInternal { get; }
    public ITokenNode Keyword { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IEnumBody BodyInternal { get; }
    public TreeNodeCollection`1<IEnumMemberDeclaration> EnumMemberDeclarations { get; }
    protected TreeNodeCollection`1<IEnumMemberDeclaration> _EnumMemberDeclarations { get; }
    public TreeNodeEnumerable`1<IEnumMemberDeclaration> EnumMemberDeclarationsEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public ICSharpNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParametersEnumerable { get; }
    public ITypeUsage UnderlyingTypeUsage { get; }
    public ITokenNode TypeDeclarationKeyword { get; }
    public TreeNodeCollection`1<ICSharpTypeMemberDeclaration> MemberDeclarations { get; }
    public IReadOnlyList`1<ITypeDeclaration> TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private IEnum JetBrains.ReSharper.Psi.CSharp.Tree.IEnumDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public IMemberOwnerBody Body { get; }
    public IReadOnlyList`1<ITypeDeclaration> NestedTypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public IEnumerable`1<IDeclaredType> SuperTypes { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IEnumBody get_EnumBody();
    public virtual IEnumBase get_ExtendedIntegralTypeInternal();
    public virtual ITokenNode get_Keyword();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_Semicolon();
    public virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public virtual ITypeParameterOfTypeList get_TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IEnumBody get_BodyInternal();
    public sealed virtual TreeNodeCollection`1<IEnumMemberDeclaration> get_EnumMemberDeclarations();
    protected virtual TreeNodeCollection`1<IEnumMemberDeclaration> get__EnumMemberDeclarations();
    public virtual TreeNodeEnumerable`1<IEnumMemberDeclaration> get_EnumMemberDeclarationsEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual ICSharpNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParametersEnumerable();
    public virtual ITypeUsage get_UnderlyingTypeUsage();
    public virtual IEnumBody SetEnumBody(IEnumBody param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual ITypeUsage SetUnderlyingTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public sealed virtual ITokenNode get_TypeDeclarationKeyword();
    public virtual TreeNodeCollection`1<ICSharpTypeMemberDeclaration> get_MemberDeclarations();
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration typeParameterDeclaration);
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    public sealed virtual bool CanBindTo(ITypeElement typeElement);
    public virtual void SetStatic(bool value);
    public virtual string get_DeclaredName();
    private sealed virtual override IEnum JetBrains.ReSharper.Psi.CSharp.Tree.IEnumDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public sealed virtual IMemberOwnerBody get_Body();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_NestedTypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual IEnumerable`1<IDeclaredType> get_SuperTypes();
    public sealed virtual IType GetUnderlyingType();
    public sealed virtual void SetUnderlyingType(IDeclaredType declaredType);
    public sealed virtual void RemoveEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclaration);
    public sealed virtual IEnumMemberDeclaration AddEnumMemberDeclarationBefore(IEnumMemberDeclaration enumMemberDeclaration, IEnumMemberDeclaration anchor);
    public sealed virtual IEnumMemberDeclaration AddEnumMemberDeclarationAfter(IEnumMemberDeclaration enumMemberDeclaration, IEnumMemberDeclaration anchor);
    public sealed virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    protected virtual Hash CalculateHashInternal();
    public sealed virtual IDeclarationsRange GetAllDeclarationsRange();
    public sealed virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange textRange);
    public sealed virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
    private void EnsureCommaAfter(ITreeNode lastDecl);
    public sealed virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    [NotNullAttribute]
private static ITreeRange FixupDeclarationsRange(IDeclarationsRange range);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EnumMemberDeclaration : ProperTypeMemberDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short VALUE;
    [ThreadStaticAttribute]
private static int ourCurrentRecursionDepth;
    private static int MaximumRecursionDepth;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public ITokenNode EquivalenceSign { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ICSharpExpression ValueExpression { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IEnumDeclaration DeclaringEnum { get; }
    public string DeclaredName { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public IEnumMemberDeclaration PreviousDeclaration { get; }
    public IEnumMemberDeclaration NextDeclaration { get; }
    public IField EnumMember { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    public IModifiersList ModifiersList { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual ITokenNode get_EquivalenceSign();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpExpression get_ValueExpression();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IEnumDeclaration get_DeclaringEnum();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public virtual string ToString();
    [NotNullAttribute]
public ConstantValue CalculateConstantValue();
    public virtual string get_DeclaredName();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual IEnumMemberDeclaration get_PreviousDeclaration();
    public sealed virtual IEnumMemberDeclaration get_NextDeclaration();
    public sealed virtual IField get_EnumMember();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
    public virtual AccessRights GetAccessRights();
    public virtual AccessRights GetSemanticAccessRights();
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IEnumMemberDeclaration.SetValueExpression(ICSharpExpression param);
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    protected virtual IDeclaredElement CreateDeclaredElement();
    public sealed virtual IModifiersList get_ModifiersList();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EqualityExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public EqualityExpressionType EqualityType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public sealed virtual EqualityExpressionType get_EqualityType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ErrorDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short MESSAGE;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode Message { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_Message();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EventDeclaration : EventDeclarationStub {
    protected virtual IDeclaredElement CreateDeclaredElement();
    public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    public virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public virtual void RemoveAttribute(IAttribute attribute);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.EventDeclarationStub : ProperTypeMemberDeclarationBase {
    public static short CSHARP_QUALIFIER;
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_LBRACE;
    public static short ACCESSOR_DECL;
    public static short CSHARP_RBRACE;
    private IOwnerQualification myCachedInterfaceQualification;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedInterfaceQualificationValid;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IAccessorDeclaration> AccessorDeclarations { get; }
    public TreeNodeEnumerable`1<IAccessorDeclaration> AccessorDeclarationsEnumerable { get; }
    public ITokenNode EquivalenceSign { get; }
    public IVariableInitializer Initial { get; }
    public IOwnerQualification InterfaceQualification { get; }
    protected IOwnerQualification _InterfaceQualification { get; }
    public ITokenNode LBrace { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public ITypeUsage DelegateTypeUsage { get; }
    public IReferenceName InterfaceQualificationReference { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IMultipleDeclaration MultipleDeclaration { get; }
    public IType Type { get; }
    private IModifiersListOwner ModifiersListOwner { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsSealed { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string DeclaredName { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    public bool IsFieldLikeEvent { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IEvent JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration.DeclaredElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IAccessorDeclaration> get_AccessorDeclarations();
    public virtual TreeNodeEnumerable`1<IAccessorDeclaration> get_AccessorDeclarationsEnumerable();
    public virtual ITokenNode get_EquivalenceSign();
    public virtual IVariableInitializer get_Initial();
    public sealed virtual IOwnerQualification get_InterfaceQualification();
    protected virtual IOwnerQualification get__InterfaceQualification();
    public virtual ITokenNode get_LBrace();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual ITypeUsage get_DelegateTypeUsage();
    public virtual IReferenceName get_InterfaceQualificationReference();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual IMultipleDeclaration get_MultipleDeclaration();
    public virtual ITypeUsage SetDelegateTypeUsage(ITypeUsage param);
    public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual IOwnerQualification SetInterfaceQualification(IOwnerQualification param);
    public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public sealed virtual IType get_Type();
    public sealed virtual void SetType(IType type);
    private IModifiersListOwner get_ModifiersListOwner();
    protected virtual bool HasExecutableCodeBody();
    public virtual bool IsSemanticallyAbstract();
    public virtual bool IsSemanticallyVirtual();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsSealed();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
    public virtual AccessRights GetAccessRights();
    public virtual AccessRights GetSemanticAccessRights();
    public virtual void SetAccessRights(AccessRights rights);
    public virtual void SetAbstract(bool value);
    public virtual void SetVirtual(bool value);
    public virtual void SetOverride(bool value);
    public virtual void SetStatic(bool value);
    protected virtual Hash CalculateHashInternal();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    public sealed virtual bool get_IsFieldLikeEvent();
    private void EnsureBracesBeforeAddAccessor();
    private void EnshureBracesAfterRemoveAccessor();
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationBefore(IAccessorDeclaration accessorDeclaration, IAccessorDeclaration anchor);
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationAfter(IAccessorDeclaration accessorDeclaration, IAccessorDeclaration anchor);
    public sealed virtual void RemoveAccessorDeclaration(IAccessorDeclaration accessorDeclaration);
    public virtual void SetReadonly(bool value);
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IEvent JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration.get_DeclaredElement();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExceptionFilterClause : CSharpCompositeElement {
    public static short WHEN_KEYWORD;
    public static short CSHARP_LPAR;
    public static short CSHARP_CONDITION;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ICSharpExpression Condition { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode WhenKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Condition();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_WhenKeyword();
    public virtual ICSharpExpression SetCondition(ICSharpExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExpressionElement : CSharpCompositeElement {
    public static short EXPR;
    [NullableAttribute("1")]
private MyCollectionExpressionAddReference myAddReference;
    [NullableAttribute("1")]
private MyParamsDefaultConstructorReference myParamsDefaultConstructorReference;
    [NullableAttribute("1")]
private MyParamsCreateMethodReference myParamsCreateMethodReference;
    [NullableAttribute("1")]
private MyParamsAddReference myParamsAddReference;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    [NullableAttribute("1")]
public ICSharpInvocationReference AddReference { get; }
    [NullableAttribute("1")]
public IReference ParamsDefaultConstructorReference { get; }
    [NullableAttribute("1")]
public IReference ParamsCreateMethodReference { get; }
    [NullableAttribute("1")]
public IReference ParamsAddReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual ICSharpInvocationReference get_AddReference();
    [NullableContextAttribute("1")]
public sealed virtual IReference get_ParamsDefaultConstructorReference();
    [NullableContextAttribute("1")]
public sealed virtual IReference get_ParamsCreateMethodReference();
    [NullableContextAttribute("1")]
public sealed virtual IReference get_ParamsAddReference();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    [NullableContextAttribute("1")]
public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
private static bool IsIgnoredParamsCollectionCreation(IExpressionElement expressionElement, IType paramsCollectionType, IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExpressionInitializer : CSharpCompositeElement {
    public static short EXRP;
    public NodeType NodeType { get; }
    public ICSharpExpression Value { get; }
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Value();
    public virtual ICSharpExpression SetValue(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual bool get_IntroducesScope();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExpressionQualifier : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    [NotNullAttribute]
public ICSharpExpression Expression { get; }
    [NotNullAttribute]
public IResolveContext ResolveContext { get; }
    public bool Resolved { get; }
    public ExpressionQualifier(ICSharpExpression expression, IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_Expression();
    [CompilerGeneratedAttribute]
public IResolveContext get_ResolveContext();
    [CanBeNullAttribute]
[PureAttribute]
public IType GetQualifierType();
    public virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public virtual QualifierKind GetKind();
    public virtual bool get_Resolved();
    public virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IExpressionType GetQualifierExpressionType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExpressionStatement : StatementBase {
    public static short EXPR;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode Semicolon { get; }
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_Semicolon();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual bool get_IntroducesScope();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExtendedType : ExtendedTypeStub {
    [CanBeNullAttribute]
public virtual IArgumentList SetArgumentList(IArgumentList param);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExtendedTypeStub : CSharpCompositeElement {
    public static short CSHARP_TYPE;
    public static short CSHARP_LPAR;
    public static short ARGUMENT_LIST;
    public static short CSHARP_RPAR;
    private MyConstructorReference myReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public ICSharpInvocationReference ConstructorReference { get; }
    public IReference TypeReference { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpInvocationReference Reference { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    private bool HasConstructorInvocation();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ICSharpInvocationReference get_ConstructorReference();
    public sealed virtual IReference get_TypeReference();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpInvocationReference get_Reference();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual string Dump();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ITokenNode> get_Delimiters();
    public sealed virtual ITokenNode get_LBound();
    public sealed virtual ITokenNode get_RBound();
    public sealed virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual void RemoveArgument(ICSharpArgument argument);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExtendsList : CSharpCompositeElement {
    public static short CSHARP_COLON;
    public static short EXTENDS_TYPE;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IExtendedType> ExtendedTypes { get; }
    public TreeNodeEnumerable`1<IExtendedType> ExtendedTypesEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> ExtendedInterfaces { get; }
    public TreeNodeEnumerable`1<ITypeUsage> ExtendedInterfacesEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Colon();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IExtendedType> get_ExtendedTypes();
    public virtual TreeNodeEnumerable`1<IExtendedType> get_ExtendedTypesEnumerable();
    public virtual TreeNodeCollection`1<ITypeUsage> get_ExtendedInterfaces();
    public virtual TreeNodeEnumerable`1<ITypeUsage> get_ExtendedInterfacesEnumerable();
    public virtual string ToString();
    public sealed virtual IExtendedType AddExtendedTypeBefore(IExtendedType extendedType, IExtendedType anchor);
    public sealed virtual IExtendedType AddExtendedTypeAfter(IExtendedType extendedType, IExtendedType anchor);
    public sealed virtual void RemoveExtendedType(IExtendedType extendedType);
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ExternAliasDirective : CSharpCompositeElement {
    public static short KEYWORD;
    public static short ALIAS_KEYWORD;
    public static short CSHARP_NAME;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ITokenNode AliasKeyword { get; }
    public ITokenNode Keyword { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode Semicolon { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AliasKeyword();
    public virtual ITokenNode get_Keyword();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_Semicolon();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.FieldDeclaration : FieldDeclarationStub {
    protected virtual IDeclaredElement CreateDeclaredElement();
    public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    public virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public virtual void RemoveAttribute(IAttribute attribute);
    public virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.FieldDeclarationStub : ProperTypeMemberDeclarationBase {
    public static short CSHARP_NAME;
    public static short CSHARP_LBRACKET;
    public static short CSHARP_CONSTANT_EXPRESSION;
    public static short CSHARP_RBRACKET;
    public static short CSHARP_EQ;
    public static short CSHARP_INITIALIZER;
    public NodeType NodeType { get; }
    public ITokenNode EquivalenceSign { get; }
    public ICSharpExpression FixedBufferSizeExpression { get; }
    public IVariableInitializer Initial { get; }
    public ITokenNode LBracket { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode RBracket { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IMultipleDeclaration MultipleDeclaration { get; }
    public ITypeUsage TypeUsage { get; }
    public IType Type { get; }
    private IModifiersListOwner ModifiersListOwner { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public string DeclaredName { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IField JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration.DeclaredElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EquivalenceSign();
    public virtual ICSharpExpression get_FixedBufferSizeExpression();
    public virtual IVariableInitializer get_Initial();
    public virtual ITokenNode get_LBracket();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_RBracket();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual IMultipleDeclaration get_MultipleDeclaration();
    public virtual ITypeUsage get_TypeUsage();
    public virtual ICSharpExpression SetFixedBufferSizeExpression(ICSharpExpression param);
    public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IType get_Type();
    public sealed virtual void SetType(IType type);
    private IModifiersListOwner get_ModifiersListOwner();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
    public sealed virtual bool get_IsRequired();
    public sealed virtual void SetRequired(bool value);
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual void SetReferenceKind(ReferenceKind referenceKind);
    public virtual AccessRights GetAccessRights();
    public virtual AccessRights GetSemanticAccessRights();
    public virtual void SetAccessRights(AccessRights rights);
    public virtual void SetStatic(bool value);
    public virtual void SetUnsafe(bool value);
    public virtual void SetReadonly(bool value);
    public virtual void SetVolatile(bool value);
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IField JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration.get_DeclaredElement();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForeachHeader : CSharpCompositeElement {
    public static short DECL;
    public static short DECONSTRUCT_TUPLE;
    public static short KEYWORD;
    public static short EXPR;
    public NodeType NodeType { get; }
    public ICSharpExpression Collection { get; }
    public IDeclarationExpression DeclarationExpression { get; }
    public ITupleExpression DeconstructionTuple { get; }
    public ITokenNode InKeyword { get; }
    public IEnumerable`1<ISingleVariableDesignation> IteratorDeclarations { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Collection();
    public virtual IDeclarationExpression get_DeclarationExpression();
    public virtual ITupleExpression get_DeconstructionTuple();
    public virtual ITokenNode get_InKeyword();
    public virtual ICSharpExpression SetCollection(ICSharpExpression param);
    public virtual IDeclarationExpression SetDeclarationExpression(IDeclarationExpression param);
    public virtual ITupleExpression SetDeconstructionTuple(ITupleExpression param);
    public virtual string ToString();
    public sealed virtual IEnumerable`1<ISingleVariableDesignation> get_IteratorDeclarations();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForeachReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<TForeachReferencesOwner> {
    protected ForeachReferenceBase`1(TForeachReferencesOwner owner);
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForeachStatement : ForeachStatementStub {
    public virtual void SetAwait(bool isAwait);
    public virtual ICSharpStatement SetBody(ICSharpStatement param);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0(bool isAwait);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForeachStatementStub : StatementBase {
    public static short AWAIT;
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short HEADER;
    public static short CSHARP_RPAR;
    public static short CSHARP_BODY;
    private MyGetEnumeratorReference myGetEnumeratorReference;
    private MyMoveNextReference myMoveNextReference;
    private MyCurrentReference myCurrentReference;
    private MyGetAwaiterReference myGetAwaiterReference;
    private MyAwaiterGetResultReference myAwaiterGetResultReference;
    private MyAwaiterOnCompletedReference myAwaiterOnCompletedReference;
    private MyAwaiterIsCompletedReference myAwaiterIsCompletedReference;
    public NodeType NodeType { get; }
    public ITokenNode AwaitKeyword { get; }
    public ICSharpStatement Body { get; }
    public IForeachHeader ForeachHeader { get; }
    public ITokenNode ForeachKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ICSharpExpression Collection { get; }
    public IEnumerable`1<ISingleVariableDesignation> IteratorDeclarations { get; }
    public ITreeNode IteratorDeclarationsContainer { get; }
    public TreeTextRange IterationReferencesRange { get; }
    public bool IsAwait { get; }
    private ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.Collection { get; }
    public IEnumerable`1<ICSharpLocalVariable> IteratorVariables { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public string IteratorName { get; }
    public TreeTextRange AwaitRange { get; }
    private bool IsWellFormedAwaitConstruct { get; }
    public IForeachPatternReference GetEnumeratorReference { get; }
    public IForeachPatternReference MoveNextReference { get; }
    public IForeachPatternReference CurrentReference { get; }
    public IManagedReference GetAwaiterReference { get; }
    public IManagedReference AwaiterGetResultReference { get; }
    public IManagedReference AwaiterOnCompletedReference { get; }
    public IManagedReference AwaiterIsCompletedReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AwaitKeyword();
    public virtual ICSharpStatement get_Body();
    public virtual IForeachHeader get_ForeachHeader();
    public virtual ITokenNode get_ForeachKeyword();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ICSharpExpression get_Collection();
    public virtual ICSharpStatement SetBody(ICSharpStatement param);
    public virtual ICSharpExpression SetCollection(ICSharpExpression param);
    public virtual IForeachHeader SetForeachHeader(IForeachHeader param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IEnumerable`1<ISingleVariableDesignation> get_IteratorDeclarations();
    public sealed virtual ITreeNode get_IteratorDeclarationsContainer();
    public sealed virtual TreeTextRange get_IterationReferencesRange();
    public sealed virtual bool get_IsAwait();
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.get_Collection();
    public virtual void SetAwait(bool isAwait);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForeachStatementStub/<get_IteratorVariables>d__51")]
public sealed virtual IEnumerable`1<ICSharpLocalVariable> get_IteratorVariables();
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual string get_IteratorName();
    public sealed virtual TreeTextRange get_AwaitRange();
    private bool get_IsWellFormedAwaitConstruct();
    public sealed virtual IForeachPatternReference get_GetEnumeratorReference();
    public sealed virtual IForeachPatternReference get_MoveNextReference();
    public sealed virtual IForeachPatternReference get_CurrentReference();
    public sealed virtual IManagedReference get_GetAwaiterReference();
    public sealed virtual IManagedReference get_AwaiterGetResultReference();
    public sealed virtual IManagedReference get_AwaiterOnCompletedReference();
    public sealed virtual IManagedReference get_AwaiterIsCompletedReference();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetAccessContainingTypeElement();
    private sealed virtual override Staticness JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetStaticness();
    private sealed virtual override QualifierKind JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetQualifierKind();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetQualifierTypeElement();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForInitializer : CSharpCompositeElement {
    public static short EXPR;
    public static short CSHARP_COMMA;
    public static short DECL;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IMultipleLocalVariableDeclaration Declaration { get; }
    public TreeNodeCollection`1<ICSharpExpression> Expressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ExpressionsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual IMultipleLocalVariableDeclaration get_Declaration();
    public virtual TreeNodeCollection`1<ICSharpExpression> get_Expressions();
    public virtual TreeNodeEnumerable`1<ICSharpExpression> get_ExpressionsEnumerable();
    public virtual IMultipleLocalVariableDeclaration SetDeclaration(IMultipleLocalVariableDeclaration param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForIterator : CSharpCompositeElement {
    public static short EXPR;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> Expressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ExpressionsEnumerable { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ICSharpExpression> get_Expressions();
    public virtual TreeNodeEnumerable`1<ICSharpExpression> get_ExpressionsEnumerable();
    public virtual string ToString();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.FormalParameterList : CSharpCompositeElement {
    public static short CSHARP_PARAMETER;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForStatement : ForStatementStub {
    [CanBeNullAttribute]
public virtual ICSharpStatement SetBody(ICSharpStatement bodyStatement);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ForStatementStub : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short INITIALIZER;
    public static short CSHARP_SEMICOLON;
    public static short CSHARP_CONDITION;
    public static short CSHARP_SEMICOLON2;
    public static short ITERATOR;
    public static short CSHARP_RPAR;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public ICSharpStatement Body { get; }
    public ICSharpExpression Condition { get; }
    public ITokenNode ForKeyword { get; }
    public IForInitializer Initializer { get; }
    public IForIterator Iterators { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon1 { get; }
    public ITokenNode Semicolon2 { get; }
    public TreeNodeCollection`1<ILocalVariableDeclaration> InitializerDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalVariableDeclaration> InitializerDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> InitializerExpressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> InitializerExpressionsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> IteratorExpressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> IteratorExpressionsEnumerable { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpStatement get_Body();
    public virtual ICSharpExpression get_Condition();
    public virtual ITokenNode get_ForKeyword();
    public virtual IForInitializer get_Initializer();
    public virtual IForIterator get_Iterators();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Semicolon1();
    public virtual ITokenNode get_Semicolon2();
    public virtual TreeNodeCollection`1<ILocalVariableDeclaration> get_InitializerDeclarations();
    public virtual TreeNodeEnumerable`1<ILocalVariableDeclaration> get_InitializerDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ICSharpExpression> get_InitializerExpressions();
    public virtual TreeNodeEnumerable`1<ICSharpExpression> get_InitializerExpressionsEnumerable();
    public virtual TreeNodeCollection`1<ICSharpExpression> get_IteratorExpressions();
    public virtual TreeNodeEnumerable`1<ICSharpExpression> get_IteratorExpressionsEnumerable();
    public virtual ICSharpStatement SetBody(ICSharpStatement param);
    public virtual ICSharpExpression SetCondition(ICSharpExpression param);
    public virtual IForInitializer SetInitializer(IForInitializer param);
    public virtual IForIterator SetIterators(IForIterator param);
    public virtual string ToString();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual void RemoveInitializerDeclaration(ILocalVariableDeclaration variableDeclaration);
    public sealed virtual void RemoveInitializerExpression(ICSharpExpression initializerExpression);
    public sealed virtual void RemoveIteratorExpression(ICSharpExpression iteratorExpression);
    public ILocalVariableDeclaration AddInitializerDeclarationAfter(ILocalVariableDeclaration param, ILocalVariableDeclaration anchor);
    public ILocalVariableDeclaration AddInitializerDeclarationBefore(ILocalVariableDeclaration param, ILocalVariableDeclaration anchor);
    public sealed virtual TExpression AddInitializerExpressionBefore(TExpression initializerExpression, ICSharpExpression anchor);
    public sealed virtual TExpression AddInitializerExpressionAfter(TExpression initializerExpression, ICSharpExpression anchor);
    public sealed virtual TExpression AddIteratorExpressionBefore(TExpression iteratorExpression, ICSharpExpression anchor);
    public sealed virtual TExpression AddIteratorExpressionAfter(TExpression iteratorExpression, ICSharpExpression anchor);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.FromReference : QueryChainReferenceBase`1<QueryFromClause> {
    private static string SELECT_MANY;
    public FromReference(QueryFromClause owner);
    public virtual ICSharpArgumentInfo[] GetArguments();
    public virtual string GetName();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.FunctionPointerCallingConvention : CSharpCompositeElement {
    public static short MANAGED;
    public static short CSHARP_LBRACKET;
    public static short CSHARP_NAME;
    public static short CSHARP_RBRACKET;
    public NodeType NodeType { get; }
    public ITokenNode LBracket { get; }
    public ICSharpIdentifier ManagedKeyword { get; }
    public ITokenNode RBracket { get; }
    public TreeNodeCollection`1<ICSharpIdentifier> UnmanagedCallingConventions { get; }
    public TreeNodeEnumerable`1<ICSharpIdentifier> UnmanagedCallingConventionsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LBracket();
    public virtual ICSharpIdentifier get_ManagedKeyword();
    public virtual ITokenNode get_RBracket();
    public virtual TreeNodeCollection`1<ICSharpIdentifier> get_UnmanagedCallingConventions();
    public virtual TreeNodeEnumerable`1<ICSharpIdentifier> get_UnmanagedCallingConventionsEnumerable();
    public virtual ICSharpIdentifier SetManagedKeyword(ICSharpIdentifier param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.FunctionPointerParameter : CSharpCompositeElement {
    public static short MODIFIERS;
    public static short CSHARP_TYPE;
    public NodeType NodeType { get; }
    public IFunctionPointerParameterModifiers ModifierList { get; }
    public ITypeUsage TypeUsage { get; }
    public IType Type { get; }
    public ParameterKind ParameterKind { get; }
    public bool IsReturnTypeParameter { get; }
    public ReferenceKind ReturnKind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IFunctionPointerParameterModifiers get_ModifierList();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IFunctionPointerParameterModifiers SetModifierList(IFunctionPointerParameterModifiers param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IType get_Type();
    public sealed virtual ParameterKind get_ParameterKind();
    public sealed virtual bool get_IsReturnTypeParameter();
    public sealed virtual ReferenceKind get_ReturnKind();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.FunctionPointerParameterModifiers : CSharpCompositeElement {
    public static short KEYWORD;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Modifier { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifierEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Modifier();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifierEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.FunctionPointerTypeUsage : CSharpCompositeElement {
    public static short KEYWORD;
    public static short POINTER;
    public static short CALLINGCONV;
    public static short CSHARP_LANGLE;
    public static short PARAMETER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RANGLE;
    public NodeType NodeType { get; }
    public IFunctionPointerCallingConvention CallingConvention { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode DelegateKeyword { get; }
    public ITokenNode LBound { get; }
    public TreeNodeCollection`1<IFunctionPointerParameter> Parameters { get; }
    public TreeNodeEnumerable`1<IFunctionPointerParameter> ParametersEnumerable { get; }
    public ITokenNode PointerMark { get; }
    public ITokenNode RBound { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IFunctionPointerCallingConvention get_CallingConvention();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_DelegateKeyword();
    public virtual ITokenNode get_LBound();
    public virtual TreeNodeCollection`1<IFunctionPointerParameter> get_Parameters();
    public virtual TreeNodeEnumerable`1<IFunctionPointerParameter> get_ParametersEnumerable();
    public virtual ITokenNode get_PointerMark();
    public virtual ITokenNode get_RBound();
    public virtual IFunctionPointerCallingConvention SetCallingConvention(IFunctionPointerCallingConvention param);
    public sealed virtual ITypeUsage ReplaceBy(ITypeUsage typeUsage);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.GeneralCatchClause : CSharpCompositeElement {
    public static short KEYWORD;
    public static short CSHARP_CONDITION;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public IBlock Body { get; }
    public ITokenNode CatchKeyword { get; }
    public IExceptionFilterClause Filter { get; }
    public ICSharpExpression FilterCondition { get; }
    public IDeclaredType ExceptionType { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Body();
    public virtual ITokenNode get_CatchKeyword();
    public virtual IExceptionFilterClause get_Filter();
    public virtual ICSharpExpression get_FilterCondition();
    public virtual IBlock SetBody(IBlock param);
    public virtual IExceptionFilterClause SetFilter(IExceptionFilterClause param);
    public virtual ICSharpExpression SetFilterCondition(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual TCatchClause ReplaceBy(TCatchClause clause);
    public sealed virtual IDeclaredType get_ExceptionType();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.GetAwaiterReferenceBase`1 : InvocableAwaitReferenceBase`1<TAwaitReferencesOwner> {
    protected GetAwaiterReferenceBase`1(TAwaitReferencesOwner owner);
    public virtual string GetName();
}
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.GetAwaiterReferenceUtil : object {
    [CanBeNullAttribute]
public static IType GetAwaiterReturnType(IManagedReference awaiterReference, IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.GetEnumeratorReferenceBase`1 : ForeachReferenceBase`1<TForeachReferencesOwner> {
    public ICSharpInvocationInfo Invocation { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public ICSharpInvocationReference Reference { get; }
    protected GetEnumeratorReferenceBase`1(TForeachReferencesOwner owner);
    public virtual string GetName();
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    [NotNullAttribute]
private static IType GetCollectionTypeForResolve(IResolveContext resolveContext, ICSharpExpression collection, bool isAwaitForeach);
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.GotoCaseStatement : StatementBase {
    public static short KEYWORD;
    public static short KEYWORD2;
    public static short CSHARP_CONSTANT_EXPRESSION;
    public static short KEYWORD3;
    public static short CSHARP_SEMICOLON;
    [NotNullAttribute]
private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    public NodeType NodeType { get; }
    public ITokenNode CaseKeyword { get; }
    public ITokenNode DefaultKeyword { get; }
    public ITokenNode GotoKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ICSharpExpression ValueExpression { get; }
    public bool IsGotoDefault { get; }
    public ConstantValue CachedConstantValue { get; public set; }
    public ConstantValue ConstantValue { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_CaseKeyword();
    public virtual ITokenNode get_DefaultKeyword();
    public virtual ITokenNode get_GotoKeyword();
    public virtual ITokenNode get_Semicolon();
    public virtual ICSharpExpression get_ValueExpression();
    public virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IGotoCaseStatement.SetValueExpression(ICSharpExpression param);
    public sealed virtual bool get_IsGotoDefault();
    public sealed virtual ConstantValue get_CachedConstantValue();
    public sealed virtual void set_CachedConstantValue(ConstantValue value);
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public sealed virtual ISwitchCaseLabel ResolveLabel(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.GotoStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_LABEL_REFERENCE;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ITokenNode GotoKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ILabelReferenceElement Target { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_GotoKeyword();
    public virtual ITokenNode get_Semicolon();
    public virtual ILabelReferenceElement get_Target();
    public virtual ILabelReferenceElement SetTarget(ILabelReferenceElement param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.GroupReference : QueryChainReferenceBase`1<QueryGroupClause> {
    private static string GROUPBY;
    public GroupReference(QueryGroupClause owner);
    public virtual ICSharpArgumentInfo[] GetArguments();
    public virtual string GetName();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ICSharpHashableDeclaration {
    [NotNullAttribute]
public IEnumerable`1<ICSharpHashableDeclaration> Children { get; }
    public bool IsInternal { get; }
    [ItemNotNullAttribute]
public abstract virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedNames);
    public abstract virtual IEnumerable`1<ICSharpHashableDeclaration> get_Children();
    public abstract virtual bool get_IsInternal();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.Identifier : CSharpTokenBase {
    [NotNullAttribute]
private string myText;
    public string Name { get; }
    public NodeType NodeType { get; }
    public Identifier(string text);
    public sealed virtual string get_Name();
    public virtual NodeType get_NodeType();
    public virtual int GetTextLength();
    public virtual string GetText();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IfDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short CSHARP_OP1;
    public NodeType NodeType { get; }
    public IPreprocessorExpression Condition { get; }
    public ITokenNode Directive { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPreprocessorExpression get_Condition();
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_NumberSign();
    public virtual IPreprocessorExpression SetCondition(IPreprocessorExpression param);
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IfStatement : IfStatementStub {
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual short GetChildRole(TreeElement child);
    [CanBeNullAttribute]
public virtual ICSharpStatement SetThen(ICSharpStatement thenStatement);
    public virtual ICSharpStatement SetElse(ICSharpStatement elseStatement);
    public sealed virtual bool get_IntroducesScope();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IfStatementStub : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short CSHARP_CONDITION;
    public static short CSHARP_RPAR;
    public static short CSHARP_THEN;
    public static short ELSE;
    public static short CSHARP_ELSE;
    public NodeType NodeType { get; }
    public ICSharpExpression Condition { get; }
    public ICSharpStatement Else { get; }
    public ITokenNode ElseKeyword { get; }
    public ITokenNode IfKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ICSharpStatement Then { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Condition();
    public virtual ICSharpStatement get_Else();
    public virtual ITokenNode get_ElseKeyword();
    public virtual ITokenNode get_IfKeyword();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ICSharpStatement get_Then();
    public virtual ICSharpExpression SetCondition(ICSharpExpression param);
    public virtual ICSharpStatement SetElse(ICSharpStatement param);
    public virtual ICSharpStatement SetThen(ICSharpStatement param);
    public virtual string ToString();
}
internal interface JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IMemberAssignment {
    public ICSharpIdentifier NameIdentifier { get; }
    [NotNullAttribute]
public abstract virtual IType GetConstructedType(IResolveContext resolveContext);
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual void SetName(string name);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InactivePreprocessorBranchElement : CSharpCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual string ToString();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    private sealed virtual override void JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTreeNode.Accept(TreeNodeVisitor visitor);
    private sealed virtual override void JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTreeNode.Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    private sealed virtual override TReturn JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTreeNode.Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InactivePreprocessorBranchNodeType : CSharpCompositeNodeType {
    [NotNullAttribute]
internal static InactivePreprocessorBranchNodeType INSTANCE;
    private static InactivePreprocessorBranchNodeType();
    public virtual CompositeElement Create();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IndexerDeclaration : IndexerDeclarationStub {
    protected virtual IDeclaredElement CreateDeclaredElement();
    [CanBeNullAttribute]
public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IndexerDeclarationStub : ProperTypeMemberDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short CSHARP_TYPE;
    public static short CSHARP_QUALIFIER;
    public static short CSHARP_NAME;
    public static short CSHARP_LBRACKET;
    public static short PARAMS;
    public static short CSHARP_RBRACKET;
    public static short CSHARP_LBRACE;
    public static short ACCESSOR_DECL;
    public static short CSHARP_RBRACE;
    public static short ARROW_CLAUSE;
    public static short CSHARP_SEMICOLON;
    private static string THIS;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IAccessorDeclaration> AccessorDeclarations { get; }
    public TreeNodeEnumerable`1<IAccessorDeclaration> AccessorDeclarationsEnumerable { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IOwnerQualification InterfaceQualification { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode LBracket { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode RBracket { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode ThisKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IReferenceName InterfaceQualificationReference { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public string DeclaredName { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public ReferenceKind ReturnKind { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public IType Type { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    private IProperty JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerDeclaration.DeclaredElement { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IAccessorDeclaration> get_AccessorDeclarations();
    public virtual TreeNodeEnumerable`1<IAccessorDeclaration> get_AccessorDeclarationsEnumerable();
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IOwnerQualification get_InterfaceQualification();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_LBracket();
    public virtual IFormalParameterList get_Params();
    public virtual ITokenNode get_RBrace();
    public virtual ITokenNode get_RBracket();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_ThisKeyword();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IReferenceName get_InterfaceQualificationReference();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IOwnerQualification SetInterfaceQualification(IOwnerQualification param);
    public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IFormalParameterList SetParams(IFormalParameterList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public virtual string get_DeclaredName();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    protected virtual bool HasExecutableCodeBody();
    public virtual bool IsSemanticallyAbstract();
    public virtual bool IsSemanticallyVirtual();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual void SetReturnKind(ReferenceKind returnKind);
    protected internal virtual string GetShortNameOfDeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    public sealed virtual ITokenNode get_LPar();
    public sealed virtual ITokenNode get_RPar();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationAfter(IAccessorDeclaration accessorDeclaration, IAccessorDeclaration anchor);
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationBefore(IAccessorDeclaration accessorDeclaration, IAccessorDeclaration anchor);
    public sealed virtual void RemoveAccessorDeclaration(IAccessorDeclaration accessorDeclaration);
    public virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IProperty JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerDeclaration.get_DeclaredElement();
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IndexerInitializer : IndexerInitializerStub {
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual ICreationExpressionInitializer SetInitializer(ICreationExpressionInitializer param);
    private void RemoveRightPart();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IndexerInitializerStub : MemberInitializerBase {
    public static short CSHARP_LBRACKET;
    public static short ARGUMENT_LIST;
    public static short CSHARP_RBRACKET;
    public static short CSHARP_EQ;
    public static short CSHARP_OP2;
    public static short CSHARP_INITIALIZER;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public ICSharpExpression Expression { get; }
    public ICreationExpressionInitializer Initializer { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode Operator { get; }
    public ITokenNode RBracket { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    private IPsiModule JetBrains.ReSharper.Psi.IInvocationInfo.PsiModule { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual ICSharpExpression get_Expression();
    public virtual ICreationExpressionInitializer get_Initializer();
    public virtual ITokenNode get_LBracket();
    public virtual ITokenNode get_Operator();
    public virtual ITokenNode get_RBracket();
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual ICreationExpressionInitializer SetInitializer(ICreationExpressionInitializer param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IList`1<ITokenNode> get_Delimiters();
    public sealed virtual ITokenNode get_LBound();
    public sealed virtual ITokenNode get_RBound();
    public sealed virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual void RemoveArgument(ICSharpArgument argument);
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    private sealed virtual override string JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Dump();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IInvocationInfo.get_PsiModule();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IndexFromEndExpression : CSharpExpressionBase {
    public static short OP_SIGN;
    public static short OP;
    private IndexTypeReference myReference;
    public NodeType NodeType { get; }
    public IUnaryExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public IReference TypeReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IUnaryExpression get_Operand();
    public virtual ITokenNode get_OperatorSign();
    public virtual IUnaryExpression SetOperand(IUnaryExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IReference get_TypeReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InterfaceDeclaration : InterfaceDeclarationStub {
    [NotNullAttribute]
public virtual IClassBody SetBody(IClassBody param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InterfaceDeclarationStub : ClassLikeDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short KEYWORD;
    public static short CSHARP_NAME;
    public static short TYPE_PARAMETERS_LIST;
    public static short CONSTRUCTOR;
    public static short CSHARP_BASE;
    public static short CONSTRAINTS;
    public static short CSHARP_BLOCK;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IClassBody Body { get; }
    public IExtendsList ExtendedInterfaces { get; }
    public ITokenNode InterfaceKeyword { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IPrimaryConstructorDeclaration PrimaryConstructorDeclaration { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IClassBody BodyInternal { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> ExtendedInterfaceUsages { get; }
    public TreeNodeEnumerable`1<ITypeUsage> ExtendedInterfaceUsagesEnumerable { get; }
    public TreeNodeCollection`1<IFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IIndexerDeclaration> IndexerDeclarations { get; }
    public TreeNodeEnumerable`1<IIndexerDeclaration> IndexerDeclarationsEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IOperatorDeclaration> OperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IOperatorDeclaration> OperatorDeclarationsEnumerable { get; }
    public ICSharpNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParametersEnumerable { get; }
    public ITokenNode TypeDeclarationKeyword { get; }
    public IExtendsList ExtendsList { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public IReadOnlyList`1<ITypeDeclaration> TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> DestructorDeclarations { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> SuperTypeUsageNodes { get; }
    public TreeNodeCollection`1<IClassMemberDeclaration> ClassMemberDeclarations { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public string DeclaredName { get; }
    private ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.DeclaredElement { get; }
    private IInterface JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IMemberOwnerBody JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration.Body { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IClassBody get_Body();
    public virtual IExtendsList get_ExtendedInterfaces();
    public virtual ITokenNode get_InterfaceKeyword();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IPrimaryConstructorDeclaration get_PrimaryConstructorDeclaration();
    public virtual ITokenNode get_Semicolon();
    public virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public virtual ITypeParameterOfTypeList get_TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IClassBody get_BodyInternal();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeUsage> get_ExtendedInterfaceUsages();
    public virtual TreeNodeEnumerable`1<ITypeUsage> get_ExtendedInterfaceUsagesEnumerable();
    public virtual TreeNodeCollection`1<IFieldDeclaration> get_FieldDeclarations();
    public virtual TreeNodeEnumerable`1<IFieldDeclaration> get_FieldDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IIndexerDeclaration> get_IndexerDeclarations();
    public virtual TreeNodeEnumerable`1<IIndexerDeclaration> get_IndexerDeclarationsEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_NestedTypeDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IOperatorDeclaration> get_OperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IOperatorDeclaration> get_OperatorDeclarationsEnumerable();
    public virtual ICSharpNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParametersEnumerable();
    public virtual IClassBody SetBody(IClassBody param);
    public virtual IExtendsList SetExtendedInterfaces(IExtendsList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IPrimaryConstructorDeclaration SetPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual string ToString();
    public sealed virtual ITokenNode get_TypeDeclarationKeyword();
    public sealed virtual IExtendsList get_ExtendsList();
    public sealed virtual IExtendsList GetOrCreateExtendsList();
    public sealed virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public sealed virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    public sealed virtual TreeNodeCollection`1<IDestructorDeclaration> get_DestructorDeclarations();
    public sealed virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeUsage> get_SuperTypeUsageNodes();
    public virtual TreeNodeCollection`1<IClassMemberDeclaration> get_ClassMemberDeclarations();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    public virtual void SetAbstract(bool value);
    public virtual void SetStatic(bool value);
    public virtual string get_DeclaredName();
    public sealed virtual bool CanBindTo(ITypeElement typeElement);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.get_DeclaredElement();
    private sealed virtual override IInterface JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IMemberOwnerBody JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration.get_Body();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration typeParameterDeclaration);
    public sealed virtual void AddSuperInterface(IDeclaredType interfaceType, bool before);
    public sealed virtual void RemoveSuperInterface(IDeclaredType interfaceType);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InterpolatedStringExpression : CSharpExpressionBase {
    public static short LITERAL;
    public static short INSERT;
    [NotNullAttribute]
private MyFormatMethodReference myFormatMethodReference;
    [NotNullAttribute]
private MyHandlerConstructorReference myHandlerConstructorReference;
    [NotNullAttribute]
private MyHandlerAppendLiteralMethodReference myHandlerAppendLiteralMethodReference;
    [NotNullAttribute]
private MyHandlerAppendLiteralParamsDefaultConstructorReference myHandlerAppendLiteralParamsDefaultConstructorReference;
    [NotNullAttribute]
private MyHandlerAppendLiteralParamsCreateMethodReference myHandlerAppendLiteralParamsCreateMethodReference;
    [NotNullAttribute]
private MyHandlerAppendLiteralParamsAddReference myHandlerAppendLiteralParamsAddReference;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IInterpolatedStringInsert> Inserts { get; }
    public TreeNodeEnumerable`1<IInterpolatedStringInsert> InsertsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Literals { get; }
    public TreeNodeEnumerable`1<ITokenNode> LiteralsEnumerable { get; }
    public ICSharpInvocationReference FormatReference { get; }
    public IInterpolatedStringHandlerConstructorReference HandlerConstructorReference { get; }
    public ICSharpInvocationReference HandlerAppendLiteralReference { get; }
    public IReference HandlerAppendLiteralParamsDefaultConstructorReference { get; }
    public IReference HandlerAppendLiteralParamsCreateMethodReference { get; }
    public IReference HandlerAppendLiteralParamsAddReference { get; }
    private IList`1<ITokenNode> JetBrains.ReSharper.Psi.CSharp.Tree.IStringLiteralOwner.StringLiterals { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IInterpolatedStringInsert> get_Inserts();
    public virtual TreeNodeEnumerable`1<IInterpolatedStringInsert> get_InsertsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Literals();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_LiteralsEnumerable();
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual ICSharpInvocationReference get_FormatReference();
    public sealed virtual IInterpolatedStringHandlerConstructorReference get_HandlerConstructorReference();
    public sealed virtual ICSharpInvocationReference get_HandlerAppendLiteralReference();
    public sealed virtual IReference get_HandlerAppendLiteralParamsDefaultConstructorReference();
    public sealed virtual IReference get_HandlerAppendLiteralParamsCreateMethodReference();
    public sealed virtual IReference get_HandlerAppendLiteralParamsAddReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual IType Type(IResolveContext resolveContext);
    [PureAttribute]
public sealed virtual InterpolatedStringKind GetInterpolatedStringKind(IResolveContext resolveContext);
    [PureAttribute]
internal InterpolatedStringConvertedTypeInfo GetConvertedTypeInfo(IResolveContext resolveContext);
    [PureAttribute]
private bool ShouldUseDefaultInterpolatedStringHandler(IResolveContext resolveContext, PredefinedType predefinedType);
    [PureAttribute]
internal bool CanUseInterpolatedStringHandlers();
    private sealed virtual override IList`1<ITokenNode> JetBrains.ReSharper.Psi.CSharp.Tree.IStringLiteralOwner.get_StringLiterals();
    private sealed virtual override void JetBrains.ReSharper.Psi.CSharp.Tree.IStringLiteralOwner.SetText(string literalText);
    [CompilerGeneratedAttribute]
internal static bool <ShouldUseDefaultInterpolatedStringHandler>g__ContainsAwait|43_0(ITreeNode body);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InterpolatedStringHandlerMethodReferenceBase`1 : InterpolatedStringReferenceBase`1<TOwner> {
    protected InterpolatedStringHandlerMethodReferenceBase`1(TOwner owner);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public sealed virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public sealed virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InterpolatedStringInsert : CSharpCompositeElement {
    public static short EXPR1;
    public static short CSHARP_COMMA;
    public static short EXPR2;
    public static short FORMAT_SPECIFIER;
    private MyHandlerAppendFormattedMethodReference myHandlerAppendFormattedMethodReference;
    [NotNullAttribute]
private MyHandlerAppendFormattedParamsDefaultConstructorReference myHandlerAppendFormattedParamsDefaultConstructorReference;
    [NotNullAttribute]
private MyHandlerAppendFormattedParamsCreateMethodReference myHandlerAppendFormattedParamsCreateMethodReference;
    [NotNullAttribute]
private MyHandlerAppendFormattedParamsAddReference myHandlerAppendFormattedParamsAddReference;
    public NodeType NodeType { get; }
    public ICSharpExpression AlignmentExpression { get; }
    public ITokenNode Comma { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode FormatSpecifier { get; }
    public ICSharpInvocationReference HandlerAppendFormattedReference { get; }
    public IReference HandlerAppendFormattedParamsDefaultConstructorReference { get; }
    public IReference HandlerAppendFormattedParamsCreateMethodReference { get; }
    public IReference HandlerAppendFormattedParamsAddReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_AlignmentExpression();
    public virtual ITokenNode get_Comma();
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_FormatSpecifier();
    public virtual ICSharpExpression SetAlignmentExpression(ICSharpExpression param);
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual ICSharpInvocationReference get_HandlerAppendFormattedReference();
    public sealed virtual IReference get_HandlerAppendFormattedParamsDefaultConstructorReference();
    public sealed virtual IReference get_HandlerAppendFormattedParamsCreateMethodReference();
    public sealed virtual IReference get_HandlerAppendFormattedParamsAddReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InterpolatedStringReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<TOwner> {
    [NotNullAttribute]
protected InterpolatedStringExpression InterpolatedStringExpression { get; }
    public ICSharpInvocationInfo Invocation { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public IList`1<IType> TypeArguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public ICSharpInvocationReference Reference { get; }
    public IPsiModule PsiModule { get; }
    protected InterpolatedStringReferenceBase`1(TOwner owner);
    protected abstract virtual InterpolatedStringExpression get_InterpolatedStringExpression();
    public sealed virtual IReference BindTo(IDeclaredElement element);
    public sealed virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public abstract virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public abstract virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public abstract virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InvalidDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short MESSAGE;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode EndOfLine { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_EndOfLine();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
    public sealed virtual TreeTextRange GetInvalidNameRange();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InvocableAwaitReferenceBase`1 : AwaitReferenceBase`1<TAwaitReferencesOwner> {
    public IList`1<IType> TypeArguments { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    [NotNullAttribute]
public ICSharpInvocationReference Reference { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    [NotNullAttribute]
private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    public ICSharpInvocationInfo Invocation { get; }
    protected InvocableAwaitReferenceBase`1(TAwaitReferencesOwner owner);
    protected virtual ResolveResultWithInfo CoreResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    public sealed virtual IList`1<IType> get_TypeArguments();
    public virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.InvocationExpression : CSharpExpressionBase {
    public static short OP;
    public static short CSHARP_LPAR;
    public static short ARGUMENT_LIST;
    public static short CSHARP_RPAR;
    private InvocationExpressionReference myInvocationReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public IPrimaryExpression InvokedExpression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    private IInvocationExpressionReference JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression.InvocationExpressionReference { get; }
    private IInvocationExpressionReference JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression.Reference { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    public bool HasConditionalAccessSign { get; }
    public ICSharpExpression ConditionalQualifier { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual IPrimaryExpression get_InvokedExpression();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual IPrimaryExpression SetInvokedExpression(IPrimaryExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IInvocationExpressionReference JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression.get_InvocationExpressionReference();
    private sealed virtual override IInvocationExpressionReference JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression.get_Reference();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IList`1<ITokenNode> get_Delimiters();
    public sealed virtual ITokenNode get_LBound();
    public sealed virtual ITokenNode get_RBound();
    public sealed virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual void RemoveArgument(ICSharpArgument argument);
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual bool get_HasConditionalAccessSign();
    public sealed virtual ICSharpExpression get_ConditionalQualifier();
    public sealed virtual ICSharpExpression SetConditionalQualifier(ICSharpExpression expression);
    public sealed virtual IConditionalAccessSign get_ConditionalAccessSign();
    public sealed virtual void SetConditionalAccessSign(bool value);
    public sealed virtual IExpressionType UnliftedExpressionType();
    public sealed virtual bool IsNameofOperator();
    public sealed virtual bool IsNameofOperator(IResolveContext resolveContext);
    private bool IsNameofOperatorImpl(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IParamsAddReference {
    [NullableContextAttribute("1")]
public abstract virtual IParameter GetParamsParameter(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IParamsCreateMethodReference {
    [NullableContextAttribute("1")]
public abstract virtual IParameter GetParamsParameter(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IParamsDefaultConstructorReference {
    [NullableContextAttribute("1")]
public abstract virtual IParameter GetParamsParameter(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.IsExpression : CSharpExpressionBase {
    public static short OP;
    public static short OP_SIGN;
    public static short PATTERN;
    [NotNullAttribute]
private CachedPsiValue`1<DecisionDag> myCachedDecisionDag;
    public NodeType NodeType { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public IPattern Pattern { get; }
    public IType IsType { get; }
    private ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IDecisionDagOwner.GoverningExpression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Operand();
    public virtual ITokenNode get_OperatorSign();
    public virtual IPattern get_Pattern();
    public virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public virtual IPattern SetPattern(IPattern param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    protected virtual void PreInit();
    public sealed virtual IType get_IsType();
    public sealed virtual IType GetIsType(IResolveContext resolveContext);
    public sealed virtual IsExpressionKind GetKind(IResolveContext resolveContext, bool unresolvedIsTypeCheck);
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IDecisionDagOwner.get_GoverningExpression();
    public sealed virtual DecisionDag GetOrCreateDecisionDag(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.JoinReference : QueryChainReferenceBase`1<QueryJoinClause> {
    private static string JOIN;
    private static string GROUP_JOIN;
    public JoinReference(QueryJoinClause owner);
    [NotNullAttribute]
private ICSharpArgumentInfo ArgumentWithCast(ICSharpExpression expression);
    public virtual ICSharpArgumentInfo[] GetArguments();
    public virtual string GetName();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.Keyword : CSharpCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LabelDeclaration : CSharpNonCachedDeclarationBase {
    public static short CSHARP_NAME;
    public NodeType NodeType { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public string DeclaredName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual DeclaredElementType GetElementType();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LabelReferenceElement : CSharpCompositeElement {
    public static short CSHARP_NAME;
    private CachedPsiValue`1<ResolveResultWithInfo> myResolveCache;
    private LocalUserDataHolder myUserDataHolder;
    public NodeType NodeType { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    public IReference Reference { get; }
    public bool HasMultipleNames { get; }
    public bool ShouldResolveInGlobalTable { get; }
    public bool IsQualified { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual ResolveResultWithInfo get_CurrentResolveResult();
    public sealed virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T val);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public sealed virtual IReference get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IAccessContext GetAccessContext();
    public sealed virtual ITreeNode GetTreeNode();
    public sealed virtual string GetName();
    public sealed virtual bool get_HasMultipleNames();
    public sealed virtual HybridCollection`1<string> GetAllNames();
    public sealed virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public sealed virtual ISymbolTable GetCompletionSymbolTable();
    public sealed virtual ResolveResultWithInfo Resolve();
    public sealed virtual IReference BindTo(IDeclaredElement element);
    public sealed virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    private sealed virtual override TreeTextRange JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeTextRange();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    public sealed virtual bool get_ShouldResolveInGlobalTable();
    public sealed virtual bool get_IsQualified();
    public sealed virtual IQualifier GetQualifier();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LabelStatement : StatementBase {
    public static short CSHARP_LABEL_NAME;
    public static short CSHARP_COLON;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public ILabelDeclaration Label { get; }
    public bool CanBeEmbedded { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Colon();
    public virtual ILabelDeclaration get_Label();
    public virtual ILabelDeclaration SetLabel(ILabelDeclaration param);
    public virtual string ToString();
    public virtual bool get_CanBeEmbedded();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LambdaExpression : LambdaExpressionStub {
    public virtual ICSharpExpression SetBodyExpression(ICSharpExpression param);
    public virtual ILambdaSignature SetSignature(ILambdaSignature param);
    public virtual IBlock SetBodyBlock(IBlock param);
    public virtual ITypeUsage SetReturnType(ITypeUsage param);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LambdaExpressionStub : CSharpExpressionBase {
    public static short CSHARP_ATTRIBUTES;
    public static short ASYNC;
    public static short STATIC;
    public static short BYREF;
    public static short READONLY;
    public static short RETURN_TYPE;
    public static short SIGNATURE;
    public static short LAMBDA_ARROW;
    public static short BODY_EXPRESSION;
    public static short BODY_BLOCK;
    private CachedPsiValue`1<IType> myCachedAnnotatedInferredReturnType;
    public NodeType NodeType { get; }
    public IBlock BodyBlock { get; }
    public ICSharpExpression BodyExpression { get; }
    public ITokenNode LambdaArrow { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode RefReadonlyKeyword { get; }
    public ITypeUsage ReturnType { get; }
    public ILambdaSignature Signature { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<ILocalRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ITokenNode RPar { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public bool IsAsync { get; }
    public bool IsStatic { get; }
    public IType InferredReturnType { get; }
    private IType JetBrains.ReSharper.Psi.IParametersOwner.ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public ITokenNode AsyncKeyword { get; }
    public ITokenNode StaticKeyword { get; }
    public ReferenceKind ExplicitReturnKind { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public bool HasImplicitlyTypedParameters { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameter> Parameters { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    private TreeNodeEnumerable`1<ICSharpParameterDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.ParameterDeclarationsEnumerable { get; }
    private TreeNodeCollection`1<ICSharpParameterDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.ParameterDeclarations { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    public string DeclaredName { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public IType AnnotatedInferredReturnType { get; public set; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_BodyBlock();
    public virtual ICSharpExpression get_BodyExpression();
    public virtual ITokenNode get_LambdaArrow();
    public virtual ITokenNode get_RefKeyword();
    public virtual ITokenNode get_RefReadonlyKeyword();
    public virtual ITypeUsage get_ReturnType();
    public virtual ILambdaSignature get_Signature();
    public virtual IAttributeSectionList get_AttributeSectionList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual TreeNodeCollection`1<ILocalRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ILocalRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual ITokenNode get_RPar();
    public virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public virtual IBlock SetBodyBlock(IBlock param);
    public virtual ICSharpExpression SetBodyExpression(ICSharpExpression param);
    public virtual ITypeUsage SetReturnType(ITypeUsage param);
    public virtual ILambdaSignature SetSignature(ILambdaSignature param);
    public virtual string ToString();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IType get_InferredReturnType();
    private sealed virtual override IType JetBrains.ReSharper.Psi.IParametersOwner.get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IType GetInferredReturnType(IResolveContext resolveContext);
    public sealed virtual ITokenNode get_AsyncKeyword();
    public sealed virtual ITokenNode get_StaticKeyword();
    public sealed virtual ReferenceKind get_ExplicitReturnKind();
    public sealed virtual TParameterDeclaration AddParameterDeclarationBefore(TParameterDeclaration parameterDeclaration, ILocalParameterDeclaration anchor);
    [NotNullAttribute]
private TLocalParameterDeclaration AddFirstAndSingleParameter(TLocalParameterDeclaration parameterDeclaration);
    public sealed virtual TParameterDeclaration AddParameterDeclarationAfter(TParameterDeclaration parameterDeclaration, ILocalParameterDeclaration anchor);
    public sealed virtual TLocalParameterDeclaration ReplaceParameterDeclaration(ILocalParameterDeclaration parameterDeclaration, TLocalParameterDeclaration newParameterDeclaration);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(ILocalParameterDeclaration parameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual bool TrySetSignatureParentheses(bool value);
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual bool get_HasImplicitlyTypedParameters();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    private sealed virtual override TreeNodeEnumerable`1<ICSharpParameterDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_ParameterDeclarationsEnumerable();
    private sealed virtual override TreeNodeCollection`1<ICSharpParameterDeclaration> JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_ParameterDeclarations();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    public sealed virtual ILocalParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    private sealed virtual override IParameterDeclaration JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual ILocalParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    private sealed virtual override IParameterDeclaration JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public sealed virtual void SetAsync(bool value);
    public sealed virtual void SetStatic(bool value);
    public sealed virtual TreeTextRange GetNameRange();
    public virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    public virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public virtual void RemoveAttribute(IAttribute attribute);
    private IList`1<IAttribute> GetOurAttributes();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public virtual IType Type(IResolveContext resolveContext);
    private static bool IsExplicitCastOperand(ICSharpExpression expression);
    public sealed virtual IType get_AnnotatedInferredReturnType();
    public sealed virtual void set_AnnotatedInferredReturnType(IType value);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LambdaSignature : CSharpCompositeElement {
    public static short CSHARP_LPAR;
    public static short CSHARP_PARAMETER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<ILocalRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual TreeNodeCollection`1<ILocalRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ILocalRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LetReference : QueryChainReferenceBase`1<QueryLetClause> {
    private static string SELECT;
    public LetReference(QueryLetClause owner);
    public virtual ICSharpArgumentInfo[] GetArguments();
    public virtual string GetName();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LineDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short LINE_INDICATOR;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ILineIndicator LineIndicator { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ILineIndicator get_LineIndicator();
    public virtual ITokenNode get_NumberSign();
    public virtual ILineIndicator SetLineIndicator(ILineIndicator param);
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LineIndicator : CSharpCompositeElement {
    public static short LINE;
    public static short NAME;
    public static short DEFAULT;
    public NodeType NodeType { get; }
    public ITokenNode Default { get; }
    public ITokenNode Hidden { get; }
    public ITokenNode LineDigits { get; }
    public ITokenNode Name { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Default();
    public virtual ITokenNode get_Hidden();
    public virtual ITokenNode get_LineDigits();
    public virtual ITokenNode get_Name();
    public virtual string ToString();
    public virtual bool IsFiltered();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ListPattern : ListPatternStub {
    protected virtual void PreInit();
    [NullableContextAttribute("2")]
public virtual IVariableDesignation SetDesignation(IVariableDesignation newDesignation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ListPatternReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<T> {
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public ICSharpInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    public ICSharpInvocationInfo Invocation { get; }
    protected ListPatternReferenceBase`1(T owner);
    public abstract virtual IList`1<ICSharpArgumentInfo> GetArguments();
    protected ISymbolFilter[] GetIndexerFilters(ISymbolFilter additionalFilter, IAccessContext accessContext);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ListPatternStub : CSharpCompositeElement {
    public static short CSHARP_LBRACKET;
    public static short CSHARP_PATTERN;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACKET;
    public static short VARIABLE_DESIGNATION;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IListPatternReference <LengthReference>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IListPatternReference <IndexerReference>k__BackingField;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IVariableDesignation Designation { get; }
    public ITokenNode LBracket { get; }
    public TreeNodeCollection`1<IPattern> Patterns { get; }
    public TreeNodeEnumerable`1<IPattern> PatternsEnumerable { get; }
    public ITokenNode RBracket { get; }
    [NullableAttribute("1")]
public IListPatternReference LengthReference { get; protected set; }
    [NullableAttribute("1")]
public IListPatternReference IndexerReference { get; protected set; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual IVariableDesignation get_Designation();
    public virtual ITokenNode get_LBracket();
    public virtual TreeNodeCollection`1<IPattern> get_Patterns();
    public virtual TreeNodeEnumerable`1<IPattern> get_PatternsEnumerable();
    public virtual ITokenNode get_RBracket();
    public virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IListPatternReference get_LengthReference();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected void set_LengthReference(IListPatternReference value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IListPatternReference get_IndexerReference();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected void set_IndexerReference(IListPatternReference value);
    public virtual ReferenceCollection GetFirstClassReferences();
    [NullableContextAttribute("1")]
public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    [NullableContextAttribute("2")]
public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
public sealed virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
public sealed virtual IType GetDesignationType(IVariableDesignation designation, IResolveContext resolveContext);
    [NullableContextAttribute("1")]
public sealed virtual IExpressionType GetDesignationExpressionType(IVariableDesignation designation, IResolveContext resolveContext);
    [NullableContextAttribute("1")]
public sealed virtual IPattern AddPatternAfter(IPattern pattern, IPattern anchor);
    [NullableContextAttribute("1")]
public sealed virtual IPattern AddPatternBefore(IPattern pattern, IPattern anchor);
    [NullableContextAttribute("1")]
public sealed virtual void RemovePattern(IPattern pattern);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalArglistParameterDeclaration : CSharpNonCachedDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short ARGLIST_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode ArglistKeyword { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public bool IsValueVariable { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public ParameterKind Kind { get; }
    public bool IsOptional { get; }
    public ICSharpExpression DefaultValue { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public IType Type { get; }
    [NotNullAttribute]
private IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.DeclaredElement { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITypeUsage TypeUsage { get; }
    public IParameter DeclaredElement { get; }
    public string DeclaredName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ArglistKeyword();
    public virtual IAttributeSectionList get_AttributeSectionList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public virtual string ToString();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IList`1<IAttribute> GetOurAttributes();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsOptional();
    public sealed virtual ICSharpExpression get_DefaultValue();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    private sealed virtual override IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.get_DeclaredElement();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public sealed virtual ITypeUsage get_TypeUsage();
    public sealed virtual TParameterDeclaration ReplaceBy(TParameterDeclaration declaration);
    public IParameter get_DeclaredElement();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual bool IsSynthetic();
    protected internal virtual string GetShortNameOfDeclaredElement();
    public sealed virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public sealed virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    public sealed virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public sealed virtual void RemoveAttribute(IAttribute attribute);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalConstantDeclaration : CSharpNonCachedDeclarationBase {
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short CSHARP_CONSTANT_EXPRESSION;
    [ThreadStaticAttribute]
private static JetHashSet`1<ICSharpLocalVariable> ourConstantCalculationsInProgress;
    private CachedPsiValue`1<IType> myCachedType;
    private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    public NodeType NodeType { get; }
    public ITokenNode EquivalenceSign { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ICSharpExpression ValueExpression { get; }
    public IMultipleDeclaration MultipleDeclaration { get; }
    public ITypeUsage TypeUsage { get; }
    public IReferenceName ScalarTypeName { get; }
    private ICSharpLocalVariable JetBrains.ReSharper.Psi.CSharp.Tree.ILocalConstantDeclaration.DeclaredElement { get; }
    public string DeclaredName { get; }
    public IType Type { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public bool IsWritable { get; }
    public bool IsConstant { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ConstantValue CachedConstantValue { get; public set; }
    public ConstantValue ConstantValue { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    public bool IsImplicitlyTyped { get; }
    public bool IsUsedAsNotNullable { get; }
    public bool ContributesAnnotationToTypeInference { get; }
    public ReferenceKind ReferenceKind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EquivalenceSign();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpExpression get_ValueExpression();
    public virtual IMultipleDeclaration get_MultipleDeclaration();
    public virtual ITypeUsage get_TypeUsage();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    protected virtual void PreInit();
    public sealed virtual IReferenceName get_ScalarTypeName();
    private sealed virtual override ICSharpLocalVariable JetBrains.ReSharper.Psi.CSharp.Tree.ILocalConstantDeclaration.get_DeclaredElement();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual IType get_Type();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ScopedKind get_Scope();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual void SetType(IType type);
    public sealed virtual ConstantValue get_CachedConstantValue();
    public sealed virtual void set_CachedConstantValue(ConstantValue value);
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.ILocalConstantDeclaration.SetValueExpression(ICSharpExpression param);
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    public sealed virtual bool get_IsImplicitlyTyped();
    public sealed virtual bool get_IsUsedAsNotNullable();
    public sealed virtual bool get_ContributesAnnotationToTypeInference();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    public virtual string ToString();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalFormalParameterList : CSharpCompositeElement {
    public static short CSHARP_PARAMETER;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ILocalParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ILocalParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ILocalParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalFunctionDeclaration : LocalFunctionDeclarationStub {
    [CanBeNullAttribute]
public virtual IBlock SetBody(IBlock block);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalFunctionDeclarationStub : CSharpNonCachedDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short CSHARP_TYPE;
    public static short CSHARP_NAME;
    public static short TYPE_PARAMETERS_LIST;
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public static short CONSTRAINTS;
    public static short CSHARP_BLOCK;
    public static short ARROW_CLAUSE;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IBlock Body { get; }
    public ITokenNode LPar { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ILocalFormalParameterList ParameterList { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfLocalFunctionList TypeParameterList { get; }
    public ITypeUsage TypeUsage { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfLocalFunctionDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> TypeParameterDeclarationsEnumerable { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public IParametersOwner DeclaredParametersOwner { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ILocalFunction JetBrains.ReSharper.Psi.CSharp.Tree.ILocalFunctionDeclaration.DeclaredElement { get; }
    public IType Type { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsVarArg { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public string DeclaredName { get; }
    public bool HasAccessRights { get; }
    public bool IsStatic { get; }
    public bool IsUnsafe { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsVolatile { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IBlock get_Body();
    public virtual ITokenNode get_LPar();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ILocalFormalParameterList get_ParameterList();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Semicolon();
    public virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public virtual ITypeParameterOfLocalFunctionList get_TypeParameterList();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IAttributeSectionList get_AttributeSectionList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfLocalFunctionDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public virtual IBlock SetBody(IBlock param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ILocalFormalParameterList SetParameterList(ILocalFormalParameterList param);
    public virtual ITypeParameterOfLocalFunctionList SetTypeParameterList(ITypeParameterOfLocalFunctionList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public sealed virtual IParametersOwner get_DeclaredParametersOwner();
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual ITypeParameterOfLocalFunctionDeclaration AddTypeParameterBefore(ITypeParameterOfLocalFunctionDeclaration typeParameter, ITypeParameterOfLocalFunctionDeclaration anchor);
    public sealed virtual ITypeParameterOfLocalFunctionDeclaration AddTypeParameterAfter(ITypeParameterOfLocalFunctionDeclaration typeParameter, ITypeParameterOfLocalFunctionDeclaration anchor);
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfLocalFunctionDeclaration typeParameter);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
    public sealed virtual void SetAbstract(bool value);
    public sealed virtual void SetSealed(bool value);
    public sealed virtual void SetVirtual(bool value);
    public sealed virtual void SetOverride(bool value);
    public sealed virtual void SetStatic(bool value);
    public sealed virtual void SetReadonly(bool value);
    public sealed virtual void SetExtern(bool value);
    public sealed virtual void SetUnsafe(bool value);
    public sealed virtual void SetVolatile(bool value);
    public sealed virtual void SetAsync(bool isAsync);
    public sealed virtual void SetReturnKind(ReferenceKind returnKind);
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ILocalFunction JetBrains.ReSharper.Psi.CSharp.Tree.ILocalFunctionDeclaration.get_DeclaredElement();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public virtual DeclaredElementType GetElementType();
    public virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsync();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
    public sealed virtual bool get_HasAccessRights();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual void SetAccessRights(AccessRights rights);
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public sealed virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    public sealed virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public sealed virtual void RemoveAttribute(IAttribute attribute);
    private IList`1<IAttribute> GetOurAttributes();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalRegularParameterDeclaration : LocalRegularParameterDeclarationStub {
    [ThreadStaticAttribute]
private static JetHashSet`1<IParameter> ourTypeCalculationsInProgress;
    private CachedPsiValue`1<IType> myCachedType;
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    protected virtual void ClearCachedData();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    [CanBeNullAttribute]
public virtual ICSharpExpression SetDefaultValue(ICSharpExpression param);
    public virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList attributeSectionList);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalRegularParameterDeclarationStub : CSharpNonCachedDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short PARAMETER_MODIFIERS;
    public static short CSHARP_TYPE;
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short VALUE;
    protected MyParamsDefaultConstructorReference modreq(System.Runtime.CompilerServices.IsVolatile) myParamsDefaultConstructorReference;
    protected MyParamsCreateMethodReference modreq(System.Runtime.CompilerServices.IsVolatile) myParamsCreateMethodReference;
    protected MyParamsAnyArgumentAddMethodReference modreq(System.Runtime.CompilerServices.IsVolatile) myParamsAnyArgumentAddMethodReference;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public ICSharpExpression DefaultValue { get; }
    public ITokenNode EqSign { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IParameterModifiersList ParameterModifiersList { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public bool IsExplicitlyTyped { get; }
    public bool IsImplicitlyTyped { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsOptional { get; }
    public ITokenNode ParamsKeyword { get; }
    public ITokenNode ThisKeyword { get; }
    public ITokenNode ScopedKeyword { get; }
    public IReference ParamsDefaultConstructorReference { get; }
    public IReference ParamsCreateMethodReference { get; }
    public IReference ParamsAnyArgumentAddMethodReference { get; }
    public bool IsValueVariable { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public IType Type { get; }
    public IParameter DeclaredElement { get; }
    public string DeclaredName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributeSectionList();
    public virtual ICSharpExpression get_DefaultValue();
    public virtual ITokenNode get_EqSign();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IParameterModifiersList get_ParameterModifiersList();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public virtual ICSharpExpression SetDefaultValue(ICSharpExpression param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IParameterModifiersList SetParameterModifiersList(IParameterModifiersList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public sealed virtual bool get_IsExplicitlyTyped();
    public sealed virtual bool get_IsImplicitlyTyped();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    [NotNullAttribute]
[ItemNotNullAttribute]
private IList`1<IAttribute> GetOurAttributes();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsOptional();
    public sealed virtual ITokenNode get_ParamsKeyword();
    public sealed virtual ITokenNode get_ThisKeyword();
    public sealed virtual ITokenNode get_ScopedKeyword();
    public sealed virtual IReference get_ParamsDefaultConstructorReference();
    public sealed virtual IReference get_ParamsCreateMethodReference();
    public sealed virtual IReference get_ParamsAnyArgumentAddMethodReference();
    protected bool ShouldOwnParamsReferences();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public sealed virtual IParameter get_DeclaredElement();
    public sealed virtual TParameterDeclaration ReplaceBy(TParameterDeclaration declaration);
    public sealed virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public sealed virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    public sealed virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public sealed virtual void RemoveAttribute(IAttribute attribute);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual DeclaredElementType GetElementType();
    public virtual bool IsSynthetic();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalVariableDeclaration : LocalVariableDeclarationStub {
    public ScopedKind Scope { get; }
    public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual ScopedKind get_Scope();
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalVariableDeclarationBase : CSharpNonCachedDeclarationBase {
    [ThreadStaticAttribute]
private static JetHashSet`1<ICSharpLocalVariable> ourTypeCalculationsInProgress;
    private CachedPsiValue`1<IType> myCachedType;
    [CompilerGeneratedAttribute]
private bool <IsUsedAsNotNullable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContributesAnnotationToTypeInference>k__BackingField;
    public IType Type { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public bool IsVar { get; }
    public bool IsUsedAsNotNullable { get; internal set; }
    public bool ContributesAnnotationToTypeInference { get; internal set; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsWritable { get; }
    [CanBeNullAttribute]
protected IType ExplicitlyDeclaredType { get; }
    public bool IsConstant { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsImplicitlyTyped { get; }
    protected virtual void PreInit();
    public abstract virtual void SetType(IType type);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IType get_Type();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public virtual bool get_IsVar();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUsedAsNotNullable();
    [CompilerGeneratedAttribute]
internal void set_IsUsedAsNotNullable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ContributesAnnotationToTypeInference();
    [CompilerGeneratedAttribute]
internal void set_ContributesAnnotationToTypeInference(bool value);
    public virtual ReferenceKind get_ReferenceKind();
    public abstract virtual bool get_IsWritable();
    protected abstract virtual IType get_ExplicitlyDeclaredType();
    [CanBeNullAttribute]
protected abstract virtual IType GetImplicitType(IResolveContext resolveContext);
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsStatic();
    public abstract virtual ScopedKind get_Scope();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsImplicitlyTyped();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CalculateType(IResolveContext resolveContext);
    public abstract virtual string ToString();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LocalVariableDeclarationStub : LocalVariableDeclarationBase {
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short CSHARP_INITIALIZER;
    public NodeType NodeType { get; }
    public ITokenNode EquivalenceSign { get; }
    public IVariableInitializer Initial { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IMultipleDeclaration MultipleDeclaration { get; }
    public ITypeUsage TypeUsage { get; }
    public string DeclaredName { get; }
    protected IType ExplicitlyDeclaredType { get; }
    public bool IsScoped { get; }
    public bool IsVar { get; }
    public ReferenceKind ReferenceKind { get; }
    public UsingDeclarationKind UsingKind { get; }
    public bool IsWritable { get; }
    private ICSharpLocalVariable JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration.DeclaredElement { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EquivalenceSign();
    public virtual IVariableInitializer get_Initial();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IMultipleDeclaration get_MultipleDeclaration();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    protected virtual IType get_ExplicitlyDeclaredType();
    public sealed virtual bool get_IsScoped();
    public virtual bool get_IsVar();
    public virtual ReferenceKind get_ReferenceKind();
    public sealed virtual UsingDeclarationKind get_UsingKind();
    public virtual bool get_IsWritable();
    public sealed virtual void SetVar();
    public sealed virtual void SetScoped(bool addScopedKeyword);
    public sealed virtual void SetReferenceKind(ReferenceKind kind);
    public sealed virtual void SetUsingKind(UsingDeclarationKind kind);
    public virtual void SetType(IType type);
    [NotNullAttribute]
protected virtual IType GetImplicitType(IResolveContext resolveContext);
    private sealed virtual override ICSharpLocalVariable JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration.get_DeclaredElement();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LockStatement : LockStatementStub {
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    [CanBeNullAttribute]
public virtual ICSharpStatement SetBody(ICSharpStatement bodyStatement);
    public sealed virtual bool get_IntroducesScope();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.LockStatementStub : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short EXPR;
    public static short CSHARP_RPAR;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public ICSharpStatement Body { get; }
    public ITokenNode LPar { get; }
    public ITokenNode LockKeyword { get; }
    public ICSharpExpression Monitor { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpStatement get_Body();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_LockKeyword();
    public virtual ICSharpExpression get_Monitor();
    public virtual ITokenNode get_RPar();
    public virtual ICSharpStatement SetBody(ICSharpStatement param);
    public virtual ICSharpExpression SetMonitor(ICSharpExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MakerefExpression : CSharpExpressionBase {
    public static short MAKEREF_KEYWORD;
    public static short CSHARP_LPAR;
    public static short EXPR;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode MakerefKeyword { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_MakerefKeyword();
    public virtual ITokenNode get_RPar();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MemberAssignmentReferenceBase`1 : ManagedCheckedReferenceBase`1<TOwner> {
    protected MemberAssignmentReferenceBase`1(TOwner owner);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    [NotNullAttribute]
protected abstract virtual ISymbolFilter[] GetCompletionSymbolFilters();
    public sealed virtual ISymbolTable GetCompletionSymbolTable();
    public virtual string GetName();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MemberInitializerBase : CSharpCompositeElement {
    [CompilerGeneratedAttribute]
private IReference <Reference>k__BackingField;
    public IReference Reference { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual IReference get_Reference();
    [CompilerGeneratedAttribute]
protected void set_Reference(IReference value);
    public virtual ReferenceCollection GetFirstClassReferences();
    [NotNullAttribute]
public sealed virtual IType GetConstructedType(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MemberOwnerDeclarationBase : TypeElementDeclarationBase {
    public ITypeElement DeclaredElement { get; }
    public TreeNodeCollection`1<ICSharpTypeMemberDeclaration> MemberDeclarations { get; }
    public IEnumerable`1<ICSharpHashableDeclaration> Children { get; }
    public int LevelDelta { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual ITypeElement get_DeclaredElement();
    public abstract virtual TreeNodeCollection`1<ICSharpTypeMemberDeclaration> get_MemberDeclarations();
    public sealed virtual IClassLikeDeclaration GetContainingClassLikeDeclaration();
    public virtual IEnumerable`1<ICSharpHashableDeclaration> get_Children();
    private static bool CanSkip(ICSharpTypeMemberDeclaration member);
    public virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public virtual int get_LevelDelta();
    [CompilerGeneratedAttribute]
private bool <get_Children>g__CanSkipPrivateMembers|6_1();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MethodDeclaration : MethodDeclarationStub {
    [CanBeNullAttribute]
public virtual IBlock SetBody(IBlock block);
    [CanBeNullAttribute]
public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    protected virtual Hash CalculateHashInternal();
    public virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MethodDeclarationStub : ProperTypeMemberDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short CSHARP_TYPE;
    public static short CSHARP_QUALIFIER;
    public static short CSHARP_NAME;
    public static short TYPE_PARAMETERS_LIST;
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public static short CONSTRAINTS;
    public static short CSHARP_BLOCK;
    public static short ARROW_CLAUSE;
    public static short CSHARP_SEMICOLON;
    private IOwnerQualification myCachedInterfaceQualification;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedInterfaceQualificationValid;
    private TreeNodeCollection`1<ICSharpParameterDeclaration> myCachedParameterDeclarations;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedParameterDeclarationsValid;
    [CanBeNullAttribute]
private String modreq(System.Runtime.CompilerServices.IsVolatile) myCachedName;
    public NodeType NodeType { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public IBlock Body { get; }
    public IOwnerQualification InterfaceQualification { get; }
    protected IOwnerQualification _InterfaceQualification { get; }
    public ITokenNode LPar { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfMethodList TypeParameterList { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IReferenceName InterfaceQualificationReference { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    protected TreeNodeCollection`1<ICSharpParameterDeclaration> _ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IMethod JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public bool IsPartial { get; }
    public ReferenceKind ReturnKind { get; }
    public int LevelDelta { get; }
    public IType Type { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsExtensionMethod { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IAttributeSectionList get_AttributeSectionList();
    public virtual IBlock get_Body();
    public sealed virtual IOwnerQualification get_InterfaceQualification();
    protected virtual IOwnerQualification get__InterfaceQualification();
    public virtual ITokenNode get_LPar();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IFormalParameterList get_Params();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Semicolon();
    public virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public virtual ITypeParameterOfMethodList get_TypeParameterList();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IReferenceName get_InterfaceQualificationReference();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public sealed virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    protected virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get__ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public virtual IBlock SetBody(IBlock param);
    public virtual IOwnerQualification SetInterfaceQualification(IOwnerQualification param);
    public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IFormalParameterList SetParams(IFormalParameterList param);
    public virtual ITypeParameterOfMethodList SetTypeParameterList(ITypeParameterOfMethodList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    protected virtual void ClearCachedData();
    public virtual string get_DeclaredName();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IMethod JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual bool get_IsPartial();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual void SetPartial(bool isPartial);
    public sealed virtual void SetAsync(bool isAsync);
    public sealed virtual void SetReturnKind(ReferenceKind returnKind);
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual int get_LevelDelta();
    public virtual string ToString();
    [NotNullAttribute]
public static string ToString(string name, ICSharpDeclaration declaration, TreeNodeEnumerable`1<ICSharpParameterDeclaration> parameters);
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public sealed virtual ITypeParameterOfMethodDeclaration AddTypeParameterBefore(ITypeParameterOfMethodDeclaration param, ITypeParameterOfMethodDeclaration anchor);
    public sealed virtual ITypeParameterOfMethodDeclaration AddTypeParameterAfter(ITypeParameterOfMethodDeclaration param, ITypeParameterOfMethodDeclaration anchor);
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfMethodDeclaration param);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause param, ITypeParameterConstraintsClause anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause param, ITypeParameterConstraintsClause anchor);
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsync();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    protected virtual bool HasExecutableCodeBody();
    public virtual bool IsSemanticallyAbstract();
    public virtual bool IsSemanticallyVirtual();
    public virtual bool IsSemanticallyPrivate();
    public sealed virtual bool get_IsExtensionMethod();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MissingDesignation : CSharpCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ModifiersList : CSharpCompositeElement {
    public static short MODIFIER;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Modifiers { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Modifiers();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersEnumerable();
    public virtual string ToString();
    public sealed virtual ITokenNode AddModifier(ITokenNode modifier);
    public sealed virtual void RemoveModifier(ITokenNode modifier);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MoveNextReferenceBase`1 : ForeachReferenceBase`1<TForeachReferencesOwner> {
    protected MoveNextReferenceBase`1(TForeachReferencesOwner owner);
    public virtual string GetName();
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MultipleConstantDeclaration : CSharpCompositeElement {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short KEYWORD;
    public static short CSHARP_TYPE;
    public static short DECLARATOR;
    public static short CSHARP_COMMA;
    public static short CSHARP_SEMICOLON;
    private TreeNodeCollection`1<IConstantDeclaration> myCachedDeclarators;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDeclaratorsValid;
    public NodeType NodeType { get; }
    public IAttributeSectionList Attributes { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ConstKeyword { get; }
    public TreeNodeCollection`1<IMultipleDeclarationMember> Declarators { get; }
    public TreeNodeEnumerable`1<IMultipleDeclarationMember> DeclaratorsEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode Semicolon { get; }
    public ITypeUsage TypeUsage { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_Attributes();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_ConstKeyword();
    public virtual TreeNodeCollection`1<IMultipleDeclarationMember> get_Declarators();
    public virtual TreeNodeEnumerable`1<IMultipleDeclarationMember> get_DeclaratorsEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual ITokenNode get_Semicolon();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IAttributeSectionList SetAttributes(IAttributeSectionList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual TDeclarationMember AddDeclaratorBefore(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual TDeclarationMember AddDeclaratorAfter(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual void RemoveDeclarator(IMultipleDeclarationMember declarationMember);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MultipleEventDeclaration : CSharpCompositeElement {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short KEYWORD;
    public static short CSHARP_TYPE;
    public static short DECLARATOR;
    public static short CSHARP_COMMA;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IAttributeSectionList Attributes { get; }
    public TreeNodeCollection`1<ITokenNode> Commas { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommasEnumerable { get; }
    public TreeNodeCollection`1<IMultipleDeclarationMember> Declarators { get; }
    public TreeNodeEnumerable`1<IMultipleDeclarationMember> DeclaratorsEnumerable { get; }
    public ITokenNode EventKeyword { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode Semicolon { get; }
    public ITypeUsage TypeUsage { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_Attributes();
    public virtual TreeNodeCollection`1<ITokenNode> get_Commas();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommasEnumerable();
    public virtual TreeNodeCollection`1<IMultipleDeclarationMember> get_Declarators();
    public virtual TreeNodeEnumerable`1<IMultipleDeclarationMember> get_DeclaratorsEnumerable();
    public virtual ITokenNode get_EventKeyword();
    public virtual IModifiersList get_ModifiersList();
    public virtual ITokenNode get_Semicolon();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IAttributeSectionList SetAttributes(IAttributeSectionList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual TDeclarationMember AddDeclaratorBefore(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual TDeclarationMember AddDeclaratorAfter(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual void RemoveDeclarator(IMultipleDeclarationMember declarationMember);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MultipleFieldDeclaration : CSharpCompositeElement {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short CSHARP_TYPE;
    public static short DECLARATOR;
    public static short CSHARP_COMMA;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IAttributeSectionList Attributes { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IMultipleDeclarationMember> Declarators { get; }
    public TreeNodeEnumerable`1<IMultipleDeclarationMember> DeclaratorsEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode Semicolon { get; }
    public ITypeUsage TypeUsage { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    private TreeNodeCollection`1<IMultipleDeclarationMember> JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleDeclaration.Declarators { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_Attributes();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IMultipleDeclarationMember> get_Declarators();
    public virtual TreeNodeEnumerable`1<IMultipleDeclarationMember> get_DeclaratorsEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual ITokenNode get_Semicolon();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IAttributeSectionList SetAttributes(IAttributeSectionList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual TDeclarationMember AddDeclaratorBefore(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual TDeclarationMember AddDeclaratorAfter(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual void RemoveDeclarator(IMultipleDeclarationMember declarationMember);
    private sealed virtual override TreeNodeCollection`1<IMultipleDeclarationMember> JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleDeclaration.get_Declarators();
    public sealed virtual bool get_IsRequired();
    public sealed virtual void SetRequired(bool value);
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual void SetReferenceKind(ReferenceKind referenceKind);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MultipleLocalConstantDeclaration : CSharpCompositeElement {
    public static short KEYWORD;
    public static short SCOPED_KEYWORD;
    public static short CSHARP_TYPE;
    public static short DECLARATOR;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ConstKeyword { get; }
    public TreeNodeCollection`1<IMultipleDeclarationMember> Declarators { get; }
    public TreeNodeEnumerable`1<IMultipleDeclarationMember> DeclaratorsEnumerable { get; }
    public ITokenNode ScopedKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_ConstKeyword();
    public virtual TreeNodeCollection`1<IMultipleDeclarationMember> get_Declarators();
    public virtual TreeNodeEnumerable`1<IMultipleDeclarationMember> get_DeclaratorsEnumerable();
    public virtual ITokenNode get_ScopedKeyword();
    public virtual ITypeUsage get_TypeUsage();
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public sealed virtual TDeclarationMember AddDeclaratorBefore(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual TDeclarationMember AddDeclaratorAfter(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual void RemoveDeclarator(IMultipleDeclarationMember declarationMember);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MultipleLocalVariableDeclaration : CSharpCompositeElement {
    public static short AWAIT;
    public static short CSHARP_KEYWORD;
    public static short SCOPED_KEYWORD;
    public static short BYREF;
    public static short READONLY;
    public static short VAR_KEYWORD;
    public static short CSHARP_TYPE;
    public static short DECLARATOR;
    public static short CSHARP_COMMA;
    private MyDisposeMethodReference myDisposeMethodReference;
    private MyGetAwaiterReference myGetAwaiterReference;
    private MyAwaiterGetResultReference myAwaiterGetResultReference;
    private MyAwaiterOnCompletedReference myAwaiterOnCompletedReference;
    private MyAwaiterIsCompletedReference myAwaiterIsCompletedReference;
    public NodeType NodeType { get; }
    public ITokenNode AwaitKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IMultipleDeclarationMember> Declarators { get; }
    public TreeNodeEnumerable`1<IMultipleDeclarationMember> DeclaratorsEnumerable { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode RefReadonlyKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> ScopedKeywords { get; }
    public TreeNodeEnumerable`1<ITokenNode> ScopedKeywordsEnumerable { get; }
    public ITypeUsage TypeUsage { get; }
    public ITokenNode UsingKeyword { get; }
    public ITokenNode VarKeyword { get; }
    public IDisposeMethodReference DisposeReference { get; }
    public IManagedReference GetAwaiterReference { get; }
    public IManagedReference AwaiterGetResultReference { get; }
    public IManagedReference AwaiterOnCompletedReference { get; }
    public IManagedReference AwaiterIsCompletedReference { get; }
    public ITreeNode TypeDesignator { get; }
    public bool IsVar { get; }
    public TreeTextRange UsingRange { get; }
    public TreeTextRange AwaitRange { get; }
    public UsingDeclarationKind UsingKind { get; }
    public ReferenceKind ReferenceKind { get; }
    private bool IsUsing { get; }
    public bool IsAwait { get; }
    private bool IsWellFormedAwaitConstruct { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AwaitKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IMultipleDeclarationMember> get_Declarators();
    public virtual TreeNodeEnumerable`1<IMultipleDeclarationMember> get_DeclaratorsEnumerable();
    public virtual ITokenNode get_RefKeyword();
    public virtual ITokenNode get_RefReadonlyKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_ScopedKeywords();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ScopedKeywordsEnumerable();
    public virtual ITypeUsage get_TypeUsage();
    public virtual ITokenNode get_UsingKeyword();
    public virtual ITokenNode get_VarKeyword();
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IDisposeMethodReference get_DisposeReference();
    public sealed virtual IManagedReference get_GetAwaiterReference();
    public sealed virtual IManagedReference get_AwaiterGetResultReference();
    public sealed virtual IManagedReference get_AwaiterOnCompletedReference();
    public sealed virtual IManagedReference get_AwaiterIsCompletedReference();
    public sealed virtual DocumentRange GetTypeRange();
    public sealed virtual ITreeNode get_TypeDesignator();
    public sealed virtual bool get_IsVar();
    public sealed virtual void SetVar();
    public sealed virtual TreeTextRange get_UsingRange();
    public sealed virtual TreeTextRange get_AwaitRange();
    public sealed virtual UsingDeclarationKind get_UsingKind();
    public sealed virtual ReferenceKind get_ReferenceKind();
    private bool get_IsUsing();
    public sealed virtual bool get_IsAwait();
    public sealed virtual void SetUsingKind(UsingDeclarationKind kind);
    public sealed virtual void SetReferenceKind(ReferenceKind kind);
    public sealed virtual void SetScoped(bool addScopedKeyword);
    public sealed virtual TDeclarationMember AddDeclaratorBefore(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual TDeclarationMember AddDeclaratorAfter(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public sealed virtual void RemoveDeclarator(IMultipleDeclarationMember declarationMember);
    private bool get_IsWellFormedAwaitConstruct();
    [CompilerGeneratedAttribute]
private void <SetUsingKind>g__SetUsing|77_0(bool isUsing);
    [CompilerGeneratedAttribute]
private void <SetUsingKind>g__SetAwait|77_1(bool isAwait);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.MultiplicativeExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.NamespaceBody : CSharpCompositeElement {
    public static short CSHARP_LBRACE;
    public static short IMPORTS_LIST;
    public static short NAMESPACE;
    public static short TYPE;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public IUsingList ImportsList { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<ICSharpNamespaceDeclaration> NamespaceDeclarationNodes { get; }
    public TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> NamespaceDeclarationNodesEnumerable { get; }
    public ITokenNode RBrace { get; }
    public ICSharpNamespaceDeclaration NamespaceDeclaration { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IUsingList get_ImportsList();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationNodes();
    public virtual TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationNodesEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual ICSharpNamespaceDeclaration get_NamespaceDeclaration();
    public virtual IUsingList SetImportsList(IUsingList param);
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.NegatedPattern : CSharpCompositeElement {
    public static short NOT_KEYWORD;
    public static short PATTERN;
    public NodeType NodeType { get; }
    public ITokenNode NotKeyword { get; }
    public IPattern Pattern { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_NotKeyword();
    public virtual IPattern get_Pattern();
    public virtual IPattern SetPattern(IPattern param);
    public virtual string ToString();
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.NewLine : WhitespaceBase {
    public NodeType NodeType { get; }
    public bool IsNewLine { get; }
    public NewLine(string text);
    public virtual NodeType get_NodeType();
    public virtual bool get_IsNewLine();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.NullableDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short SETTING;
    public static short TARGET;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode NumberSign { get; }
    public ITokenNode Setting { get; }
    public ITokenNode Target { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public Nullable`1<NullableDirectiveSettingKind> SettingKind { get; }
    public Nullable`1<NullableDirectiveTargetKind> TargetKind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_NumberSign();
    public virtual ITokenNode get_Setting();
    public virtual ITokenNode get_Target();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
    public sealed virtual Nullable`1<NullableDirectiveSettingKind> get_SettingKind();
    public sealed virtual Nullable`1<NullableDirectiveTargetKind> get_TargetKind();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.NullableTypeMark : CSharpCompositeElement {
    public static short KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode Quest { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Quest();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.NullableTypeUsage : CSharpCompositeElement {
    public static short ELEMENT_TYPE;
    public static short NULLABLE;
    public NodeType NodeType { get; }
    public INullableTypeMark NullableMark { get; }
    public ITypeUsage UnderlyingType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual INullableTypeMark get_NullableMark();
    public virtual ITypeUsage get_UnderlyingType();
    public virtual INullableTypeMark SetNullableMark(INullableTypeMark param);
    public virtual ITypeUsage SetUnderlyingType(ITypeUsage param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.NullCoalescingExpression : CSharpExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    public IList`1<ICSharpExpression> OperatorOperands { get; }
    public IOperatorReference OperatorReference { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public IManagedReference Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public virtual ICSharpExpression get_RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual IList`1<ICSharpExpression> get_OperatorOperands();
    public sealed virtual IOperatorReference get_OperatorReference();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
private ICSharpArgumentInfo[] GetArguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ObjectCreationExpression : ObjectCreationExpressionStub {
    [CanBeNullAttribute]
public virtual ICreationExpressionInitializer SetInitializer(ICreationExpressionInitializer param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage typeUsage);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ObjectCreationExpressionStub : CSharpExpressionBase {
    public static short KEYWORD;
    public static short CSHARP_TYPE;
    public static short CSHARP_LPAR;
    public static short ARGUMENT_LIST;
    public static short CSHARP_RPAR;
    public static short CSHARP_INITIALIZER;
    private ConstructorReference myConstructorReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public ICreationExpressionInitializer Initializer { get; }
    public ITokenNode LPar { get; }
    public ITokenNode NewKeyword { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public IReference TypeReference { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public IReferenceName TypeName { get; }
    public IReference ConstructorReference { get; }
    public IManagedReference Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual ICreationExpressionInitializer get_Initializer();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_NewKeyword();
    public virtual ITokenNode get_RPar();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual ICreationExpressionInitializer SetInitializer(ICreationExpressionInitializer param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    [NotNullAttribute]
private IType TypeFromTypeUsage(ITypeUsage typeUsage);
    public virtual IType Type(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public sealed virtual IReference get_TypeReference();
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IReferenceName get_TypeName();
    public sealed virtual IReference get_ConstructorReference();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual IList`1<ITokenNode> get_Delimiters();
    public sealed virtual ITokenNode get_LBound();
    public sealed virtual ITokenNode get_RBound();
    public sealed virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    public sealed virtual void RemoveArgument(ICSharpArgument argument);
    public sealed virtual IType ExplicitType();
    [CompilerGeneratedAttribute]
internal static IReference <get_TypeReference>g__GetTypeReferenceFromTypeUsage|41_0(ITypeUsage typeUsage);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ObjectInitializer : CreationExpressionInitializerBase {
    public static short CSHARP_LBRACE;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IMemberInitializer> MemberInitializers { get; }
    public TreeNodeEnumerable`1<IMemberInitializer> MemberInitializersEnumerable { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<IInitializerElement> InitializerElements { get; }
    public TreeNodeEnumerable`1<IInitializerElement> InitializerElementsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IMemberInitializer> get_MemberInitializers();
    public virtual TreeNodeEnumerable`1<IMemberInitializer> get_MemberInitializersEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual string ToString();
    public sealed virtual IMemberInitializer AddMemberInitializerAfter(IMemberInitializer memberInitializer, IMemberInitializer anchor);
    public sealed virtual IMemberInitializer AddMemberInitializerBefore(IMemberInitializer memberInitializer, IMemberInitializer anchor);
    public sealed virtual TreeNodeCollection`1<IInitializerElement> get_InitializerElements();
    public sealed virtual TreeNodeEnumerable`1<IInitializerElement> get_InitializerElementsEnumerable();
    public sealed virtual void RemoveMemberInitializer(IMemberInitializer memberInitializer);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.OperatorDeclarationBase : ProperTypeMemberDeclarationBase {
    [NotNullAttribute]
public IType Type { get; }
    public bool IsAbstract { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    [CanBeNullAttribute]
public IDocCommentBlock DocCommentBlock { get; }
    public bool IsAsync { get; }
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public virtual bool get_IsAbstract();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual bool get_IsAsync();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.OrderByReference : QueryChainReferenceBase`1<QueryOrderByClause> {
    private static string ORDERBY;
    private static string THENBY;
    private static string ORDERBY_DESCENDING;
    private static string THENBY_DESCENDING;
    [NotNullAttribute]
private QueryOrdering myOrdering;
    public OrderByReference(QueryOrdering ordering);
    public virtual ICSharpArgumentInfo[] GetArguments();
    public virtual string GetName();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.OrPattern : CSharpCompositeElement {
    public static short PATTERN_OP1;
    public static short OR_KEYWORD;
    public static short PATTERN_OP2;
    public NodeType NodeType { get; }
    public IPattern LeftPattern { get; }
    public ITokenNode OrKeyword { get; }
    public IPattern RightPattern { get; }
    private ITokenNode JetBrains.ReSharper.Psi.CSharp.Tree.IBinaryPattern.Keyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPattern get_LeftPattern();
    public virtual ITokenNode get_OrKeyword();
    public virtual IPattern get_RightPattern();
    public virtual IPattern SetLeftPattern(IPattern param);
    public virtual IPattern SetRightPattern(IPattern param);
    public virtual string ToString();
    private sealed virtual override ITokenNode JetBrains.ReSharper.Psi.CSharp.Tree.IBinaryPattern.get_Keyword();
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
private void <GetPatternType>g__CollectCandidates|21_1(IPattern pattern, List`1<IType> candidates, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
private IType <GetPatternType>g__LeastSpecificType|21_2(List`1<IType> candidates, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
private IType <GetPatternType>g__LessSpecificCandidate|21_3(IType bestSoFar, IType possiblyLessSpecificCandidate, <>c__DisplayClass21_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.OwnerQualification : CSharpCompositeElement {
    public static short QUALIFIER;
    public static short CSHARP_REFERENCE_DELIMITER;
    public NodeType NodeType { get; }
    public ITokenNode Dot { get; }
    public IReferenceName Qualifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Dot();
    public virtual IReferenceName get_Qualifier();
    public virtual IReferenceName SetQualifier(IReferenceName param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParameterModifiersList : CSharpCompositeElement {
    public static short MODIFIER;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Modifiers { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Modifiers();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersEnumerable();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParamsAddReferenceBase`1 : AddReferenceBase`1<T> {
    protected ParamsAddReferenceBase`1(T owner);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    protected virtual bool IsIgnored(IResolveContext resolveContext, IType paramsCollectionType);
    protected IType GetParamsCollectionType(IResolveContext resolveContext);
    public abstract virtual IParameter GetParamsParameter(IResolveContext resolveContext);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParamsAddReferenceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IParameter GetParamsParameter(IParamsAddReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParamsCreateMethodReferenceBase`1 : CreateMethodReferenceBase`1<T> {
    protected ParamsCreateMethodReferenceBase`1(T owner);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    protected virtual IType GetTargetType(IResolveContext resolveContext);
    public abstract virtual IParameter GetParamsParameter(IResolveContext resolveContext);
    protected virtual bool IsIgnored(IResolveContext resolveContext, IType paramsCollectionType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParamsCreateMethodReferenceExtension : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IParameter GetParamsParameter(IParamsCreateMethodReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParamsDefaultConstructorReferenceBase`1 : DefaultConstructorReferenceBase`1<T> {
    protected ParamsDefaultConstructorReferenceBase`1(T owner);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    protected virtual bool IsIgnored(IResolveContext resolveContext, IType paramsCollectionType);
    private IDeclaredType GetParamsCollectionType(IResolveContext resolveContext);
    public abstract virtual IParameter GetParamsParameter(IResolveContext resolveContext);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParamsDefaultConstructorReferenceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IParameter GetParamsParameter(IParamsDefaultConstructorReference reference);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParenthesizedExpression : CSharpExpressionBase {
    public static short CSHARP_LPAR;
    public static short OP;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParenthesizedPattern : CSharpCompositeElement {
    public static short CSHARP_LPAR;
    public static short PATTERN;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public IPattern Pattern { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual IPattern get_Pattern();
    public virtual ITokenNode get_RPar();
    public virtual IPattern SetPattern(IPattern param);
    public virtual string ToString();
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ParenthesizedVariableDesignation : CSharpCompositeElement {
    public static short CSHARP_LPAR;
    public static short DESIGNATION;
    public static short CSHARP_COMMA;
    public static short CSHARP_RPAR;
    private ParenthesizedVariableDesignationDeconstructionReference myDeconstructionReference;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IVariableDesignation> ChildrenDesignations { get; }
    public TreeNodeEnumerable`1<IVariableDesignation> ChildrenDesignationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public IDeconstructionReference DeconstructionReference { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    [NotNullAttribute]
public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IType> TypeArguments { get; }
    public ICSharpInvocationReference Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IVariableDesignation> get_ChildrenDesignations();
    public virtual TreeNodeEnumerable`1<IVariableDesignation> get_ChildrenDesignationsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IDeconstructionReference get_DeconstructionReference();
    public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    public sealed virtual int IndexOfDesignation(IVariableDesignation designation);
    public sealed virtual TVariableDesignation AddDesignationAfter(TVariableDesignation designation, IVariableDesignation anchor);
    public sealed virtual TVariableDesignation AddDesignationBefore(TVariableDesignation designation, IVariableDesignation anchor);
    public sealed virtual void RemoveDesignation(IVariableDesignation designation);
    public sealed virtual IType GetDesignationType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IExpressionType GetDesignationExpressionType(IVariableDesignation designation, IResolveContext resolveContext);
    private sealed virtual override ReferenceCollection JetBrains.ReSharper.Psi.Tree.ITreeNode.GetFirstClassReferences();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IType> get_TypeArguments();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual CSharpLanguageLevel GetLatestSupportedLanguageVersion();
    public sealed virtual string Dump();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PatternGuardClause : CSharpCompositeElement {
    public static short WHEN_KEYWORD;
    public static short CSHARP_CONDITION;
    public NodeType NodeType { get; }
    public ICSharpExpression Condition { get; }
    public ITokenNode WhenKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Condition();
    public virtual ITokenNode get_WhenKeyword();
    public virtual ICSharpExpression SetCondition(ICSharpExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PointerTypeUsage : CSharpCompositeElement {
    public static short ELEMENT_TYPE;
    public static short POINTER;
    public NodeType NodeType { get; }
    public ITypeUsage ElementType { get; }
    public TreeNodeCollection`1<IUnsafeCodePointer> PointerMarks { get; }
    public TreeNodeEnumerable`1<IUnsafeCodePointer> PointerMarksEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITypeUsage get_ElementType();
    public virtual TreeNodeCollection`1<IUnsafeCodePointer> get_PointerMarks();
    public virtual TreeNodeEnumerable`1<IUnsafeCodePointer> get_PointerMarksEnumerable();
    public virtual ITypeUsage SetElementType(ITypeUsage param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PostfixOperatorExpression : CSharpExpressionBase {
    public static short OPERAND;
    public static short OPERATOR;
    private UnaryOperatorReference myReference;
    public NodeType NodeType { get; }
    public IPrimaryExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    [NotNullAttribute]
private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    [NotNullAttribute]
public IOperatorReference OperatorReference { get; }
    public IList`1<ICSharpExpression> OperatorOperands { get; }
    public PostfixOperatorType PostfixOperatorType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPrimaryExpression get_Operand();
    public virtual ITokenNode get_OperatorSign();
    public virtual IPrimaryExpression SetOperand(IPrimaryExpression param);
    public virtual string ToString();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
private ICSharpArgumentInfo[] GetArguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IOperatorReference get_OperatorReference();
    public sealed virtual IList`1<ICSharpExpression> get_OperatorOperands();
    protected virtual void PreInit();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual PostfixOperatorType get_PostfixOperatorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PragmaDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short MESSAGE;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode Message { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_Message();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PredefinedDeclaredTypeUsage : object {
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PredefinedTypeExpression : CSharpExpressionBase {
    public static short CSHARP_REFERENCE;
    public NodeType NodeType { get; }
    public IPredefinedTypeReference PredefinedTypeName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPredefinedTypeReference get_PredefinedTypeName();
    public virtual IPredefinedTypeReference SetPredefinedTypeName(IPredefinedTypeReference param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PredefinedTypeReference : CSharpCompositeElement {
    public static short KEYWORD;
    private LocalUserDataHolder myUserDataHolder;
    public NodeType NodeType { get; }
    public ITokenNode TypeKeyword { get; }
    public IReference Reference { get; }
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    public bool HasMultipleNames { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_TypeKeyword();
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T val);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public sealed virtual IReference get_Reference();
    public sealed virtual ResolveResultWithInfo get_CurrentResolveResult();
    public sealed virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ITreeNode GetTreeNode();
    public sealed virtual string GetName();
    public sealed virtual bool get_HasMultipleNames();
    public sealed virtual HybridCollection`1<string> GetAllNames();
    public sealed virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public sealed virtual ResolveResultWithInfo Resolve();
    public sealed virtual IReference BindTo(IDeclaredElement element);
    public sealed virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual IAccessContext GetAccessContext();
    private sealed virtual override TreeTextRange JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeTextRange();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PredefinedTypeUsage : CSharpCompositeElement {
    public static short CSHARP_REFERENCE;
    public NodeType NodeType { get; }
    public IPredefinedTypeReference ScalarPredefinedTypeName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPredefinedTypeReference get_ScalarPredefinedTypeName();
    public virtual IPredefinedTypeReference SetScalarPredefinedTypeName(IPredefinedTypeReference param);
    public sealed virtual ITypeUsage ReplaceBy(ITypeUsage typeUsage);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PrefixOperatorExpression : CSharpExpressionBase {
    public static short OP_SIGN;
    public static short OP;
    private UnaryOperatorReference myReference;
    public NodeType NodeType { get; }
    public IUnaryExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    [NotNullAttribute]
private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    [NotNullAttribute]
public IOperatorReference OperatorReference { get; }
    public IList`1<ICSharpExpression> OperatorOperands { get; }
    public PrefixOperatorType PrefixOperatorType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IUnaryExpression get_Operand();
    public virtual ITokenNode get_OperatorSign();
    public virtual IUnaryExpression SetOperand(IUnaryExpression param);
    public virtual string ToString();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
private ICSharpArgumentInfo[] GetArguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IOperatorReference get_OperatorReference();
    public sealed virtual IList`1<ICSharpExpression> get_OperatorOperands();
    protected virtual void PreInit();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual PrefixOperatorType get_PrefixOperatorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PreprocessorAndExpression : CSharpCompositeElement {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    public NodeType NodeType { get; }
    public IPreprocessorExpression LeftOperand { get; }
    public ITokenNode OpSign { get; }
    public IPreprocessorExpression RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPreprocessorExpression get_LeftOperand();
    public virtual ITokenNode get_OpSign();
    public virtual IPreprocessorExpression get_RightOperand();
    public virtual IPreprocessorExpression SetLeftOperand(IPreprocessorExpression param);
    public virtual IPreprocessorExpression SetRightOperand(IPreprocessorExpression param);
    public virtual string ToString();
    public virtual bool IsFiltered();
    [CanBeNullAttribute]
[PureAttribute]
private TreeElement GetNextFilteredChild(ITreeNode child);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PreprocessorConditionalSymbol : CSharpCompositeElement {
    public static short CSHARP_NAME;
    public NodeType NodeType { get; }
    public ITokenNode NameIdentifier { get; }
    public string Name { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_NameIdentifier();
    public virtual string ToString();
    public sealed virtual string get_Name();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PreprocessorEqualityExpression : CSharpCompositeElement {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    public NodeType NodeType { get; }
    public IPreprocessorExpression LeftOperand { get; }
    public ITokenNode OpSign { get; }
    public IPreprocessorExpression RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPreprocessorExpression get_LeftOperand();
    public virtual ITokenNode get_OpSign();
    public virtual IPreprocessorExpression get_RightOperand();
    public virtual IPreprocessorExpression SetLeftOperand(IPreprocessorExpression param);
    public virtual IPreprocessorExpression SetRightOperand(IPreprocessorExpression param);
    public virtual string ToString();
    public virtual bool IsFiltered();
    [CanBeNullAttribute]
[PureAttribute]
private TreeElement GetNextFilteredChild(ITreeNode child);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PreprocessorNegation : CSharpCompositeElement {
    public static short OP_SIGN;
    public static short CSHARP_OP1;
    public NodeType NodeType { get; }
    public ITokenNode OpSign { get; }
    public IPreprocessorUnaryExpression Operand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_OpSign();
    public virtual IPreprocessorUnaryExpression get_Operand();
    public virtual IPreprocessorUnaryExpression SetOperand(IPreprocessorUnaryExpression param);
    public virtual string ToString();
    public virtual bool IsFiltered();
    [CanBeNullAttribute]
[PureAttribute]
private TreeElement GetNextFilteredChild(ITreeNode child);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PreprocessorOrExpression : CSharpCompositeElement {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    public NodeType NodeType { get; }
    public IPreprocessorExpression LeftOperand { get; }
    public ITokenNode OpSign { get; }
    public IPreprocessorExpression RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPreprocessorExpression get_LeftOperand();
    public virtual ITokenNode get_OpSign();
    public virtual IPreprocessorExpression get_RightOperand();
    public virtual IPreprocessorExpression SetLeftOperand(IPreprocessorExpression param);
    public virtual IPreprocessorExpression SetRightOperand(IPreprocessorExpression param);
    public virtual string ToString();
    public virtual bool IsFiltered();
    [CanBeNullAttribute]
[PureAttribute]
private TreeElement GetNextFilteredChild(ITreeNode child);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PreprocessorParenthesizedExpression : CSharpCompositeElement {
    public static short CSHARP_LPAR;
    public static short CSHARP_OP1;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public IPreprocessorExpression Operand { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual IPreprocessorExpression get_Operand();
    public virtual ITokenNode get_RPar();
    public virtual IPreprocessorExpression SetOperand(IPreprocessorExpression param);
    public virtual string ToString();
    public virtual bool IsFiltered();
    [CanBeNullAttribute]
[PureAttribute]
private TreeElement GetNextFilteredChild(ITreeNode child);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PreprocessorPragmaBody : CSharpCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PrimaryConstructorDeclaration : ProperTypeMemberDeclarationBase {
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public IModifiersOwner ModifiersOwner { get; }
    public IModifiersList ModifiersList { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IPrimaryConstructor JetBrains.ReSharper.Psi.CSharp.Tree.IPrimaryConstructorDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    public IParametersOwner DeclaredParametersOwner { get; }
    public string DeclaredName { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual IFormalParameterList get_Params();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IFormalParameterList SetParams(IFormalParameterList param);
    public virtual string ToString();
    public virtual TreeTextRange GetNameRange();
    public virtual void SetName(string name);
    public virtual bool IsSynthetic();
    public sealed virtual IModifiersOwner get_ModifiersOwner();
    public sealed virtual IModifiersList get_ModifiersList();
    public sealed virtual IModifiersList SetModifiersList(IModifiersList param);
    protected virtual IDeclaredElement CreateDeclaredElement();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IPrimaryConstructor JetBrains.ReSharper.Psi.CSharp.Tree.IPrimaryConstructorDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    public sealed virtual IParametersOwner get_DeclaredParametersOwner();
    public virtual string get_DeclaredName();
    protected internal virtual string GetShortNameOfDeclaredElement();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PrimaryConstructorDeclaration/<EnumerateAttributes>d__50")]
private IEnumerable`1<IAttribute> EnumerateAttributes();
    public sealed virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public sealed virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    protected virtual Hash CalculateHashInternal();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PropertyAssignment : CSharpCompositeElement {
    public static short CSHARP_REFERENCE;
    public static short CSHARP_EQ;
    public static short CSHARP_OP2;
    private PropertyAssignmentReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode Operator { get; }
    public ICSharpIdentifier PropertyNameIdentifier { get; }
    public ICSharpExpression Source { get; }
    public IReference Reference { get; }
    public IAttribute ContainingAttribute { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Operator();
    public virtual ICSharpIdentifier get_PropertyNameIdentifier();
    public virtual ICSharpExpression get_Source();
    public virtual ICSharpIdentifier SetPropertyNameIdentifier(ICSharpIdentifier param);
    public virtual ICSharpExpression SetSource(ICSharpExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IReference get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IAttribute get_ContainingAttribute();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public sealed virtual IType GetConstructedType(IResolveContext resolveContext);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual void SetName(string name);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PropertyDeclaration : PropertyDeclarationStub {
    private CachedPsiValue`1<FieldKeywordPresenceFlags> myHasFieldKeywordReference;
    private FieldKeywordPresenceFlags FieldKeywordPresence { get; }
    public bool HasBackingFieldReference { get; }
    protected virtual IDeclaredElement CreateDeclaredElement();
    protected virtual void PreInit();
    private FieldKeywordPresenceFlags get_FieldKeywordPresence();
    public virtual bool get_HasBackingFieldReference();
    public virtual bool HasBackingFieldReferenceIn(AccessorKind accessorKind);
    [CanBeNullAttribute]
public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    [CanBeNullAttribute]
public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PropertyDeclarationStub : ProperTypeMemberDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short CSHARP_TYPE;
    public static short CSHARP_QUALIFIER;
    public static short CSHARP_NAME;
    public static short CSHARP_LBRACE;
    public static short ACCESSOR_DECL;
    public static short CSHARP_RBRACE;
    public static short CSHARP_EQ;
    public static short CSHARP_INITIALIZER;
    public static short CSHARP_SEMICOLON;
    public static short ARROW_CLAUSE;
    private IOwnerQualification myCachedInterfaceQualification;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedInterfaceQualificationValid;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IAccessorDeclaration> AccessorDeclarations { get; }
    public TreeNodeEnumerable`1<IAccessorDeclaration> AccessorDeclarationsEnumerable { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public ITokenNode EquivalenceSign { get; }
    public IVariableInitializer Initial { get; }
    public IOwnerQualification InterfaceQualification { get; }
    protected IOwnerQualification _InterfaceQualification { get; }
    public ITokenNode LBrace { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode Semicolon { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IReferenceName InterfaceQualificationReference { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsAuto { get; }
    public bool HasBackingFieldReference { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsRequired { get; }
    public IType Type { get; }
    public string DeclaredName { get; }
    private IProperty JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration.DeclaredElement { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    public ITreeNode Initializer { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IAccessorDeclaration> get_AccessorDeclarations();
    public virtual TreeNodeEnumerable`1<IAccessorDeclaration> get_AccessorDeclarationsEnumerable();
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual ITokenNode get_EquivalenceSign();
    public virtual IVariableInitializer get_Initial();
    public sealed virtual IOwnerQualification get_InterfaceQualification();
    protected virtual IOwnerQualification get__InterfaceQualification();
    public virtual ITokenNode get_LBrace();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_RBrace();
    public virtual ITokenNode get_Semicolon();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IReferenceName get_InterfaceQualificationReference();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual IOwnerQualification SetInterfaceQualification(IOwnerQualification param);
    public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationAfter(IAccessorDeclaration accessorDeclaration, IAccessorDeclaration anchor);
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationBefore(IAccessorDeclaration accessorDeclaration, IAccessorDeclaration anchor);
    public sealed virtual void RemoveAccessorDeclaration(IAccessorDeclaration accessorDeclaration);
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    protected virtual bool HasExecutableCodeBody();
    public virtual bool IsSemanticallyAbstract();
    public virtual bool IsSemanticallyVirtual();
    public sealed virtual bool get_IsAuto();
    public abstract virtual bool get_HasBackingFieldReference();
    public abstract virtual bool HasBackingFieldReferenceIn(AccessorKind accessorKind);
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual bool get_IsRequired();
    public sealed virtual void SetRequired(bool value);
    public sealed virtual void SetReturnKind(ReferenceKind returnKind);
    public sealed virtual IType get_Type();
    public sealed virtual void SetType(IType type);
    public virtual string get_DeclaredName();
    private sealed virtual override IProperty JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration.get_DeclaredElement();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    public sealed virtual ITreeNode get_Initializer();
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PropertyInitializer : MemberInitializerBase {
    public static short CSHARP_REFERENCE;
    public static short CSHARP_EQ;
    public static short CSHARP_OP2;
    public static short CSHARP_INITIALIZER;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    public ICreationExpressionInitializer Initializer { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode Operator { get; }
    public string MemberName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ICreationExpressionInitializer get_Initializer();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_Operator();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual ICreationExpressionInitializer SetInitializer(ICreationExpressionInitializer param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual string get_MemberName();
    public sealed virtual void SetMemberName(string name);
    public sealed virtual void SetName(string name);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PropertyPatternClause : CSharpCompositeElement {
    public static short CSHARP_LBRACE;
    public static short CSHARP_PATTERN;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<ISubpattern> Patterns { get; }
    public TreeNodeEnumerable`1<ISubpattern> PatternsEnumerable { get; }
    public ITokenNode RBrace { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<ISubpattern> get_Patterns();
    public virtual TreeNodeEnumerable`1<ISubpattern> get_PatternsEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual string ToString();
    public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual IType GetSubpatternType(ISubpattern subpattern, IResolveContext resolveContext);
    public sealed virtual ISubpattern AddSubpatternAfter(ISubpattern subpattern, ISubpattern anchor);
    public sealed virtual ISubpattern AddSubpatternBefore(ISubpattern subpattern, ISubpattern anchor);
    public sealed virtual void RemoveSubpattern(ISubpattern subpattern);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ProperTypeMemberDeclarationBase : TypeMemberDeclarationBase {
    private IDeclaredElement modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDeclaredElement;
    public IDeclaredElement DeclaredElement { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.CachedDeclaredElement { get; private set; }
    protected virtual void PreInit();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.get_CachedDeclaredElement();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.set_CachedDeclaredElement(IDeclaredElement value);
    [NotNullAttribute]
protected abstract virtual IDeclaredElement CreateDeclaredElement();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.PsiGeneratedGetterTestUtil : PsiGetterTestUtil {
    internal static void TestAccessorDeclaration(int level, IAccessorDeclaration param, string caller);
    internal static void TestAccessorOwnerDeclaration(int level, IAccessorOwnerDeclaration param, string caller);
    internal static void TestAdditiveExpression(int level, IAdditiveExpression param, string caller);
    internal static void TestAllowsRefStructConstraint(int level, IAllowsRefStructConstraint param, string caller);
    internal static void TestAndPattern(int level, IAndPattern param, string caller);
    internal static void TestAnonymousMemberDeclaration(int level, IAnonymousMemberDeclaration param, string caller);
    internal static void TestAnonymousMethodExpression(int level, IAnonymousMethodExpression param, string caller);
    internal static void TestAnonymousObjectCreationExpression(int level, IAnonymousObjectCreationExpression param, string caller);
    internal static void TestAnonymousObjectInitializer(int level, IAnonymousObjectInitializer param, string caller);
    internal static void TestArglistExpression(int level, IArglistExpression param, string caller);
    internal static void TestArgumentList(int level, IArgumentList param, string caller);
    internal static void TestArrayCreationExpression(int level, IArrayCreationExpression param, string caller);
    internal static void TestArrayInitializer(int level, IArrayInitializer param, string caller);
    internal static void TestArrayTypeUsage(int level, IArrayTypeUsage param, string caller);
    internal static void TestArrowExpressionClause(int level, IArrowExpressionClause param, string caller);
    internal static void TestAsExpression(int level, IAsExpression param, string caller);
    internal static void TestAssignmentExpression(int level, IAssignmentExpression param, string caller);
    internal static void TestAttribute(int level, IAttribute param, string caller);
    internal static void TestAttributeList(int level, IAttributeList param, string caller);
    internal static void TestAttributeSection(int level, IAttributeSection param, string caller);
    internal static void TestAttributeSectionList(int level, IAttributeSectionList param, string caller);
    internal static void TestAttributesOwnerDeclaration(int level, IAttributesOwnerDeclaration param, string caller);
    internal static void TestAwaitExpression(int level, IAwaitExpression param, string caller);
    internal static void TestBaseExpression(int level, IBaseExpression param, string caller);
    internal static void TestBinaryExpression(int level, IBinaryExpression param, string caller);
    internal static void TestBinaryPattern(int level, IBinaryPattern param, string caller);
    internal static void TestBitwiseAndExpression(int level, IBitwiseAndExpression param, string caller);
    internal static void TestBitwiseExclusiveOrExpression(int level, IBitwiseExclusiveOrExpression param, string caller);
    internal static void TestBitwiseInclusiveOrExpression(int level, IBitwiseInclusiveOrExpression param, string caller);
    internal static void TestBlock(int level, IBlock param, string caller);
    internal static void TestBreakStatement(int level, IBreakStatement param, string caller);
    internal static void TestCSharpArgument(int level, ICSharpArgument param, string caller);
    internal static void TestCSharpArgumentsOwner(int level, ICSharpArgumentsOwner param, string caller);
    internal static void TestCSharpDeclaration(int level, ICSharpDeclaration param, string caller);
    internal static void TestCSharpExpression(int level, ICSharpExpression param, string caller);
    internal static void TestCSharpFile(int level, ICSharpFile param, string caller);
    internal static void TestCSharpFunctionDeclaration(int level, ICSharpFunctionDeclaration param, string caller);
    internal static void TestCSharpLiteralExpression(int level, ICSharpLiteralExpression param, string caller);
    internal static void TestCSharpModifiersOwnerDeclaration(int level, ICSharpModifiersOwnerDeclaration param, string caller);
    internal static void TestCSharpNamespaceDeclaration(int level, ICSharpNamespaceDeclaration param, string caller);
    internal static void TestCSharpParameterDeclaration(int level, ICSharpParameterDeclaration param, string caller);
    internal static void TestCSharpParametersOwnerDeclaration(int level, ICSharpParametersOwnerDeclaration param, string caller);
    internal static void TestCSharpRegularParameterDeclaration(int level, ICSharpRegularParameterDeclaration param, string caller);
    internal static void TestCSharpStatement(int level, ICSharpStatement param, string caller);
    internal static void TestCSharpTypeAndNamespaceHolderDeclaration(int level, ICSharpTypeAndNamespaceHolderDeclaration param, string caller);
    internal static void TestCSharpTypeDeclaration(int level, ICSharpTypeDeclaration param, string caller);
    internal static void TestCSharpTypeMemberDeclaration(int level, ICSharpTypeMemberDeclaration param, string caller);
    internal static void TestCastExpression(int level, ICastExpression param, string caller);
    internal static void TestCatchClause(int level, ICatchClause param, string caller);
    internal static void TestCatchVariableDeclaration(int level, ICatchVariableDeclaration param, string caller);
    internal static void TestCheckedExpression(int level, ICheckedExpression param, string caller);
    internal static void TestCheckedStatement(int level, ICheckedStatement param, string caller);
    internal static void TestClassBody(int level, IClassBody param, string caller);
    internal static void TestClassDeclaration(int level, IClassDeclaration param, string caller);
    internal static void TestClassLikeDeclaration(int level, IClassLikeDeclaration param, string caller);
    internal static void TestClassMemberDeclaration(int level, IClassMemberDeclaration param, string caller);
    internal static void TestCollectionElementInitializer(int level, ICollectionElementInitializer param, string caller);
    internal static void TestCollectionExpression(int level, ICollectionExpression param, string caller);
    internal static void TestCollectionExpressionElement(int level, ICollectionExpressionElement param, string caller);
    internal static void TestCollectionInitializer(int level, ICollectionInitializer param, string caller);
    internal static void TestConditionalAccessSign(int level, IConditionalAccessSign param, string caller);
    internal static void TestConditionalAndExpression(int level, IConditionalAndExpression param, string caller);
    internal static void TestConditionalOrExpression(int level, IConditionalOrExpression param, string caller);
    internal static void TestConditionalTernaryExpression(int level, IConditionalTernaryExpression param, string caller);
    internal static void TestConstantDeclaration(int level, IConstantDeclaration param, string caller);
    internal static void TestConstantOrTypePattern(int level, IConstantOrTypePattern param, string caller);
    internal static void TestConstructorConstraint(int level, IConstructorConstraint param, string caller);
    internal static void TestConstructorDeclaration(int level, IConstructorDeclaration param, string caller);
    internal static void TestConstructorInitializer(int level, IConstructorInitializer param, string caller);
    internal static void TestContinueStatement(int level, IContinueStatement param, string caller);
    internal static void TestConversionOperatorDeclaration(int level, IConversionOperatorDeclaration param, string caller);
    internal static void TestCreationExpression(int level, ICreationExpression param, string caller);
    internal static void TestCreationExpressionInitializer(int level, ICreationExpressionInitializer param, string caller);
    internal static void TestDeclarationExpression(int level, IDeclarationExpression param, string caller);
    internal static void TestDeclarationStatement(int level, IDeclarationStatement param, string caller);
    internal static void TestDeconstructionPatternClause(int level, IDeconstructionPatternClause param, string caller);
    internal static void TestDefaultConstraint(int level, IDefaultConstraint param, string caller);
    internal static void TestDefaultExpression(int level, IDefaultExpression param, string caller);
    internal static void TestDefineDirective(int level, IDefineDirective param, string caller);
    internal static void TestDelegateDeclaration(int level, IDelegateDeclaration param, string caller);
    internal static void TestDestructorDeclaration(int level, IDestructorDeclaration param, string caller);
    internal static void TestDiscardDesignation(int level, IDiscardDesignation param, string caller);
    internal static void TestDiscardPattern(int level, IDiscardPattern param, string caller);
    internal static void TestDoStatement(int level, IDoStatement param, string caller);
    internal static void TestDocCRefElement(int level, IDocCRefElement param, string caller);
    internal static void TestDocCRefExpression(int level, IDocCRefExpression param, string caller);
    internal static void TestDocCRefParameter(int level, IDocCRefParameter param, string caller);
    internal static void TestDocCRefParameterType(int level, IDocCRefParameterType param, string caller);
    internal static void TestDocCRefParameterTypeName(int level, IDocCRefParameterTypeName param, string caller);
    internal static void TestDocCRefSignature(int level, IDocCRefSignature param, string caller);
    internal static void TestDocCRefTypeParameter(int level, IDocCRefTypeParameter param, string caller);
    internal static void TestDocCRefTypeParameterList(int level, IDocCRefTypeParameterList param, string caller);
    internal static void TestElementAccessExpression(int level, IElementAccessExpression param, string caller);
    internal static void TestElifDirective(int level, IElifDirective param, string caller);
    internal static void TestElseDirective(int level, IElseDirective param, string caller);
    internal static void TestEmptyStatement(int level, IEmptyStatement param, string caller);
    internal static void TestEndRegion(int level, IEndRegion param, string caller);
    internal static void TestEndifDirective(int level, IEndifDirective param, string caller);
    internal static void TestEnumBase(int level, IEnumBase param, string caller);
    internal static void TestEnumBody(int level, IEnumBody param, string caller);
    internal static void TestEnumDeclaration(int level, IEnumDeclaration param, string caller);
    internal static void TestEnumMemberDeclaration(int level, IEnumMemberDeclaration param, string caller);
    internal static void TestEqualityExpression(int level, IEqualityExpression param, string caller);
    internal static void TestErrorDirective(int level, IErrorDirective param, string caller);
    internal static void TestErrorElement(int level, IErrorElement param, string caller);
    internal static void TestEventDeclaration(int level, IEventDeclaration param, string caller);
    internal static void TestExceptionFilterClause(int level, IExceptionFilterClause param, string caller);
    internal static void TestExpressionBodyOwnerDeclaration(int level, IExpressionBodyOwnerDeclaration param, string caller);
    internal static void TestExpressionElement(int level, IExpressionElement param, string caller);
    internal static void TestExpressionInitializer(int level, IExpressionInitializer param, string caller);
    internal static void TestExpressionStatement(int level, IExpressionStatement param, string caller);
    internal static void TestExtendedType(int level, IExtendedType param, string caller);
    internal static void TestExtendsList(int level, IExtendsList param, string caller);
    internal static void TestExternAliasDirective(int level, IExternAliasDirective param, string caller);
    internal static void TestFieldDeclaration(int level, IFieldDeclaration param, string caller);
    internal static void TestForInitializer(int level, IForInitializer param, string caller);
    internal static void TestForIterator(int level, IForIterator param, string caller);
    internal static void TestForStatement(int level, IForStatement param, string caller);
    internal static void TestForeachHeader(int level, IForeachHeader param, string caller);
    internal static void TestForeachStatement(int level, IForeachStatement param, string caller);
    internal static void TestFormalParameterList(int level, IFormalParameterList param, string caller);
    internal static void TestFunctionPointerCallingConvention(int level, IFunctionPointerCallingConvention param, string caller);
    internal static void TestFunctionPointerParameter(int level, IFunctionPointerParameter param, string caller);
    internal static void TestFunctionPointerParameterModifiers(int level, IFunctionPointerParameterModifiers param, string caller);
    internal static void TestFunctionPointerTypeUsage(int level, IFunctionPointerTypeUsage param, string caller);
    internal static void TestGeneralCatchClause(int level, IGeneralCatchClause param, string caller);
    internal static void TestGotoCaseStatement(int level, IGotoCaseStatement param, string caller);
    internal static void TestGotoStatement(int level, IGotoStatement param, string caller);
    internal static void TestIdentifier(int level, ICSharpIdentifier param, string caller);
    internal static void TestIfDirective(int level, IIfDirective param, string caller);
    internal static void TestIfStatement(int level, IIfStatement param, string caller);
    internal static void TestIndexFromEndExpression(int level, IIndexFromEndExpression param, string caller);
    internal static void TestIndexerDeclaration(int level, IIndexerDeclaration param, string caller);
    internal static void TestIndexerInitializer(int level, IIndexerInitializer param, string caller);
    internal static void TestInitializedMemberInitializer(int level, IInitializedMemberInitializer param, string caller);
    internal static void TestInitializerElement(int level, IInitializerElement param, string caller);
    internal static void TestInterfaceDeclaration(int level, IInterfaceDeclaration param, string caller);
    internal static void TestInterfaceQualificationOwner(int level, IInterfaceQualificationOwner param, string caller);
    internal static void TestInterpolatedStringExpression(int level, IInterpolatedStringExpression param, string caller);
    internal static void TestInterpolatedStringInsert(int level, IInterpolatedStringInsert param, string caller);
    internal static void TestInvalidDirective(int level, IInvalidDirective param, string caller);
    internal static void TestInvocationExpression(int level, IInvocationExpression param, string caller);
    internal static void TestIsExpression(int level, IIsExpression param, string caller);
    internal static void TestKeyword(int level, IKeyword param, string caller);
    internal static void TestLabelDeclaration(int level, ILabelDeclaration param, string caller);
    internal static void TestLabelReferenceElement(int level, ILabelReferenceElement param, string caller);
    internal static void TestLabelStatement(int level, ILabelStatement param, string caller);
    internal static void TestLambdaExpression(int level, ILambdaExpression param, string caller);
    internal static void TestLambdaSignature(int level, ILambdaSignature param, string caller);
    internal static void TestLineDirective(int level, ILineDirective param, string caller);
    internal static void TestLineIndicator(int level, ILineIndicator param, string caller);
    internal static void TestListPattern(int level, IListPattern param, string caller);
    internal static void TestLocalArglistParameterDeclaration(int level, ILocalArglistParameterDeclaration param, string caller);
    internal static void TestLocalConstantDeclaration(int level, ILocalConstantDeclaration param, string caller);
    internal static void TestLocalFormalParameterList(int level, ILocalFormalParameterList param, string caller);
    internal static void TestLocalFunctionDeclaration(int level, ILocalFunctionDeclaration param, string caller);
    internal static void TestLocalParameterDeclaration(int level, ILocalParameterDeclaration param, string caller);
    internal static void TestLocalRegularParameterDeclaration(int level, ILocalRegularParameterDeclaration param, string caller);
    internal static void TestLocalVariableDeclaration(int level, ILocalVariableDeclaration param, string caller);
    internal static void TestLockStatement(int level, ILockStatement param, string caller);
    internal static void TestMakerefExpression(int level, IMakerefExpression param, string caller);
    internal static void TestMemberInitializer(int level, IMemberInitializer param, string caller);
    internal static void TestMemberOwnerBody(int level, IMemberOwnerBody param, string caller);
    internal static void TestMemberOwnerDeclaration(int level, IMemberOwnerDeclaration param, string caller);
    internal static void TestMethodDeclaration(int level, IMethodDeclaration param, string caller);
    internal static void TestMissingDesignation(int level, IMissingDesignation param, string caller);
    internal static void TestModifiersList(int level, IModifiersList param, string caller);
    internal static void TestMultipleConstantDeclaration(int level, IMultipleConstantDeclaration param, string caller);
    internal static void TestMultipleDeclaration(int level, IMultipleDeclaration param, string caller);
    internal static void TestMultipleDeclarationMember(int level, IMultipleDeclarationMember param, string caller);
    internal static void TestMultipleEventDeclaration(int level, IMultipleEventDeclaration param, string caller);
    internal static void TestMultipleFieldDeclaration(int level, IMultipleFieldDeclaration param, string caller);
    internal static void TestMultipleLocalConstantDeclaration(int level, IMultipleLocalConstantDeclaration param, string caller);
    internal static void TestMultipleLocalVariableDeclaration(int level, IMultipleLocalVariableDeclaration param, string caller);
    internal static void TestMultiplicativeExpression(int level, IMultiplicativeExpression param, string caller);
    internal static void TestNamedMemberInitializer(int level, INamedMemberInitializer param, string caller);
    internal static void TestNamespaceBody(int level, INamespaceBody param, string caller);
    internal static void TestNegatedPattern(int level, INegatedPattern param, string caller);
    internal static void TestNullCoalescingExpression(int level, INullCoalescingExpression param, string caller);
    internal static void TestNullableDirective(int level, INullableDirective param, string caller);
    internal static void TestNullableTypeMark(int level, INullableTypeMark param, string caller);
    internal static void TestNullableTypeUsage(int level, INullableTypeUsage param, string caller);
    internal static void TestObjectCreationExpression(int level, IObjectCreationExpression param, string caller);
    internal static void TestObjectInitializer(int level, IObjectInitializer param, string caller);
    internal static void TestOperatorDeclaration(int level, IOperatorDeclaration param, string caller);
    internal static void TestOperatorExpression(int level, IOperatorExpression param, string caller);
    internal static void TestOrPattern(int level, IOrPattern param, string caller);
    internal static void TestOverflowCheckingStatement(int level, IOverflowCheckingStatement param, string caller);
    internal static void TestOwnerQualification(int level, IOwnerQualification param, string caller);
    internal static void TestParameterModifiersList(int level, IParameterModifiersList param, string caller);
    internal static void TestParenthesizedExpression(int level, IParenthesizedExpression param, string caller);
    internal static void TestParenthesizedPattern(int level, IParenthesizedPattern param, string caller);
    internal static void TestParenthesizedVariableDesignation(int level, IParenthesizedVariableDesignation param, string caller);
    internal static void TestPattern(int level, IPattern param, string caller);
    internal static void TestPatternGuardClause(int level, IPatternGuardClause param, string caller);
    internal static void TestPointerTypeUsage(int level, IPointerTypeUsage param, string caller);
    internal static void TestPostfixOperatorExpression(int level, IPostfixOperatorExpression param, string caller);
    internal static void TestPragmaDirective(int level, IPragmaDirective param, string caller);
    internal static void TestPredefinedTypeExpression(int level, IPredefinedTypeExpression param, string caller);
    internal static void TestPredefinedTypeReference(int level, IPredefinedTypeReference param, string caller);
    internal static void TestPredefinedTypeUsage(int level, IPredefinedTypeUsage param, string caller);
    internal static void TestPrefixOperatorExpression(int level, IPrefixOperatorExpression param, string caller);
    internal static void TestPreprocessor(int level, IPreprocessor param, string caller);
    internal static void TestPreprocessorAndExpression(int level, IPreprocessorAndExpression param, string caller);
    internal static void TestPreprocessorConditionalSymbol(int level, IPreprocessorConditionalSymbol param, string caller);
    internal static void TestPreprocessorDirective(int level, IPreprocessorDirective param, string caller);
    internal static void TestPreprocessorEqualityExpression(int level, IPreprocessorEqualityExpression param, string caller);
    internal static void TestPreprocessorExpression(int level, IPreprocessorExpression param, string caller);
    internal static void TestPreprocessorNegation(int level, IPreprocessorNegation param, string caller);
    internal static void TestPreprocessorOrExpression(int level, IPreprocessorOrExpression param, string caller);
    internal static void TestPreprocessorParenthesizedExpression(int level, IPreprocessorParenthesizedExpression param, string caller);
    internal static void TestPreprocessorPragmaBody(int level, IPreprocessorPragmaBody param, string caller);
    internal static void TestPreprocessorUnaryExpression(int level, IPreprocessorUnaryExpression param, string caller);
    internal static void TestPrimaryConstructorDeclaration(int level, IPrimaryConstructorDeclaration param, string caller);
    internal static void TestPrimaryExpression(int level, IPrimaryExpression param, string caller);
    internal static void TestPropertyAssignment(int level, IPropertyAssignment param, string caller);
    internal static void TestPropertyDeclaration(int level, IPropertyDeclaration param, string caller);
    internal static void TestPropertyInitializer(int level, IPropertyInitializer param, string caller);
    internal static void TestPropertyPatternClause(int level, IPropertyPatternClause param, string caller);
    internal static void TestQueryClause(int level, IQueryClause param, string caller);
    internal static void TestQueryClausesHolder(int level, IQueryClausesHolder param, string caller);
    internal static void TestQueryContinuation(int level, IQueryContinuation param, string caller);
    internal static void TestQueryExpression(int level, IQueryExpression param, string caller);
    internal static void TestQueryFirstFrom(int level, IQueryFirstFrom param, string caller);
    internal static void TestQueryFromClause(int level, IQueryFromClause param, string caller);
    internal static void TestQueryGroupClause(int level, IQueryGroupClause param, string caller);
    internal static void TestQueryJoinClause(int level, IQueryJoinClause param, string caller);
    internal static void TestQueryLetClause(int level, IQueryLetClause param, string caller);
    internal static void TestQueryOrderByClause(int level, IQueryOrderByClause param, string caller);
    internal static void TestQueryOrdering(int level, IQueryOrdering param, string caller);
    internal static void TestQueryParameterPlatform(int level, IQueryParameterPlatform param, string caller);
    internal static void TestQueryRangeVariableDeclaration(int level, IQueryRangeVariableDeclaration param, string caller);
    internal static void TestQuerySelectClause(int level, IQuerySelectClause param, string caller);
    internal static void TestQueryWhereClause(int level, IQueryWhereClause param, string caller);
    internal static void TestRangeExpression(int level, IRangeExpression param, string caller);
    internal static void TestRankSpecifier(int level, IRankSpecifier param, string caller);
    internal static void TestRecordDeclaration(int level, IRecordDeclaration param, string caller);
    internal static void TestRecursivePattern(int level, IRecursivePattern param, string caller);
    internal static void TestRefExpression(int level, IRefExpression param, string caller);
    internal static void TestReferenceExpression(int level, IReferenceExpression param, string caller);
    internal static void TestReferenceName(int level, IReferenceName param, string caller);
    internal static void TestReferenceTypeConstraint(int level, IReferenceTypeConstraint param, string caller);
    internal static void TestReftypeExpression(int level, IReftypeExpression param, string caller);
    internal static void TestRefvalueExpression(int level, IRefvalueExpression param, string caller);
    internal static void TestRelationalExpression(int level, IRelationalExpression param, string caller);
    internal static void TestRelationalPattern(int level, IRelationalPattern param, string caller);
    internal static void TestResourceAcquisitionExpressionsList(int level, IResourceAcquisitionExpressionsList param, string caller);
    internal static void TestReturnStatement(int level, IReturnStatement param, string caller);
    internal static void TestScalarTypeUsage(int level, IScalarTypeUsage param, string caller);
    internal static void TestShiftExpression(int level, IShiftExpression param, string caller);
    internal static void TestSignOperatorDeclaration(int level, ISignOperatorDeclaration param, string caller);
    internal static void TestSingleVariableDesignation(int level, ISingleVariableDesignation param, string caller);
    internal static void TestSlicePattern(int level, ISlicePattern param, string caller);
    internal static void TestSpecificCatchClause(int level, ISpecificCatchClause param, string caller);
    internal static void TestSpreadElement(int level, ISpreadElement param, string caller);
    internal static void TestStackAllocExpression(int level, IStackAllocExpression param, string caller);
    internal static void TestStartRegion(int level, IStartRegion param, string caller);
    internal static void TestStatementsOwner(int level, IStatementsOwner param, string caller);
    internal static void TestStructDeclaration(int level, IStructDeclaration param, string caller);
    internal static void TestSubpattern(int level, ISubpattern param, string caller);
    internal static void TestSuppressNullableWarningExpression(int level, ISuppressNullableWarningExpression param, string caller);
    internal static void TestSwitchBlock(int level, ISwitchBlock param, string caller);
    internal static void TestSwitchCaseLabel(int level, ISwitchCaseLabel param, string caller);
    internal static void TestSwitchExpression(int level, ISwitchExpression param, string caller);
    internal static void TestSwitchExpressionArm(int level, ISwitchExpressionArm param, string caller);
    internal static void TestSwitchSection(int level, ISwitchSection param, string caller);
    internal static void TestSwitchStatement(int level, ISwitchStatement param, string caller);
    internal static void TestThisExpression(int level, IThisExpression param, string caller);
    internal static void TestThrowExpression(int level, IThrowExpression param, string caller);
    internal static void TestThrowStatement(int level, IThrowStatement param, string caller);
    internal static void TestTopLevelCode(int level, ITopLevelCode param, string caller);
    internal static void TestTryStatement(int level, ITryStatement param, string caller);
    internal static void TestTupleComponent(int level, ITupleComponent param, string caller);
    internal static void TestTupleComponentList(int level, ITupleComponentList param, string caller);
    internal static void TestTupleExpression(int level, ITupleExpression param, string caller);
    internal static void TestTupleTypeComponent(int level, ITupleTypeComponent param, string caller);
    internal static void TestTupleTypeComponentList(int level, ITupleTypeComponentList param, string caller);
    internal static void TestTupleTypeUsage(int level, ITupleTypeUsage param, string caller);
    internal static void TestTypeArgumentList(int level, ITypeArgumentList param, string caller);
    internal static void TestTypeConstraint(int level, ITypeConstraint param, string caller);
    internal static void TestTypeMemberArglistParameterDeclaration(int level, ITypeMemberArglistParameterDeclaration param, string caller);
    internal static void TestTypeMemberRegularParameterDeclaration(int level, ITypeMemberRegularParameterDeclaration param, string caller);
    internal static void TestTypeParameterConstraint(int level, ITypeParameterConstraint param, string caller);
    internal static void TestTypeParameterConstraintsClause(int level, ITypeParameterConstraintsClause param, string caller);
    internal static void TestTypeParameterDeclaration(int level, ITypeParameterDeclaration param, string caller);
    internal static void TestTypeParameterOfLocalFunctionDeclaration(int level, ITypeParameterOfLocalFunctionDeclaration param, string caller);
    internal static void TestTypeParameterOfLocalFunctionList(int level, ITypeParameterOfLocalFunctionList param, string caller);
    internal static void TestTypeParameterOfMethodDeclaration(int level, ITypeParameterOfMethodDeclaration param, string caller);
    internal static void TestTypeParameterOfMethodList(int level, ITypeParameterOfMethodList param, string caller);
    internal static void TestTypeParameterOfTypeDeclaration(int level, ITypeParameterOfTypeDeclaration param, string caller);
    internal static void TestTypeParameterOfTypeList(int level, ITypeParameterOfTypeList param, string caller);
    internal static void TestTypeParameterReference(int level, ITypeParameterReference param, string caller);
    internal static void TestTypePattern(int level, ITypePattern param, string caller);
    internal static void TestTypeUsage(int level, ITypeUsage param, string caller);
    internal static void TestTypeofExpression(int level, ITypeofExpression param, string caller);
    internal static void TestUnaryExpression(int level, IUnaryExpression param, string caller);
    internal static void TestUnaryOperatorExpression(int level, IUnaryOperatorExpression param, string caller);
    internal static void TestUncheckedExpression(int level, IUncheckedExpression param, string caller);
    internal static void TestUncheckedStatement(int level, IUncheckedStatement param, string caller);
    internal static void TestUndefDirective(int level, IUndefDirective param, string caller);
    internal static void TestUnsafeCodeAddressOfExpression(int level, IUnsafeCodeAddressOfExpression param, string caller);
    internal static void TestUnsafeCodeFixedPointerDeclaration(int level, IUnsafeCodeFixedPointerDeclaration param, string caller);
    internal static void TestUnsafeCodeFixedPointerInitializer(int level, IUnsafeCodeFixedPointerInitializer param, string caller);
    internal static void TestUnsafeCodeFixedStatement(int level, IUnsafeCodeFixedStatement param, string caller);
    internal static void TestUnsafeCodePointer(int level, IUnsafeCodePointer param, string caller);
    internal static void TestUnsafeCodePointerAccessExpression(int level, IUnsafeCodePointerAccessExpression param, string caller);
    internal static void TestUnsafeCodePointerIndirectionExpression(int level, IUnsafeCodePointerIndirectionExpression param, string caller);
    internal static void TestUnsafeCodeSizeOfExpression(int level, IUnsafeCodeSizeOfExpression param, string caller);
    internal static void TestUnsafeCodeUnsafeStatement(int level, IUnsafeCodeUnsafeStatement param, string caller);
    internal static void TestUserTypeUsage(int level, IUserTypeUsage param, string caller);
    internal static void TestUsingAliasDirective(int level, IUsingAliasDirective param, string caller);
    internal static void TestUsingDirective(int level, IUsingDirective param, string caller);
    internal static void TestUsingList(int level, IUsingList param, string caller);
    internal static void TestUsingStatement(int level, IUsingStatement param, string caller);
    internal static void TestUsingSymbolDirective(int level, IUsingSymbolDirective param, string caller);
    internal static void TestValueTypeConstraint(int level, IValueTypeConstraint param, string caller);
    internal static void TestVarDeconstructionPattern(int level, IVarDeconstructionPattern param, string caller);
    internal static void TestVarPattern(int level, IVarPattern param, string caller);
    internal static void TestVariableDeclaration(int level, IVariableDeclaration param, string caller);
    internal static void TestVariableDesignation(int level, IVariableDesignation param, string caller);
    internal static void TestVariableInitializer(int level, IVariableInitializer param, string caller);
    internal static void TestWarningAction(int level, IWarningAction param, string caller);
    internal static void TestWarningDirective(int level, IWarningDirective param, string caller);
    internal static void TestWarningList(int level, IWarningList param, string caller);
    internal static void TestWhileStatement(int level, IWhileStatement param, string caller);
    internal static void TestWithExpression(int level, IWithExpression param, string caller);
    internal static void TestWithInitializerAssignment(int level, IWithInitializerAssignment param, string caller);
    internal static void TestYieldStatement(int level, IYieldStatement param, string caller);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QualifierExpressionResolver : NonQualifiedReferencesResolverBase {
    private ITreeNode myTopElement;
    public QualifierExpressionResolver(IResolveContext resolveContext);
    public void Run(ICSharpExpression expression);
    protected virtual void VisitElement(ITreeNode element);
    protected virtual ValueTuple`2<ISymbolTable, int> GetInitialSymbolTable(SymbolTableMode mode);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryClauseBase : CSharpCompositeElement {
    public IList`1<IQueryReference> QueryReferences { get; }
    public IQueryClause PreviousClause { get; }
    public IQueryClause NextClause { get; }
    [CanBeNullAttribute]
public IType CastType { get; }
    [NotNullAttribute]
public IList`1<IQueryRangeVariableDeclaration> Declarations { get; }
    public IList`1<IQueryParameterPlatform> Platforms { get; }
    public IGeneratedQueryArgument GeneratedArgument { get; }
    public ITokenNode FirstKeyword { get; }
    public abstract virtual IList`1<IQueryReference> get_QueryReferences();
    public sealed virtual IQueryClause get_PreviousClause();
    public sealed virtual IQueryClause get_NextClause();
    protected bool IsExpressionTrivial(ICSharpExpression expression, SimpleScheme scheme);
    internal abstract virtual QueryKind GetKindImpl();
    public virtual QueryKind GetKind();
    public virtual IType get_CastType();
    public virtual IList`1<IQueryRangeVariableDeclaration> get_Declarations();
    public abstract virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public virtual IGeneratedQueryArgument get_GeneratedArgument();
    public abstract virtual ITokenNode get_FirstKeyword();
    [NotNullAttribute]
protected IList`1<IQueryParameterPlatform> CreatePlatformsList(IQueryParameterPlatform v1, IQueryParameterPlatform v2);
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryClauseExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static IQueryClause PreviousClauseThrough(IQueryClause clause);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static IQueryClause NextClauseEx(IQueryClause clause);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryContinuation : CSharpCompositeElement {
    public static short INTO_KEYWORD;
    public static short DECL;
    public static short CLAUSE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IQueryClause> Clauses { get; }
    public TreeNodeEnumerable`1<IQueryClause> ClausesEnumerable { get; }
    public IQueryRangeVariableDeclaration Declaration { get; }
    public ITokenNode IntoKeyword { get; }
    public string Name { get; }
    public IQueryClausesHolder Previous { get; }
    public IQueryClausesHolder Next { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IQueryClause> get_Clauses();
    public virtual TreeNodeEnumerable`1<IQueryClause> get_ClausesEnumerable();
    public virtual IQueryRangeVariableDeclaration get_Declaration();
    public virtual ITokenNode get_IntoKeyword();
    public virtual IQueryRangeVariableDeclaration SetDeclaration(IQueryRangeVariableDeclaration param);
    public virtual string ToString();
    public sealed virtual string get_Name();
    public sealed virtual IQueryClausesHolder get_Previous();
    public sealed virtual IQueryClausesHolder get_Next();
    public sealed virtual IQueryClause AddQueryClauseAfter(IQueryClause queryClause, IQueryClause anchor);
    public sealed virtual IQueryClause AddQueryClauseBefore(IQueryClause queryClause, IQueryClause anchor);
    public sealed virtual void RemoveQueryClause(IQueryClause clause);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryExpression : CSharpExpressionBase {
    public static short FROM;
    public static short CLAUSE;
    public static short CONTINUATION;
    private bool myBuilderIsValid;
    private QueryBuilder myBuilder;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IQueryClause> Clauses { get; }
    public TreeNodeEnumerable`1<IQueryClause> ClausesEnumerable { get; }
    public TreeNodeCollection`1<IQueryContinuation> Continuations { get; }
    public TreeNodeEnumerable`1<IQueryContinuation> ContinuationsEnumerable { get; }
    public IQueryFirstFrom From { get; }
    public IQueryClausesHolder Previous { get; }
    public IQueryClausesHolder Next { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IQueryClause> get_Clauses();
    public virtual TreeNodeEnumerable`1<IQueryClause> get_ClausesEnumerable();
    public virtual TreeNodeCollection`1<IQueryContinuation> get_Continuations();
    public virtual TreeNodeEnumerable`1<IQueryContinuation> get_ContinuationsEnumerable();
    public virtual IQueryFirstFrom get_From();
    public virtual IQueryFirstFrom SetFrom(IQueryFirstFrom param);
    public virtual string ToString();
    public sealed virtual IQueryClausesHolder get_Previous();
    public sealed virtual IQueryClausesHolder get_Next();
    protected virtual void PreInit();
    protected virtual void ClearCachedData();
    private IQueryClause GetLastClause();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    private QueryBuilder GetBuilder();
    public sealed virtual IReadOnlyList`1<IQueryVariable> GetVariables(IQueryParameterPlatform platform);
    public sealed virtual IScheme GetScheme(IQueryClause clause);
    public sealed virtual void RemoveContinuation(IQueryContinuation continuation);
    public sealed virtual IQueryClause AddQueryClauseAfter(IQueryClause queryClause, IQueryClause anchor);
    public sealed virtual IQueryClause AddQueryClauseBefore(IQueryClause queryClause, IQueryClause anchor);
    public sealed virtual void RemoveQueryClause(IQueryClause clause);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryFirstFrom : CSharpCompositeElement {
    public static short FROM_KEYWORD;
    public static short CSHARP_TYPE;
    public static short DECL;
    public static short IN_KEYWORD;
    public static short EXPR;
    private CastReference myCastReference;
    public NodeType NodeType { get; }
    public IQueryRangeVariableDeclaration Declaration { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode FromKeyword { get; }
    public ITokenNode InKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public string Name { get; }
    public IQueryCastReference CastReference { get; }
    public IType CastType { get; }
    public ITokenNode Keyword { get; }
    private ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IQueryCastReferenceProvider.Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryRangeVariableDeclaration get_Declaration();
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_FromKeyword();
    public virtual ITokenNode get_InKeyword();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IQueryRangeVariableDeclaration SetDeclaration(IQueryRangeVariableDeclaration param);
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual string get_Name();
    public sealed virtual IQueryCastReference get_CastReference();
    public sealed virtual IType get_CastType();
    public sealed virtual ITokenNode get_Keyword();
    public sealed virtual IReference GetReferenceQualifiedByExpression();
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IQueryCastReferenceProvider.get_Expression();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryFromClause : QueryClauseBase {
    public static short FROM_KEYWORD;
    public static short CSHARP_TYPE;
    public static short DECL;
    public static short IN_KEYWORD;
    public static short EXPR;
    private FromReference myReference;
    private CastReference myCastReference;
    public NodeType NodeType { get; }
    public IQueryRangeVariableDeclaration Declaration { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode FromKeyword { get; }
    public ITokenNode InKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public IList`1<IQueryReference> QueryReferences { get; }
    public IList`1<IQueryParameterPlatform> Platforms { get; }
    public IGeneratedQueryArgument GeneratedArgument { get; }
    public ITokenNode FirstKeyword { get; }
    public string Name { get; }
    public IQueryChainReference SelectReference { get; }
    public IQueryCastReference CastReference { get; }
    public IType CastType { get; }
    public ITokenNode Keyword { get; }
    private ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IQueryCastReferenceProvider.Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryRangeVariableDeclaration get_Declaration();
    public virtual IQueryParameterPlatform get_Expression();
    public virtual ITokenNode get_FromKeyword();
    public virtual ITokenNode get_InKeyword();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IQueryRangeVariableDeclaration SetDeclaration(IQueryRangeVariableDeclaration param);
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual IList`1<IQueryReference> get_QueryReferences();
    public virtual ReferenceCollection GetFirstClassReferences();
    internal virtual QueryKind GetKindImpl();
    public virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public virtual IGeneratedQueryArgument get_GeneratedArgument();
    public virtual ITokenNode get_FirstKeyword();
    public sealed virtual string get_Name();
    public sealed virtual IQueryChainReference get_SelectReference();
    public sealed virtual IQueryCastReference get_CastReference();
    public virtual IType get_CastType();
    public sealed virtual ITokenNode get_Keyword();
    private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IQueryCastReferenceProvider.get_Expression();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryGroupClause : QueryClauseBase {
    public static short GROUP_KEYWORD;
    public static short CSHARP_OP1;
    public static short BY_KEYWORD;
    public static short CSHARP_OP2;
    private GroupReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode ByKeyword { get; }
    public IQueryParameterPlatform Criteria { get; }
    public ITokenNode GroupKeyword { get; }
    public IQueryParameterPlatform Subject { get; }
    public IList`1<IQueryReference> QueryReferences { get; }
    public IQueryReference GroupReference { get; }
    public IList`1<IQueryParameterPlatform> Platforms { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ByKeyword();
    public virtual IQueryParameterPlatform get_Criteria();
    public virtual ITokenNode get_GroupKeyword();
    public virtual IQueryParameterPlatform get_Subject();
    public virtual IQueryParameterPlatform SetCriteria(IQueryParameterPlatform param);
    public virtual IQueryParameterPlatform SetSubject(IQueryParameterPlatform param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual IList`1<IQueryReference> get_QueryReferences();
    public sealed virtual IQueryReference get_GroupReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual QueryKind GetKind();
    public virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public virtual ITokenNode get_FirstKeyword();
    internal virtual QueryKind GetKindImpl();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryJoinClause : QueryClauseBase {
    public static short JOIN_KEYWORD;
    public static short CSHARP_TYPE;
    public static short DECL;
    public static short IN_KEYWORD;
    public static short EXPR1;
    public static short ON_KEYWORD;
    public static short EXPR2;
    public static short EQUALS_KEYWORD;
    public static short EXPR3;
    public static short INTO_KEYWORD;
    public static short DECLARATOR;
    private JoinReference myReference;
    private CastReference myCastReference;
    public NodeType NodeType { get; }
    public IQueryParameterPlatform EqualsExpression { get; }
    public ITokenNode EqualsKeyword { get; }
    public ICSharpExpression InExpression { get; }
    public ITokenNode InKeyword { get; }
    public IQueryRangeVariableDeclaration IntoDeclaration { get; }
    public ITokenNode IntoKeyword { get; }
    public IQueryRangeVariableDeclaration JoinDeclaration { get; }
    public ITokenNode JoinKeyword { get; }
    public IQueryParameterPlatform OnExpression { get; }
    public ITokenNode OnKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public IList`1<IQueryReference> QueryReferences { get; }
    public IList`1<IQueryParameterPlatform> Platforms { get; }
    public IGeneratedQueryArgument GeneratedArgument { get; }
    public ITokenNode FirstKeyword { get; }
    public string VariableName { get; }
    public string IntoName { get; }
    public IQueryChainReference JoinReference { get; }
    public IQueryCastReference CastReference { get; }
    public IType CastType { get; }
    public ITokenNode Keyword { get; }
    public ICSharpExpression Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryParameterPlatform get_EqualsExpression();
    public virtual ITokenNode get_EqualsKeyword();
    public virtual ICSharpExpression get_InExpression();
    public virtual ITokenNode get_InKeyword();
    public virtual IQueryRangeVariableDeclaration get_IntoDeclaration();
    public virtual ITokenNode get_IntoKeyword();
    public virtual IQueryRangeVariableDeclaration get_JoinDeclaration();
    public virtual ITokenNode get_JoinKeyword();
    public virtual IQueryParameterPlatform get_OnExpression();
    public virtual ITokenNode get_OnKeyword();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IQueryParameterPlatform SetEqualsExpression(IQueryParameterPlatform param);
    public virtual ICSharpExpression SetInExpression(ICSharpExpression param);
    public virtual IQueryRangeVariableDeclaration SetIntoDeclaration(IQueryRangeVariableDeclaration param);
    public virtual IQueryRangeVariableDeclaration SetJoinDeclaration(IQueryRangeVariableDeclaration param);
    public virtual IQueryParameterPlatform SetOnExpression(IQueryParameterPlatform param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual IList`1<IQueryReference> get_QueryReferences();
    public virtual ReferenceCollection GetFirstClassReferences();
    internal virtual QueryKind GetKindImpl();
    public virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public virtual IGeneratedQueryArgument get_GeneratedArgument();
    public virtual ITokenNode get_FirstKeyword();
    public sealed virtual string get_VariableName();
    public sealed virtual string get_IntoName();
    public sealed virtual IQueryChainReference get_JoinReference();
    public sealed virtual IQueryCastReference get_CastReference();
    public virtual IType get_CastType();
    public sealed virtual ITokenNode get_Keyword();
    public sealed virtual ICSharpExpression get_Expression();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryLetClause : QueryClauseBase {
    public static short LET_KEYWORD;
    public static short DECL;
    public static short CSHARP_EQ;
    public static short EXPR;
    private LetReference myReference;
    public NodeType NodeType { get; }
    public IQueryRangeVariableDeclaration Declaration { get; }
    public ITokenNode EqSign { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode LetKeyword { get; }
    public string Name { get; }
    public IList`1<IQueryReference> QueryReferences { get; }
    public IList`1<IQueryParameterPlatform> Platforms { get; }
    public ITokenNode FirstKeyword { get; }
    public IQueryReference SelectReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryRangeVariableDeclaration get_Declaration();
    public virtual ITokenNode get_EqSign();
    public virtual IQueryParameterPlatform get_Expression();
    public virtual ITokenNode get_LetKeyword();
    public virtual IQueryRangeVariableDeclaration SetDeclaration(IQueryRangeVariableDeclaration param);
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual string get_Name();
    public virtual IList`1<IQueryReference> get_QueryReferences();
    public virtual ReferenceCollection GetFirstClassReferences();
    internal virtual QueryKind GetKindImpl();
    public virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public virtual ITokenNode get_FirstKeyword();
    public sealed virtual IQueryReference get_SelectReference();
    public sealed virtual IList`1<IQueryAnonymousTypeProperty> GetGeneratedProperties();
    public sealed virtual IQueryAnonymousType GetAnonymousType();
    public sealed virtual IQueryAnonymousType GetAnonymousType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryOrderByClause : QueryClauseBase {
    public static short ORDERBY_KEYWORD;
    public static short ORDERING;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode OrderByKeyword { get; }
    public TreeNodeCollection`1<IQueryOrdering> Orderings { get; }
    public TreeNodeEnumerable`1<IQueryOrdering> OrderingsEnumerable { get; }
    public IList`1<IQueryReference> QueryReferences { get; }
    public IList`1<IQueryParameterPlatform> Platforms { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_OrderByKeyword();
    public virtual TreeNodeCollection`1<IQueryOrdering> get_Orderings();
    public virtual TreeNodeEnumerable`1<IQueryOrdering> get_OrderingsEnumerable();
    public virtual string ToString();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IList`1<IQueryReference> get_QueryReferences();
    internal virtual QueryKind GetKindImpl();
    public virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public virtual ITokenNode get_FirstKeyword();
    public sealed virtual IQueryOrdering AddQueryOrderingAfter(IQueryOrdering queryOrdering, IQueryOrdering anchor);
    public sealed virtual IQueryOrdering AddQueryOrderingBefore(IQueryOrdering queryOrdering, IQueryOrdering anchor);
    public sealed virtual void RemoveQueryOrdering(IQueryOrdering queryOrdering);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryOrdering : CSharpCompositeElement {
    public static short EXPR;
    public static short ASCENDING_KEYWORD;
    public static short DESCENDING_KEYWORD;
    private OrderByReference myReference;
    private object myLock;
    public NodeType NodeType { get; }
    public ITokenNode AscendingKeyword { get; }
    public ITokenNode DescendingKeyword { get; }
    public IQueryParameterPlatform Expression { get; }
    public IQueryReference Reference { get; }
    [CanBeNullAttribute]
public QueryOrderByClause ParentClause { get; }
    public bool IsFirstInClause { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AscendingKeyword();
    public virtual ITokenNode get_DescendingKeyword();
    public virtual IQueryParameterPlatform get_Expression();
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IQueryReference get_Reference();
    public QueryOrderByClause get_ParentClause();
    public bool get_IsFirstInClause();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryParameterPlatform : CSharpCompositeElement {
    public static short VALUE;
    public NodeType NodeType { get; }
    public ICSharpExpression Value { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IType LambdaReturnType { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public bool IsStatic { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameterDeclaration> ParameterDeclarations { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public CSharpParameterInstance MatchingParameter { get; }
    private DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.MatchingParameter { get; }
    public ICSharpInvocationInfo Invocation { get; }
    public IPsiModule PsiModule { get; }
    public bool IsNamedArgument { get; }
    public string ArgumentName { get; }
    public ParameterKind Kind { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public IManagedConvertible ManagedConvertible { get; }
    public int LevelDelta { get; }
    [NotNullAttribute]
public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Value();
    public virtual ICSharpExpression SetValue(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    private sealed virtual override DocumentRange JetBrains.ReSharper.Psi.IArgumentInfo.GetDocumentRange();
    public sealed virtual IReadOnlyList`1<IQueryVariable> GetVariables();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IType GetLambdaReturnType(IResolveContext resolveContext);
    public sealed virtual IType get_LambdaReturnType();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IParameterDeclaration> get_ParameterDeclarations();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    public sealed virtual CSharpParameterInstance get_MatchingParameter();
    private sealed virtual override DeclaredElementInstance`1<IParameter> JetBrains.ReSharper.Psi.IArgumentInfo.get_MatchingParameter();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual bool get_IsNamedArgument();
    public sealed virtual string get_ArgumentName();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual ParameterKind get_Kind();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryRangeVariableDeclaration : CSharpNonCachedDeclarationBase {
    public static short CSHARP_NAME;
    public NodeType NodeType { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IQueryRangeVariable DeclaredElement { get; }
    public IType Type { get; }
    public IList`1<IQueryDeclaredElement> RelatedDeclaredElements { get; }
    public string DeclaredName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    public sealed virtual IQueryRangeVariable get_DeclaredElement();
    public sealed virtual IType get_Type();
    public sealed virtual IList`1<IQueryDeclaredElement> get_RelatedDeclaredElements();
    public sealed virtual QueryDeclarationKind GetKind();
    public virtual string get_DeclaredName();
    public virtual DeclaredElementType GetElementType();
    public virtual TreeTextRange GetNameRange();
    public virtual void SetName(string name);
    [NotNullAttribute]
private static IList`1<IQueryDeclaredElement> CalcRelatedElements(IQueryClause clause, bool select);
    private IList`1<IQueryDeclaredElement> CalcRelatedElements(IQueryClausesHolder holder);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QuerySelectClause : QueryClauseBase {
    public static short SELECT_KEYWORD;
    public static short EXPR;
    private SelectReference myReference;
    public NodeType NodeType { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode SelectKeyword { get; }
    public IQueryReference SelectReference { get; }
    public IList`1<IQueryReference> QueryReferences { get; }
    private bool HasReference { get; }
    public IList`1<IQueryParameterPlatform> Platforms { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryParameterPlatform get_Expression();
    public virtual ITokenNode get_SelectKeyword();
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IQueryReference get_SelectReference();
    public virtual IList`1<IQueryReference> get_QueryReferences();
    public virtual ReferenceCollection GetFirstClassReferences();
    private bool get_HasReference();
    internal virtual QueryKind GetKindImpl();
    public virtual QueryKind GetKind();
    public virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.QueryWhereClause : QueryClauseBase {
    public static short WHERE_KEYWORD;
    public static short EXPR;
    private WhereReference myReference;
    public NodeType NodeType { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode WhereKeyword { get; }
    public IList`1<IQueryReference> QueryReferences { get; }
    public IQueryReference WhereReference { get; }
    public IList`1<IQueryParameterPlatform> Platforms { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryParameterPlatform get_Expression();
    public virtual ITokenNode get_WhereKeyword();
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual IList`1<IQueryReference> get_QueryReferences();
    public sealed virtual IQueryReference get_WhereReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    internal virtual QueryKind GetKindImpl();
    public virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RangeExpression : RangeExpressionStub {
    private RangeTypeReference myReference;
    public IReference TypeReference { get; }
    protected virtual void PreInit();
    public virtual IReference get_TypeReference();
    public virtual ReferenceCollection GetFirstClassReferences();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RangeExpressionStub : CSharpExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public IReference TypeReference { get; }
    public RangeKind RangeKind { get; }
    public IList`1<ICSharpExpression> OperatorOperands { get; }
    public IOperatorReference OperatorReference { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    public IManagedReference Reference { get; }
    private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public abstract virtual IReference get_TypeReference();
    public sealed virtual RangeKind get_RangeKind();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual IList`1<ICSharpExpression> get_OperatorOperands();
    public sealed virtual IOperatorReference get_OperatorReference();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
private ICSharpArgumentInfo[] GetArguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    [CompilerGeneratedAttribute]
private bool <CalculateExpressionTypeAux>g__IsOperandOfNullableIntOrIndexType|33_0(ICSharpExpression operand, <>c__DisplayClass33_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RankSpecifier : CSharpCompositeElement {
    public static short CSHARP_LBRACKET;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACKET;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Commas { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommasEnumerable { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Commas();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommasEnumerable();
    public virtual ITokenNode get_LBracket();
    public virtual ITokenNode get_RBracket();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RecordDeclaration : RecordDeclarationStub {
    [NotNullAttribute]
public virtual IClassBody SetBody(IClassBody param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RecordDeclarationStub : ClassLikeDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short KEYWORD;
    public static short CLASS_KIND_MODIFIER;
    public static short STRUCT_KIND_MODIFIER;
    public static short CSHARP_NAME;
    public static short TYPE_PARAMETERS_LIST;
    public static short CONSTRUCTOR;
    public static short CSHARP_BASE;
    public static short CONSTRAINTS;
    public static short CSHARP_BLOCK;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IClassBody Body { get; }
    public ITokenNode ClassModifier { get; }
    public IExtendsList ExtendsList { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IPrimaryConstructorDeclaration PrimaryConstructorDeclaration { get; }
    public ITokenNode RecordKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode StructModifier { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IClassBody BodyInternal { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> DestructorDeclarations { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IIndexerDeclaration> IndexerDeclarations { get; }
    public TreeNodeEnumerable`1<IIndexerDeclaration> IndexerDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> InheritedTypeUsages { get; }
    public TreeNodeEnumerable`1<ITypeUsage> InheritedTypeUsagesEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IOperatorDeclaration> OperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IOperatorDeclaration> OperatorDeclarationsEnumerable { get; }
    public ICSharpNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParametersEnumerable { get; }
    public ITokenNode TypeDeclarationKeyword { get; }
    public IReadOnlyList`1<ITypeDeclaration> TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    public bool IsStruct { get; }
    private ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.DeclaredElement { get; }
    private IRecord JetBrains.ReSharper.Psi.CSharp.Tree.IRecordDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IMemberOwnerBody JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration.Body { get; }
    public TreeNodeCollection`1<IClassMemberDeclaration> ClassMemberDeclarations { get; }
    public string DeclaredName { get; }
    public bool IsStatic { get; }
    public TreeNodeCollection`1<ITypeUsage> SuperTypeUsageNodes { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IClassBody get_Body();
    public virtual ITokenNode get_ClassModifier();
    public virtual IExtendsList get_ExtendsList();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IPrimaryConstructorDeclaration get_PrimaryConstructorDeclaration();
    public virtual ITokenNode get_RecordKeyword();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_StructModifier();
    public virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public virtual ITypeParameterOfTypeList get_TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IClassBody get_BodyInternal();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IDestructorDeclaration> get_DestructorDeclarations();
    public virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IFieldDeclaration> get_FieldDeclarations();
    public virtual TreeNodeEnumerable`1<IFieldDeclaration> get_FieldDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IIndexerDeclaration> get_IndexerDeclarations();
    public virtual TreeNodeEnumerable`1<IIndexerDeclaration> get_IndexerDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeUsage> get_InheritedTypeUsages();
    public virtual TreeNodeEnumerable`1<ITypeUsage> get_InheritedTypeUsagesEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_NestedTypeDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IOperatorDeclaration> get_OperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IOperatorDeclaration> get_OperatorDeclarationsEnumerable();
    public virtual ICSharpNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParametersEnumerable();
    public virtual IClassBody SetBody(IClassBody param);
    public virtual IExtendsList SetExtendsList(IExtendsList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IPrimaryConstructorDeclaration SetPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual string ToString();
    public sealed virtual ITokenNode get_TypeDeclarationKeyword();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    public sealed virtual bool CanBindTo(ITypeElement typeElement);
    public sealed virtual bool get_IsStruct();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.get_DeclaredElement();
    private sealed virtual override IRecord JetBrains.ReSharper.Psi.CSharp.Tree.IRecordDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IMemberOwnerBody JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration.get_Body();
    public virtual TreeNodeCollection`1<IClassMemberDeclaration> get_ClassMemberDeclarations();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual bool get_IsStatic();
    public sealed virtual IExtendsList GetOrCreateExtendsList();
    public virtual TreeNodeCollection`1<ITypeUsage> get_SuperTypeUsageNodes();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration typeParameterDeclaration);
    public sealed virtual void SetSuperRecord(IDeclaredType classType);
    public sealed virtual void SetKindKeyword(RecordDeclarationTypeKind typeKind);
    public sealed virtual void AddSuperInterface(IDeclaredType interfaceType, bool before);
    public sealed virtual void RemoveSuperInterface(IDeclaredType interfaceType);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RecursivePattern : RecursivePatternStub {
    [ContractAnnotationAttribute("propertyPatternClause: notnull => notnull; propertyPatternClause: null => null")]
public virtual IPropertyPatternClause SetPropertyPatternClause(IPropertyPatternClause propertyPatternClause);
    [ContractAnnotationAttribute("deconstructionPatternClause: notnull => notnull; deconstructionPatternClause: null => null")]
public virtual IDeconstructionPatternClause SetDeconstructionPatternClause(IDeconstructionPatternClause deconstructionPatternClause);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RecursivePatternStub : CSharpCompositeElement {
    public static short CSHARP_TYPE;
    public static short DECONSTRUCTION_PATTERN_CLAUSE;
    public static short PROPERTY_PATTERN_CLAUSE;
    public static short VARIABLE_DESIGNATION;
    public NodeType NodeType { get; }
    public IDeconstructionPatternClause DeconstructionPatternClause { get; }
    public IVariableDesignation Designation { get; }
    public IPropertyPatternClause PropertyPatternClause { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<ISubpattern> DeconstructionPatterns { get; }
    public TreeNodeEnumerable`1<ISubpattern> DeconstructionPatternsEnumerable { get; }
    public TreeNodeCollection`1<ISubpattern> PropertyPatterns { get; }
    public TreeNodeEnumerable`1<ISubpattern> PropertyPatternsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IDeconstructionPatternClause get_DeconstructionPatternClause();
    public virtual IVariableDesignation get_Designation();
    public virtual IPropertyPatternClause get_PropertyPatternClause();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<ISubpattern> get_DeconstructionPatterns();
    public virtual TreeNodeEnumerable`1<ISubpattern> get_DeconstructionPatternsEnumerable();
    public virtual TreeNodeCollection`1<ISubpattern> get_PropertyPatterns();
    public virtual TreeNodeEnumerable`1<ISubpattern> get_PropertyPatternsEnumerable();
    public virtual IDeconstructionPatternClause SetDeconstructionPatternClause(IDeconstructionPatternClause param);
    public virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    public virtual IPropertyPatternClause SetPropertyPatternClause(IPropertyPatternClause param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    public sealed virtual IType GetDesignationType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IExpressionType GetDesignationExpressionType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceExpression : ReferenceExpressionStub {
    public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    [CanBeNullAttribute]
public virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceExpressionBase : CSharpExpressionBase {
    [CanBeNullAttribute]
public ICSharpExpression QualifierExpression { get; }
    [CanBeNullAttribute]
private IIdentifier IdentifierNode { get; }
    public int TypeArgumentsNumber { get; }
    [NotNullAttribute]
public IList`1<IType> TypeArguments { get; }
    public sealed virtual ICSharpExpression get_QualifierExpression();
    private IIdentifier get_IdentifierNode();
    public sealed virtual int get_TypeArgumentsNumber();
    protected abstract virtual ITypeArgumentList GetTypeArgumentList();
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual IList`1<IType> get_TypeArguments();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceExpressionQualifier : ExpressionQualifier {
    [NotNullAttribute]
protected IReferenceExpression Owner { get; }
    public bool Resolved { get; }
    public ReferenceExpressionQualifier(IReferenceExpression referenceExpression, IResolveContext resolveContext);
    protected IReferenceExpression get_Owner();
    protected virtual ResolveResultWithInfo ResolveReference();
    public virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public virtual QualifierKind GetKind();
    internal static QualifierKind CalculateQualifierKind(IResolveResult result);
    public virtual bool get_Resolved();
    public virtual ITypeElement GetQualifierTypeElement();
}
[DebuggerDisplayAttribute("ReferenceExpression ({GetName()})")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceExpressionReference : ReferenceExpressionReferenceBase`1<ReferenceExpressionStub> {
    public bool IsQualified { get; }
    public ReferenceExpressionReference(ReferenceExpressionStub owner);
    public virtual bool get_IsQualified();
    public virtual string GetName();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    protected virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    protected virtual ICSharpArgumentInfo ExtensionArgument(IResolveContext resolveContext);
    [PureAttribute]
private bool IsNameofOperator(ResolveResultWithInfo resolveResult);
    public virtual ResolveResultWithInfo PreResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    [NotNullAttribute]
private ResolveResultWithInfo TryResolveSubpatternMemberAccess(IResolveContext resolveContext);
    [CanBeNullAttribute]
private ResolveResultWithInfo TryResolveNativeInteger(ResolveResultWithInfo resolve);
    [CanBeNullAttribute]
private ISymbolTable GetPatternReferenceNameSymbolTable(IResolveContext resolveContext, ISymbolTable symbolTable);
    [NotNullAttribute]
private ResolveResultWithInfo TryResolveTypeUnderIsExpression(IResolveContext resolveContext, ISymbolTable symbolTable, ResolveResultWithInfo baseResult);
    [CanBeNullAttribute]
private IReferenceExpression GetTopmostReferenceExpression(bool allowQuestionMark);
    protected virtual bool IsUnderIsExpression();
    [CanBeNullAttribute]
private ResolveResultWithInfo TryResolveExternAlias(ISymbolTable symbolTable);
    [CanBeNullAttribute]
private ResolveResultWithInfo TryResolveTransparentProperty(IResolveContext context, ResolveResultWithInfo baseResult);
    [CanBeNullAttribute]
private ResolveResultWithInfo ResolveInTransparentVariableFromMultitype(IResolveContext context, IMultitype multitype, ITransparentVariable variable);
    [CanBeNullAttribute]
private ResolveResultWithInfo ResolveInTransparentVariableFromAnonymousType(IResolveContext context, ICSharpAnonymousType anonymousType, ITransparentVariable variable);
    [CanBeNullAttribute]
private static IClrDeclaredElement ResolveInTransparentVariable(IResolveContext resolveContext, ICSharpAnonymousType anonymousType, Scheme scheme, string name);
    protected virtual ResolveResultWithInfo RefineResolve(IResolveContext resolveContext, ResolveResultWithInfo preResolve);
    private ResolveResultWithInfo ChoosePatternPropertyOrClass(IResolveContext resolveContext, PatternPropertyOrClassPartialResult patternPropertyOrClassPartialResult);
    protected virtual ResolveResultWithInfo RefineResolveErrorType(ResolveResultWithInfo resolveResult, IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual ISymbolTable GetCompletionSymbolTable();
    [CanBeNullAttribute]
private ISymbolTable BuildSymbolTableFromTransparentVariables(IResolveContext resolveContext);
    private static void AddAnonymousProperties(IResolveContext resolveContext, ITypeOwner var, SymbolTable table);
    public sealed virtual Refers RefersToDeclaredElement(IDeclaredElement declaredElement);
    public virtual ResolveResultWithInfo ResolveAsUnqualified(ISymbolTable symbolTable);
    private static bool IsDangerousExpression(ICSharpExpression expression);
    private static bool IsDangerousTupleExpression(ITupleExpression tupleExpression);
    [NotNullAttribute]
private IResolveContext GetNewResolveContext();
    public virtual bool IsValid();
    [CompilerGeneratedAttribute]
private Refers <RefersToDeclaredElement>b__28_0(IDeclaredElement element);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceExpressionReferenceBase`1 : ManagedTwoPhaseReferenceImplBase`1<TExpression> {
    protected ReferenceExpressionReferenceBase`1(TExpression owner);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    [CanBeNullAttribute]
protected abstract virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    [CanBeNullAttribute]
protected abstract virtual ICSharpArgumentInfo ExtensionArgument(IResolveContext resolveContext);
    public virtual IQualifier GetQualifier(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
private static ISymbolFilter GetEnumInitializerFilter(ICSharpExpression expression, bool isNonQualifiedReferenceExpression);
    [NotNullAttribute]
private static ISymbolFilter GetExcludeParametersFilter(ICSharpExpression expression, IResolveContext resolveContext);
    [NotNullAttribute]
private ISymbolFilter[] ReferenceExpressionResolveFilters(string name, IResolveContext resolveContext, IAccessContext context, bool isNonQualified);
    public virtual ResolveResultWithInfo PreResolve(IResolveContext resolveContext, ISymbolTable originalSymbolTable);
    [NotNullAttribute]
[PureAttribute]
private ISymbolFilter[] GetReferenceResolveFilters(IResolveContext resolveContext, string name, IAccessContext accessContext, bool isQualified);
    [CanBeNullAttribute]
[PureAttribute]
private IElementAccessExpression GetContainingElementAccessExpression();
    [NotNullAttribute]
[PureAttribute]
private ResolveResultWithInfo CreatePartialResultForMethodGroup(IResolveContext resolveContext, ResolveResultWithInfo result, IList`1<ISymbolInfo> symbolInfos, string name);
    [NotNullAttribute]
[PureAttribute]
private ResolveResultWithInfo CreatePartialResultForValueVsClassPossibly(IResolveContext resolveContext, ResolveResultWithInfo oldResolveResult, ISymbolTable originalSymbolTable, IAccessContext accessContext, string name, bool isQualified);
    [CanBeNullAttribute]
[PureAttribute]
protected ResolveResultWithInfo ResolveAsReferenceName(IAccessContext accessContext, ISymbolTable symbolTable, string name);
    [NotNullAttribute]
private IType GetPropertyElementType(ITypeOwner typeOwner, IResolveContext resolveContext);
    [NotNullAttribute]
private ResolveResultWithInfo ChoosePropertyOrClass(IResolveContext resolveContext, PropertyOrClassPartialResult propertyOrClassResult, IResolveInfo info);
    [NotNullAttribute]
private ResolveResultWithInfo ChooseMethod(IResolveContext resolveContext, MethodGroupResolveResult methodGroup, IResolveInfo resolveInfo);
    [NotNullAttribute]
internal MethodChooser MethodGroupChooser(IResolveContext resolveContext, MethodGroupResolveResult methodGroup, ResolveErrorType errorType);
    [NotNullAttribute]
private ResolveErrorType MethodGroupResolveInfo(IList`1<DeclaredElementInstance> candidates);
    [NotNullAttribute]
private ResolveResultWithInfo MethodsForInvalidContext(IResolveContext resolveContext, MethodGroupResolveResult methodGroup);
    protected virtual ResolveResultWithInfo RefineResolve(IResolveContext resolveContext, ResolveResultWithInfo preResolve);
    [NotNullAttribute]
protected virtual ResolveResultWithInfo RefineResolveErrorType(ResolveResultWithInfo resolveResult, IResolveContext resolveContext);
    [NotNullAttribute]
private ResolveResultWithInfo RefineMethodGroupResolveResult(ResolveResultWithInfo resolveResult, IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual ISymbolTable GetCompletionSymbolTable();
    public virtual string Dump();
    [CompilerGeneratedAttribute]
internal static bool <ChoosePropertyOrClass>g__HasBothInstanceAndStaticCandidates|17_1(ResolveResultWithInfo resolveResult);
    [CompilerGeneratedAttribute]
private bool <ChoosePropertyOrClass>g__InStaticContextWherePrimaryConstructorParameterIsNotReallyAccessible|17_2();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceExpressionStub : ReferenceExpressionBase {
    public static short EXPR;
    public static short CSHARP_REFERENCE;
    public static short CSHARP_CONDITIONAL_SIGN;
    public static short CSHARP_REFERENCE_DELIMITER;
    public static short TYPE_ARGS;
    private ReferenceExpressionReference modreq(System.Runtime.CompilerServices.IsVolatile) myManagedReference;
    public NodeType NodeType { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode Delimiter { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IPrimaryExpression QualifierExpressionInternal { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    public ICSharpArgument ContainerArgument { get; }
    public bool IsQualified { get; }
    public IReferenceExpressionReference Reference { get; }
    public bool HasConditionalAccessSign { get; }
    public ICSharpExpression ConditionalQualifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IConditionalAccessSign get_ConditionalAccessSign();
    public virtual ITokenNode get_Delimiter();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IPrimaryExpression get_QualifierExpressionInternal();
    public virtual ITypeArgumentList get_TypeArgumentList();
    public virtual ICSharpArgument get_ContainerArgument();
    public virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public virtual string ToString();
    protected virtual ITypeArgumentList GetTypeArgumentList();
    protected virtual void PreInit();
    public sealed virtual bool get_IsQualified();
    public sealed virtual IReferenceExpressionReference get_Reference();
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    [NotNullAttribute]
private IExpressionType ComputeDiscardReferenceType(IResolveContext resolveContext);
    [NotNullAttribute]
private static ISubstitution GetPureMethodSubstitution(ITypeParametersOwner method, ISubstitution inferredSubstitution);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    [PureAttribute]
private static bool CanBeConstantValue(IReferenceExpression expression, IResolveContext resolveContext);
    [NotNullAttribute]
private ConstantValue GetConstantValueImpl(IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
    public sealed virtual ICSharpExpression SetQualifierExpression(ICSharpExpression expression);
    public sealed virtual bool get_HasConditionalAccessSign();
    public sealed virtual ICSharpExpression get_ConditionalQualifier();
    public sealed virtual ICSharpExpression SetConditionalQualifier(ICSharpExpression expression);
    public sealed virtual void SetConditionalAccessSign(bool value);
    public sealed virtual IExpressionType UnliftedExpressionType();
    public sealed virtual void SetTypeArguments(ICollection`1<IType> typeArguments);
    [CompilerGeneratedAttribute]
private bool <Classify>g__IsStructMemberIsClassifiedAsVariable|35_0(ITypeMember typeMember, <>c__DisplayClass35_0& );
    [CompilerGeneratedAttribute]
private bool <Classify>g__IsStructMemberIsClassifiedAsReadOnlyVariable|35_1(ITypeMember typeMember, <>c__DisplayClass35_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceName : ReferenceNameStub {
    internal ReferenceName(TreeElement identifier);
    [NotNullAttribute]
public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    [CanBeNullAttribute]
public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceNameQualifiedNameComparer : object {
    [NotNullAttribute]
public static IEqualityComparer`1<IReferenceName> Instance;
    private static ReferenceNameQualifiedNameComparer();
    public sealed virtual bool Equals(IReferenceName x, IReferenceName y);
    public sealed virtual int GetHashCode(IReferenceName obj);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceNameStub : CSharpCompositeElement {
    public static short QUALIFIER;
    public static short CSHARP_REFERENCE_DELIMITER;
    public static short CSHARP_REFERENCE;
    public static short TYPE_ARGS;
    private ReferenceNameReference modreq(System.Runtime.CompilerServices.IsVolatile) myReference;
    public NodeType NodeType { get; }
    public ITokenNode Delimiter { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IReferenceName QualifierInternal { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    public IList`1<IType> TypeArguments { get; }
    public string ShortName { get; }
    public string QualifiedName { get; }
    public int TypeArgumentsNumber { get; }
    public IReferenceNameReference Reference { get; }
    public bool Resolved { get; }
    public IReferenceName Qualifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Delimiter();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IReferenceName get_QualifierInternal();
    public virtual ITypeArgumentList get_TypeArgumentList();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    protected virtual void PreInit();
    public virtual IList`1<IType> get_TypeArguments();
    public sealed virtual string get_ShortName();
    public sealed virtual string get_QualifiedName();
    public sealed virtual void AppendQualifiedName(StringBuilder builder);
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public virtual int get_TypeArgumentsNumber();
    public sealed virtual IReferenceNameReference get_Reference();
    public virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    [CanBeNullAttribute]
private ISymbolTable UsingListReferenceSymbolTable(IResolveResult resolveResult);
    [CanBeNullAttribute]
private ISymbolTable ExtendsListReferenceSymbolTable(IResolveResult resolveResult);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceNameStub/<GetSuperTypes>d__38")]
private static IEnumerable`1<ValueTuple`2<ITypeElement, ISubstitution>> GetSuperTypes(ITypeElement targetTypeElement, ITypeElement baseTypeBeingProcessed);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public virtual IReferenceName get_Qualifier();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual IReferenceName ReplaceBy(IReferenceName name);
    public sealed virtual IReferenceName SetQualifier(IReferenceName newQualifier);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReferenceTypeConstraint : CSharpCompositeElement {
    public static short KEYWORD;
    public static short NULLABLE;
    public NodeType NodeType { get; }
    public ITokenNode Keyword { get; }
    public INullableTypeMark NullableMark { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Keyword();
    public virtual INullableTypeMark get_NullableMark();
    public virtual INullableTypeMark SetNullableMark(INullableTypeMark param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RefExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short EXPR;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode RefKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_RefKeyword();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public sealed virtual ReferenceKind GetExpectedReferenceKind(IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
internal static ReferenceKind <GetExpectedReferenceKind>g__GetReferenceKindByParameterKind|17_0(ParameterKind parameterKind);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReftypeExpression : CSharpExpressionBase {
    public static short REFTYPE_KEYWORD;
    public static short CSHARP_LPAR;
    public static short EXPR;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode ReftypeKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_ReftypeKeyword();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RefvalueExpression : CSharpExpressionBase {
    public static short REFVALUE_KEYWORD;
    public static short CSHARP_LPAR;
    public static short EXPR;
    public static short CSHARP_COMMA;
    public static short CSHARP_TYPE;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode Comma { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode RefvalueKeyword { get; }
    public ITypeUsage TargetType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Comma();
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_RefvalueKeyword();
    public virtual ITypeUsage get_TargetType();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual ITypeUsage SetTargetType(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RelationalExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.RelationalPattern : CSharpCompositeElement {
    public static short OP_SIGN;
    public static short CSHARP_CONSTANT_EXPRESSION;
    private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    public NodeType NodeType { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode Sign { get; }
    public RelationalPatternKind Kind { get; }
    public ConstantValue ConstantValue { get; }
    public ConstantValue CachedConstantValue { get; public set; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Operand();
    public virtual ITokenNode get_Sign();
    public virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual RelationalPatternKind get_Kind();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual ConstantValue get_CachedConstantValue();
    public sealed virtual void set_CachedConstantValue(ConstantValue value);
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ResourceAcquisitionExpressionsList : CSharpCompositeElement {
    public static short EXPR;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> Expressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ExpressionsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ICSharpExpression> get_Expressions();
    public virtual TreeNodeEnumerable`1<ICSharpExpression> get_ExpressionsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ReturnStatement : StatementBase {
    public static short KEYWORD;
    public static short EXPR;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ITokenNode ReturnKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ICSharpExpression Value { get; }
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ReturnKeyword();
    public virtual ITokenNode get_Semicolon();
    public virtual ICSharpExpression get_Value();
    public virtual ICSharpExpression SetValue(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual bool get_IntroducesScope();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SelectReference : QueryChainReferenceBase`1<QuerySelectClause> {
    private static string SELECT;
    public SelectReference(QuerySelectClause owner);
    public virtual ICSharpArgumentInfo[] GetArguments();
    public virtual string GetName();
    public virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ShiftExpression : BinaryExpressionBase {
    public static short CSHARP_OP1;
    public static short OP_SIGN;
    public static short CSHARP_OP2;
    private ICSharpExpression myCachedLeftOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedLeftOperandValid;
    private ICSharpExpression myCachedRightOperand;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedRightOperandValid;
    public NodeType NodeType { get; }
    public ICSharpExpression LeftOperand { get; }
    protected ICSharpExpression _LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    public ICSharpExpression RightOperand { get; }
    protected ICSharpExpression _RightOperand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public sealed virtual ICSharpExpression get_LeftOperand();
    protected virtual ICSharpExpression get__LeftOperand();
    public virtual ITokenNode get_OperatorSign();
    public sealed virtual ICSharpExpression get_RightOperand();
    protected virtual ICSharpExpression get__RightOperand();
    public virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SignOperatorDeclaration : SignOperatorDeclarationStub {
    protected virtual IDeclaredElement CreateDeclaredElement();
    public virtual IBlock SetBody(IBlock param);
    [CanBeNullAttribute]
public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SignOperatorDeclarationStub : OperatorDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short CSHARP_TYPE;
    public static short CSHARP_QUALIFIER;
    public static short OPERATOR_KEYWORD;
    public static short CHECKED_KEYWORD;
    public static short OPERATOR_SIGN;
    public static short CSHARP_LPAR;
    public static short PARAMS;
    public static short CSHARP_RPAR;
    public static short CSHARP_BLOCK;
    public static short ARROW_CLAUSE;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IArrowExpressionClause ArrowClause { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IBlock Body { get; }
    public ITokenNode CheckedKeyword { get; }
    public IOwnerQualification InterfaceQualification { get; }
    public ITokenNode LPar { get; }
    public ITokenNode OperatorKeyword { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IReferenceName InterfaceQualificationReference { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode OperatorSign { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public string DeclaredName { get; }
    public bool IsChecked { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public bool IsIterator { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrowExpressionClause get_ArrowClause();
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IBlock get_Body();
    public virtual ITokenNode get_CheckedKeyword();
    public virtual IOwnerQualification get_InterfaceQualification();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_OperatorKeyword();
    public virtual IFormalParameterList get_Params();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Semicolon();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IReferenceName get_InterfaceQualificationReference();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual ITokenNode get_OperatorSign();
    public virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    public virtual IBlock SetBody(IBlock param);
    public virtual IOwnerQualification SetInterfaceQualification(IOwnerQualification param);
    public virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IFormalParameterList SetParams(IFormalParameterList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public virtual TreeTextRange GetNameRange();
    public virtual string get_DeclaredName();
    public sealed virtual bool get_IsChecked();
    protected internal virtual string GetShortNameOfDeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public virtual void SetName(string name);
    public sealed virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
    public sealed virtual bool get_IsIterator();
    public sealed virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SingleVariableDesignation : LocalVariableDeclarationBase {
    public static short CSHARP_NAME;
    [ThreadStaticAttribute]
private static JetHashSet`1<ICSharpLocalVariable> ourTypeCalculationsInProgress;
    public NodeType NodeType { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ICSharpLocalVariable DeclaredElement { get; }
    public bool IsVar { get; }
    public string DeclaredName { get; }
    [NotNullAttribute]
private IDeclaredElement JetBrains.ReSharper.Psi.Tree.IDeclaration.DeclaredElement { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsWritable { get; }
    public ScopedKind Scope { get; }
    protected IType ExplicitlyDeclaredType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public sealed virtual ICSharpLocalVariable get_DeclaredElement();
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    public virtual bool get_IsVar();
    public sealed virtual void SetVar();
    public virtual string get_DeclaredName();
    public virtual TreeTextRange GetNameRange();
    public virtual void SetName(string name);
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.Tree.IDeclaration.get_DeclaredElement();
    public virtual void SetType(IType type);
    public virtual ReferenceKind get_ReferenceKind();
    public virtual bool get_IsWritable();
    public virtual ScopedKind get_Scope();
    protected virtual IType get_ExplicitlyDeclaredType();
    protected virtual IType GetImplicitType(IResolveContext resolveContext);
    public virtual string ToString();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SlicePattern : CSharpCompositeElement {
    public static short OP_SIGN;
    public static short CSHARP_PATTERN;
    [NullableAttribute("1")]
private MyRangeIndexerReference myRangeIndexerReference;
    public NodeType NodeType { get; }
    public ITokenNode OperatorSign { get; }
    public IPattern Pattern { get; }
    [NullableAttribute("1")]
public IListPatternReference RangeIndexerReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_OperatorSign();
    public virtual IPattern get_Pattern();
    public virtual IPattern SetPattern(IPattern param);
    public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual IListPatternReference get_RangeIndexerReference();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    [NullableContextAttribute("1")]
public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    [NullableContextAttribute("2")]
public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SpecificCatchClause : CSharpCompositeElement {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short CSHARP_TYPE;
    public static short DECL;
    public static short CSHARP_RPAR;
    public static short CSHARP_CONDITION;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public IBlock Body { get; }
    public ITokenNode CatchKeyword { get; }
    public ICatchVariableDeclaration ExceptionDeclaration { get; }
    public ITypeUsage ExceptionTypeUsage { get; }
    public IExceptionFilterClause Filter { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ICSharpExpression FilterCondition { get; }
    public IDeclaredType ExceptionType { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Body();
    public virtual ITokenNode get_CatchKeyword();
    public virtual ICatchVariableDeclaration get_ExceptionDeclaration();
    public virtual ITypeUsage get_ExceptionTypeUsage();
    public virtual IExceptionFilterClause get_Filter();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ICSharpExpression get_FilterCondition();
    public virtual IBlock SetBody(IBlock param);
    public virtual ICatchVariableDeclaration SetExceptionDeclaration(ICatchVariableDeclaration param);
    public virtual ITypeUsage SetExceptionTypeUsage(ITypeUsage param);
    public virtual IExceptionFilterClause SetFilter(IExceptionFilterClause param);
    public virtual ICSharpExpression SetFilterCondition(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual IDeclaredType get_ExceptionType();
    public sealed virtual TCatchClause ReplaceBy(TCatchClause clause);
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual void SetCaughtType(IType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SpreadElement : CSharpCompositeElement {
    public static short OP_SIGN;
    public static short EXPR;
    private MyGetEnumeratorReference myGetEnumeratorReference;
    private MyMoveNextReference myMoveNextReference;
    private MyCurrentReference myCurrentReference;
    private MyCollectionExpressionAddReference myAddReference;
    private MyLengthOrCountReference myLengthOrCountReference;
    private MyParamsDefaultConstructorReference myParamsDefaultConstructorReference;
    private MyParamsCreateMethodReference myParamsCreateMethodReference;
    private MyParamsAddReference myParamsAddReference;
    [NullableAttribute("0")]
public NodeType NodeType { get; }
    [NullableAttribute("0")]
public ICSharpExpression Collection { get; }
    [NullableAttribute("0")]
public ITokenNode OperatorSign { get; }
    public IForeachPatternReference GetEnumeratorReference { get; }
    public IForeachPatternReference MoveNextReference { get; }
    public IForeachPatternReference CurrentReference { get; }
    public ICSharpInvocationReference AddReference { get; }
    public IReference ParamsDefaultConstructorReference { get; }
    public IReference ParamsCreateMethodReference { get; }
    public IReference ParamsAddReference { get; }
    public IReference CountOrLengthReference { get; }
    public TreeTextRange IterationReferencesRange { get; }
    public bool IsAwait { get; }
    [NullableAttribute("2")]
private ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.Collection { get; }
    [NullableContextAttribute("0")]
public virtual NodeType get_NodeType();
    [NullableContextAttribute("0")]
public virtual void Accept(TreeNodeVisitor visitor);
    [NullableContextAttribute("0")]
public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    [NullableContextAttribute("0")]
public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    [NullableContextAttribute("0")]
public virtual short GetChildRole(TreeElement child);
    [NullableContextAttribute("0")]
public virtual ICSharpExpression get_Collection();
    [NullableContextAttribute("0")]
public virtual ITokenNode get_OperatorSign();
    [NullableContextAttribute("0")]
public virtual ICSharpExpression SetCollection(ICSharpExpression param);
    [NullableContextAttribute("0")]
public virtual string ToString();
    public sealed virtual IForeachPatternReference get_GetEnumeratorReference();
    public sealed virtual IForeachPatternReference get_MoveNextReference();
    public sealed virtual IForeachPatternReference get_CurrentReference();
    public sealed virtual ICSharpInvocationReference get_AddReference();
    public sealed virtual IReference get_ParamsDefaultConstructorReference();
    public sealed virtual IReference get_ParamsCreateMethodReference();
    public sealed virtual IReference get_ParamsAddReference();
    public sealed virtual IReference get_CountOrLengthReference();
    public sealed virtual TreeTextRange get_IterationReferencesRange();
    public sealed virtual bool get_IsAwait();
    [NullableContextAttribute("2")]
private sealed virtual override ICSharpExpression JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner.get_Collection();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    [NullableContextAttribute("2")]
private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetAccessContainingTypeElement();
    private sealed virtual override Staticness JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetStaticness();
    private sealed virtual override QualifierKind JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetQualifierKind();
    [NullableContextAttribute("2")]
private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetQualifierTypeElement();
    private static bool IsIgnoredParamsCollectionCreation(SpreadElement spreadElement, IType paramsCollectionType, IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.StackAllocExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short CSHARP_TYPE;
    public static short CSHARP_LBRACKET;
    public static short CSHARP_RBRACKET;
    public static short CSHARP_INITIALIZER;
    public static short EXPR;
    public NodeType NodeType { get; }
    public IArrayInitializer ArrayInitializer { get; }
    public ICSharpExpression DimExpr { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ITokenNode StackallocKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public IType PointerType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayInitializer get_ArrayInitializer();
    public virtual ICSharpExpression get_DimExpr();
    public virtual ITokenNode get_LBracket();
    public virtual ITokenNode get_RBracket();
    public virtual ITokenNode get_StackallocKeyword();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IArrayInitializer SetArrayInitializer(IArrayInitializer param);
    public virtual ICSharpExpression SetDimExpr(ICSharpExpression param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual IType Type(IResolveContext resolveContext);
    public sealed virtual IType get_PointerType();
    public sealed virtual void SetPointerType(IPointerType pointerType);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.StartRegion : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short MESSAGE;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode Message { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public string Name { get; }
    public IEndRegion EndRegion { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_Message();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public sealed virtual string get_Name();
    public sealed virtual IEndRegion get_EndRegion();
    public virtual bool IsFiltered();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.StatementBase : CSharpCompositeElement {
    [CompilerGeneratedAttribute]
private VariablesInfo <HasVariables>k__BackingField;
    internal VariablesInfo HasVariables { get; internal set; }
    public bool CanBeEmbedded { get; }
    [CompilerGeneratedAttribute]
internal VariablesInfo get_HasVariables();
    [CompilerGeneratedAttribute]
internal void set_HasVariables(VariablesInfo value);
    protected virtual void ClearCachedData();
    public sealed virtual TStatement ReplaceBy(TStatement statement);
    public virtual bool get_CanBeEmbedded();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.StructDeclaration : StructDeclarationStub {
    [NotNullAttribute]
public virtual IClassBody SetBody(IClassBody param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.StructDeclarationStub : ClassLikeDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short MODIFIERS;
    public static short KEYWORD;
    public static short CSHARP_NAME;
    public static short TYPE_PARAMETERS_LIST;
    public static short CONSTRUCTOR;
    public static short CSHARP_BASE;
    public static short CONSTRAINTS;
    public static short CSHARP_BLOCK;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public IClassBody Body { get; }
    public IExtendsList ImplementedInterfacesList { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IPrimaryConstructorDeclaration PrimaryConstructorDeclaration { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode StructKeyword { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IClassBody BodyInternal { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> ImplementedInterfaceUsages { get; }
    public TreeNodeEnumerable`1<ITypeUsage> ImplementedInterfaceUsagesEnumerable { get; }
    public TreeNodeCollection`1<IIndexerDeclaration> IndexerDeclarations { get; }
    public TreeNodeEnumerable`1<IIndexerDeclaration> IndexerDeclarationsEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ModifiersInternal { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersInternalEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IOperatorDeclaration> OperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IOperatorDeclaration> OperatorDeclarationsEnumerable { get; }
    public ICSharpNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParametersEnumerable { get; }
    public ITokenNode TypeDeclarationKeyword { get; }
    public IExtendsList ExtendsList { get; }
    public TreeNodeCollection`1<ITypeUsage> SuperTypeUsageNodes { get; }
    public IReadOnlyList`1<ITypeDeclaration> TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> DestructorDeclarations { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorDeclarationsEnumerable { get; }
    public bool IsByRefLike { get; }
    public string DeclaredName { get; }
    private ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.DeclaredElement { get; }
    private IStruct JetBrains.ReSharper.Psi.CSharp.Tree.IStructDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IMemberOwnerBody JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration.Body { get; }
    public TreeNodeCollection`1<IClassMemberDeclaration> ClassMemberDeclarations { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual IClassBody get_Body();
    public virtual IExtendsList get_ImplementedInterfacesList();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IPrimaryConstructorDeclaration get_PrimaryConstructorDeclaration();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_StructKeyword();
    public virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public virtual ITypeParameterOfTypeList get_TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IClassBody get_BodyInternal();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IFieldDeclaration> get_FieldDeclarations();
    public virtual TreeNodeEnumerable`1<IFieldDeclaration> get_FieldDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeUsage> get_ImplementedInterfaceUsages();
    public virtual TreeNodeEnumerable`1<ITypeUsage> get_ImplementedInterfaceUsagesEnumerable();
    public virtual TreeNodeCollection`1<IIndexerDeclaration> get_IndexerDeclarations();
    public virtual TreeNodeEnumerable`1<IIndexerDeclaration> get_IndexerDeclarationsEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ModifiersInternal();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersInternalEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_NestedTypeDeclarations();
    public virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IOperatorDeclaration> get_OperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IOperatorDeclaration> get_OperatorDeclarationsEnumerable();
    public virtual ICSharpNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParametersEnumerable();
    public virtual IClassBody SetBody(IClassBody param);
    public virtual IExtendsList SetImplementedInterfacesList(IExtendsList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IPrimaryConstructorDeclaration SetPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual string ToString();
    public sealed virtual ITokenNode get_TypeDeclarationKeyword();
    public sealed virtual IExtendsList get_ExtendsList();
    public virtual TreeNodeCollection`1<ITypeUsage> get_SuperTypeUsageNodes();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    public sealed virtual IExtendsList GetOrCreateExtendsList();
    public sealed virtual TreeNodeCollection`1<IDestructorDeclaration> get_DestructorDeclarations();
    public sealed virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorDeclarationsEnumerable();
    public sealed virtual bool get_IsByRefLike();
    public sealed virtual void SetIsByRefLike(bool value);
    public virtual void SetSealed(bool value);
    public virtual void SetStatic(bool value);
    public virtual string get_DeclaredName();
    public sealed virtual bool CanBindTo(ITypeElement typeElement);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration.get_DeclaredElement();
    private sealed virtual override IStruct JetBrains.ReSharper.Psi.CSharp.Tree.IStructDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IMemberOwnerBody JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration.get_Body();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual TreeNodeCollection`1<IClassMemberDeclaration> get_ClassMemberDeclarations();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration typeParameterDeclaration);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual void AddSuperInterface(IDeclaredType interfaceType, bool before);
    public sealed virtual void RemoveSuperInterface(IDeclaredType interfaceType);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public sealed virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
    private sealed virtual override ICSharpTypeDeclaration JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration.GetContainingTypeDeclaration();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.Subpattern : CSharpCompositeElement {
    public static short EXPR;
    public static short CSHARP_COLON;
    public static short PATTERN;
    public NodeType NodeType { get; }
    public ICSharpExpression AccessExpression { get; }
    public ITokenNode Colon { get; }
    public IPattern Pattern { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_AccessExpression();
    public virtual ITokenNode get_Colon();
    public virtual IPattern get_Pattern();
    public virtual ICSharpExpression SetAccessExpression(ICSharpExpression param);
    public virtual IPattern SetPattern(IPattern param);
    public virtual string ToString();
    [PureAttribute]
[NotNullAttribute]
internal IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual void SetSimpleMemberAccessName(string name);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SuppressNullableWarningExpression : CSharpExpressionBase {
    public static short OPERAND;
    public static short OPERATOR;
    public NodeType NodeType { get; }
    public IPrimaryExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPrimaryExpression get_Operand();
    public virtual ITokenNode get_OperatorSign();
    public virtual IPrimaryExpression SetOperand(IPrimaryExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SwitchBlock : CSharpCompositeElement {
    public static short CSHARP_LBRACE;
    public static short SECTION;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ISwitchSection> Sections { get; }
    public TreeNodeEnumerable`1<ISwitchSection> SectionsEnumerable { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual TreeNodeCollection`1<ISwitchSection> get_Sections();
    public virtual TreeNodeEnumerable`1<ISwitchSection> get_SectionsEnumerable();
    public virtual string ToString();
    private void EnsureRBrace();
    public sealed virtual ISwitchSection AddSectionBefore(ISwitchSection switchSection, ISwitchSection anchor);
    public sealed virtual ISwitchSection AddSectionAfter(ISwitchSection switchSection, ISwitchSection anchor);
    public sealed virtual void RemoveSection(ISwitchSection switchSection);
    public sealed virtual void RemoveSwitchCaseLabel(ISwitchCaseLabel switchCaseLabel);
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SwitchCaseLabel : CSharpCompositeElement {
    public static short KEYWORD;
    public static short PATTERN;
    public static short GUARD;
    public static short CSHARP_COLON;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public IPatternGuardClause Guard { get; }
    public ITokenNode Keyword { get; }
    public IPattern Pattern { get; }
    public ICSharpExpression ValueExpression { get; }
    public bool IsDefault { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Colon();
    public virtual IPatternGuardClause get_Guard();
    public virtual ITokenNode get_Keyword();
    public virtual IPattern get_Pattern();
    public virtual ICSharpExpression get_ValueExpression();
    public virtual IPatternGuardClause SetGuard(IPatternGuardClause param);
    public virtual IPattern SetPattern(IPattern param);
    public virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual bool get_IsDefault();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SwitchExpression : CSharpExpressionBase {
    public static short CSHARP_CONDITION;
    public static short KEYWORD;
    public static short CSHARP_LBRACE;
    public static short SWITCH_EXPRESSION_ARM;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    [NotNullAttribute]
private CachedPsiValue`1<DecisionDag> myCachedDecisionDag;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ISwitchExpressionArm> Arms { get; }
    public TreeNodeEnumerable`1<ISwitchExpressionArm> ArmsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ICSharpExpression GoverningExpression { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode SwitchKeyword { get; }
    public IEnumerable`1<ICSharpExpression> TargetTypedExpressions { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ISwitchExpressionArm> get_Arms();
    public virtual TreeNodeEnumerable`1<ISwitchExpressionArm> get_ArmsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ICSharpExpression get_GoverningExpression();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual ITokenNode get_SwitchKeyword();
    public virtual ICSharpExpression SetGoverningExpression(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    protected virtual void PreInit();
    public sealed virtual IType GetGoverningType();
    public sealed virtual IType GetGoverningType(IResolveContext resolveContext);
    public sealed virtual ISwitchExpressionArm AddSwitchExpressionArmAfter(ISwitchExpressionArm switchExpressionArm, ISwitchExpressionArm anchor);
    public sealed virtual ISwitchExpressionArm AddSwitchExpressionArmBefore(ISwitchExpressionArm switchExpressionArm, ISwitchExpressionArm anchor);
    public sealed virtual void RemoveSwitchExpressionArm(ISwitchExpressionArm switchExpressionArm);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SwitchExpression/<get_TargetTypedExpressions>d__40")]
public sealed virtual IEnumerable`1<ICSharpExpression> get_TargetTypedExpressions();
    public IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    public sealed virtual DecisionDag GetOrCreateDecisionDag(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SwitchExpressionArm : CSharpCompositeElement {
    public static short PATTERN;
    public static short GUARD;
    public static short LAMBDA_ARROW;
    public static short ARM_EXPRESSION;
    public NodeType NodeType { get; }
    public ITokenNode BodyArrow { get; }
    public ICSharpExpression Expression { get; }
    public IPatternGuardClause Guard { get; }
    public IPattern Pattern { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_BodyArrow();
    public virtual ICSharpExpression get_Expression();
    public virtual IPatternGuardClause get_Guard();
    public virtual IPattern get_Pattern();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual IPatternGuardClause SetGuard(IPatternGuardClause param);
    public virtual IPattern SetPattern(IPattern param);
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SwitchSection : CSharpCompositeElement {
    public static short CASES;
    public static short STATEMENT;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ISwitchCaseLabel> CaseLabels { get; }
    public TreeNodeEnumerable`1<ISwitchCaseLabel> CaseLabelsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpStatement> Statements { get; }
    public TreeNodeEnumerable`1<ICSharpStatement> StatementsEnumerable { get; }
    [CanBeNullAttribute]
private ITreeNode LastCaseNode { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ISwitchCaseLabel> get_CaseLabels();
    public virtual TreeNodeEnumerable`1<ISwitchCaseLabel> get_CaseLabelsEnumerable();
    public virtual TreeNodeCollection`1<ICSharpStatement> get_Statements();
    public virtual TreeNodeEnumerable`1<ICSharpStatement> get_StatementsEnumerable();
    public virtual string ToString();
    public sealed virtual ICSharpStatementsRange GetAllStatementsRange();
    public sealed virtual void RemoveStatementsRange(ICSharpStatementsRange range);
    private ITreeNode get_LastCaseNode();
    public sealed virtual ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange range, ICSharpStatement anchor);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange range, ICSharpStatement anchor);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange range, ICSharpStatementsRange anchor);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange range, ICSharpStatementsRange anchor);
    private static ICSharpStatementsRange CreateStatementsRange(ICSharpStatement statement);
    public sealed virtual TStatement AddStatementBeforeRange(TStatement param, ICSharpStatementsRange anchor);
    public sealed virtual TStatement AddStatementAfterRange(TStatement param, ICSharpStatementsRange anchor);
    public sealed virtual TStatement AddStatementAfter(TStatement param, ICSharpStatement anchor);
    public sealed virtual TStatement AddStatementBefore(TStatement param, ICSharpStatement anchor);
    public sealed virtual void RemoveStatement(ICSharpStatement param);
    public sealed virtual ISwitchCaseLabel AddCaseLabelAfter(ISwitchCaseLabel caseLabel, ISwitchCaseLabel anchor);
    public sealed virtual ISwitchCaseLabel AddCaseLabelBefore(ISwitchCaseLabel caseLabel, ISwitchCaseLabel anchor);
    public sealed virtual void RemoveCaseLabel(ISwitchCaseLabel caseLabel);
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.SwitchStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short GOVERNING_EXRESSION;
    public static short CSHARP_RPAR;
    public static short TUPLE_GOVERNING_EXPRESSION;
    public static short SWITCH_BLOCK;
    [NotNullAttribute]
private CachedPsiValue`1<DecisionDag> myCachedDecisionDag;
    public NodeType NodeType { get; }
    public ISwitchBlock Block { get; }
    public ITokenNode LParInternal { get; }
    public ITokenNode RParInternal { get; }
    public ICSharpExpression SimpleGoverningExpressionInternal { get; }
    public ITokenNode SwitchKeyword { get; }
    public ITupleExpression TupleGoverningExpressionInternal { get; }
    public TreeNodeCollection`1<ISwitchSection> Sections { get; }
    public TreeNodeEnumerable`1<ISwitchSection> SectionsEnumerable { get; }
    public ITokenNode LParenth { get; }
    public ITokenNode RParenth { get; }
    public ICSharpExpression GoverningExpression { get; }
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ISwitchBlock get_Block();
    public virtual ITokenNode get_LParInternal();
    public virtual ITokenNode get_RParInternal();
    public virtual ICSharpExpression get_SimpleGoverningExpressionInternal();
    public virtual ITokenNode get_SwitchKeyword();
    public virtual ITupleExpression get_TupleGoverningExpressionInternal();
    public virtual TreeNodeCollection`1<ISwitchSection> get_Sections();
    public virtual TreeNodeEnumerable`1<ISwitchSection> get_SectionsEnumerable();
    public virtual ISwitchBlock SetBlock(ISwitchBlock param);
    public virtual string ToString();
    public sealed virtual ITokenNode get_LParenth();
    public sealed virtual ITokenNode get_RParenth();
    public sealed virtual ICSharpExpression get_GoverningExpression();
    protected virtual void PreInit();
    public sealed virtual IType GetGoverningType();
    public sealed virtual IType GetGoverningType(IResolveContext resolveContext);
    public sealed virtual bool get_IntroducesScope();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual ICSharpExpression SetGoverningExpression(ICSharpExpression governingExpression);
    public sealed virtual DecisionDag GetOrCreateDecisionDag(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ThisExpression : CSharpExpressionBase {
    public static short THIS;
    public NodeType NodeType { get; }
    public ITokenNode This { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_This();
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ThrowExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short EXPR;
    public NodeType NodeType { get; }
    public ICSharpExpression Exception { get; }
    public ITokenNode ThrowKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Exception();
    public virtual ITokenNode get_ThrowKeyword();
    public virtual ICSharpExpression SetException(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ThrowStatement : StatementBase {
    public static short KEYWORD;
    public static short EXPR;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ICSharpExpression Exception { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode ThrowKeyword { get; }
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpExpression get_Exception();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_ThrowKeyword();
    public virtual ICSharpExpression SetException(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual bool get_IntroducesScope();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TopLevelCode : CSharpCompositeElement {
    public static short STATEMENT;
    private static string SYMBOL_NAME;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private CachedPsiValue`1<ValueTuple`2<IType, bool>> myCachedReturnTypeInfo;
    [CompilerGeneratedAttribute]
private IDeclaredElement <CacheDeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameter <ArgsParameter>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private static Func`2<TopLevelCode, ValueTuple`2<IType, bool>> ourCalcReturnTypeInfo;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ICSharpStatement> Statements { get; }
    public TreeNodeEnumerable`1<ICSharpStatement> StatementsEnumerable { get; }
    public bool IsOnValidPosition { get; }
    public ITopLevelEntryPoint DeclaredElement { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.Tree.IDeclaration.DeclaredElement { get; }
    public IDeclaredElement CacheDeclaredElement { get; public set; }
    public IClass ContainingType { get; }
    public IParameter ArgsParameter { get; private set; }
    public IList`1<IParameter> Parameters { get; }
    public bool IsAsync { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public string DeclaredName { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public IEnumerable`1<ICSharpHashableDeclaration> Children { get; }
    public bool IsInternal { get; }
    private static TopLevelCode();
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ICSharpStatement> get_Statements();
    public virtual TreeNodeEnumerable`1<ICSharpStatement> get_StatementsEnumerable();
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual bool get_IsOnValidPosition();
    public sealed virtual ITopLevelEntryPoint get_DeclaredElement();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.Tree.IDeclaration.get_DeclaredElement();
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredElement get_CacheDeclaredElement();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CacheDeclaredElement(IDeclaredElement value);
    public IClass get_ContainingType();
    [CompilerGeneratedAttribute]
public sealed virtual IParameter get_ArgsParameter();
    [CompilerGeneratedAttribute]
private void set_ArgsParameter(IParameter value);
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual bool get_IsAsync();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual string get_DeclaredName();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public sealed virtual TreeTextRange GetNameRange();
    public sealed virtual void SetName(string name);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Tree.IDeclaration.IsSynthetic();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.IsSynthetic();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    private sealed virtual override XmlNode JetBrains.ReSharper.Psi.IDeclaredElement.GetXMLDoc(bool inherit);
    private sealed virtual override XmlNode JetBrains.ReSharper.Psi.Tree.IXmlDocOwnerTreeNode.GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    [NotNullAttribute]
[PureAttribute]
private IReadOnlyList`1<IDeclaredElement> GetLocalElements(bool includeLabels);
    [PureAttribute]
private ValueTuple`2<bool, bool> ScanStatements();
    public sealed virtual ICSharpStatementsRange GetAllStatementsRange();
    public sealed virtual void RemoveStatementsRange(ICSharpStatementsRange range);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange range, ICSharpStatement anchor);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange range, ICSharpStatement anchor);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange range, ICSharpStatementsRange anchor);
    public sealed virtual ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange range, ICSharpStatementsRange anchor);
    private static ICSharpStatementsRange CreateStatementsRange(ICSharpStatement statement);
    public sealed virtual TStatement AddStatementBeforeRange(TStatement param, ICSharpStatementsRange anchor);
    public sealed virtual TStatement AddStatementAfterRange(TStatement param, ICSharpStatementsRange anchor);
    public sealed virtual TStatement AddStatementAfter(TStatement param, ICSharpStatement anchor);
    public sealed virtual TStatement AddStatementBefore(TStatement param, ICSharpStatement anchor);
    public sealed virtual void RemoveStatement(ICSharpStatement param);
    public sealed virtual Hash CalcHash();
    public sealed virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedNames);
    public sealed virtual IEnumerable`1<ICSharpHashableDeclaration> get_Children();
    public sealed virtual bool get_IsInternal();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
internal static IType <.cctor>g__CreateTaskOfInt|92_1(<>c__DisplayClass92_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TryStatement : StatementBase {
    public static short KEYWORD1;
    public static short CSHARP_BLOCK;
    public static short CATCH;
    public static short KEYWORD2;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ICatchClause> Catches { get; }
    public TreeNodeEnumerable`1<ICatchClause> CatchesEnumerable { get; }
    public IBlock FinallyBlock { get; }
    public ITokenNode FinallyKeyword { get; }
    public IBlock Try { get; }
    public ITokenNode TryKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ICatchClause> get_Catches();
    public virtual TreeNodeEnumerable`1<ICatchClause> get_CatchesEnumerable();
    public virtual IBlock get_FinallyBlock();
    public virtual ITokenNode get_FinallyKeyword();
    public virtual IBlock get_Try();
    public virtual ITokenNode get_TryKeyword();
    public virtual IBlock SetFinallyBlock(IBlock param);
    public virtual IBlock SetTry(IBlock param);
    public virtual string ToString();
    public sealed virtual TCatchClause AddCatchClause(TCatchClause clause);
    public sealed virtual void RemoveCatchClause(ICatchClause clause);
    [CanBeNullAttribute]
private sealed virtual override IBlock JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement.SetFinallyBlock(IBlock finallyBlock);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TupleComponent : CSharpCompositeElement {
    public static short PARAMETER_NAME;
    public static short CSHARP_COLON;
    public static short VALUE;
    private TupleComponentReference myNamedTupleComponentReference;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public ICSharpIdentifier NameIdentifierInternal { get; }
    public ICSharpExpression Value { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public string ExplicitComponentName { get; }
    public IReference NamedTupleComponentReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Colon();
    public virtual ICSharpIdentifier get_NameIdentifierInternal();
    public virtual ICSharpExpression get_Value();
    public virtual ICSharpExpression SetValue(ICSharpExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public sealed virtual string get_ExplicitComponentName();
    [CanBeNullAttribute]
private string GetExplicitOrMaybeInferredComponentName(IResolveContext resolveContext);
    public sealed virtual IReference get_NamedTupleComponentReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual void SetComponentName(string name);
    [CanBeNullAttribute]
public sealed virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier newIdentifier);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TupleComponentList : CSharpCompositeElement {
    public static short TUPLE_COMPONENT;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITupleComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleComponent> ComponentsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ITupleComponent> get_Components();
    public virtual TreeNodeEnumerable`1<ITupleComponent> get_ComponentsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TupleExpression : CSharpExpressionBase {
    public static short CSHARP_LPAR;
    public static short TUPLE_COMPONENT_LIST;
    public static short CSHARP_RPAR;
    private TupleExpressionDeconstructionReference myDeconstructionReference;
    public NodeType NodeType { get; }
    public ITupleComponentList ComponentList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITupleComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleComponent> ComponentsEnumerable { get; }
    public IDeconstructionReference DeconstructionReference { get; }
    private bool JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.IsLValue { get; }
    private IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Arguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    [NotNullAttribute]
public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IType> TypeArguments { get; }
    public ICSharpInvocationReference Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITupleComponentList get_ComponentList();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<ITupleComponent> get_Components();
    public virtual TreeNodeEnumerable`1<ITupleComponent> get_ComponentsEnumerable();
    public virtual ITupleComponentList SetComponentList(ITupleComponentList param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IDeconstructionReference get_DeconstructionReference();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual ITupleComponent AddComponentAfter(ITupleComponent component, ITupleComponent anchor);
    public sealed virtual ITupleComponent AddComponentBefore(ITupleComponent component, ITupleComponent anchor);
    public sealed virtual void RemoveComponent(ITupleComponent component);
    public sealed virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    public sealed virtual int IndexOfComponent(ITupleComponent component);
    public sealed virtual IExpressionType GetComponentSourceExpressionType(ITupleComponent component, IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    private sealed virtual override bool JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression.get_IsLValue();
    private sealed virtual override IList`1<ICSharpArgumentInfo> JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Arguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IType> get_TypeArguments();
    public sealed virtual ICSharpInvocationReference get_Reference();
    public sealed virtual CSharpLanguageLevel GetLanguageVersion();
    public sealed virtual string Dump();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    private IReadOnlyList`1<TupleConversionMatch> GetTupleTypeConversions(IType targetNonTupleType, CSharpTypeConversionRule conversionRule, IResolveContext resolveContext);
    [NotNullAttribute]
private IReadOnlyList`1<TupleConversionMatch> ChooseBestConversion(IReadOnlyList`1<TupleConversionMatch> tupleConversions, IResolveContext resolveContext, CSharpTypeConversionRule conversionRule, IType unliftedTargetType);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TupleTypeComponent : CSharpCompositeElement {
    public static short CSHARP_TYPE;
    public static short CSHARP_NAME;
    private TupleComponentReference myNamedTupleComponentReference;
    public NodeType NodeType { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITypeUsage TypeUsage { get; }
    public string ExplicitName { get; }
    public IReference NamedTupleComponentReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITypeUsage get_TypeUsage();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual string get_ExplicitName();
    public sealed virtual void SetComponentName(string name);
    public sealed virtual IReference get_NamedTupleComponentReference();
    public virtual ReferenceCollection GetFirstClassReferences();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TupleTypeComponentList : CSharpCompositeElement {
    public static short COMPONENT;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IEnumerable`1<ITupleTypeComponent> ComponentsEnumerable { get; }
    public IList`1<ITupleTypeComponent> Components { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual string ToString();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TupleTypeComponentList/<get_ComponentsEnumerable>d__15")]
public sealed virtual IEnumerable`1<ITupleTypeComponent> get_ComponentsEnumerable();
    public sealed virtual IList`1<ITupleTypeComponent> get_Components();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TupleTypeUsage : CSharpCompositeElement {
    public static short CSHARP_LPAR;
    public static short COMPONENT_LIST;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITupleTypeComponentList ComponentList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public IList`1<ITupleTypeComponent> Components { get; }
    public IEnumerable`1<ITupleTypeComponent> ComponentsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITupleTypeComponentList get_ComponentList();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITupleTypeComponentList SetComponentList(ITupleTypeComponentList param);
    public sealed virtual ITypeUsage ReplaceBy(ITypeUsage typeUsage);
    public sealed virtual ITupleTypeComponent AddTupleComponentBefore(ITupleTypeComponent component, ITupleTypeComponent anchor);
    public sealed virtual ITupleTypeComponent AddTupleComponentAfter(ITupleTypeComponent component, ITupleTypeComponent anchor);
    public sealed virtual void RemoveTupleComponent(ITupleTypeComponent component);
    public sealed virtual IList`1<ITupleTypeComponent> get_Components();
    public sealed virtual IEnumerable`1<ITupleTypeComponent> get_ComponentsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeArgumentList : CSharpCompositeElement {
    public static short CSHARP_LANGLE;
    public static short CSHARP_TYPE;
    public static short CSHARP_COMMA;
    public static short CSHARP_RANGLE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Commas { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommasEnumerable { get; }
    public ITokenNode LAngle { get; }
    public ITokenNode RAngle { get; }
    public IList`1<ITypeUsage> TypeArgumentNodes { get; }
    public IList`1<IType> TypeArguments { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Commas();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommasEnumerable();
    public virtual ITokenNode get_LAngle();
    public virtual ITokenNode get_RAngle();
    public virtual string ToString();
    public sealed virtual IList`1<ITypeUsage> get_TypeArgumentNodes();
    public sealed virtual void RemoveTypeArgument(ITypeUsage typeUsage);
    public sealed virtual void SetTypeArguments(IType[] types);
    public sealed virtual void SetTypeArguments(ITypeUsage[] typeUsages);
    public sealed virtual IList`1<IType> get_TypeArguments();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeConstraint : CSharpCompositeElement {
    public static short CSHARP_TYPE;
    public NodeType NodeType { get; }
    public ITypeUsage TypeUsage { get; }
    public IType Constraint { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITypeUsage get_TypeUsage();
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IType get_Constraint();
    public sealed virtual void SetType(IType type);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeElementDeclarationBase : TypeMemberDeclarationBase {
    private CachedPsiValue`1<Tuple`3<ISymbolTable, int, SymbolTableMode>> myTableCache;
    [CompilerGeneratedAttribute]
private IDeclaredElement <JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.CacheDeclaredElement>k__BackingField;
    [NotNullAttribute]
public string CLRName { get; }
    public bool IsPartial { get; }
    [CanBeNullAttribute]
public IDocCommentBlock DocCommentBlock { get; }
    public IEnumerable`1<ICSharpHashableDeclaration> Children { get; }
    public int LevelDelta { get; }
    public Tuple`3<ISymbolTable, int, SymbolTableMode> CachedTable { get; public set; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.CacheDeclaredElement { get; private set; }
    public IDeclaredElement DeclaredElement { get; }
    public sealed virtual string get_CLRName();
    public sealed virtual bool get_IsPartial();
    public sealed virtual void SetPartial(bool value);
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock node);
    public virtual IHashableEntityInfo CalcMainHash(string parentQualifiedName, String& qualifiedName);
    public abstract virtual IEnumerable`1<ICSharpHashableDeclaration> get_Children();
    protected virtual Hash CalculateHashInternal();
    public virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public virtual int get_LevelDelta();
    public sealed virtual Tuple`3<ISymbolTable, int, SymbolTableMode> get_CachedTable();
    public sealed virtual void set_CachedTable(Tuple`3<ISymbolTable, int, SymbolTableMode> value);
    protected virtual void PreInit();
    [CompilerGeneratedAttribute]
private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.get_CacheDeclaredElement();
    [CompilerGeneratedAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.set_CacheDeclaredElement(IDeclaredElement value);
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual bool IsSemanticallyPrivate();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeMemberArglistParameterDeclaration : AttributesOwnerDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short ARGLIST_KEYWORD;
    [CanBeNullAttribute]
private IDeclaredElement modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDeclaredElement;
    public NodeType NodeType { get; }
    public ITokenNode ArglistKeyword { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.CachedDeclaredElement { get; private set; }
    public IDeclaredElement DeclaredElement { get; }
    private IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.DeclaredElement { get; }
    public string DeclaredName { get; }
    public bool IsVarArg { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsOptional { get; }
    public ICSharpExpression DefaultValue { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITypeUsage TypeUsage { get; }
    public IType Type { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ArglistKeyword();
    public virtual IAttributeSectionList get_AttributeSectionList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public virtual string ToString();
    protected virtual void PreInit();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.get_CachedDeclaredElement();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.set_CachedDeclaredElement(IDeclaredElement value);
    public sealed virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.get_DeclaredElement();
    public virtual bool IsSynthetic();
    public virtual string get_DeclaredName();
    protected internal virtual string GetShortNameOfDeclaredElement();
    public virtual TreeTextRange GetNameRange();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsOptional();
    public sealed virtual ICSharpExpression get_DefaultValue();
    public sealed virtual ICSharpIdentifier get_NameIdentifier();
    public sealed virtual ITypeUsage get_TypeUsage();
    public virtual void SetName(string name);
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public sealed virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public sealed virtual TParameterDeclaration ReplaceBy(TParameterDeclaration declaration);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeMemberDeclarationBase : AttributesOwnerDeclarationBase {
    public bool HasAccessRights { get; }
    public bool IsAbstract { get; }
    [CanBeNullAttribute]
private IModifiersListOwner ModifiersListOwner { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    private IEnumerable`1<ICSharpHashableDeclaration> JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ICSharpHashableDeclaration.Children { get; }
    private bool JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ICSharpHashableDeclaration.IsInternal { get; }
    public virtual AccessRights GetAccessRights();
    public virtual AccessRights GetSemanticAccessRights();
    public sealed virtual bool get_HasAccessRights();
    public virtual bool get_IsAbstract();
    [CanBeNullAttribute]
[PureAttribute]
public sealed virtual ITypeDeclaration GetContainingTypeDeclaration();
    private IModifiersListOwner get_ModifiersListOwner();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
    public virtual void SetAccessRights(AccessRights rights);
    public virtual void SetAbstract(bool value);
    public virtual void SetSealed(bool value);
    public virtual void SetVirtual(bool value);
    public virtual void SetOverride(bool value);
    public virtual void SetStatic(bool value);
    public virtual void SetReadonly(bool value);
    public virtual void SetExtern(bool value);
    public virtual void SetUnsafe(bool value);
    public virtual void SetVolatile(bool value);
    [PureAttribute]
protected virtual bool HasExecutableCodeBody();
    [PureAttribute]
public virtual bool IsSemanticallyAbstract();
    [PureAttribute]
public virtual bool IsSemanticallyVirtual();
    [PureAttribute]
public virtual bool IsSemanticallyPrivate();
    [PureAttribute]
protected bool IsInterfaceMemberSemanticallyAbstract();
    [PureAttribute]
protected bool IsInterfaceMemberSemanticallyVirtual();
    public virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    [NotNullAttribute]
public virtual IHashableEntityInfo CalcMainHash(string parentQualifiedName, String& qualifiedName);
    protected virtual Hash CalculateHashInternal();
    public sealed virtual Hash CalcHash();
    private sealed virtual override IEnumerable`1<ICSharpHashableDeclaration> JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ICSharpHashableDeclaration.get_Children();
    private sealed virtual override bool JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ICSharpHashableDeclaration.get_IsInternal();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeMemberRegularParameterDeclaration : TypeMemberRegularParameterDeclarationStub {
    [CanBeNullAttribute]
public virtual ICSharpExpression SetDefaultValue(ICSharpExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeMemberRegularParameterDeclarationStub : AttributesOwnerDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short PARAMETER_MODIFIERS;
    public static short CSHARP_TYPE;
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short VALUE;
    private IDeclaredElement modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDeclaredElement;
    private MyParamsDefaultConstructorReference modreq(System.Runtime.CompilerServices.IsVolatile) myParamsDefaultConstructorReference;
    private MyParamsCreateMethodReference modreq(System.Runtime.CompilerServices.IsVolatile) myParamsCreateMethodReference;
    private MyParamsAnyArgumentAddMethodReference modreq(System.Runtime.CompilerServices.IsVolatile) myParamsAnyArgumentAddMethodReference;
    private static Func`2<TypeMemberRegularParameterDeclaration, IDeclaredElement> DeclaredElementFactory;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public ICSharpExpression DefaultValue { get; }
    public ITokenNode EqSign { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IParameterModifiersList ParameterModifiersList { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IReferenceName ScalarTypeName { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.CachedDeclaredElement { get; private set; }
    public IDeclaredElement DeclaredElement { get; }
    private IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.DeclaredElement { get; }
    public string DeclaredName { get; }
    public bool IsVarArg { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsOptional { get; }
    public ITokenNode ParamsKeyword { get; }
    public ITokenNode ThisKeyword { get; }
    public ITokenNode ScopedKeyword { get; }
    public IReference ParamsDefaultConstructorReference { get; }
    public IReference ParamsCreateMethodReference { get; }
    public IReference ParamsAnyArgumentAddMethodReference { get; }
    public IType Type { get; }
    private static TypeMemberRegularParameterDeclarationStub();
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributeSectionList();
    public virtual ICSharpExpression get_DefaultValue();
    public virtual ITokenNode get_EqSign();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IParameterModifiersList get_ParameterModifiersList();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public virtual ICSharpExpression SetDefaultValue(ICSharpExpression param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IParameterModifiersList SetParameterModifiersList(IParameterModifiersList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    protected virtual void ClearCachedData();
    public sealed virtual IReferenceName get_ScalarTypeName();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.get_CachedDeclaredElement();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.set_CachedDeclaredElement(IDeclaredElement value);
    public sealed virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.get_DeclaredElement();
    public sealed virtual void SetType(IType type);
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsOptional();
    public sealed virtual ITokenNode get_ParamsKeyword();
    public sealed virtual ITokenNode get_ThisKeyword();
    public sealed virtual ITokenNode get_ScopedKeyword();
    public sealed virtual IReference get_ParamsDefaultConstructorReference();
    public sealed virtual IReference get_ParamsCreateMethodReference();
    public sealed virtual IReference get_ParamsAnyArgumentAddMethodReference();
    private bool ShouldOwnParamsReferences();
    public sealed virtual IType get_Type();
    public virtual string ToString();
    public sealed virtual TParameterDeclaration ReplaceBy(TParameterDeclaration declaration);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeofExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short CSHARP_TYPE;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeName { get; }
    public ITokenNode TypeofKeyword { get; }
    public IType ArgumentType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITypeUsage get_TypeName();
    public virtual ITokenNode get_TypeofKeyword();
    public virtual ITypeUsage SetTypeName(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual IType get_ArgumentType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeParameterConstraintsClause : CSharpCompositeElement {
    public static short KEYWORD;
    public static short CSHARP_PARAMETER;
    public static short CSHARP_COLON;
    public static short CONSTRAINTS;
    public static short CSHARP_COMMA;
    public NodeType NodeType { get; }
    public ITokenNode Colon { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> Constraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> ConstraintsEnumerable { get; }
    public ITypeParameterReference TypeParameter { get; }
    public ITokenNode WhereKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Colon();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_Constraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_ConstraintsEnumerable();
    public virtual ITypeParameterReference get_TypeParameter();
    public virtual ITokenNode get_WhereKeyword();
    public virtual ITypeParameterReference SetTypeParameter(ITypeParameterReference param);
    public virtual string ToString();
    public sealed virtual TTypeParameterConstraint AddTypeParameterConstraint(TTypeParameterConstraint constraint);
    public sealed virtual void RemoveTypeParameterConstraint(ITypeParameterConstraint constraint);
    public sealed virtual TTypeConstraint AddTypeConstraintAfter(TTypeConstraint constraint, ITypeConstraint anchor);
    public sealed virtual TTypeConstraint AddTypeConstraintBefore(TTypeConstraint constraint, ITypeConstraint anchor);
    private void EnsureColon();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeParameterOfLocalFunctionDeclaration : AttributesOwnerDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short IN_KEYWORD;
    public static short OUT_KEYWORD;
    public static short CSHARP_NAME;
    private object mySync;
    private TypeParameterOfLocalFunction modreq(System.Runtime.CompilerServices.IsVolatile) myDeclaredElement;
    public NodeType NodeType { get; }
    public ITokenNode InKeyword { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode OutKeyword { get; }
    public TreeNodeCollection`1<IAttribute> AttributesInternal { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesInternalEnumerable { get; }
    public ILocalFunctionDeclaration LocalFunctionDeclaration { get; }
    public string DeclaredName { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    [NotNullAttribute]
private ITypeParameter JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration.DeclaredElement { get; }
    public TypeParameterVariance Variance { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_InKeyword();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_OutKeyword();
    public virtual TreeNodeCollection`1<IAttribute> get_AttributesInternal();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesInternalEnumerable();
    public virtual ILocalFunctionDeclaration get_LocalFunctionDeclaration();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual bool IsSynthetic();
    public sealed virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public sealed virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override ITypeParameter JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration.get_DeclaredElement();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual void SetVariance(TypeParameterVariance variance);
    public sealed virtual ITypeParameterConstraintsClause GetConstraintsClause();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeParameterOfLocalFunctionList : CSharpCompositeElement {
    public static short CSHARP_LANGLE;
    public static short CSHARP_PARAMETER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RANGLE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LAngle { get; }
    public ITokenNode RAngle { get; }
    public TreeNodeCollection`1<ITypeParameterOfLocalFunctionDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LAngle();
    public virtual ITokenNode get_RAngle();
    public virtual TreeNodeCollection`1<ITypeParameterOfLocalFunctionDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeParameterOfMethodDeclaration : CSharpDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short IN_KEYWORD;
    public static short OUT_KEYWORD;
    public static short CSHARP_NAME;
    private IDeclaredElement modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDeclaredElement;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public ITokenNode InKeyword { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode OutKeyword { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IMethodDeclaration MethodDeclaration { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.CachedDeclaredElement { get; private set; }
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    private ITypeParameter JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration.DeclaredElement { get; }
    public TypeParameterVariance Variance { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual ITokenNode get_InKeyword();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_OutKeyword();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IMethodDeclaration get_MethodDeclaration();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.get_CachedDeclaredElement();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.set_CachedDeclaredElement(IDeclaredElement value);
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public virtual bool IsSynthetic();
    public virtual string get_DeclaredName();
    private sealed virtual override ITypeParameter JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration.get_DeclaredElement();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual void SetVariance(TypeParameterVariance variance);
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ITypeParameterConstraintsClause GetConstraintsClause();
    public sealed virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    public sealed virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    public sealed virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public sealed virtual void RemoveAttribute(IAttribute attribute);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeParameterOfMethodList : CSharpCompositeElement {
    public static short CSHARP_LANGLE;
    public static short CSHARP_PARAMETER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RANGLE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LAngle { get; }
    public ITokenNode RAngle { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LAngle();
    public virtual ITokenNode get_RAngle();
    public virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeParameterOfTypeDeclaration : AttributesOwnerDeclarationBase {
    public static short CSHARP_ATTRIBUTES;
    public static short IN_KEYWORD;
    public static short OUT_KEYWORD;
    public static short CSHARP_NAME;
    [CompilerGeneratedAttribute]
private IDeclaredElement <JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.CacheDeclaredElement>k__BackingField;
    public NodeType NodeType { get; }
    public IAttributeSectionList AttributesInternal { get; }
    public ITokenNode InKeyword { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode OutKeyword { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IDeclaredElement DeclaredElement { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.CacheDeclaredElement { get; private set; }
    public string DeclaredName { get; }
    public TypeParameterVariance Variance { get; }
    private ITypeParameter JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration.DeclaredElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeSectionList get_AttributesInternal();
    public virtual ITokenNode get_InKeyword();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_OutKeyword();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.get_CacheDeclaredElement();
    [CompilerGeneratedAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2.set_CacheDeclaredElement(IDeclaredElement value);
    public virtual string get_DeclaredName();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual void SetVariance(TypeParameterVariance variance);
    private sealed virtual override ITypeParameter JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration.get_DeclaredElement();
    public sealed virtual ITypeParameterConstraintsClause GetConstraintsClause();
    public virtual void SetName(string name);
    private sealed virtual override XmlNode JetBrains.ReSharper.Psi.Tree.IXmlDocOwnerTreeNode.GetXMLDoc(bool inherit);
    public virtual TreeTextRange GetNameRange();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeParameterOfTypeList : CSharpCompositeElement {
    public static short CSHARP_LANGLE;
    public static short CSHARP_PARAMETER;
    public static short CSHARP_COMMA;
    public static short CSHARP_RANGLE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LAngle { get; }
    public ITokenNode RAngle { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LAngle();
    public virtual ITokenNode get_RAngle();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypeParameterReference : CSharpCompositeElement {
    public static short CSHARP_NAME;
    private LocalUserDataHolder myUserDataHolder;
    private CachedPsiValue`1<ResolveResultWithInfo> myResolveCache;
    public NodeType NodeType { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    [NotNullAttribute]
public IReference Reference { get; }
    [NotNullAttribute]
public string Name { get; }
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    public bool HasMultipleNames { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T val);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public sealed virtual IReference get_Reference();
    public sealed virtual string get_Name();
    private sealed virtual override TreeTextRange JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeTextRange();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ResolveResultWithInfo get_CurrentResolveResult();
    public sealed virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    [NotNullAttribute]
private IList`1<ITypeParameter> GetTypeParameters();
    public sealed virtual ITreeNode GetTreeNode();
    public sealed virtual string GetName();
    public sealed virtual bool get_HasMultipleNames();
    public sealed virtual HybridCollection`1<string> GetAllNames();
    public sealed virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public sealed virtual ResolveResultWithInfo Resolve();
    public sealed virtual IReference BindTo(IDeclaredElement element);
    public sealed virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual IAccessContext GetAccessContext();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual ISymbolTable GetCompletionSymbolTable();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.TypePattern : CSharpCompositeElement {
    public static short CSHARP_TYPE;
    public static short VARIABLE_DESIGNATION;
    public NodeType NodeType { get; }
    public IVariableDesignation Designation { get; }
    public ITypeUsage TypeUsage { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVariableDesignation get_Designation();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    [NotNullAttribute]
private IType GetSourceType();
    public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    public sealed virtual IType GetDesignationType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IExpressionType GetDesignationExpressionType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnaryOperatorExpression : CSharpExpressionBase {
    public static short OP_SIGN;
    public static short OP;
    private UnaryOperatorReference myReference;
    public NodeType NodeType { get; }
    public IUnaryExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public IList`1<IType> TypeArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public ICSharpArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
public IManagedReference Reference { get; }
    [NotNullAttribute]
private ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.Reference { get; }
    [NotNullAttribute]
public IOperatorReference OperatorReference { get; }
    public IList`1<ICSharpExpression> OperatorOperands { get; }
    public UnaryOperatorType UnaryOperatorType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IUnaryExpression get_Operand();
    public virtual ITokenNode get_OperatorSign();
    public virtual IUnaryExpression SetOperand(IUnaryExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
private ICSharpArgumentInfo[] GetArguments();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual ICSharpArgumentInfo get_ExtensionQualifier();
    public sealed virtual IManagedReference get_Reference();
    private sealed virtual override ICSharpInvocationReference JetBrains.ReSharper.Psi.CSharp.ICSharpInvocationInfo.get_Reference();
    public sealed virtual IOperatorReference get_OperatorReference();
    public sealed virtual IList`1<ICSharpExpression> get_OperatorOperands();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public sealed virtual UnaryOperatorType get_UnaryOperatorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnaryOperatorReference : ManagedNonQualifiableReferenceBase`1<IOperatorExpression> {
    public ICSharpInvocationInfo Invocation { get; }
    public UnaryOperatorReference(IOperatorExpression owner);
    public virtual string GetName();
    public sealed virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual ICSharpInvocationInfo get_Invocation();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public sealed virtual Refers RefersToDeclaredElement(IDeclaredElement declaredElement);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
private Refers <RefersToDeclaredElement>b__8_0(IDeclaredElement element);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UncheckedExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short OP;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode RPar { get; }
    public ITokenNode UncheckedKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual ICSharpExpression get_Operand();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_UncheckedKeyword();
    public virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public virtual IQualifierWithTypeElement AsQualifier(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UncheckedStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public IBlock Body { get; }
    public ITokenNode UncheckedKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Body();
    public virtual ITokenNode get_UncheckedKeyword();
    public virtual IBlock SetBody(IBlock param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UndefDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short CSHARP_NAME;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode Name { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public string SymbolName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_Name();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public sealed virtual string get_SymbolName();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodeAddressOfExpression : CSharpExpressionBase {
    public static short AND;
    public static short CSHARP_OP1;
    public NodeType NodeType { get; }
    public ITokenNode Address { get; }
    public IUnaryExpression Operand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Address();
    public virtual IUnaryExpression get_Operand();
    public virtual IUnaryExpression SetOperand(IUnaryExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodeFixedPointerDeclaration : UnsafeCodeFixedPointerDeclarationStub {
    [NullableContextAttribute("2")]
public virtual IVariableInitializer SetInitial(IVariableInitializer param);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodeFixedPointerDeclarationStub : LocalVariableDeclarationBase {
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short CSHARP_INITIALIZER;
    [NullableAttribute("1")]
private FixedPatternMethodReference myFixedPatternMethodReference;
    public NodeType NodeType { get; }
    public ITokenNode EquivalenceSign { get; }
    public IVariableInitializer Initial { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IUnsafeCodeFixedStatement DeclaringFixedStatement { get; }
    public ITypeUsage TypeUsage { get; }
    [NullableAttribute("2")]
public IReferenceName ScalarTypeName { get; }
    [NullableAttribute("1")]
public IFixedPatternMethodReference FixedPatternReference { get; }
    [NullableAttribute("1")]
public string DeclaredName { get; }
    public bool IsWritable { get; }
    public ScopedKind Scope { get; }
    [NullableAttribute("2")]
protected IType ExplicitlyDeclaredType { get; }
    [NullableAttribute("2")]
private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    [NullableAttribute("1")]
private ILocalVariable JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerDeclaration.DeclaredElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EquivalenceSign();
    public virtual IVariableInitializer get_Initial();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual IUnsafeCodeFixedStatement get_DeclaringFixedStatement();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    protected virtual void PreInit();
    [NullableContextAttribute("2")]
public sealed virtual IReferenceName get_ScalarTypeName();
    [NullableContextAttribute("1")]
public sealed virtual IFixedPatternMethodReference get_FixedPatternReference();
    [NullableContextAttribute("1")]
public virtual string get_DeclaredName();
    public virtual bool get_IsWritable();
    public virtual ScopedKind get_Scope();
    [NullableContextAttribute("2")]
protected virtual IType get_ExplicitlyDeclaredType();
    [NullableContextAttribute("2")]
private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    [NullableContextAttribute("1")]
private sealed virtual override ILocalVariable JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerDeclaration.get_DeclaredElement();
    private sealed virtual override ReferenceCollection JetBrains.ReSharper.Psi.Tree.ITreeNode.GetFirstClassReferences();
    [NullableContextAttribute("1")]
public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    [NullableContextAttribute("1")]
public virtual void SetType(IType type);
    [NullableContextAttribute("1")]
protected virtual IType GetImplicitType(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodeFixedPointerInitializer : CSharpCompositeElement {
    public static short AND;
    public static short VALUE;
    public NodeType NodeType { get; }
    public ITokenNode AddressOp { get; }
    public ICSharpExpression Value { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AddressOp();
    public virtual ICSharpExpression get_Value();
    public virtual ICSharpExpression SetValue(ICSharpExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodeFixedStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short CSHARP_TYPE;
    public static short DECLARATOR;
    public static short CSHARP_COMMA;
    public static short CSHARP_RPAR;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public ICSharpStatement Body { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode FixedKeyword { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<IUnsafeCodeFixedPointerDeclaration> PointerDeclarations { get; }
    public TreeNodeEnumerable`1<IUnsafeCodeFixedPointerDeclaration> PointerDeclarationsEnumerable { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpStatement get_Body();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_FixedKeyword();
    public virtual ITokenNode get_LPar();
    public virtual TreeNodeCollection`1<IUnsafeCodeFixedPointerDeclaration> get_PointerDeclarations();
    public virtual TreeNodeEnumerable`1<IUnsafeCodeFixedPointerDeclaration> get_PointerDeclarationsEnumerable();
    public virtual ITokenNode get_RPar();
    public virtual ITypeUsage get_TypeUsage();
    public virtual ICSharpStatement SetBody(ICSharpStatement param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual void RemovePointerDeclaration(IUnsafeCodeFixedPointerDeclaration pointerDeclaration);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodePointer : CSharpCompositeElement {
    public static short ASTERISK;
    public NodeType NodeType { get; }
    public ITokenNode Sign { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Sign();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodePointerAccessExpression : CSharpExpressionBase {
    public static short CSHARP_OP1;
    public static short OPERATOR;
    public static short CSHARP_REFERENCE;
    public static short TYPE_ARGS;
    private UnsafeCodePointerAccessExpressionReference myReference;
    public NodeType NodeType { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode OperatorSign { get; }
    public IPrimaryExpression PointerExpression { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    public IList`1<IType> TypeArguments { get; }
    public int TypeArgumentsNumber { get; }
    public IManagedTwoPhaseReference Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ITokenNode get_OperatorSign();
    public virtual IPrimaryExpression get_PointerExpression();
    public virtual ITypeArgumentList get_TypeArgumentList();
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual IPrimaryExpression SetPointerExpression(IPrimaryExpression param);
    public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public sealed virtual IList`1<IType> get_TypeArguments();
    public sealed virtual int get_TypeArgumentsNumber();
    public virtual ReferenceCollection GetFirstClassReferences();
    protected virtual void PreInit();
    public sealed virtual IManagedTwoPhaseReference get_Reference();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodePointerAccessExpressionReference : ReferenceExpressionReferenceBase`1<UnsafeCodePointerAccessExpression> {
    public bool IsQualified { get; }
    public UnsafeCodePointerAccessExpressionReference(UnsafeCodePointerAccessExpression owner);
    public virtual string GetName();
    public virtual TreeTextRange GetTreeTextRange();
    protected virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    public virtual bool get_IsQualified();
    protected virtual ICSharpArgumentInfo ExtensionArgument(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodePointerIndirectionExpression : CSharpExpressionBase {
    public static short ASTERISK;
    public static short CSHARP_OP1;
    public NodeType NodeType { get; }
    public ITokenNode Indirection { get; }
    public IUnaryExpression Operand { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Indirection();
    public virtual IUnaryExpression get_Operand();
    public virtual IUnaryExpression SetOperand(IUnaryExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ExpressionClassification Classify(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodeSizeOfExpression : CSharpExpressionBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short CSHARP_TYPE;
    public static short CSHARP_RPAR;
    public NodeType NodeType { get; }
    public ITokenNode LPar { get; }
    public ITypeUsage Operand { get; }
    public ITokenNode RPar { get; }
    public ITokenNode SizeofKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LPar();
    public virtual ITypeUsage get_Operand();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_SizeofKeyword();
    public virtual ITypeUsage SetOperand(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UnsafeCodeUnsafeStatement : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public IBlock Body { get; }
    public ITokenNode UnsafeKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Body();
    public virtual ITokenNode get_UnsafeKeyword();
    public virtual IBlock SetBody(IBlock param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UserDeclaredTypeUsage : object {
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UserTypeUsage : CSharpCompositeElement {
    public static short CSHARP_TYPE;
    public NodeType NodeType { get; }
    public IReferenceName ScalarTypeName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IReferenceName get_ScalarTypeName();
    public virtual IReferenceName SetScalarTypeName(IReferenceName param);
    public sealed virtual ITypeUsage ReplaceBy(ITypeUsage typeUsage);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UsingAliasDirective : CSharpCompositeElement {
    public static short GLOBAL_KEYWORD;
    public static short CSHARP_KEYWORD;
    public static short STATIC_KEYWORD;
    public static short UNSAFE_KEYWORD;
    public static short CSHARP_NAME;
    public static short CSHARP_EQ;
    public static short CSHARP_NAMESPACE_OR_TYPE;
    public static short CSHARP_SEMICOLON;
    [NullableAttribute("2")]
private ISymbolAlias myGlobalSymbolAliasInstance;
    [NullableAttribute("1")]
private CachedPsiValue`1<AliasedSymbol> myCachedAliasedSymbol;
    public NodeType NodeType { get; }
    public ICSharpIdentifier Alias { get; }
    public ITokenNode EquivalenceSign { get; }
    public ITokenNode GlobalKeyword { get; }
    public ITypeUsage NamespaceOrType { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode StaticKeyword { get; }
    public ITokenNode UnsafeKeyword { get; }
    public ITokenNode UsingKeyword { get; }
    [NullableAttribute("1")]
public string AliasName { get; }
    public bool IsNamespaceOrRegularDeclaredTypeAlias { get; }
    public AliasedSymbol AliasedSymbol { get; }
    [NullableAttribute("2")]
public string ExternAliasName { get; }
    [NullableAttribute("1")]
public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    [NullableAttribute("1")]
public IPsiModule Module { get; }
    [NullableAttribute("1")]
public ISubstitution IdSubstitution { get; }
    [NullableAttribute("1")]
public IDeclaredElement DeclaredElement { get; internal set; }
    [NullableAttribute("1")]
public string DeclaredName { get; }
    [NullableAttribute("1")]
private ISymbolAlias JetBrains.ReSharper.Psi.CSharp.Tree.IUsingAliasDirective.DeclaredElement { get; }
    public bool IsStatic { get; }
    public bool IsGlobal { get; }
    public bool IsUnsafe { get; }
    public bool IsAlias { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpIdentifier get_Alias();
    public virtual ITokenNode get_EquivalenceSign();
    public virtual ITokenNode get_GlobalKeyword();
    public virtual ITypeUsage get_NamespaceOrType();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_StaticKeyword();
    public virtual ITokenNode get_UnsafeKeyword();
    public virtual ITokenNode get_UsingKeyword();
    public virtual ICSharpIdentifier SetAlias(ICSharpIdentifier param);
    public virtual ITypeUsage SetNamespaceOrType(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    [NullableContextAttribute("1")]
public sealed virtual string get_AliasName();
    public sealed virtual bool get_IsNamespaceOrRegularDeclaredTypeAlias();
    public sealed virtual AliasedSymbol get_AliasedSymbol();
    [NullableContextAttribute("2")]
public sealed virtual string get_ExternAliasName();
    [NullableContextAttribute("1")]
public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual HybridCollection`1<IUsingAliasDirective> GetDeclarations();
    [NullableContextAttribute("1")]
private sealed virtual override IList`1<IDeclaration> JetBrains.ReSharper.Psi.IDeclaredElement.GetDeclarations();
    [NullableContextAttribute("1")]
public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    [NullableContextAttribute("1")]
public sealed virtual DeclaredElementType GetElementType();
    [NullableContextAttribute("2")]
public sealed virtual ITypeElement GetContainingType();
    [NullableContextAttribute("2")]
public sealed virtual ITypeMember GetContainingTypeMember();
    [NullableContextAttribute("2")]
public sealed virtual XmlNode GetXMLDoc(bool inherit);
    [NullableContextAttribute("2")]
public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    [NullableContextAttribute("1")]
public sealed virtual IPsiModule get_Module();
    [NullableContextAttribute("1")]
public sealed virtual ISubstitution get_IdSubstitution();
    [NullableContextAttribute("1")]
public sealed virtual IDeclaredElement get_DeclaredElement();
    [NullableContextAttribute("1")]
internal void set_DeclaredElement(IDeclaredElement value);
    [NullableContextAttribute("1")]
public sealed virtual string get_DeclaredName();
    [NullableContextAttribute("1")]
public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    [NullableContextAttribute("1")]
private sealed virtual override ISymbolAlias JetBrains.ReSharper.Psi.CSharp.Tree.IUsingAliasDirective.get_DeclaredElement();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsGlobal();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsAlias();
    public sealed virtual void SetStatic(bool isStatic);
    public sealed virtual void SetGlobal(bool isGlobal);
    public sealed virtual void SetUnsafe(bool isUnsafe);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <get_AliasedSymbol>g__CanBeNamespaceReference|42_1(IReferenceName referenceName);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UsingList : CSharpCompositeElement {
    public static short EXTERN_ALIAS_DIRECTIVE;
    public static short IMPORT;
    [NotNullAttribute]
private CachedPsiValue`1<Dictionary`2<IReferenceName, ResolveResultWithInfo>> myUsingNamespaceResolveCache;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IExternAliasDirective> ExternAliases { get; }
    public TreeNodeEnumerable`1<IExternAliasDirective> ExternAliasesEnumerable { get; }
    public TreeNodeCollection`1<IUsingDirective> Imports { get; }
    public TreeNodeEnumerable`1<IUsingDirective> ImportsEnumerable { get; }
    public ICSharpFile ContainingFileInternal { get; }
    public ICSharpNamespaceDeclaration ContainingNamespaceInternal { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IExternAliasDirective> get_ExternAliases();
    public virtual TreeNodeEnumerable`1<IExternAliasDirective> get_ExternAliasesEnumerable();
    public virtual TreeNodeCollection`1<IUsingDirective> get_Imports();
    public virtual TreeNodeEnumerable`1<IUsingDirective> get_ImportsEnumerable();
    public virtual ICSharpFile get_ContainingFileInternal();
    public virtual ICSharpNamespaceDeclaration get_ContainingNamespaceInternal();
    public virtual string ToString();
    protected virtual void PreInit();
    public ResolveResultWithInfo GetCachedResult(IReferenceName name);
    public void SetCachedResult(IReferenceName name, ResolveResultWithInfo result);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UsingStatement : UsingStatementStub {
    [CanBeNullAttribute]
public virtual ICSharpStatement SetBody(ICSharpStatement param);
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UsingStatementStub : StatementBase {
    public static short AWAIT;
    public static short CSHARP_KEYWORD;
    public static short CSHARP_LPAR;
    public static short EXPRESSIONS_LIST;
    public static short DECL;
    public static short CSHARP_RPAR;
    public static short CSHARP_BODY;
    private MyDisposeMethodReference myDisposeMethodReference;
    private MyGetAwaiterReference myGetAwaiterReference;
    private MyAwaiterGetResultReference myAwaiterGetResultReference;
    private MyAwaiterOnCompletedReference myAwaiterOnCompletedReference;
    private MyAwaiterIsCompletedReference myAwaiterIsCompletedReference;
    public NodeType NodeType { get; }
    public ITokenNode AwaitKeyword { get; }
    public ICSharpStatement Body { get; }
    public IMultipleLocalVariableDeclaration Declaration { get; }
    public IResourceAcquisitionExpressionsList ExpressionsList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode UsingKeyword { get; }
    public TreeNodeCollection`1<ICSharpExpression> Expressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ExpressionsEnumerable { get; }
    public TreeNodeCollection`1<ILocalVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public bool IsAwait { get; }
    public UsingDeclarationKind Kind { get; }
    public IDisposeMethodReference DisposeReference { get; }
    public IManagedReference GetAwaiterReference { get; }
    public IManagedReference AwaiterGetResultReference { get; }
    public IManagedReference AwaiterOnCompletedReference { get; }
    public IManagedReference AwaiterIsCompletedReference { get; }
    public TreeTextRange AwaitRange { get; }
    public TreeTextRange UsingRange { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    private bool IsWellFormedAwaitConstruct { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AwaitKeyword();
    public virtual ICSharpStatement get_Body();
    public virtual IMultipleLocalVariableDeclaration get_Declaration();
    public virtual IResourceAcquisitionExpressionsList get_ExpressionsList();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_UsingKeyword();
    public virtual TreeNodeCollection`1<ICSharpExpression> get_Expressions();
    public virtual TreeNodeEnumerable`1<ICSharpExpression> get_ExpressionsEnumerable();
    public virtual TreeNodeCollection`1<ILocalVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<ILocalVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual ICSharpStatement SetBody(ICSharpStatement param);
    public virtual IMultipleLocalVariableDeclaration SetDeclaration(IMultipleLocalVariableDeclaration param);
    public virtual IResourceAcquisitionExpressionsList SetExpressionsList(IResourceAcquisitionExpressionsList param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual bool get_IsAwait();
    public sealed virtual void SetAwait(bool isAwait);
    public sealed virtual UsingDeclarationKind get_Kind();
    public sealed virtual IDisposeMethodReference get_DisposeReference();
    public sealed virtual IManagedReference get_GetAwaiterReference();
    public sealed virtual IManagedReference get_AwaiterGetResultReference();
    public sealed virtual IManagedReference get_AwaiterOnCompletedReference();
    public sealed virtual IManagedReference get_AwaiterIsCompletedReference();
    public sealed virtual TreeTextRange get_AwaitRange();
    public sealed virtual TreeTextRange get_UsingRange();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual ILocalVariableDeclaration AddVariableDeclarationBefore(ILocalVariableDeclaration variableDeclaration, ILocalVariableDeclaration anchor);
    public sealed virtual ILocalVariableDeclaration AddVariableDeclarationAfter(ILocalVariableDeclaration variableDeclaration, ILocalVariableDeclaration anchor);
    [NotNullAttribute]
private ILocalVariableDeclaration AddNewVariableDeclaration(ILocalVariableDeclaration declaration);
    public sealed virtual void RemoveVariableDeclaration(ILocalVariableDeclaration variableDeclaration);
    public sealed virtual TExpression SetExpression(TExpression expression);
    private bool get_IsWellFormedAwaitConstruct();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.UsingSymbolDirective : CSharpCompositeElement {
    public static short GLOBAL_KEYWORD;
    public static short CSHARP_KEYWORD;
    public static short STATIC_KEYWORD;
    public static short UNSAFE_KEYWORD;
    public static short CSHARP_REFERENCE;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ITokenNode GlobalKeyword { get; }
    public IReferenceName ImportedSymbolName { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode StaticKeyword { get; }
    public ITokenNode UnsafeKeyword { get; }
    public ITokenNode UsingKeyword { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DeclaredElementInstance`1<IDeclaredElement> ImportedSymbol { get; }
    [NullableAttribute("2")]
public IReferenceName NamespaceOrTypeName { get; }
    public bool IsStatic { get; }
    public bool IsGlobal { get; }
    public bool IsUnsafe { get; }
    public bool IsAlias { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_GlobalKeyword();
    public virtual IReferenceName get_ImportedSymbolName();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_StaticKeyword();
    public virtual ITokenNode get_UnsafeKeyword();
    public virtual ITokenNode get_UsingKeyword();
    public virtual IReferenceName SetImportedSymbolName(IReferenceName param);
    public virtual string ToString();
    public sealed virtual DeclaredElementInstance`1<IDeclaredElement> get_ImportedSymbol();
    [NullableContextAttribute("2")]
public IReferenceName get_NamespaceOrTypeName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsGlobal();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsAlias();
    public sealed virtual void SetStatic(bool isStatic);
    public sealed virtual void SetGlobal(bool isGlobal);
    public sealed virtual void SetUnsafe(bool isUnsafe);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.ValueTypeConstraint : CSharpCompositeElement {
    public static short KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode Keyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Keyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.VarDeconstructionPattern : CSharpCompositeElement {
    public static short VAR_KEYWORD;
    public static short VARIABLE_DESIGNATION;
    public NodeType NodeType { get; }
    public IParenthesizedVariableDesignation Designation { get; }
    public ITokenNode VarKeyword { get; }
    private IVariableDesignation JetBrains.ReSharper.Psi.CSharp.Tree.IPatternWithDesignation.Designation { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IParenthesizedVariableDesignation get_Designation();
    public virtual ITokenNode get_VarKeyword();
    public virtual IParenthesizedVariableDesignation SetDesignation(IParenthesizedVariableDesignation param);
    public virtual string ToString();
    private sealed virtual override IVariableDesignation JetBrains.ReSharper.Psi.CSharp.Tree.IPatternWithDesignation.get_Designation();
    public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    public sealed virtual IType GetDesignationType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IExpressionType GetDesignationExpressionType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.VarPattern : CSharpCompositeElement {
    public static short VAR_KEYWORD;
    public static short VARIABLE_DESIGNATION;
    public NodeType NodeType { get; }
    public IVariableDesignation Designation { get; }
    public ITokenNode VarKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVariableDesignation get_Designation();
    public virtual ITokenNode get_VarKeyword();
    public virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    public virtual string ToString();
    public sealed virtual IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    public sealed virtual IType GetDesignationType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IExpressionType GetDesignationExpressionType(IVariableDesignation designation, IResolveContext resolveContext);
    public sealed virtual IType GetPatternType(IResolveContext resolveContext);
    public sealed virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WarningAction : CSharpCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WarningDirective : CSharpCompositeElement {
    public static short NUMBER_SIGN;
    public static short DIRECTIVE;
    public static short MESSAGE;
    public NodeType NodeType { get; }
    public ITokenNode Directive { get; }
    public ITokenNode Message { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Directive();
    public virtual ITokenNode get_Message();
    public virtual ITokenNode get_NumberSign();
    public virtual string ToString();
    public sealed virtual PreprocessorDirectiveKind get_Kind();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WarningList : CSharpCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
    public virtual bool IsFiltered();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WhereReference : QueryChainReferenceBase`1<QueryWhereClause> {
    private static string WHERE;
    public WhereReference(QueryWhereClause owner);
    public virtual ICSharpArgumentInfo[] GetArguments();
    public virtual string GetName();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WhileStatement : WhileStatementStub {
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    [CanBeNullAttribute]
public virtual ICSharpStatement SetBody(ICSharpStatement bodyStatement);
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WhileStatementStub : StatementBase {
    public static short KEYWORD;
    public static short CSHARP_LPAR;
    public static short CSHARP_CONDITION;
    public static short CSHARP_RPAR;
    public static short CSHARP_BODY;
    public NodeType NodeType { get; }
    public ICSharpStatement Body { get; }
    public ICSharpExpression Condition { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode WhileKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ICSharpStatement get_Body();
    public virtual ICSharpExpression get_Condition();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_WhileKeyword();
    public virtual ICSharpStatement SetBody(ICSharpStatement param);
    public virtual ICSharpExpression SetCondition(ICSharpExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.Whitespace : WhitespaceBase {
    public NodeType NodeType { get; }
    public bool IsNewLine { get; }
    public Whitespace(string text);
    public virtual NodeType get_NodeType();
    public virtual bool get_IsNewLine();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WhitespaceBase : CSharpTokenBase {
    [NotNullAttribute]
private string myText;
    public bool IsNewLine { get; }
    protected WhitespaceBase(string text);
    public virtual bool IsFiltered();
    public virtual int GetTextLength();
    public virtual string GetText();
    public abstract virtual bool get_IsNewLine();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WithExpression : CSharpExpressionBase {
    public static short CSHARP_CONDITION;
    public static short KEYWORD;
    public static short CSHARP_LBRACE;
    public static short WITH_INITIALIZER_ASSIGNMENT;
    public static short CSHARP_COMMA;
    public static short CSHARP_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IWithInitializerAssignment> Initializers { get; }
    public TreeNodeEnumerable`1<IWithInitializerAssignment> InitializersEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode WithKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IWithInitializerAssignment> get_Initializers();
    public virtual TreeNodeEnumerable`1<IWithInitializerAssignment> get_InitializersEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual ICSharpExpression get_Operand();
    public virtual ITokenNode get_RBrace();
    public virtual ITokenNode get_WithKeyword();
    public virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionTypeAux(IResolveContext resolveContext);
    public sealed virtual IWithInitializerAssignment AddWithInitializerAssignmentAfter(IWithInitializerAssignment withInitializerAssignment, IWithInitializerAssignment anchor);
    public sealed virtual IWithInitializerAssignment AddWithInitializerAssignmentBefore(IWithInitializerAssignment withInitializerAssignment, IWithInitializerAssignment anchor);
    public sealed virtual void RemoveWithInitializerAssignment(IWithInitializerAssignment withInitializerAssignment);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.WithInitializerAssignment : CSharpCompositeElement {
    public static short CSHARP_REFERENCE;
    public static short CSHARP_EQ;
    public static short ARM_EXPRESSION;
    private WithMemberReference myMemberReference;
    public NodeType NodeType { get; }
    public ITokenNode Eq { get; }
    public ICSharpExpression Expression { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IManagedReference MemberReference { get; }
    public string MemberName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Eq();
    public virtual ICSharpExpression get_Expression();
    public virtual ICSharpIdentifier get_NameIdentifier();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IManagedReference get_MemberReference();
    public sealed virtual string get_MemberName();
    [PureAttribute]
[NotNullAttribute]
private IType GetSourceType(IResolveContext resolveContext);
    public sealed virtual void SetMemberName(string name);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Tree.YieldStatement : StatementBase {
    public static short KEYWORD;
    public static short RETURN;
    public static short EXPR;
    public static short BREAK;
    public static short CSHARP_SEMICOLON;
    public NodeType NodeType { get; }
    public ITokenNode BreakKeyword { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode ReturnKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode YieldKeyword { get; }
    public YieldStatementType StatementType { get; }
    public ICSharpExpression Value { get; }
    public bool IntroducesScope { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_BreakKeyword();
    public virtual ICSharpExpression get_Expression();
    public virtual ITokenNode get_ReturnKeyword();
    public virtual ITokenNode get_Semicolon();
    public virtual ITokenNode get_YieldKeyword();
    public virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public virtual string ToString();
    public sealed virtual YieldStatementType get_StatementType();
    public sealed virtual ICSharpExpression get_Value();
    public sealed virtual bool get_IntroducesScope();
    [NotNullAttribute]
public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.TupleEqualityOperator : object {
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private IList`1<IParameter> myParameters;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DeclaredElementInstance`1<ISignOperator>> <NestedEqualityOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IOperator> <UsedNonEqualityOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <TupleComponentNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IReadOnlyList`1<DeclaredElementInstance`1<ISignOperator>> NestedEqualityOperators { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IOperator> UsedNonEqualityOperators { get; }
    [CanBeNullAttribute]
[ItemCanBeNullAttribute]
public IReadOnlyList`1<string> TupleComponentNames { get; }
    public bool IsChecked { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ITypeElement ContainingType { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public TupleEqualityOperator(string name, IPsiModule psiModule, IReadOnlyList`1<DeclaredElementInstance`1<ISignOperator>> nestedEqualityOperators, IReadOnlyList`1<IOperator> usedNonEqualityOperators, IReadOnlyList`1<string> tupleComponentNames);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DeclaredElementInstance`1<ISignOperator>> get_NestedEqualityOperators();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IOperator> get_UsedNonEqualityOperators();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_TupleComponentNames();
    public sealed virtual bool get_IsChecked();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<IParameter> get_Parameters();
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
private IParameter[] CreateOperatorParameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public virtual string ToString();
    private bool Equals(TupleEqualityOperator other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.TypeAliasBindingService : object {
    public static TypeAliasBindingService Instance;
    public PsiModificationServicePriority Priority { get; }
    private static TypeAliasBindingService();
    public sealed virtual PsiModificationServicePriority get_Priority();
    public sealed virtual bool IsApplicable(ITreeNode originalNode, bool fromPhysicalTree, ITreeNode insertedCopyNode, bool toPhysicalTree);
    public sealed virtual object CreateContext(ITreeNode originalNode, IReferenceContextCodec referenceContextCodec, ITreeNode insertedCopyNode);
    [NullableContextAttribute("2")]
public sealed virtual ITreeNode Apply(ITreeNode node, object context);
    public sealed virtual bool ShouldApplyToDescendants(ITreeNode node, object context);
    public sealed virtual void CleanupContext(ITreeNode node, object context);
    public sealed virtual void OnCopyWithResolve(ITreeNode node, ITreeNode copy);
    [CompilerGeneratedAttribute]
internal static void <CreateContext>g__ProcessTypeUsage|4_0(IUserTypeUsage userTypeUsage, Dictionary`2& map);
    [CompilerGeneratedAttribute]
internal static bool <Apply>g__IsResolvedOk|5_0(IUserTypeUsage typeUsage);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.AddressOfMethodGroupType : object {
    [NotNullAttribute]
private MethodChooser myMethodChooser;
    public bool IsNonCacheable { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public AddressOfMethodGroupType(MethodChooser methodChooser);
    public sealed virtual bool ImplicitConversionExists(IFunctionPointerType functionPointerType);
    public sealed virtual ResolveResultWithInfo Resolve(IFunctionPointerType functionPointerType);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsNonCacheable();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Types.AnyExpressionTypeBase : object {
    [NotNullAttribute]
private IPsiModule myModule;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    protected AnyExpressionTypeBase(IPsiModule module);
    public bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual IType ToIType();
    public abstract virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.CollectionExpressionType : object {
    private ICollectionExpression myCollectionExpression;
    private List`1<IExpressionType> myNestedTypes;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public IReadOnlyList`1<IExpressionType> ElementTypes { get; }
    public ICollectionExpression CollectionExpression { get; }
    public bool IsNonCacheable { get; }
    public IEnumerable`1<IExpressionType> NestedTypes { get; }
    public CollectionExpressionType(ICollectionExpression collectionExpression, IResolveContext resolveContext);
    [NullableContextAttribute("2")]
public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual IReadOnlyList`1<IExpressionType> get_ElementTypes();
    public sealed virtual ICollectionExpression get_CollectionExpression();
    public sealed virtual bool get_IsNonCacheable();
    public sealed virtual IEnumerable`1<IExpressionType> get_NestedTypes();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.ConditionalExpressionType : object {
    [NotNullAttribute]
private IConditionalTernaryExpression myConditionalExpression;
    [CanBeNullAttribute]
private IType myDerivedType;
    [CompilerGeneratedAttribute]
private IExpressionType <ThenExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionType <ElseExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConditionalConversionSupported>k__BackingField;
    public IExpressionType ThenExpressionType { get; }
    public IExpressionType ElseExpressionType { get; }
    public bool ConditionalConversionSupported { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    private IEnumerable`1<IExpressionType> JetBrains.ReSharper.Psi.ITargetTypedExpressionType.NestedTypes { get; }
    public bool IsNonCacheable { get; }
    internal ConditionalExpressionType(IConditionalTernaryExpression conditionalExpression, IResolveContext resolveContext);
    internal ConditionalExpressionType(IConditionalTernaryExpression conditionalExpression, IExpressionType thenExpressionType, IExpressionType elseExpressionType, IType derivedType);
    [CompilerGeneratedAttribute]
public sealed virtual IExpressionType get_ThenExpressionType();
    [CompilerGeneratedAttribute]
public sealed virtual IExpressionType get_ElseExpressionType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ConditionalConversionSupported();
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
    private sealed virtual override IEnumerable`1<IExpressionType> JetBrains.ReSharper.Psi.ITargetTypedExpressionType.get_NestedTypes();
    private static IType FindDerivedType(IConditionalTernaryExpression conditionalExpression, IExpressionType thenExpressionType, IExpressionType elseExpressionType, IResolveContext resolveContext);
    public sealed virtual bool get_IsNonCacheable();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.ConstantType : object {
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValue>k__BackingField;
    public IPsiModule Module { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public ConstantType(ConstantValue constantValue, IPsiModule module);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual IType GetDefaultType();
    public sealed virtual bool IsNullType();
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Types.CSharpAnonymousType : AnonymousTypeBase {
    [NotNullAttribute]
private IList`1<AnonymousTypeDescriptor> myDescriptor;
    [CanBeNullAttribute]
private ICSharpAnonymousTypeProperty[] myProperties;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    public IPsiModule Module { get; }
    public IList`1<AnonymousTypeDescriptor> TypeDescriptor { get; }
    public IList`1<ICSharpAnonymousTypeProperty> Properties { get; }
    internal CSharpAnonymousType(IPsiModule module, IList`1<AnonymousTypeDescriptor> descriptor);
    public virtual ITypePointer CreatePointer();
    [CompilerGeneratedAttribute]
public virtual IPsiModule get_Module();
    public virtual IType WithTypeDecorations(TypeDecorationSet typeDecorations);
    public virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    public virtual IAnonymousType TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual IList`1<AnonymousTypeDescriptor> get_TypeDescriptor();
    public virtual IList`1<ICSharpAnonymousTypeProperty> get_Properties();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.CSharpInterpolatedStringExpressionType : object {
    [NotNullAttribute]
private IInterpolatedStringExpression myInterpolatedStringExpression;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public CSharpInterpolatedStringExpressionType(IInterpolatedStringExpression interpolatedStringExpression);
    public sealed virtual IType ToIType();
    public sealed virtual IType GetConvertedType(IResolveContext resolveContext);
    public sealed virtual InterpolatedStringKind GetInterpolatedStringKind(IResolveContext resolveContext);
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Types.CSharpMethodGroupTypeBase : object {
    public CSharpLanguageLevel LanguageLevel { get; }
    public CSharpLanguageLevel LatestSupportedLanguageLevel { get; }
    public bool IsNonCacheable { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public string MethodShortName { get; }
    public abstract virtual ResolveResultWithInfo Resolve(IList`1<ICSharpArgumentInfo> arguments);
    public abstract virtual ResolveResultWithInfo Resolve(IDelegate delegate, ISubstitution substitution);
    public abstract virtual ISymbolTable GetMethodsSymbolTable();
    public abstract virtual CSharpLanguageLevel get_LanguageLevel();
    public abstract virtual CSharpLanguageLevel get_LatestSupportedLanguageLevel();
    [CanBeNullAttribute]
protected abstract virtual DeclaredElementInstance`1<IParametersOwner> ChooseSingleFunction(IDelegate delegate, ISubstitution substitution, Boolean& isExtension, IResolveInfo& info);
    public sealed virtual bool IsApplicableTo(IDelegate delegate, ISubstitution substitution);
    public abstract virtual bool ImplicitConversionExists(IDelegate delegate, ISubstitution substitution);
    public abstract virtual IAddressOfMethodGroupType TakeAddressOf();
    public abstract virtual IType ToIType();
    public abstract virtual IType GetFunctionType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public abstract virtual bool get_IsNonCacheable();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual IPsiModule get_Module();
    public abstract virtual bool IsValid();
    public abstract virtual string get_MethodShortName();
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Types.CSharpMethodGroupTypeFactory : object {
    [CanBeNullAttribute]
private static ICSharpArgumentInfo CreateExtensionArgumentInfo(IType extensionQualifierType);
    [NotNullAttribute]
public static IMethodGroupType Create(TMethodLike methodLike, ISubstitution substitution, IType extensionQualifierType, ITreeNode context);
    [NotNullAttribute]
public static IMethodGroupType Create(IMethod method, ISubstitution substitution, IUnsafeCodePointerAccessExpression methodGroupExpression);
    [NotNullAttribute]
public static IMethodGroupType Create(TMethodLike methodLike, ISubstitution substitution, IReferenceExpression methodGroupExpression);
    [NotNullAttribute]
public static IMethodGroupType Create(MethodChooser chooser);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.Types.CSharpMethodGroupTypeUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static IList`1<ICSharpArgumentInfo> Arguments(IDelegate delegate, ISubstitution substitution, CSharpLanguageLevel languageLevel);
    [NotNullAttribute]
[PureAttribute]
public static IList`1<ICSharpArgumentInfo> Arguments(IFunctionPointerType functionPointerType, CSharpLanguageLevel languageLevel);
    [PureAttribute]
public static bool CheckArgumentTypes(IParametersOwner targetFunction, ISubstitution targetSubstitution, IParametersOwner sourceFunction, ISubstitution sourceSubstitution, bool isExtensionMethod, IPsiModule context, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [PureAttribute]
public static bool CheckReturnType(IType targetReturnType, bool isReturnByReference, IParametersOwner method, ISubstitution substitution, IPsiModule context);
    [PureAttribute]
public static bool CheckReturnType(IDelegate delegate, ISubstitution delegateSubstitution, IParametersOwner method, ISubstitution substitution, IPsiModule context);
    [NotNullAttribute]
private static IType ProcessDynamicsInTypeStructure(IType type, CSharpLanguageLevel languageLevel);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.CSharpTupleExpressionType : TupleExpressionTypeBase {
    public CSharpTupleExpressionType(IPsiModule module, TupleExpressionTypeComponent[] component);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Types.DefaultLiteralExpressionType : object {
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNullableWarningsSuppression>k__BackingField;
    public IPsiModule Module { get; }
    public bool HasNullableWarningsSuppression { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public DefaultLiteralExpressionType(IPsiModule module, bool hasNullableWarningsSuppression);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasNullableWarningsSuppression();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IType GetDefaultType();
    public sealed virtual bool IsNullType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Types.DiscardExpressionType : AnyExpressionTypeBase {
    public DiscardExpressionType(IPsiModule module);
    public virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.EventType : object {
    [NotNullAttribute]
private IEvent myEvent;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public EventType(IEvent event);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Types.InterpolatedStringConcatenationExpressionType : object {
    [NotNullAttribute]
private IAdditiveExpression myAdditiveExpression;
    public IPsiModule Module { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public InterpolatedStringConcatenationExpressionType(IAdditiveExpression additiveExpression);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IType ToIType();
    public sealed virtual IType GetConvertedType(IResolveContext resolveContext);
    public sealed virtual InterpolatedStringKind GetInterpolatedStringKind(IResolveContext resolveContext);
    [CanBeNullAttribute]
[PureAttribute]
private static IInterpolatedStringExpression GetInterpolatedStringOperand(ICSharpExpression expression);
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Impl.Types.LambdaExpressionTypeBase : object {
    [CanBeNullAttribute]
private IResolveContext myResolveContext;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IParameter> <LambdaParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <LanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <LatestSupportedLanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    protected bool myIsInNaturalFunctionTypeContext;
    [CompilerGeneratedAttribute]
private IType <AnnotatedInferredReturnType>k__BackingField;
    [CanBeNullAttribute]
private IReadOnlyList`1<Pair`2<IType, ParameterKind>> myParameterTypes;
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private IList`1<IExpressionType> myReturnTypes;
    private bool myIsPossibleStatement;
    private bool myIsRefReturn;
    private bool myITypeIsCached;
    [CanBeNullAttribute]
private IType myIType;
    [NotNullAttribute]
protected IReadOnlyList`1<IParameter> LambdaParameters { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public CSharpLanguageLevel LatestSupportedLanguageLevel { get; }
    protected IPsiModule PsiModule { get; }
    [CanBeNullAttribute]
protected IType AnnotatedInferredReturnType { get; }
    [NotNullAttribute]
protected IResolveContext ResolveContext { get; }
    public bool IsBoundLambda { get; }
    protected bool IsAsync { get; }
    public IType ExplicitReturnType { get; }
    public ReferenceKind ExplicitReturnKind { get; }
    public bool HasParametersList { get; }
    public IReadOnlyList`1<Pair`2<IType, ParameterKind>> ParameterTypesAndKinds { get; }
    public ICollection`1<IExpressionType> ReturnValues { get; }
    private bool JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionType.IsAsync { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    public bool IsResolved { get; }
    public bool IsNonCacheable { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public ITreeNode VerificationScope { get; }
    public bool HasUnfinishedReturnExpression { get; }
    protected LambdaExpressionTypeBase(IPsiModule psiModule, IResolveContext resolveContext, IReadOnlyList`1<IParameter> parameters, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, IType annotatedInferredReturnType, bool isInNaturalFunctionTypeContext);
    [CompilerGeneratedAttribute]
protected IReadOnlyList`1<IParameter> get_LambdaParameters();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpLanguageLevel get_LanguageLevel();
    [CompilerGeneratedAttribute]
public CSharpLanguageLevel get_LatestSupportedLanguageLevel();
    [CompilerGeneratedAttribute]
protected IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
protected IType get_AnnotatedInferredReturnType();
    protected IResolveContext get_ResolveContext();
    public bool get_IsBoundLambda();
    public bool CanCacheValues(IResolveContext resolveContext);
    public abstract virtual IList`1<IExpressionType> CalculateReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    public abstract virtual bool IsImplicitReturnReachable(IResolveContext resolveContext);
    public sealed virtual IList`1<IExpressionType> GetReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    protected abstract virtual bool get_IsAsync();
    public virtual IType get_ExplicitReturnType();
    public virtual ReferenceKind get_ExplicitReturnKind();
    public sealed virtual bool get_HasParametersList();
    public sealed virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> get_ParameterTypesAndKinds();
    public sealed virtual ICollection`1<IExpressionType> get_ReturnValues();
    public sealed virtual IType InferredResultTypeWithoutAsync();
    public sealed virtual IType InferredResultTypeWithoutAsync(bool allowFunctionTypes, Boolean& isRefReturn, ICollection`1& returnValues);
    public sealed virtual IType ToIType();
    public virtual IType GetFunctionType();
    private IType CalculateFunctionType();
    public sealed virtual bool CanHaveNaturalType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    [CanBeNullAttribute]
private IType UnwrapReturnTypeFromAsync(IType originalReturnType);
    public sealed virtual bool IsReturnTypeConvertibleTo(IDelegate delegate, ISubstitution delegateSubstitution);
    private bool IsReturnTypeConvertibleTo(IResolveContext resolveContext, IDelegate delegate, ISubstitution delegateSubstitution, IList`1<IExpressionType> returnTypes, bool isRefReturn, bool isPossibleStatement);
    public sealed virtual bool IsSignatureConvertibleTo(IDelegate delegate, ISubstitution delegateSubstitution);
    public sealed virtual bool VerifyFunctionType(IDelegate delegate, ISubstitution substitution);
    private sealed virtual override bool JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionType.get_IsAsync();
    public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsNonCacheable();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_Module();
    public abstract virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
    public virtual bool IsValid();
    [NotNullAttribute]
private IReadOnlyList`1<Pair`2<IType, ParameterKind>> GetParameterTypes(IResolveContext resolveContext);
    [CanBeNullAttribute]
[PureAttribute]
private IResolveContext ForkForDelegate(IDelegate delegate, ISubstitution delegateSubstitution);
    [NotNullAttribute]
private IReadOnlyList`1<Pair`2<IType, ParameterKind>> GetParameterTypes(IDelegate delegate, ISubstitution delegateSubstitution);
    public abstract virtual ITreeNode get_VerificationScope();
    [NotNullAttribute]
public sealed virtual IReadOnlyList`1<IParameter> GetImplicitLambdaParameters();
    public sealed virtual bool HasImplicitLambdaParameters();
    public virtual bool get_HasUnfinishedReturnExpression();
    private sealed virtual override IType JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionTypeImpl.TryComputeNaturalTypeFromExplicitSignature();
    private sealed virtual override IType JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionTypeImpl.TryComputeImplicitNaturalType(ICollection`1<IExpressionType> returnTypes, bool hasRefReturn);
    [CanBeNullAttribute]
private IType TryComputeNaturalTypeFromExplicitSignature();
    [CanBeNullAttribute]
private IType TryComputeImplicitNaturalType(ICollection`1<IExpressionType> returnTypes, bool hasRefReturn);
    [CanBeNullAttribute]
[PureAttribute]
private IType TryFindStandardDelegateByExplicitReturnTypeOrFallbackToAnonymousDelegate(IType realReturnType);
    [CanBeNullAttribute]
[PureAttribute]
private IType TryFindStandardVoidReturningDelegateOrFallbackToAnonymousDelegate(IType realReturnType);
    [PureAttribute]
private bool ParametersCanMatchStandardDelegate();
    private bool ReturnTypeCanMatchStandardDelegate(IType realReturnType);
    private bool TryAddParameterTypes(List`1<IType> typeArguments);
    private bool TryAddVoidReturnTypeArgument(List`1<IType> typeArguments);
    [CanBeNullAttribute]
[PureAttribute]
private IType TryCreateAnonymousDelegateType(IType realReturnType, ReferenceKind returnKind);
    [CompilerGeneratedAttribute]
private void <GetReturnTypes>g__TryCacheReturnTypes|31_0(bool isPossibleStatement, bool isRefReturn, <>c__DisplayClass31_0& );
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
[PureAttribute]
private IType <TryComputeImplicitNaturalType>g__TryFindStandardDelegateByInferredReturnTypeOrFallbackToAnonymousDelegate|83_0(IType inferredReturnType, <>c__DisplayClass83_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.LambdaExpressionTypeForBlock : LambdaExpressionTypeBase {
    [NotNullAttribute]
private IBlock myBody;
    private Nullable`1<bool> myImplicitReturnIsReachable;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExplicitReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <ExplicitReturnKind>k__BackingField;
    protected bool IsAsync { get; }
    public IType ExplicitReturnType { get; }
    public ReferenceKind ExplicitReturnKind { get; }
    [NotNullAttribute]
public ITreeNode VerificationScope { get; }
    private LambdaExpressionTypeForBlock(IPsiModule psiModule, IResolveContext resolveContext, IReadOnlyList`1<IParameter> parameters, IBlock body, bool isAsync, IType explicitReturnType, IType annotatedInferredReturnType, ReferenceKind explicitReturnKind, bool isInNaturalFunctionTypeContext, CSharpLanguageLevel level, CSharpLanguageLevel latestSupportedLanguageLevel);
    public static IAnonymousFunctionType Create(IPsiModule psiModule, IResolveContext resolveContext, IReadOnlyList`1<IParameter> parameters, IBlock body, bool isAsync, IType explicitReturnType, IType annotatedInferredReturnType, ReferenceKind explicitReturnKind, bool hasNaturalType, CSharpLanguageLevel level, CSharpLanguageLevel latestSupportedLanguageLevel);
    [CompilerGeneratedAttribute]
protected sealed virtual bool get_IsAsync();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExplicitReturnType();
    [CompilerGeneratedAttribute]
public sealed virtual ReferenceKind get_ExplicitReturnKind();
    public virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
    public virtual bool IsValid();
    public virtual IList`1<IExpressionType> CalculateReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    public virtual bool IsImplicitReturnReachable(IResolveContext resolveContext);
    public virtual ITreeNode get_VerificationScope();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.LambdaExpressionTypeForExpression : LambdaExpressionTypeBase {
    [CanBeNullAttribute]
private ICSharpExpression myBody;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExplicitReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <ExplicitReturnKind>k__BackingField;
    protected bool IsAsync { get; }
    public IType ExplicitReturnType { get; }
    public ReferenceKind ExplicitReturnKind { get; }
    public ITreeNode VerificationScope { get; }
    public bool HasUnfinishedReturnExpression { get; }
    private LambdaExpressionTypeForExpression(IPsiModule psiModule, IResolveContext resolveContext, IReadOnlyList`1<IParameter> parameters, ICSharpExpression body, bool isAsync, IType explicitReturnType, IType annotatedInferredReturnType, ReferenceKind explicitReturnKind, bool isInNaturalFunctionTypeContext, CSharpLanguageLevel level, CSharpLanguageLevel latestSupportedLanguageLevel);
    public static IAnonymousFunctionType Create(IPsiModule psiModule, IResolveContext resolveContext, IReadOnlyList`1<IParameter> parameters, ICSharpExpression body, bool isAsync, IType explicitReturnType, IType annotatedInferredReturnType, ReferenceKind explicitReturnKind, bool hasNaturalType, CSharpLanguageLevel level, CSharpLanguageLevel latestSupportedLanguageLevel);
    [CompilerGeneratedAttribute]
protected sealed virtual bool get_IsAsync();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExplicitReturnType();
    [CompilerGeneratedAttribute]
public sealed virtual ReferenceKind get_ExplicitReturnKind();
    public virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
    public virtual bool IsValid();
    public virtual IList`1<IExpressionType> CalculateReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    public virtual bool IsImplicitReturnReachable(IResolveContext resolveContext);
    public virtual ITreeNode get_VerificationScope();
    public virtual bool get_HasUnfinishedReturnExpression();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.NullType : object {
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNullableWarningsSuppression>k__BackingField;
    public IPsiModule Module { get; }
    public bool HasNullableWarningsSuppression { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public ConstantValue ConstantValue { get; }
    public NullType(IPsiModule module, bool hasNullableWarningsSuppression);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public bool get_HasNullableWarningsSuppression();
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IType GetDefaultType();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool IsNullType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Types.OutVariableExpressionType : AnyExpressionTypeBase {
    public OutVariableExpressionType(IPsiModule module);
    public virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.StackAllocExpressionType : object {
    [CanBeNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private IStackAllocExpression myStackAllocExpression;
    [NotNullAttribute]
private IResolveContext ResolveContext { get; }
    public IType UnderlyingType { get; }
    public IType SpanType { get; }
    public IPointerType PointerType { get; }
    public bool IsNonCacheable { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public StackAllocExpressionType(IResolveContext resolveContext, IStackAllocExpression stackAllocExpression);
    private IResolveContext get_ResolveContext();
    public IType get_UnderlyingType();
    public IType get_SpanType();
    public IPointerType get_PointerType();
    public sealed virtual IPointerType ToPointerType();
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsNonCacheable();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.SwitchExpressionType : object {
    [NotNullAttribute]
private ISwitchExpression mySwitchExpression;
    [CanBeNullAttribute]
private IType myBestCommonType;
    [NotNullAttribute]
[ItemNotNullAttribute]
private List`1<IExpressionType> myArmsExpressionTypes;
    public bool IsNonCacheable { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public IReadOnlyList`1<IExpressionType> ArmsExpressionTypes { get; }
    private IEnumerable`1<IExpressionType> JetBrains.ReSharper.Psi.ITargetTypedExpressionType.NestedTypes { get; }
    internal SwitchExpressionType(ISwitchExpression switchExpression, IResolveContext resolveContext);
    internal SwitchExpressionType(ISwitchExpression switchExpression, List`1<IExpressionType> armsExpressionTypes, IType bestCommonType);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsNonCacheable();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual IReadOnlyList`1<IExpressionType> get_ArmsExpressionTypes();
    private sealed virtual override IEnumerable`1<IExpressionType> JetBrains.ReSharper.Psi.ITargetTypedExpressionType.get_NestedTypes();
    private bool AllArmsConvertibleTo(IType bestCommonType, IResolveContext resolveContext, ICSharpTypeConversionRule typeConversionRule);
}
internal class JetBrains.ReSharper.Psi.CSharp.Impl.Types.TargetTypedObjectCreationExpressionType : object {
    [NotNullAttribute]
private IObjectCreationExpression myObjectCreationExpression;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IExpressionType> <ArgumentExpressionTypes>k__BackingField;
    public IReadOnlyList`1<IExpressionType> ArgumentExpressionTypes { get; }
    public IEnumerable`1<IExpressionType> NestedTypes { get; }
    public IPsiModule Module { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public TargetTypedObjectCreationExpressionType(IObjectCreationExpression objectCreationExpression, IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IExpressionType> get_ArgumentExpressionTypes();
    public sealed virtual IEnumerable`1<IExpressionType> get_NestedTypes();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Types.ThrowExpressionType : object {
    [NotNullAttribute]
private IPsiModule myModule;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public ThrowExpressionType(IPsiModule module);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpParameterOfUnresolvedMethod : object {
    private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private bool <HasName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private IParametersOwner <ContainingParametersOwner>k__BackingField;
    public bool HasName { get; }
    public string ShortName { get; }
    public IType Type { get; }
    public ParameterKind Kind { get; }
    public IPsiModule Module { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsValueVariable { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public bool IsDynamic { get; }
    public CSharpParameterOfUnresolvedMethod(IParametersOwner owner, IType type, string shortName, ParameterKind kind, bool hasName);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ParameterKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public bool Equals(CSharpParameterOfUnresolvedMethod other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool get_IsDynamic();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpUnresolvedConstructor : object {
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ICSharpParameterOfUnresolvedMethod> <Parameters>k__BackingField;
    public bool IsDynamic { get; }
    public string ShortName { get; }
    private IList`1<IParameter> JetBrains.ReSharper.Psi.IParametersOwner.Parameters { get; }
    public IList`1<ICSharpParameterOfUnresolvedMethod> Parameters { get; }
    public IPsiModule Module { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsDefault { get; }
    public bool IsParameterless { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public CSharpUnresolvedConstructor(string shortName, ITreeNode element, IList`1<ICSharpArgument> arguments);
    public CSharpUnresolvedConstructor(string shortName, ITreeNode element);
    public sealed virtual bool get_IsDynamic();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    private sealed virtual override IList`1<IParameter> JetBrains.ReSharper.Psi.IParametersOwner.get_Parameters();
    [CompilerGeneratedAttribute]
public IList`1<ICSharpParameterOfUnresolvedMethod> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public bool Equals(CSharpUnresolvedConstructor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsParameterless();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsValueTypeZeroInit();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpUnresolvedElementPresenter : object {
    public virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement declaredElement, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    private static TextRange AppendString(RichText sb, string substr, TextStyle textStyle);
    public virtual string Format(ParameterKind parameterKind);
    public virtual string Format(AccessRights accessRights);
    public virtual string GetEntityKind(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpUnresolvedField : object {
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    public bool IsDynamic { get; }
    public string ShortName { get; }
    public bool IsStatic { get; }
    public IPsiModule Module { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public CSharpUnresolvedField(string shortName, ITreeNode element, bool isStatic, bool isDynamic);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDynamic();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStatic();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpUnresolvedFieldType : DeclaredElementTypeBase {
    public static DeclaredElementType UnresolvedField;
    public static DeclaredElementType DynamicField;
    protected IDeclaredElementPresenter DefaultPresenter { get; }
    public CSharpUnresolvedFieldType(string name, IconId imageName);
    private static CSharpUnresolvedFieldType();
    protected virtual IDeclaredElementPresenter get_DefaultPresenter();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpUnresolvedMethod : object {
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ICSharpParameterOfUnresolvedMethod> <Parameters>k__BackingField;
    public bool IsDynamic { get; }
    public string ShortName { get; }
    private IList`1<IParameter> JetBrains.ReSharper.Psi.IParametersOwner.Parameters { get; }
    public IList`1<ICSharpParameterOfUnresolvedMethod> Parameters { get; }
    public IPsiModule Module { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public bool IsExtensionMethod { get; }
    public bool IsVarArg { get; }
    public bool IsAsync { get; }
    public CSharpUnresolvedMethod(string shortName, ITreeNode element, IList`1<ICSharpArgument> arguments, bool isDynamic);
    public CSharpUnresolvedMethod(string shortName, ITreeNode element);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDynamic();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    private sealed virtual override IList`1<IParameter> JetBrains.ReSharper.Psi.IParametersOwner.get_Parameters();
    [CompilerGeneratedAttribute]
public IList`1<ICSharpParameterOfUnresolvedMethod> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsAsync();
    public bool Equals(CSharpUnresolvedMethod other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpUnresolvedMethodType : DeclaredElementTypeBase {
    public static DeclaredElementType UnresolvedMethod;
    public static DeclaredElementType DynamicMethod;
    protected IDeclaredElementPresenter DefaultPresenter { get; }
    public CSharpUnresolvedMethodType(string name, IconId imageName);
    private static CSharpUnresolvedMethodType();
    protected virtual IDeclaredElementPresenter get_DefaultPresenter();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpUnresolvedTypeElement : object {
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [NotNullAttribute]
private ITreeNode myElement;
    [CanBeNullAttribute]
private ITypeParameter[] myTypeParameters;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TypeParametersCount>k__BackingField;
    public string ShortName { get; }
    public IPsiModule Module { get; }
    public bool IsDynamic { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public CSharpUnresolvedTypeElement(string shortName, ITreeNode element, int typeParametersCount);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    [CompilerGeneratedAttribute]
public sealed virtual int get_TypeParametersCount();
    public virtual IClrTypeName GetClrName();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public sealed virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public bool Equals(CSharpUnresolvedTypeElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.CSharpUnresolvedTypeParameter : CSharpUnresolvedTypeElement {
    private CSharpUnresolvedTypeElement myUnresolvedTypeElement;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; }
    public TypeParameterVariance Variance { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsUnmanagedType { get; }
    public bool HasDefaultConstructor { get; }
    public bool IsNotNullableValueOrReferenceType { get; }
    public bool AllowsByRefLikeType { get; }
    public TypeParameterNullability Nullability { get; }
    public bool HasTypeConstraints { get; }
    public IList`1<IType> TypeConstraints { get; }
    public TypeParameterConstraintFlags Constraints { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public ITypeParametersOwner Owner { get; }
    public ITypeElement OwnerType { get; }
    public IParametersOwner OwnerFunction { get; }
    public IMethod OwnerMethod { get; }
    public CSharpUnresolvedTypeParameter(string shortName, ITreeNode element, int typeParametersNumber, int index, CSharpUnresolvedTypeElement unresolvedTypeElement);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    public virtual IClrTypeName GetClrName();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsUnmanagedType();
    public sealed virtual bool get_HasDefaultConstructor();
    public sealed virtual bool get_IsNotNullableValueOrReferenceType();
    public sealed virtual bool get_AllowsByRefLikeType();
    public sealed virtual TypeParameterNullability get_Nullability();
    public sealed virtual TypeParameterNullability GetNullability(ISubstitution explicitInheritorSubstitution);
    public sealed virtual bool get_HasTypeConstraints();
    public sealed virtual IList`1<IType> get_TypeConstraints();
    public sealed virtual TypeParameterConstraintFlags get_Constraints();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual ITypeParametersOwner get_Owner();
    public sealed virtual ITypeElement get_OwnerType();
    public sealed virtual IParametersOwner get_OwnerFunction();
    public sealed virtual IMethod get_OwnerMethod();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.ICSharpParameterOfUnresolvedMethod {
    public bool HasName { get; }
    public abstract virtual bool get_HasName();
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.ICSharpUnresolvedConstructor {
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.ICSharpUnresolvedField {
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.ICSharpUnresolvedMethod {
}
public interface JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.ICSharpUnresolvedTypeElement {
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.UnresolvedElementsUtil : object {
    [NotNullAttribute]
public static IList`1<ICSharpParameterOfUnresolvedMethod> CreateParameters(IParametersOwner owner, IEnumerable`1<ICSharpArgument> arguments);
}
public static class JetBrains.ReSharper.Psi.CSharp.Impl.UnresolvedSupport.UnresolvedSymbolTableUtil : object {
    [NotNullAttribute]
public static IEnumerable`1<string> CollectUnresolvedNames(ITreeNode context, Func`2<IDeclaredElement, bool> filter, bool useTopLocalScope);
    [NotNullAttribute]
public static ISymbolTable CreateSymbolTable(ISymbolTable symbolTable, IQualifiableReference qualifiableReference, bool useTopLocalScope);
    [PureAttribute]
[CanBeNullAttribute]
private static ILocalScope GetTopLocalScope(ITreeNode element);
    private static FrugalLocalList`1<Pair`2<ITreeNode, ISandBox>> GetSandboxes(ITreeNode realExpression, ITreeNode context);
    private static bool CompareQualifiers(ITreeNode element1, ITreeNode element2);
    [CanBeNullAttribute]
private static ITreeNode GetQualifierElement(ITreeNode element);
    private static bool CompareNodes(ITreeNode node1, ITreeNode node2);
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.UsingDirectiveComparer : object {
    [NotNullAttribute]
public static UsingDirectiveComparer Instance;
    private static UsingDirectiveComparer();
    public sealed virtual bool Equals(IUsingDirective x, IUsingDirective y);
    public sealed virtual int GetHashCode(IUsingDirective usingDirective);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Impl.UsingUtil : object {
    [NotNullAttribute]
public static TreeNodeMarker SaveImportListPositionMarker;
    private static UsingUtil();
    private static void AssertValidImportTarget(DeclaredElementInstance instance);
    [NotNullAttribute]
public static ICollection`1<IReference> GetUsingDirectiveUsageInContainingFile(IUsingDirective usingDirective);
    [NotNullAttribute]
public static Dictionary`2<IUsingDirective, IList`1<IReference>> GetUsingDirectiveUsage(ICSharpFile file);
    [NotNullAttribute]
public static OneToListMap`2<IUsingDirective, IReference> CollectReferences(ICSharpFile file, IEnumerable`1<IUsingDirective> usingDirectivesToCheck);
    public static bool CheckNamespaceAlreadyImported(ICSharpTypeAndNamespaceHolderDeclaration scope, INamespace nameSpace, string requiredExternAlias);
    public static bool CheckExtensionAlreadyImported(ICSharpTypeAndNamespaceHolderDeclaration scope, IMethod extensionMethod, string requiredExternAlias);
    public static bool CheckAlreadyImported(ICSharpTypeAndNamespaceHolderDeclaration scope, DeclaredElementInstance importTarget, string requiredExternAlias);
    public static bool CheckCanBeImported(ITreeNode context, DeclaredElementInstance importTarget);
    public static bool CheckTypeCanBeImported(ITreeNode context, ITypeElement typeElement, ISubstitution substitution);
    public static bool CheckNamespaceCanBeImported(ITreeNode context, INamespace nameSpace);
    [CanBeNullAttribute]
public static IUsingAliasDirective FindAliasTo(ICSharpTypeAndNamespaceHolderDeclaration scope, INamespace nameSpace, string requiredExternAlias);
    [CanBeNullAttribute]
public static IUsingAliasDirective FindAliasTo(ICSharpTypeAndNamespaceHolderDeclaration scope, ITypeElement typeElement, ISubstitution substitution, bool onlyVisible);
    [CanBeNullAttribute]
public static IUsingAliasDirective FindAliasTo(ICSharpTypeAndNamespaceHolderDeclaration scope, IType type);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.UsingUtil/<GetAliasDirectives>d__14")]
private static IEnumerable`1<IUsingAliasDirective> GetAliasDirectives(ICSharpTypeAndNamespaceHolderDeclaration scope, bool withContainingScopes, bool onlyVisible);
    [NotNullAttribute]
public static IUsingDirective AddImportTo(ICSharpTypeAndNamespaceHolderDeclaration scope, INamespace nameSpace, string externAlias);
    [NotNullAttribute]
public static IUsingDirective AddImportTo(ICSharpTypeAndNamespaceHolderDeclaration scope, DeclaredElementInstance importTarget, string externAlias, ITreeNode usageContext);
    [PureAttribute]
public static int CompareUsingSymbolDirectiveOrderStrings(string directive1, string directive2, bool sortUsingsWithSystemFirst);
    [PureAttribute]
public static int CompareNamesCaseSensitive(string name1, string name2);
    [PureAttribute]
[NotNullAttribute]
public static string GetQualifiedNameOrderString(IReferenceName referenceName);
    [NotNullAttribute]
public static IUsingDirective AddImportTo(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective directive, bool saveUsingListPosition, ITreeNode usageContext);
    [CanBeNullAttribute]
public static IUsingDirective GetUsingOf(IQualifiableReference reference);
    public static bool IsTrivialAlias(IUsingAliasDirective directive);
    public static FrugalLocalList`1<IUsingList> GetUsingLists(ICSharpFile file);
    private static void CollectAllImportDirectives(ICSharpTypeAndNamespaceHolderDeclaration declaration, List`1<IUsingDirective> directives);
    public static void RemoveImport(IUsingDirective usingDirective);
    public static void RemoveImport(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective);
    public static void RemoveImports(ICSharpTypeAndNamespaceHolderDeclaration scope, IReadOnlyList`1<IUsingDirective> usingDirectives);
    private static IUsingDirective AddImportAfterInternal(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective, ITreeNode anchor);
    private static IUsingDirective AddImportBeforeInternal(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective, ITreeNode anchor);
    [ExtensionAttribute]
[NotNullAttribute]
private static IUsingList EnsurePositionAfterPP(IUsingList usingList);
    public static IUsingDirective AddImportAfter(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective, ITreeNode anchor);
    public static IUsingDirective AddImportBefore(ICSharpTypeAndNamespaceHolderDeclaration scope, IUsingDirective usingDirective, ITreeNode anchor);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool CanRequireImport(IReference reference);
    [NotNullAttribute]
public static IList`1<Conflict> GetImportConflicts(ICSharpTypeAndNamespaceHolderDeclaration scope, INamespace nameSpace, string externAlias);
    [NotNullAttribute]
public static IList`1<Conflict> GetImportConflicts(ICSharpTypeAndNamespaceHolderDeclaration scope, DeclaredElementInstance`1<ITypeElement> target, string externAlias);
    [NotNullAttribute]
internal static IList`1<Conflict> GetImportConflicts(ICSharpTypeAndNamespaceHolderDeclaration scope, DeclaredElementInstance target, string externAlias, Key`1<DeclaredElementInstance> filterKey, TReference referenceToTryResolve, Action`1<TReference> referenceResolve);
    private static bool IsOkResolveResult(ResolveErrorType errorType);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Impl.UsingUtil/<FindAllReferencesTo>d__38")]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<IReference> FindAllReferencesTo(ICSharpFile file, IUsingDirective usingDirective);
    internal static bool CheckAliasValidInScope(ICSharpTypeAndNamespaceHolderDeclaration scope, string aliasName);
    public static INodeTreeNavigator CreateUsingListNavigator(IUsingList usingList);
    [CompilerGeneratedAttribute]
internal static bool <FindAliasTo>g__IsAliasTo|11_0(IUsingAliasDirective usingAliasDirective, INamespace namespaceElement, string requiredExternAlias);
    [CompilerGeneratedAttribute]
internal static bool <FindAliasTo>g__IsAliasTo|12_0(IUsingAliasDirective aliasDirective, DeclaredElementInstance declaredElementInstance);
    [CompilerGeneratedAttribute]
internal static bool <FindAliasTo>g__IsAliasTo|13_0(IUsingAliasDirective usingAliasDirective, IType type);
    [CompilerGeneratedAttribute]
internal static bool <GetAliasDirectives>g__IsVisible|14_0(IUsingAliasDirective aliasDirective, <>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <CompareUsingSymbolDirectiveOrderStrings>g__IsSystemNamespaceDirective|17_0(string qualifiedImportText);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <CompareUsingSymbolDirectiveOrderStrings>g__IsWindowsNamespaceDirective|17_1(string qualifiedImportText);
    [CompilerGeneratedAttribute]
internal static void <GetQualifiedNameOrderString>g__Append|19_0(IReferenceName referenceName, StringBuilder builder);
    [CompilerGeneratedAttribute]
internal static void <GetQualifiedNameOrderString>g__AppendType|19_1(ITypeUsage typeUsage, StringBuilder builder);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static IUsingDirective <AddImportTo>g__LastGlobalUsingDirective|20_0(ICSharpTypeAndNamespaceHolderDeclaration scope);
    [CompilerGeneratedAttribute]
internal static void <GetUsingLists>g__CollectAllImportLists|23_0(ICSharpTypeAndNamespaceHolderDeclaration declaration, FrugalLocalList`1& lists);
    [CompilerGeneratedAttribute]
internal static bool <FindAllReferencesTo>g__CheckReference|38_0(IReference reference, <>c__DisplayClass38_0& );
    [CompilerGeneratedAttribute]
internal static bool <FindAllReferencesTo>g__CheckCandidate|38_1(ResolveResultWithInfo resolveResult, IDeclaredElement candidate, <>c__DisplayClass38_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Impl.Utf8StringConcatenationOperator : PredefinedOperator {
    [NullableContextAttribute("1")]
public Utf8StringConcatenationOperator(IPsiModule module);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Injected.AnnotatedInjectionByLanguageInjectionAttributeNodeProvider : AnnotatedInjectionByAttributeNodeProvider {
    [NotNullAttribute]
private Lazy`1<LanguageInjectionAnnotationProvider> myAnnotationProvider;
    private static string LanguageInjectionAttributeShortName;
    protected string AttributeShortName { get; }
    protected AnnotatedInjectionByLanguageInjectionAttributeNodeProvider(CodeAnnotationsCache codeAnnotationsCache);
    public virtual bool Check(ITreeNode node, ILiteralsInjectionDataProvider injectedContext, Object& data);
    public virtual string GetPrefix(ITreeNode node, object data);
    public virtual string GetSuffix(ITreeNode node, object data);
    protected virtual string get_AttributeShortName();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Injected.AnnotatedInjectionByStringSyntaxAttributeNodeProvider : AnnotatedInjectionByAttributeNodeProvider {
    [NotNullAttribute]
private Lazy`1<StringSyntaxAnnotationProvider> myAnnotationProvider;
    [NotNullAttribute]
protected string AttributeShortName { get; }
    protected AnnotatedInjectionByStringSyntaxAttributeNodeProvider(CodeAnnotationsCache codeAnnotationsCache);
    protected virtual string get_AttributeShortName();
    public virtual bool Check(ITreeNode node, ILiteralsInjectionDataProvider injectedContext, Object& data);
    public virtual string GetPrefix(ITreeNode node, object data);
    public virtual string GetSuffix(ITreeNode node, object data);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Injected.AnnotatedXmlInjectionByLanguageInjectionAttributeNodeProvider : AnnotatedInjectionByLanguageInjectionAttributeNodeProvider {
    public string ProvidedLanguageID { get; }
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public string Guid { get; }
    public AnnotatedXmlInjectionByLanguageInjectionAttributeNodeProvider(CodeAnnotationsCache codeAnnotationsCache);
    public virtual string get_ProvidedLanguageID();
    public virtual PsiLanguageType get_SupportedOriginalLanguage();
    public virtual string get_Guid();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Injected.AnnotatedXmlInjectionByStringSyntaxAttributeNodeProvider : AnnotatedInjectionByStringSyntaxAttributeNodeProvider {
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public string ProvidedLanguageID { get; }
    public string Guid { get; }
    public AnnotatedXmlInjectionByStringSyntaxAttributeNodeProvider(CodeAnnotationsCache codeAnnotationsCache);
    public virtual PsiLanguageType get_SupportedOriginalLanguage();
    public virtual string get_ProvidedLanguageID();
    public virtual string get_Guid();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Injected.CSharpInjectionAnnotationChecker`1 : ValueType {
    [NotNullAttribute]
private ICodeAnnotationInfoProvider`2<IAttributesOwner, TAnnotationInfo> myAnnotationProvider;
    [NotNullAttribute]
private String[] myAttributeShortNames;
    public CSharpInjectionAnnotationChecker`1(ICodeAnnotationInfoProvider`2<IAttributesOwner, TAnnotationInfo> annotationProvider, String[] attributeShortNames);
    public bool TryGetInfo(IStringLiteralOwner stringLiteralOwner, TAnnotationInfo& annotationInfo);
    public bool TryGetInfo(IStringLiteralOwner stringLiteralOwner, TAnnotationInfo& annotationInfo, ICSharpArgumentsOwner& invocationInfo);
    private bool TryGetInfoByArgument(ICSharpArgumentInfo argumentInfo, ICSharpArgumentsOwner argumentsOwner, TAnnotationInfo& result);
    private bool TryGetInfoByReference(IReference memberReference, TAnnotationInfo& result);
    [PureAttribute]
private bool TryGetInfo(IDeclaredElement declaredElement, TAnnotationInfo& info);
    [PureAttribute]
private bool HasMemberWithAttribute(IPsiModule psiModule, string memberName);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Injected.CSharpLanguageInjectionTargetsFinderFactory : object {
    public sealed virtual ILanguageInjectionTargetsFinder CreateAnnotationTargetsFinder();
}
public static class JetBrains.ReSharper.Psi.CSharp.Injected.CSharpLanguageInjectionUtil : object {
    [NotNullAttribute]
private static Key`1<string> ourStringSyntaxKey;
    [NotNullAttribute]
private static Key`1<InjectionAnnotationInfo> ourLanguageInjectionKey;
    [NotNullAttribute]
private static HashSet`1<string> ourNonLanguageSyntaxNames;
    private static string NoInjectionId;
    private static InjectionAnnotationInfo ourNoInjectionInfo;
    private static CSharpLanguageInjectionUtil();
    [CanBeNullAttribute]
public static string TryGetStringSyntaxFor(IStringLiteralOwner stringLiteralOwner, StringSyntaxAnnotationProvider annotationProvider);
    [CanBeNullAttribute]
public static InjectionAnnotationInfo TryGetInjectionAnnotationInfo(IStringLiteralOwner stringLiteralOwner, LanguageInjectionAnnotationProvider annotationProvider);
    [ContractAnnotationAttribute("=> true, languageName:notnull; => false, languageName:null")]
public static bool TryGetAnyInjectedAnnotationInfo(IStringLiteralOwner stringLiteralOwner, LanguageInjectionAnnotationProvider languageInjectionAnnotationProvider, StringSyntaxAnnotationProvider stringSyntaxAnnotationProvider, String& languageName, String& prefix, String& suffix);
    public static CSharpInjectionAnnotationChecker`1<TAnnotationInfo> CreateAnnotationChecker(ICodeAnnotationInfoProvider`2<IAttributesOwner, TAnnotationInfo> annotationProvider, String[] attributeShortNames);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Injected.LanguageInjectionAttributeWatcher : object {
    public static IClrTypeName LanguageInjectionAttributeClrTypeName;
    public static IClrTypeName[] AllInjectionsClrNames;
    public IEnumerable`1<IClrTypeName> AttributeClrNamesToWatch { get; }
    private static LanguageInjectionAttributeWatcher();
    public sealed virtual IEnumerable`1<IClrTypeName> get_AttributeClrNamesToWatch();
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Injected.StringSyntaxAttributeWatcher : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IClrTypeName> <AttributeClrNamesToWatch>k__BackingField;
    public IEnumerable`1<IClrTypeName> AttributeClrNamesToWatch { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IClrTypeName> get_AttributeClrNamesToWatch();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Injected.XmlInCsStringsLanguageInjector : LanguageInjectorProviderInLiteralsWithRangeMarkersBase`3<IXmlFile, IStringLiteralOwner, CSharpLiteralInjectionTarget> {
    public string ProvidedInjectionID { get; }
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public PsiLanguageType ProvidedLanguage { get; }
    public XmlInCsStringsLanguageInjector(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, InjectionNodeProvidersViewer providersViewer, CSharpLiteralInjectionTarget injectionTarget);
    public virtual string get_ProvidedInjectionID();
    public virtual PsiLanguageType get_SupportedOriginalLanguage();
    public virtual PsiLanguageType get_ProvidedLanguage();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Injected.XmlInCsStringsPsiProvider : LiteralsInjectionPsiProvider`2<CSharpLanguage, InjectedXmlLanguage> {
    public bool ProvidedLanguageCanHaveNestedInjects { get; }
    public XmlInCsStringsPsiProvider(XmlInCsStringsLanguageInjector injectorProvider);
    public virtual bool get_ProvidedLanguageCanHaveNestedInjects();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Internal.CSharpLanguageLevelDiagnosticInfoProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Internal.CSharpLanguageLevelDiagnosticInfoProvider/<GetDiagnosticInfo>d__2")]
public sealed virtual IEnumerable`1<ValueTuple`2<string, object>> GetDiagnosticInfo(IFile file);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Internal.CSharpNullableContextDiagnosticInfoProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Internal.CSharpNullableContextDiagnosticInfoProvider/<GetDiagnosticInfo>d__2")]
public sealed virtual IEnumerable`1<ValueTuple`2<string, object>> GetDiagnosticInfo(IFile file);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Internal.CSharpOtherDiagnosticInfoProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Internal.CSharpOtherDiagnosticInfoProvider/<GetDiagnosticInfo>d__2")]
public sealed virtual IEnumerable`1<ValueTuple`2<string, object>> GetDiagnosticInfo(IFile file);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Internal.CSharpProjectConfigurationDiagnosticInfoProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Internal.CSharpProjectConfigurationDiagnosticInfoProvider/<GetDiagnosticInfo>d__2")]
public sealed virtual IEnumerable`1<ValueTuple`2<string, object>> GetDiagnosticInfo(IFile file);
}
public interface JetBrains.ReSharper.Psi.CSharp.INullableContextProvider {
    [CanBeNullAttribute]
public INullableContextModifier NullableContextModifier { get; }
    [PureAttribute]
public abstract virtual bool IsApplicable(IPsiModule psiModule);
    [PureAttribute]
public abstract virtual NullableContextKind GetNullableContextKind(IPsiModule psiModule);
    public abstract virtual INullableContextModifier get_NullableContextModifier();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.InvocationInfoExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<ICSharpArgumentInfo> AllArguments(ICSharpInvocationInfo invocation, bool isCandidateExtension);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
internal static ICSharpArgumentInfo CreateExpressionArgument(ICSharpInvocationInfo invocation, ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasNamedArguments(ICSharpInvocationInfo invocation);
}
public interface JetBrains.ReSharper.Psi.CSharp.IPrimaryConstructor {
}
public interface JetBrains.ReSharper.Psi.CSharp.IRecord {
    public bool PositionalFieldsAreSupported { get; }
    public abstract virtual bool get_PositionalFieldsAreSupported();
    [NullableContextAttribute("1")]
[PureAttribute]
public abstract virtual IEnumerable`1<PositionalParameterImplementation> GetPositionalParametersImplementations();
}
public interface JetBrains.ReSharper.Psi.CSharp.ITypeElementWithPrimaryConstructor {
    [NullableAttribute("2")]
public IPrimaryConstructor PrimaryConstructor { get; }
    [NullableContextAttribute("2")]
public abstract virtual IPrimaryConstructor get_PrimaryConstructor();
    [NullableContextAttribute("1")]
[PureAttribute]
public abstract virtual IReadOnlyCollection`1<IParameter> GetCapturedParameters(IList`1<IParameter> parameters);
}
public class JetBrains.ReSharper.Psi.CSharp.LocalFunctionIdSubstitution : IdSubstitution {
    [NotNullAttribute]
private ILocalFunctionDeclaration myLocalFunction;
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private IList`1<ITypeParameter> myTypeParameters;
    public IList`1<ITypeParameter> Domain { get; }
    private LocalFunctionIdSubstitution(ILocalFunctionDeclaration localFunction);
    [PureAttribute]
[NotNullAttribute]
private static IList`1<ITypeParameter> GetAllTypeParameters(ILocalFunctionDeclaration localFunction);
    [NotNullAttribute]
[PureAttribute]
public static ISubstitution Create(ILocalFunctionDeclaration localFunction);
    public virtual bool IsEmpty();
    public virtual bool IsValid();
    public virtual ISubstitution TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual IList`1<ITypeParameter> get_Domain();
}
public class JetBrains.ReSharper.Psi.CSharp.MemberSignatureComparer : object {
    public static MemberSignatureComparer ExplicitImplementationComparer;
    public static MemberSignatureComparer CSharpImplicitImplementationComparer;
    public static MemberSignatureComparer CSharpCloseImplicitImplementationComparer;
    public static MemberSignatureComparer DuplicateSourceComparer;
    public static MemberSignatureComparer RecordAPISignatureComparer;
    public static MemberSignatureComparer PartialMethodsComparer;
    public static MemberSignatureComparer PartialMethodsStrictComparer;
    public static MemberSignatureComparer InterceptorsComparer;
    public static MemberSignatureComparer InterceptorsStrictComparer;
    public static MemberSignatureComparer CSharpOverrideComparer;
    private static MemberSignatureComparer CSharpWithTupleNamesComparer;
    private static MemberSignatureComparer CSharpWithoutTupleNamesComparer;
    public static MemberSignatureComparer CSharpAccessorOverrideComparer;
    public static MemberSignatureComparer CSharpCustomModifierOverrideComparer;
    public static MemberSignatureComparer RuntimeSignatureComparer;
    public static MemberSignatureComparer RuntimeExplicitImplementationSignatureComparer;
    public static MemberSignatureComparer RuntimePlusRefOutSignatureComparer;
    public static MemberSignatureComparer RuntimeImplicitImplementationComparer;
    public static MemberSignatureComparer RetargetedExplicitImplementationComparer;
    public static MemberSignatureComparer CrefComparer;
    internal static MemberSignatureComparer CSharp10MethodGroupSignatureComparer;
    internal static MemberSignatureComparer MethodGroupSignatureComparer;
    private bool myConsiderName;
    private bool myConsiderExplicitlyImplementedInterfaces;
    private bool myConsiderReturnType;
    private bool myConsiderTypeConstraints;
    private bool myConsiderArity;
    private bool myConsiderCallingConvention;
    private RefKindCompareMode myRefKindCompareMode;
    private IEqualityComparer`1<IType> myTypeEqualityComparer;
    private MemberSignatureComparer(bool considerName, bool considerExplicitlyImplementedInterfaces, bool considerReturnType, bool considerTypeConstraints, bool considerCallingConvention, RefKindCompareMode refKindCompareMode, bool considerArity, IEqualityComparer`1<IType> typeEqualityComparer);
    private static MemberSignatureComparer();
    public bool Equals(ValueTuple`3<IParametersOwner, ISubstitution, bool> x, ValueTuple`3<IParametersOwner, ISubstitution, bool> y);
    private bool HaveSameParameterKind(IParameter xParameter, IParameter yParameter);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Naming.NameCanoniser : object {
    public sealed virtual string GetCanonicalShortName(string name);
    public sealed virtual string GetCanonicalQualifiedName(string name);
}
public class JetBrains.ReSharper.Psi.CSharp.Naming.NameComparer`1 : object {
    private bool myLongerNamesFirst;
    public NameComparer`1(bool longerNamesFirst);
    public sealed virtual int Compare(T x, T y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[NamedElementsBagAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage")]
public class JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpElementKindOfElementType : ElementKindOfElementType {
    public static IElementKind LAMBDA_PARAMETER;
    public static IElementKind PRIMARY_CTOR_PARAMETER;
    public static IElementKind ASYNC_METHOD;
    public static IElementKind TASK_RETURNING_METHOD;
    public static IElementKind LOCAL_FUNCTION;
    public static IElementKind ASYNC_LOCAL_FUNCTION;
    public static IElementKind TASK_RETURNING_LOCAL_FUNCTION;
    public static IElementKind CATCH_VARIABLE;
    public static IElementKind PURE_CLASS;
    public static IElementKind RECORD;
    [NullableAttribute("2")]
public PsiLanguageType Language { get; }
    [ObsoleteAttribute("Consider to use overload with resourceType and resourceName instead of presentableName.")]
protected CSharpElementKindOfElementType(string name, string presentableName, Func`2<IDeclaredElement, bool> isApplicable, IElementKind parent, RoslynNamingSymbolModifier modifier);
    protected CSharpElementKindOfElementType(string name, Type resourceType, string resourceName, Func`2<IDeclaredElement, bool> isApplicable, IElementKind parent, RoslynNamingSymbolModifier modifier);
    private static CSharpElementKindOfElementType();
    [NullableContextAttribute("2")]
public virtual PsiLanguageType get_Language();
}
[NamingConsistencyCheckerAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpNamingConsistencyChecker : ClrNamingConsistencyCheckerBase {
    protected virtual bool IsException(string canonicalName);
    protected virtual IDeclaredElement GetDeclaredElementToCheck(IDeclaration declaration);
    protected virtual bool IsUnnamedElement(IDeclaration declaration);
}
[ShellComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpNamingDefaultSettingValuesProvider : object {
    [CompilerGeneratedAttribute]
private ICollectionEvents`1<DefaultSettingValuesProvider> <Items>k__BackingField;
    public ICollectionEvents`1<DefaultSettingValuesProvider> Items { get; }
    public CSharpNamingDefaultSettingValuesProvider(ISettingsSchema schema);
    [CompilerGeneratedAttribute]
public sealed virtual ICollectionEvents`1<DefaultSettingValuesProvider> get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpNamingPolicyProvider : ClrPolicyProviderBase`1<CSharpNamingSettings> {
    protected bool UsePredefinedNamingSettings { get; }
    public CSharpNamingPolicyProvider(PsiLanguageType language, IPsiSourceFile sourceFile, IContextBoundSettingsStore settings);
    protected virtual bool get_UsePredefinedNamingSettings();
    public virtual NamingPolicy GetPolicy(IDeclaredElement declaredElement);
    public virtual NamingPolicy GetPolicy(NamedElementKinds namedElementKind, IElementKind namedElementDescriptor, AccessRightKinds accessRightKinds, StaticnessKinds staticnessKinds);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpNamingPolicyProviderFactory : object {
    private PsiLanguageType myLanguage;
    public CSharpNamingPolicyProviderFactory(PsiLanguageType language);
    public sealed virtual INamingPolicyProvider CreatePolicyProvider(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpNamingService : ClrNamingLanguageServiceBase {
    [NotNullAttribute]
private ICSharpExpectedTypesProvider myExpectedTypesProvider;
    private static Dictionary`2<string, string> ourNamesMap;
    public CSharpNamingService(CSharpLanguage language, IEnumerable`1<IClrNamingSuggestionAdviser> namingSuggestionAdvisers, ICSharpExpectedTypesProvider expectedTypesProvider);
    private static CSharpNamingService();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpNamingService/<SuggestRoots>d__3")]
public virtual IEnumerable`1<NameRoot> SuggestRoots(ITreeNode element, bool useExpectedTypes, INamingPolicyProvider policyProvider);
    [PureAttribute]
private static bool MakeSenseToUseOperandNames(IBinaryExpression binaryExpression);
    [NotNullAttribute]
[PureAttribute]
private static ICSharpExpression GetExpressionToUseForNaming(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpNamingService/<SuggestRoots>d__6")]
public virtual IEnumerable`1<NameRoot> SuggestRoots(IDeclaredElement declaredElement, INamingPolicyProvider policyProvider);
    public virtual NamedElementKinds GetNamedElementKind(IDeclaredElement element);
    protected virtual bool IsLocalDeclaration(IDeclaration declaration);
    protected virtual bool IsStaticScope(ILocalScope localScope);
    public virtual ScopeKind GetScopeKind(IDeclaredElement element);
    protected virtual ISymbolTable FilterConflictingElementsSymbolTable(ISymbolTable table, ITreeNode context);
    protected virtual void AddSymbolsFromNestedScope(ITreeNode context, HashSet`1<IDeclaredElement> conflicted, ITreeNode scope, string shortName);
    protected virtual NameRoot GetAbbreviation(NameRoot root);
    public virtual string MangleNameIfNecessary(string name, ITreeNode usageContext);
    protected virtual string Unmangle(string name);
    protected virtual bool IsMangled(string name);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<NameRoot> <>n__0(IDeclaredElement declaredElement, INamingPolicyProvider policyProvider);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.Naming.Settings.NamingSettings", "JetBrains.ReSharper.Psi.CSharp.Resources.Strings", "CNamingSettingsSettingDescription")]
[EditorConfigKeyAttribute("csharp")]
public class JetBrains.ReSharper.Psi.CSharp.Naming2.CSharpNamingSettings : ClrLanguageNamingSettingsKeyBase {
}
[NamingCheckExceptionAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Naming2.SuppressMainMethodRenameSuggestion : object {
    public string PredefinedName { get; }
    public string get_PredefinedName();
    public sealed virtual bool ShouldBeExcepted(IDeclaredElement declaredElement);
    public sealed virtual bool IsApplicable(IPsiSourceFile sourceFile);
}
public enum JetBrains.ReSharper.Psi.CSharp.NullableContext : Enum {
    public byte value__;
    public static NullableContext Default;
    public static NullableContext Enabled;
    public static NullableContext Disabled;
    public static NullableContext Restored;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class JetBrains.ReSharper.Psi.CSharp.NullableContextInfo : ValueType {
    public static NullableContextInfo Default;
    public static NullableContextInfo Disabled;
    public static NullableContextInfo Enabled;
    [CompilerGeneratedAttribute]
private NullableContext <AnnotationsContext>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableContext <WarningsContext>k__BackingField;
    public NullableContext AnnotationsContext { get; }
    public NullableContext WarningsContext { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public NullableContextInfo(NullableContext annotationsContext, NullableContext warningsContext);
    private static NullableContextInfo();
    [CompilerGeneratedAttribute]
public NullableContext get_AnnotationsContext();
    [CompilerGeneratedAttribute]
public NullableContext get_WarningsContext();
    public void Deconstruct(NullableContext& annotationsContext, NullableContext& warningsContext);
    public NullableContextInfo MergeWithDefault(bool isGeneratedFile, NullableContextInfo& moduleNullableContext);
    public sealed virtual bool Equals(NullableContextInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(NullableContextInfo left, NullableContextInfo right);
    public static bool op_Inequality(NullableContextInfo left, NullableContextInfo right);
    private string get_DebuggerDisplay();
}
public static class JetBrains.ReSharper.Psi.CSharp.ParameterScopeCompatibilityVerifier : object {
    public static bool ReportInvalidScopedOverrideAsError(IDeclaredElement baseMethod, IDeclaredElement overrideMethod);
    public static bool ReportInvalidScopedOverrideAsError(IDeclaredElement method, IFunctionPointerType functionPointer);
    public static bool RequiresValidScopedOverrideForRefSafety(IParametersOwner parametersOwner, IResolveContext resolveContext);
    public static bool ScopedModifiersAreCompatible(bool allowVariance, ScopedKind baseScope, bool baseHasUnscopedRefAttribute, ScopedKind overrideScope, bool overrideHasUnscopedRefAttribute);
}
internal class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpFilteringLexer : FilteringLexer {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private ILexer`1<int> myTypedLexer;
    [CanBeNullAttribute]
private CSharpPreprocessor myPreprocessor;
    public bool LastSkippedDefinitelyContainsLineBreak;
    [DebuggerBrowsableAttribute("0")]
public int CurrentPosition { get; public set; }
    public CSharpFilteringLexer(ILexer`1<int> lexer, CSharpPreprocessor preProcessor);
    protected virtual bool Skip(TokenNodeType tokenType);
    protected virtual void SkipFilteredTokens();
    public sealed virtual int get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(int value);
}
public class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexer : CSharpLexerGenerated {
    public CSharpLexer(IBuffer buffer);
    [PureAttribute]
public static bool IsWhitespace(string input);
    [PureAttribute]
public static bool IsWhitespace(char ch);
    [PureAttribute]
public static bool IsNewLine(char ch);
    [PureAttribute]
[CanBeNullAttribute]
public static TokenNodeType GetKeyword(string keyword);
    [PureAttribute]
public static bool IsKeyword(string input);
    [PureAttribute]
public static bool IsContextualKeyword(string input);
    [PureAttribute]
public static bool IsContextualQueryKeyword(string input);
    [PureAttribute]
public static bool IsInsideInterpolatedString(UInt32 lexerState);
    [PureAttribute]
public static ValueTuple`2<NullableContext, NullableContext> GetNullableContext(UInt32 lexerState);
    [PureAttribute]
public static RawInterpolatedStringInfo GetRawInterpolatedStringInfo(UInt32 lexerState);
    public virtual TokenNodeType _locateToken();
}
public class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerGenerated : object {
    private static int YY_F;
    private static int YY_NO_STATE;
    private static int YY_NOT_ACCEPT;
    private static int YY_START;
    private static int YY_END;
    private static int YY_NO_ANCHOR;
    private static int YY_BOL;
    private static int YY_EOF;
    private int yy_buffer_index;
    private int yy_buffer_start;
    private int yy_buffer_end;
    private IBuffer yy_buffer;
    private int yy_eof_pos;
    private bool yy_at_bol;
    private int yy_lexical_state;
    protected static int PPMESSAGE;
    protected static int ISR;
    protected static int IS_RAW_TEXT;
    protected static int PPNULLABLE;
    protected static int ISV;
    protected static int YYINITIAL;
    protected static int PPDIGITS;
    protected static int PPSHARP;
    protected static int PPSYMBOL;
    protected static int START_LINE;
    protected static int IS_RAW;
    private static Int32[] yy_state_dtrans;
    private static int YY_E_INTERNAL;
    private static int YY_E_MATCH;
    private static String[] yy_error_string;
    private static Int32[] yy_acpt;
    private static Int32[] yy_cmap;
    private static Int32[] yy_rmap;
    private static Int32[0...,0...] yy_nxt;
    [NotNullAttribute]
protected static LexerDictionary`1<TokenNodeType> Keywords;
    [NotNullAttribute]
protected static HashSet`1<string> KeywordNames;
    [NotNullAttribute]
protected static HashSet`1<string> ContextualKeywordNames;
    [NotNullAttribute]
protected static HashSet`1<string> ContextualQueryKeywordNames;
    [CanBeNullAttribute]
private TokenNodeType myCurrentTokenType;
    [NotNullAttribute]
private ImmutableStack`1<InterpolatedStringStackItem> myInterpolatedStringStack;
    [NotNullAttribute]
private ImmutableStack`1<RawInterpolatedStringInfo> myRawInterpolatedStringStack;
    private NullableContextState myNullableContextState;
    public UInt32 LexerStateEx { get; }
    public CSharpLexerState CurrentPosition { get; public set; }
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public int LexemIndent { get; }
    public IBuffer Buffer { get; }
    protected int BufferIndex { get; protected set; }
    protected int BufferStart { get; protected set; }
    protected int BufferEnd { get; protected set; }
    public int EOFPos { get; }
    protected int LexicalState { get; protected set; }
    public CSharpLexerGenerated(IBuffer buffer);
    public CSharpLexerGenerated(IBuffer buffer, int startOffset, int endOffset);
    private static CSharpLexerGenerated();
    private T Coalesce(T first, T second);
    private void yybegin(int state);
    private void yy_move_end();
    private static bool yy_isnewline(char c);
    internal string yytext();
    private int yylength();
    private void yy_error(int code, bool fatal);
    public virtual TokenNodeType _locateToken();
    private TokenNodeType MakeToken(TokenNodeType type);
    public sealed virtual void Start();
    public sealed virtual void Start(int startOffset, int endOffset, UInt32 state);
    public sealed virtual void Advance();
    public sealed virtual UInt32 get_LexerStateEx();
    public sealed virtual CSharpLexerState get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(CSharpLexerState value);
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual int get_LexemIndent();
    public sealed virtual IBuffer get_Buffer();
    protected int get_BufferIndex();
    protected void set_BufferIndex(int value);
    protected int get_BufferStart();
    protected void set_BufferStart(int value);
    protected int get_BufferEnd();
    protected void set_BufferEnd(int value);
    public sealed virtual int get_EOFPos();
    protected int get_LexicalState();
    protected void set_LexicalState(int value);
    private void LocateToken();
    private void PrepareNullableContextChange(NullableContext newContext);
    private void FixupNullableContextChangeTarget(NullableContextChangeTarget changeTarget);
    private void ApplyNullableContextChange();
    private void PushInterpolatedStringStackItem(InterpolatedStringStackItem item);
    private void PopInterpolatedStringStackItem(InterpolatedStringStackItem item);
    protected void RestoreState();
    [PureAttribute]
private static int ToState(InterpolatedStringStackItem item);
    private TokenNodeType ScanRawStringLiteral();
    private TokenNodeType ScanRawInterpolatedStringStart();
    private TokenNodeType ScanRawInterpolatedStringText();
    private TokenNodeType HandleCloseBraceInRawInterpolation();
    private void ConsumeWhitespace();
    private int ConsumeQuoteSequence();
    private int ConsumeDollarSignSequence();
    private int ConsumeOpenBraceSequence();
    private int ConsumeCloseBraceSequence();
    private int ConsumeCharSequence(char ch);
    [PureAttribute]
protected static bool IsWhitespace(char ch);
    [PureAttribute]
protected static bool IsNewLine(char ch);
    protected void AdvancePastNewLine();
    [CompilerGeneratedAttribute]
private void <ScanRawStringLiteral>g__ScanMultiLineRawStringLiteral|98_0(<>c__DisplayClass98_0& );
    [CompilerGeneratedAttribute]
private bool <ScanRawStringLiteral>g__ScanMultiLineRawStringLiteralLine|98_1(<>c__DisplayClass98_0& );
    [CompilerGeneratedAttribute]
private void <ScanRawStringLiteral>g__ScanSingleLineRawStringLiteral|98_2(<>c__DisplayClass98_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerState : ValueType {
    public TokenNodeType CurrentTokenType;
    public ImmutableStack`1<InterpolatedStringStackItem> InterpolatedStringStack;
    public ImmutableStack`1<RawInterpolatedStringInfo> RawInterpolatedStringStack;
    public NullableContextState NullableContextState;
    public int BufferIndex;
    public int BufferStart;
    public int BufferEnd;
    public int LexicalState;
}
internal class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpLexerTypeEvidenceState : ValueType {
    private State myState;
    public bool IsEvidentTypeContext { get; }
    private CSharpLexerTypeEvidenceState(State state);
    public static CSharpLexerTypeEvidenceState Create();
    public bool get_IsEvidentTypeContext();
    public void ProcessCurrentToken(ILexer lexer);
}
internal class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpMissingTokensInserter : MissingTokenInserterBase {
    [NotNullAttribute]
private ILexer myLexer;
    [CanBeNullAttribute]
private PreProcessorParser myPreProcessorParser;
    private CSharpMissingTokensInserter(ILexer lexer, ITokenOffsetProvider offsetProvider, PreProcessorParser preProcessorParser, ITokenIntern intern);
    protected virtual void ProcessLeafElement(TreeElement root);
    private void ProcessInactiveBranch(int leafOffset, CompositeElement parent, TreeElement anchor);
    private void CreateDocCommentBlock(TreeElement anchor, TreeElement token1, int leafOffset);
    private static void MoveDocCommentBlockInPlace(TreeElement anchor, DocCommentBlock docCommentBlock);
    private static void MoveLastSpacesOutside(CompositeElement element, CompositeElement parent, ITreeNode anchor, bool includeLineBreaks);
    [NotNullAttribute]
private TreeElement CreateMissingToken();
    private void Patch(CompositeElement root);
    [PureAttribute]
private static bool IsNodeToAttachCommentTo(ITreeNode descendant);
    private static void PatchImportList(CompositeElement root, IUsingList importsList);
    [PureAttribute]
private static bool CanAttachCommentNode(TreeElement root);
    private static void PatchCommentsAfterStatement(CompositeElement statementLike);
    public static void Run(TreeElement node, ILexer lexer, ITokenOffsetProvider offsetProvider, bool trimTokens, PreProcessorParser preProcessorParser, ITokenIntern tokenIntern);
}
internal class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParser : CSharpParserGenerated {
    [NotNullAttribute]
private ILexer`1<int> myOriginalLexer;
    [NotNullAttribute]
private CommonIdentifierIntern myCommonIdentifierIntern;
    [NotNullAttribute]
private CSharpPreprocessor myPreprocessor;
    [NotNullAttribute]
private IExpandChameleonStrategy myChameleonsStrategy;
    [CanBeNullAttribute]
private ITokenIntern myTokenIntern;
    private CSharpLanguageLevel myLanguageLevel;
    private bool myIsInAsync;
    private int myQueryDepth;
    private int myBlockDepth;
    private static int MaxNestedExpressions;
    private int myNestedExpressionCount;
    private static int MaxNestedUnaryExpressions;
    private int myNestedUnaryExpressionCount;
    private bool myIsInPattern;
    private bool myTopLevelLocalFunctionSpeculativeParse;
    private bool myForceConditionalAccessExpression;
    private bool myDoNotCreateChameleonForCollectionExpression;
    private static int TooDeepSyntaxThreshold;
    private bool IsInAsync { get; }
    private bool IsInQuery { get; }
    [NotNullAttribute]
public ITokenIntern TokenIntern { get; }
    public CSharpParser(ILexer`1<int> lexer, IEnumerable`1<PreProcessingDirective> defines, CommonIdentifierIntern commonIdentifierIntern, CSharpLanguageLevel languageLevel);
    public sealed virtual void SetChameleonExpansionMode(bool expandImmediately);
    private bool get_IsInAsync();
    private bool get_IsInQuery();
    private void SetInAsync(bool value);
    private void EnterQuery();
    private void LeaveQuery();
    public sealed virtual void SetupParsingContext(CSharpParsingContext parsingContext);
    [PureAttribute]
private bool GetIsAsyncByCheckingParentDeclaration(CompositeElement parent);
    public sealed virtual void SetupParsingFromExistingTree(ITreeNode treeContext);
    private bool IsCurrentTokenQueryKeywordInQuery();
    [PureAttribute]
private bool IsCurrentTokenQueryContextualKeyword();
    [PureAttribute]
private bool IsTrueIdentifier();
    private void InsertMissingTokens(TreeElement result, bool trimMissingTokens);
    [CanBeNullAttribute]
private TreeElement PrepareElement(CompositeElement dummyHolder, bool trimMissingTokens);
    [NotNullAttribute]
public sealed virtual IFile ParseFile();
    public virtual void ParseCompilationUnit(CompositeElement result);
    [PureAttribute]
private bool IsTopLevelMemberStart();
    public virtual TreeElement ParseCSharpNamespaceDeclaration();
    [NotNullAttribute]
public virtual TreeElement ParseNamespaceBody();
    [NotNullAttribute]
private TreeElement ParseNamespaceBodyCore(bool hasSemicolonAfterName);
    public virtual TreeElement ParseUsingList();
    private TreeElement ParseUsingListCore(bool isTopLevelContext);
    public virtual TreeElement ParseUsingDirective(TreeElement globalKeyword, TreeElement usingKeyword, TreeElement staticKeyword, TreeElement unsafeKeyword);
    public virtual void ParseUsingDirectiveAuxError(CompositeElement result, TreeElement globalKeyword, TreeElement usingKeyword, TreeElement staticKeyword, TreeElement unsafeKeyword);
    protected virtual CompositeElement HandleErrorInUsingDirective(CompositeElement result, SyntaxError error);
    private bool IsUsingDirectiveFollows(bool includeSemicolon);
    protected virtual CompositeElement HandleErrorInUsingSymbolDirective(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInUsingDirectiveAuxError(CompositeElement result, SyntaxError error);
    private bool IsPossibleTopLevelUsingDeclarationOrStatement();
    [CanBeNullAttribute]
public virtual TreeElement ParseTopLevelCode();
    private bool IsFollowedByTopLevelMember();
    private bool IsPossibleTopLevelNewExpression();
    private bool IsCollectionExpression();
    private bool IsPossibleMemberName();
    private Nullable`1<bool> IsPossibleTypedIdentifierStart(bool allowThisKeyword);
    protected virtual CompositeElement HandleErrorInNamespaceMemberDeclarationAux(CompositeElement result, SyntaxError error);
    [CanBeNullAttribute]
public sealed virtual IBlock ParseCodeBlock();
    private void ParseNonParsableBlockOrExpression(int initialLexerPosition, CompositeElement result);
    private CompositeElement ParseBlockWithNonparsableElement(int initialLexerPosition);
    private CompositeElement ParseCollectionExpressionWithNonparsableElement(int initialLexerPosition);
    public sealed virtual ITreeNode ParseMemberDeclaration();
    public sealed virtual ICSharpExpression ParseExpression();
    public sealed virtual ICSharpStatement ParseStatement();
    [MustUseReturnValueAttribute]
protected virtual TreeElement CreateToken();
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private TreeElement CreateToken(TokenNodeType tokenType);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public virtual TreeElement ParseIdentifier();
    private static void ThrowIdentifierExpected();
    private void ThrowInvalidExpressionTerm();
    public virtual TreeElement ParsePostfixOperatorExpression();
    public virtual TreeElement ParseElementAccessExpression();
    public virtual TreeElement ParseInvocationExpression();
    public virtual TreeElement ParseSuppressNullableWarningExpression();
    public virtual void ParseArrayCreationAux(CompositeElement result);
    private TreeElement ParsePrimaryFollow(CompositeElement primaryCandidate);
    protected virtual CompositeElement HandleErrorInMultipleFieldDeclaration(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInMultipleEventDeclaration(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInConstructorDeclaration(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInIndexerDeclaration(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInPropertyDeclaration(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInMethodDeclaration(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInConversionOperatorDeclaration(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInSignOperatorDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseErroneousBlock(CompositeElement result);
    public virtual void ParseNamespaceErroneousBlock(CompositeElement result);
    [NotNullAttribute]
private static CompositeElement CreateMissingDimensionExpressionError();
    [NotNullAttribute]
public virtual TreeElement ParseErrorElement();
    public virtual TreeElement ParsePrimaryExpression();
    [PureAttribute]
private bool IsTargetTypedObjectCreation();
    public virtual TreeElement ParseUnaryExpression();
    private CompositeElement ParseAnonymousMethod();
    private bool IsPossibleStaticAsyncDelegate();
    public virtual TreeElement ParseReferenceExpression();
    public virtual void ParseGlobalAttributeSectionAux(CompositeElement result);
    public virtual void ParseExternAliasDirectivesAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInExternAliasDirective(CompositeElement result, SyntaxError error);
    private bool LookaheadAliasKeyword();
    [NotNullAttribute]
public virtual TreeElement ParseAttribute();
    public virtual void ParseAttributeArguments(CompositeElement result);
    public virtual void ParseDeclarationOrExpressionOrLabelStatement(CompositeElement result);
    [PureAttribute]
private bool ShouldParseBadAwaitExpression(TokenNodeType lookahead);
    protected virtual CompositeElement HandleErrorInExpressionStatement(CompositeElement result, SyntaxError error);
    public virtual void ParseMultipleEventDeclarationTerminator(CompositeElement result);
    public virtual void ParseDeclarationOrExpressionOrLabelStatementError(CompositeElement result, TreeElement elseKeyword);
    public virtual TreeElement ParseDeclarationStatement();
    public virtual TreeElement ParseMultipleLocalVariableDeclaration();
    [CanBeNullAttribute]
private TreeElement TryParseLocalFunctionDeclaration();
    public virtual TreeElement ParseForInitializer();
    public virtual void ParseResourceAcquisition(CompositeElement result);
    private bool IsUsingStatementVariableDeclaration(ScanTypeFlags st);
    protected virtual CompositeElement HandleErrorInVariableInitializer(CompositeElement result, SyntaxError error);
    protected virtual CompositeElement HandleErrorInLocalVariableDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseSwitchGoverningExpression(CompositeElement result);
    [NotNullAttribute]
private CompositeElement ParseParenthesizeExpressionOrTupleExpression();
    private ValueTuple`2<TreeElement, CompositeElement> ParseExpressionWithParenthesesOrTupleExpression(TreeElement lparenth, bool forSwitchStatement);
    [NotNullAttribute]
public virtual TreeElement ParseClassBody();
    private bool IsCorrectMemberEnd(TokenNodeType tokenType);
    public virtual TreeElement ParseCollectionElementInitializer();
    [NotNullAttribute]
public virtual TreeElement ParseCSharpArgument();
    [NotNullAttribute]
public virtual TreeElement ParseTupleComponent();
    [NotNullAttribute]
public virtual TreeElement ParseArgumentList();
    [NotNullAttribute]
private TreeElement ParseInitializerAux(CompositeNodeType nodeType, InitializerElementParseFunction parseElement, ErrorHandle handleError, bool allowCommaAtEnd);
    public virtual TreeElement ParseMemberInitializer();
    [NotNullAttribute]
public virtual TreeElement ParseArrayInitializer();
    public virtual TreeElement ParseUserTypeUsage();
    public virtual TreeElement ParseTypeUsage();
    private TreeElement ParseTypeUsage(Nullable`1<NameOptions> nameOptions);
    private TreeElement ParseTypeUsage(Nullable`1<NameOptions> nameOptions, Int32& underlyingTypeEndPosition);
    public virtual TreeElement ParseArrayTypeUsage();
    public virtual TreeElement ParseNullableTypeUsage();
    [NotNullAttribute]
internal TreeElement ParseArrayInitializerWithoutChameleon();
    [CanBeNullAttribute]
private CompositeElement HandleChameleonArrayInitializer();
    [NotNullAttribute]
internal TreeElement ParseArrayInitializerAndInsertMissingTokens();
    [NotNullAttribute]
public virtual TreeElement ParseObjectInitializer();
    [NotNullAttribute]
public virtual TreeElement ParseCollectionExpression();
    [CanBeNullAttribute]
private CompositeElement HandleChameleonCollectionExpression();
    private TreeElement ParseCollectionExpressionWithoutChameleon();
    [NotNullAttribute]
internal TreeElement ParseCollectionExpressionAndInsertMissingTokens();
    [NotNullAttribute]
public virtual TreeElement ParseCollectionInitializer();
    [NotNullAttribute]
public virtual TreeElement ParseAnonymousObjectInitializer();
    [NotNullAttribute]
public virtual TreeElement ParseAnonymousMemberDeclaration();
    public virtual TreeElement ParseCreationExpressionInitializer();
    [NotNullAttribute]
public virtual TreeElement ParseAttributeSection();
    public virtual TreeElement ParseModifiersList();
    public virtual TreeElement ParseParameterModifiersList();
    public virtual TreeElement ParseFunctionPointerParameterModifiers();
    [NotNullAttribute]
public virtual TreeElement ParseAttributeList();
    public virtual TreeElement ParseReferenceName(TreeElement identifier);
    public virtual void ParseTheFMPIOorIdentifierDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods);
    public virtual void ParseOtherStructMemberDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t);
    public virtual void ParseTheFMPIDeclarationAux(CompositeElement result, TreeElement attrs, TreeElement mods, TreeElement t);
    public virtual void ParseBlockOrNonParsableBlock(CompositeElement result);
    public virtual void ParseOwnerQualificationAux(CompositeElement result);
    public virtual TreeElement ParseOwnerQualification(TreeElement memberIdentifier);
    public virtual TreeElement ParseEnumBody();
    public virtual void ParseStatementAux(CompositeElement result);
    private void ParseStatementCore(CompositeElement result, bool isTopLevel);
    public virtual void ParseEmbeddedStatementNoIdentifier(CompositeElement result);
    public virtual TreeElement ParseUnsafeCodePointerAccessExpression();
    public virtual void ParseTypeUsageInStackAlloc(CompositeElement result);
    public virtual void ParseForeachHeaderAux(CompositeElement result, TreeElement context);
    private bool MoveToMatchingRBrace();
    private bool MoveToMatchingRBracket();
    private bool MoveToMatchingToken(TokenNodeType openToken, TokenNodeType closeToken);
    private bool MoveToMatchingRBrace(Nullable`1& missingRBracePosition);
    private bool MoveToMatchingRBracket(Nullable`1& missingRBracketPosition);
    private bool MoveToMatchingToken(TokenNodeType openToken, TokenNodeType closeToken, Nullable`1& missingTokenPosition);
    private bool IsInFollowStatementAux(TokenNodeType tokenType);
    public ITokenIntern get_TokenIntern();
    public virtual void ParseFunctionBody(CompositeElement result);
    private bool HandleChameleonBody(CompositeElement result);
    public virtual TreeElement ParseConstructorInitializer();
    private bool ExpressionFollowsFailure();
    private ScanTypeArgumentListKind ScanTypeArgumentList(NameOptions options);
    private ScanTypeFlags ScanType(NameOptions nameOptions);
    private ScanTypeFlags ScanType(TokenNodeType& lastTokenType, NameOptions nameOptions);
    private ScanTypeFlags ScanNonArrayType(NameOptions nameOptions, TokenNodeType& lastTokenType);
    private bool ShouldParseNullableTypeMark(NameOptions nameOptions);
    private ScanTypeFlags ScanNamedTypePart(NameOptions nameOptions, TokenNodeType& lastTokenType);
    private ScanTypeFlags ScanTupleType(TokenNodeType& lastTokenType);
    private ScanTypeFlags ScanFunctionPointerType(TokenNodeType& lastTokenType);
    private ScanTypeFlags ScanPossibleTypeArgumentList();
    private ScanTypeFlags ScanPossibleTypeArgumentList(TokenNodeType& lastTokenType, Boolean& isDefinitelyTypeArgumentList);
    [PureAttribute]
private bool IsDotOrColonColon();
    [PureAttribute]
private bool IsTypeArgumentList(NameOptions nameOptions);
    [PureAttribute]
private bool IsFunctionPointerTypeUsageStart();
    [PureAttribute]
private bool IsPossibleFunctionPointerParameterListStart(TokenNodeType tokenType);
    [PureAttribute]
private bool IsGlobalAttribute(bool allowIncompleteTarget);
    private bool IsByNameArgument();
    public virtual void ParseLocalParameterAux(CompositeElement result);
    public virtual void ParseParameterAux(CompositeElement result);
    protected virtual bool ExpectScopedKeywordRegularParameterModifier();
    protected virtual bool ExpectScopedKeywordFunctionPointerParameterModifier();
    private bool ExpectScopedKeyword(bool isFunctionPointerParameter);
    protected virtual bool ExpectScopedKeywordInLocalDeclaration();
    protected virtual TreeElement MatchScopedKeywordInLocalDeclaration();
    private bool ShouldContextualKeywordBeTreatedAsModifier(bool parsingStatementNotDeclaration);
    private bool IsTypeDeclarationStart();
    protected virtual TreeElement MatchScopedKeywordRegularParameterModifier();
    protected virtual TreeElement MatchScopedKeywordFunctionPointerParameterModifier();
    public virtual TreeElement ParseTypeMemberRegularParameterDeclaration(TreeElement attrs);
    [NotNullAttribute]
public virtual TreeElement ParseLocalRegularParameterDeclaration(TreeElement attrs);
    [NotNullAttribute]
private TreeElement ParseRegularParameter(CompositeElement result);
    private bool IsDeclaration(DeclarationOrExpressionCheckContext context);
    private bool LookaheadIsDeclaration(DeclarationOrExpressionCheckContext context, bool hasVarOrDynamic);
    [PureAttribute]
private LocalFunctionScanResult IsLocalFunctionDeclaration(LocalFunctionCheckContext context);
    [MustUseReturnValueAttribute]
private ScanLocalFunctionFlags ScanLocalFunctionSignature(bool preferInvocation);
    public virtual void ParseLocalFunctionHeader(CompositeElement result);
    [PureAttribute]
private bool LooksLikeCastExpression(bool forPattern);
    private bool ScanCast(bool forPattern);
    [PureAttribute]
[NotNullAttribute]
private TreeElement MatchContextualKeyword(TokenNodeType tokenType);
    [PureAttribute]
private bool ExpectContextualKeyword(TokenNodeType type);
    [NotNullAttribute]
protected virtual TreeElement MatchPartialKeyword();
    protected virtual bool ExpectPartialKeyword();
    protected virtual TreeElement MatchWhereKeyword();
    protected virtual bool ExpectWhereKeyword();
    protected virtual TreeElement MatchAliasKeyword();
    protected virtual bool ExpectAliasKeyword();
    protected virtual TreeElement MatchYieldKeyword();
    protected virtual bool ExpectYieldKeyword();
    protected virtual TreeElement MatchVarKeyword();
    protected virtual bool ExpectVarKeyword();
    protected virtual TreeElement MatchFromKeyword();
    protected virtual bool ExpectFromKeyword();
    protected virtual TreeElement MatchByKeyword();
    protected virtual bool ExpectByKeyword();
    protected virtual TreeElement MatchGroupKeyword();
    protected virtual bool ExpectGroupKeyword();
    protected virtual TreeElement MatchSelectKeyword();
    protected virtual bool ExpectSelectKeyword();
    protected virtual TreeElement MatchAscendingKeyword();
    protected virtual bool ExpectAscendingKeyword();
    protected virtual TreeElement MatchDescendingKeyword();
    protected virtual bool ExpectDescendingKeyword();
    protected virtual TreeElement MatchEqualsKeyword();
    protected virtual bool ExpectEqualsKeyword();
    protected virtual TreeElement MatchIntoKeyword();
    protected virtual bool ExpectIntoKeyword();
    protected virtual TreeElement MatchJoinKeyword();
    protected virtual bool ExpectJoinKeyword();
    protected virtual TreeElement MatchLetKeyword();
    protected virtual bool ExpectLetKeyword();
    protected virtual TreeElement MatchOnKeyword();
    protected virtual bool ExpectOnKeyword();
    protected virtual TreeElement MatchOrderByKeyword();
    protected virtual bool ExpectOrderByKeyword();
    protected virtual TreeElement MatchAsyncKeyword();
    protected virtual bool ExpectRecordKeyword();
    protected virtual TreeElement MatchRecordKeyword();
    protected virtual bool ExpectDelegateTypeKeyword();
    protected virtual TreeElement MatchDelegateTypeKeyword();
    protected virtual bool ExpectWithKeyword();
    protected virtual TreeElement MatchWithKeyword();
    protected virtual bool ExpectAndKeyword();
    protected virtual TreeElement MatchAndKeyword();
    protected virtual bool ExpectOrKeyword();
    protected virtual TreeElement MatchOrKeyword();
    protected virtual bool ExpectNotKeyword();
    protected virtual TreeElement MatchNotKeyword();
    protected virtual bool ExpectGlobalKeyword();
    protected virtual TreeElement MatchGlobalKeyword();
    protected virtual bool ExpectRequiredKeyword();
    protected virtual TreeElement MatchRequiredKeyword();
    protected virtual bool ExpectScopedKeyword();
    protected virtual TreeElement MatchScopedKeyword();
    protected virtual bool ExpectFileKeyword();
    protected virtual TreeElement MatchFileKeyword();
    protected virtual bool ExpectAllowsKeyword();
    protected virtual TreeElement MatchAllowsKeyword();
    protected virtual bool ExpectAsyncKeyword();
    protected virtual TreeElement MatchAwaitKeyword();
    protected virtual bool ExpectAwaitKeyword();
    [NotNullAttribute]
protected virtual TreeElement MatchWhenKeyword();
    protected virtual bool ExpectWhenKeyword();
    private bool ExpectShiftLikeToken(TokenNodeType secondTokenType);
    private TreeElement MatchShiftLikeToken(TokenNodeType secondTokenType, TokenNodeType resultTokenType);
    protected virtual TreeElement MatchRShift();
    protected virtual bool ExpectRShift();
    private bool ExpectRShiftShiftToken(TokenNodeType lastTokenType);
    [NotNullAttribute]
private TreeElement MatchRShiftShiftToken(TokenNodeType lastTokenType, TokenNodeType resultToken);
    protected virtual bool ExpectRShiftShift();
    protected virtual TreeElement MatchRShiftShift();
    protected virtual bool ExpectRShiftShiftAssign();
    protected virtual TreeElement MatchRShiftShiftAssign();
    protected virtual TreeElement MatchRShiftAssign();
    protected virtual bool ExpectRShiftAssign();
    protected virtual TreeElement MatchGreater();
    protected virtual bool ExpectGreater();
    protected virtual bool LookaheadExpression();
    protected virtual bool LookaheadRefExpression();
    protected virtual bool LookaheadThrowOrRefExpression();
    public virtual TreeElement ParseCSharpExpression();
    [NotNullAttribute]
[PureAttribute]
private static CompositeElement Surround(TreeElement what, CompositeNodeType with);
    private TreeElement ParseExpressionNullC();
    [NotNullAttribute]
public virtual TreeElement ParseThrowExpression();
    [PureAttribute]
private bool ExpectThrowKeyword();
    [PureAttribute]
private bool ExpectRefKeyword();
    public virtual void ParseThrowOrRefExpression(CompositeElement result);
    public virtual void ParseThrowOrRefExpressionBody(CompositeElement result);
    public virtual void ParsePossiblyRefValue(CompositeElement result);
    public TreeElement ParsePossiblyRefValue();
    private TreeElement ParseExpressionCor();
    private TreeElement ParseExpressionCand();
    private TreeElement ParseExpressionIor();
    private TreeElement ParseExpressionEor();
    private TreeElement ParseExpressionAnd();
    private TreeElement ParseExpressionEqu();
    private TreeElement ParseExpressionAsIsFollow(CompositeElement primaryCandidate);
    private TreeElement ParseExpressionAsIs();
    [PureAttribute]
private bool IsCodeCompletionToken();
    private void ParseCodeCompletionToken(CompositeElement element);
    public virtual TreeElement ParsePattern();
    private TreeElement ParsePattern(PatternParsingMode parsingMode);
    private TreeElement ParseOrPattern(PatternParsingMode parsingMode);
    private TreeElement ParseAndPattern(PatternParsingMode parsingMode);
    private TreeElement ParseNegatedPattern(PatternParsingMode parsingMode);
    [NotNullAttribute]
private CompositeElement ParseParenthesizedPattern(PatternParsingMode parsingMode);
    private TreeElement ParsePrimaryPattern(PatternParsingMode parsingMode);
    [NotNullAttribute]
private TreeElement ParseListPattern(PatternParsingMode parsingMode);
    [NotNullAttribute]
public virtual TreeElement ParseSlicePattern();
    public virtual TreeElement ParseSpreadElement();
    [NotNullAttribute]
private CompositeElement ParseConstantOrTypePattern(PatternParsingMode parsingMode);
    [CanBeNullAttribute]
[MustUseReturnValueAttribute]
private CompositeElement ParsePatternContinued(TreeElement typeUsage, PatternParsingMode parsingMode);
    private TreeElement ParseSimpleDesignation(PatternParsingMode parsingMode);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
private CompositeElement ParseSubpatternList(CompositeNodeType nodeType, TokenNodeType closeTokenType);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
private CompositeElement ParseSubpatternList(CompositeNodeType nodeType, TokenNodeType closeTokenType, Func`2<CSharpParser, TreeElement> parseFunc, Func`2<CompositeElement, CompositeElement> wrapErrorElement);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
private TreeElement ParseSubpatternElement();
    [MustUseReturnValueAttribute]
private bool IsMakingProgress(Int32& lastTokenPosition);
    [PureAttribute]
private bool IsPossibleSubpatternElement();
    [PureAttribute]
private bool IsPossibleExpression(bool allowBinaryExpressions, bool allowAssignmentExpressions);
    [PureAttribute]
private bool LooksLikeTypeOfPattern();
    [PureAttribute]
private bool LooksLikeTupleArrayType();
    [MustUseReturnValueAttribute]
private ScanPatternFlags ScanPattern(PatternParsingMode parsingMode);
    [NotNullAttribute]
private static TreeElement ReplaceDiscardWithReferenceExpression(TreeElement pattern);
    [PureAttribute]
private bool IsValidPatternDesignation(PatternParsingMode parsingMode);
    [NotNullAttribute]
private TreeElement ParseExpression(Precedence precedence);
    [NotNullAttribute]
private CompositeElement ParseConstantOrTypePattern(Precedence precedence);
    [NotNullAttribute]
private TreeElement ParseRelationalPattern(TokenNodeType signToken);
    private TreeElement ParseExpressionRel();
    private TreeElement ParseExpressionRelAux(CompositeElement firstOperand);
    private TreeElement ParseExpressionShift();
    private TreeElement ParseExpressionShiftAux(CompositeElement firstOperand);
    private TreeElement ParseExpressionRange();
    private TreeElement ParseExpressionAdd();
    private TreeElement ParseExpressionAddAux(CompositeElement firstOperand);
    private TreeElement ParseExpressionMul();
    private TreeElement ParseExpressionMulAux(CompositeElement firstOperand);
    public virtual void ParseLambdaExpressionModifiers(CompositeElement result);
    public virtual void ParseLambdaExpressionReturnType(CompositeElement result);
    public virtual void ParseLambdaParameterAux(CompositeElement result, TreeElement lPar);
    [CanBeNullAttribute]
private TreeElement TryParseLambdaExpression();
    private TreeElement ParseExpressionLambda();
    public virtual TreeElement ParseSwitchExpression();
    private TreeElement ParseSwitchOrWithExpression();
    private void ParseSwitchExpressionBody(CompositeElement result);
    [NotNullAttribute]
public virtual TreeElement ParseSwitchExpressionArm();
    [CanBeNullAttribute]
private TreeElement ParsePatternGuardClauseInSwitchExpressionArm();
    public virtual TreeElement ParseWithExpression();
    private void ParseWithExpressionBody(CompositeElement result);
    [NotNullAttribute]
public virtual TreeElement ParseWithInitializerAssignment();
    [PureAttribute]
private bool IsPossibleLambdaExpression(Precedence precedence);
    [PureAttribute]
private bool IsPossibleLambdaExpressionCore(Precedence precedence);
    private bool IsAnonymousFunctionAsyncModifier();
    private bool ScanParenthesizedLambda(Precedence precedence);
    private bool ScanParenthesizedImplicitlyTypedLambda(Precedence precedence);
    private bool ScanExplicitlyTypedLambda(Precedence precedence);
    private bool IsPossibleAnonymousMethodExpression();
    private bool IsQueryExpressionBeginning();
    private TreeElement ParseExpressionCondOrAssn();
    private static TreeElement ExtractQuestion(CompositeElement result);
    protected virtual CompositeElement HandleErrorInAccessorDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAdditiveExpression();
    public virtual TreeElement ParseAsExpression();
    public virtual TreeElement ParseAssignmentExpression();
    public virtual TreeElement ParseBitwiseAndExpression();
    public virtual TreeElement ParseBitwiseExclusiveOrExpression();
    public virtual TreeElement ParseBitwiseInclusiveOrExpression();
    public virtual TreeElement ParseConditionalAndExpression();
    public virtual TreeElement ParseConditionalOrExpression();
    public virtual TreeElement ParseConditionalTernaryExpression();
    public virtual TreeElement ParseEqualityExpression();
    public virtual TreeElement ParseIsExpression();
    public virtual TreeElement ParseMultiplicativeExpression();
    public virtual TreeElement ParseNullCoalescingExpression();
    public virtual TreeElement ParseRelationalExpression();
    public virtual TreeElement ParseShiftExpression();
    protected virtual CompositeElement HandleErrorInQueryOrdering(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseRangeExpression();
    public virtual TreeElement ParseBlock();
    public virtual TreeElement ParseSwitchSection();
    [PureAttribute]
private bool IsSwitchSectionStart();
    private bool ExpectQueryClauseExplicitType();
    public virtual TreeElement ParseQueryExpression();
    protected virtual CompositeElement HandleErrorInQueryBody(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryFirstFrom();
    [NotNullAttribute]
public virtual TreeElement ParseQueryFromClause();
    [NotNullAttribute]
public virtual TreeElement ParseQueryJoinClause();
    [PureAttribute]
private bool IsPossibleDeconstructionLeft();
    [PureAttribute]
private bool IsPossibleDeclarationExpressionAsFirstArgumentOfTuple();
    [PureAttribute]
private bool IsPossibleDeclarationExpressionAsNonFirstArgumentOfTuple();
    [PureAttribute]
private bool IsPossibleDeclarationExpressionInOutArgument();
    private bool ScanPossibleDeclarationExpression(bool acceptPointerTypes, NodeTypeSet expectFollows);
    [PureAttribute]
private static bool IsPredefinedType(TokenNodeType tokenType);
    private bool ScanDesignation(bool permitParenthesizedDesignation);
    [MustUseReturnValueAttribute]
public virtual TreeElement ParseVariableDesignation(TreeElement context);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
public virtual TreeElement ParseParenthesizedVariableDesignation(TreeElement context);
    [CanBeNullAttribute]
public virtual TreeElement ParseNullableDirective(TreeElement sharp);
    public virtual void ParsePreprocessorDirectiveAux(CompositeElement result);
    [NotNullAttribute]
public virtual TreeElement ParseCastExpression();
    public virtual TreeElement ParseTypeParameterConstraint();
    public virtual TreeElement ParseAllowsRefStructConstraint();
    protected virtual TreeElement MatchConditionalSymbolName();
    protected virtual bool ExpectConditionalSymbolName();
    protected virtual CompositeElement HandleErrorInSignOperatorDeclarator(CompositeElement result, SyntaxError error);
    public DocCRefExpression ParseCRefExpression();
    public DocCRefParameterTypeName ParseCRefParameterTypeName();
    public virtual TreeElement ParseDocCRefElement();
    public virtual TreeElement ParseDocCRefParameterTypeName();
    [CompilerGeneratedAttribute]
private CompositeElement <ParseCompilationUnit>g__CreateUnexpectedTokenError|35_0();
    [CompilerGeneratedAttribute]
private bool <IsTopLevelMemberStart>g__IsObjectCreationExpression|36_0();
    [CompilerGeneratedAttribute]
private CompositeElement <ParseNamespaceBodyCore>g__CreateUnexpectedTokenError|39_0();
    [CompilerGeneratedAttribute]
private TreeElement <ParseNamespaceBodyCore>g__TryParseTopLevelCode|39_1();
    [CompilerGeneratedAttribute]
private bool <IsUsingDirectiveFollows>g__IsTypeAccess|45_0();
    [CompilerGeneratedAttribute]
private bool <ParseTopLevelCode>g__ShouldParseTopLevelCodeStatement|49_0();
    [CompilerGeneratedAttribute]
private TreeElement <ParseTopLevelCode>g__TryParseLocalFunctionDeclarationStatementWithRollbackIfFailed|49_1();
    [CompilerGeneratedAttribute]
private bool <ParseTopLevelCode>g__IsPossibleTopLevelRefVariableOrRefReturningLocalFunctionDeclaration|49_2();
    [CompilerGeneratedAttribute]
private bool <ParseClassBody>g__IsInClassBodyFollow|114_0(TokenNodeType tokenType);
    [CompilerGeneratedAttribute]
private void <ParseCollectionElementInitializer>b__116_0(CompositeElement r);
    [CompilerGeneratedAttribute]
private bool <ParseArgumentList>g__IsLikelyArgumentWithoutLeadingCommaOnTheSameLine|119_0();
    [CompilerGeneratedAttribute]
private CompositeElement <ParseTypeUsage>g__WrapWith|128_0(CompositeNodeType parentElementType, Int32& underlyingTypeUsageEndPosition, <>c__DisplayClass128_0& );
    [CompilerGeneratedAttribute]
private bool <ParseTypeUsage>g__ShouldParseRankSpecifier|128_1(<>c__DisplayClass128_0& );
    [CompilerGeneratedAttribute]
private void <ParseArrayInitializerWithoutChameleon>b__131_0(CompositeElement resultElement);
    [CompilerGeneratedAttribute]
private void <ParseAnonymousObjectInitializer>b__140_0(CompositeElement result);
    [CompilerGeneratedAttribute]
private bool <ParseStatementCore>g__ShouldParseDeclarationOrExpressionOrLabelStatement|157_0(<>c__DisplayClass157_0& );
    [CompilerGeneratedAttribute]
private void <ParseStatementCore>g__HandleErrorsInNonTopLevelStatement|157_1(<>c__DisplayClass157_0& );
    [CompilerGeneratedAttribute]
private void <ScanFunctionPointerType>g__SkipFunctionPointerCallingConvention|185_0(TokenNodeType& lastToken);
    [CompilerGeneratedAttribute]
private bool <ScanFunctionPointerType>g__SkipFunctionPointerParameter|185_1(bool validStart);
    [CompilerGeneratedAttribute]
internal static bool <ScanFunctionPointerType>g__IsParameterModifier|185_2(TokenNodeType tokenType);
    [CompilerGeneratedAttribute]
private bool <IsGlobalAttribute>g__ShouldParseAsCollectionExpression|192_0();
    [CompilerGeneratedAttribute]
private bool <ScanCast>g__IsBinaryPattern|218_0();
    [CompilerGeneratedAttribute]
private bool <ScanCast>g__IsBinaryPatternKeyword|218_2();
    [CompilerGeneratedAttribute]
private bool <ScanCast>g__CanFollowCast|218_1(TokenNodeType tokenType);
    [CompilerGeneratedAttribute]
private void <MatchRShiftShiftToken>g__ExpectToken|288_0(TokenNodeType expectedTokenType);
    [CompilerGeneratedAttribute]
private TreeElement <ParsePrimaryPattern>g__ParseTypeUsageWithoutNullableMark|327_0();
    [CompilerGeneratedAttribute]
private TreeElement <ParsePatternContinued>g__ParsePropertyDesignationClause|332_0();
    [CompilerGeneratedAttribute]
internal static CompositeElement <ParseSubpatternList>g__WrapErrorElement|334_0(CompositeElement errorElement);
    [CompilerGeneratedAttribute]
internal static bool <ParseSubpatternList>g__IsTerminator|335_0(CSharpFilteringLexer lexer);
    [CompilerGeneratedAttribute]
private TreeElement <ParseExpressionCondOrAssn>g__ParseThrowOrRefOrCondOrAssnExpression|381_0();
    [CompilerGeneratedAttribute]
internal static bool <ParseExpressionCondOrAssn>g__ContainsTernaryCollectionToReinterpret|381_1(TreeElement treeElement);
    [CompilerGeneratedAttribute]
private bool <ScanPossibleDeclarationExpression>g__ScanPossibleDeclarationExpressionCore|414_0(bool hasScoped, <>c__DisplayClass414_0& );
    [CompilerGeneratedAttribute]
internal static bool <ParseVariableDesignation>g__IsForeachContext|417_0(<>c__DisplayClass417_0& );
    [CompilerGeneratedAttribute]
internal static bool <ParseParenthesizedVariableDesignation>g__IsDesignationElement|418_0(ITokenNodeType tokenType);
    [CompilerGeneratedAttribute]
internal static bool <ParseParenthesizedVariableDesignation>g__IsPartOfDesignation|418_1(ITokenNodeType tokenType);
    [CompilerGeneratedAttribute]
internal static bool <ParseParenthesizedVariableDesignation>g__IsTerminator|418_2(ITokenNodeType tokenType);
    [CompilerGeneratedAttribute]
internal static TreeElement <ParseParenthesizedVariableDesignation>g__CreateMissingDesignation|418_3();
    [CompilerGeneratedAttribute]
private bool <ParseParenthesizedVariableDesignation>g__IsLikelyVariableDesignationWithoutLeadingCommaOnTheSameLine|418_4();
}
public enum JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpParsingContext : Enum {
    public int value__;
    public static CSharpParsingContext Default;
    public static CSharpParsingContext Async;
    public static CSharpParsingContext Query;
}
internal class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpPreprocessor : TreeNodeVisitor {
    [NotNullAttribute]
private ITokenOffsetProvider myOffsetProvider;
    [NotNullAttribute]
private HashSet`1<string> myDefinedSymbols;
    [NotNullAttribute]
private Stack`1<bool> myIfBranchesStack;
    [NotNullAttribute]
private Dictionary`2<int, ParsedDirective> myPpDirectivesByOffset;
    [NotNullAttribute]
private List`1<TextRange> myPPRanges;
    [NotNullAttribute]
private HashSet`1<string> myUsedConditionalNames;
    [NotNullAttribute]
private HashSet`1<string> myLocalDefines;
    [CanBeNullAttribute]
private string myCurrentDirectiveBalanceError;
    private ILexer`1<int> myLexer;
    private bool myHasNonTrivialPPDirectives;
    private bool myIsNotPreprocessing;
    private bool myHavePPDirectives;
    private bool myHasLastPpRange;
    private bool myLastPpRangeValue;
    private int myLastPpRangeStart;
    private int myLastPpRangeEnd;
    private static NodeTypeSet TRIVIAL_PP_TOKEN_TYPES;
    [NotNullAttribute]
public PreProcessingDirectivesInFile ConditionalNames { get; }
    public bool HasNonTrivialPPDirectives { get; }
    public CSharpPreprocessor(ITokenOffsetProvider offsetProvider, IEnumerable`1<PreProcessingDirective> defines);
    private static CSharpPreprocessor();
    [CanBeNullAttribute]
[PureAttribute]
public TreeElement GetPPDirectiveAtOffset(int offset);
    public PreProcessingDirectivesInFile get_ConditionalNames();
    public void PreProcess(ILexer`1<int> originalLexer, ILexer`1<int> filteredLexer, CSharpParser parser, ITokenIntern intern);
    private void ParsePreprocessorDirective(ILexer`1<int> originalLexer, ILexer`1<int> filteredLexer, CSharpParser parser, ITokenIntern intern);
    public bool get_HasNonTrivialPPDirectives();
    public bool HasPPDirectivesInRange(TextRange range);
    public bool IsTrivialPPTokenType(TokenNodeType tokenType);
    public bool IsInPPTokenRange(int startOffset);
    public virtual void VisitDefineDirective(IDefineDirective defineDirectiveParam);
    public virtual void VisitUndefDirective(IUndefDirective undefDirectiveParam);
    public virtual void VisitIfDirective(IIfDirective ifDirectiveParam);
    public virtual void VisitElifDirective(IElifDirective elifDirectiveParam);
    public virtual void VisitElseDirective(IElseDirective elseDirectiveParam);
    public virtual void VisitEndifDirective(IEndifDirective endifDirectiveParam);
    public virtual void VisitNullableDirective(INullableDirective nullableDirectiveParam);
    [NotNullAttribute]
private TreeElement ParseInactiveBranch();
    public void ReportMissingEndIfDirectiveIfAny(CompositeElement result);
}
public static class JetBrains.ReSharper.Psi.CSharp.Parsing.CSharpTokenType : object {
    public static int WHITE_SPACE_NODE_TYPE_INDEX;
    public static TokenNodeType WHITE_SPACE;
    public static int NEW_LINE_NODE_TYPE_INDEX;
    public static TokenNodeType NEW_LINE;
    public static int END_OF_LINE_COMMENT_NODE_TYPE_INDEX;
    public static TokenNodeType END_OF_LINE_COMMENT;
    public static int C_STYLE_COMMENT_NODE_TYPE_INDEX;
    public static TokenNodeType C_STYLE_COMMENT;
    public static int IDENTIFIER_NODE_TYPE_INDEX;
    public static TokenNodeType IDENTIFIER;
    public static int INTEGER_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType INTEGER_LITERAL;
    public static int FLOAT_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType FLOAT_LITERAL;
    public static int CHARACTER_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType CHARACTER_LITERAL;
    public static int STRING_LITERAL_REGULAR_NODE_TYPE_INDEX;
    public static TokenNodeType STRING_LITERAL_REGULAR;
    public static int STRING_LITERAL_VERBATIM_NODE_TYPE_INDEX;
    public static TokenNodeType STRING_LITERAL_VERBATIM;
    public static int SINGLE_LINE_RAW_STRING_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType SINGLE_LINE_RAW_STRING_LITERAL;
    public static int MULTI_LINE_RAW_STRING_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType MULTI_LINE_RAW_STRING_LITERAL;
    public static int INTERPOLATED_STRING_REGULAR_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_REGULAR;
    public static int INTERPOLATED_STRING_REGULAR_START_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_REGULAR_START;
    public static int INTERPOLATED_STRING_REGULAR_MIDDLE_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_REGULAR_MIDDLE;
    public static int INTERPOLATED_STRING_REGULAR_END_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_REGULAR_END;
    public static int INTERPOLATED_STRING_VERBATIM_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_VERBATIM;
    public static int INTERPOLATED_STRING_VERBATIM_START_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_VERBATIM_START;
    public static int INTERPOLATED_STRING_VERBATIM_MIDDLE_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_VERBATIM_MIDDLE;
    public static int INTERPOLATED_STRING_VERBATIM_END_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_VERBATIM_END;
    public static int INTERPOLATED_FORMAT_SPECIFIER_REGULAR_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_FORMAT_SPECIFIER_REGULAR;
    public static int INTERPOLATED_FORMAT_SPECIFIER_VERBATIM_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_FORMAT_SPECIFIER_VERBATIM;
    public static int INTERPOLATED_STRING_RAW_SINGLE_LINE_START_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_RAW_SINGLE_LINE_START;
    public static int INTERPOLATED_STRING_RAW_MULTI_LINE_START_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_RAW_MULTI_LINE_START;
    public static int INTERPOLATED_STRING_RAW_END_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_RAW_END;
    public static int INTERPOLATED_STRING_RAW_INSERT_START_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_RAW_INSERT_START;
    public static int INTERPOLATED_STRING_RAW_INSERT_END_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_RAW_INSERT_END;
    public static int INTERPOLATED_STRING_RAW_TEXT_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_RAW_TEXT;
    public static int INTERPOLATED_FORMAT_SPECIFIER_RAW_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_FORMAT_SPECIFIER_RAW;
    public static int BAD_CHARACTER_NODE_TYPE_INDEX;
    public static TokenNodeType BAD_CHARACTER;
    public static int CHAMELEON_NODE_TYPE_INDEX;
    public static TokenNodeType CHAMELEON;
    public static int PP_BAD_CHARACTER_NODE_TYPE_INDEX;
    public static TokenNodeType PP_BAD_CHARACTER;
    public static int PP_SKIPPED_LINE_NODE_TYPE_INDEX;
    public static TokenNodeType PP_SKIPPED_LINE;
    public static int PP_DEC_DIGITS_NODE_TYPE_INDEX;
    public static TokenNodeType PP_DEC_DIGITS;
    public static int PP_FILENAME_NODE_TYPE_INDEX;
    public static TokenNodeType PP_FILENAME;
    public static int PP_DEFAULT_NODE_TYPE_INDEX;
    public static TokenNodeType PP_DEFAULT;
    public static int PP_MESSAGE_NODE_TYPE_INDEX;
    public static TokenNodeType PP_MESSAGE;
    public static int PP_HIDDEN_NODE_TYPE_INDEX;
    public static TokenNodeType PP_HIDDEN;
    public static int PP_CONDITIONAL_SYMBOL_NODE_TYPE_INDEX;
    public static TokenNodeType PP_CONDITIONAL_SYMBOL;
    public static int PP_BAD_DIRECTIVE_NODE_TYPE_INDEX;
    public static TokenNodeType PP_BAD_DIRECTIVE;
    public static int EOF_NODE_TYPE_INDEX;
    public static TokenNodeType EOF;
    public static NodeTypeSet KEYWORDS;
    public static NodeTypeSet QUERY_KEYWORDS;
    public static NodeTypeSet TYPE_KEYWORDS;
    public static NodeTypeSet CONTEXTUAL_KEYWORDS;
    public static NodeTypeSet LITERALS;
    public static NodeTypeSet STRING_INTERPOLATION;
    public static NodeTypeSet CONSTANT_LITERALS;
    public static NodeTypeSet PREPROCESSOR;
    public static TokenNodeType ABSTRACT_KEYWORD;
    public static int ABSTRACT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType AS_KEYWORD;
    public static int AS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BASE_KEYWORD;
    public static int BASE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BOOL_KEYWORD;
    public static int BOOL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BREAK_KEYWORD;
    public static int BREAK_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BYTE_KEYWORD;
    public static int BYTE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CASE_KEYWORD;
    public static int CASE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CATCH_KEYWORD;
    public static int CATCH_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CHAR_KEYWORD;
    public static int CHAR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CHECKED_KEYWORD;
    public static int CHECKED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CLASS_KEYWORD;
    public static int CLASS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CONST_KEYWORD;
    public static int CONST_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CONTINUE_KEYWORD;
    public static int CONTINUE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DECIMAL_KEYWORD;
    public static int DECIMAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DEFAULT_KEYWORD;
    public static int DEFAULT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DELEGATE_KEYWORD;
    public static int DELEGATE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DO_KEYWORD;
    public static int DO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DOUBLE_KEYWORD;
    public static int DOUBLE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ELSE_KEYWORD;
    public static int ELSE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ENUM_KEYWORD;
    public static int ENUM_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType EVENT_KEYWORD;
    public static int EVENT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType EXPLICIT_KEYWORD;
    public static int EXPLICIT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType EXTERN_KEYWORD;
    public static int EXTERN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FALSE_KEYWORD;
    public static int FALSE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FINALLY_KEYWORD;
    public static int FINALLY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FIXED_KEYWORD;
    public static int FIXED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FLOAT_KEYWORD;
    public static int FLOAT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FOR_KEYWORD;
    public static int FOR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FOREACH_KEYWORD;
    public static int FOREACH_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GOTO_KEYWORD;
    public static int GOTO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IF_KEYWORD;
    public static int IF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IMPLICIT_KEYWORD;
    public static int IMPLICIT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IN_KEYWORD;
    public static int IN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType INT_KEYWORD;
    public static int INT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType INTERFACE_KEYWORD;
    public static int INTERFACE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType INTERNAL_KEYWORD;
    public static int INTERNAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IS_KEYWORD;
    public static int IS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LOCK_KEYWORD;
    public static int LOCK_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LONG_KEYWORD;
    public static int LONG_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NAMESPACE_KEYWORD;
    public static int NAMESPACE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NEW_KEYWORD;
    public static int NEW_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NULL_KEYWORD;
    public static int NULL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OBJECT_KEYWORD;
    public static int OBJECT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OPERATOR_KEYWORD;
    public static int OPERATOR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OUT_KEYWORD;
    public static int OUT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OVERRIDE_KEYWORD;
    public static int OVERRIDE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PARAMS_KEYWORD;
    public static int PARAMS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PRIVATE_KEYWORD;
    public static int PRIVATE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PROTECTED_KEYWORD;
    public static int PROTECTED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PUBLIC_KEYWORD;
    public static int PUBLIC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType READONLY_KEYWORD;
    public static int READONLY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType REF_KEYWORD;
    public static int REF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType RETURN_KEYWORD;
    public static int RETURN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SBYTE_KEYWORD;
    public static int SBYTE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SEALED_KEYWORD;
    public static int SEALED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SHORT_KEYWORD;
    public static int SHORT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SIZEOF_KEYWORD;
    public static int SIZEOF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STACKALLOC_KEYWORD;
    public static int STACKALLOC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STATIC_KEYWORD;
    public static int STATIC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STRING_KEYWORD;
    public static int STRING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STRUCT_KEYWORD;
    public static int STRUCT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SWITCH_KEYWORD;
    public static int SWITCH_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType THIS_KEYWORD;
    public static int THIS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType THROW_KEYWORD;
    public static int THROW_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TRUE_KEYWORD;
    public static int TRUE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TRY_KEYWORD;
    public static int TRY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TYPEOF_KEYWORD;
    public static int TYPEOF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType UINT_KEYWORD;
    public static int UINT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ULONG_KEYWORD;
    public static int ULONG_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType UNCHECKED_KEYWORD;
    public static int UNCHECKED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType UNSAFE_KEYWORD;
    public static int UNSAFE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType USHORT_KEYWORD;
    public static int USHORT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType USING_KEYWORD;
    public static int USING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType VIRTUAL_KEYWORD;
    public static int VIRTUAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType VOID_KEYWORD;
    public static int VOID_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType VOLATILE_KEYWORD;
    public static int VOLATILE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WHILE_KEYWORD;
    public static int WHILE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ARGLIST_KEYWORD;
    public static int ARGLIST_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType MAKEREF_KEYWORD;
    public static int MAKEREF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType REFTYPE_KEYWORD;
    public static int REFTYPE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType REFVALUE_KEYWORD;
    public static int REFVALUE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType AWAIT_KEYWORD;
    public static int AWAIT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ASYNC_KEYWORD;
    public static int ASYNC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType YIELD_KEYWORD;
    public static int YIELD_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WHERE_KEYWORD;
    public static int WHERE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PARTIAL_KEYWORD;
    public static int PARTIAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ALIAS_KEYWORD;
    public static int ALIAS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType VAR_KEYWORD;
    public static int VAR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DYNAMIC_KEYWORD;
    public static int DYNAMIC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WHEN_KEYWORD;
    public static int WHEN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType RECORD_KEYWORD;
    public static int RECORD_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WITH_KEYWORD;
    public static int WITH_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType AND_KEYWORD;
    public static int AND_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OR_KEYWORD;
    public static int OR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NOT_KEYWORD;
    public static int NOT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GLOBAL_KEYWORD;
    public static int GLOBAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType REQUIRED_KEYWORD;
    public static int REQUIRED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SCOPED_KEYWORD;
    public static int SCOPED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FILE_KEYWORD;
    public static int FILE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ALLOWS_KEYWORD;
    public static int ALLOWS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FROM_KEYWORD;
    public static int FROM_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType JOIN_KEYWORD;
    public static int JOIN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ON_KEYWORD;
    public static int ON_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType EQUALS_KEYWORD;
    public static int EQUALS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType INTO_KEYWORD;
    public static int INTO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LET_KEYWORD;
    public static int LET_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ORDERBY_KEYWORD;
    public static int ORDERBY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ASCENDING_KEYWORD;
    public static int ASCENDING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DESCENDING_KEYWORD;
    public static int DESCENDING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SELECT_KEYWORD;
    public static int SELECT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GROUP_KEYWORD;
    public static int GROUP_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BY_KEYWORD;
    public static int BY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LPARENTH;
    public static int LPARENTH_NODE_TYPE_INDEX;
    public static TokenNodeType RPARENTH;
    public static int RPARENTH_NODE_TYPE_INDEX;
    public static TokenNodeType LBRACE;
    public static int LBRACE_NODE_TYPE_INDEX;
    public static TokenNodeType RBRACE;
    public static int RBRACE_NODE_TYPE_INDEX;
    public static TokenNodeType LBRACKET;
    public static int LBRACKET_NODE_TYPE_INDEX;
    public static TokenNodeType RBRACKET;
    public static int RBRACKET_NODE_TYPE_INDEX;
    public static TokenNodeType SEMICOLON;
    public static int SEMICOLON_NODE_TYPE_INDEX;
    public static TokenNodeType COMMA;
    public static int COMMA_NODE_TYPE_INDEX;
    public static TokenNodeType DOT;
    public static int DOT_NODE_TYPE_INDEX;
    public static TokenNodeType EQ;
    public static int EQ_NODE_TYPE_INDEX;
    public static TokenNodeType GT;
    public static int GT_NODE_TYPE_INDEX;
    public static TokenNodeType GTGTEQ;
    public static int GTGTEQ_NODE_TYPE_INDEX;
    public static TokenNodeType GTGT;
    public static int GTGT_NODE_TYPE_INDEX;
    public static TokenNodeType GTGTGTEQ;
    public static int GTGTGTEQ_NODE_TYPE_INDEX;
    public static TokenNodeType GTGTGT;
    public static int GTGTGT_NODE_TYPE_INDEX;
    public static TokenNodeType LT;
    public static int LT_NODE_TYPE_INDEX;
    public static TokenNodeType EXCL;
    public static int EXCL_NODE_TYPE_INDEX;
    public static TokenNodeType TILDE;
    public static int TILDE_NODE_TYPE_INDEX;
    public static TokenNodeType QUEST;
    public static int QUEST_NODE_TYPE_INDEX;
    public static TokenNodeType COLON;
    public static int COLON_NODE_TYPE_INDEX;
    public static TokenNodeType PLUS;
    public static int PLUS_NODE_TYPE_INDEX;
    public static TokenNodeType MINUS;
    public static int MINUS_NODE_TYPE_INDEX;
    public static TokenNodeType ASTERISK;
    public static int ASTERISK_NODE_TYPE_INDEX;
    public static TokenNodeType DIV;
    public static int DIV_NODE_TYPE_INDEX;
    public static TokenNodeType AND;
    public static int AND_NODE_TYPE_INDEX;
    public static TokenNodeType OR;
    public static int OR_NODE_TYPE_INDEX;
    public static TokenNodeType XOR;
    public static int XOR_NODE_TYPE_INDEX;
    public static TokenNodeType PERC;
    public static int PERC_NODE_TYPE_INDEX;
    public static TokenNodeType EQEQ;
    public static int EQEQ_NODE_TYPE_INDEX;
    public static TokenNodeType LE;
    public static int LE_NODE_TYPE_INDEX;
    public static TokenNodeType GE;
    public static int GE_NODE_TYPE_INDEX;
    public static TokenNodeType NE;
    public static int NE_NODE_TYPE_INDEX;
    public static TokenNodeType ANDAND;
    public static int ANDAND_NODE_TYPE_INDEX;
    public static TokenNodeType OROR;
    public static int OROR_NODE_TYPE_INDEX;
    public static TokenNodeType PLUSPLUS;
    public static int PLUSPLUS_NODE_TYPE_INDEX;
    public static TokenNodeType MINUSMINUS;
    public static int MINUSMINUS_NODE_TYPE_INDEX;
    public static TokenNodeType LTLT;
    public static int LTLT_NODE_TYPE_INDEX;
    public static TokenNodeType PLUSEQ;
    public static int PLUSEQ_NODE_TYPE_INDEX;
    public static TokenNodeType MINUSEQ;
    public static int MINUSEQ_NODE_TYPE_INDEX;
    public static TokenNodeType ASTERISKEQ;
    public static int ASTERISKEQ_NODE_TYPE_INDEX;
    public static TokenNodeType DIVEQ;
    public static int DIVEQ_NODE_TYPE_INDEX;
    public static TokenNodeType ANDEQ;
    public static int ANDEQ_NODE_TYPE_INDEX;
    public static TokenNodeType OREQ;
    public static int OREQ_NODE_TYPE_INDEX;
    public static TokenNodeType XOREQ;
    public static int XOREQ_NODE_TYPE_INDEX;
    public static TokenNodeType PERCEQ;
    public static int PERCEQ_NODE_TYPE_INDEX;
    public static TokenNodeType LTLTEQ;
    public static int LTLTEQ_NODE_TYPE_INDEX;
    public static TokenNodeType ARROW;
    public static int ARROW_NODE_TYPE_INDEX;
    public static TokenNodeType LAMBDA_ARROW;
    public static int LAMBDA_ARROW_NODE_TYPE_INDEX;
    public static TokenNodeType DOUBLE_COLON;
    public static int DOUBLE_COLON_NODE_TYPE_INDEX;
    public static TokenNodeType DOUBLE_QUEST;
    public static int DOUBLE_QUEST_NODE_TYPE_INDEX;
    public static TokenNodeType DOTDOT;
    public static int DOTDOT_NODE_TYPE_INDEX;
    public static TokenNodeType DOUBLE_QUEST_EQ;
    public static int DOUBLE_QUEST_EQ_NODE_TYPE_INDEX;
    public static TokenNodeType PP_SHARP;
    public static int PP_SHARP_NODE_TYPE_INDEX;
    public static TokenNodeType PP_DEFINE_DECLARATION;
    public static int PP_DEFINE_DECLARATION_NODE_TYPE_INDEX;
    public static TokenNodeType PP_UNDEF_DECLARATION;
    public static int PP_UNDEF_DECLARATION_NODE_TYPE_INDEX;
    public static TokenNodeType PP_IF_SECTION;
    public static int PP_IF_SECTION_NODE_TYPE_INDEX;
    public static TokenNodeType PP_ELIF_SECTION;
    public static int PP_ELIF_SECTION_NODE_TYPE_INDEX;
    public static TokenNodeType PP_ELSE_SECTION;
    public static int PP_ELSE_SECTION_NODE_TYPE_INDEX;
    public static TokenNodeType PP_ENDIF;
    public static int PP_ENDIF_NODE_TYPE_INDEX;
    public static TokenNodeType PP_ERROR_DIAGNOSTIC;
    public static int PP_ERROR_DIAGNOSTIC_NODE_TYPE_INDEX;
    public static TokenNodeType PP_WARNING_DIAGNOSTIC;
    public static int PP_WARNING_DIAGNOSTIC_NODE_TYPE_INDEX;
    public static TokenNodeType PP_START_REGION;
    public static int PP_START_REGION_NODE_TYPE_INDEX;
    public static TokenNodeType PP_END_REGION;
    public static int PP_END_REGION_NODE_TYPE_INDEX;
    public static TokenNodeType PP_LINE;
    public static int PP_LINE_NODE_TYPE_INDEX;
    public static TokenNodeType PP_COMMA;
    public static int PP_COMMA_NODE_TYPE_INDEX;
    public static TokenNodeType PP_PRAGMA;
    public static int PP_PRAGMA_NODE_TYPE_INDEX;
    public static TokenNodeType PP_OR;
    public static int PP_OR_NODE_TYPE_INDEX;
    public static TokenNodeType PP_AND;
    public static int PP_AND_NODE_TYPE_INDEX;
    public static TokenNodeType PP_EQU;
    public static int PP_EQU_NODE_TYPE_INDEX;
    public static TokenNodeType PP_NEQ;
    public static int PP_NEQ_NODE_TYPE_INDEX;
    public static TokenNodeType PP_NOT;
    public static int PP_NOT_NODE_TYPE_INDEX;
    public static TokenNodeType PP_LPAR;
    public static int PP_LPAR_NODE_TYPE_INDEX;
    public static TokenNodeType PP_RPAR;
    public static int PP_RPAR_NODE_TYPE_INDEX;
    public static TokenNodeType PP_NULLABLE;
    public static int PP_NULLABLE_NODE_TYPE_INDEX;
    public static TokenNodeType PP_NULLABLE_DISABLE;
    public static int PP_NULLABLE_DISABLE_NODE_TYPE_INDEX;
    public static TokenNodeType PP_NULLABLE_ENABLE;
    public static int PP_NULLABLE_ENABLE_NODE_TYPE_INDEX;
    public static TokenNodeType PP_NULLABLE_RESTORE;
    public static int PP_NULLABLE_RESTORE_NODE_TYPE_INDEX;
    public static TokenNodeType PP_NULLABLE_ANNOTATIONS;
    public static int PP_NULLABLE_ANNOTATIONS_NODE_TYPE_INDEX;
    public static TokenNodeType PP_NULLABLE_WARNINGS;
    public static int PP_NULLABLE_WARNINGS_NODE_TYPE_INDEX;
    private static int LAST_GENERATED_TOKEN_TYPE_INDEX;
    private static CSharpTokenType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Parsing.ICSharpParser {
    public abstract virtual IFile ParseFile();
    public abstract virtual IBlock ParseCodeBlock();
    public abstract virtual ICSharpExpression ParseExpression();
    public abstract virtual ITreeNode ParseMemberDeclaration();
    public abstract virtual ICSharpStatement ParseStatement();
    public abstract virtual void SetChameleonExpansionMode(bool expandImmediately);
    [ObsoleteAttribute("Will be removed, use SetupParsingFromExistingTree")]
public abstract virtual void SetupParsingContext(CSharpParsingContext parsingContext);
    public abstract virtual void SetupParsingFromExistingTree(ITreeNode treeContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Parsing.ICSharpTokenNodeType {
    public bool IsContextualKeyword { get; }
    public abstract virtual bool get_IsContextualKeyword();
}
public enum JetBrains.ReSharper.Psi.CSharp.Parsing.InterpolatedStringStackItem : Enum {
    public int value__;
    public static InterpolatedStringStackItem Brace;
    public static InterpolatedStringStackItem Bracket;
    public static InterpolatedStringStackItem Parenth;
    public static InterpolatedStringStackItem RegularInterpolatedString;
    public static InterpolatedStringStackItem VerbatimInterpolatedString;
    public static InterpolatedStringStackItem RawInterpolatedString;
}
public enum JetBrains.ReSharper.Psi.CSharp.Parsing.NullableContextChangeTarget : Enum {
    public byte value__;
    public static NullableContextChangeTarget None;
    public static NullableContextChangeTarget Annotations;
    public static NullableContextChangeTarget Warnings;
    public static NullableContextChangeTarget AnnotationsAndWarnings;
}
public class JetBrains.ReSharper.Psi.CSharp.Parsing.NullableContextState : ValueType {
    public static NullableContext InvalidNullableContext;
    public NullableContext AnnotationsContext;
    public NullableContext WarningsContext;
    public NullableContext NewContext;
    public NullableContextChangeTarget NewContextTarget;
    public bool IsDefault { get; }
    public bool IsValid { get; }
    public bool get_IsDefault();
    public bool get_IsValid();
}
public static class JetBrains.ReSharper.Psi.CSharp.Parsing.ParserMessages : object {
    public static string IDS_PARAMETER_MODIFIER;
    public static string IDS_CLOSURE_PARAMETER_MODIFIER;
    public static string IDS_EXPECTED_SYMBOL { get; }
    public static string IDS_EXPECTED_TWO_SYMBOLS { get; }
    public static string IDS_UNEXPECTED_TOKEN { get; }
    public static string IDS_DECLARATION_OR_EXPRESSION_OR_LABEL_STATEMENT { get; }
    public static string IDS_EMBEDDED_STATEMENT_NO_IDENTIFIER { get; }
    public static string IDS_DECLARATION_STATEMENT { get; }
    public static string IDS_STATEMENT_AUX { get; }
    public static string IDS_JUMP_STATEMENT_AUX { get; }
    public static string IDS_SELECTION_STATEMENT_AUX { get; }
    public static string IDS_ITERATION_STATEMENT_AUX { get; }
    public static string IDS_GOTO_CASE_STATEMENT { get; }
    public static string IDS_GOTO_STATEMENT { get; }
    public static string IDS_PRIMARY_EXPRESSION { get; }
    public static string IDS_C_SHARP_EXPRESSION { get; }
    public static string IDS_C_SHARP_LITERAL_EXPRESSION { get; }
    public static string IDS_CREATION_EXPRESSION { get; }
    public static string IDS_ARRAY_CREATION_AUX { get; }
    public static string IDS_ASSIGNMENT_OPERATOR_AUX { get; }
    public static string IDS_TUPLE_EXPRESSION { get; }
    public static string IDS_DECLARATION_EXPRESSION { get; }
    public static string IDS_PATTERN { get; }
    public static string IDS_USING_DIRECTIVE { get; }
    public static string IDS_CLASS_MEMBER_DECLARATION_AUX { get; }
    public static string IDS_THE_M_P_I_DECLARATION_AUX { get; }
    public static string IDS_THE_M_P_DECLARATION_AUX { get; }
    public static string IDS_STRUCT_MEMBER_DECLARATION { get; }
    public static string IDS_CLASS_MEMBER_DECLARATION_AUX1 { get; }
    public static string IDS_THE_F_M_P_I_OOR_IDENTIFIER_DECLARATION_AUX { get; }
    public static string IDS_C_SHARP_TYPE_DECLARATION { get; }
    public static string IDS_TYPE_DECLARATION_AUX { get; }
    public static string IDS_MEMBER_OWNER_DECLARATION { get; }
    public static string IDS_CLASS_LIKE_DECLARATION { get; }
    public static string IDS_CLASS_BODY { get; }
    public static string IDS_ENUM_BODY { get; }
    public static string IDS__IDENTIFIER { get; }
    public static string IDS_PREDEFINED_TYPE_REFERENCE { get; }
    public static string IDS_TYPE_USAGE { get; }
    public static string IDS_USER_TYPE_USAGE { get; }
    public static string IDS_RANK_SPECIFIER { get; }
    public static string IDS_NUMERIC_TYPE { get; }
    public static string IDS_INTEGRAL_TYPE { get; }
    public static string IDS_FLOATING_POINT_TYPE { get; }
    public static string IDS_SIGN_OPERATOR_SIGN { get; }
    public static string IDS_FUNCTION_BODY { get; }
    public static string IDS_ARROW_EXPRESSION_CLAUSE { get; }
    public static string IDS_BLOCK { get; }
    public static string IDS_C_SHARP_ARGUMENT { get; }
    public static string IDS_CREATION_EXPRESSION_INITIALIZER { get; }
    public static string IDS_INITIALIZER_ELEMENT { get; }
    public static string IDS_MEMBER_INITIALIZER { get; }
    public static string IDS_INITIALIZED_MEMBER_INITIALIZER { get; }
    public static string IDS_EXPRESSION_OR_INITIALIZER_PART { get; }
    public static string IDS_RESOURCE_ACQUISITION { get; }
    public static string IDS_VARIABLE_INITIALIZER { get; }
    public static string IDS_LAMBDA_SIGNATURE { get; }
    public static string IDS_ATTRIBUTE_PROPERTY_ASSIGNMENT { get; }
    public static string IDS_REGULAR_PARAMETER_MODIFIERS { get; }
    public static string IDS_QUERY_GROUP_CLAUSE { get; }
    public static string IDS_QUERY_SELECT_CLAUSE { get; }
    public static string IDS_ATTRIBUTE_SECTION { get; }
    public static string IDS_TYPE_MEMBER_MODIFIER { get; }
    public static string IDS_VARIABLE_DESIGNATION { get; }
    public static string IDS_TYPE_MEMBER_REGULAR_PARAMETER_DECLARATION { get; }
    public static string IDS_TYPE_MEMBER_ARGLIST_PARAMETER_DECLARATION { get; }
    public static string IDS_SWITCH_CASE_LABEL { get; }
    public static string IDS_SWITCH_GOVERNING_EXPRESSION { get; }
    public static string IDS_FUNCTION_POINTER_PARAMETER_MODIFIER { get; }
    public static string IDS_FOREACH_VARIABLE_DECLARATION { get; }
    public static string IDS_COLLECTION_EXPRESSION_ELEMENT { get; }
    public static string IDS_MODIFIERS_LIST { get; }
    public static string IDS_FOR_INITIALIZER { get; }
    public static string IDS_TYPE_PARAMETER_CONSTRAINT { get; }
    public static string IDS_LOCAL_REGULAR_PARAMETER_DECLARATION { get; }
    public static string IDS_LOCAL_ARGLIST_PARAMETER_DECLARATION { get; }
    public static string IDS_IMPLICIT_LAMBDA_PARAMETER_DECLARATION { get; }
    public static string IDS_INTERPOLATED_STRING_EXPRESSION { get; }
    public static string IDS_LINE_INDICATOR { get; }
    public static string IDS_PREPROCESSOR_CONSTANT { get; }
    public static string IDS_PREPROCESSOR_EXPRESSION { get; }
    public static string IDS_PREPROCESSOR_UNARY_EXPRESSION { get; }
    public static string IDS_PREPROCESSOR_DIRECTIVE { get; }
    public static string IDS_PREPROCESSOR_SYMBOL_NAME { get; }
    public static string IDS__DOC_C_REF_IDENTIFIER_OR_KEYWORD { get; }
    public static string IDS_DOC_C_REF_ELEMENT_AUX { get; }
    public static string IDS_DOC_C_REF_GENERICS_L_ANGLE { get; }
    public static string IDS_DOC_C_REF_GENERICS_R_ANGLE { get; }
    public static string IDS_UNSAFE_CODE_POINTER { get; }
    public static string IDS_CONSTRUCTOR_DECLARATION { get; }
    public static string IDS_SCALAR_TYPE_USAGE { get; }
    public static string get_IDS_EXPECTED_SYMBOL();
    public static string get_IDS_EXPECTED_TWO_SYMBOLS();
    public static string get_IDS_UNEXPECTED_TOKEN();
    public static string get_IDS_DECLARATION_OR_EXPRESSION_OR_LABEL_STATEMENT();
    public static string get_IDS_EMBEDDED_STATEMENT_NO_IDENTIFIER();
    public static string get_IDS_DECLARATION_STATEMENT();
    public static string get_IDS_STATEMENT_AUX();
    public static string get_IDS_JUMP_STATEMENT_AUX();
    public static string get_IDS_SELECTION_STATEMENT_AUX();
    public static string get_IDS_ITERATION_STATEMENT_AUX();
    public static string get_IDS_GOTO_CASE_STATEMENT();
    public static string get_IDS_GOTO_STATEMENT();
    public static string get_IDS_PRIMARY_EXPRESSION();
    public static string get_IDS_C_SHARP_EXPRESSION();
    public static string get_IDS_C_SHARP_LITERAL_EXPRESSION();
    public static string get_IDS_CREATION_EXPRESSION();
    public static string get_IDS_ARRAY_CREATION_AUX();
    public static string get_IDS_ASSIGNMENT_OPERATOR_AUX();
    public static string get_IDS_TUPLE_EXPRESSION();
    public static string get_IDS_DECLARATION_EXPRESSION();
    public static string get_IDS_PATTERN();
    public static string get_IDS_USING_DIRECTIVE();
    public static string get_IDS_CLASS_MEMBER_DECLARATION_AUX();
    public static string get_IDS_THE_M_P_I_DECLARATION_AUX();
    public static string get_IDS_THE_M_P_DECLARATION_AUX();
    public static string get_IDS_STRUCT_MEMBER_DECLARATION();
    public static string get_IDS_CLASS_MEMBER_DECLARATION_AUX1();
    public static string get_IDS_THE_F_M_P_I_OOR_IDENTIFIER_DECLARATION_AUX();
    public static string get_IDS_C_SHARP_TYPE_DECLARATION();
    public static string get_IDS_TYPE_DECLARATION_AUX();
    public static string get_IDS_MEMBER_OWNER_DECLARATION();
    public static string get_IDS_CLASS_LIKE_DECLARATION();
    public static string get_IDS_CLASS_BODY();
    public static string get_IDS_ENUM_BODY();
    public static string get_IDS__IDENTIFIER();
    public static string get_IDS_PREDEFINED_TYPE_REFERENCE();
    public static string get_IDS_TYPE_USAGE();
    public static string get_IDS_USER_TYPE_USAGE();
    public static string get_IDS_RANK_SPECIFIER();
    public static string get_IDS_NUMERIC_TYPE();
    public static string get_IDS_INTEGRAL_TYPE();
    public static string get_IDS_FLOATING_POINT_TYPE();
    public static string get_IDS_SIGN_OPERATOR_SIGN();
    public static string get_IDS_FUNCTION_BODY();
    public static string get_IDS_ARROW_EXPRESSION_CLAUSE();
    public static string get_IDS_BLOCK();
    public static string get_IDS_C_SHARP_ARGUMENT();
    public static string get_IDS_CREATION_EXPRESSION_INITIALIZER();
    public static string get_IDS_INITIALIZER_ELEMENT();
    public static string get_IDS_MEMBER_INITIALIZER();
    public static string get_IDS_INITIALIZED_MEMBER_INITIALIZER();
    public static string get_IDS_EXPRESSION_OR_INITIALIZER_PART();
    public static string get_IDS_RESOURCE_ACQUISITION();
    public static string get_IDS_VARIABLE_INITIALIZER();
    public static string get_IDS_LAMBDA_SIGNATURE();
    public static string get_IDS_ATTRIBUTE_PROPERTY_ASSIGNMENT();
    public static string get_IDS_REGULAR_PARAMETER_MODIFIERS();
    public static string get_IDS_QUERY_GROUP_CLAUSE();
    public static string get_IDS_QUERY_SELECT_CLAUSE();
    public static string get_IDS_ATTRIBUTE_SECTION();
    public static string get_IDS_TYPE_MEMBER_MODIFIER();
    public static string get_IDS_VARIABLE_DESIGNATION();
    public static string get_IDS_TYPE_MEMBER_REGULAR_PARAMETER_DECLARATION();
    public static string get_IDS_TYPE_MEMBER_ARGLIST_PARAMETER_DECLARATION();
    public static string get_IDS_SWITCH_CASE_LABEL();
    public static string get_IDS_SWITCH_GOVERNING_EXPRESSION();
    public static string get_IDS_FUNCTION_POINTER_PARAMETER_MODIFIER();
    public static string get_IDS_FOREACH_VARIABLE_DECLARATION();
    public static string get_IDS_COLLECTION_EXPRESSION_ELEMENT();
    public static string get_IDS_MODIFIERS_LIST();
    public static string get_IDS_FOR_INITIALIZER();
    public static string get_IDS_TYPE_PARAMETER_CONSTRAINT();
    public static string get_IDS_LOCAL_REGULAR_PARAMETER_DECLARATION();
    public static string get_IDS_LOCAL_ARGLIST_PARAMETER_DECLARATION();
    public static string get_IDS_IMPLICIT_LAMBDA_PARAMETER_DECLARATION();
    public static string get_IDS_INTERPOLATED_STRING_EXPRESSION();
    public static string get_IDS_LINE_INDICATOR();
    public static string get_IDS_PREPROCESSOR_CONSTANT();
    public static string get_IDS_PREPROCESSOR_EXPRESSION();
    public static string get_IDS_PREPROCESSOR_UNARY_EXPRESSION();
    public static string get_IDS_PREPROCESSOR_DIRECTIVE();
    public static string get_IDS_PREPROCESSOR_SYMBOL_NAME();
    public static string get_IDS__DOC_C_REF_IDENTIFIER_OR_KEYWORD();
    public static string get_IDS_DOC_C_REF_ELEMENT_AUX();
    public static string get_IDS_DOC_C_REF_GENERICS_L_ANGLE();
    public static string get_IDS_DOC_C_REF_GENERICS_R_ANGLE();
    public static string get_IDS_UNSAFE_CODE_POINTER();
    public static string get_IDS_CONSTRUCTOR_DECLARATION();
    public static string get_IDS_SCALAR_TYPE_USAGE();
    public static string GetString(string id);
    [NotNullAttribute]
public static string GetUnexpectedTokenMessage();
    [NotNullAttribute]
public static string GetExpectedMessage(string expectedSymbol);
    [NotNullAttribute]
public static string GetExpectedMessage(string firstExpectedSymbol, string secondExpectedSymbol);
}
internal static class JetBrains.ReSharper.Psi.CSharp.Parsing.ParserNodeTypeSets : object {
    [NotNullAttribute]
public static NodeTypeSet LITERAL_EXPRESSION_START;
    [NotNullAttribute]
public static NodeTypeSet PREDEFINED_TYPE_EXPRESSION_START;
    [NotNullAttribute]
public static NodeTypeSet FIELD_DECLARATION_DECISION_CHAR;
    [NotNullAttribute]
public static NodeTypeSet TYPE_USAGE_START;
    [NotNullAttribute]
public static NodeTypeSet CANNOT_FOLLOW_CAST;
    [NotNullAttribute]
public static NodeTypeSet EXPRESSION_HEURISITCS;
    [ObsoleteAttribute("This do not includes [ from attributtes on lambda expressions and should be eventually phased out, replaced by IsPossibleExpression")]
[NotNullAttribute]
public static NodeTypeSet EXPRESSION_FIRST;
    [NotNullAttribute]
public static NodeTypeSet EXPRESSION_FOLLOWS;
    [NotNullAttribute]
public static NodeTypeSet POSSIBLE_EXPRESSION;
    [NotNullAttribute]
public static NodeTypeSet POSSIBLE_EXPRESSION_ANY_UNARY;
    public static NodeTypeSet ASSIGNMENT_TOKEN;
    [NotNullAttribute]
public static NodeTypeSet BINARY_EXPRESSION;
    [NotNullAttribute]
public static NodeTypeSet BINARY_SHIFT_EXPRESSION;
    [NotNullAttribute]
public static NodeTypeSet DECISION_CHAR_FOR_TYPE_ARGUMENT_LIST;
    [NotNullAttribute]
public static NodeTypeSet ARGUMENT_HEURISTICS;
    [NotNullAttribute]
public static NodeTypeSet PREDEFINED_TYPE_KEYWORDS;
    [NotNullAttribute]
public static NodeTypeSet DECISION_CHAR_FOR_PARTIAL;
    [NotNullAttribute]
public static NodeTypeSet INTERPOLATED_STRING_EXPRESSION_START;
    [NotNullAttribute]
public static Dictionary`2<string, TokenNodeType> QueryKeywords;
    [NotNullAttribute]
public static NodeTypeSet LOCAL_METHOD_UNSUPPORTED_MODIFIERS;
    [NotNullAttribute]
public static NodeTypeSet LOCAL_METHOD_MODIFIER_KEYWORDS;
    [NotNullAttribute]
public static NodeTypeSet LOCAL_METHOD_LOOKAHEAD_TOKENS;
    [NotNullAttribute]
public static NodeTypeSet CHAMELEON_STOPPER_TOKENS;
    [NotNullAttribute]
public static NodeTypeSet TOP_LEVEL_MEMBER_START;
    [NotNullAttribute]
public static NodeTypeSet STATEMENT_FOLLOWS;
    [NotNullAttribute]
public static NodeTypeSet TOP_LEVEL_CODE_FOLLOWS;
    [NotNullAttribute]
public static NodeTypeSet DEFINITELY_TOP_LEVEL_CODE_START;
    [NotNullAttribute]
public static NodeTypeSet TOP_LEVEL_CODE_START;
    [NotNullAttribute]
public static NodeTypeSet POSSIBLE_TYPE_DECLARATION_START;
    [NotNullAttribute]
public static NodeTypeSet NAMESPACE_MEMBER_DECLARATION_FOLLOWS;
    [NotNullAttribute]
public static NodeTypeSet CLASS_MEMBER_START;
    [NotNullAttribute]
public static NodeTypeSet MODIFIER_LIST;
    [NotNullAttribute]
public static NodeTypeSet CLASS_MEMBER_END;
    [NotNullAttribute]
public static NodeTypeSet DOC_CREF_PARAMETER_TYPE_NAME;
    [NotNullAttribute]
public static NodeTypeSet PARAMETER_MODE_MODIFIERS;
    [NotNullAttribute]
public static NodeTypeSet PARAMETER_MODIFIERS;
    [NotNullAttribute]
public static NodeTypeSet FUNCTION_POINTER_PARAMETER_MODIFIERS;
    [NotNullAttribute]
public static NodeTypeSet TUPLE_FIRST_ARGUMENT_FOLLOWS;
    [NotNullAttribute]
public static NodeTypeSet TUPLE_NON_FIRST_ARGUMENT_FOLLOWS;
    private static ParserNodeTypeSets();
    [NotNullAttribute]
[PureAttribute]
public static UnexpectedToken NewUnexpectedToken(TreeElement result);
}
public class JetBrains.ReSharper.Psi.CSharp.Parsing.RawInterpolatedStringInfo : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsMultiLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DollarSignCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    public bool IsMultiLine { get; public set; }
    public int DollarSignCount { get; public set; }
    public int QuoteCount { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsMultiLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsMultiLine(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_DollarSignCount();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DollarSignCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_QuoteCount();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QuoteCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RawInterpolatedStringInfo left, RawInterpolatedStringInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RawInterpolatedStringInfo left, RawInterpolatedStringInfo right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RawInterpolatedStringInfo other);
}
public static class JetBrains.ReSharper.Psi.CSharp.Parsing.SyntheticComments : object {
    public static string SystemEndComment;
    public static char SystemCommentChar;
    public static string AspLeadingComment;
    public static string CodeCompletionIdentifierToken;
    [PureAttribute]
public static bool IsSyntheticNonStickyComment(ITreeNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.PositionalParameterImplementation : ValueType {
    [NullableAttribute("2")]
private ITypeMember myBaseOrExplicitMember;
    [CompilerGeneratedAttribute]
private IParameter <PositionalParameter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IProperty <GeneratedProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    public IParameter PositionalParameter { get; }
    [NullableAttribute("2")]
public IProperty GeneratedProperty { get; }
    [NullableAttribute("2")]
public ITypeMember ExplicitDeclarationMember { get; }
    [NullableAttribute("2")]
public IProperty OverridenBaseProperty { get; }
    public ISubstitution Substitution { get; }
    internal PositionalParameterImplementation(IParameter positionalParameter, IProperty generatedProperty);
    internal PositionalParameterImplementation(IParameter positionalParameter, ITypeMember explicitDeclarationMember, ISubstitution substitution);
    internal PositionalParameterImplementation(IParameter positionalParameter, IProperty generatedProperty, IProperty overridedBaseProperty, ISubstitution substitution);
    [CompilerGeneratedAttribute]
public IParameter get_PositionalParameter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IProperty get_GeneratedProperty();
    [NullableContextAttribute("2")]
public ITypeMember get_ExplicitDeclarationMember();
    [NullableContextAttribute("2")]
public IProperty get_OverridenBaseProperty();
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    [PureAttribute]
public bool HasCorrectExplicitImplementation(bool fieldsCanBePositional);
}
public class JetBrains.ReSharper.Psi.CSharp.Properties.AssemblyReferenceClass_PsiFeaturesPsiCsharp : AssemblyReferenceClass_ComponentModel {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.RecordExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool HasBaseRecordClass(IRecord record);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasBaseRecordClass(IRecord record, IDeclaredType& baseRecordType);
    [ExtensionAttribute]
[PureAttribute]
public static IParameter FindCorrespondingRecordPositionalParameterByImplicitProperty(IProperty property);
    [ExtensionAttribute]
[PureAttribute]
public static IParameter FindCorrespondingRecordPositionalParameterByExplicitProperty(IProperty property);
    [ExtensionAttribute]
[PureAttribute]
public static IParameter FindCorrespondingRecordPositionalParameterByExplicitField(IField field);
    [ExtensionAttribute]
[PureAttribute]
public static IProperty FindCorrespondingRecordImplicitProperty(IParameter parameter);
    [ExtensionAttribute]
[PureAttribute]
public static IMethod FindCorrespondingRecordImplicitDeconstruct(IPrimaryConstructor primaryConstructor);
    [ExtensionAttribute]
[PureAttribute]
public static ITypeMember FindCorrespondingRecordImplicitOrExplicitPositionalMember(IParameter parameter, bool sameTypeOnly, bool skipSameType, bool requireToBeValid, bool requirePrimaryConstructor);
    [ExtensionAttribute]
[PureAttribute]
public static IParameter FindDeconstructParameterByPositionalParameter(IParameter parameter, bool onlyImplicit);
    [ExtensionAttribute]
[PureAttribute]
public static IParameter FindPositionalParameterByDeconstructParameter(IParameter parameter);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordPositionalParameter(IParameter parameter);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordCloneMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitDeconstructMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitEqualityContractProperty(IProperty property);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitPrintMembersMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitToStringMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitGetHashCodeMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitTypedEqualsMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitSpecialMember(ITypeMember typeMember);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordCopyConstructor(IConstructor constructor);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitCopyConstructor(IConstructor constructor);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordSpecialMember(ITypeMember typeMember);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRecordImplicitPositionalProperty(ITypeMember typeMember);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanExplicitlyImplementPositionalRecordMember(ITypeMember typeMember);
    [ExtensionAttribute]
[PureAttribute]
public static IDeclaredType GetIEquatableOfRecordType(IRecord record);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsImplicitlyImplementedIEquatable(IRecord record, IType type);
    [CompilerGeneratedAttribute]
internal static bool <FindCorrespondingRecordImplicitOrExplicitPositionalMember>g__MemberMatchesParameter|7_0(ITypeMember typeMember, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static IParameter <FindDeconstructParameterByPositionalParameter>g__TryFindParameter|8_0(IMethod deconstructMethod, <>c__DisplayClass8_0& );
}
[FlagsAttribute]
internal enum JetBrains.ReSharper.Psi.CSharp.RefKindCompareMode : Enum {
    public int value__;
    public static RefKindCompareMode DoNotConsiderDifferences;
    public static RefKindCompareMode ConsiderDifferences;
    public static RefKindCompareMode AllowRefReadonlyVsInMismatch;
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.RefSafetyRulesVersionCacheInvalidator : object {
    public sealed virtual bool IsLanguageLevelBoundCrossed(Nullable`1<CSharpLanguageLevel> before, CSharpLanguageLevel after);
    public sealed virtual void OnLanguageLevelChanged(IPsiModule psiModule, Nullable`1<CSharpLanguageLevel> before, CSharpLanguageLevel after);
}
[SolutionFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.RefSafetyRulesVersionModuleProvider : object {
    public sealed virtual Nullable`1<RefSafetyRulesVersion> GetRefSafetyRulesVersionFromModule(IPsiModule module);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.CSharpImplicitBaseConstructorInvocationReference : ImplicitBaseConstructorInvocationReference {
    public CSharpImplicitBaseConstructorInvocationReference(IDeclaration ownerElement, IClass baseClass);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.CSharpResolveErrorType : ResolveErrorType {
    [NotNullAttribute]
public static CSharpResolveErrorType MULTIPLE_RESULTS_IN_STRING_LITERAL;
    [NotNullAttribute]
public static CSharpResolveErrorType VALUETUPLE_DECONSTRUCTION;
    [NotNullAttribute]
public static CSharpResolveErrorType ITUPLE_DECONSTRUCTION;
    [NotNullAttribute]
public static CSharpResolveErrorType DISCARD;
    [NotNullAttribute]
public static CSharpResolveErrorType INCORRECT_INVOCABLE_USE;
    [NotNullAttribute]
public static CSharpResolveErrorType OPERATOR_IS_NOT_APPLICABLE;
    [NotNullAttribute]
public static CSharpResolveErrorType TRUE_FALSE_OPERATOR_MISSED;
    [NotNullAttribute]
public static CSharpResolveErrorType CONDITIONAL_LOGIC_OPERATOR_TYPES_MISMATCH;
    [NotNullAttribute]
public static CSharpResolveErrorType IS_NOT_ALIAS;
    [NotNullAttribute]
public static CSharpResolveErrorType INCORRECT_SIGNATURE_IN_DOCCOMMENT;
    [NotNullAttribute]
public static CSharpResolveErrorType NOT_VARIABLE_IN_INITIALIZER;
    [NotNullAttribute]
public static CSharpResolveErrorType NOT_VARIABLE_IN_SUBPATTERN;
    [NotNullAttribute]
public static CSharpResolveErrorType PARAMETER_NOT_VALID_HERE;
    [NotNullAttribute]
public static CSharpResolveErrorType INCORRECT_METHOD_GROUP_RETURN_TYPE;
    [NotNullAttribute]
public static CSharpResolveErrorType INCORRECT_METHOD_GROUP_REFNESS;
    [NotNullAttribute]
public static CSharpResolveErrorType DELEGATE_TYPE_CANNOT_BE_INFERRED;
    [NotNullAttribute]
public static CSharpResolveErrorType USE_LOCAL_BEFORE_DECLARATION;
    [NotNullAttribute]
public static CSharpResolveErrorType INDEXED_PROPERTY_WITHOUT_ARGUMENTS;
    [NotNullAttribute]
public static CSharpResolveErrorType METHOD_GROUP_INVALID_CONTEXT;
    [NotNullAttribute]
public static CSharpResolveErrorType INCORRECT_AWAITABLE_PATTERN;
    [NotNullAttribute]
public static CSharpResolveErrorType EXTENSION_DYNAMIC_DISPATCH;
    [NotNullAttribute]
public static CSharpResolveErrorType CANT_USE_TYPE_ARGUMENTS;
    [NotNullAttribute]
public static CSharpResolveErrorType MISMATCHING_TUPLE_CARDINALITY;
    [NotNullAttribute]
public static CSharpResolveErrorType TUPLE_COMPONENT_EQUALITY_NOT_RESOLVED;
    [NotNullAttribute]
public static CSharpResolveErrorType WRONG_CALLING_CONVENTION;
    [NotNullAttribute]
public static CSharpResolveErrorType WRONG_INTERPOLATED_STRING_HANDLER_ARGUMENTS_ANNOTATION;
    private CSharpResolveErrorType(string name, bool isAcceptable);
    private static CSharpResolveErrorType();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Resolve.CSharpResolveInfoFactory : object {
    [NotNullAttribute]
[PureAttribute]
public static IResolveInfo Create(IReadOnlyList`1<IUsingDirective> usingDirectives, IResolveInfo resolveInfo);
    [NotNullAttribute]
[PureAttribute]
public static IResolveInfo Create(IUsingDirective usingDirective, IResolveInfo resolveInfo);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IResolveInfo WithInfo(ResolveErrorType errorType, IResolveInfo withIInfo);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Resolve.CSharpResolveResultExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsEventSubscription(IResolveResult resolveResult);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLateBound(IResolveResult resolveResult);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateSimpleResolveResult(IResolveResult resolveResult);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Resolve.DeconstructionReferenceExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IType GetDeconstructionSourceType(IDeconstructionReference reference, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsValueTupleDeconstruction(IDeconstructionReference reference);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsITupleDeconstruction(IDeconstructionReference reference);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ResolveResultWithInfo ResolveDeconstructParameter(IDeconstructionReference reference, int componentIndex, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<TupleTypeComponent> ResolveDeconstructTupleComponent(IDeconstructionReference deconstructionReference, int componentIndex);
    [PureAttribute]
[CanBeNullAttribute]
private static IParameter FindDeconstructParameter(IMethod deconstructMethod, int componentIndex);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IType GetDeconstructComponentType(IDeconstructionReference reference, int componentIndex, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IExpressionType GetDeconstructComponentExpressionType(IDeconstructionReference reference, int componentIndex, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<DecoratedType`1<TupleTypeDecoration>> GetDeconstructionAsTupleType(IDeconstructionReference reference, IResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.EventSubscriptionResolveResult : ResolveResultWithSubstitution {
    public EventSubscriptionResolveResult(IResolveResult resolveResult);
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpDocCommentReference {
    public ICommentNode CommentNode { get; public set; }
    public TreeOffset LocalOffset { get; public set; }
    public abstract virtual ICommentNode get_CommentNode();
    public abstract virtual void set_CommentNode(ICommentNode value);
    public abstract virtual TreeOffset get_LocalOffset();
    public abstract virtual void set_LocalOffset(TreeOffset value);
    public abstract virtual TreeTextRange GetSignatureRange();
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.ICSharpInvocationReference {
    [NotNullAttribute]
public ICSharpInvocationInfo Invocation { get; }
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ISymbolInfo> GetCandidates();
    public abstract virtual bool ShouldInferTypeArguments();
    public abstract virtual ICSharpInvocationInfo get_Invocation();
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.IDeconstructionReference {
    [PureAttribute]
[NotNullAttribute]
public abstract virtual IExpressionType GetDeconstructionSourceExpressionType(IResolveContext resolveContext);
    [PureAttribute]
public abstract virtual int GetDeconstructionComponentsCount();
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.IResolveInfoWithUsings {
    [NotNullAttribute]
public IReadOnlyList`1<IUsingDirective> UsingDirectives { get; }
    public abstract virtual IReadOnlyList`1<IUsingDirective> get_UsingDirectives();
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.IResolvePatcher {
    public abstract virtual IResolveResult PatchResolve(IReferenceName referenceName, IResolveInfo& errorType);
    public abstract virtual IType PatchLocalVariableType(ILocalVariable loaclVariable, IResolveContext resolveContext);
    public abstract virtual ISymbolTable PatchSymbolTable(IReferenceName referenceName);
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.AddReferenceCandidateFound : OverloadResolutionResultImpl`1<MatchedCandidate> {
    public bool IsFinalResult { get; }
    public ResolveErrorType ErrorType { get; }
    public AddReferenceCandidateFound(List`1<MatchedCandidate> candidates, ITypeParameterValuator typeParameterValues);
    public virtual bool get_IsFinalResult();
    public virtual ResolveErrorType get_ErrorType();
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ApplicableCandidate : object {
    [NotNullAttribute]
private CandidateWithResolveContext myCandidate;
    [CompilerGeneratedAttribute]
private bool <HasInconvertibleImplicitLambdas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInvalidArgumentConversions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTypeArgumentInferredFromFunctionType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFunctionTypeConversions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expanded>k__BackingField;
    public IResolveContext ResolveContext { get; }
    public ISymbolInfo OriginalSymbolInfo { get; }
    public bool HasInconvertibleImplicitLambdas { get; }
    public bool HasInvalidArgumentConversions { get; }
    public bool HasTypeArgumentInferredFromFunctionType { get; }
    public bool HasFunctionTypeConversions { get; }
    public DeclaredElementInstance`1<IParametersOwner> ParametersOwnerInstance { get; }
    public ISubstitution ParametersOwnerSubstitution { get; }
    public IParametersOwner ParametersOwner { get; }
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public IList`1<ArgumentMatch> MatchResult { get; }
    public bool IsDynamicDispatch { get; }
    public bool Expanded { get; }
    public ApplicableCandidate(CandidateWithResolveContext candidate, bool hasInconvertibleImplicitLambdas, bool hasInvalidArgumentConversions, bool hasTypeArgumentInferredFromFunctionType, bool hasFunctionTypeConversions);
    public IResolveContext get_ResolveContext();
    public sealed virtual ISymbolInfo get_OriginalSymbolInfo();
    [CompilerGeneratedAttribute]
public bool get_HasInconvertibleImplicitLambdas();
    [CompilerGeneratedAttribute]
public bool get_HasInvalidArgumentConversions();
    [CompilerGeneratedAttribute]
public bool get_HasTypeArgumentInferredFromFunctionType();
    [CompilerGeneratedAttribute]
public bool get_HasFunctionTypeConversions();
    public sealed virtual DeclaredElementInstance`1<IParametersOwner> get_ParametersOwnerInstance();
    public ISubstitution get_ParametersOwnerSubstitution();
    public IParametersOwner get_ParametersOwner();
    public IDeclaredElement get_DeclaredElement();
    public ISubstitution get_Substitution();
    public IList`1<ArgumentMatch> get_MatchResult();
    public bool get_IsDynamicDispatch();
    public IList`1<ArgumentMatchWithType> MatchResultWithTypes();
    [CompilerGeneratedAttribute]
public bool get_Expanded();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ApplicableCandidatesFound : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public bool IsFinalResult { get; }
    public ApplicableCandidatesFound(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool get_IsFinalResult();
}
internal abstract class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ApplicableCandidatesResultBase : OverloadResolutionResultImpl`1<ApplicableCandidate> {
    [CompilerGeneratedAttribute]
private IResolveContext <motherResolveContext>P;
    protected ApplicableCandidatesResultBase(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
    public virtual ResolveResultWithInfo CommitResolveResult();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ArgumentMatchWithType : ValueType {
    [CompilerGeneratedAttribute]
private ICSharpArgumentInfo <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionType <ArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchKind <Expanded>k__BackingField;
    [NotNullAttribute]
public ICSharpArgumentInfo Argument { get; }
    public IExpressionType ArgumentType { get; }
    [CanBeNullAttribute]
public IParameter Parameter { get; }
    [CanBeNullAttribute]
public IType ParameterType { get; }
    public MatchKind Expanded { get; }
    public ArgumentMatchWithType(ArgumentMatch match, IExpressionType argumentType, IType parameterType);
    public ArgumentMatchWithType(ArgumentMatch match, IExpressionType argumentType, IType parameterType, MatchKind kind);
    public ArgumentMatchWithType(ICSharpArgumentInfo argumentInfo, IParameter parameter, IExpressionType argumentType, IType parameterType, MatchKind kind);
    [CompilerGeneratedAttribute]
public ICSharpArgumentInfo get_Argument();
    [CompilerGeneratedAttribute]
public IExpressionType get_ArgumentType();
    [CompilerGeneratedAttribute]
public IParameter get_Parameter();
    [CompilerGeneratedAttribute]
public IType get_ParameterType();
    [CompilerGeneratedAttribute]
public MatchKind get_Expanded();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ArgumentsMismatch : OverloadResolutionResultImpl`1<Candidate> {
    public ResolveErrorType ErrorType { get; }
    public ArgumentsMismatch(IList`1<Candidate> candidates, ITypeParameterValuator typeParameterValues);
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.BackToArgumentMatcher : object {
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentIndex>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public int ArgumentIndex { get; }
    public BackToArgumentMatcher(IList`1<ICSharpArgumentInfo> arguments, int argumentIndex);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [CompilerGeneratedAttribute]
public int get_ArgumentIndex();
    [NotNullAttribute]
public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.BetterConversionResult : ValueType {
    public static BetterConversionResult Neither;
    public int Result;
    public bool Ignore;
    public BetterConversionResult(int result, bool ignore);
    private static BetterConversionResult();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.BetterConversionSelector : object {
    private CSharpLanguageLevel myLanguageLevel;
    private CSharpLanguageLevel myLatestSupportedLanguageLevel;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    [NotNullAttribute]
public IPsiModule Module { get; }
    [NotNullAttribute]
public IResolveContext ResolveContext { get; }
    internal BetterConversionSelector(IPsiModule module, IResolveContext resolveContext, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [CompilerGeneratedAttribute]
public IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public IResolveContext get_ResolveContext();
    public bool ExpressionExactlyMatches(IExpressionType expressionType, IType type);
    private bool ExpressionExactlyMatchesTuples(ITupleExpressionType tupleExpressionType, IType type);
    public BetterConversionResult IsBetterConversion(IType type1, IType type2, IExpressionType typeToConvert1, IExpressionType typeToConvert2, int reccounter, bool isOperatorPromotion);
    private bool IsBetterCollectionExpressionConversion(IType type1, Conversion conversion1, IType type2, Conversion conversion2, ICSharpTypeConversionRule typeConversionRule);
    private BetterConversionResult IsBetterConversionTarget(IType type1, IType type2, IExpressionType typeToConvert1, IExpressionType typeToConvert2, int reccounter, bool isOperatorPromotion);
    public BetterConversionResult IsBetterConversionBasic(IType type1, IType type2, IExpressionType typeToConvert1, IExpressionType typeToConvert2, bool isOperatorPromotion);
    private static BetterConversionResult CheckMethodGroupCorrectness(BetterConversionResult result, DeclaredElementInstance`1<IDelegate> delegate1, DeclaredElementInstance`1<IDelegate> delegate2, IExpressionType expressionType1, IExpressionType expressionType2);
    protected bool IsIgnorable(IType type1, IType type2, IExpressionType typeToConvert1, IExpressionType typeToConvert2);
    private bool IsBetterConversionForPredefinedTypes(IType type1, IType type2);
    public BetterConversionResult IsBetterConversionBefore60(IType type1, IType type2, IExpressionType typeToConvert1, IExpressionType typeToConvert2, int reccounter, bool isOperatorPromotion);
    [CompilerGeneratedAttribute]
internal static bool <IsBetterCollectionExpressionConversion>g__HasImplicitConversion|12_0(IType from, IType to, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsBetterCollectionExpressionConversion>g__IsSzArrayOrArrayInterface|12_1(IType type, IType& elementType);
}
public static class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.BetterFunctionMemberSelector : object {
    public static int IsBetterFunctionMember(ApplicableCandidate candidate1, ApplicableCandidate candidate2, IPsiModule module, IResolveContext resolveContext, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static int IsBetterFunctionMemberUntil50(ApplicableCandidate candidate1, ApplicableCandidate candidate2, IPsiModule module, IResolveContext resolveContext, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static int IsBetterFunctionMember60Way(ApplicableCandidate candidate1, ApplicableCandidate candidate2, IPsiModule module, IResolveContext resolveContext, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static int HasMoreParametersInExpandedForm(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static bool AreIdenticalParameterTypes(ApplicableCandidate candidate1, ApplicableCandidate candidate2, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static int CountUsedParametersIncludingOptional(ApplicableCandidate candidate);
    private static bool AreIdenticalImplicitOptionalParameterTypes(ApplicableCandidate candidate1, ApplicableCandidate candidate2, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static Nullable`1<int> IsBetterFunctionWhenNonIdenticalParameterTypes60Way(ApplicableCandidate candidate1, ApplicableCandidate candidate2, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static int IsBetterFunctionWhenNonIdenticalParameterTypes(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static int CountTypeModifiers(IType type);
    private static int LessModoptParametersIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static int RequiredFunctionTypeOrNot(ApplicableCandidate candidate1, ApplicableCandidate candidate2, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static int ExplicitRefKindIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static bool IsInterpolatedStringRefMismatch(ArgumentMatchWithType match);
    private static int ByValIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2, CSharpLanguageLevel latestSupportedLanguageLevel);
    private static int MoreOptimizedOrSpecificParamsParameterTypeIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2, IPsiModule module);
    public static int HasBetterConversion(ApplicableCandidate candidate1, ApplicableCandidate candidate2, IPsiModule module, IResolveContext resolveContext, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, bool isOperatorPromotion);
    public static BetterConversionResult IsBetterConversion(IType type1, IType type2, IExpressionType typeToConvert1, IExpressionType typeToConvert2, IPsiModule module, IResolveContext resolveContext, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel, bool isOperatorPromotion);
    private static int CandidateFromClassIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static bool IsGeneric(IParametersOwner parametersOwner);
    private static int NonGenericIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static bool IsApplicableInExpandedForm(ApplicableCandidate candidate);
    private static int NonExpandedIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static int ExplicitArgumentsIsBetter60Way(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static int ExplicitArgumentsIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    [NotNullAttribute]
private static IEnumerable`1<IParameter> ImplicitOptionalParameters(ApplicableCandidate candidate);
    private static bool HasImplicitOptionalArguments(ApplicableCandidate candidate);
    private static int CountUsedParameters(ApplicableCandidate candidate);
    private static int CandidateWithMoreUsedParametersIsBetter(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static int MoreSpecificParameterTypes60Way(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    public static int MoreSpecificParameterTypes(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    private static int IsMoreSpecific(IType type1, IType type2, bool paramsCase);
    [CompilerGeneratedAttribute]
internal static bool <RequiredFunctionTypeOrNot>g__RequiredFunctionType|11_0(ApplicableCandidate candidate);
    [CompilerGeneratedAttribute]
internal static bool <ExplicitRefKindIsBetter>g__HasImplicitRef|12_0(ArgumentMatch match);
    [CompilerGeneratedAttribute]
internal static bool <ExplicitRefKindIsBetter>g__HasImplicitRefCSharp10|12_1(ArgumentMatchWithType match);
    [CompilerGeneratedAttribute]
internal static bool <ByValIsBetter>g__IsAcceptableRefMismatch|14_0(ParameterKind refKind, <>c__DisplayClass14_0& , <>c__DisplayClass14_1& );
    [CompilerGeneratedAttribute]
internal static bool <MoreOptimizedOrSpecificParamsParameterTypeIsBetter>g__HasImplicitConversion|15_0(IType type1, IType type2, <>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static bool <MoreOptimizedOrSpecificParamsParameterTypeIsBetter>g__IsArrayOrArrayInterfaceType|15_1(IType type, IType& elementType);
    [CompilerGeneratedAttribute]
internal static bool <HasBetterConversion>g__MatchKind|16_0(ArgumentMatchWithType match, <>c__DisplayClass16_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.Candidate : object {
    [CompilerGeneratedAttribute]
private ISymbolInfo <OriginalSymbolInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IParametersOwner <ParametersOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <ParametersOwnerSubstitution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParametersOwnerChanged>k__BackingField;
    public DeclaredElementInstance`1<IParametersOwner> ParametersOwnerInstance { get; }
    public ISymbolInfo OriginalSymbolInfo { get; }
    public IParametersOwner ParametersOwner { get; }
    public ISubstitution ParametersOwnerSubstitution { get; }
    public bool ParametersOwnerChanged { get; }
    public Candidate(IParametersOwner parametersOwner, ISubstitution substitution);
    public Candidate(ISymbolInfo symbolInfo, IParametersOwner parametersOwner, ISubstitution substitution, bool parametersOwnerChanged);
    public sealed virtual DeclaredElementInstance`1<IParametersOwner> get_ParametersOwnerInstance();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbolInfo get_OriginalSymbolInfo();
    [CompilerGeneratedAttribute]
public IParametersOwner get_ParametersOwner();
    [CompilerGeneratedAttribute]
public ISubstitution get_ParametersOwnerSubstitution();
    [CompilerGeneratedAttribute]
public bool get_ParametersOwnerChanged();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.CandidateWithResolveContext : object {
    [NotNullAttribute]
private InferedCandidate myCandidate;
    private List`1<ArgumentMatchWithType> myMatchResultWithTypes;
    private Nullable`1<bool> myIsDynamicDispatch;
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    public ISymbolInfo OriginalSymbolInfo { get; }
    public DeclaredElementInstance`1<IParametersOwner> ParametersOwnerInstance { get; }
    public IResolveContext ResolveContext { get; }
    public bool HasTypeArgumentInferredFromFunctionType { get; }
    public IParametersOwner ParametersOwner { get; }
    public bool ParametersOwnerChanged { get; }
    public IList`1<ArgumentMatch> MatchResult { get; }
    public ISubstitution ParametersOwnerSubstitution { get; }
    public ICollection`1<ITypeParameter> DynamicTypeParameters { get; }
    public bool IsDynamicDispatch { get; }
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public CandidateWithResolveContext(InferedCandidate candidate, IResolveContext resolveContext);
    public sealed virtual ISymbolInfo get_OriginalSymbolInfo();
    public sealed virtual DeclaredElementInstance`1<IParametersOwner> get_ParametersOwnerInstance();
    [CompilerGeneratedAttribute]
public IResolveContext get_ResolveContext();
    public bool get_HasTypeArgumentInferredFromFunctionType();
    public IParametersOwner get_ParametersOwner();
    public bool get_ParametersOwnerChanged();
    public IList`1<ArgumentMatch> get_MatchResult();
    public ISubstitution get_ParametersOwnerSubstitution();
    public List`1<ArgumentMatchWithType> MatchResultWithTypes();
    public ICollection`1<ITypeParameter> get_DynamicTypeParameters();
    public bool get_IsDynamicDispatch();
    public IDeclaredElement get_DeclaredElement();
    public ISubstitution get_Substitution();
    private void FixPossibleExpandedArgumentMatch();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.DelegateReturnTypeNotCompatible : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public DelegateReturnTypeNotCompatible(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.DynamicDispatch : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public DynamicDispatch(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
    protected virtual ResolveResultWithInfo CreateResolveResult(DeclaredElementInstance candidate, IResolveInfo resolveInfo);
    protected virtual ResolveResultWithInfo CreateResolveResult(IList`1<DeclaredElementInstance> candidates, IResolveInfo resolveInfo);
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.DynamicInvocation : OverloadResolutionResultBase {
    [CompilerGeneratedAttribute]
private IList`1<ISymbolInfo> <candidates>P;
    public ResolveErrorType ErrorType { get; }
    public DynamicInvocation(IList`1<ISymbolInfo> candidates);
    public virtual ResolveErrorType get_ErrorType();
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ExceptArgumentMatcher : object {
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentIndex>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public int ArgumentIndex { get; }
    public ExceptArgumentMatcher(IList`1<ICSharpArgumentInfo> arguments, int argumentIndex);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [CompilerGeneratedAttribute]
public int get_ArgumentIndex();
    [NotNullAttribute]
public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [CompilerGeneratedAttribute]
private bool <Match>b__7_0(ArgumentMatch match, int index);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.FunctionPointerArgumentsMatcher : MethodChooserArgumentsMatcherBase {
    [CompilerGeneratedAttribute]
private IFunctionPointerType <FunctionPointerType>k__BackingField;
    [NotNullAttribute]
public IFunctionPointerType FunctionPointerType { get; }
    public IType ReturnType { get; }
    public bool ReturnsByReference { get; }
    public FunctionPointerArgumentsMatcher(IList`1<ICSharpArgumentInfo> arguments, IFunctionPointerType functionPointerType);
    [CompilerGeneratedAttribute]
public IFunctionPointerType get_FunctionPointerType();
    public sealed virtual IType get_ReturnType();
    public sealed virtual bool get_ReturnsByReference();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.GroupByArgumentMatcher : object {
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentIndex>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public int ArgumentIndex { get; }
    public GroupByArgumentMatcher(IList`1<ICSharpArgumentInfo> arguments, int argumentIndex);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [CompilerGeneratedAttribute]
public int get_ArgumentIndex();
    [NotNullAttribute]
public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.IArgumentsMatcher {
    [NotNullAttribute]
public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public abstract virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public abstract virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ICandidate {
    public ISymbolInfo OriginalSymbolInfo { get; }
    public DeclaredElementInstance`1<IParametersOwner> ParametersOwnerInstance { get; }
    public abstract virtual ISymbolInfo get_OriginalSymbolInfo();
    public abstract virtual DeclaredElementInstance`1<IParametersOwner> get_ParametersOwnerInstance();
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.IMethodGroupArgumentsMatcher {
    [NotNullAttribute]
public IType ReturnType { get; }
    public bool ReturnsByReference { get; }
    public abstract virtual IType get_ReturnType();
    public abstract virtual bool get_ReturnsByReference();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.IncorrectParameterKind : OverloadResolutionResultImpl`1<MatchedCandidate> {
    public ResolveErrorType ErrorType { get; }
    public IncorrectParameterKind(IList`1<MatchedCandidate> candidates, ITypeParameterValuator typeParameterValues);
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.IncorrectParameterNumber : OverloadResolutionResultImpl`1<Candidate> {
    public ResolveErrorType ErrorType { get; }
    public IncorrectParameterNumber(IList`1<Candidate> candidates, ITypeParameterValuator typeParameterValues);
    public virtual ResolveErrorType get_ErrorType();
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.IncorrectParameterType : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public bool IsFinalResult { get; }
    public IncorrectParameterType(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool get_IsFinalResult();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.InferedCandidate : object {
    [NotNullAttribute]
private MatchedCandidate myCandidate;
    [CompilerGeneratedAttribute]
private ISubstitution <InferedSubstitution>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ITypeParameter> <DynamicTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTypeArgumentInferredFromFunctionType>k__BackingField;
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public ISymbolInfo OriginalSymbolInfo { get; }
    public DeclaredElementInstance`1<IParametersOwner> ParametersOwnerInstance { get; }
    public IParametersOwner ParametersOwner { get; }
    public bool ParametersOwnerChanged { get; }
    public IList`1<ArgumentMatch> MatchResult { get; }
    public ISubstitution ParametersOwnerSubstitution { get; }
    public ISubstitution InferedSubstitution { get; }
    public ICollection`1<ITypeParameter> DynamicTypeParameters { get; }
    public bool HasTypeArgumentInferredFromFunctionType { get; }
    public InferedCandidate(MatchedCandidate candidate, ISubstitution inferedSubstitution, ICollection`1<ITypeParameter> dynamicTypeParameters, bool hasTypeArgumentInferredFromFunctionType);
    public IDeclaredElement get_DeclaredElement();
    public ISubstitution get_Substitution();
    public sealed virtual ISymbolInfo get_OriginalSymbolInfo();
    public sealed virtual DeclaredElementInstance`1<IParametersOwner> get_ParametersOwnerInstance();
    public IParametersOwner get_ParametersOwner();
    public bool get_ParametersOwnerChanged();
    public IList`1<ArgumentMatch> get_MatchResult();
    public ISubstitution get_ParametersOwnerSubstitution();
    [CompilerGeneratedAttribute]
public ISubstitution get_InferedSubstitution();
    [CompilerGeneratedAttribute]
public ICollection`1<ITypeParameter> get_DynamicTypeParameters();
    [CompilerGeneratedAttribute]
public bool get_HasTypeArgumentInferredFromFunctionType();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.InterpolationResolveArgumentsMatcher : object {
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public InterpolationResolveArgumentsMatcher(IList`1<ICSharpArgumentInfo> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.IOverloadResolutionData {
    public IList`1<IType> ExplicitTypeParameterValues { get; }
    [NotNullAttribute]
public IList`1<ICSharpArgumentInfo> Arguments { get; }
    [NotNullAttribute]
public IArgumentsMatcher ArgumentsMatcher { get; }
    [NotNullAttribute]
public IPsiModule Module { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public CSharpLanguageLevel LatestSupportedLanguageLevel { get; }
    public bool StrictTypeInference { get; }
    public bool ShouldInferTypeParameters { get; }
    public bool CollectionExpressionAddResolve { get; }
    [NotNullAttribute]
public ICSharpTypeConversionRule TypeConversionRule { get; }
    [CanBeNullAttribute]
public IAccessContext AccessContext { get; }
    public abstract virtual IList`1<IType> get_ExplicitTypeParameterValues();
    public abstract virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    public abstract virtual IArgumentsMatcher get_ArgumentsMatcher();
    public abstract virtual IPsiModule get_Module();
    public abstract virtual CSharpLanguageLevel get_LanguageLevel();
    public abstract virtual CSharpLanguageLevel get_LatestSupportedLanguageLevel();
    public abstract virtual bool get_StrictTypeInference();
    public abstract virtual bool get_ShouldInferTypeParameters();
    public abstract virtual bool get_CollectionExpressionAddResolve();
    public abstract virtual ICSharpTypeConversionRule get_TypeConversionRule();
    public abstract virtual IAccessContext get_AccessContext();
}
public interface JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ITypeParameterValuator {
    public bool IsImplicit { get; }
    public abstract virtual bool get_IsImplicit();
    public abstract virtual ISubstitution InferImplicitTypeParameterValues(TMethodLike method, ISubstitution originalSubstitution);
    public abstract virtual ISubstitution SubstituteExplicitTypeParameterValues(ITypeParametersOwner typeParametersOwner, ISubstitution originalSubstitution);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.MatchedCandidate : object {
    [NotNullAttribute]
private Candidate myCandidate;
    [CompilerGeneratedAttribute]
private IList`1<ArgumentMatch> <MatchResult>k__BackingField;
    public IList`1<ArgumentMatch> MatchResult { get; }
    public ISymbolInfo OriginalSymbolInfo { get; }
    public DeclaredElementInstance`1<IParametersOwner> ParametersOwnerInstance { get; }
    public IParametersOwner ParametersOwner { get; }
    public ISubstitution ParametersOwnerSubstitution { get; }
    public bool ParametersOwnerChanged { get; }
    public MatchedCandidate PrimaryCandidate { get; }
    public MatchedCandidate SecondaryCandidate { get; }
    public MatchedCandidate(Candidate candidate, IList`1<ArgumentMatch> matches);
    [CompilerGeneratedAttribute]
public IList`1<ArgumentMatch> get_MatchResult();
    public sealed virtual ISymbolInfo get_OriginalSymbolInfo();
    public sealed virtual DeclaredElementInstance`1<IParametersOwner> get_ParametersOwnerInstance();
    public IParametersOwner get_ParametersOwner();
    public ISubstitution get_ParametersOwnerSubstitution();
    public bool get_ParametersOwnerChanged();
    public MatchedCandidate get_PrimaryCandidate();
    public MatchedCandidate get_SecondaryCandidate();
    public bool IsDynamicDispatch(IResolveContext resolveContext);
}
public enum JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.MatchKind : Enum {
    public int value__;
    public static MatchKind None;
    public static MatchKind Expanded;
    public static MatchKind PossibleAsCollection;
    public static MatchKind PossibleAsExpanded;
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.MethodChooserArgumentsMatcher : MethodChooserArgumentsMatcherBase {
    [CompilerGeneratedAttribute]
private IDelegate <Delegate>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [NotNullAttribute]
public IDelegate Delegate { get; }
    [NotNullAttribute]
public ISubstitution Substitution { get; }
    public IType ReturnType { get; }
    public bool ReturnsByReference { get; }
    public MethodChooserArgumentsMatcher(IList`1<ICSharpArgumentInfo> arguments, IDelegate delegate, ISubstitution substitution);
    [CompilerGeneratedAttribute]
public IDelegate get_Delegate();
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    public sealed virtual IType get_ReturnType();
    public sealed virtual bool get_ReturnsByReference();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.MethodChooserArgumentsMatcherBase : object {
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public MethodChooserArgumentsMatcherBase(IList`1<ICSharpArgumentInfo> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.NoApplicableCandidates : OverloadResolutionResultImpl`1<CandidateWithResolveContext> {
    [CompilerGeneratedAttribute]
private IResolveContext <motherResolveContext>P;
    public ResolveErrorType ErrorType { get; }
    public NoApplicableCandidates(IResolveContext motherResolveContext, IList`1<CandidateWithResolveContext> inferenceResult);
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
    public virtual ResolveResultWithInfo CommitResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.NoFullyApplicableCandidates : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public NoFullyApplicableCandidates(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.NonStrictMatcher : object {
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public NonStrictMatcher(IList`1<ICSharpArgumentInfo> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [NotNullAttribute]
public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.NoOverloadResolution : OverloadResolutionResult {
    [CompilerGeneratedAttribute]
private ResolveResultWithInfo <result>P;
    public ResolveErrorType ErrorType { get; }
    public bool IsEmpty { get; }
    public bool IsFinalResult { get; }
    public NoOverloadResolution(ResolveResultWithInfo result);
    public virtual ResolveResultWithInfo CommitResolveResult();
    public virtual ResolveResultWithInfo GetResolveResult();
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsFinalResult();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OperatorArgumentsMatcher : object {
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public OperatorArgumentsMatcher(IList`1<ICSharpArgumentInfo> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionData : object {
    [CompilerGeneratedAttribute]
private IArgumentsMatcher <ArgumentsMatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IType> <ExplicitTypeParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldInferTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectionExpressionAddResolve>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictTypeInference>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <LanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <LatestSupportedLanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ICSharpTypeConversionRule <TypeConversionRule>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccessContext <AccessContext>k__BackingField;
    public IArgumentsMatcher ArgumentsMatcher { get; }
    public IList`1<IType> ExplicitTypeParameterValues { get; public set; }
    public bool ShouldInferTypeParameters { get; public set; }
    public bool CollectionExpressionAddResolve { get; public set; }
    public bool StrictTypeInference { get; public set; }
    public IPsiModule Module { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public CSharpLanguageLevel LatestSupportedLanguageLevel { get; }
    public ICSharpTypeConversionRule TypeConversionRule { get; }
    public IAccessContext AccessContext { get; public set; }
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public OverloadResolutionData(IArgumentsMatcher argumentsMatcher, IPsiModule psiModule, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    public OverloadResolutionData(IList`1<ICSharpArgumentInfo> arguments, IPsiModule psiModule, ITreeNode context);
    [CompilerGeneratedAttribute]
public sealed virtual IArgumentsMatcher get_ArgumentsMatcher();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IType> get_ExplicitTypeParameterValues();
    [CompilerGeneratedAttribute]
public void set_ExplicitTypeParameterValues(IList`1<IType> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldInferTypeParameters();
    [CompilerGeneratedAttribute]
public void set_ShouldInferTypeParameters(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CollectionExpressionAddResolve();
    [CompilerGeneratedAttribute]
public void set_CollectionExpressionAddResolve(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StrictTypeInference();
    [CompilerGeneratedAttribute]
public void set_StrictTypeInference(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpLanguageLevel get_LanguageLevel();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpLanguageLevel get_LatestSupportedLanguageLevel();
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpTypeConversionRule get_TypeConversionRule();
    [CompilerGeneratedAttribute]
public sealed virtual IAccessContext get_AccessContext();
    [CompilerGeneratedAttribute]
public void set_AccessContext(IAccessContext value);
    public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionDataExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp100Supported(IOverloadResolutionData data);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp72Supported(IOverloadResolutionData data);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp6Supported(IOverloadResolutionData data);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp5Supported(IOverloadResolutionData data);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp4Supported(IOverloadResolutionData data);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCSharp3Supported(IOverloadResolutionData data);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionDataExtensions/<MatchThroughTargetTypedExpressions>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<ArgumentMatchWithType> MatchThroughTargetTypedExpressions(IEnumerable`1<ArgumentMatchWithType> matchResultWithTypes, bool allowTargetTypedExpressionsConstituents);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionDataExtensions/<MatchResultWithTypes>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<ArgumentMatchWithType> MatchResultWithTypes(IList`1<ArgumentMatch> matchResult, ISubstitution parametersOwnerSubstitution, IResolveContext resolveContext);
    [NotNullAttribute]
public static ICollection`1<ITypeParameter> DynamicTypeParameters(IList`1<ArgumentMatch> matchResult, IResolveContext resolveContext);
    [NotNullAttribute]
internal static ICollection`1<ITypeParameter> DynamicTypeParameters(IList`1<ArgumentMatch> matchResult, IResolveContext resolveContext, IDictionary`2& extension);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static IType <MatchResultWithTypes>g__GetElementType|7_0(IType parameterType, ICSharpArgumentInfo argumentInfo);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionEngine : object {
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private IOverloadResolutionData myData;
    [NotNullAttribute]
private TypeParameterValuator myTypeParameterValuator;
    [NotNullAttribute]
private ICSharpTypeConstraintsVerifier myTypeConstraintsVerifier;
    public OverloadResolutionEngine(IResolveContext resolveContext, IOverloadResolutionData data);
    [NotNullAttribute]
public OverloadResolutionResult ResolveOverloads(IList`1<ISymbolInfo> invocables);
    private IList`1<ApplicableCandidate> CheckMethodGroupsReturnType(IList`1<ApplicableCandidate> candidates);
    private IList`1<ApplicableCandidate> CheckCallingConventions(IList`1<ApplicableCandidate> candidates);
    private bool AreTypeArgumentConstraintsCorrect(ApplicableCandidate candidate);
    private IList`1<ApplicableCandidate> CheckTypeArgumentConstraints(IList`1<ApplicableCandidate> candidates);
    private IList`1<ApplicableCandidate> CheckStaticness(IList`1<ApplicableCandidate> candidates);
    private List`1<MatchedCandidate> FilterOutBadGenericMethods(IList`1<MatchedCandidate> candidates);
    private static bool IsValidExtensionMethodThisArgConversion(Conversion conversion);
    private bool InferExtensionMethodTypeArguments(MatchedCandidate candidate, IList`1<ITypeParameter> methodTypeParameters, ISubstitution& substitution);
    [NotNullAttribute]
private IList`1<Candidate> ExtractSignatureOwner(IList`1<ISymbolInfo> candidates, Boolean& containsDynamicValue);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> FindTheBest(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> FilterOutCandidatesFromParentClassesOrInterfaces(IList`1<ApplicableCandidate> candidates);
    private static bool HasDifferentParameterTypesInUnknownArgumentPosition(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
public IList`1<ApplicableCandidate> Verify(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
public IList`1<ApplicableCandidate> CheckFullyApplicability(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
private IList`1<Candidate> FilterNumberOfLambdaArguments(IList`1<Candidate> candidates);
    private static bool VerifyArguments(ApplicableCandidate candidate);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> CheckApplicability(IList`1<MatchedCandidate> candidates, IList`1& notApplicableResults);
    [CanBeNullAttribute]
private ApplicableCandidate CheckApplicability(MatchedCandidate candidate, IResolveContext resolveContext, CandidateWithResolveContext& candidateWithResolveContext);
    [CanBeNullAttribute]
private InferedCandidate InferTypeParameters(MatchedCandidate candidate, IResolveContext& resolveContext);
    private ISubstitution InferTypeParametersBeforeApplicabilityCheck(IResolveContext& resolveContext, MatchedCandidate candidate, ICollection`1& dynamicTypeParameters, Boolean& hasTypeArgumentInferredFromFunctionType);
    [CanBeNullAttribute]
private static CandidateWithResolveContext ForkIfNeeded(IResolveContext resolveContext, InferedCandidate candidate);
    private static bool HasDynamicTypeParameters(IType parameterType, ICollection`1<ITypeParameter> dynamicTypeParameters);
    [CanBeNullAttribute]
private ApplicableCandidate IsApplicableCandidate(CandidateWithResolveContext candidate);
    private ApplicableCandidate IsApplicableAfterTypeInference(IResolveContext resolveContext, InferedCandidate candidate, CandidateWithResolveContext& candidateWithResolveContext);
    private static ISubstitution CompleteSubstitutionWithUnknownTypes(ISubstitution substitution, IList`1<ITypeParameter> notInferredTypeParameters);
    private ISubstitution SubstituteExplicitTypeParameters(MatchedCandidate candidate);
    private ISubstitution SubstituteExplicitTypeParameters(IDeclaredElement declaredElement, ISubstitution substitution);
    [CanBeNullAttribute]
private ISubstitution InferTypes20Way(ISubstitution substitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, IList`1<ArgumentMatch> matchResult);
    [CanBeNullAttribute]
internal ISubstitution InferGivenTypeParameters(IParametersOwner parametersOwner, ISubstitution substitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    private ISubstitution InferTypes30Way(IParametersOwner parametersOwner, ISubstitution substitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    [CanBeNullAttribute]
private ISubstitution InferTypes20Way(IParametersOwner parametersOwner, ISubstitution substitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    [CanBeNullAttribute]
private MatchedCandidate CreateCandidate(IParametersOwner parametersOwner, ISubstitution substitution);
    public bool IsApplicable(IParametersOwner parametersOwner, ISubstitution substitution, bool isReducedFormExtension);
    public bool IsApplicableAfterTypeInference(IParametersOwner parametersOwner, ISubstitution substitution, IList`1<ArgumentMatch> matchResult, ICollection`1<ITypeParameter> dynamicTypeParameters);
    [CanBeNullAttribute]
public ApplicableCandidate GetApplicableCandidateAfterTypeInference(IParametersOwner parametersOwner, ISubstitution substitution, JetHashSet`1<ITypeParameter> dynamicTypeParameters, CandidateWithResolveContext& candidateWithResolveContext);
    private static bool BuildPrimaryConstraints(ArgumentMatchWithType match, TypeInferenceState state, ICollection`1<ITypeParameter> dynamicTypeParams, CSharpLanguageLevel languageLevel, bool strictTypeInference);
    private static bool BuildPrimaryConstraints(IExpressionType expressionType, IType parameterType, ParameterKind argumentKind, MatchKind matchKind, TypeInferenceState state, ICollection`1<ITypeParameter> dynamicTypeParams, CSharpLanguageLevel languageLevel, bool strictTypeInference);
    private static bool BuildPrimaryConstraints(IResolveContext resolveContext, IParametersOwner parametersOwner, IList`1<ArgumentMatch> matchResult, TypeInferenceState state, ICollection`1<ITypeParameter> dynamicTypeParams, IOverloadResolutionData overloadResolutionData);
    private ISubstitution InferTypes30Way(IResolveContext& resolveContext, IParametersOwner parametersOwner, ISubstitution substitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, IList`1<ArgumentMatch> matchResult, ICollection`1& dynamicTypeParameters, Boolean& hasTypeArgumentInferredFromFunctionType);
    public static ISubstitution InferTypes30Way(IResolveContext& resolveContext, IParametersOwner parametersOwner, ISubstitution substitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, IList`1<ArgumentMatch> matchResult, IOverloadResolutionData overloadResolutionData, ICollection`1& dynamicTypeParameters, Boolean& hasTypeArgumentInferredFromFunctionType);
    [NotNullAttribute]
private IList`1<MatchedCandidate> MatchArgumentsAgainstParameters(IList`1<Candidate> candidates);
    [NotNullAttribute]
private IList`1<Candidate> MatchParameterNumber(IList`1<Candidate> candidates);
    [NotNullAttribute]
private List`1<MatchedCandidate> MatchParameterKind(IList`1<MatchedCandidate> candidates);
    [PureAttribute]
private bool CheckParameterKinds(IList`1<ArgumentMatch> matchResult);
    [CompilerGeneratedAttribute]
internal static bool <IsApplicable>g__InvocationRequiresUnboxing|38_0(<>c__DisplayClass38_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionPriorityUtil : object {
    private static Pool<ITypeElement, ApplicableCandidate> ourCandidatesPool;
    private static OverloadResolutionPriorityUtil();
    public static IList`1<ApplicableCandidate> FilterOutLowerPriorityCandidates(IList`1<ApplicableCandidate> candidates, CSharpLanguageLevel languageLevel);
    public static int GetPriority(IParametersOwner parametersOwner);
    [NullableContextAttribute("2")]
public static bool IsMatchingAttributeConstructor(IConstructor constructor);
    [CompilerGeneratedAttribute]
internal static bool <FilterOutLowerPriorityCandidates>g__CheckIfAnyCandidateCanHaveOverloadResolutionPriority|1_0(IList`1<ApplicableCandidate> applicableCandidates);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionResult : object {
    [NotNullAttribute]
public ResolveErrorType ErrorType { get; }
    public bool IsFinalResult { get; }
    public bool IsEmpty { get; }
    public abstract virtual ResolveResultWithInfo CommitResolveResult();
    public abstract virtual ResolveResultWithInfo GetResolveResult();
    public abstract virtual ResolveErrorType get_ErrorType();
    public abstract virtual bool get_IsFinalResult();
    public abstract virtual bool get_IsEmpty();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionResultBase : OverloadResolutionResult {
    [CanBeNullAttribute]
protected ITypeParameterValuator myTypeParameterValuator;
    public bool IsFinalResult { get; }
    public bool IsEmpty { get; }
    protected OverloadResolutionResultBase(ITypeParameterValuator typeParameterValues);
    public virtual ResolveResultWithInfo CommitResolveResult();
    public virtual ResolveResultWithInfo GetResolveResult();
    private IList`1<DeclaredElementInstance> DistinctCandidates(IList`1<DeclaredElementInstance> candidates);
    protected abstract virtual IList`1<DeclaredElementInstance> GetCandidates();
    protected virtual ResolveResultWithInfo CreateResolveResult(IList`1<DeclaredElementInstance> candidates, IResolveInfo resolveInfo);
    protected virtual ResolveResultWithInfo CreateResolveResult(DeclaredElementInstance candidate, IResolveInfo resolveInfo);
    private void ValuateTypeParametersImplicitly(IList`1& candidates);
    private void ValuateTypeParametersExplicitly(IList`1& candidates);
    public virtual bool get_IsFinalResult();
    public virtual bool get_IsEmpty();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverloadResolutionResultImpl`1 : OverloadResolutionResultBase {
    [CompilerGeneratedAttribute]
private IList`1<TCandidate> <Candidates>k__BackingField;
    [NotNullAttribute]
protected IList`1<TCandidate> Candidates { get; }
    protected OverloadResolutionResultImpl`1(IList`1<TCandidate> candidates, ITypeParameterValuator typeParameterValues);
    [CompilerGeneratedAttribute]
protected IList`1<TCandidate> get_Candidates();
    protected virtual ResolveResultWithInfo CreateResolveResult(DeclaredElementInstance candidate, IResolveInfo resolveInfo);
    protected virtual ResolveResultWithInfo CreateResolveResult(IList`1<DeclaredElementInstance> candidates, IResolveInfo resolveInfo);
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.OverriddenFilterForCandidates`1 : OverriddenFilter`1<TCandidate> {
    public static OverriddenFilterForCandidates`1<TCandidate> INSTANCE;
    private static OverriddenFilterForCandidates`1();
    protected virtual ISymbolInfo GetSymbolInfo(TCandidate symbolInfo);
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.ResolveArgumentsMatcher : object {
    private bool myStrict;
    private CSharpLanguageLevel myLanguageLevel;
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public ResolveArgumentsMatcher(IList`1<ICSharpArgumentInfo> arguments, CSharpLanguageLevel languageLevel);
    public ResolveArgumentsMatcher(IList`1<ICSharpArgumentInfo> arguments, bool strict, CSharpLanguageLevel languageLevel);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.SignatureOwnerNotFound : OverloadResolutionResultBase {
    [CompilerGeneratedAttribute]
private IList`1<ISymbolInfo> <infos>P;
    public ResolveErrorType ErrorType { get; }
    public SignatureOwnerNotFound(IList`1<ISymbolInfo> infos);
    public virtual ResolveErrorType get_ErrorType();
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
    protected virtual ResolveResultWithInfo CreateResolveResult(DeclaredElementInstance candidate, IResolveInfo resolveInfo);
    protected virtual ResolveResultWithInfo CreateResolveResult(IList`1<DeclaredElementInstance> candidates, IResolveInfo resolveInfo);
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.StaticnessFailed : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public StaticnessFailed(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.TypeConstraintsFailed : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public TypeConstraintsFailed(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.TypeInferenceFailed : OverloadResolutionResultImpl`1<MatchedCandidate> {
    public ResolveErrorType ErrorType { get; }
    public TypeInferenceFailed(IList`1<MatchedCandidate> candidatesWithMatchedParameterNumber, ITypeParameterValuator typeParameterValuator);
    protected virtual IList`1<DeclaredElementInstance> GetCandidates();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.UpToArgumentMatcher : object {
    [CompilerGeneratedAttribute]
private IList`1<ICSharpArgumentInfo> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentIndex>k__BackingField;
    public IList`1<ICSharpArgumentInfo> Arguments { get; }
    public int ArgumentIndex { get; }
    public UpToArgumentMatcher(IList`1<ICSharpArgumentInfo> arguments, int argumentIndex);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ICSharpArgumentInfo> get_Arguments();
    [CompilerGeneratedAttribute]
public int get_ArgumentIndex();
    [NotNullAttribute]
public sealed virtual IList`1<ArgumentMatch> Match(IList`1<IParameter> parameters);
    public sealed virtual bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.VerificationFailedCandidates : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public VerificationFailedCandidates(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.OverloadResolution.WrongCallingConvention : ApplicableCandidatesResultBase {
    public ResolveErrorType ErrorType { get; }
    public WrongCallingConvention(IResolveContext motherResolveContext, IList`1<ApplicableCandidate> applicableCandidates);
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.ResolveInfoWithUsing : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IUsingDirective> <UsingDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveErrorType <ResolveErrorType>k__BackingField;
    public IReadOnlyList`1<IUsingDirective> UsingDirectives { get; }
    public ResolveErrorType ResolveErrorType { get; }
    public ResolveInfoWithUsing(IUsingDirective usingDirective, IResolveInfo resolveInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IUsingDirective> get_UsingDirectives();
    [CompilerGeneratedAttribute]
public sealed virtual ResolveErrorType get_ResolveErrorType();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.CSharp.Resolve.ResolveInfoWithUsings : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IUsingDirective> <UsingDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveErrorType <ResolveErrorType>k__BackingField;
    public IReadOnlyList`1<IUsingDirective> UsingDirectives { get; }
    public ResolveErrorType ResolveErrorType { get; }
    public ResolveInfoWithUsings(IReadOnlyList`1<IUsingDirective> usingDirectives, IResolveInfo resolveInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IUsingDirective> get_UsingDirectives();
    [CompilerGeneratedAttribute]
public sealed virtual ResolveErrorType get_ResolveErrorType();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Resolve.ResolveInfoWithUsingsExtension : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static string GetExternAliasName(IResolveInfoWithUsings info);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IUsingDirective> GetUsingDirectives(IResolveInfo info);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IUsingAliasDirective TryGetUsingAliasDirective(IResolveInfo info);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ISymbolAlias TryGetSymbolAlias(IResolveInfo info);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Resolve.TypeInference.CSharpTypeInferenceBoundsSolver : object {
    public sealed virtual ISubstitution SolveLikeResolve(IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> typeBounds, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ITypeConversionRule conversionRule);
    [NotNullAttribute]
public sealed virtual IReadOnlyList`1<ISubstitution> Solve(IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> typeBounds, ITypeConversionRule conversionRule);
    [CanBeNullAttribute]
private static IDictionary`2<ITypeParameter, IType> SolveSingleSolution(Dictionary`2<ITypeParameter, TypeInferenceBoundsSet> solution, ITypeConversionRule conversionRule);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Resolve.TypeInference.CSharpTypeInferenceMatcher : CLRTypeInferenceMatcher {
    public static CSharpTypeInferenceMatcher Instance;
    private static CSharpTypeInferenceMatcher();
    public virtual bool Match(TypeInferenceKind inferenceKind, IType actualType, IType formalTypeWithVariables, ITypeInferenceConsumer consumer);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Resolve.TypeInference.CSharpTypeInferenceUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool InferFromSimpleArgument(ICSharpArgumentInfo argumentInfo, IExpressionType expressionType, IType parameterType, ITypeInferenceConsumer consumer);
    [NotNullAttribute]
[PureAttribute]
public static ISubstitution InferTypes(IList`1<ICSharpArgumentInfo> arguments, IParametersOwner parametersOwner, ISubstitution substitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, IPsiModule module, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [NotNullAttribute]
public static IReadOnlyList`1<ITypeParameter> GetIdTypeParameters(TMethodLike method, ISubstitution substitution);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IType SolveTypeInferenceBounds(TypeInferenceBoundsSet boundsSet, ITypeParameter typeParameter, ISubstitution substitution, ITypeConversionRule conversionRule, Boolean& inferredFromFunctionType);
    private static ValueTuple`2<IType, bool> SolveTypeInferenceBounds(ITypeParameter typeParameter, ICollection`1<TypeInferenceBound> bounds, ISubstitution substitution, ICSharpTypeConversionRule conversionRule);
    private static void AddAllCandidates(Dictionary`2<IType, IType> initialCandidates, ICollection`1<TypeInferenceBound> bounds, TypeParameterVariance typeParameterVariance);
    private static void MergeOrRemoveCandidates(Dictionary`2<IType, IType> candidates, Dictionary`2<IType, IType> initialCandidates, ICollection`1<TypeInferenceBound> bounds, TypeParameterVariance variance, ICSharpTypeConversionRule typeConversionRule);
    private static bool ImplicitConversionExists(IType source, IType destination, ICSharpTypeConversionRule typeConversionRule, bool predefined);
    private static void MergeAndReplaceIfStillCandidate(Dictionary`2<IType, IType> candidates, IType oldCandidate, IType newCandidate, TypeParameterVariance variance);
    private static TypeParameterVariance GetTypeParameterVariance(TypeInferenceKind boundKind);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <SolveTypeInferenceBounds>g__AnyBound|4_1(TypeInferenceKind kind, Func`2<IType, bool> predicate, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <SolveTypeInferenceBounds>g__ContainsFunctionTypes|4_2(TypeInferenceKind kind, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <SolveTypeInferenceBounds>g__ContainsNonFunctionTypes|4_3(TypeInferenceKind kind, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static ICollection`1<TypeInferenceBound> <SolveTypeInferenceBounds>g__RemoveFunctionTypesFromLowerBounds|4_4(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <SolveTypeInferenceBounds>g__HasExpressionTypeConstraint|4_5(ITypeParameter typeParameter, ISubstitution substitution);
}
public class JetBrains.ReSharper.Psi.CSharp.Resources.PsiCSharpThemedIcons : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string AccessorDeclarationSettingDescription { get; }
    public static string AmbiguousUserDefinedConversions_Text { get; }
    public static string ExpectedTupleElementName__Text { get; }
    public static string FileLayoutDesigner_Elements_Body_Type_Block_Text { get; }
    public static string FileLayoutDesigner_Elements_Body_Type_Expression_Text { get; }
    public static string FileLayoutDesigner_Elements_Direction_Ascending_Text { get; }
    public static string FileLayoutDesigner_Elements_Direction_Descending_Text { get; }
    public static string FileLayoutDesigner_Elements_DisplayName_Text { get; }
    public static string FileLayoutDesigner_Elements_Pattern_RemoveRegions_All_Text { get; }
    public static string AsyncMethod_PresentableName_Text { get; }
    public static string AsyncTaskMethod_PresentableName_Text { get; }
    public static string CaseBlockBracesSettingDescription { get; }
    public static string AdditiveOperatorsSettingDescription { get; }
    public static string AddusingDirectivesOnOptimizationSettingDescription { get; }
    public static string AddusingDirectiveToDeepestScopeSettingDescription { get; }
    public static string AfterAttributesSettingDescription { get; }
    public static string AfterBaseTypesListColonSettingDescription { get; }
    public static string AfterCommaSettingDescription { get; }
    public static string AfterFileHeaderCommentSettingDescription { get; }
    public static string AfterFileScopedNamespaceDirectiveSettingDescription { get; }
    public static string AfterMultilineStatementsSettingDescription { get; }
    public static string AfterOperatorKeywordSettingDescription { get; }
    public static string AfterOtherColonsSettingDescription { get; }
    public static string AfterQuestSettingDescription { get; }
    public static string AfterColonSettingDescription { get; }
    public static string AfterStatementsWithChildBlocksSettingDescription { get; }
    public static string AfterStatementsWithControlTransferSettingDescription { get; }
    public static string AfterTypeCastParenthesesSettingDescription { get; }
    public static string AfterTypeParameterConstraintColonSettingDescription { get; }
    public static string AllowCommentAfterSettingDescription { get; }
    public static string AllowConstructorInitializerOnTheSameLineSettingDescription { get; }
    public static string AllowPrimaryConstructorInitializerOnTheSameLineSettingDescription { get; }
    public static string AllowglobalPrefixUseSettingDescription { get; }
    public static string AllowTypeConstraintsOnTheSameLineSettingDescription { get; }
    public static string AnonymousMethodBodySettingDescription { get; }
    public static string AnonymousMethodsDelegatesAndLambdasSettingDescription { get; }
    public static string ApplyStyleHeuristicsSettingDescription { get; }
    public static string ApplySyntaxStyleOnCodeCompletionSettingDescription { get; }
    public static string AroundAutoAbstractPropertyEventSettingDescription { get; }
    public static string AroundDotSettingDescription { get; }
    public static string AroundFieldSettingDescription { get; }
    public static string AroundInNamespaceAliasDirectiveSettingDescription { get; }
    public static string AroundLambdaArrowSettingDescription { get; }
    public static string AroundLocalFunctionSettingDescription { get; }
    public static string AroundMethodSettingDescription { get; }
    public static string AroundNamespaceSettingDescription { get; }
    public static string AroundOperandsOfTheFollowingOperationsSettingDescription { get; }
    public static string AroundPropertyEventAccessorSettingDescription { get; }
    public static string AroundPropertyEventSettingDescription { get; }
    public static string AroundRegionSettingDescription { get; }
    public static string AroundSingleLineAutoAbstractPropertyEventSettingDescription { get; }
    public static string AroundSingleLineFieldSettingDescription { get; }
    public static string AroundSingleLineLocalFunctionSettingDescription { get; }
    public static string AroundSingleLineMethodSettingDescription { get; }
    public static string AroundSingleLinePropertyEventAccessorSettingDescription { get; }
    public static string AroundSingleLinePropertyEventSettingDescription { get; }
    public static string AroundSingleLineTypeSettingDescription { get; }
    public static string AroundTypeSettingDescription { get; }
    public static string ArrayObjectAndCollectionInitializerSettingDescription { get; }
    public static string AssignmentOperatorsSettingDescription { get; }
    public static string BeforeAfterAndSettingDescription { get; }
    public static string BeforeANewLineInMultilineListsSettingDescription { get; }
    public static string BeforeArrayAccessBracketsSettingDescription { get; }
    public static string BeforeArrayRankBracketsSettingDescription { get; }
    public static string BeforeBaseTypesListColonSettingDescription { get; }
    public static string BeforeCommaSettingDescription { get; }
    public static string BeforeEndOfLineCommentSettingDescription { get; }
    public static string BeforeMultilineStatementsSettingDescription { get; }
    public static string BeforeNullableMarkSettingDescription { get; }
    public static string BeforeOtherColonsSettingDescription { get; }
    public static string BeforeSemicolonSettingDescription { get; }
    public static string BeforeQuestSettingDescription { get; }
    public static string BeforeColonSettingDescription { get; }
    public static string BeforeSingleLineAccessorsBlockSettingDescription { get; }
    public static string BeforeSingleLineCommentSettingDescription { get; }
    public static string BeforeStatementsWithChildBlocksSettingDescription { get; }
    public static string BeforeStatementsWithControlTransferSettingDescription { get; }
    public static string BeforeTypeArgumentListAngleSettingDescription { get; }
    public static string BeforeTypeParameterConstraintColonSettingDescription { get; }
    public static string BeforeTypeParameterListAngleSettingDescription { get; }
    public static string BeforeUnsafePointerDeclarationSettingDescription { get; }
    public static string BetweenAccessorsInSingleLinePropertyEventSettingDescription { get; }
    public static string BetweenAttributeSectionsSettingDescription { get; }
    public static string BetweenKeywordAndExpressionSettingDescription { get; }
    public static string BetweenKeywordAndTypeSettingDescription { get; }
    public static string BinaryExpressionsSettingDescription { get; }
    public static string BinaryPatternsSettingDescription { get; }
    public static string BitwiseOperatorsSettingDescription { get; }
    public static string BreakLineInABlockWithASingleStatementSettingDescription { get; }
    public static string BreakLineInSingleEmbeddedStatementSettingDescription { get; }
    public static string CallArgumentsBySettingDescription { get; }
    public static string CallArgumentsSettingDescription { get; }
    public static string CatchVariable_PresentableName_Text { get; }
    public static string CFileLayoutPatternSettingDescription { get; }
    public static string ChainedMethodCallsSettingDescription { get; }
    public static string CLanguageLevelSettingDescription { get; }
    public static string CLanguageSettingsSettingDescription { get; }
    public static string Class_PresentableName_Text { get; }
    public static string CMemberOrderPatternSettingDescription { get; }
    public static string CNamespaceImportSettingDescription { get; }
    public static string CNamingSettingsSettingDescription { get; }
    public static string CodeFormattingInCSettingDescription { get; }
    public static string CollectionExpressionElementExpected_Text { get; }
    public static string CollectionExpressionExpected_Text { get; }
    public static string ConstructorsAndDestructorsSettingDescription { get; }
    public static string CSharpVarKeywordUsageSettingsSettingDescription { get; }
    public static string CustomPatternUseNullForDefaultPatternSettingDescription { get; }
    public static string FileLayoutDesigner_Elements_Pattern_RemoveRegions_ExceptGenerated_Text { get; }
    public static string FileLayoutDesigner_Elements_Is_Text { get; }
    public static string FileLayoutDesigner_Elements_ImplementsInterface_Immediate_Text { get; }
    public static string FileLayoutDesigner_Elements_Name_IgnoreCase_Text { get; }
    public static string KeepNonTrivialUsingAliasesSettingDescription { get; }
    public static string LambdaParameter_PresentableName_Text { get; }
    public static string PrimaryConstructor_Text { get; }
    public static string PrimaryCtorParameter_PresentableName_Text { get; }
    public static string RecordPositionalParameter_PresentableName_Text { get; }
    public static string LocalFunction_PresentableName_Text { get; }
    public static string AsyncLocalFunction_PresentableName_Text { get; }
    public static string AsyncTaskLocalFunction_PresentableName_Text { get; }
    public static string FileLayoutDesigner_Elements_Pattern_RemoveRegions_None_Text { get; }
    public static string FileLayoutDesigner_Elements_HandlesEvent_MatchBy_Text { get; }
    public static string FileLayoutDesigner_Elements_Name_Text { get; }
    public static string NoParameters_Text { get; }
    public static string FileLayoutDesigner_Elements_Priority_Text { get; }
    public static string FileLayoutDesigner_Elements_ParameterName_Text { get; }
    public static string Record_PresentableName_Text { get; }
    public static string FileLayoutDesigner_Elements_Pattern_RemoveRegions_Text { get; }
    public static string FileLayoutDesigner_Elements_Patterns_StaticFieldReorderingPolicy_Relaxed_Text { get; }
    public static string RemoveUnusedOnlyUsingAliasesSettingDescription { get; }
    public static string DontForceSingleLinesSettingDescription { get; }
    public static string DontIndentCommentsStartedAtFirstColumnSettingDescription { get; }
    public static string DontRemoveExtraBlankLinesSettingDescription { get; }
    public static string ElsewhereSettingDescription { get; }
    public static string EmptyBracesFormattingSettingDescription { get; }
    public static string EndCommentsSettingDescription { get; }
    public static string EqualityOperatorsSettingDescription { get; }
    public static string EvenWhenOperationsOfTheSameTypeAreNestedSettingDescription { get; }
    public static string ExpressionsInitializersSwitchExpressionsPatternsSettingDescription { get; }
    public static string FieldsAndConstantsSettingDescription { get; }
    public static string FileLayoutPatternSettingDescription { get; }
    public static string ForBuiltInTypesSettingDescription { get; }
    public static string ForSimpleTypesSettingDescription { get; }
    public static string GeneratorModeSettingDescription { get; }
    public static string IncludePrefixCommentsInIndentsSettingDescription { get; }
    public static string IndentBracesInsideStatementConditionsSettingDescription { get; }
    public static string IndentIfElseElifEndifSettingDescription { get; }
    public static string IndentInsideNamespaceDeclarationSettingDescription { get; }
    public static string IndentMethodCallsParenthesisSettingDescription { get; }
    public static string IndentMethodDeclarationsParenthesisSettingDescription { get; }
    public static string IndentPrimaryConstructorDeclarationsParenthesisSettingDescription { get; }
    public static string IndentOtherParenthesisAndBracketsSettingDescription { get; }
    public static string IndentOtherPreprocessorDirectivesSettingDescription { get; }
    public static string IndentRegionEndregionSettingDescription { get; }
    public static string IndentStatementIfWhileForEtcParenthesisSettingDescription { get; }
    public static string IndentTypeArgumentsAnglesSettingDescription { get; }
    public static string IndentTypeConstraintsSettingDescription { get; }
    public static string IndentTypeParametersAnglesSettingDescription { get; }
    public static string InLocalsMembersAndParametersPreferSettingDescription { get; }
    public static string InMemberAccessExpressionsPreferSettingDescription { get; }
    public static string ApplyToNativeIntegerDescription { get; }
    public static string InsideNamespaceSettingDescription { get; }
    public static string InsideRegionSettingDescription { get; }
    public static string InsideTypeSettingDescription { get; }
    public static string InvocationsOfTheSameMethodSettingDescription { get; }
    public static string JoinOrSeparateAttributesInSectionSettingDescription { get; }
    public static string KeepExistingArrangementOfAttributesSettingDescription { get; }
    public static string KeepExistingArrangementOfDeclarationBlocksSettingDescription { get; }
    public static string KeepExistingArrangementOfEmbeddedBlocksSettingDescription { get; }
    public static string KeepExistingArrangementOfEmbeddedStatementsSettingDescription { get; }
    public static string KeepExistingArrangementOfEnumerationSettingDescription { get; }
    public static string KeepExistingArrangementOfExpressionBodiedMembersSettingDescription { get; }
    public static string KeepExistingArrangementOfInitializersSettingDescription { get; }
    public static string KeepExistingArrangementOfParenthesisInDeclarationSettingDescription { get; }
    public static string KeepExistingArrangementOfParenthesisInInvocationSettingDescription { get; }
    public static string KeepExistingArrangementOfPropertyPatternsSettingDescription { get; }
    public static string KeepExistingArrangementOfListPatternsSettingDescription { get; }
    public static string KeepExistingArrangementOfSwitchExpressionsSettingDescription { get; }
    public static string KeepExistingAttributePlacementSettingDescription { get; }
    public static string KeepExistingLineBreaksSettingDescription { get; }
    public static string KeepMaxBlankLinesInCodeSettingDescription { get; }
    public static string KeepMaxBlankLinesInDeclarationsSettingDescription { get; }
    public static string KeepusingDirectivesOnOptimizationSettingDescription { get; }
    public static string LambdaAndDelegateAnonymousMethodDeclarationSettingDescription { get; }
    public static string LayoutTypeSettingDescription { get; }
    public static string LINQQuerySettingDescription { get; }
    public static string ListOfBaseClassesAndInterfacesSettingDescription { get; }
    public static string LiteralValuesSettingDescription { get; }
    public static string LocalFunctionsSettingDescription { get; }
    public static string LogicalNotOperatorSettingDescription { get; }
    public static string LogicalOperatorsSettingDescription { get; }
    public static string MaxArrayInitializerElementsOnASingleLineSettingDescription { get; }
    public static string MaxEnumerationMembersOnASingleLineSettingDescription { get; }
    public static string MaxFormalParametersOnASingleLineSettingDescription { get; }
    public static string MaxPrimaryConstructorParametersOnASingleLineSettingDescription { get; }
    public static string MaxInvocationArgumentsOnASingleLineSettingDescription { get; }
    public static string MaxObjectAndCollectionInitializerElementsOnASingleLineSettingDescription { get; }
    public static string MaxPatternPropertiesOnASingleLineSettingDescription { get; }
    public static string MembersToQualifySettingDescription { get; }
    public static string MethodCallEmptyParenthesesSettingDescription { get; }
    public static string MethodCallParenthesesSettingDescription { get; }
    public static string MethodDeclarationEmptyParenthesesSettingDescription { get; }
    public static string MethodDeclarationParenthesesSettingDescription { get; }
    public static string MethodDeclarationSettingDescription { get; }
    public static string MethodParametersSettingDescription { get; }
    public static string MethodsAndOperatorsSettingDescription { get; }
    public static string ModifiersOrderSettingDescription { get; }
    public static string MultilineMethodSignatureSettingDescription { get; }
    public static string MultipleDeclarationsSettingDescription { get; }
    public static string MultiplicativeOperatorsSettingDescription { get; }
    public static string NamedExpressionsVariablesPropertiesMethodsEtcSettingDescription { get; }
    public static string NamespacesSettingDescription { get; }
    public static string NamespacesThatShouldNotBeRemovedFromFullyQualifiedTypeNamesSettingDescription { get; }
    public static string NestedTernaryExpressionStyleSettingDescription { get; }
    public static string NestedTernaryOperatorsSettingDescription { get; }
    public static string NullCoalescingOperatorSettingDescription { get; }
    public static string OtherAssignmentsAndInitializersSettingDescription { get; }
    public static string OtherExpressionsSettingDescription { get; }
    public static string OtherSettingDescription { get; }
    public static string OutdentBinaryOperatorsSettingDescription { get; }
    public static string OutdentBinaryPatternsSettingDescription { get; }
    public static string OutdentCommasSettingDescription { get; }
    public static string OutdentDotsInChainedMethodCallsSettingDescription { get; }
    public static string OutdentStatementLabelsSettingDescription { get; }
    public static string OutdentTernaryExpressionsSettingDescription { get; }
    public static string ParenthesesSettingDescription { get; }
    public static string ParserCollectionExpressionElementSymbol_Text { get; }
    public static string PlaceABlockWithASingleSimpleStatementOnTheSameLineSettingDescription { get; }
    public static string PlaceAbstractAutoPropertyIndexerEventDeclarationOnSingleLineSettingDescription { get; }
    public static string PlaceAccessorAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceAttributeOnSeparateLineIfItIsLongerThanSettingDescription { get; }
    public static string PlaceAttributeSectionListOnSeparateLineIfItIsLongerThanSettingDescription { get; }
    public static string PlaceCommentsAtFirstColumnWhenCommentingOutCodeSettingDescription { get; }
    public static string PlaceFieldAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceItOnSingleLineEvenWhenItHasAttributesOnAccessorsSettingDescription { get; }
    public static string PlaceMethodAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceMethodExpressionBodyOnTheSameLineSettingDescription { get; }
    public static string PlaceMultilineAccessorAttributeOnTheSameLineSettingDescription { get; }
    public static string PlacePropertyAccessorExpressionBodyOnTheSameLineSettingDescription { get; }
    public static string PlacePropertyExpressionBodyOnTheSameLineSettingDescription { get; }
    public static string PlacePropertyIndexerEventAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceRecordFieldAttributeOnTheSameLine { get; }
    public static string PlaceSimpleAccessorOnSingleLineSettingDescription { get; }
    public static string PlaceSimpleAnonymousMethodOnSingleLineSettingDescription { get; }
    public static string PlaceSimpleArrayObjectAndCollectionOnSingleLineSettingDescription { get; }
    public static string PlaceSimpleEmbeddedStatementOnTheSameLineSettingDescription { get; }
    public static string PlaceSimpleEnumerationOnSingleLineSettingDescription { get; }
    public static string PlaceSimpleMethodOnSingleLineSettingDescription { get; }
    public static string PlaceSimplePropertyIndexerEventDeclarationOnSingleLineSettingDescription { get; }
    public static string PlaceSimplePropertyPatternOnSingleLineSettingDescription { get; }
    public static string PlaceSimpleListPatternOnSingleLineSettingDescription { get; }
    public static string PlaceSimpleSwitchExpressionOnSingleLineSettingDescription { get; }
    public static string PlaceSinglelineAccessorAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceSinglelineMethodAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceSystemAndWindowsNamespacesFirstWhenSortingusingDirectivesSettingDescription { get; }
    public static string PlaceTypeAttributeOnTheSameLineSettingDescription { get; }
    public static string PreferExplicitImplicitInternalModifierForTypesSettingDescription { get; }
    public static string PreferExplicitImplicitPrivateModifierForTypeMembersSettingDescription { get; }
    public static string PreferExtensionMethodsImportWithusingStaticDirectiveSettingDescription { get; }
    public static string PreferFullyQualifiedReferencesSettingDescription { get; }
    public static string PreferFullyQualifiedUsingNameAtNestedScopeSettingDescription { get; }
    public static string PreferRoslynVisualStudioLogicForTypeEvidenceSettingDescription { get; }
    public static string PreferSeparateDeclarationsForDeconstructedVariablesSettingDescription { get; }
    public static string PreferWrapBeforeFirstConstraintSettingDescription { get; }
    public static string PreferWrapBeforeMultilineLINQExpressionsSettingDescription { get; }
    public static string PreferWrapBeforeOperatorInBinaryExpressionSettingDescription { get; }
    public static string PreferWrapBeforeOperatorInBinaryPatternSettingDescription { get; }
    public static string PreferWrapBeforeTypeParametersOpeningAngleSettingDescription { get; }
    public static string PropertiesAndEventsSettingDescription { get; }
    public static string PropertiesIndexersAndEventsSettingDescription { get; }
    public static string PropertyDeclarationSettingDescription { get; }
    public static string PropertyPatternsSettingDescription { get; }
    public static string ListPatternsSettingDescription { get; }
    public static string QualifyMembersDeclaredInSettingDescription { get; }
    public static string QualifyWithTheNameOfSettingDescription { get; }
    public static string RelationalOperatorsSettingDescription { get; }
    public static string RemoveRedundantParenthesesSettingDescription { get; }
    public static string RemoveRedundantSettingDescription { get; }
    public static string RevertToOldFormattingEngineSettingDescription { get; }
    public static string ShiftOperatorsSettingDescription { get; }
    public static string SimpleMethodsOperatorsDelegatesSettingDescription { get; }
    public static string SimpleSwitchSectionsSettingDescription { get; }
    public static string SkipSingleArgumentsSettingDescription { get; }
    public static string FileLayoutDesigner_Elements_SortBy_Text { get; }
    public static string FileLayoutDesigner_Elements_Direction_Text { get; }
    public static string SortusingDirectivesSettingDescription { get; }
    public static string SpaceBetweenEmptyBracesSettingDescription { get; }
    public static string StatementConditionsInsideParenthesisSettingDescription { get; }
    public static string FileLayoutDesigner_Elements_Patterns_StaticFieldReorderingPolicy_Text { get; }
    public static string StaticMemberQualifierSettingDescription { get; }
    public static string FileLayoutDesigner_Elements_Patterns_StaticFieldReorderingPolicy_Strict_Text { get; }
    public static string StringLiteralValuesSettingDescription { get; }
    public static string SwitchExpressionsSettingDescription { get; }
    public static string SyntaxStyleInCSettingDescription { get; }
    public static string FileLayoutDesigner_Elements_HasAttribute_Target_Text { get; }
    public static string TupleComponentsSettingDescription { get; }
    public static string TupleComponentShouldBeAddedInOrder_Text { get; }
    public static string TupleComponentShouldBeRemovedInOrder_Text { get; }
    public static string TupleComponent_DoesnTMatchExpectedComponent_Text { get; }
    public static string TupleComponent_ShouldBeRemovedInOrder_Text { get; }
    public static string TupleElementName_DoesnTMatchExpected_Text { get; }
    public static string TupleElementName_ShouldBeRemovedInOrder_Text { get; }
    public static string TypeAndNamespaceDeclarationSettingDescription { get; }
    public static string TypeArgumentAnglesSettingDescription { get; }
    public static string TypeCastParenthesesSettingDescription { get; }
    public static string TypeParameterAnglesSettingDescription { get; }
    public static string TypeParameterConstraintsSettingDescription { get; }
    public static string TypeParametersListSettingDescription { get; }
    public static string FileLayoutDesigner_Elements_Body_Type_Text { get; }
    public static string TypeParameter_ShouldBeRemovedInOrder_Text { get; }
    public static string Type_DoesnTMatchExpectedType__Text { get; }
    public static string UnaryMinusOperatorSettingDescription { get; }
    public static string UnaryPlusOperatorSettingDescription { get; }
    public static string FileLayoutDesigner_Elements_Patterns_StaticFieldReorderingPolicy_Unrestricted_Text { get; }
    public static string UnsafeAddressofOperatorSettingDescription { get; }
    public static string UnsafeArrowOperatorSettingDescription { get; }
    public static string UnsafeAsteriskOperatorSettingDescription { get; }
    public static string UseContinuousLineIndentInsideExpressionBracesSettingDescription { get; }
    public static string UseContinuousLineIndentInsideParenthesisSettingDescription { get; }
    public static string UseUsingAliasDirectiveToResolveConflictsSettingDescription { get; }
    public static string UsevarKeywordForDiscardsSettingDescription { get; }
    public static string VariablesAndLocalConstantsSettingDescription { get; }
    public static string WhenCreatedTypeIsEvidentFromUsageSettingDescription { get; }
    public static string WhenCreatedTypeIsNotEvidentFromUsageSettingDescription { get; }
    public static string WhenTheLastElementIsNotFollowedByANewLineSettingDescription { get; }
    public static string WhenTheOperationsFromTheFollowingGroupsAreNestedSettingDescription { get; }
    public static string WhenTypeIsEvidentFromUsageSettingDescription { get; }
    public static string WhenTypeIsNotEvidentFromUsageSettingDescription { get; }
    public static string WithinArrayAccessBracketsSettingDescription { get; }
    public static string WithinListPatternBracketsSettingDescription { get; }
    public static string WithinSlicePatternSettingDescription { get; }
    public static string WithinArrayRankBracketsSettingDescription { get; }
    public static string WithinArrayRankEmptyBracketsSettingDescription { get; }
    public static string WithinAttributeBracketsSettingDescription { get; }
    public static string WithinSingleLineAccessorSettingDescription { get; }
    public static string WithinSingleLineAnonymousMethodSettingDescription { get; }
    public static string WithinSingleLineExpressionBracesSettingDescription { get; }
    public static string WithinSingleLineMethodSettingDescription { get; }
    public static string WrapArrayInitializerSettingDescription { get; }
    public static string WrapChainedBinaryExpressionsSettingDescription { get; }
    public static string WrapChainedMethodCallsSettingDescription { get; }
    public static string WrapCollectionExpressionSettingDescription { get; }
    public static string WrapComplexBinaryPatternsSettingDescription { get; }
    public static string WrapEnumerationDeclarationSettingDescription { get; }
    public static string WrapExtendsImplementsListSettingDescription { get; }
    public static string WrapFormalParametersSettingDescription { get; }
    public static string WrapPrimaryConstructorParametersSettingDescription { get; }
    public static string WrapInvocationArgumentsSettingDescription { get; }
    public static string WrapLINQExpressionsSettingDescription { get; }
    public static string WrapMultipleDeclarationSettingDescription { get; }
    public static string WrapMultipleTypeParameterConstraintsSettingDescription { get; }
    public static string WrapObjectAndCollectionInitializerSettingDescription { get; }
    public static string WrapPropertyPatternSettingDescription { get; }
    public static string WrapListPatternSettingDescription { get; }
    public static string WrapSwitchExpressionSettingDescription { get; }
    public static string WrapTernaryExpressionSettingDescription { get; }
    public static string WrapVerbatimInterpolatedStringsSettingDescription { get; }
    public static string ThisQualifierSettingsKey_Description { get; }
    public static string ThisQualifierSettingsKey_InstanceMembersQualifyMembers_SettingsEntryDescription { get; }
    public static string SettingsEntry_Description_InStatement { get; }
    public static string SettingsEntryDescription_Parentheses { get; }
    public static string SettingsEntryDescription_Parentheses_CheckedUnchecked { get; }
    public static string CSharpFormatSettingsKey_SpaceBeforeColonInUse_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_SpaceAfterColonInCase_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_PlaceElseOnNewLine_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_PlaceWhileOnNewLine_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_PlaceCatchOnNewLine_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_PlaceFinallyOnNewLine_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_RemoveBlankLinesNearBracesInDeclaration_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_RemoveBlankLinesNearBracesInCode_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_BlankLinesBetweenUsingGroups_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_BlankLinesAfterUsingList_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_BlankLinesBeforeCase_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_BlankLinesAfterCase_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_BlankLinesAroundMultilineCaseSection_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_BlankLinesAroundBlockCaseSection_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_AlignMultilineForStmt_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeInvocationRpar_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeInvocationLpar_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapAfterInvocationLpar_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeDeclarationRpar_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeDeclarationLpar_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapAfterDeclarationLpar_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeExtendsColon_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapAfterDotInMethodCalls_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeComma_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeEq_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapAroundEq_SettingsEntryDescription { get; }
    public static string AlwaysIfMultiLine { get; }
    public static string StronglyPrefer { get; }
    public static string DefaultWrap { get; }
    public static string AvoidIfPossible { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeTernaryOpsigns_SettingsEntryDescription { get; }
    public static string SettingsEntryDescription_ForceChopCompoundConditionInStatement { get; }
    public static string CSharpFormatSettingsKey_PlaceLinqInotOnNewLine_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapForStmtHeaderStyle_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_WrapBeforeArrowWithExpressions_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_PlaceSimpleCaseStatementOnSameLine_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_TreatCaseStatementWithBreakAsSimple_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_SpaceBeforeForSemicolon_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_SpaceAfterForSemicolon_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_SpecialElseIfTreatment_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_IndentCaseFromSwitch_SettingsEntry { get; }
    public static string CSharpFormatSettingsKey_IndentBreakFromCase_SettingsEntry { get; }
    public static string SettingsEntryDescription_IndentNestetStatements { get; }
    public static string CSharpFormatSettingsKey_SimpleCaseStatementStyle_SettingsEntryDescription { get; }
    public static string SettingsEntryDescription_BracesInStatement { get; }
    public static string CSharpFormatSettingsKey_RedundantThisQualifierStyle_SettingsEntryDescription { get; }
    public static string CFormatting_Text { get; }
    public static string CIndenting_Text { get; }
    public static string CWrapping_Text { get; }
    public static string FileIsNotIncludedIntoCompilation_Text { get; }
    public static string AddTrailingCommaToConformToCodeStyle_Text { get; }
    public static string RemoveTrailingCommaToConformToCodeStyle_Text { get; }
    public static string UseSeparateDeclarationExpressions_Text { get; }
    public static string UsePositionalDeconstructionPattern_Text { get; }
    public static string UseSingleDeconstructionDeclaration_Text { get; }
    public static string UseVarDeconstructionPattern_Text { get; }
    public static string UseExplicitDiscardDeclaration_Text { get; }
    public static string UseExplicitVar_Pattern_Text { get; }
    public static string RemoveRedundantVarKeyword_Text { get; }
    public static string AddBraces_Description_Text { get; }
    public static string FileLayoutDesigner_Elements_HandlesEvent_MatchBy_SubscriptionOrSignature_Text { get; }
    public static string CustomLayout_Description_Text { get; }
    public static string DefaultLayoutUsingRegions_Description_Text { get; }
    public static string DefaultLayoutWithoutRegions_Description_Text { get; }
    public static string DoNotChange_Description_Text { get; }
    public static string DoNotUse_Description_Text { get; }
    public static string ForFields_Description_Text { get; }
    public static string ForFieldsInThisClass_Description_Text { get; }
    public static string ForThisClassMembers_Description_Text { get; }
    public static string RemoveBraces_Description_Text { get; }
    public static string FileLayoutDesigner_Elements_HandlesEvent_MatchBy_Signature_Text { get; }
    public static string FileLayoutDesigner_Elements_HandlesEvent_MatchBy_Subscription_Text { get; }
    public static string UseVar_Description_Text { get; }
    public static string UseVarWhenEvident_Description_Text { get; }
    public static string UseAlways_Description_Text { get; }
    public static string UseBracesForMultiline_Description_Text { get; }
    public static string UseExplicitType_Description_Text { get; }
    public static string Namespace_Text { get; }
    public static string RecordStruct_Text { get; }
    public static string Record_Text { get; }
    public static string Class_Text { get; }
    public static string Interface_Text { get; }
    public static string Struct_Text { get; }
    public static string Delegate_Text { get; }
    public static string Enum_Text { get; }
    public static string Accessor_Text { get; }
    public static string Destructor_Text { get; }
    public static string Method_Text { get; }
    public static string Constructor_Text { get; }
    public static string CheckedOperator_Text { get; }
    public static string Operator_Text { get; }
    public static string LocalFunction_Text { get; }
    public static string FunctionPointer_Text { get; }
    public static string Field_Text { get; }
    public static string Constant_Text { get; }
    public static string EnumMember_Text { get; }
    public static string Indexer_Text { get; }
    public static string IndexedProperty_Text { get; }
    public static string RangeVariable_Text { get; }
    public static string Property_Text { get; }
    public static string Event_Text { get; }
    public static string Parameter_Text { get; }
    public static string LocalConstant_Text { get; }
    public static string LocalVariable_Text { get; }
    public static string Label_Text { get; }
    public static string TypeParameter_Text { get; }
    public static string AnonymousFunction_Text { get; }
    public static string Alias_Text { get; }
    public static string Type_Text { get; }
    public static string CommaExpected_Text { get; }
    public static string LambdaArrowExpected_Text { get; }
    public static string PatternIsMissing_Text { get; }
    public static string EqualsExpected_Text { get; }
    public static string AliasKeywordExpected_Text { get; }
    public static string ExternAliasDirectivesAreOnlyAllowed_Text { get; }
    public static string UsingDirectivesAreOnlyAllowedInTheBeginningOfFile_Text { get; }
    public static string UsingDirectivesAreOnlyAllowedInTheBeginningOfNamespace_Text { get; }
    public static string EndifDirectiveExpected_Text { get; }
    public static string ArrayCreationMustHaveArraySizeOrArray_Text { get; }
    public static string DimensionExpressionMissing_Text { get; }
    public static string EnableDisableRestoreExpected_Text { get; }
    public static string ExpressionExpected_Text { get; }
    public static string IncorrectPrimaryExpression_Text { get; }
    public static string InitializerExpected_Text { get; }
    public static string Missing_Text { get; }
    public static string NamespaceBodyBlockExpected_Text { get; }
    public static string GlobalAttributesAreOnlyAllowedInThe_Text { get; }
    public static string ExternAliasDirectivesAreOnlyAllowed2_Text { get; }
    public static string ParserExpectedTwoSymbols_Text { get; }
    public static string ParserExpectedSymbol_Text { get; }
    public static string ParserUnexpectedToken_Text { get; }
    public static string ParserStatementSymbol_Text { get; }
    public static string ParserExpressionSymbol_Text { get; }
    public static string ParserTupleExpressionSymbol_Text { get; }
    public static string ParserPatternSymbol_Text { get; }
    public static string ParserUsingDirectiveSymbol_Text { get; }
    public static string ParserTypeMemberDeclarationSymbol_Text { get; }
    public static string ParserTypeDeclarationSymbol_Text { get; }
    public static string ParserTypeDeclarationBodySymbol_Text { get; }
    public static string ParserEnumDeclarationBodySymbol_Text { get; }
    public static string ParserIdentifierSymbol_Text { get; }
    public static string ParserUsageOfPredefinedTypeSymbol_Text { get; }
    public static string ParserUsageOfTypeSymbol_Text { get; }
    public static string ParserUsageOfUserDefinedTypeSymbol_Text { get; }
    public static string ParserConditionalSymbol_Text { get; }
    public static string ParserConditionalSymbolName_Text { get; }
    public static string ParserLineNumberSymbol_Text { get; }
    public static string ParserTypeParameterConstraintSymbol_Text { get; }
    public static string ParserPointerTypeSymbol_Text { get; }
    public static string ParserConstructorDeclarationSymbol_Text { get; }
    public static string ParserInterpolationStringExpressionSymbol_Text { get; }
    public static string ParserInitializerSymbol_Text { get; }
    public static string ParserValidOperatorSignSymbol_Text { get; }
    public static string ParserFunctionBodySymbol_Text { get; }
    public static string ParserExpressionBodyClauseSymbol_Text { get; }
    public static string ParserMethodBodySymbol_Text { get; }
    public static string ParserExpressionOrInitializerSymbol_Text { get; }
    public static string ParserVariableDesignationSymbol_Text { get; }
    public static string ParserDeclarationOrExpressionListSymbol_Text { get; }
    public static string ParserLambdaSignatureSymbol_Text { get; }
    public static string ParserPropertyAssignmentSymbol_Text { get; }
    public static string ParserParameterModifierSymbol_Text { get; }
    public static string ParserGroupClauseSymbol_Text { get; }
    public static string ParserSelectClauseSymbol_Text { get; }
    public static string ParserAttributeSectionSymbol_Text { get; }
    public static string ParserModifierSymbol_Text { get; }
    public static string ParserParameterDeclarationSymbol_Text { get; }
    public static string ParserSwitchCaseLabelSymbol_Text { get; }
    public static string ParserSwitchGoverningExpressionSymbol_Text { get; }
    public static string ParserParameterModifierSymbol2_Text { get; }
    public static string ParserForeachVariableDeclarationSymbol_Text { get; }
    public static string ParserArgumentSymbol_Text { get; }
    public static string WarningsAnnotationsExpected_Text { get; }
    public static string SameClass_Text { get; }
    public static string BaseClass_Text { get; }
    public static string CSharpPatternStyleSettingsSettingDescription { get; }
    public static string NullCheckingPatternStyle { get; }
    public static string UseEmptyRecursivePattern_Text { get; }
    public static string UseNotNullPattern_Text { get; }
    public static string EmptyRecursivePattern_Text { get; }
    public static string NotNullPattern_Text { get; }
    public static string InAnonymousType_Text { get; }
    public static string InAnonymousTypeBrackets_Text { get; }
    public static string InconsistentBodyStyleUseStatementBody_Text { get; }
    public static string InconsistentBodyStyleUseExpressionBodiedIndexer_Text { get; }
    public static string InconsistentBodyStyleUseExpressionBodiedProperty_Text { get; }
    public static string InconsistentBodyStyleUseExpressionBodiedGetter_Text { get; }
    public static string InconsistentBodyStyleUseExpressionBody_Text { get; }
    public static string EntityFrameworkSettingsDescription { get; }
    public static string EntityFrameworkAnalysisSettingsEntryDescription { get; }
    public static string DumpDbContextsStructureText { get; }
    public static string CSharpFormatSettingsKey_PreferToWrapBeforeFirstMethodCall_SettingsEntryDescription { get; }
    public static string CSharpFormatSettingsKey_PreferToWrapAfterPropertiesAndFields_SettingsEntryDescription { get; }
    public static string AlignMultilineCommentsWithAsterisksSettingsDescription { get; }
    public static string Align_Text { get; }
    public static string IndentToPreviousLine_Text { get; }
    public static string HowToIndentRawStringLiteralsSettingsDescription { get; }
    public static string EntityFrameworkAnalysisSettingsDisabledDbContextsDescription { get; }
    public static string TypeDoesNotMatchExpectedTypeMessage { get; }
    public static string EntityFrameworkQueryAnalysisModeSettingsEntryDescription { get; }
    public static string EntityFrameworkEntityAdornment_Settings_Enabled_Description { get; }
    public static string EntityFrameworkModelAnalysis_Settings_Enabled_Description { get; }
    public static string Presenter_ITopLevelEntryPoint_Text { get; }
    public static string Presenter_IAnonymousMethod_Text { get; }
    public static string Presenter_INamespace_Root_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_AccessorDeclarationSettingDescription();
    public static string get_AmbiguousUserDefinedConversions_Text();
    public static string get_ExpectedTupleElementName__Text();
    public static string get_FileLayoutDesigner_Elements_Body_Type_Block_Text();
    public static string get_FileLayoutDesigner_Elements_Body_Type_Expression_Text();
    public static string get_FileLayoutDesigner_Elements_Direction_Ascending_Text();
    public static string get_FileLayoutDesigner_Elements_Direction_Descending_Text();
    public static string get_FileLayoutDesigner_Elements_DisplayName_Text();
    public static string get_FileLayoutDesigner_Elements_Pattern_RemoveRegions_All_Text();
    public static string get_AsyncMethod_PresentableName_Text();
    public static string get_AsyncTaskMethod_PresentableName_Text();
    public static string get_CaseBlockBracesSettingDescription();
    public static string get_AdditiveOperatorsSettingDescription();
    public static string get_AddusingDirectivesOnOptimizationSettingDescription();
    public static string get_AddusingDirectiveToDeepestScopeSettingDescription();
    public static string get_AfterAttributesSettingDescription();
    public static string get_AfterBaseTypesListColonSettingDescription();
    public static string get_AfterCommaSettingDescription();
    public static string get_AfterFileHeaderCommentSettingDescription();
    public static string get_AfterFileScopedNamespaceDirectiveSettingDescription();
    public static string get_AfterMultilineStatementsSettingDescription();
    public static string get_AfterOperatorKeywordSettingDescription();
    public static string get_AfterOtherColonsSettingDescription();
    public static string get_AfterQuestSettingDescription();
    public static string get_AfterColonSettingDescription();
    public static string get_AfterStatementsWithChildBlocksSettingDescription();
    public static string get_AfterStatementsWithControlTransferSettingDescription();
    public static string get_AfterTypeCastParenthesesSettingDescription();
    public static string get_AfterTypeParameterConstraintColonSettingDescription();
    public static string get_AllowCommentAfterSettingDescription();
    public static string get_AllowConstructorInitializerOnTheSameLineSettingDescription();
    public static string get_AllowPrimaryConstructorInitializerOnTheSameLineSettingDescription();
    public static string get_AllowglobalPrefixUseSettingDescription();
    public static string get_AllowTypeConstraintsOnTheSameLineSettingDescription();
    public static string get_AnonymousMethodBodySettingDescription();
    public static string get_AnonymousMethodsDelegatesAndLambdasSettingDescription();
    public static string get_ApplyStyleHeuristicsSettingDescription();
    public static string get_ApplySyntaxStyleOnCodeCompletionSettingDescription();
    public static string get_AroundAutoAbstractPropertyEventSettingDescription();
    public static string get_AroundDotSettingDescription();
    public static string get_AroundFieldSettingDescription();
    public static string get_AroundInNamespaceAliasDirectiveSettingDescription();
    public static string get_AroundLambdaArrowSettingDescription();
    public static string get_AroundLocalFunctionSettingDescription();
    public static string get_AroundMethodSettingDescription();
    public static string get_AroundNamespaceSettingDescription();
    public static string get_AroundOperandsOfTheFollowingOperationsSettingDescription();
    public static string get_AroundPropertyEventAccessorSettingDescription();
    public static string get_AroundPropertyEventSettingDescription();
    public static string get_AroundRegionSettingDescription();
    public static string get_AroundSingleLineAutoAbstractPropertyEventSettingDescription();
    public static string get_AroundSingleLineFieldSettingDescription();
    public static string get_AroundSingleLineLocalFunctionSettingDescription();
    public static string get_AroundSingleLineMethodSettingDescription();
    public static string get_AroundSingleLinePropertyEventAccessorSettingDescription();
    public static string get_AroundSingleLinePropertyEventSettingDescription();
    public static string get_AroundSingleLineTypeSettingDescription();
    public static string get_AroundTypeSettingDescription();
    public static string get_ArrayObjectAndCollectionInitializerSettingDescription();
    public static string get_AssignmentOperatorsSettingDescription();
    public static string get_BeforeAfterAndSettingDescription();
    public static string get_BeforeANewLineInMultilineListsSettingDescription();
    public static string get_BeforeArrayAccessBracketsSettingDescription();
    public static string get_BeforeArrayRankBracketsSettingDescription();
    public static string get_BeforeBaseTypesListColonSettingDescription();
    public static string get_BeforeCommaSettingDescription();
    public static string get_BeforeEndOfLineCommentSettingDescription();
    public static string get_BeforeMultilineStatementsSettingDescription();
    public static string get_BeforeNullableMarkSettingDescription();
    public static string get_BeforeOtherColonsSettingDescription();
    public static string get_BeforeSemicolonSettingDescription();
    public static string get_BeforeQuestSettingDescription();
    public static string get_BeforeColonSettingDescription();
    public static string get_BeforeSingleLineAccessorsBlockSettingDescription();
    public static string get_BeforeSingleLineCommentSettingDescription();
    public static string get_BeforeStatementsWithChildBlocksSettingDescription();
    public static string get_BeforeStatementsWithControlTransferSettingDescription();
    public static string get_BeforeTypeArgumentListAngleSettingDescription();
    public static string get_BeforeTypeParameterConstraintColonSettingDescription();
    public static string get_BeforeTypeParameterListAngleSettingDescription();
    public static string get_BeforeUnsafePointerDeclarationSettingDescription();
    public static string get_BetweenAccessorsInSingleLinePropertyEventSettingDescription();
    public static string get_BetweenAttributeSectionsSettingDescription();
    public static string get_BetweenKeywordAndExpressionSettingDescription();
    public static string get_BetweenKeywordAndTypeSettingDescription();
    public static string get_BinaryExpressionsSettingDescription();
    public static string get_BinaryPatternsSettingDescription();
    public static string get_BitwiseOperatorsSettingDescription();
    public static string get_BreakLineInABlockWithASingleStatementSettingDescription();
    public static string get_BreakLineInSingleEmbeddedStatementSettingDescription();
    public static string get_CallArgumentsBySettingDescription();
    public static string get_CallArgumentsSettingDescription();
    public static string get_CatchVariable_PresentableName_Text();
    public static string get_CFileLayoutPatternSettingDescription();
    public static string get_ChainedMethodCallsSettingDescription();
    public static string get_CLanguageLevelSettingDescription();
    public static string get_CLanguageSettingsSettingDescription();
    public static string get_Class_PresentableName_Text();
    public static string get_CMemberOrderPatternSettingDescription();
    public static string get_CNamespaceImportSettingDescription();
    public static string get_CNamingSettingsSettingDescription();
    public static string get_CodeFormattingInCSettingDescription();
    public static string get_CollectionExpressionElementExpected_Text();
    public static string get_CollectionExpressionExpected_Text();
    public static string get_ConstructorsAndDestructorsSettingDescription();
    public static string get_CSharpVarKeywordUsageSettingsSettingDescription();
    public static string get_CustomPatternUseNullForDefaultPatternSettingDescription();
    public static string get_FileLayoutDesigner_Elements_Pattern_RemoveRegions_ExceptGenerated_Text();
    public static string get_FileLayoutDesigner_Elements_Is_Text();
    public static string get_FileLayoutDesigner_Elements_ImplementsInterface_Immediate_Text();
    public static string get_FileLayoutDesigner_Elements_Name_IgnoreCase_Text();
    public static string get_KeepNonTrivialUsingAliasesSettingDescription();
    public static string get_LambdaParameter_PresentableName_Text();
    public static string get_PrimaryConstructor_Text();
    public static string get_PrimaryCtorParameter_PresentableName_Text();
    public static string get_RecordPositionalParameter_PresentableName_Text();
    public static string get_LocalFunction_PresentableName_Text();
    public static string get_AsyncLocalFunction_PresentableName_Text();
    public static string get_AsyncTaskLocalFunction_PresentableName_Text();
    public static string get_FileLayoutDesigner_Elements_Pattern_RemoveRegions_None_Text();
    public static string get_FileLayoutDesigner_Elements_HandlesEvent_MatchBy_Text();
    public static string get_FileLayoutDesigner_Elements_Name_Text();
    public static string get_NoParameters_Text();
    public static string get_FileLayoutDesigner_Elements_Priority_Text();
    public static string get_FileLayoutDesigner_Elements_ParameterName_Text();
    public static string get_Record_PresentableName_Text();
    public static string get_FileLayoutDesigner_Elements_Pattern_RemoveRegions_Text();
    public static string get_FileLayoutDesigner_Elements_Patterns_StaticFieldReorderingPolicy_Relaxed_Text();
    public static string get_RemoveUnusedOnlyUsingAliasesSettingDescription();
    public static string get_DontForceSingleLinesSettingDescription();
    public static string get_DontIndentCommentsStartedAtFirstColumnSettingDescription();
    public static string get_DontRemoveExtraBlankLinesSettingDescription();
    public static string get_ElsewhereSettingDescription();
    public static string get_EmptyBracesFormattingSettingDescription();
    public static string get_EndCommentsSettingDescription();
    public static string get_EqualityOperatorsSettingDescription();
    public static string get_EvenWhenOperationsOfTheSameTypeAreNestedSettingDescription();
    public static string get_ExpressionsInitializersSwitchExpressionsPatternsSettingDescription();
    public static string get_FieldsAndConstantsSettingDescription();
    public static string get_FileLayoutPatternSettingDescription();
    public static string get_ForBuiltInTypesSettingDescription();
    public static string get_ForSimpleTypesSettingDescription();
    public static string get_GeneratorModeSettingDescription();
    public static string get_IncludePrefixCommentsInIndentsSettingDescription();
    public static string get_IndentBracesInsideStatementConditionsSettingDescription();
    public static string get_IndentIfElseElifEndifSettingDescription();
    public static string get_IndentInsideNamespaceDeclarationSettingDescription();
    public static string get_IndentMethodCallsParenthesisSettingDescription();
    public static string get_IndentMethodDeclarationsParenthesisSettingDescription();
    public static string get_IndentPrimaryConstructorDeclarationsParenthesisSettingDescription();
    public static string get_IndentOtherParenthesisAndBracketsSettingDescription();
    public static string get_IndentOtherPreprocessorDirectivesSettingDescription();
    public static string get_IndentRegionEndregionSettingDescription();
    public static string get_IndentStatementIfWhileForEtcParenthesisSettingDescription();
    public static string get_IndentTypeArgumentsAnglesSettingDescription();
    public static string get_IndentTypeConstraintsSettingDescription();
    public static string get_IndentTypeParametersAnglesSettingDescription();
    public static string get_InLocalsMembersAndParametersPreferSettingDescription();
    public static string get_InMemberAccessExpressionsPreferSettingDescription();
    public static string get_ApplyToNativeIntegerDescription();
    public static string get_InsideNamespaceSettingDescription();
    public static string get_InsideRegionSettingDescription();
    public static string get_InsideTypeSettingDescription();
    public static string get_InvocationsOfTheSameMethodSettingDescription();
    public static string get_JoinOrSeparateAttributesInSectionSettingDescription();
    public static string get_KeepExistingArrangementOfAttributesSettingDescription();
    public static string get_KeepExistingArrangementOfDeclarationBlocksSettingDescription();
    public static string get_KeepExistingArrangementOfEmbeddedBlocksSettingDescription();
    public static string get_KeepExistingArrangementOfEmbeddedStatementsSettingDescription();
    public static string get_KeepExistingArrangementOfEnumerationSettingDescription();
    public static string get_KeepExistingArrangementOfExpressionBodiedMembersSettingDescription();
    public static string get_KeepExistingArrangementOfInitializersSettingDescription();
    public static string get_KeepExistingArrangementOfParenthesisInDeclarationSettingDescription();
    public static string get_KeepExistingArrangementOfParenthesisInInvocationSettingDescription();
    public static string get_KeepExistingArrangementOfPropertyPatternsSettingDescription();
    public static string get_KeepExistingArrangementOfListPatternsSettingDescription();
    public static string get_KeepExistingArrangementOfSwitchExpressionsSettingDescription();
    public static string get_KeepExistingAttributePlacementSettingDescription();
    public static string get_KeepExistingLineBreaksSettingDescription();
    public static string get_KeepMaxBlankLinesInCodeSettingDescription();
    public static string get_KeepMaxBlankLinesInDeclarationsSettingDescription();
    public static string get_KeepusingDirectivesOnOptimizationSettingDescription();
    public static string get_LambdaAndDelegateAnonymousMethodDeclarationSettingDescription();
    public static string get_LayoutTypeSettingDescription();
    public static string get_LINQQuerySettingDescription();
    public static string get_ListOfBaseClassesAndInterfacesSettingDescription();
    public static string get_LiteralValuesSettingDescription();
    public static string get_LocalFunctionsSettingDescription();
    public static string get_LogicalNotOperatorSettingDescription();
    public static string get_LogicalOperatorsSettingDescription();
    public static string get_MaxArrayInitializerElementsOnASingleLineSettingDescription();
    public static string get_MaxEnumerationMembersOnASingleLineSettingDescription();
    public static string get_MaxFormalParametersOnASingleLineSettingDescription();
    public static string get_MaxPrimaryConstructorParametersOnASingleLineSettingDescription();
    public static string get_MaxInvocationArgumentsOnASingleLineSettingDescription();
    public static string get_MaxObjectAndCollectionInitializerElementsOnASingleLineSettingDescription();
    public static string get_MaxPatternPropertiesOnASingleLineSettingDescription();
    public static string get_MembersToQualifySettingDescription();
    public static string get_MethodCallEmptyParenthesesSettingDescription();
    public static string get_MethodCallParenthesesSettingDescription();
    public static string get_MethodDeclarationEmptyParenthesesSettingDescription();
    public static string get_MethodDeclarationParenthesesSettingDescription();
    public static string get_MethodDeclarationSettingDescription();
    public static string get_MethodParametersSettingDescription();
    public static string get_MethodsAndOperatorsSettingDescription();
    public static string get_ModifiersOrderSettingDescription();
    public static string get_MultilineMethodSignatureSettingDescription();
    public static string get_MultipleDeclarationsSettingDescription();
    public static string get_MultiplicativeOperatorsSettingDescription();
    public static string get_NamedExpressionsVariablesPropertiesMethodsEtcSettingDescription();
    public static string get_NamespacesSettingDescription();
    public static string get_NamespacesThatShouldNotBeRemovedFromFullyQualifiedTypeNamesSettingDescription();
    public static string get_NestedTernaryExpressionStyleSettingDescription();
    public static string get_NestedTernaryOperatorsSettingDescription();
    public static string get_NullCoalescingOperatorSettingDescription();
    public static string get_OtherAssignmentsAndInitializersSettingDescription();
    public static string get_OtherExpressionsSettingDescription();
    public static string get_OtherSettingDescription();
    public static string get_OutdentBinaryOperatorsSettingDescription();
    public static string get_OutdentBinaryPatternsSettingDescription();
    public static string get_OutdentCommasSettingDescription();
    public static string get_OutdentDotsInChainedMethodCallsSettingDescription();
    public static string get_OutdentStatementLabelsSettingDescription();
    public static string get_OutdentTernaryExpressionsSettingDescription();
    public static string get_ParenthesesSettingDescription();
    public static string get_ParserCollectionExpressionElementSymbol_Text();
    public static string get_PlaceABlockWithASingleSimpleStatementOnTheSameLineSettingDescription();
    public static string get_PlaceAbstractAutoPropertyIndexerEventDeclarationOnSingleLineSettingDescription();
    public static string get_PlaceAccessorAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceAttributeOnSeparateLineIfItIsLongerThanSettingDescription();
    public static string get_PlaceAttributeSectionListOnSeparateLineIfItIsLongerThanSettingDescription();
    public static string get_PlaceCommentsAtFirstColumnWhenCommentingOutCodeSettingDescription();
    public static string get_PlaceFieldAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceItOnSingleLineEvenWhenItHasAttributesOnAccessorsSettingDescription();
    public static string get_PlaceMethodAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceMethodExpressionBodyOnTheSameLineSettingDescription();
    public static string get_PlaceMultilineAccessorAttributeOnTheSameLineSettingDescription();
    public static string get_PlacePropertyAccessorExpressionBodyOnTheSameLineSettingDescription();
    public static string get_PlacePropertyExpressionBodyOnTheSameLineSettingDescription();
    public static string get_PlacePropertyIndexerEventAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceRecordFieldAttributeOnTheSameLine();
    public static string get_PlaceSimpleAccessorOnSingleLineSettingDescription();
    public static string get_PlaceSimpleAnonymousMethodOnSingleLineSettingDescription();
    public static string get_PlaceSimpleArrayObjectAndCollectionOnSingleLineSettingDescription();
    public static string get_PlaceSimpleEmbeddedStatementOnTheSameLineSettingDescription();
    public static string get_PlaceSimpleEnumerationOnSingleLineSettingDescription();
    public static string get_PlaceSimpleMethodOnSingleLineSettingDescription();
    public static string get_PlaceSimplePropertyIndexerEventDeclarationOnSingleLineSettingDescription();
    public static string get_PlaceSimplePropertyPatternOnSingleLineSettingDescription();
    public static string get_PlaceSimpleListPatternOnSingleLineSettingDescription();
    public static string get_PlaceSimpleSwitchExpressionOnSingleLineSettingDescription();
    public static string get_PlaceSinglelineAccessorAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceSinglelineMethodAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceSystemAndWindowsNamespacesFirstWhenSortingusingDirectivesSettingDescription();
    public static string get_PlaceTypeAttributeOnTheSameLineSettingDescription();
    public static string get_PreferExplicitImplicitInternalModifierForTypesSettingDescription();
    public static string get_PreferExplicitImplicitPrivateModifierForTypeMembersSettingDescription();
    public static string get_PreferExtensionMethodsImportWithusingStaticDirectiveSettingDescription();
    public static string get_PreferFullyQualifiedReferencesSettingDescription();
    public static string get_PreferFullyQualifiedUsingNameAtNestedScopeSettingDescription();
    public static string get_PreferRoslynVisualStudioLogicForTypeEvidenceSettingDescription();
    public static string get_PreferSeparateDeclarationsForDeconstructedVariablesSettingDescription();
    public static string get_PreferWrapBeforeFirstConstraintSettingDescription();
    public static string get_PreferWrapBeforeMultilineLINQExpressionsSettingDescription();
    public static string get_PreferWrapBeforeOperatorInBinaryExpressionSettingDescription();
    public static string get_PreferWrapBeforeOperatorInBinaryPatternSettingDescription();
    public static string get_PreferWrapBeforeTypeParametersOpeningAngleSettingDescription();
    public static string get_PropertiesAndEventsSettingDescription();
    public static string get_PropertiesIndexersAndEventsSettingDescription();
    public static string get_PropertyDeclarationSettingDescription();
    public static string get_PropertyPatternsSettingDescription();
    public static string get_ListPatternsSettingDescription();
    public static string get_QualifyMembersDeclaredInSettingDescription();
    public static string get_QualifyWithTheNameOfSettingDescription();
    public static string get_RelationalOperatorsSettingDescription();
    public static string get_RemoveRedundantParenthesesSettingDescription();
    public static string get_RemoveRedundantSettingDescription();
    public static string get_RevertToOldFormattingEngineSettingDescription();
    public static string get_ShiftOperatorsSettingDescription();
    public static string get_SimpleMethodsOperatorsDelegatesSettingDescription();
    public static string get_SimpleSwitchSectionsSettingDescription();
    public static string get_SkipSingleArgumentsSettingDescription();
    public static string get_FileLayoutDesigner_Elements_SortBy_Text();
    public static string get_FileLayoutDesigner_Elements_Direction_Text();
    public static string get_SortusingDirectivesSettingDescription();
    public static string get_SpaceBetweenEmptyBracesSettingDescription();
    public static string get_StatementConditionsInsideParenthesisSettingDescription();
    public static string get_FileLayoutDesigner_Elements_Patterns_StaticFieldReorderingPolicy_Text();
    public static string get_StaticMemberQualifierSettingDescription();
    public static string get_FileLayoutDesigner_Elements_Patterns_StaticFieldReorderingPolicy_Strict_Text();
    public static string get_StringLiteralValuesSettingDescription();
    public static string get_SwitchExpressionsSettingDescription();
    public static string get_SyntaxStyleInCSettingDescription();
    public static string get_FileLayoutDesigner_Elements_HasAttribute_Target_Text();
    public static string get_TupleComponentsSettingDescription();
    public static string get_TupleComponentShouldBeAddedInOrder_Text();
    public static string get_TupleComponentShouldBeRemovedInOrder_Text();
    public static string get_TupleComponent_DoesnTMatchExpectedComponent_Text();
    public static string get_TupleComponent_ShouldBeRemovedInOrder_Text();
    public static string get_TupleElementName_DoesnTMatchExpected_Text();
    public static string get_TupleElementName_ShouldBeRemovedInOrder_Text();
    public static string get_TypeAndNamespaceDeclarationSettingDescription();
    public static string get_TypeArgumentAnglesSettingDescription();
    public static string get_TypeCastParenthesesSettingDescription();
    public static string get_TypeParameterAnglesSettingDescription();
    public static string get_TypeParameterConstraintsSettingDescription();
    public static string get_TypeParametersListSettingDescription();
    public static string get_FileLayoutDesigner_Elements_Body_Type_Text();
    public static string get_TypeParameter_ShouldBeRemovedInOrder_Text();
    public static string get_Type_DoesnTMatchExpectedType__Text();
    public static string get_UnaryMinusOperatorSettingDescription();
    public static string get_UnaryPlusOperatorSettingDescription();
    public static string get_FileLayoutDesigner_Elements_Patterns_StaticFieldReorderingPolicy_Unrestricted_Text();
    public static string get_UnsafeAddressofOperatorSettingDescription();
    public static string get_UnsafeArrowOperatorSettingDescription();
    public static string get_UnsafeAsteriskOperatorSettingDescription();
    public static string get_UseContinuousLineIndentInsideExpressionBracesSettingDescription();
    public static string get_UseContinuousLineIndentInsideParenthesisSettingDescription();
    public static string get_UseUsingAliasDirectiveToResolveConflictsSettingDescription();
    public static string get_UsevarKeywordForDiscardsSettingDescription();
    public static string get_VariablesAndLocalConstantsSettingDescription();
    public static string get_WhenCreatedTypeIsEvidentFromUsageSettingDescription();
    public static string get_WhenCreatedTypeIsNotEvidentFromUsageSettingDescription();
    public static string get_WhenTheLastElementIsNotFollowedByANewLineSettingDescription();
    public static string get_WhenTheOperationsFromTheFollowingGroupsAreNestedSettingDescription();
    public static string get_WhenTypeIsEvidentFromUsageSettingDescription();
    public static string get_WhenTypeIsNotEvidentFromUsageSettingDescription();
    public static string get_WithinArrayAccessBracketsSettingDescription();
    public static string get_WithinListPatternBracketsSettingDescription();
    public static string get_WithinSlicePatternSettingDescription();
    public static string get_WithinArrayRankBracketsSettingDescription();
    public static string get_WithinArrayRankEmptyBracketsSettingDescription();
    public static string get_WithinAttributeBracketsSettingDescription();
    public static string get_WithinSingleLineAccessorSettingDescription();
    public static string get_WithinSingleLineAnonymousMethodSettingDescription();
    public static string get_WithinSingleLineExpressionBracesSettingDescription();
    public static string get_WithinSingleLineMethodSettingDescription();
    public static string get_WrapArrayInitializerSettingDescription();
    public static string get_WrapChainedBinaryExpressionsSettingDescription();
    public static string get_WrapChainedMethodCallsSettingDescription();
    public static string get_WrapCollectionExpressionSettingDescription();
    public static string get_WrapComplexBinaryPatternsSettingDescription();
    public static string get_WrapEnumerationDeclarationSettingDescription();
    public static string get_WrapExtendsImplementsListSettingDescription();
    public static string get_WrapFormalParametersSettingDescription();
    public static string get_WrapPrimaryConstructorParametersSettingDescription();
    public static string get_WrapInvocationArgumentsSettingDescription();
    public static string get_WrapLINQExpressionsSettingDescription();
    public static string get_WrapMultipleDeclarationSettingDescription();
    public static string get_WrapMultipleTypeParameterConstraintsSettingDescription();
    public static string get_WrapObjectAndCollectionInitializerSettingDescription();
    public static string get_WrapPropertyPatternSettingDescription();
    public static string get_WrapListPatternSettingDescription();
    public static string get_WrapSwitchExpressionSettingDescription();
    public static string get_WrapTernaryExpressionSettingDescription();
    public static string get_WrapVerbatimInterpolatedStringsSettingDescription();
    public static string get_ThisQualifierSettingsKey_Description();
    public static string get_ThisQualifierSettingsKey_InstanceMembersQualifyMembers_SettingsEntryDescription();
    public static string get_SettingsEntry_Description_InStatement();
    public static string get_SettingsEntryDescription_Parentheses();
    public static string get_SettingsEntryDescription_Parentheses_CheckedUnchecked();
    public static string get_CSharpFormatSettingsKey_SpaceBeforeColonInUse_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_SpaceAfterColonInCase_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_PlaceElseOnNewLine_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_PlaceWhileOnNewLine_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_PlaceCatchOnNewLine_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_PlaceFinallyOnNewLine_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_RemoveBlankLinesNearBracesInDeclaration_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_RemoveBlankLinesNearBracesInCode_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_BlankLinesBetweenUsingGroups_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_BlankLinesAfterUsingList_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_BlankLinesBeforeCase_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_BlankLinesAfterCase_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_BlankLinesAroundMultilineCaseSection_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_BlankLinesAroundBlockCaseSection_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_AlignMultilineForStmt_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapBeforeInvocationRpar_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapBeforeInvocationLpar_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapAfterInvocationLpar_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapBeforeDeclarationRpar_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapBeforeDeclarationLpar_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapAfterDeclarationLpar_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapBeforeExtendsColon_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapAfterDotInMethodCalls_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapBeforeComma_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapBeforeEq_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapAroundEq_SettingsEntryDescription();
    public static string get_AlwaysIfMultiLine();
    public static string get_StronglyPrefer();
    public static string get_DefaultWrap();
    public static string get_AvoidIfPossible();
    public static string get_CSharpFormatSettingsKey_WrapBeforeTernaryOpsigns_SettingsEntryDescription();
    public static string get_SettingsEntryDescription_ForceChopCompoundConditionInStatement();
    public static string get_CSharpFormatSettingsKey_PlaceLinqInotOnNewLine_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapForStmtHeaderStyle_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_WrapBeforeArrowWithExpressions_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_PlaceSimpleCaseStatementOnSameLine_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_TreatCaseStatementWithBreakAsSimple_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_SpaceBeforeForSemicolon_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_SpaceAfterForSemicolon_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_SpecialElseIfTreatment_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_IndentCaseFromSwitch_SettingsEntry();
    public static string get_CSharpFormatSettingsKey_IndentBreakFromCase_SettingsEntry();
    public static string get_SettingsEntryDescription_IndentNestetStatements();
    public static string get_CSharpFormatSettingsKey_SimpleCaseStatementStyle_SettingsEntryDescription();
    public static string get_SettingsEntryDescription_BracesInStatement();
    public static string get_CSharpFormatSettingsKey_RedundantThisQualifierStyle_SettingsEntryDescription();
    public static string get_CFormatting_Text();
    public static string get_CIndenting_Text();
    public static string get_CWrapping_Text();
    public static string get_FileIsNotIncludedIntoCompilation_Text();
    public static string get_AddTrailingCommaToConformToCodeStyle_Text();
    public static string get_RemoveTrailingCommaToConformToCodeStyle_Text();
    public static string get_UseSeparateDeclarationExpressions_Text();
    public static string get_UsePositionalDeconstructionPattern_Text();
    public static string get_UseSingleDeconstructionDeclaration_Text();
    public static string get_UseVarDeconstructionPattern_Text();
    public static string get_UseExplicitDiscardDeclaration_Text();
    public static string get_UseExplicitVar_Pattern_Text();
    public static string get_RemoveRedundantVarKeyword_Text();
    public static string get_AddBraces_Description_Text();
    public static string get_FileLayoutDesigner_Elements_HandlesEvent_MatchBy_SubscriptionOrSignature_Text();
    public static string get_CustomLayout_Description_Text();
    public static string get_DefaultLayoutUsingRegions_Description_Text();
    public static string get_DefaultLayoutWithoutRegions_Description_Text();
    public static string get_DoNotChange_Description_Text();
    public static string get_DoNotUse_Description_Text();
    public static string get_ForFields_Description_Text();
    public static string get_ForFieldsInThisClass_Description_Text();
    public static string get_ForThisClassMembers_Description_Text();
    public static string get_RemoveBraces_Description_Text();
    public static string get_FileLayoutDesigner_Elements_HandlesEvent_MatchBy_Signature_Text();
    public static string get_FileLayoutDesigner_Elements_HandlesEvent_MatchBy_Subscription_Text();
    public static string get_UseVar_Description_Text();
    public static string get_UseVarWhenEvident_Description_Text();
    public static string get_UseAlways_Description_Text();
    public static string get_UseBracesForMultiline_Description_Text();
    public static string get_UseExplicitType_Description_Text();
    public static string get_Namespace_Text();
    public static string get_RecordStruct_Text();
    public static string get_Record_Text();
    public static string get_Class_Text();
    public static string get_Interface_Text();
    public static string get_Struct_Text();
    public static string get_Delegate_Text();
    public static string get_Enum_Text();
    public static string get_Accessor_Text();
    public static string get_Destructor_Text();
    public static string get_Method_Text();
    public static string get_Constructor_Text();
    public static string get_CheckedOperator_Text();
    public static string get_Operator_Text();
    public static string get_LocalFunction_Text();
    public static string get_FunctionPointer_Text();
    public static string get_Field_Text();
    public static string get_Constant_Text();
    public static string get_EnumMember_Text();
    public static string get_Indexer_Text();
    public static string get_IndexedProperty_Text();
    public static string get_RangeVariable_Text();
    public static string get_Property_Text();
    public static string get_Event_Text();
    public static string get_Parameter_Text();
    public static string get_LocalConstant_Text();
    public static string get_LocalVariable_Text();
    public static string get_Label_Text();
    public static string get_TypeParameter_Text();
    public static string get_AnonymousFunction_Text();
    public static string get_Alias_Text();
    public static string get_Type_Text();
    public static string get_CommaExpected_Text();
    public static string get_LambdaArrowExpected_Text();
    public static string get_PatternIsMissing_Text();
    public static string get_EqualsExpected_Text();
    public static string get_AliasKeywordExpected_Text();
    public static string get_ExternAliasDirectivesAreOnlyAllowed_Text();
    public static string get_UsingDirectivesAreOnlyAllowedInTheBeginningOfFile_Text();
    public static string get_UsingDirectivesAreOnlyAllowedInTheBeginningOfNamespace_Text();
    public static string get_EndifDirectiveExpected_Text();
    public static string get_ArrayCreationMustHaveArraySizeOrArray_Text();
    public static string get_DimensionExpressionMissing_Text();
    public static string get_EnableDisableRestoreExpected_Text();
    public static string get_ExpressionExpected_Text();
    public static string get_IncorrectPrimaryExpression_Text();
    public static string get_InitializerExpected_Text();
    public static string get_Missing_Text();
    public static string get_NamespaceBodyBlockExpected_Text();
    public static string get_GlobalAttributesAreOnlyAllowedInThe_Text();
    public static string get_ExternAliasDirectivesAreOnlyAllowed2_Text();
    public static string get_ParserExpectedTwoSymbols_Text();
    public static string get_ParserExpectedSymbol_Text();
    public static string get_ParserUnexpectedToken_Text();
    public static string get_ParserStatementSymbol_Text();
    public static string get_ParserExpressionSymbol_Text();
    public static string get_ParserTupleExpressionSymbol_Text();
    public static string get_ParserPatternSymbol_Text();
    public static string get_ParserUsingDirectiveSymbol_Text();
    public static string get_ParserTypeMemberDeclarationSymbol_Text();
    public static string get_ParserTypeDeclarationSymbol_Text();
    public static string get_ParserTypeDeclarationBodySymbol_Text();
    public static string get_ParserEnumDeclarationBodySymbol_Text();
    public static string get_ParserIdentifierSymbol_Text();
    public static string get_ParserUsageOfPredefinedTypeSymbol_Text();
    public static string get_ParserUsageOfTypeSymbol_Text();
    public static string get_ParserUsageOfUserDefinedTypeSymbol_Text();
    public static string get_ParserConditionalSymbol_Text();
    public static string get_ParserConditionalSymbolName_Text();
    public static string get_ParserLineNumberSymbol_Text();
    public static string get_ParserTypeParameterConstraintSymbol_Text();
    public static string get_ParserPointerTypeSymbol_Text();
    public static string get_ParserConstructorDeclarationSymbol_Text();
    public static string get_ParserInterpolationStringExpressionSymbol_Text();
    public static string get_ParserInitializerSymbol_Text();
    public static string get_ParserValidOperatorSignSymbol_Text();
    public static string get_ParserFunctionBodySymbol_Text();
    public static string get_ParserExpressionBodyClauseSymbol_Text();
    public static string get_ParserMethodBodySymbol_Text();
    public static string get_ParserExpressionOrInitializerSymbol_Text();
    public static string get_ParserVariableDesignationSymbol_Text();
    public static string get_ParserDeclarationOrExpressionListSymbol_Text();
    public static string get_ParserLambdaSignatureSymbol_Text();
    public static string get_ParserPropertyAssignmentSymbol_Text();
    public static string get_ParserParameterModifierSymbol_Text();
    public static string get_ParserGroupClauseSymbol_Text();
    public static string get_ParserSelectClauseSymbol_Text();
    public static string get_ParserAttributeSectionSymbol_Text();
    public static string get_ParserModifierSymbol_Text();
    public static string get_ParserParameterDeclarationSymbol_Text();
    public static string get_ParserSwitchCaseLabelSymbol_Text();
    public static string get_ParserSwitchGoverningExpressionSymbol_Text();
    public static string get_ParserParameterModifierSymbol2_Text();
    public static string get_ParserForeachVariableDeclarationSymbol_Text();
    public static string get_ParserArgumentSymbol_Text();
    public static string get_WarningsAnnotationsExpected_Text();
    public static string get_SameClass_Text();
    public static string get_BaseClass_Text();
    public static string get_CSharpPatternStyleSettingsSettingDescription();
    public static string get_NullCheckingPatternStyle();
    public static string get_UseEmptyRecursivePattern_Text();
    public static string get_UseNotNullPattern_Text();
    public static string get_EmptyRecursivePattern_Text();
    public static string get_NotNullPattern_Text();
    public static string get_InAnonymousType_Text();
    public static string get_InAnonymousTypeBrackets_Text();
    public static string get_InconsistentBodyStyleUseStatementBody_Text();
    public static string get_InconsistentBodyStyleUseExpressionBodiedIndexer_Text();
    public static string get_InconsistentBodyStyleUseExpressionBodiedProperty_Text();
    public static string get_InconsistentBodyStyleUseExpressionBodiedGetter_Text();
    public static string get_InconsistentBodyStyleUseExpressionBody_Text();
    public static string get_EntityFrameworkSettingsDescription();
    public static string get_EntityFrameworkAnalysisSettingsEntryDescription();
    public static string get_DumpDbContextsStructureText();
    public static string get_CSharpFormatSettingsKey_PreferToWrapBeforeFirstMethodCall_SettingsEntryDescription();
    public static string get_CSharpFormatSettingsKey_PreferToWrapAfterPropertiesAndFields_SettingsEntryDescription();
    public static string get_AlignMultilineCommentsWithAsterisksSettingsDescription();
    public static string get_Align_Text();
    public static string get_IndentToPreviousLine_Text();
    public static string get_HowToIndentRawStringLiteralsSettingsDescription();
    public static string get_EntityFrameworkAnalysisSettingsDisabledDbContextsDescription();
    public static string get_TypeDoesNotMatchExpectedTypeMessage();
    public static string get_EntityFrameworkQueryAnalysisModeSettingsEntryDescription();
    public static string get_EntityFrameworkEntityAdornment_Settings_Enabled_Description();
    public static string get_EntityFrameworkModelAnalysis_Settings_Enabled_Description();
    public static string get_Presenter_ITopLevelEntryPoint_Text();
    public static string get_Presenter_IAnonymousMethod_Text();
    public static string get_Presenter_INamespace_Root_Text();
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.SourceGenerators.CSharpSourceGeneratedFilesLanguageProvider : object {
    public ProjectLanguage SupportedProjectLanguage { get; }
    public PsiLanguageType PsiLanguageType { get; }
    public ProjectFileType ProjectFileType { get; }
    public sealed virtual ProjectLanguage get_SupportedProjectLanguage();
    public sealed virtual PsiLanguageType get_PsiLanguageType();
    public sealed virtual ProjectFileType get_ProjectFileType();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AccessorDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanUseInitOnlyMembers(ITreeNode context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AccessorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByOwnModifiersList(IModifiersList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AccessorOwnerDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByAccessorDeclaration(IAccessorDeclaration param);
    [PureAttribute]
public static TreeNodeCollection`1<IAccessorOwnerDeclaration> GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
public static TreeNodeCollection`1<IAccessorOwnerDeclaration> GetByModifiersList(IModifiersList param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AccessorOwnerExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IAccessorDeclaration GetAccessorDeclaration(IAccessorOwnerDeclaration ownerDeclaration, AccessorKind accessorKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasAccessorDeclaration(IAccessorOwnerDeclaration ownerDeclaration, AccessorKind accessorKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsWellFormed(IAccessorOwnerDeclaration ownerDeclaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasCodeBodyOrAccessorsWithBody(IAccessorOwnerDeclaration ownerDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AdditiveExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAdditiveExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAdditiveExpression GetByRightOperand(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AllowsRefStructConstraintNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AndPatternNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAndPattern GetByLeftPattern(IPattern param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAndPattern GetByRightPattern(IPattern param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AnonymousFunctionExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false, delegateType: null; => delegateType: canbenull")]
public static bool IsConvertedToConcreteDelegateType(IAnonymousFunctionExpression anonymousFunctionExpression, Nullable`1& delegateType, bool allowLinqExpressionOfT, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool DefinitelyMustHaveNaturalType(IAnonymousFunctionExpression anonymousFunctionExpression, bool allowLinqExpressionOfT);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNaturalDelegateTypeUsed(IAnonymousFunctionExpression anonymousFunctionExpression, IDeclaredType& naturalDelegateType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInNaturalFunctionTypeContext(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInNaturalFunctionTypeContext(ICSharpExpression expression, IResolveContext resolveContext);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AnonymousMemberDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousMemberDeclaration GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousMemberDeclaration GetByNameIdentifier(ICSharpIdentifier identifier);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AnonymousMethodExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousMethodExpression GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousMethodExpression GetByParameterDeclaration(ILocalParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousMethodExpression GetByParameterList(ILocalFormalParameterList param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AnonymousObjectCreationExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousObjectCreationExpression GetByAnonymousInitializer(IAnonymousObjectInitializer param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AnonymousObjectInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousObjectInitializer GetByMemberInitializer(IAnonymousMemberDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ArglistExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArglistExpression GetByArgument(ICSharpArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArglistExpression GetByArgumentList(IArgumentList param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ArgumentListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArgumentList GetByArgument(ICSharpArgument param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ArrayCreationExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayCreationExpression GetByArrayInitializer(IArrayInitializer param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayCreationExpression GetByDim(IRankSpecifier param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayCreationExpression GetByDimInit(ICSharpExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayCreationExpression GetByTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayCreationExpression GetByCreatedTypeUsage(ITypeUsage typeUsage);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static IArrayCreationExpression GetByTypeName(IReferenceName referenceName);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IArrayCreationExpression GetByElementInitializerRecursively(IVariableInitializer initializer);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IArrayCreationExpression GetByElementInitializerExpression(ICSharpExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ArrayInitializerExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static int GetMaximumRank(IArrayInitializer arrayInitializer);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IType GetImplicitlyConvertedTo(IArrayInitializer arrayInitializer, IResolveContext resolveContext);
    [CanBeNullAttribute]
[PureAttribute]
private static IDeclaration GetContainingDeclarationWithType(IVariableInitializer initializer);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ArrayInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayInitializer GetByElementInitializer(IVariableInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IArrayInitializer GetByElementInitializerRecursively(IVariableInitializer initializer);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IArrayInitializer GetByElementInitializerExpressionRecursively(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IArrayInitializer GetByElementInitializerExpression(ICSharpExpression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ArrayTypeUsageNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayTypeUsage GetByArrayRank(IRankSpecifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayTypeUsage GetByElementType(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ArrowExpressionClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrowExpressionClause GetByExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AsExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAsExpression GetByOperand(ICSharpExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAsExpression GetByTypeOperand(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAsExpression GetByScalarTypeName(IReferenceName scalarTypeName);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AssignmentExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEventSubscription(IAssignmentExpression assignmentExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static AssignmentKind GetAssignmentKind(IAssignmentExpression assignmentExpression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullCoalesceAssignment(IAssignmentExpression assignmentExpression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.AssignmentExpressionExtensions/<GetAllDestinationExpressions>d__3")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<ICSharpExpression> GetAllDestinationExpressions(IAssignmentExpression assignmentExpression);
    [ExtensionAttribute]
public static void Deconstruct(IAssignmentExpression assignmentExpression, ICSharpExpression& destionation, ICSharpExpression& source);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AssignmentExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAssignmentExpression GetByDest(ICSharpExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAssignmentExpression GetBySource(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IAssignmentExpression GetBySourceOrDest(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IAssignmentExpression GetByDeconstructionComponent(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IAssignmentExpression GetByDeconstructionTupleExpression(ITupleExpression tupleExpression);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.AssignmentKind : Enum {
    public int value__;
    public static AssignmentKind OrdinaryAssignment;
    public static AssignmentKind DeconstructingAssignment;
    public static AssignmentKind DeconstructingDeclaration;
    public static AssignmentKind DeconstructionMixed;
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.AssignmentType : Enum {
    public int value__;
    public static AssignmentType INVALID;
    public static AssignmentType EQ;
    public static AssignmentType PLUSEQ;
    public static AssignmentType MINUSEQ;
    public static AssignmentType ASTERISKEQ;
    public static AssignmentType DIVEQ;
    public static AssignmentType PERCEQ;
    public static AssignmentType ANDEQ;
    public static AssignmentType OREQ;
    public static AssignmentType XOREQ;
    public static AssignmentType LTLTEQ;
    public static AssignmentType GTGTEQ;
    public static AssignmentType GTGTGTEQ;
    public static AssignmentType DOUBLE_QUEST_EQ;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IDeclaredType GetAttributeType(IAttribute attribute);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static string GetExplicitTargetName(IAttribute attribute);
    [ExtensionAttribute]
[PureAttribute]
public static AttributeTargets GetAttributeTargets(IAttribute attribute);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributeListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttributeList GetByAttribute(IAttribute param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributeNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttribute GetByArgument(ICSharpArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttribute GetByConstructorArgumentExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttribute GetByName(IReferenceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttribute GetByPropertyAssignment(IPropertyAssignment param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributeSectionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static string GetTargetNameOrEmpty(IAttributeSection section);
    [ExtensionAttribute]
public static void SetTarget(IAttributeSection section, AttributeTarget target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributeSectionListNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttributeSectionList GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttributeSectionList GetBySection(IAttributeSection param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributeSectionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttributeSection GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttributeSection GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttributeSection GetByTargetIdentifier(ICSharpIdentifier param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributesOwnerDeclarationExtensions : object {
    [PureAttribute]
public static bool IsSynthetic(IAttributesOwnerDeclaration attributesOwnerDeclaration);
    [ExtensionAttribute]
[PureAttribute]
public static TreeNodeEnumerable`1<IAttributeSection> GetAttributeSectionsEnumerable(IAttributesOwnerDeclaration attributesOwnerDeclaration);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IAttributeSectionList TryGetAttributeSectionList(IAttributesOwnerDeclaration parent);
    [ExtensionAttribute]
public static void RemoveAttributeSectionList(IAttributesOwnerDeclaration parent);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAttributeSectionList GetOrCreateAttributeSectionList(IAttributesOwnerDeclaration parent);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanHasAttributesAccordingToLanguageLevel(IAttributesOwnerDeclaration attributesOwnerDeclaration);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributesOwnerDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static TreeNodeCollection`1<ICSharpDeclaration> GetByAttribute(IAttribute param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.AttributeTarget : Enum {
    public int value__;
    public static AttributeTarget None;
    public static AttributeTarget Assembly;
    public static AttributeTarget Module;
    public static AttributeTarget Event;
    public static AttributeTarget Field;
    public static AttributeTarget Method;
    public static AttributeTarget Param;
    public static AttributeTarget Property;
    public static AttributeTarget Return;
    public static AttributeTarget Type;
    public static AttributeTarget Typevar;
    public static AttributeTarget Unknown;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AttributeTargetUtil : object {
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static string GetKeyword(AttributeTarget target);
    [PureAttribute]
public static AttributeTarget FromKeyword(string keyword);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AwaitExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnderAsyncDeclaration(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnderAsyncDeclaration(ITreeNode node, bool treatTopLevelCodeAsAsync);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.AwaitExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAwaitExpression GetByTask(IUnaryExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BaseExpressionNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BinaryExpressionExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(IBinaryExpression binaryExpression, ICSharpExpression& leftOperand, ICSharpExpression& rightOperand);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BinaryExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IBinaryExpression GetByLeftOperand(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IBinaryExpression GetByRightOperand(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IBinaryExpression GetByAnyOperand(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BinaryPatternNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IBinaryPattern GetByLeftPattern(IPattern pattern);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IBinaryPattern GetByRightPattern(IPattern pattern);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IBinaryPattern GetByAnyOperand(IPattern pattern);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BitwiseAndExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBitwiseAndExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBitwiseAndExpression GetByRightOperand(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BitwiseExclusiveOrExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBitwiseExclusiveOrExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBitwiseExclusiveOrExpression GetByRightOperand(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BitwiseInclusiveOrExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBitwiseInclusiveOrExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBitwiseInclusiveOrExpression GetByRightOperand(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BlockNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBlock GetByStatement(ICSharpStatement param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.BreakStatementNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CastExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Conversion GetConversion(ICastExpression castExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CastExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICastExpression GetByOp(ICSharpExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICastExpression GetByTargetType(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICastExpression GetByScalarTypeName(IReferenceName scalarTypeName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CatchClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchClause GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchClause GetByFilter(IExceptionFilterClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchClause GetByFilterCondition(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CatchVariableDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchVariableDeclaration GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CheckedExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICheckedExpression GetByOperand(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CheckedStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICheckedStatement GetByBody(IBlock param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ClassBodyExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmptyBody(IMemberOwnerBody memberOwnerBody);
    [ExtensionAttribute]
public static void ReplaceWithSemicolon(IMemberOwnerBody memberOwnerBody);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ClassBodyNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByConstantDeclaration(IMultipleConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByConstructor(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByDestructor(IDestructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByEventDeclaration(IMultipleEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByFieldDeclaration(IMultipleFieldDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByIndexer(IIndexerDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByMethod(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByOperator(IOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByPropertie(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByTypeDeclaration(ICSharpTypeDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ClassDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByDestructorDeclaration(IDestructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByExtendsList(IExtendsList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByFieldDeclaration(IFieldDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByIndexerDeclaration(IIndexerDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByInheritedTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByNestedTypeDeclaration(ICSharpTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByOperatorDeclaration(IOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByTypeParameterConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ClassLikeDeclarationExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IClassBody EnsureHasClassBody(IClassLikeDeclaration classLikeDeclaration);
    [CompilerGeneratedAttribute]
internal static void <EnsureHasClassBody>g__FixClassBody|0_0(<>c__DisplayClass0_0& );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ClassLikeDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByFieldDeclaration(IFieldDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByIndexerDeclaration(IIndexerDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByNestedTypeDeclaration(ICSharpTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByOperatorDeclaration(IOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByConstructorDeclaration(IConstructorDeclaration constructorDeclaration);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByExtendsList(IExtendsList extendsList);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ClassMemberDeclarationNavigator : object {
    [PureAttribute]
public static TreeNodeCollection`1<IClassMemberDeclaration> GetByAttribute(IAttribute param);
    [PureAttribute]
public static TreeNodeCollection`1<IClassMemberDeclaration> GetByModifiersList(IModifiersList param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CollectionElementInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICollectionElementInitializer GetByArgument(ICSharpArgument param);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionElementKinds : Enum {
    public int value__;
    public static CollectionExpressionElementKinds None;
    public static CollectionExpressionElementKinds Expression;
    public static CollectionExpressionElementKinds Spread;
    public static CollectionExpressionElementKinds All;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionElementNavigator : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ITreeRange GetTreeRangeBetweenBrackets(ICollectionExpression collectionExpression);
    [ExtensionAttribute]
[PureAttribute]
public static CollectionExpressionElementKinds GetElementKinds(ICollectionExpression collectionExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSpanTypedWithArrayAllocation(ICollectionExpression collectionExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeLoweredToInlineArray(ICollectionExpression collectionExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeLoweredToRuntimeHelpersCreateSpan(ICollectionExpression collectionExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollectionExpressionTargetInterfaceType(IType targetType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollectionExpressionTargetInterfaceType(IType targetType, IType& elementType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInContextWhereCollectionExpressionCanHaveProperTargetType(ICSharpExpression expression);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionKind : Enum {
    public int value__;
    public static CollectionExpressionKind None;
    public static CollectionExpressionKind Array;
    public static CollectionExpressionKind Span;
    public static CollectionExpressionKind ReadOnlySpan;
    public static CollectionExpressionKind CollectionBuilder;
    public static CollectionExpressionKind ImplementsIEnumerable;
    public static CollectionExpressionKind ArrayInterface;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICollectionExpression GetByCollectionElement(ICollectionExpressionElement param);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[RequiredMemberAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Tree.CollectionExpressionTargetTypeInfo : ValueType {
    [CompilerGeneratedAttribute]
private IType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionExpressionKind <Kind>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IType <ElementType>k__BackingField;
    [RequiredMemberAttribute]
public IType TargetType { get; public set; }
    [RequiredMemberAttribute]
public CollectionExpressionKind Kind { get; public set; }
    [NullableAttribute("2")]
public IType ElementType { get; public set; }
    [CompilerGeneratedAttribute]
public IType get_TargetType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetType(IType value);
    [CompilerGeneratedAttribute]
public CollectionExpressionKind get_Kind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Kind(CollectionExpressionKind value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IType get_ElementType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ElementType(IType value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CollectionInitializerExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmpty(ICollectionInitializer collectionInitializer);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CollectionInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICollectionInitializer GetByElementInitializer(ICollectionElementInitializer param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.CommentType : Enum {
    public byte value__;
    public static CommentType END_OF_LINE_COMMENT;
    public static CommentType MULTILINE_COMMENT;
    public static CommentType DOC_COMMENT;
    public static CommentType MULTILINE_DOC_COMMENT;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CommentTypeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDocComment(CommentType commentType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEndOfLineComment(CommentType commentType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPartOfConditionalAccess(IConditionalAccessExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTopPartOfConditionalAccess(IConditionalAccessExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsIntermediatePartOfConditionalAccess(IConditionalAccessExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsAllowedConditionalAccessQualifierType(IExpressionType expressionType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAllowedConditionalAccessExpressionType(IExpressionType expressionType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTopConditionalAccess(IConditionalAccessExpression expression);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpExpression GetConditionalAccessQualifier(IConditionalAccessExpression expression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExpressionType GetLiftedExpressionType(ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
public static IType GetLiftedExpressionType(IType type);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReference GetConditionalMemberReference(IConditionalAccessExpression expression);
    [ExtensionAttribute]
[NotNullAttribute]
public static TExpression ReplaceByInConditionalAccessQualifier(IConditionalAccessExpression expression, TExpression expr);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IConditionalAccessExpression GetByQualifier(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IConditionalAccessExpression GetTopByQualifier(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAccessSignNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalAndExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalAndExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalAndExpression GetByRightOperand(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalOrExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalOrExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalOrExpression GetByRightOperand(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalTernaryExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTargetTyped(IConditionalTernaryExpression conditionalExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTargetTyped(IConditionalTernaryExpression conditionalExpression, IResolveContext resolveContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConditionalTernaryExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalTernaryExpression GetByConditionOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalTernaryExpression GetByElseResult(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalTernaryExpression GetByThenResult(ICSharpExpression param);
    [NullableContextAttribute("0")]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static IConditionalTernaryExpression GetByAnyBranch(ICSharpExpression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConstantDeclarationNavigator : object {
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IConstantDeclaration> GetByAttribute(IAttribute param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IConstantDeclaration> GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstantDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IConstantDeclaration> GetByTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstantDeclaration GetByValueExpression(ICSharpExpression param);
    [NullableContextAttribute("0")]
[PureAttribute]
[ItemCanBeNullAttribute]
public static TreeNodeCollection`1<IConstantDeclaration> GetByScalarTypeName(IReferenceName scalarTypeName);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConstantOrTypePatternExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(IConstantOrTypePattern constantOrTypePattern, ConstantOrTypePatternKind& kind);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.ConstantOrTypePatternKind : Enum {
    public int value__;
    public static ConstantOrTypePatternKind TypeCheck;
    public static ConstantOrTypePatternKind ConstantValueCheck;
    public static ConstantOrTypePatternKind Unknown;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConstantOrTypePatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstantOrTypePattern GetByExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConstructorConstraintNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConstructorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByInitializer(IConstructorInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByTypeName(ICSharpIdentifier param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.ConstructorInitializerKind : Enum {
    public int value__;
    public static ConstructorInitializerKind THIS;
    public static ConstructorInitializerKind BASE;
    public static ConstructorInitializerKind UNKNOWN;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConstructorInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorInitializer GetByArgument(ICSharpArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorInitializer GetByArgumentList(IArgumentList param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ContinueStatementNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ConversionOperatorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByTypeUsage(ITypeUsage param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CreationExpressionInitializerExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTopLevel(ICreationExpressionInitializer initializer);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNestedInitializer(ICreationExpressionInitializer initializer);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CreationExpressionInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICreationExpressionInitializer GetByInitializerElement(IInitializerElement initializerElement);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CreationExpressionNavigator : object {
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICreationExpression GetByInitializer(ICreationExpressionInitializer initializer);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.CSharpAccessorKind : Enum {
    public byte value__;
    public static CSharpAccessorKind UNKNOWN;
    public static CSharpAccessorKind GETTER;
    public static CSharpAccessorKind SETTER;
    public static CSharpAccessorKind ADDER;
    public static CSharpAccessorKind REMOVER;
    public static CSharpAccessorKind INITTER;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpArgumentExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetImplicitlyConvertedTo(ICSharpArgument argument);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetImplicitlyConvertedTo(ICSharpArgument argument, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCompatibleWith(ParameterKind targetKind, ParameterKind sourceKind, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsImplicitInArgument(ICSharpArgument argument);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsImplicitInArgument(ICSharpArgument argument, IResolveContext resolveContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpArgumentNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpArgument GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpArgument GetByValue(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpArgumentsOwnerExtensions : object {
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpArgumentsOwner GetArgumentsOwner(IReference reference);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpArgumentInfo TryFindMatchingNonExpandedArgument(ICSharpArgumentsOwner invocationExpression, IParameter parameter, bool includeExtensionQualifier);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpArgumentsOwnerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpArgumentsOwner GetByArgument(ICSharpArgument param);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpArgumentsOwner GetByArgumentList(IArgumentList argumentList);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpClosureExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInsideClosure(ITreeNode element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetClosureTargetType(ICSharpClosure closure);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpCompositeNodeType : CompositeNodeType {
    protected CSharpCompositeNodeType(string s, int index);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpDeclarationExtensions : object {
    [ExtensionAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static TreeNodeCollection`1<ITypeParameterConstraintsClause> GetTypeParameterConstraintClauses(ICSharpDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool HasCodeBody(ICSharpDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpCodeBody GetCodeBody(ICSharpDeclaration declaration);
    [ExtensionAttribute]
public static CSharpCodeBody SetCodeBody(ICSharpDeclaration declaration, CSharpCodeBody codeBody);
    [ExtensionAttribute]
[NotNullAttribute]
public static TBody SetCodeBody(ICSharpDeclaration declaration, TBody body);
    [ExtensionAttribute]
public static void RemoveCodeBody(ICSharpDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasXmlDocumentation(ICSharpDeclaration declaration);
    [CompilerGeneratedAttribute]
internal static CSharpCodeBody <GetCodeBody>g__Create|2_0(IArrowExpressionClause arrowExpressionClause, IBlock block);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpDeclarationNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpDocCommentBlockExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpDocCommentBlock TryFindDeclarationWithDocumentation(ICSharpDeclaration declaration);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpExpressionNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpFileNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetByExternAliase(IExternAliasDirective param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetByImport(IUsingDirective param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetByImportsList(IUsingList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetByNamespaceDeclaration(ICSharpNamespaceDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetByNamespaceDeclarationNode(ICSharpNamespaceDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetBySection(IAttributeSection param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetByTypeDeclaration(ICSharpTypeDeclaration param);
    [PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFile GetByTopLevelCode(ITopLevelCode topLevelCode);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpFunctionDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsIteratorBlock(ICSharpFunctionDeclaration functionDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpFunctionDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFunctionDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFunctionDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpFunctionDeclaration GetByBody(IBlock param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpLiteralExpressionNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpModifiersOwnerDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool HasModifier(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration, TokenNodeType tokenType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindFirstModifier(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration, TokenNodeType tokenType);
    [ExtensionAttribute]
public static void RemoveModifier(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration, TokenNodeType tokenType);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpModifiersOwnerDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static TreeNodeCollection`1<ICSharpDeclaration> GetByAttribute(IAttribute param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpNamespaceDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmptyBody(ICSharpNamespaceDeclaration namespaceDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpNamespaceDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpNamespaceDeclaration GetByBody(INamespaceBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpNamespaceDeclaration GetByExternAliase(IExternAliasDirective param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpNamespaceDeclaration GetByImport(IUsingDirective param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpNamespaceDeclaration GetByImportsList(IUsingList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpNamespaceDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpNamespaceDeclaration GetByNamespaceDeclaration(ICSharpNamespaceDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpNamespaceDeclaration GetByNamespaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpNamespaceDeclaration GetByTypeDeclaration(ICSharpTypeDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpParameterDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpParameterDeclaration GetByAttributeSectionList(IAttributeSectionList param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpParametersOwnerDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpParametersOwnerDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpRegularParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpRegularParameterDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpRegularParameterDeclaration GetByAttributeSectionList(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpRegularParameterDeclaration GetByDefaultValue(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpRegularParameterDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpRegularParameterDeclaration GetByParameterModifiersList(IParameterModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpRegularParameterDeclaration GetByTypeUsage(ITypeUsage param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpStatementExtensions : object {
    [ExtensionAttribute]
public static void RemoveOrReplaceByEmptyStatement(ICSharpStatement statement);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpStatementNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpTreeNodeExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpNamespaceDeclaration GetContainingNamespaceDeclaration(ITreeNode treeNode);
    [CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Backward compatibility")]
public static ICSharpTypeDeclaration GetContainingTypeDeclaration(ICSharpTreeNode treeNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpTypeDeclaration GetContainingTypeDeclaration(ITreeNode treeNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpTypeDeclaration GetContainingTypeDeclaration(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITypeElement GetContainingTypeElement(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Use 'GetContainingTypeMemberDeclarationIgnoringClosures()' or 'GetContainingFunctionLikeDeclarationOrClosure()' instead to clarify the required behavior")]
public static ICSharpTypeMemberDeclaration GetContainingTypeMemberDeclaration(ITreeNode treeNode);
    [CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Backward compatibility")]
public static ICSharpTypeMemberDeclaration GetContainingTypeMemberDeclarationIgnoringClosures(ICSharpTreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpTypeMemberDeclaration GetContainingTypeMemberDeclarationIgnoringClosures(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpDeclaration GetContainingTypeMemberDeclarationOrTopLevelCodeIgnoringClosures(ITreeNode treeNode, bool returnThis);
    [CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Backward compatibility")]
public static ICSharpFunctionDeclaration GetContainingFunctionDeclarationIgnoringClosures(ICSharpTreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpFunctionDeclaration GetContainingFunctionDeclarationIgnoringClosures(ITreeNode treeNode, bool returnThis);
    [CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Backward compatibility")]
public static ICSharpDeclaration GetContainingFunctionLikeDeclarationOrClosure(ICSharpTreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpDeclaration GetContainingFunctionLikeDeclarationOrClosure(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetPreviousMeaningfulSiblingThroughWhitespaceAndComments(ITreeNode node, bool onlyAtTheSameLine);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpTypeAndNamespaceHolderDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpTypeAndNamespaceHolderDeclaration GetByExternAliase(IExternAliasDirective param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpTypeAndNamespaceHolderDeclaration GetByImport(IUsingDirective param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpTypeAndNamespaceHolderDeclaration GetByImportsList(IUsingList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpTypeAndNamespaceHolderDeclaration GetByNamespaceDeclaration(ICSharpNamespaceDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpTypeAndNamespaceHolderDeclaration GetByTypeDeclaration(ICSharpTypeDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpTypeDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.CSharpTypeMemberDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static TreeNodeCollection`1<ICSharpTypeMemberDeclaration> GetByAttribute(IAttribute param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DeclarationExpressionExtensions : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.DeclarationExpressionExtensions/<IterateSingleVariableDesignations>d__0")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<ISingleVariableDesignation> IterateSingleVariableDesignations(IDeclarationExpression declarationExpression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.DeclarationExpressionExtensions/<UnfoldVariableDesignations>d__1")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<IVariableDesignation> UnfoldVariableDesignations(IDeclarationExpression declarationExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DeclarationExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeclarationExpression GetByDesignation(IVariableDesignation param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeclarationExpression GetByTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeclarationExpression GetByVariableDesignationRecursively(IVariableDesignation variableDesignation);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DeclarationStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeclarationStatement GetByConstantDeclaration(ILocalConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeclarationStatement GetByDeclaration(IMultipleDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeclarationStatement GetByLocalFunctionDeclaration(ILocalFunctionDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeclarationStatement GetByVariableDeclaration(ILocalVariableDeclaration param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DeconstructionPatternClauseExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeParsedAsCastExpression(IDeconstructionPatternClause deconstructionPatternClause);
    [ExtensionAttribute]
public static void FixToAvoidAmbiguityWithCastExpression(IDeconstructionPatternClause deconstructionPatternClause);
    [ExtensionAttribute]
public static void RemoveIfAllDiscardedAndRedundant(IDeconstructionPatternClause deconstructionPatternClause);
    [CompilerGeneratedAttribute]
internal static bool <CanBeParsedAsCastExpression>g__CanBeParsedAsTypeUsage|0_0(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DeconstructionPatternClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeconstructionPatternClause GetByPattern(ISubpattern param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DefaultConstraintNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DefaultExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDefaultExpression GetByTypeName(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DefineDirectiveNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DelegateDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByTypeParameterConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DestructorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDestructorDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDestructorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDestructorDeclaration GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDestructorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDestructorDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDestructorDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDestructorDeclaration GetByTypeName(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DiscardDesignationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDiscardDesignation GetByUnderscoreIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DiscardPatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDiscardPattern GetByUnderscore(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCommentBlockNodeNavigator : object {
    [CanBeNullAttribute]
public static ICSharpDocCommentBlock GetByDocCommentNode(IDocCommentNode docCommentNode);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCRefElementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefElement GetByQualifier(IDocCRefElement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefElement GetBySignature(IDocCRefSignature param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefElement GetByTypeParameterList(IDocCRefTypeParameterList param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCRefExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefExpression GetByElement(IDocCRefElement param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCRefParameterNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefParameter GetByParameterType(IDocCRefParameterType param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCRefParameterTypeNameNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefParameterTypeName GetByQualifier(IDocCRefParameterTypeName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefParameterTypeName GetByTypeArgument(IDocCRefParameterType param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCRefParameterTypeNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefParameterType GetByArrayRank(IRankSpecifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefParameterType GetByNullableMark(INullableTypeMark param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefParameterType GetByPointerMark(IUnsafeCodePointer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefParameterType GetByTypeName(IDocCRefParameterTypeName param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCRefSignatureNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefSignature GetByParameter(IDocCRefParameter param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCRefTypeParameterListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCRefTypeParameterList GetByTypeParameter(IDocCRefTypeParameter param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DocCRefTypeParameterNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.DoStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDoStatement GetByBody(ICSharpStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDoStatement GetByCondition(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ElementAccessExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElementAccessExpression GetByArgument(ICSharpArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElementAccessExpression GetByArgumentList(IArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElementAccessExpression GetByConditionalAccessSign(IConditionalAccessSign param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElementAccessExpression GetByOperand(IPrimaryExpression param);
    [NullableContextAttribute("0")]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElementAccessExpression GetByOperand(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ElifDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElifDirective GetByCondition(IPreprocessorExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ElseDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EmptyStatementNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EndifDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EndRegionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EnumBaseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumBase GetByUnderlyingType(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EnumBodyNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumBody GetByMember(IEnumMemberDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EnumDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByEnumBody(IEnumBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByEnumMemberDeclaration(IEnumMemberDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByTypeParameterConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByUnderlyingTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EnumMemberDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumMemberDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumMemberDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumMemberDeclaration GetByValueExpression(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EqualityExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEqualityExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEqualityExpression GetByRightOperand(ICSharpExpression param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.EqualityExpressionType : Enum {
    public int value__;
    public static EqualityExpressionType EQEQ;
    public static EqualityExpressionType NE;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ErrorDirectiveNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EventDeclarationExtensions : object {
    [ExtensionAttribute]
public static void RemoveExplicitAccessors(IEventDeclaration eventDeclaration);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IMultipleEventDeclaration GetMultiDeclarationIfEventIsAlone(IEventDeclaration eventDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.EventDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByAccessorDeclaration(IAccessorDeclaration param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IEventDeclaration> GetByAttribute(IAttribute param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IEventDeclaration> GetByDelegateTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByInitial(IVariableInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IEventDeclaration> GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [NullableContextAttribute("0")]
[PureAttribute]
[ItemNotNullAttribute]
public static TreeNodeCollection`1<IEventDeclaration> GetByDelegateName(IReferenceName referenceName);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExceptionFilterClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExceptionFilterClause GetByCondition(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExpressionBodyOwnerDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IParametersOwner GetParametersOwner(IExpressionBodyOwnerDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsAsync(IExpressionBodyOwnerDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanHaveExpressionBody(IExpressionBodyOwnerDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ICSharpIdentifier GetNameIdentifier(IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclaration);
    [ExtensionAttribute]
public static void EnsureHasSemicolon(IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclaration);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExpressionBodyOwnerDeclarationNavigator : object {
    [PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionBodyOwnerDeclaration GetByBodyExpression(ICSharpExpression expression);
    [PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionBodyOwnerDeclaration GetByArrowClause(IArrowExpressionClause arrowClause);
    public static ICSharpDeclaration GetByAttribute(IAttribute attribute);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.ExpressionClassification : Enum {
    public int value__;
    public static ExpressionClassification Value;
    public static ExpressionClassification MutableVariable;
    public static ExpressionClassification ReadOnlyVariable;
    public static ExpressionClassification WriteableExpression;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExpressionClassificationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVariable(ExpressionClassification classification);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsWritable(ExpressionClassification classification);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeAccessedAsVariable(ExpressionClassification classification, bool isReadOnlyAccess);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExpressionElementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionElement GetByExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExpressionInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionInitializer GetByValue(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExpressionStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionStatement GetByExpression(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExtendedTypeNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExtendedType GetByArgument(ICSharpArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExtendedType GetByArgumentList(IArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExtendedType GetByTypeUsage(ITypeUsage param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExtendedType GetByDeclaredType(ITypeUsage typeUsage);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExtendsListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExtendsList GetByExtendedInterface(ITypeUsage param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExtendsList GetByExtendedType(IExtendedType param);
    [PureAttribute]
[ContractAnnotationAttribute("null => null")]
[CanBeNullAttribute]
public static IExtendsList ByClassLikeDeclaration(IClassLikeDeclaration classLikeDeclaration);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ExternAliasDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternAliasDirective GetByNameIdentifier(ICSharpIdentifier param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.FieldDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IMultipleFieldDeclaration GetMultiDeclarationIfFieldIsAlone(IFieldDeclaration fieldDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.FieldDeclarationNavigator : object {
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IFieldDeclaration> GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFieldDeclaration GetByFixedBufferSizeExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFieldDeclaration GetByInitial(IVariableInitializer param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IFieldDeclaration> GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFieldDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IFieldDeclaration> GetByTypeUsage(ITypeUsage param);
    [NullableContextAttribute("0")]
[PureAttribute]
[ItemCanBeNullAttribute]
public static TreeNodeCollection`1<IFieldDeclaration> GetByScalarTypeName(IReferenceName scalarTypeName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ForeachHeaderNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachHeader GetByCollection(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachHeader GetByDeclarationExpression(IDeclarationExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachHeader GetByDeconstructionTuple(ITupleExpression param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachHeader GetByDeconstructionTupleRecursively(ITupleExpression tupleExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ForeachStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByBody(ICSharpStatement param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByCollection(ICSharpExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByForeachHeader(IForeachHeader param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByIteratorDeclaration(IVariableDesignation iteratorDeclaration);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByIteratorDeclarationRecursively(IVariableDesignation iteratorDeclaration);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByDeclarationExpression(IDeclarationExpression declarationExpression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByDeclarationExpressionRecursively(IDeclarationExpression declarationExpression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByDeconstructionTuple(ITupleExpression tupleExpression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForeachStatement GetByDeconstructionTupleRecursively(ITupleExpression tupleExpression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IForeachStatement GetByDeconstructionTupleComponentValue(ICSharpExpression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ForInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForInitializer GetByDeclaration(IMultipleLocalVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForInitializer GetByExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ForIteratorNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForIterator GetByExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.FormalParameterListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFormalParameterList GetByParameterDeclaration(ICSharpParameterDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ForStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByBody(ICSharpStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByCondition(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByInitializer(IForInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByInitializerDeclaration(ILocalVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByInitializerExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByIteratorExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByIterators(IForIterator param);
    [NullableContextAttribute("0")]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static IForStatement GetByAnyExpression(ICSharpExpression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.FunctionPointerCallingConventionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFunctionPointerCallingConvention GetByManagedKeyword(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFunctionPointerCallingConvention GetByUnmanagedCallingConvention(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.FunctionPointerParameterModifiersNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.FunctionPointerParameterNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFunctionPointerParameter GetByModifierList(IFunctionPointerParameterModifiers param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFunctionPointerParameter GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.FunctionPointerTypeUsageNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFunctionPointerTypeUsage GetByCallingConvention(IFunctionPointerCallingConvention param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFunctionPointerTypeUsage GetByParameter(IFunctionPointerParameter param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.GeneralCatchClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGeneralCatchClause GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGeneralCatchClause GetByFilter(IExceptionFilterClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGeneralCatchClause GetByFilterCondition(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.GotoCaseStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGotoCaseStatement GetByValueExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.GotoStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGotoStatement GetByTarget(ILabelReferenceElement param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorDeclaration {
    public ICSharpIdentifier NameIdentifier { get; }
    public IModifiersList OwnModifiersList { get; }
    public IModifiersList ModifiersList { get; }
    [CanBeNullAttribute]
public IAccessor DeclaredElement { get; }
    public bool IsAuto { get; }
    public AccessorKind Kind { get; }
    public CSharpAccessorKind CSharpKind { get; }
    public bool IsInitOnly { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual IModifiersList get_OwnModifiersList();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual IModifiersList SetOwnModifiersList(IModifiersList param);
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IAccessor get_DeclaredElement();
    public abstract virtual bool get_IsAuto();
    public abstract virtual AccessorKind get_Kind();
    public abstract virtual CSharpAccessorKind get_CSharpKind();
    public abstract virtual bool get_IsInitOnly();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAccessorOwnerDeclaration {
    public TreeNodeCollection`1<IAccessorDeclaration> AccessorDeclarations { get; }
    public TreeNodeEnumerable`1<IAccessorDeclaration> AccessorDeclarationsEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual TreeNodeCollection`1<IAccessorDeclaration> get_AccessorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IAccessorDeclaration> get_AccessorDeclarationsEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    [NotNullAttribute]
public abstract virtual IAccessorDeclaration AddAccessorDeclarationBefore(IAccessorDeclaration accessorDeclaration, IAccessorDeclaration anchor);
    [NotNullAttribute]
public abstract virtual IAccessorDeclaration AddAccessorDeclarationAfter(IAccessorDeclaration accessorDeclaration, IAccessorDeclaration anchor);
    public abstract virtual void RemoveAccessorDeclaration(IAccessorDeclaration accessorDeclaration);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAdditiveExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAllowsRefStructConstraint {
    public ITokenNode AllowsKeyword { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode StructKeyword { get; }
    public abstract virtual ITokenNode get_AllowsKeyword();
    public abstract virtual ITokenNode get_RefKeyword();
    public abstract virtual ITokenNode get_StructKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAndPattern {
    public ITokenNode AndKeyword { get; }
    public abstract virtual ITokenNode get_AndKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpression {
    public bool IsAsync { get; }
    [NotNullAttribute]
public IType InferredReturnType { get; }
    public abstract virtual bool get_IsAsync();
    public abstract virtual IType get_InferredReturnType();
    [NotNullAttribute]
public abstract virtual IType GetInferredReturnType(IResolveContext resolveContext);
    public abstract virtual void SetAsync(bool value);
    public abstract virtual void SetStatic(bool value);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousFunctionExpressionImpl {
    [CanBeNullAttribute]
public IType AnnotatedInferredReturnType { get; public set; }
    public abstract virtual IType get_AnnotatedInferredReturnType();
    public abstract virtual void set_AnnotatedInferredReturnType(IType value);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMemberDeclaration {
    public ICSharpExpression Expression { get; }
    public ITokenNode Operator { get; }
    [NotNullAttribute]
public IReference ReferenceToProperty { get; }
    public bool IsProjectionInitializer { get; }
    [CanBeNullAttribute]
public ICSharpIdentifier NameIdentifier { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_Operator();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public abstract virtual IReference get_ReferenceToProperty();
    public abstract virtual bool get_IsProjectionInitializer();
    [PureAttribute]
public abstract virtual TreeTextRange GetNameTextRange();
    [PureAttribute]
public abstract virtual DocumentRange GetNameDocumentRange();
    [NotNullAttribute]
public abstract virtual string GetName();
    public abstract virtual void SetName(string name);
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier name);
    [NotNullAttribute]
public abstract virtual IAnonymousMemberDeclaration ReplaceBy(IAnonymousMemberDeclaration newMember);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousMethodExpression {
    public ITokenNode AsyncKeyword { get; }
    public IBlock Body { get; }
    public ITokenNode DelegateKeyword { get; }
    public ITokenNode LPar { get; }
    public ILocalFormalParameterList ParameterList { get; }
    public ITokenNode RPar { get; }
    public ITokenNode StaticKeyword { get; }
    public TreeNodeCollection`1<ILocalParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public abstract virtual ITokenNode get_AsyncKeyword();
    public abstract virtual IBlock get_Body();
    public abstract virtual ITokenNode get_DelegateKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ILocalFormalParameterList get_ParameterList();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_StaticKeyword();
    public abstract virtual TreeNodeCollection`1<ILocalParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public abstract virtual IBlock SetBody(IBlock param);
    public abstract virtual ILocalFormalParameterList SetParameterList(ILocalFormalParameterList param);
    [NotNullAttribute]
public abstract virtual ILocalParameterDeclaration AddParameterDeclarationBefore(ILocalParameterDeclaration parameterDeclaration, ILocalParameterDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ILocalParameterDeclaration AddParameterDeclarationAfter(ILocalParameterDeclaration parameterDeclaration, ILocalParameterDeclaration anchor);
    public abstract virtual void RemoveParameterDeclaration(ILocalParameterDeclaration parameterDeclaration);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousObjectCreationExpression {
    public IAnonymousObjectInitializer AnonymousInitializer { get; }
    public abstract virtual IAnonymousObjectInitializer get_AnonymousInitializer();
    public abstract virtual IAnonymousObjectInitializer SetAnonymousInitializer(IAnonymousObjectInitializer param);
    public abstract virtual IList`1<AnonymousTypeDescriptor> GetTypeDescriptor(IResolveContext resolveContext);
    public abstract virtual IList`1<AnonymousTypeDescriptor> GetTypeDescriptor();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAnonymousObjectInitializer {
    public TreeNodeCollection`1<IAnonymousMemberDeclaration> MemberInitializers { get; }
    public TreeNodeEnumerable`1<IAnonymousMemberDeclaration> MemberInitializersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IAnonymousMemberDeclaration> get_MemberInitializers();
    public abstract virtual TreeNodeEnumerable`1<IAnonymousMemberDeclaration> get_MemberInitializersEnumerable();
    [NotNullAttribute]
public abstract virtual IAnonymousMemberDeclaration AddMemberInitializerAfter(IAnonymousMemberDeclaration memberDeclaration, IAnonymousMemberDeclaration anchor);
    [NotNullAttribute]
public abstract virtual IAnonymousMemberDeclaration AddMemberInitializerBefore(IAnonymousMemberDeclaration memberDeclaration, IAnonymousMemberDeclaration anchor);
    public abstract virtual void RemoveMemberInitializer(IAnonymousMemberDeclaration memberDeclaration);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IArglistExpression {
    public ITokenNode ArglistKeyword { get; }
    public IArgumentList ArgumentList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public abstract virtual ITokenNode get_ArglistKeyword();
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public abstract virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IArgumentList {
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    [NullableAttribute("1")]
public IReference ParamsDefaultConstructorReference { get; }
    [NullableAttribute("1")]
public IReference ParamsCreateMethodReference { get; }
    public abstract virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public abstract virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    [NullableContextAttribute("1")]
public abstract virtual IReference get_ParamsDefaultConstructorReference();
    [NullableContextAttribute("1")]
public abstract virtual IReference get_ParamsCreateMethodReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IArrayCreationExpression {
    public IArrayInitializer ArrayInitializer { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> DimInits { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> DimInitsEnumerable { get; }
    public TreeNodeCollection`1<IRankSpecifier> Dims { get; }
    public TreeNodeEnumerable`1<IRankSpecifier> DimsEnumerable { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public IReferenceName TypeName { get; }
    public bool IsImplicitlyTypedArray { get; }
    [NotNullAttribute]
public Int32[] Dimensions { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IList`1<ICSharpExpression> Sizes { get; }
    public abstract virtual IArrayInitializer get_ArrayInitializer();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpExpression> get_DimInits();
    public abstract virtual TreeNodeEnumerable`1<ICSharpExpression> get_DimInitsEnumerable();
    public abstract virtual TreeNodeCollection`1<IRankSpecifier> get_Dims();
    public abstract virtual TreeNodeEnumerable`1<IRankSpecifier> get_DimsEnumerable();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IArrayInitializer SetArrayInitializer(IArrayInitializer param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IReferenceName get_TypeName();
    public abstract virtual bool get_IsImplicitlyTypedArray();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetElementType();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetElementType(IResolveContext resolveContext);
    public abstract virtual Int32[] get_Dimensions();
    public abstract virtual IList`1<ICSharpExpression> get_Sizes();
    public abstract virtual void SetArrayType(IArrayType arrayType);
    public abstract virtual void SetElementType(IType elementType);
    public abstract virtual void SetImplicitType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IArrayInitializer {
    public TreeNodeCollection`1<IVariableInitializer> ElementInitializers { get; }
    public TreeNodeEnumerable`1<IVariableInitializer> ElementInitializersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IVariableInitializer> get_ElementInitializers();
    public abstract virtual TreeNodeEnumerable`1<IVariableInitializer> get_ElementInitializersEnumerable();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetElementType(bool strict);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetElementType(IResolveContext resolveContext, bool strict);
    [NotNullAttribute]
public abstract virtual IVariableInitializer AddElementInitializerAfter(IVariableInitializer initializer, IVariableInitializer anchor);
    [NotNullAttribute]
public abstract virtual IVariableInitializer AddElementInitializerBefore(IVariableInitializer initializer, IVariableInitializer anchor);
    public abstract virtual void RemoveElementInitializer(IVariableInitializer initializer);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IArrayTypeUsage {
    public TreeNodeCollection`1<IRankSpecifier> ArrayRanks { get; }
    public TreeNodeEnumerable`1<IRankSpecifier> ArrayRanksEnumerable { get; }
    public ITypeUsage ElementType { get; }
    public abstract virtual TreeNodeCollection`1<IRankSpecifier> get_ArrayRanks();
    public abstract virtual TreeNodeEnumerable`1<IRankSpecifier> get_ArrayRanksEnumerable();
    public abstract virtual ITypeUsage get_ElementType();
    public abstract virtual ITypeUsage SetElementType(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IArrowExpressionClause {
    public ITokenNode BodyArrow { get; }
    public ICSharpExpression Expression { get; }
    public abstract virtual ITokenNode get_BodyArrow();
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAsExpression {
    public ICSharpExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public ITypeUsage TypeOperand { get; }
    public abstract virtual ICSharpExpression get_Operand();
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual ITypeUsage get_TypeOperand();
    public abstract virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public abstract virtual ITypeUsage SetTypeOperand(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAssignmentExpression {
    public ICSharpExpression Dest { get; }
    public ICSharpExpression Source { get; }
    public bool IsRefAssignment { get; }
    public bool IsCompoundAssignment { get; }
    public AssignmentType AssignmentType { get; }
    public abstract virtual ICSharpExpression get_Dest();
    public abstract virtual ICSharpExpression get_Source();
    public abstract virtual ICSharpExpression SetDest(ICSharpExpression param);
    public abstract virtual ICSharpExpression SetSource(ICSharpExpression param);
    public abstract virtual bool get_IsRefAssignment();
    public abstract virtual bool get_IsCompoundAssignment();
    public abstract virtual AssignmentType get_AssignmentType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAttribute {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public IReferenceName Name { get; }
    public TreeNodeCollection`1<IPropertyAssignment> PropertyAssignments { get; }
    public TreeNodeEnumerable`1<IPropertyAssignment> PropertyAssignmentsEnumerable { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ICSharpExpression> ConstructorArgumentExpressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ConstructorArgumentExpressionsEnumerable { get; }
    [NotNullAttribute]
public IReference ConstructorReference { get; }
    [CanBeNullAttribute]
public IReference TypeReference { get; }
    public AttributeTarget Target { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual IReferenceName get_Name();
    public abstract virtual TreeNodeCollection`1<IPropertyAssignment> get_PropertyAssignments();
    public abstract virtual TreeNodeEnumerable`1<IPropertyAssignment> get_PropertyAssignmentsEnumerable();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<ICSharpExpression> get_ConstructorArgumentExpressions();
    public abstract virtual TreeNodeEnumerable`1<ICSharpExpression> get_ConstructorArgumentExpressionsEnumerable();
    public abstract virtual IReferenceName SetName(IReferenceName param);
    public abstract virtual IReference get_ConstructorReference();
    public abstract virtual IReference get_TypeReference();
    public abstract virtual AttributeTarget get_Target();
    [NotNullAttribute]
public abstract virtual IPropertyAssignment AddPropertyAssignmentBefore(IPropertyAssignment propertyAssignment, IPropertyAssignment anchor);
    [NotNullAttribute]
public abstract virtual IPropertyAssignment AddPropertyAssignmentAfter(IPropertyAssignment propertyAssignment, IPropertyAssignment anchor);
    public abstract virtual void RemovePropertyAssignment(IPropertyAssignment propertyAssignment);
    public abstract virtual void SetTarget(AttributeTarget target);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAttributeList {
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual IAttribute AddAttributeBefore(IAttribute param, IAttribute anchor);
    public abstract virtual IAttribute AddAttributeAfter(IAttribute param, IAttribute anchor);
    public abstract virtual void RemoveAttribute(IAttribute param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAttributeSection {
    public IAttributeList AttributeList { get; }
    public ITokenNode Colon { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ICSharpIdentifier TargetIdentifier { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public AttributeTarget Target { get; }
    public abstract virtual IAttributeList get_AttributeList();
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual ICSharpIdentifier get_TargetIdentifier();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public abstract virtual IAttributeList SetAttributeList(IAttributeList param);
    public abstract virtual ICSharpIdentifier SetTargetIdentifier(ICSharpIdentifier param);
    public abstract virtual void RemoveAttribute(IAttribute attribute);
    public abstract virtual AttributeTarget get_Target();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAttributeSectionList {
    public TreeNodeCollection`1<IAttributeSection> Sections { get; }
    public TreeNodeEnumerable`1<IAttributeSection> SectionsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IAttributeSection> get_Sections();
    public abstract virtual TreeNodeEnumerable`1<IAttributeSection> get_SectionsEnumerable();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    [NotNullAttribute]
public abstract virtual IAttributeSection AddSectionBefore(IAttributeSection section, IAttributeSection anchor);
    [NotNullAttribute]
public abstract virtual IAttributeSection AddSectionAfter(IAttributeSection section, IAttributeSection anchor);
    public abstract virtual void RemoveSection(IAttributeSection section);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAttributesOwnerDeclaration {
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    [NotNullAttribute]
public abstract virtual IAttribute AddAttributeBefore(IAttribute attribute, IAttribute anchor);
    [NotNullAttribute]
public abstract virtual IAttribute AddAttributeAfter(IAttribute attribute, IAttribute anchor);
    [NotNullAttribute]
public abstract virtual IAttribute ReplaceAttribute(IAttribute attribute, IAttribute newAttribute);
    public abstract virtual void RemoveAttribute(IAttribute attribute);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitExpression {
    public ITokenNode AwaitKeyword { get; }
    public IUnaryExpression Task { get; }
    public abstract virtual ITokenNode get_AwaitKeyword();
    public abstract virtual IUnaryExpression get_Task();
    public abstract virtual IUnaryExpression SetTask(IUnaryExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IAwaitReferencesOwner {
    public bool IsAwait { get; }
    public TreeTextRange AwaitRange { get; }
    [CanBeNullAttribute]
public IManagedReference GetAwaiterReference { get; }
    [CanBeNullAttribute]
public IManagedReference AwaiterGetResultReference { get; }
    [CanBeNullAttribute]
public IManagedReference AwaiterOnCompletedReference { get; }
    [CanBeNullAttribute]
public IManagedReference AwaiterIsCompletedReference { get; }
    public abstract virtual bool get_IsAwait();
    public abstract virtual TreeTextRange get_AwaitRange();
    public abstract virtual IManagedReference get_GetAwaiterReference();
    public abstract virtual IManagedReference get_AwaiterGetResultReference();
    public abstract virtual IManagedReference get_AwaiterOnCompletedReference();
    public abstract virtual IManagedReference get_AwaiterIsCompletedReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IBaseExpression {
    public ITokenNode Base { get; }
    public abstract virtual ITokenNode get_Base();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IBinaryExpression {
    public ICSharpExpression LeftOperand { get; }
    public ICSharpExpression RightOperand { get; }
    [NotNullAttribute]
public IOperatorReference OperatorReference { get; }
    public abstract virtual ICSharpExpression get_LeftOperand();
    public abstract virtual ICSharpExpression get_RightOperand();
    public abstract virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public abstract virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public abstract virtual IOperatorReference get_OperatorReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IBinaryPattern {
    public IPattern LeftPattern { get; }
    public IPattern RightPattern { get; }
    public ITokenNode Keyword { get; }
    public abstract virtual IPattern get_LeftPattern();
    public abstract virtual IPattern get_RightPattern();
    public abstract virtual IPattern SetLeftPattern(IPattern param);
    public abstract virtual IPattern SetRightPattern(IPattern param);
    public abstract virtual ITokenNode get_Keyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IBitwiseAndExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IBitwiseExclusiveOrExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IBitwiseInclusiveOrExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IBlock {
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IBreakStatement {
    public ITokenNode BreakKeyword { get; }
    public ITokenNode Semicolon { get; }
    public abstract virtual ITokenNode get_BreakKeyword();
    public abstract virtual ITokenNode get_Semicolon();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICastExpression {
    public ITokenNode LPar { get; }
    public ICSharpExpression Op { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TargetType { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ICSharpExpression get_Op();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TargetType();
    public abstract virtual ICSharpExpression SetOp(ICSharpExpression param);
    public abstract virtual ITypeUsage SetTargetType(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICatchClause {
    public IBlock Body { get; }
    public ITokenNode CatchKeyword { get; }
    [CanBeNullAttribute]
public IExceptionFilterClause Filter { get; }
    public ICSharpExpression FilterCondition { get; }
    [NotNullAttribute]
public IDeclaredType ExceptionType { get; }
    public abstract virtual IBlock get_Body();
    public abstract virtual ITokenNode get_CatchKeyword();
    public abstract virtual IExceptionFilterClause get_Filter();
    public abstract virtual ICSharpExpression get_FilterCondition();
    public abstract virtual IBlock SetBody(IBlock param);
    public abstract virtual IExceptionFilterClause SetFilter(IExceptionFilterClause param);
    public abstract virtual ICSharpExpression SetFilterCondition(ICSharpExpression param);
    [NotNullAttribute]
public abstract virtual TCatchClause ReplaceBy(TCatchClause clause);
    public abstract virtual IDeclaredType get_ExceptionType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICatchVariableDeclaration {
    [NotNullAttribute]
public ILocalVariable DeclaredElement { get; }
    public abstract virtual ILocalVariable get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICheckedExpression {
    public ITokenNode CheckedKeyword { get; }
    public ITokenNode LPar { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ITokenNode get_CheckedKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ICSharpExpression get_Operand();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ICSharpExpression SetOperand(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICheckedStatement {
    public ITokenNode CheckedKeyword { get; }
    public abstract virtual ITokenNode get_CheckedKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IClassBody {
    public TreeNodeCollection`1<IMultipleConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> Constructors { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorsEnumerable { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> Destructors { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorsEnumerable { get; }
    public TreeNodeCollection`1<IMultipleEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMultipleFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IIndexerDeclaration> Indexers { get; }
    public TreeNodeEnumerable`1<IIndexerDeclaration> IndexersEnumerable { get; }
    public TreeNodeCollection`1<IMethodDeclaration> Methods { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodsEnumerable { get; }
    public TreeNodeCollection`1<IOperatorDeclaration> Operators { get; }
    public TreeNodeEnumerable`1<IOperatorDeclaration> OperatorsEnumerable { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> Properties { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertiesEnumerable { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> TypeDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IMultipleConstantDeclaration> get_ConstantDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IMultipleConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IConstructorDeclaration> get_Constructors();
    public abstract virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorsEnumerable();
    public abstract virtual TreeNodeCollection`1<IDestructorDeclaration> get_Destructors();
    public abstract virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorsEnumerable();
    public abstract virtual TreeNodeCollection`1<IMultipleEventDeclaration> get_EventDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IMultipleEventDeclaration> get_EventDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IMultipleFieldDeclaration> get_FieldDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IMultipleFieldDeclaration> get_FieldDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IIndexerDeclaration> get_Indexers();
    public abstract virtual TreeNodeEnumerable`1<IIndexerDeclaration> get_IndexersEnumerable();
    public abstract virtual TreeNodeCollection`1<IMethodDeclaration> get_Methods();
    public abstract virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodsEnumerable();
    public abstract virtual TreeNodeCollection`1<IOperatorDeclaration> get_Operators();
    public abstract virtual TreeNodeEnumerable`1<IOperatorDeclaration> get_OperatorsEnumerable();
    public abstract virtual TreeNodeCollection`1<IPropertyDeclaration> get_Properties();
    public abstract virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertiesEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_TypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_TypeDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IClassDeclaration {
    public ITokenNode ClassKeyword { get; }
    [CanBeNullAttribute]
public IExtendsList ExtendsList { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> DestructorDeclarations { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> InheritedTypeUsages { get; }
    public TreeNodeEnumerable`1<ITypeUsage> InheritedTypeUsagesEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    [CanBeNullAttribute]
public IClass DeclaredElement { get; }
    [CanBeNullAttribute]
public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<IFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public abstract virtual ITokenNode get_ClassKeyword();
    public abstract virtual IExtendsList get_ExtendsList();
    public abstract virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IDestructorDeclaration> get_DestructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeUsage> get_InheritedTypeUsages();
    public abstract virtual TreeNodeEnumerable`1<ITypeUsage> get_InheritedTypeUsagesEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public abstract virtual IExtendsList SetExtendsList(IExtendsList param);
    public abstract virtual IClass get_DeclaredElement();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual void SetSuperClass(IDeclaredType classType);
    public abstract virtual TreeNodeCollection`1<IFieldDeclaration> get_FieldDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IFieldDeclaration> get_FieldDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IClassLikeDeclaration {
    public IClassBody Body { get; }
    [CanBeNullAttribute]
public IPrimaryConstructorDeclaration PrimaryConstructorDeclaration { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IIndexerDeclaration> IndexerDeclarations { get; }
    public TreeNodeEnumerable`1<IIndexerDeclaration> IndexerDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IOperatorDeclaration> OperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IOperatorDeclaration> OperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    [CanBeNullAttribute]
public IExtendsList ExtendsList { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> DestructorDeclarations { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorDeclarationsEnumerable { get; }
    [CanBeNullAttribute]
public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ITypeUsage> SuperTypeUsageNodes { get; }
    public TreeNodeCollection`1<IClassMemberDeclaration> ClassMemberDeclarations { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    [CanBeNullAttribute]
public ITypeElement DeclaredElement { get; }
    public abstract virtual IClassBody get_Body();
    public abstract virtual IPrimaryConstructorDeclaration get_PrimaryConstructorDeclaration();
    public abstract virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IFieldDeclaration> get_FieldDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IFieldDeclaration> get_FieldDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IIndexerDeclaration> get_IndexerDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IIndexerDeclaration> get_IndexerDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_NestedTypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IOperatorDeclaration> get_OperatorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IOperatorDeclaration> get_OperatorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public abstract virtual IClassBody SetBody(IClassBody param);
    public abstract virtual IPrimaryConstructorDeclaration SetPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    public abstract virtual IExtendsList get_ExtendsList();
    [NotNullAttribute]
public abstract virtual IExtendsList GetOrCreateExtendsList();
    public abstract virtual TreeNodeCollection`1<IDestructorDeclaration> get_DestructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorDeclarationsEnumerable();
    public abstract virtual IModifiersList get_ModifiersList();
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public abstract virtual IModifiersList SetModifiersList(IModifiersList modifiersList);
    public abstract virtual TreeNodeCollection`1<ITypeUsage> get_SuperTypeUsageNodes();
    public abstract virtual TreeNodeCollection`1<IClassMemberDeclaration> get_ClassMemberDeclarations();
    public abstract virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    [NotNullAttribute]
public abstract virtual TClassMemberDeclaration AddClassMemberDeclaration(TClassMemberDeclaration declaration);
    [NotNullAttribute]
public abstract virtual TClassMemberDeclaration AddClassMemberDeclarationAfter(TClassMemberDeclaration declaration, IClassMemberDeclaration anchor);
    [NotNullAttribute]
public abstract virtual TClassMemberDeclaration AddClassMemberDeclarationBefore(TClassMemberDeclaration declaration, IClassMemberDeclaration anchor);
    [NotNullAttribute]
public abstract virtual TClassMemberDeclaration ReplaceClassMemberDeclaration(IClassMemberDeclaration oldDeclaration, TClassMemberDeclaration newDeclaration);
    public abstract virtual void RemoveClassMemberDeclaration(IClassMemberDeclaration declaration);
    [NotNullAttribute]
public abstract virtual TClassMemberDeclaration InsertAtSpecificPosition(TClassMemberDeclaration declaration, ITreeNode anchor);
    public abstract virtual void AddSuperInterface(IDeclaredType interfaceType, bool before);
    public abstract virtual void RemoveSuperInterface(IDeclaredType interfaceType);
    public abstract virtual ITypeElement get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IClassMemberDeclaration {
    public IModifiersList ModifiersList { get; }
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionElementInitializer {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    [NullableAttribute("1")]
public IReference ParamsDefaultConstructorReference { get; }
    [NullableAttribute("1")]
public IReference ParamsCreateMethodReference { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    [NullableContextAttribute("1")]
public abstract virtual IReference get_ParamsDefaultConstructorReference();
    [NullableContextAttribute("1")]
public abstract virtual IReference get_ParamsCreateMethodReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionExpression {
    public TreeNodeCollection`1<ICollectionExpressionElement> CollectionElements { get; }
    public TreeNodeEnumerable`1<ICollectionExpressionElement> CollectionElementsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    [NullableAttribute("1")]
public IReference CollectionCreateMethodReference { get; }
    [NullableAttribute("1")]
public IReference DefaultConstructorReference { get; }
    [NullableAttribute("1")]
public IReference AddReference { get; }
    public abstract virtual TreeNodeCollection`1<ICollectionExpressionElement> get_CollectionElements();
    public abstract virtual TreeNodeEnumerable`1<ICollectionExpressionElement> get_CollectionElementsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
    [PureAttribute]
public abstract virtual CollectionExpressionTargetTypeInfo GetTargetTypeInfo();
    [NullableContextAttribute("1")]
[PureAttribute]
public abstract virtual CollectionExpressionTargetTypeInfo GetTargetTypeInfo(IResolveContext resolveContext);
    [NullableContextAttribute("1")]
[PureAttribute]
public abstract virtual CollectionExpressionTargetTypeInfo GetTargetTypeInfo(IType targetType);
    [NullableContextAttribute("1")]
public abstract virtual IReference get_CollectionCreateMethodReference();
    [NullableContextAttribute("1")]
public abstract virtual IReference get_DefaultConstructorReference();
    [NullableContextAttribute("1")]
public abstract virtual IReference get_AddReference();
    [NullableContextAttribute("1")]
public abstract virtual ICollectionExpressionElement AddCollectionElementAfter(ICollectionExpressionElement element, ICollectionExpressionElement anchor);
    [NullableContextAttribute("1")]
public abstract virtual ICollectionExpressionElement AddCollectionElementBefore(ICollectionExpressionElement element, ICollectionExpressionElement anchor);
    [NullableContextAttribute("1")]
public abstract virtual void RemoveCollectionElement(ICollectionExpressionElement element);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionExpressionElement {
    public ICSharpInvocationReference AddReference { get; }
    public IReference ParamsDefaultConstructorReference { get; }
    public IReference ParamsCreateMethodReference { get; }
    public IReference ParamsAddReference { get; }
    public abstract virtual ICSharpInvocationReference get_AddReference();
    public abstract virtual IReference get_ParamsDefaultConstructorReference();
    public abstract virtual IReference get_ParamsCreateMethodReference();
    public abstract virtual IReference get_ParamsAddReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICollectionInitializer {
    public TreeNodeCollection`1<ICollectionElementInitializer> ElementInitializers { get; }
    public TreeNodeEnumerable`1<ICollectionElementInitializer> ElementInitializersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ICollectionElementInitializer> get_ElementInitializers();
    public abstract virtual TreeNodeEnumerable`1<ICollectionElementInitializer> get_ElementInitializersEnumerable();
    [NotNullAttribute]
public abstract virtual ICollectionElementInitializer AddElementInitializerAfter(ICollectionElementInitializer elementInitializer, ICollectionElementInitializer anchor);
    [NotNullAttribute]
public abstract virtual ICollectionElementInitializer AddElementInitializerBefore(ICollectionElementInitializer elementInitializer, ICollectionElementInitializer anchor);
    public abstract virtual void RemoveElementInitializer(ICollectionElementInitializer elementInitializer);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessExpression {
    public bool HasConditionalAccessSign { get; }
    [CanBeNullAttribute]
public ICSharpExpression ConditionalQualifier { get; }
    [CanBeNullAttribute]
public IConditionalAccessSign ConditionalAccessSign { get; }
    public abstract virtual bool get_HasConditionalAccessSign();
    public abstract virtual ICSharpExpression get_ConditionalQualifier();
    public abstract virtual ICSharpExpression SetConditionalQualifier(ICSharpExpression expression);
    public abstract virtual IConditionalAccessSign get_ConditionalAccessSign();
    public abstract virtual void SetConditionalAccessSign(bool value);
    [NotNullAttribute]
public abstract virtual IExpressionType UnliftedExpressionType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAccessSign {
    public ITokenNode Quest { get; }
    public abstract virtual ITokenNode get_Quest();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalAndExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalOrExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConditionalTernaryExpression {
    public ITokenNode Colon { get; }
    public ICSharpExpression ConditionOperand { get; }
    public ICSharpExpression ElseResult { get; }
    public ITokenNode Question { get; }
    public ICSharpExpression ThenResult { get; }
    public bool IsRefConditional { get; }
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual ICSharpExpression get_ConditionOperand();
    public abstract virtual ICSharpExpression get_ElseResult();
    public abstract virtual ITokenNode get_Question();
    public abstract virtual ICSharpExpression get_ThenResult();
    public abstract virtual ICSharpExpression SetConditionOperand(ICSharpExpression param);
    public abstract virtual ICSharpExpression SetElseResult(ICSharpExpression param);
    public abstract virtual ICSharpExpression SetThenResult(ICSharpExpression param);
    public abstract virtual bool get_IsRefConditional();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConstantDeclaration {
    public ICSharpExpression ValueExpression { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public IField DeclaredElement { get; }
    public abstract virtual ICSharpExpression get_ValueExpression();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public abstract virtual IField get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConstantOrTypePattern {
    public ICSharpExpression Expression { get; }
    [NotNullAttribute]
public ConstantValue ConstantValue { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    [PureAttribute]
public abstract virtual ConstantOrTypePatternKind GetKind(IResolveContext resolveContext, Nullable`1<bool> unresolvedIsType);
    public abstract virtual ConstantValue get_ConstantValue();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorConstraint {
    public ITokenNode LPar { get; }
    public ITokenNode NewKeyword { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_NewKeyword();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorDeclaration {
    [CanBeNullAttribute]
public IConstructorInitializer Initializer { get; }
    public ITokenNode LPar { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ICSharpIdentifier TypeName { get; }
    public IModifiersList ModifiersList { get; }
    [CanBeNullAttribute]
public IConstructor DeclaredElement { get; }
    public abstract virtual IConstructorInitializer get_Initializer();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual IFormalParameterList get_Params();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ICSharpIdentifier get_TypeName();
    public abstract virtual IConstructorInitializer SetInitializer(IConstructorInitializer param);
    public abstract virtual IFormalParameterList SetParams(IFormalParameterList param);
    public abstract virtual ICSharpIdentifier SetTypeName(ICSharpIdentifier param);
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IConstructor get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConstructorInitializer {
    public IArgumentList ArgumentList { get; }
    public ITokenNode Colon { get; }
    public ITokenNode Instance { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    [NotNullAttribute]
public ICSharpInvocationReference Reference { get; }
    public ConstructorInitializerKind Kind { get; }
    [CanBeNullAttribute]
public IDeclaredType ConstructedType { get; }
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual ITokenNode get_Instance();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
    public abstract virtual ICSharpInvocationReference get_Reference();
    public abstract virtual ConstructorInitializerKind get_Kind();
    public abstract virtual IDeclaredType get_ConstructedType();
    public abstract virtual void SetKind(ConstructorInitializerKind kind);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IContinueStatement {
    public ITokenNode ContinueKeyword { get; }
    public ITokenNode Semicolon { get; }
    public abstract virtual ITokenNode get_ContinueKeyword();
    public abstract virtual ITokenNode get_Semicolon();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IConversionOperatorDeclaration {
    public ITokenNode Modifier { get; }
    public IModifiersList ModifiersList { get; }
    public bool IsImplicit { get; }
    [CanBeNullAttribute]
public IFunction DeclaredElement { get; }
    public bool IsChecked { get; }
    public abstract virtual ITokenNode get_Modifier();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual bool get_IsImplicit();
    public abstract virtual IFunction get_DeclaredElement();
    public abstract virtual bool get_IsChecked();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICreationExpression {
    public ITokenNode NewKeyword { get; }
    [CanBeNullAttribute]
public ICreationExpressionInitializer Initializer { get; }
    public abstract virtual ITokenNode get_NewKeyword();
    public abstract virtual ICreationExpressionInitializer get_Initializer();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType ExplicitType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICreationExpressionInitializer {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<IInitializerElement> InitializerElements { get; }
    public TreeNodeEnumerable`1<IInitializerElement> InitializerElementsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual TreeNodeCollection`1<IInitializerElement> get_InitializerElements();
    public abstract virtual TreeNodeEnumerable`1<IInitializerElement> get_InitializerElementsEnumerable();
    [NotNullAttribute]
public abstract virtual IType GetConstructedType(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgument {
    [CanBeNullAttribute]
public ITokenNode Colon { get; }
    public ITokenNode Mode { get; }
    [CanBeNullAttribute]
public ICSharpIdentifier NameIdentifier { get; }
    [CanBeNullAttribute]
public ICSharpExpression Value { get; }
    public IArgumentList ContainingArgumentList { get; }
    [CanBeNullAttribute]
public IReference ParameterNameReference { get; }
    [NotNullAttribute]
public IReference ParamsAddReference { get; }
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual ITokenNode get_Mode();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpExpression get_Value();
    public abstract virtual IArgumentList get_ContainingArgumentList();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ICSharpExpression SetValue(ICSharpExpression param);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual bool IsValid();
    public abstract virtual IReference get_ParameterNameReference();
    public abstract virtual IReference get_ParamsAddReference();
    public abstract virtual void SetKind(ParameterKind parameterKind);
    public abstract virtual void SetArgumentName(string name);
    [NotNullAttribute]
public abstract virtual ICSharpArgument ReplaceBy(ICSharpArgument argument);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpArgumentsOwner {
    public TreeNodeCollection`1<ICSharpArgument> Arguments { get; }
    public TreeNodeEnumerable`1<ICSharpArgument> ArgumentsEnumerable { get; }
    [NotNullAttribute]
public IList`1<ITokenNode> Delimiters { get; }
    public ITokenNode LBound { get; }
    public ITokenNode RBound { get; }
    public abstract virtual TreeNodeCollection`1<ICSharpArgument> get_Arguments();
    public abstract virtual TreeNodeEnumerable`1<ICSharpArgument> get_ArgumentsEnumerable();
    public abstract virtual IList`1<ITokenNode> get_Delimiters();
    public abstract virtual ITokenNode get_LBound();
    public abstract virtual ITokenNode get_RBound();
    [NotNullAttribute]
public abstract virtual ICSharpArgument AddArgumentBefore(ICSharpArgument argument, ICSharpArgument anchor);
    [NotNullAttribute]
public abstract virtual ICSharpArgument AddArgumentAfter(ICSharpArgument argument, ICSharpArgument anchor);
    public abstract virtual void RemoveArgument(ICSharpArgument argument);
    public abstract virtual bool IsValid();
    [NotNullAttribute]
public abstract virtual IPsiServices GetPsiServices();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpClosure {
    public bool IsStatic { get; }
    public abstract virtual bool get_IsStatic();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpCommentNode {
    public CommentType CommentType { get; }
    public abstract virtual CommentType get_CommentType();
    [NotNullAttribute]
public abstract virtual ICSharpCommentNode ReplaceBy(ICSharpCommentNode commentNode);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDeclaration {
    [CanBeNullAttribute]
public ICSharpIdentifier NameIdentifier { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpDocCommentBlock {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpExpression {
    public bool IsClassifiedAsVariable { get; }
    public bool IsLValue { get; }
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ICSharpExpression GetContainingExpression();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ICSharpStatement GetContainingStatement();
    [PureAttribute]
public abstract virtual ExpressionClassification Classify(IResolveContext resolveContext);
    public abstract virtual bool get_IsClassifiedAsVariable();
    public abstract virtual bool get_IsLValue();
    [PureAttribute]
public abstract virtual ExpressionAccessType GetAccessType(IResolveContext resolveContext);
    [NotNullAttribute]
public abstract virtual TExpression ReplaceBy(TExpression expression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFile {
    public TreeNodeCollection`1<ICSharpNamespaceDeclaration> NamespaceDeclarationNodes { get; }
    public TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> NamespaceDeclarationNodesEnumerable { get; }
    public TreeNodeCollection`1<IAttributeSection> Sections { get; }
    public TreeNodeEnumerable`1<IAttributeSection> SectionsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    [CanBeNullAttribute]
public ITopLevelCode TopLevelCode { get; }
    public abstract virtual TreeNodeCollection`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationNodes();
    public abstract virtual TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationNodesEnumerable();
    public abstract virtual TreeNodeCollection`1<IAttributeSection> get_Sections();
    public abstract virtual TreeNodeEnumerable`1<IAttributeSection> get_SectionsEnumerable();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public abstract virtual ITopLevelCode get_TopLevelCode();
    public abstract virtual ITopLevelCode SetTopLevelCode(ITopLevelCode topLevelCode);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual PreProcessingDirectivesInFile GetPreprocessorConditionals();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual NullableContextCache GetNullableContextCache();
    public abstract virtual void InvalidateNullableContextCache();
    public abstract virtual void RemoveAttribute(IAttribute attribute);
    public abstract virtual void AddAttributeBefore(IAttribute attribute, IAttribute anchor);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpFunctionDeclaration {
    public IBlock Body { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    [CanBeNullAttribute]
public IFunction DeclaredElement { get; }
    public abstract virtual IBlock get_Body();
    public abstract virtual IBlock SetBody(IBlock param);
    public abstract virtual bool get_IsIterator();
    public abstract virtual bool get_IsAsync();
    public abstract virtual IFunction get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpIdentifier {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpLiteralExpression {
    public ITokenNode Literal { get; }
    public abstract virtual ITokenNode get_Literal();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpModifiersOwnerDeclaration {
    [CanBeNullAttribute]
public IModifiersList ModifiersList { get; }
    public abstract virtual IModifiersList get_ModifiersList();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpNamespaceDeclaration {
    public INamespaceBody Body { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode NamespaceKeyword { get; }
    [CanBeNullAttribute]
public IOwnerQualification NamespaceQualification { get; }
    public ITokenNode Semicolon { get; }
    public ICSharpNamespaceDeclaration ContainingNamespace { get; }
    [NotNullAttribute]
public string ShortName { get; }
    public bool IsFileScoped { get; }
    public abstract virtual INamespaceBody get_Body();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITokenNode get_NamespaceKeyword();
    public abstract virtual IOwnerQualification get_NamespaceQualification();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ICSharpNamespaceDeclaration get_ContainingNamespace();
    public abstract virtual INamespaceBody SetBody(INamespaceBody param);
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual IOwnerQualification SetNamespaceQualification(IOwnerQualification param);
    public abstract virtual string get_ShortName();
    public abstract virtual bool get_IsFileScoped();
    [NotNullAttribute]
public abstract virtual ICSharpNamespaceDeclaration ReplaceBy(ICSharpNamespaceDeclaration namespaceDeclaration);
    [NotNullAttribute]
public abstract virtual ICSharpNamespaceDeclaration AddNamespaceDeclarationBefore(ICSharpNamespaceDeclaration namespaceDeclaration, ICSharpNamespaceDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ICSharpNamespaceDeclaration AddNamespaceDeclarationAfter(ICSharpNamespaceDeclaration namespaceDeclaration, ICSharpNamespaceDeclaration anchor);
    public abstract virtual void RemoveNamespaceDeclaration(ICSharpNamespaceDeclaration namespaceDeclaration);
    public abstract virtual IEnumerable`1<INamespace> GetDeclaredNamespaces();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParameterDeclaration {
    public IAttributeSectionList AttributeSectionList { get; }
    public bool IsVarArg { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsOptional { get; }
    [CanBeNullAttribute]
public ICSharpExpression DefaultValue { get; }
    [CanBeNullAttribute]
public ICSharpIdentifier NameIdentifier { get; }
    [CanBeNullAttribute]
public ITypeUsage TypeUsage { get; }
    public abstract virtual IAttributeSectionList get_AttributeSectionList();
    public abstract virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public abstract virtual bool get_IsVarArg();
    public abstract virtual ParameterKind get_Kind();
    public abstract virtual bool get_IsParams();
    public abstract virtual bool get_IsParameterArray();
    public abstract virtual bool get_IsParameterCollection();
    public abstract virtual bool get_IsOptional();
    public abstract virtual ICSharpExpression get_DefaultValue();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITypeUsage get_TypeUsage();
    [NotNullAttribute]
public abstract virtual TParameterDeclaration ReplaceBy(TParameterDeclaration declaration);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpParametersOwnerDeclaration {
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    [CanBeNullAttribute]
public IParametersOwner DeclaredElement { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
    [NotNullAttribute]
public abstract virtual ICSharpParameterDeclaration AddParameterDeclarationBefore(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ICSharpParameterDeclaration AddParameterDeclarationAfter(ICSharpParameterDeclaration parameterDeclaration, ICSharpParameterDeclaration anchor);
    public abstract virtual void RemoveParameterDeclaration(ICSharpParameterDeclaration parameterDeclaration);
    public abstract virtual IParametersOwner get_DeclaredElement();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpRegularParameterDeclaration {
    [CanBeNullAttribute]
public ICSharpExpression DefaultValue { get; }
    [CanBeNullAttribute]
public ITokenNode EqSign { get; }
    public IParameterModifiersList ParameterModifiersList { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public ITokenNode ParamsKeyword { get; }
    [CanBeNullAttribute]
public ITokenNode ThisKeyword { get; }
    [CanBeNullAttribute]
public ITokenNode ScopedKeyword { get; }
    [CanBeNullAttribute]
public IReference ParamsDefaultConstructorReference { get; }
    [CanBeNullAttribute]
public IReference ParamsCreateMethodReference { get; }
    [CanBeNullAttribute]
public IReference ParamsAnyArgumentAddMethodReference { get; }
    public abstract virtual ICSharpExpression get_DefaultValue();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IParameterModifiersList get_ParameterModifiersList();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ICSharpExpression SetDefaultValue(ICSharpExpression param);
    public abstract virtual IParameterModifiersList SetParameterModifiersList(IParameterModifiersList param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual ITokenNode get_ParamsKeyword();
    public abstract virtual ITokenNode get_ThisKeyword();
    public abstract virtual ITokenNode get_ScopedKeyword();
    public abstract virtual IReference get_ParamsDefaultConstructorReference();
    public abstract virtual IReference get_ParamsCreateMethodReference();
    public abstract virtual IReference get_ParamsAnyArgumentAddMethodReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpStatement {
    public bool CanBeEmbedded { get; }
    [CanBeNullAttribute]
public abstract virtual ICSharpStatement GetContainingStatement();
    public abstract virtual bool get_CanBeEmbedded();
    [NotNullAttribute]
public abstract virtual TStatement ReplaceBy(TStatement statement);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTreeNode {
    public abstract virtual void Accept(TreeNodeVisitor visitor);
    public abstract virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public abstract virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeAndNamespaceHolderDeclaration {
    public TreeNodeCollection`1<IExternAliasDirective> ExternAliases { get; }
    public TreeNodeEnumerable`1<IExternAliasDirective> ExternAliasesEnumerable { get; }
    public TreeNodeCollection`1<IUsingDirective> Imports { get; }
    public TreeNodeEnumerable`1<IUsingDirective> ImportsEnumerable { get; }
    public IUsingList ImportsList { get; }
    public TreeNodeCollection`1<ICSharpNamespaceDeclaration> NamespaceDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> NamespaceDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpTypeDeclaration> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpTypeDeclaration> TypeDeclarationsEnumerable { get; }
    [CanBeNullAttribute]
public ICSharpTypeAndNamespaceHolderDeclaration ContainingTypeAndNamespaceHolder { get; }
    public abstract virtual TreeNodeCollection`1<IExternAliasDirective> get_ExternAliases();
    public abstract virtual TreeNodeEnumerable`1<IExternAliasDirective> get_ExternAliasesEnumerable();
    public abstract virtual TreeNodeCollection`1<IUsingDirective> get_Imports();
    public abstract virtual TreeNodeEnumerable`1<IUsingDirective> get_ImportsEnumerable();
    public abstract virtual IUsingList get_ImportsList();
    public abstract virtual TreeNodeCollection`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpTypeDeclaration> get_TypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ICSharpTypeDeclaration> get_TypeDeclarationsEnumerable();
    public abstract virtual IUsingList SetImportsList(IUsingList param);
    public abstract virtual ICSharpTypeAndNamespaceHolderDeclaration get_ContainingTypeAndNamespaceHolder();
    [NotNullAttribute]
public abstract virtual IUsingDirective AddImportAfter(IUsingDirective usingDirective, IUsingDirective anchor);
    [NotNullAttribute]
public abstract virtual IUsingDirective AddImportBefore(IUsingDirective usingDirective, IUsingDirective anchor);
    [NotNullAttribute]
public abstract virtual IUsingDirective AddImport(IUsingDirective usingDirective, bool saveUsingListPosition);
    public abstract virtual void RemoveImport(IUsingDirective usingDirective);
    [NotNullAttribute]
public abstract virtual ICSharpTypeDeclaration AddTypeDeclarationBefore(ICSharpTypeDeclaration typeDeclaration, ICSharpTypeDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ICSharpTypeDeclaration AddTypeDeclarationAfter(ICSharpTypeDeclaration typeDeclaration, ICSharpTypeDeclaration anchor);
    public abstract virtual void RemoveTypeDeclaration(ICSharpTypeDeclaration typeDeclaration);
    [NotNullAttribute]
public abstract virtual ICSharpNamespaceDeclaration AddNamespaceDeclarationBefore(ICSharpNamespaceDeclaration namespaceDeclaration, ICSharpNamespaceDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ICSharpNamespaceDeclaration AddNamespaceDeclarationAfter(ICSharpNamespaceDeclaration namespaceDeclaration, ICSharpNamespaceDeclaration anchor);
    public abstract virtual void RemoveNamespaceDeclaration(ICSharpNamespaceDeclaration namespaceDeclaration);
    [NotNullAttribute]
public abstract virtual IExternAliasDirective AddExternAliasAfter(IExternAliasDirective externAlias, IExternAliasDirective anchor);
    [NotNullAttribute]
public abstract virtual IExternAliasDirective AddExternAliasBefore(IExternAliasDirective externAlias, IExternAliasDirective anchor);
    public abstract virtual void RemoveExternAlias(IExternAliasDirective externAlias);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IUsingDirective> GetEffectiveUsingDirectives();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeDeclaration {
    public ICSharpIdentifier NameIdentifier { get; }
    [CanBeNullAttribute]
public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    [CanBeNullAttribute]
public ITypeParameterOfTypeList TypeParameterList { get; }
    public IModifiersList ModifiersList { get; }
    public ICSharpNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParametersEnumerable { get; }
    [NotNullAttribute]
public ITokenNode TypeDeclarationKeyword { get; }
    public bool IsPartial { get; }
    public TreeNodeCollection`1<ICSharpTypeMemberDeclaration> MemberDeclarations { get; }
    [CanBeNullAttribute]
public ITypeElement DeclaredElement { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public abstract virtual ITypeParameterOfTypeList get_TypeParameterList();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual ICSharpNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParametersEnumerable();
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public abstract virtual ITokenNode get_TypeDeclarationKeyword();
    public abstract virtual bool get_IsPartial();
    public abstract virtual void SetPartial(bool value);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration typeParameterDeclaration, ITypeParameterOfTypeDeclaration anchor);
    public abstract virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration typeParameterDeclaration);
    [NotNullAttribute]
public abstract virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    [NotNullAttribute]
public abstract virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public abstract virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
    public abstract virtual TreeNodeCollection`1<ICSharpTypeMemberDeclaration> get_MemberDeclarations();
    public abstract virtual bool CanBindTo(ITypeElement typeElement);
    public abstract virtual ITypeElement get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ICSharpTypeMemberDeclaration {
    [NullableAttribute("2")]
public ITypeMember DeclaredElement { get; }
    [NullableContextAttribute("2")]
[PureAttribute]
public abstract virtual ICSharpTypeDeclaration GetContainingTypeDeclaration();
    [NullableContextAttribute("2")]
public abstract virtual ITypeMember get_DeclaredElement();
}
[NullableContextAttribute("2")]
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDecisionDagOwner {
    public ICSharpExpression GoverningExpression { get; }
    public abstract virtual ICSharpExpression get_GoverningExpression();
    [NullableContextAttribute("1")]
public abstract virtual DecisionDag GetOrCreateDecisionDag(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDeclarationExpression {
    public IVariableDesignation Designation { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode RefReadonlyKeyword { get; }
    public ITokenNode ScopedKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public ITokenNode VarKeyword { get; }
    public ITreeNode TypeDesignator { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsVar { get; }
    public abstract virtual IVariableDesignation get_Designation();
    public abstract virtual ITokenNode get_RefKeyword();
    public abstract virtual ITokenNode get_RefReadonlyKeyword();
    public abstract virtual ITokenNode get_ScopedKeyword();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ITokenNode get_VarKeyword();
    public abstract virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual ITreeNode get_TypeDesignator();
    public abstract virtual ReferenceKind get_ReferenceKind();
    public abstract virtual bool get_IsVar();
    public abstract virtual void SetVar();
    public abstract virtual void SetScoped(bool addScopedKeyword);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDeclarationStatement {
    public IMultipleDeclaration Declaration { get; }
    public ILocalFunctionDeclaration LocalFunctionDeclaration { get; }
    public ITokenNode Semicolon { get; }
    public TreeNodeCollection`1<ILocalConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ILocalVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public abstract virtual IMultipleDeclaration get_Declaration();
    public abstract virtual ILocalFunctionDeclaration get_LocalFunctionDeclaration();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual TreeNodeCollection`1<ILocalConstantDeclaration> get_ConstantDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ILocalVariableDeclaration> get_VariableDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalVariableDeclaration> get_VariableDeclarationsEnumerable();
    public abstract virtual IMultipleDeclaration SetDeclaration(IMultipleDeclaration param);
    public abstract virtual ILocalFunctionDeclaration SetLocalFunctionDeclaration(ILocalFunctionDeclaration param);
    public abstract virtual void RemoveConstantDeclaration(ILocalConstantDeclaration param);
    public abstract virtual void RemoveVariableDeclaration(ILocalVariableDeclaration param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDeconstructionPatternClause {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<ISubpattern> Patterns { get; }
    public TreeNodeEnumerable`1<ISubpattern> PatternsEnumerable { get; }
    public ITokenNode RPar { get; }
    [NotNullAttribute]
public IDeconstructionReference DeconstructionReference { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual TreeNodeCollection`1<ISubpattern> get_Patterns();
    public abstract virtual TreeNodeEnumerable`1<ISubpattern> get_PatternsEnumerable();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IDeconstructionReference get_DeconstructionReference();
    [PureAttribute]
public abstract virtual int IndexOfSubpattern(ISubpattern subpattern);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetSourceType(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetSubpatternType(ISubpattern subpattern, IResolveContext resolveContext);
    public abstract virtual bool IsValid();
    [NotNullAttribute]
public abstract virtual IPsiServices GetPsiServices();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDefaultConstraint {
    public ITokenNode Keyword { get; }
    public abstract virtual ITokenNode get_Keyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDefaultExpression {
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeName { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TypeName();
    public abstract virtual ITypeUsage SetTypeName(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDefineDirective {
    public ITokenNode Name { get; }
    [NotNullAttribute]
public string SymbolName { get; }
    public abstract virtual ITokenNode get_Name();
    public abstract virtual string get_SymbolName();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDelegateDeclaration {
    public ITokenNode Keyword { get; }
    public ITokenNode LPar { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode RefReadonlyKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    [CanBeNullAttribute]
public IDelegate DeclaredElement { get; }
    [NotNullAttribute]
public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual IFormalParameterList get_Params();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_RefKeyword();
    public abstract virtual ITokenNode get_RefReadonlyKeyword();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public abstract virtual IFormalParameterList SetParams(IFormalParameterList param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IDelegate get_DeclaredElement();
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public abstract virtual IModifiersList SetModifiersList(IModifiersList modifiersList);
    public abstract virtual IType get_ReturnType();
    public abstract virtual ReferenceKind get_ReturnKind();
    public abstract virtual void SetReturnKind(ReferenceKind referenceKind);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDestructorDeclaration {
    public ITokenNode LPar { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Tilde { get; }
    public ICSharpIdentifier TypeName { get; }
    [CanBeNullAttribute]
public IFunction DeclaredElement { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual IFormalParameterList get_Params();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_Tilde();
    public abstract virtual ICSharpIdentifier get_TypeName();
    public abstract virtual IFormalParameterList SetParams(IFormalParameterList param);
    public abstract virtual ICSharpIdentifier SetTypeName(ICSharpIdentifier param);
    public abstract virtual IFunction get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDiscardDesignation {
    public ICSharpIdentifier UnderscoreIdentifier { get; }
    public abstract virtual ICSharpIdentifier get_UnderscoreIdentifier();
    public abstract virtual ICSharpIdentifier SetUnderscoreIdentifier(ICSharpIdentifier param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDiscardPattern {
    public ICSharpIdentifier Underscore { get; }
    public abstract virtual ICSharpIdentifier get_Underscore();
    public abstract virtual ICSharpIdentifier SetUnderscore(ICSharpIdentifier param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDisposeMethodReference {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetResourceExpressionType(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetResourceExpressionType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDisposeMethodReferenceOwner {
    [CanBeNullAttribute]
public IDisposeMethodReference DisposeReference { get; }
    public TreeTextRange UsingRange { get; }
    public abstract virtual IDisposeMethodReference get_DisposeReference();
    public abstract virtual TreeTextRange get_UsingRange();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCommentNode {
    [NotNullAttribute]
public abstract virtual IDocCommentNode ReplaceBy(IDocCommentNode docCommentNode);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCRefElement {
    public ITokenNode CheckedKeyword { get; }
    public ITokenNode Delimiter { get; }
    public ITokenNode ExplicitKeyword { get; }
    public ITokenNode ImplicitKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode Name { get; }
    public ITokenNode OperatorKeyword { get; }
    public ITokenNode OperatorSign { get; }
    public IDocCRefElement Qualifier { get; }
    public ITokenNode RPar { get; }
    public IDocCRefSignature Signature { get; }
    public ITokenNode ThisKeyword { get; }
    public IDocCRefTypeParameterList TypeParameterList { get; }
    public abstract virtual ITokenNode get_CheckedKeyword();
    public abstract virtual ITokenNode get_Delimiter();
    public abstract virtual ITokenNode get_ExplicitKeyword();
    public abstract virtual ITokenNode get_ImplicitKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_Name();
    public abstract virtual ITokenNode get_OperatorKeyword();
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual IDocCRefElement get_Qualifier();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IDocCRefSignature get_Signature();
    public abstract virtual ITokenNode get_ThisKeyword();
    public abstract virtual IDocCRefTypeParameterList get_TypeParameterList();
    public abstract virtual IDocCRefElement SetQualifier(IDocCRefElement param);
    public abstract virtual IDocCRefSignature SetSignature(IDocCRefSignature param);
    public abstract virtual IDocCRefTypeParameterList SetTypeParameterList(IDocCRefTypeParameterList param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCRefExpression {
    public IDocCRefElement Element { get; }
    public abstract virtual IDocCRefElement get_Element();
    public abstract virtual IDocCRefElement SetElement(IDocCRefElement param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCRefParameter {
    public ITokenNode InKeyword { get; }
    public ITokenNode OutKeyword { get; }
    public IDocCRefParameterType ParameterType { get; }
    public ITokenNode ReadonlyKeyword { get; }
    public ITokenNode RefKeyword { get; }
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual ITokenNode get_OutKeyword();
    public abstract virtual IDocCRefParameterType get_ParameterType();
    public abstract virtual ITokenNode get_ReadonlyKeyword();
    public abstract virtual ITokenNode get_RefKeyword();
    public abstract virtual IDocCRefParameterType SetParameterType(IDocCRefParameterType param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCRefParameterType {
    public TreeNodeCollection`1<IRankSpecifier> ArrayRanks { get; }
    public TreeNodeEnumerable`1<IRankSpecifier> ArrayRanksEnumerable { get; }
    public INullableTypeMark NullableMark { get; }
    public TreeNodeCollection`1<IUnsafeCodePointer> PointerMarks { get; }
    public TreeNodeEnumerable`1<IUnsafeCodePointer> PointerMarksEnumerable { get; }
    public IDocCRefParameterTypeName TypeName { get; }
    public abstract virtual TreeNodeCollection`1<IRankSpecifier> get_ArrayRanks();
    public abstract virtual TreeNodeEnumerable`1<IRankSpecifier> get_ArrayRanksEnumerable();
    public abstract virtual INullableTypeMark get_NullableMark();
    public abstract virtual TreeNodeCollection`1<IUnsafeCodePointer> get_PointerMarks();
    public abstract virtual TreeNodeEnumerable`1<IUnsafeCodePointer> get_PointerMarksEnumerable();
    public abstract virtual IDocCRefParameterTypeName get_TypeName();
    public abstract virtual INullableTypeMark SetNullableMark(INullableTypeMark param);
    public abstract virtual IDocCRefParameterTypeName SetTypeName(IDocCRefParameterTypeName param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCRefParameterTypeName {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode Delimiter { get; }
    public ITokenNode Name { get; }
    public IDocCRefParameterTypeName Qualifier { get; }
    public TreeNodeCollection`1<IDocCRefParameterType> TypeArguments { get; }
    public TreeNodeEnumerable`1<IDocCRefParameterType> TypeArgumentsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_Delimiter();
    public abstract virtual ITokenNode get_Name();
    public abstract virtual IDocCRefParameterTypeName get_Qualifier();
    public abstract virtual TreeNodeCollection`1<IDocCRefParameterType> get_TypeArguments();
    public abstract virtual TreeNodeEnumerable`1<IDocCRefParameterType> get_TypeArgumentsEnumerable();
    public abstract virtual IDocCRefParameterTypeName SetQualifier(IDocCRefParameterTypeName param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCRefSignature {
    public TreeNodeCollection`1<IDocCRefParameter> Parameters { get; }
    public TreeNodeEnumerable`1<IDocCRefParameter> ParametersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IDocCRefParameter> get_Parameters();
    public abstract virtual TreeNodeEnumerable`1<IDocCRefParameter> get_ParametersEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCRefTypeParameter {
    public ITokenNode Name { get; }
    public abstract virtual ITokenNode get_Name();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDocCRefTypeParameterList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IDocCRefTypeParameter> TypeParameters { get; }
    public TreeNodeEnumerable`1<IDocCRefTypeParameter> TypeParametersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IDocCRefTypeParameter> get_TypeParameters();
    public abstract virtual TreeNodeEnumerable`1<IDocCRefTypeParameter> get_TypeParametersEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IDoStatement {
    public ICSharpStatement Body { get; }
    public ICSharpExpression Condition { get; }
    public ITokenNode DoKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode WhileKeyword { get; }
    public abstract virtual ICSharpStatement get_Body();
    public abstract virtual ICSharpExpression get_Condition();
    public abstract virtual ITokenNode get_DoKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ITokenNode get_WhileKeyword();
    public abstract virtual ICSharpStatement SetBody(ICSharpStatement param);
    public abstract virtual ICSharpExpression SetCondition(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IElementAccessExpression {
    public IArgumentList ArgumentList { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode LBracket { get; }
    public IPrimaryExpression Operand { get; }
    public ITokenNode RBracket { get; }
    [NotNullAttribute]
public IElementAccessExpressionReference ElementAccessReference { get; }
    [NotNullAttribute]
public IElementAccessExpressionReference Reference { get; }
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual IConditionalAccessSign get_ConditionalAccessSign();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual IPrimaryExpression get_Operand();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
    public abstract virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public abstract virtual IPrimaryExpression SetOperand(IPrimaryExpression param);
    public abstract virtual IElementAccessExpressionReference get_ElementAccessReference();
    public abstract virtual IElementAccessExpressionReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IElementAccessExpressionReference {
    [PureAttribute]
public abstract virtual bool IsPassThrough(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IElifDirective {
    public IPreprocessorExpression Condition { get; }
    public abstract virtual IPreprocessorExpression get_Condition();
    public abstract virtual IPreprocessorExpression SetCondition(IPreprocessorExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IElseDirective {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEmptyStatement {
    public ITokenNode Semicolon { get; }
    public abstract virtual ITokenNode get_Semicolon();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEndifDirective {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEndRegion {
    public ITokenNode Message { get; }
    [NotNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public IStartRegion StartRegion { get; }
    public abstract virtual ITokenNode get_Message();
    public abstract virtual string get_Name();
    public abstract virtual IStartRegion get_StartRegion();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEnumBase {
    public ITokenNode Colon { get; }
    public ITypeUsage UnderlyingType { get; }
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual ITypeUsage get_UnderlyingType();
    public abstract virtual ITypeUsage SetUnderlyingType(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEnumBody {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IEnumMemberDeclaration> Members { get; }
    public TreeNodeEnumerable`1<IEnumMemberDeclaration> MembersEnumerable { get; }
    public IEnumDeclaration Owner { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IEnumMemberDeclaration> get_Members();
    public abstract virtual TreeNodeEnumerable`1<IEnumMemberDeclaration> get_MembersEnumerable();
    public abstract virtual IEnumDeclaration get_Owner();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEnumDeclaration {
    public IEnumBody EnumBody { get; }
    public ITokenNode Keyword { get; }
    public TreeNodeCollection`1<IEnumMemberDeclaration> EnumMemberDeclarations { get; }
    public TreeNodeEnumerable`1<IEnumMemberDeclaration> EnumMemberDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public ITypeUsage UnderlyingTypeUsage { get; }
    public IModifiersList ModifiersList { get; }
    [CanBeNullAttribute]
public IEnum DeclaredElement { get; }
    public abstract virtual IEnumBody get_EnumBody();
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual TreeNodeCollection`1<IEnumMemberDeclaration> get_EnumMemberDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IEnumMemberDeclaration> get_EnumMemberDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public abstract virtual ITypeUsage get_UnderlyingTypeUsage();
    public abstract virtual IEnumBody SetEnumBody(IEnumBody param);
    public abstract virtual ITypeUsage SetUnderlyingTypeUsage(ITypeUsage param);
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IEnum get_DeclaredElement();
    [NotNullAttribute]
public abstract virtual IType GetUnderlyingType();
    public abstract virtual void SetUnderlyingType(IDeclaredType declaredType);
    [NotNullAttribute]
public abstract virtual IEnumMemberDeclaration AddEnumMemberDeclarationBefore(IEnumMemberDeclaration enumMemberDeclaration, IEnumMemberDeclaration anchor);
    [NotNullAttribute]
public abstract virtual IEnumMemberDeclaration AddEnumMemberDeclarationAfter(IEnumMemberDeclaration enumMemberDeclaration, IEnumMemberDeclaration anchor);
    public abstract virtual void RemoveEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclaration);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEnumMemberDeclaration {
    public ITokenNode EquivalenceSign { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ICSharpExpression ValueExpression { get; }
    public IEnumDeclaration DeclaringEnum { get; }
    [CanBeNullAttribute]
public IEnumMemberDeclaration PreviousDeclaration { get; }
    [CanBeNullAttribute]
public IEnumMemberDeclaration NextDeclaration { get; }
    [CanBeNullAttribute]
public IField EnumMember { get; }
    public abstract virtual ITokenNode get_EquivalenceSign();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpExpression get_ValueExpression();
    public abstract virtual IEnumDeclaration get_DeclaringEnum();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public abstract virtual IEnumMemberDeclaration get_PreviousDeclaration();
    public abstract virtual IEnumMemberDeclaration get_NextDeclaration();
    public abstract virtual IField get_EnumMember();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEqualityExpression {
    public EqualityExpressionType EqualityType { get; }
    public abstract virtual EqualityExpressionType get_EqualityType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IErrorDirective {
    public ITokenNode Message { get; }
    public abstract virtual ITokenNode get_Message();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IEventDeclaration {
    public IVariableInitializer Initial { get; }
    public ITypeUsage DelegateTypeUsage { get; }
    public bool IsFieldLikeEvent { get; }
    [CanBeNullAttribute]
public IEvent DeclaredElement { get; }
    public abstract virtual IVariableInitializer get_Initial();
    public abstract virtual ITypeUsage get_DelegateTypeUsage();
    public abstract virtual ITypeUsage SetDelegateTypeUsage(ITypeUsage param);
    public abstract virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public abstract virtual bool get_IsFieldLikeEvent();
    public abstract virtual IEvent get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IExceptionFilterClause {
    public ICSharpExpression Condition { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode WhenKeyword { get; }
    public abstract virtual ICSharpExpression get_Condition();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_WhenKeyword();
    public abstract virtual ICSharpExpression SetCondition(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionBodyOwnerDeclaration {
    public IArrowExpressionClause ArrowClause { get; }
    public ITokenNode Semicolon { get; }
    public abstract virtual IArrowExpressionClause get_ArrowClause();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual IArrowExpressionClause SetArrowClause(IArrowExpressionClause param);
    [ContractAnnotationAttribute("expression: null => null; expression: notnull => notnull")]
public abstract virtual ICSharpExpression SetBodyExpression(ICSharpExpression expression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionElement {
    public ICSharpExpression Expression { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionInitializer {
    public ICSharpExpression Value { get; }
    public abstract virtual ICSharpExpression get_Value();
    public abstract virtual ICSharpExpression SetValue(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IExpressionStatement {
    public ICSharpExpression Expression { get; }
    public ITokenNode Semicolon { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IExtendedType {
    public IArgumentList ArgumentList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public ICSharpInvocationReference ConstructorReference { get; }
    [CanBeNullAttribute]
public IReference TypeReference { get; }
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual ICSharpInvocationReference get_ConstructorReference();
    public abstract virtual IReference get_TypeReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IExtendsList {
    public ITokenNode Colon { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IExtendedType> ExtendedTypes { get; }
    public TreeNodeEnumerable`1<IExtendedType> ExtendedTypesEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> ExtendedInterfaces { get; }
    public TreeNodeEnumerable`1<ITypeUsage> ExtendedInterfacesEnumerable { get; }
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IExtendedType> get_ExtendedTypes();
    public abstract virtual TreeNodeEnumerable`1<IExtendedType> get_ExtendedTypesEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeUsage> get_ExtendedInterfaces();
    public abstract virtual TreeNodeEnumerable`1<ITypeUsage> get_ExtendedInterfacesEnumerable();
    [NotNullAttribute]
public abstract virtual IExtendedType AddExtendedTypeBefore(IExtendedType extendedType, IExtendedType anchor);
    [NotNullAttribute]
public abstract virtual IExtendedType AddExtendedTypeAfter(IExtendedType extendedType, IExtendedType anchor);
    public abstract virtual void RemoveExtendedType(IExtendedType extendedType);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IExternAliasDirective {
    public ITokenNode AliasKeyword { get; }
    public ITokenNode Keyword { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode Semicolon { get; }
    public abstract virtual ITokenNode get_AliasKeyword();
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.IfDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIfDirective GetByCondition(IPreprocessorExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IFieldDeclaration {
    public ICSharpExpression FixedBufferSizeExpression { get; }
    public IVariableInitializer Initial { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public IField DeclaredElement { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public abstract virtual ICSharpExpression get_FixedBufferSizeExpression();
    public abstract virtual IVariableInitializer get_Initial();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ICSharpExpression SetFixedBufferSizeExpression(ICSharpExpression param);
    public abstract virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IField get_DeclaredElement();
    public abstract virtual bool get_IsRequired();
    public abstract virtual void SetRequired(bool value);
    public abstract virtual ReferenceKind get_ReferenceKind();
    public abstract virtual void SetReferenceKind(ReferenceKind referenceKind);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IFixedPatternMethodReference {
    [PureAttribute]
[NotNullAttribute]
public abstract virtual IType GetSourceType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IForeachHeader {
    public ICSharpExpression Collection { get; }
    public IDeclarationExpression DeclarationExpression { get; }
    public ITupleExpression DeconstructionTuple { get; }
    public ITokenNode InKeyword { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<ISingleVariableDesignation> IteratorDeclarations { get; }
    public abstract virtual ICSharpExpression get_Collection();
    public abstract virtual IDeclarationExpression get_DeclarationExpression();
    public abstract virtual ITupleExpression get_DeconstructionTuple();
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual ICSharpExpression SetCollection(ICSharpExpression param);
    public abstract virtual IDeclarationExpression SetDeclarationExpression(IDeclarationExpression param);
    public abstract virtual ITupleExpression SetDeconstructionTuple(ITupleExpression param);
    public abstract virtual IEnumerable`1<ISingleVariableDesignation> get_IteratorDeclarations();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IForeachPatternReference {
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IForeachReferencesOwner {
    public TreeTextRange IterationReferencesRange { get; }
    public bool IsAwait { get; }
    [NullableAttribute("2")]
public ICSharpExpression Collection { get; }
    public IForeachPatternReference GetEnumeratorReference { get; }
    public IForeachPatternReference MoveNextReference { get; }
    public IForeachPatternReference CurrentReference { get; }
    public abstract virtual TreeTextRange get_IterationReferencesRange();
    public abstract virtual bool get_IsAwait();
    [NullableContextAttribute("2")]
public abstract virtual ICSharpExpression get_Collection();
    public abstract virtual IForeachPatternReference get_GetEnumeratorReference();
    public abstract virtual IForeachPatternReference get_MoveNextReference();
    public abstract virtual IForeachPatternReference get_CurrentReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IForeachStatement {
    public ITokenNode AwaitKeyword { get; }
    public ICSharpStatement Body { get; }
    public IForeachHeader ForeachHeader { get; }
    public ITokenNode ForeachKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ICSharpExpression Collection { get; }
    [CanBeNullAttribute]
public string IteratorName { get; }
    [NotNullAttribute]
public IEnumerable`1<ISingleVariableDesignation> IteratorDeclarations { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<ICSharpLocalVariable> IteratorVariables { get; }
    [CanBeNullAttribute]
public ITreeNode IteratorDeclarationsContainer { get; }
    public bool IsAwait { get; }
    public abstract virtual ITokenNode get_AwaitKeyword();
    public abstract virtual ICSharpStatement get_Body();
    public abstract virtual IForeachHeader get_ForeachHeader();
    public abstract virtual ITokenNode get_ForeachKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ICSharpExpression get_Collection();
    public abstract virtual ICSharpStatement SetBody(ICSharpStatement param);
    public abstract virtual ICSharpExpression SetCollection(ICSharpExpression param);
    public abstract virtual IForeachHeader SetForeachHeader(IForeachHeader param);
    public abstract virtual string get_IteratorName();
    public abstract virtual IEnumerable`1<ISingleVariableDesignation> get_IteratorDeclarations();
    public abstract virtual IEnumerable`1<ICSharpLocalVariable> get_IteratorVariables();
    public abstract virtual ITreeNode get_IteratorDeclarationsContainer();
    public abstract virtual bool get_IsAwait();
    public abstract virtual void SetAwait(bool isAwait);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IForInitializer {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IMultipleLocalVariableDeclaration Declaration { get; }
    public TreeNodeCollection`1<ICSharpExpression> Expressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ExpressionsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual IMultipleLocalVariableDeclaration get_Declaration();
    public abstract virtual TreeNodeCollection`1<ICSharpExpression> get_Expressions();
    public abstract virtual TreeNodeEnumerable`1<ICSharpExpression> get_ExpressionsEnumerable();
    public abstract virtual IMultipleLocalVariableDeclaration SetDeclaration(IMultipleLocalVariableDeclaration param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IForIterator {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> Expressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ExpressionsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpExpression> get_Expressions();
    public abstract virtual TreeNodeEnumerable`1<ICSharpExpression> get_ExpressionsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IFormalParameterList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICSharpParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ICSharpParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ICSharpParameterDeclaration> get_ParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IForStatement {
    public ICSharpStatement Body { get; }
    public ICSharpExpression Condition { get; }
    public ITokenNode ForKeyword { get; }
    public IForInitializer Initializer { get; }
    public IForIterator Iterators { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Semicolon1 { get; }
    public ITokenNode Semicolon2 { get; }
    public TreeNodeCollection`1<ILocalVariableDeclaration> InitializerDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalVariableDeclaration> InitializerDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> InitializerExpressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> InitializerExpressionsEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> IteratorExpressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> IteratorExpressionsEnumerable { get; }
    public abstract virtual ICSharpStatement get_Body();
    public abstract virtual ICSharpExpression get_Condition();
    public abstract virtual ITokenNode get_ForKeyword();
    public abstract virtual IForInitializer get_Initializer();
    public abstract virtual IForIterator get_Iterators();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_Semicolon1();
    public abstract virtual ITokenNode get_Semicolon2();
    public abstract virtual TreeNodeCollection`1<ILocalVariableDeclaration> get_InitializerDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalVariableDeclaration> get_InitializerDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpExpression> get_InitializerExpressions();
    public abstract virtual TreeNodeEnumerable`1<ICSharpExpression> get_InitializerExpressionsEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpExpression> get_IteratorExpressions();
    public abstract virtual TreeNodeEnumerable`1<ICSharpExpression> get_IteratorExpressionsEnumerable();
    public abstract virtual ICSharpStatement SetBody(ICSharpStatement param);
    public abstract virtual ICSharpExpression SetCondition(ICSharpExpression param);
    public abstract virtual IForInitializer SetInitializer(IForInitializer param);
    public abstract virtual IForIterator SetIterators(IForIterator param);
    public abstract virtual void RemoveInitializerDeclaration(ILocalVariableDeclaration variableDeclaration);
    [NotNullAttribute]
public abstract virtual TExpression AddInitializerExpressionBefore(TExpression initializerExpression, ICSharpExpression anchor);
    [NotNullAttribute]
public abstract virtual TExpression AddInitializerExpressionAfter(TExpression initializerExpression, ICSharpExpression anchor);
    public abstract virtual void RemoveInitializerExpression(ICSharpExpression initializerExpression);
    [NotNullAttribute]
public abstract virtual TExpression AddIteratorExpressionBefore(TExpression iteratorExpression, ICSharpExpression anchor);
    [NotNullAttribute]
public abstract virtual TExpression AddIteratorExpressionAfter(TExpression iteratorExpression, ICSharpExpression anchor);
    public abstract virtual void RemoveIteratorExpression(ICSharpExpression iteratorExpression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.IfStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIfStatement GetByCondition(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIfStatement GetByElse(ICSharpStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIfStatement GetByThen(ICSharpStatement param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IFunctionPointerCallingConvention {
    public ITokenNode LBracket { get; }
    [CanBeNullAttribute]
public ICSharpIdentifier ManagedKeyword { get; }
    public ITokenNode RBracket { get; }
    [CanBeNullAttribute]
public TreeNodeCollection`1<ICSharpIdentifier> UnmanagedCallingConventions { get; }
    public TreeNodeEnumerable`1<ICSharpIdentifier> UnmanagedCallingConventionsEnumerable { get; }
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ICSharpIdentifier get_ManagedKeyword();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual TreeNodeCollection`1<ICSharpIdentifier> get_UnmanagedCallingConventions();
    public abstract virtual TreeNodeEnumerable`1<ICSharpIdentifier> get_UnmanagedCallingConventionsEnumerable();
    public abstract virtual ICSharpIdentifier SetManagedKeyword(ICSharpIdentifier param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IFunctionPointerParameter {
    [CanBeNullAttribute]
public IFunctionPointerParameterModifiers ModifierList { get; }
    public ITypeUsage TypeUsage { get; }
    [NotNullAttribute]
public IType Type { get; }
    public ReferenceKind ReturnKind { get; }
    public ParameterKind ParameterKind { get; }
    public bool IsReturnTypeParameter { get; }
    public abstract virtual IFunctionPointerParameterModifiers get_ModifierList();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IFunctionPointerParameterModifiers SetModifierList(IFunctionPointerParameterModifiers param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IType get_Type();
    public abstract virtual ReferenceKind get_ReturnKind();
    public abstract virtual ParameterKind get_ParameterKind();
    public abstract virtual bool get_IsReturnTypeParameter();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IFunctionPointerParameterModifiers {
    public TreeNodeCollection`1<ITokenNode> Modifier { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifierEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Modifier();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ModifierEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IFunctionPointerTypeUsage {
    public IFunctionPointerCallingConvention CallingConvention { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode DelegateKeyword { get; }
    public ITokenNode LBound { get; }
    public TreeNodeCollection`1<IFunctionPointerParameter> Parameters { get; }
    public TreeNodeEnumerable`1<IFunctionPointerParameter> ParametersEnumerable { get; }
    public ITokenNode PointerMark { get; }
    public ITokenNode RBound { get; }
    public abstract virtual IFunctionPointerCallingConvention get_CallingConvention();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_DelegateKeyword();
    public abstract virtual ITokenNode get_LBound();
    public abstract virtual TreeNodeCollection`1<IFunctionPointerParameter> get_Parameters();
    public abstract virtual TreeNodeEnumerable`1<IFunctionPointerParameter> get_ParametersEnumerable();
    public abstract virtual ITokenNode get_PointerMark();
    public abstract virtual ITokenNode get_RBound();
    public abstract virtual IFunctionPointerCallingConvention SetCallingConvention(IFunctionPointerCallingConvention param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IGeneralCatchClause {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IGotoCaseStatement {
    public ITokenNode CaseKeyword { get; }
    public ITokenNode DefaultKeyword { get; }
    public ITokenNode GotoKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ICSharpExpression ValueExpression { get; }
    public bool IsGotoDefault { get; }
    public abstract virtual ITokenNode get_CaseKeyword();
    public abstract virtual ITokenNode get_DefaultKeyword();
    public abstract virtual ITokenNode get_GotoKeyword();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ICSharpExpression get_ValueExpression();
    public abstract virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public abstract virtual bool get_IsGotoDefault();
    [CanBeNullAttribute]
public abstract virtual ISwitchCaseLabel ResolveLabel(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IGotoStatement {
    public ITokenNode GotoKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ILabelReferenceElement Target { get; }
    public abstract virtual ITokenNode get_GotoKeyword();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ILabelReferenceElement get_Target();
    public abstract virtual ILabelReferenceElement SetTarget(ILabelReferenceElement param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IIfDirective {
    public IPreprocessorExpression Condition { get; }
    public abstract virtual IPreprocessorExpression get_Condition();
    public abstract virtual IPreprocessorExpression SetCondition(IPreprocessorExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IIfStatement {
    public ICSharpExpression Condition { get; }
    public ICSharpStatement Else { get; }
    public ITokenNode ElseKeyword { get; }
    public ITokenNode IfKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ICSharpStatement Then { get; }
    public abstract virtual ICSharpExpression get_Condition();
    public abstract virtual ICSharpStatement get_Else();
    public abstract virtual ITokenNode get_ElseKeyword();
    public abstract virtual ITokenNode get_IfKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ICSharpStatement get_Then();
    public abstract virtual ICSharpExpression SetCondition(ICSharpExpression param);
    public abstract virtual ICSharpStatement SetElse(ICSharpStatement param);
    public abstract virtual ICSharpStatement SetThen(ICSharpStatement param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInactivePreprocessorBranch {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerDeclaration {
    public ITokenNode LBracket { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RBracket { get; }
    public ITokenNode ThisKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public IModifiersList ModifiersList { get; }
    [CanBeNullAttribute]
public IProperty DeclaredElement { get; }
    public ReferenceKind ReturnKind { get; }
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual IFormalParameterList get_Params();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual ITokenNode get_ThisKeyword();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IFormalParameterList SetParams(IFormalParameterList param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IProperty get_DeclaredElement();
    public abstract virtual ReferenceKind get_ReturnKind();
    public abstract virtual void SetReturnKind(ReferenceKind returnKind);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IIndexerInitializer {
    public IArgumentList ArgumentList { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    [NotNullAttribute]
public IReference Reference { get; }
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
    public abstract virtual IReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IIndexFromEndExpression {
    public IUnaryExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    [NotNullAttribute]
public IReference TypeReference { get; }
    public abstract virtual IUnaryExpression get_Operand();
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual IUnaryExpression SetOperand(IUnaryExpression param);
    public abstract virtual IReference get_TypeReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInitializedMemberInitializer {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInitializerElement {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceDeclaration {
    [CanBeNullAttribute]
public IExtendsList ExtendedInterfaces { get; }
    public ITokenNode InterfaceKeyword { get; }
    public TreeNodeCollection`1<ITypeUsage> ExtendedInterfaceUsages { get; }
    public TreeNodeEnumerable`1<ITypeUsage> ExtendedInterfaceUsagesEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IInterface DeclaredElement { get; }
    public abstract virtual IExtendsList get_ExtendedInterfaces();
    public abstract virtual ITokenNode get_InterfaceKeyword();
    public abstract virtual TreeNodeCollection`1<ITypeUsage> get_ExtendedInterfaceUsages();
    public abstract virtual TreeNodeEnumerable`1<ITypeUsage> get_ExtendedInterfaceUsagesEnumerable();
    public abstract virtual IExtendsList SetExtendedInterfaces(IExtendsList param);
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IInterface get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInterfaceQualificationOwner {
    [CanBeNullAttribute]
public IOwnerQualification InterfaceQualification { get; }
    public IReferenceName InterfaceQualificationReference { get; }
    public abstract virtual IOwnerQualification get_InterfaceQualification();
    public abstract virtual IReferenceName get_InterfaceQualificationReference();
    public abstract virtual IOwnerQualification SetInterfaceQualification(IOwnerQualification param);
    public abstract virtual IReferenceName SetInterfaceQualificationReference(IReferenceName param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInterpolatedStringExpression {
    public TreeNodeCollection`1<IInterpolatedStringInsert> Inserts { get; }
    public TreeNodeEnumerable`1<IInterpolatedStringInsert> InsertsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Literals { get; }
    public TreeNodeEnumerable`1<ITokenNode> LiteralsEnumerable { get; }
    [NotNullAttribute]
public ICSharpInvocationReference FormatReference { get; }
    [NotNullAttribute]
public IInterpolatedStringHandlerConstructorReference HandlerConstructorReference { get; }
    [NotNullAttribute]
public ICSharpInvocationReference HandlerAppendLiteralReference { get; }
    [NotNullAttribute]
public IReference HandlerAppendLiteralParamsDefaultConstructorReference { get; }
    [NotNullAttribute]
public IReference HandlerAppendLiteralParamsCreateMethodReference { get; }
    [NotNullAttribute]
public IReference HandlerAppendLiteralParamsAddReference { get; }
    public abstract virtual TreeNodeCollection`1<IInterpolatedStringInsert> get_Inserts();
    public abstract virtual TreeNodeEnumerable`1<IInterpolatedStringInsert> get_InsertsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Literals();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_LiteralsEnumerable();
    public abstract virtual ICSharpInvocationReference get_FormatReference();
    public abstract virtual IInterpolatedStringHandlerConstructorReference get_HandlerConstructorReference();
    public abstract virtual ICSharpInvocationReference get_HandlerAppendLiteralReference();
    public abstract virtual IReference get_HandlerAppendLiteralParamsDefaultConstructorReference();
    public abstract virtual IReference get_HandlerAppendLiteralParamsCreateMethodReference();
    public abstract virtual IReference get_HandlerAppendLiteralParamsAddReference();
    public abstract virtual bool IsValid();
    public abstract virtual IPsiServices GetPsiServices();
    [PureAttribute]
public abstract virtual InterpolatedStringKind GetInterpolatedStringKind(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInterpolatedStringHandlerConstructorReference {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IList`1<ICSharpArgumentInfo> GetArguments(IResolveContext resolveContext);
    [PureAttribute]
public abstract virtual bool HasTrailingOutBoolShouldAppendArgument(IResolveContext resolveContext);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IMethod TryResolveHandlerAsStringFormat(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInterpolatedStringInsert {
    public ICSharpExpression AlignmentExpression { get; }
    public ITokenNode Comma { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode FormatSpecifier { get; }
    [NotNullAttribute]
public ICSharpInvocationReference HandlerAppendFormattedReference { get; }
    [NotNullAttribute]
public IReference HandlerAppendFormattedParamsDefaultConstructorReference { get; }
    [NotNullAttribute]
public IReference HandlerAppendFormattedParamsCreateMethodReference { get; }
    [NotNullAttribute]
public IReference HandlerAppendFormattedParamsAddReference { get; }
    public abstract virtual ICSharpExpression get_AlignmentExpression();
    public abstract virtual ITokenNode get_Comma();
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_FormatSpecifier();
    public abstract virtual ICSharpExpression SetAlignmentExpression(ICSharpExpression param);
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public abstract virtual ICSharpInvocationReference get_HandlerAppendFormattedReference();
    public abstract virtual IReference get_HandlerAppendFormattedParamsDefaultConstructorReference();
    public abstract virtual IReference get_HandlerAppendFormattedParamsCreateMethodReference();
    public abstract virtual IReference get_HandlerAppendFormattedParamsAddReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInvalidDirective {
    public ITokenNode EndOfLine { get; }
    public abstract virtual ITokenNode get_EndOfLine();
    [PureAttribute]
public abstract virtual TreeTextRange GetInvalidNameRange();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpression {
    public IArgumentList ArgumentList { get; }
    public IPrimaryExpression InvokedExpression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    [NotNullAttribute]
public IInvocationExpressionReference InvocationExpressionReference { get; }
    [NotNullAttribute]
public IInvocationExpressionReference Reference { get; }
    [ObsoleteAttribute("Always returns 'false'. What you actually need is to check (InvokedExpression as IReferenceExpression)?.HasConditionalAccessSign", "True")]
public bool HasConditionalAccessSign { get; }
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual IPrimaryExpression get_InvokedExpression();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
    public abstract virtual IPrimaryExpression SetInvokedExpression(IPrimaryExpression param);
    public abstract virtual IInvocationExpressionReference get_InvocationExpressionReference();
    public abstract virtual IInvocationExpressionReference get_Reference();
    [PureAttribute]
public abstract virtual bool IsNameofOperator();
    [PureAttribute]
public abstract virtual bool IsNameofOperator(IResolveContext resolveContext);
    public abstract virtual bool get_HasConditionalAccessSign();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IInvocationExpressionReference {
    public abstract virtual bool IsPassThrough(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IIsExpression {
    public ICSharpExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public IPattern Pattern { get; }
    [NotNullAttribute]
public IType IsType { get; }
    public abstract virtual ICSharpExpression get_Operand();
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual IPattern get_Pattern();
    public abstract virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public abstract virtual IPattern SetPattern(IPattern param);
    public abstract virtual IType get_IsType();
    [NotNullAttribute]
public abstract virtual IType GetIsType(IResolveContext resolveContext);
    [PureAttribute]
public abstract virtual IsExpressionKind GetKind(IResolveContext resolveContext, bool unresolvedIsTypeCheck);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IKeyword {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILabelDeclaration {
    public ICSharpIdentifier NameIdentifier { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILabelReferenceElement {
    public ICSharpIdentifier NameIdentifier { get; }
    [NotNullAttribute]
public IReference Reference { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual IReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILabelStatement {
    public ITokenNode Colon { get; }
    public ILabelDeclaration Label { get; }
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual ILabelDeclaration get_Label();
    public abstract virtual ILabelDeclaration SetLabel(ILabelDeclaration param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaExpression {
    public IBlock BodyBlock { get; }
    public ICSharpExpression BodyExpression { get; }
    public ITokenNode LambdaArrow { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode RefReadonlyKeyword { get; }
    public ITypeUsage ReturnType { get; }
    public ILambdaSignature Signature { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<ILocalRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ITokenNode RPar { get; }
    [CanBeNullAttribute]
public ITokenNode AsyncKeyword { get; }
    [CanBeNullAttribute]
public ITokenNode StaticKeyword { get; }
    public ReferenceKind ExplicitReturnKind { get; }
    public bool HasImplicitlyTypedParameters { get; }
    public abstract virtual IBlock get_BodyBlock();
    public abstract virtual ICSharpExpression get_BodyExpression();
    public abstract virtual ITokenNode get_LambdaArrow();
    public abstract virtual ITokenNode get_RefKeyword();
    public abstract virtual ITokenNode get_RefReadonlyKeyword();
    public abstract virtual ITypeUsage get_ReturnType();
    public abstract virtual ILambdaSignature get_Signature();
    public abstract virtual IAttributeSectionList get_AttributeSectionList();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual TreeNodeCollection`1<ILocalRegularParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public abstract virtual IBlock SetBodyBlock(IBlock param);
    public abstract virtual ICSharpExpression SetBodyExpression(ICSharpExpression param);
    public abstract virtual ITypeUsage SetReturnType(ITypeUsage param);
    public abstract virtual ILambdaSignature SetSignature(ILambdaSignature param);
    public abstract virtual ITokenNode get_AsyncKeyword();
    public abstract virtual ITokenNode get_StaticKeyword();
    public abstract virtual ReferenceKind get_ExplicitReturnKind();
    [NotNullAttribute]
public abstract virtual TParameterDeclaration AddParameterDeclarationBefore(TParameterDeclaration parameterDeclaration, ILocalParameterDeclaration anchor);
    [NotNullAttribute]
public abstract virtual TParameterDeclaration AddParameterDeclarationAfter(TParameterDeclaration parameterDeclaration, ILocalParameterDeclaration anchor);
    [NotNullAttribute]
public abstract virtual TParameterDeclaration ReplaceParameterDeclaration(ILocalParameterDeclaration parameterDeclaration, TParameterDeclaration newParameterDeclaration);
    public abstract virtual void RemoveParameterDeclaration(ILocalParameterDeclaration parameterDeclaration);
    [NotNullAttribute]
public abstract virtual ILocalParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ILocalParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public abstract virtual bool TrySetSignatureParentheses(bool value);
    public abstract virtual bool get_HasImplicitlyTypedParameters();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILambdaSignature {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<ILocalRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public ITokenNode RPar { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual TreeNodeCollection`1<ILocalRegularParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILineDirective {
    public ILineIndicator LineIndicator { get; }
    public abstract virtual ILineIndicator get_LineIndicator();
    public abstract virtual ILineIndicator SetLineIndicator(ILineIndicator param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILineIndicator {
    public ITokenNode Default { get; }
    public ITokenNode Hidden { get; }
    public ITokenNode LineDigits { get; }
    public ITokenNode Name { get; }
    public abstract virtual ITokenNode get_Default();
    public abstract virtual ITokenNode get_Hidden();
    public abstract virtual ITokenNode get_LineDigits();
    public abstract virtual ITokenNode get_Name();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IListPattern {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    [CanBeNullAttribute]
public IVariableDesignation Designation { get; }
    public ITokenNode LBracket { get; }
    public TreeNodeCollection`1<IPattern> Patterns { get; }
    public TreeNodeEnumerable`1<IPattern> PatternsEnumerable { get; }
    public ITokenNode RBracket { get; }
    [NullableAttribute("1")]
public IListPatternReference LengthReference { get; }
    [NullableAttribute("1")]
public IListPatternReference IndexerReference { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual IVariableDesignation get_Designation();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual TreeNodeCollection`1<IPattern> get_Patterns();
    public abstract virtual TreeNodeEnumerable`1<IPattern> get_PatternsEnumerable();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    [NullableContextAttribute("1")]
public abstract virtual IListPatternReference get_LengthReference();
    [NullableContextAttribute("1")]
public abstract virtual IListPatternReference get_IndexerReference();
    [NullableContextAttribute("1")]
public abstract virtual IPattern AddPatternAfter(IPattern pattern, IPattern anchor);
    [NullableContextAttribute("1")]
public abstract virtual IPattern AddPatternBefore(IPattern pattern, IPattern anchor);
    [NullableContextAttribute("1")]
public abstract virtual void RemovePattern(IPattern pattern);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IListPatternReference {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILocalArglistParameterDeclaration {
    public ITokenNode ArglistKeyword { get; }
    public abstract virtual ITokenNode get_ArglistKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILocalConstantDeclaration {
    public ICSharpExpression ValueExpression { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public IReferenceName ScalarTypeName { get; }
    [NotNullAttribute]
public ICSharpLocalVariable DeclaredElement { get; }
    public abstract virtual ICSharpExpression get_ValueExpression();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public abstract virtual IReferenceName get_ScalarTypeName();
    public abstract virtual ICSharpLocalVariable get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILocalFormalParameterList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ILocalParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ILocalParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalParameterDeclaration> get_ParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILocalFunctionDeclaration {
    public IBlock Body { get; }
    public ITokenNode LPar { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ILocalFormalParameterList ParameterList { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfLocalFunctionList TypeParameterList { get; }
    public ITypeUsage TypeUsage { get; }
    public IAttributeSectionList AttributeSectionList { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfLocalFunctionDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> TypeParameterDeclarationsEnumerable { get; }
    [NotNullAttribute]
public ILocalFunction DeclaredElement { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public bool IsStatic { get; }
    public ReferenceKind ReturnKind { get; }
    public abstract virtual IBlock get_Body();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ILocalFormalParameterList get_ParameterList();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public abstract virtual ITypeParameterOfLocalFunctionList get_TypeParameterList();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IAttributeSectionList get_AttributeSectionList();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfLocalFunctionDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> get_TypeParameterDeclarationsEnumerable();
    public abstract virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public abstract virtual IBlock SetBody(IBlock param);
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ILocalFormalParameterList SetParameterList(ILocalFormalParameterList param);
    public abstract virtual ITypeParameterOfLocalFunctionList SetTypeParameterList(ITypeParameterOfLocalFunctionList param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual ILocalFunction get_DeclaredElement();
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsIterator();
    public abstract virtual bool get_IsStatic();
    public abstract virtual ReferenceKind get_ReturnKind();
    public abstract virtual void SetAsync(bool isAsync);
    public abstract virtual void SetReturnKind(ReferenceKind returnKind);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfLocalFunctionDeclaration AddTypeParameterBefore(ITypeParameterOfLocalFunctionDeclaration typeParameter, ITypeParameterOfLocalFunctionDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfLocalFunctionDeclaration AddTypeParameterAfter(ITypeParameterOfLocalFunctionDeclaration typeParameter, ITypeParameterOfLocalFunctionDeclaration anchor);
    public abstract virtual void RemoveTypeParameter(ITypeParameterOfLocalFunctionDeclaration typeParameter);
    [NotNullAttribute]
public abstract virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    [NotNullAttribute]
public abstract virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause constraintsClause, ITypeParameterConstraintsClause anchor);
    public abstract virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause constraintsClause);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILocalParameterDeclaration {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILocalRegularParameterDeclaration {
    public bool IsExplicitlyTyped { get; }
    public bool IsImplicitlyTyped { get; }
    public abstract virtual bool get_IsExplicitlyTyped();
    public abstract virtual bool get_IsImplicitlyTyped();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILocalVariableDeclaration {
    public IVariableInitializer Initial { get; }
    public ITypeUsage TypeUsage { get; }
    [NotNullAttribute]
public ICSharpLocalVariable DeclaredElement { get; }
    public bool IsScoped { get; }
    public bool IsVar { get; }
    public ReferenceKind ReferenceKind { get; }
    public UsingDeclarationKind UsingKind { get; }
    public abstract virtual IVariableInitializer get_Initial();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual ICSharpLocalVariable get_DeclaredElement();
    public abstract virtual bool get_IsScoped();
    public abstract virtual bool get_IsVar();
    public abstract virtual ReferenceKind get_ReferenceKind();
    public abstract virtual UsingDeclarationKind get_UsingKind();
    public abstract virtual void SetVar();
    public abstract virtual void SetReferenceKind(ReferenceKind kind);
    public abstract virtual void SetUsingKind(UsingDeclarationKind kind);
    public abstract virtual void SetScoped(bool addScopedKeyword);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILockStatement {
    public ICSharpStatement Body { get; }
    public ITokenNode LPar { get; }
    public ITokenNode LockKeyword { get; }
    public ICSharpExpression Monitor { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ICSharpStatement get_Body();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_LockKeyword();
    public abstract virtual ICSharpExpression get_Monitor();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ICSharpStatement SetBody(ICSharpStatement param);
    public abstract virtual ICSharpExpression SetMonitor(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILoopStatement {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ILoopWithConditionStatement {
    public ICSharpExpression Condition { get; }
    public abstract virtual ICSharpExpression get_Condition();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMakerefExpression {
    public ICSharpExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode MakerefKeyword { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_MakerefKeyword();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMemberInitializer {
    public ICSharpExpression Expression { get; }
    public ICreationExpressionInitializer Initializer { get; }
    public ITokenNode Operator { get; }
    [NotNullAttribute]
public IReference Reference { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ICreationExpressionInitializer get_Initializer();
    public abstract virtual ITokenNode get_Operator();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public abstract virtual ICreationExpressionInitializer SetInitializer(ICreationExpressionInitializer param);
    public abstract virtual IReference get_Reference();
    [NotNullAttribute]
public abstract virtual IType GetConstructedType(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerBody {
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMemberOwnerDeclaration {
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ICSharpTypeMemberDeclaration> MemberDeclarations { get; }
    public ITypeElement DeclaredElement { get; }
    [CanBeNullAttribute]
public IMemberOwnerBody Body { get; }
    [CanBeNullAttribute]
public ITokenNode Semicolon { get; }
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual TreeNodeCollection`1<ICSharpTypeMemberDeclaration> get_MemberDeclarations();
    public abstract virtual ITypeElement get_DeclaredElement();
    public abstract virtual IMemberOwnerBody get_Body();
    public abstract virtual ITokenNode get_Semicolon();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMethodDeclaration {
    public IAttributeSectionList AttributeSectionList { get; }
    public ITokenNode LPar { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClauses { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraintsClause> TypeParameterConstraintsClausesEnumerable { get; }
    public ITypeParameterOfMethodList TypeParameterList { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public bool IsExtensionMethod { get; }
    public bool IsPartial { get; }
    public ReferenceKind ReturnKind { get; }
    [CanBeNullAttribute]
public IMethod DeclaredElement { get; }
    public abstract virtual IAttributeSectionList get_AttributeSectionList();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual IFormalParameterList get_Params();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClauses();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraintsClause> get_TypeParameterConstraintsClausesEnumerable();
    public abstract virtual ITypeParameterOfMethodList get_TypeParameterList();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
    public abstract virtual IAttributeSectionList SetAttributeSectionList(IAttributeSectionList param);
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual IFormalParameterList SetParams(IFormalParameterList param);
    public abstract virtual ITypeParameterOfMethodList SetTypeParameterList(ITypeParameterOfMethodList param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IModifiersList SetModifiersList(IModifiersList modifiersList);
    public abstract virtual bool get_IsExtensionMethod();
    public abstract virtual bool get_IsPartial();
    public abstract virtual ReferenceKind get_ReturnKind();
    public abstract virtual void SetPartial(bool isPartial);
    public abstract virtual void SetAsync(bool isAsync);
    public abstract virtual void SetReturnKind(ReferenceKind returnKind);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfMethodDeclaration AddTypeParameterBefore(ITypeParameterOfMethodDeclaration param, ITypeParameterOfMethodDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfMethodDeclaration AddTypeParameterAfter(ITypeParameterOfMethodDeclaration param, ITypeParameterOfMethodDeclaration anchor);
    public abstract virtual void RemoveTypeParameter(ITypeParameterOfMethodDeclaration param);
    [NotNullAttribute]
public abstract virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseBefore(ITypeParameterConstraintsClause param, ITypeParameterConstraintsClause anchor);
    [NotNullAttribute]
public abstract virtual ITypeParameterConstraintsClause AddTypeParameterConstraintsClauseAfter(ITypeParameterConstraintsClause param, ITypeParameterConstraintsClause anchor);
    public abstract virtual void RemoveTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    public abstract virtual IMethod get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMissingDesignation {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersList {
    public TreeNodeCollection`1<ITokenNode> Modifiers { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Modifiers();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersEnumerable();
    [NotNullAttribute]
public abstract virtual ITokenNode AddModifier(ITokenNode modifier);
    public abstract virtual void RemoveModifier(ITokenNode modifier);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IModifiersListOwner {
    [CanBeNullAttribute]
public IModifiersList ModifiersList { get; }
    public abstract virtual IModifiersList get_ModifiersList();
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public abstract virtual IModifiersList SetModifiersList(IModifiersList modifiersList);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleConstantDeclaration {
    public IAttributeSectionList Attributes { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ConstKeyword { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode Semicolon { get; }
    public abstract virtual IAttributeSectionList get_Attributes();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_ConstKeyword();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual IAttributeSectionList SetAttributes(IAttributeSectionList param);
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleDeclaration {
    public TreeNodeCollection`1<IMultipleDeclarationMember> Declarators { get; }
    public TreeNodeEnumerable`1<IMultipleDeclarationMember> DeclaratorsEnumerable { get; }
    public ITypeUsage TypeUsage { get; }
    public abstract virtual TreeNodeCollection`1<IMultipleDeclarationMember> get_Declarators();
    public abstract virtual TreeNodeEnumerable`1<IMultipleDeclarationMember> get_DeclaratorsEnumerable();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    [NotNullAttribute]
public abstract virtual TDeclarationMember AddDeclaratorBefore(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    [NotNullAttribute]
public abstract virtual TDeclarationMember AddDeclaratorAfter(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public abstract virtual void RemoveDeclarator(IMultipleDeclarationMember declarationMember);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleDeclarationMember {
    public ITokenNode EquivalenceSign { get; }
    public IMultipleDeclaration MultipleDeclaration { get; }
    public abstract virtual ITokenNode get_EquivalenceSign();
    public abstract virtual IMultipleDeclaration get_MultipleDeclaration();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleEventDeclaration {
    public IAttributeSectionList Attributes { get; }
    public TreeNodeCollection`1<ITokenNode> Commas { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommasEnumerable { get; }
    public ITokenNode EventKeyword { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode Semicolon { get; }
    public abstract virtual IAttributeSectionList get_Attributes();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Commas();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommasEnumerable();
    public abstract virtual ITokenNode get_EventKeyword();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual IAttributeSectionList SetAttributes(IAttributeSectionList param);
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleFieldDeclaration {
    public IAttributeSectionList Attributes { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode Semicolon { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public abstract virtual IAttributeSectionList get_Attributes();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual IAttributeSectionList SetAttributes(IAttributeSectionList param);
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
    public abstract virtual bool get_IsRequired();
    public abstract virtual void SetRequired(bool value);
    public abstract virtual ReferenceKind get_ReferenceKind();
    public abstract virtual void SetReferenceKind(ReferenceKind referenceKind);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleLocalConstantDeclaration {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ConstKeyword { get; }
    public ITokenNode ScopedKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_ConstKeyword();
    public abstract virtual ITokenNode get_ScopedKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMultipleLocalVariableDeclaration {
    public ITokenNode AwaitKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode RefKeyword { get; }
    public ITokenNode RefReadonlyKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> ScopedKeywords { get; }
    public TreeNodeEnumerable`1<ITokenNode> ScopedKeywordsEnumerable { get; }
    public ITokenNode UsingKeyword { get; }
    public ITokenNode VarKeyword { get; }
    public ITreeNode TypeDesignator { get; }
    public bool IsVar { get; }
    public ReferenceKind ReferenceKind { get; }
    public UsingDeclarationKind UsingKind { get; }
    public abstract virtual ITokenNode get_AwaitKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_RefKeyword();
    public abstract virtual ITokenNode get_RefReadonlyKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_ScopedKeywords();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ScopedKeywordsEnumerable();
    public abstract virtual ITokenNode get_UsingKeyword();
    public abstract virtual ITokenNode get_VarKeyword();
    public abstract virtual DocumentRange GetTypeRange();
    public abstract virtual ITreeNode get_TypeDesignator();
    public abstract virtual bool get_IsVar();
    public abstract virtual void SetVar();
    public abstract virtual ReferenceKind get_ReferenceKind();
    public abstract virtual UsingDeclarationKind get_UsingKind();
    public abstract virtual void SetReferenceKind(ReferenceKind kind);
    public abstract virtual void SetUsingKind(UsingDeclarationKind kind);
    public abstract virtual void SetScoped(bool addScopedKeyword);
    [NotNullAttribute]
public abstract virtual TDeclarationMember AddDeclaratorBefore(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    [NotNullAttribute]
public abstract virtual TDeclarationMember AddDeclaratorAfter(TDeclarationMember declarationMember, IMultipleDeclarationMember anchor);
    public abstract virtual void RemoveDeclarator(IMultipleDeclarationMember declarationMember);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IMultiplicativeExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.INamedMemberInitializer {
    public ICSharpIdentifier NameIdentifier { get; }
    [CanBeNullAttribute]
public string MemberName { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual string get_MemberName();
    public abstract virtual void SetMemberName(string name);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.INamespaceBody {
    public IUsingList ImportsList { get; }
    [CanBeNullAttribute]
public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<ICSharpNamespaceDeclaration> NamespaceDeclarationNodes { get; }
    public TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> NamespaceDeclarationNodesEnumerable { get; }
    [CanBeNullAttribute]
public ITokenNode RBrace { get; }
    public ICSharpNamespaceDeclaration NamespaceDeclaration { get; }
    public abstract virtual IUsingList get_ImportsList();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual TreeNodeCollection`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationNodes();
    public abstract virtual TreeNodeEnumerable`1<ICSharpNamespaceDeclaration> get_NamespaceDeclarationNodesEnumerable();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual ICSharpNamespaceDeclaration get_NamespaceDeclaration();
    public abstract virtual IUsingList SetImportsList(IUsingList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.IndexerDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByAccessorDeclaration(IAccessorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerDeclaration GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.IndexerInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerInitializer GetByArgument(ICSharpArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerInitializer GetByArgumentList(IArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerInitializer GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexerInitializer GetByInitializer(ICreationExpressionInitializer param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.IndexFromEndExpressionExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(IIndexFromEndExpression indexFromEndExpression, ICSharpExpression& operand);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.IndexFromEndExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexFromEndExpression GetByOperand(IUnaryExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.INegatedPattern {
    public ITokenNode NotKeyword { get; }
    public IPattern Pattern { get; }
    public abstract virtual ITokenNode get_NotKeyword();
    public abstract virtual IPattern get_Pattern();
    public abstract virtual IPattern SetPattern(IPattern param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InitializedMemberInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInitializedMemberInitializer GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInitializedMemberInitializer GetByInitializer(ICreationExpressionInitializer param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InitializerElementNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InterfaceDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByExtendedInterfaceUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByExtendedInterfaces(IExtendsList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByFieldDeclaration(IFieldDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByIndexerDeclaration(IIndexerDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByNestedTypeDeclaration(ICSharpTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByOperatorDeclaration(IOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InterfaceQualificationOwnerExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetDeclaredShortName(IInterfaceQualificationOwner owner);
    [ExtensionAttribute]
public static void SetInterfaceQualificationReference(IInterfaceQualificationOwner owner, IDeclaredType type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InterfaceQualificationOwnerNavigator : object {
    [PureAttribute]
public static TreeNodeCollection`1<IInterfaceQualificationOwner> GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceQualificationOwner GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceQualificationOwner GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
public static TreeNodeCollection`1<IInterfaceQualificationOwner> GetByModifiersList(IModifiersList param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static InterpolatedStringKind GetInterpolatedStringKind(IInterpolatedStringExpression expression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<ICSharpArgumentInfo> GetArguments(IInterpolatedStringHandlerConstructorReference reference);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetDollarSignRange(IInterpolatedStringExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetVerbatimSignRange(IInterpolatedStringExpression expression);
    [ExtensionAttribute]
[PureAttribute]
private static DocumentRange GetInterpolatedStringStartCharRange(IInterpolatedStringExpression expression, char symbol);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTrivial(IInterpolatedStringExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPartOfStringInterpolationConcatenation(IInterpolatedStringExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static StringVerbatimity GetStringVerbatimity(IInterpolatedStringExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange GetFirstLiteralRange(IInterpolatedStringExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static int GetPartsCount(IInterpolatedStringExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<ITokenNode, ITokenNode> GetBorderTokens(IInterpolatedStringExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringExpressionExtensions/<EnumerateAllLiterals>d__11")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> EnumerateAllLiterals(IInterpolatedStringExpression interpolatedStringExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterpolatedStringExpression GetByInsert(IInterpolatedStringInsert param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringInsertNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterpolatedStringInsert GetByAlignmentExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterpolatedStringInsert GetByExpression(ICSharpExpression param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.InterpolatedStringKind : Enum {
    public int value__;
    public static InterpolatedStringKind String;
    public static InterpolatedStringKind FormattableString;
    public static InterpolatedStringKind InterpolatedStringHandler;
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.INullableDirective {
    public ITokenNode Setting { get; }
    public ITokenNode Target { get; }
    public Nullable`1<NullableDirectiveSettingKind> SettingKind { get; }
    public Nullable`1<NullableDirectiveTargetKind> TargetKind { get; }
    public abstract virtual ITokenNode get_Setting();
    public abstract virtual ITokenNode get_Target();
    public abstract virtual Nullable`1<NullableDirectiveSettingKind> get_SettingKind();
    public abstract virtual Nullable`1<NullableDirectiveTargetKind> get_TargetKind();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.INullableTypeMark {
    public ITokenNode Quest { get; }
    public abstract virtual ITokenNode get_Quest();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.INullableTypeUsage {
    public INullableTypeMark NullableMark { get; }
    public ITypeUsage UnderlyingType { get; }
    public abstract virtual INullableTypeMark get_NullableMark();
    public abstract virtual ITypeUsage get_UnderlyingType();
    public abstract virtual INullableTypeMark SetNullableMark(INullableTypeMark param);
    public abstract virtual ITypeUsage SetUnderlyingType(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.INullCoalescingExpression {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InvalidDirectiveNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InvocationExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeUnfinishedDeconstructionDeclaration(IInvocationExpression invocationExpression);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ICSharpExpression GetInvokedReferenceExpressionQualifier(IInvocationExpression invocationExpression);
    [CompilerGeneratedAttribute]
internal static bool <CanBeUnfinishedDeconstructionDeclaration>g__CanBeUnfinishedDeconstructionDesignation|0_0(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.InvocationExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInvocationExpression GetByArgument(ICSharpArgument param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInvocationExpression GetByArgumentList(IArgumentList param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInvocationExpression GetByInvokedExpression(IPrimaryExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IInvocationExpression GetByInvokedExpression(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IInvocationExpression GetByArgument(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IInvocationExpression GetByUnfinishedDeconstructionDesignation(ICSharpExpression expression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IObjectCreationExpression {
    public IArgumentList ArgumentList { get; }
    public ICreationExpressionInitializer Initializer { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    [CanBeNullAttribute]
public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public IReferenceName TypeName { get; }
    [NotNullAttribute]
public IReference ConstructorReference { get; }
    [CanBeNullAttribute]
public IReference TypeReference { get; }
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual ICreationExpressionInitializer get_Initializer();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
    public abstract virtual ICreationExpressionInitializer SetInitializer(ICreationExpressionInitializer param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IReferenceName get_TypeName();
    public abstract virtual IReference get_ConstructorReference();
    public abstract virtual IReference get_TypeReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IObjectInitializer {
    public TreeNodeCollection`1<IMemberInitializer> MemberInitializers { get; }
    public TreeNodeEnumerable`1<IMemberInitializer> MemberInitializersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IMemberInitializer> get_MemberInitializers();
    public abstract virtual TreeNodeEnumerable`1<IMemberInitializer> get_MemberInitializersEnumerable();
    [NotNullAttribute]
public abstract virtual IMemberInitializer AddMemberInitializerAfter(IMemberInitializer memberInitializer, IMemberInitializer anchor);
    [NotNullAttribute]
public abstract virtual IMemberInitializer AddMemberInitializerBefore(IMemberInitializer memberInitializer, IMemberInitializer anchor);
    public abstract virtual void RemoveMemberInitializer(IMemberInitializer memberInitializer);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorDeclaration {
    public ITokenNode CheckedKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode OperatorKeyword { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    public IModifiersList ModifiersList { get; }
    [CanBeNullAttribute]
public IFunction DeclaredElement { get; }
    public bool IsChecked { get; }
    public abstract virtual ITokenNode get_CheckedKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_OperatorKeyword();
    public abstract virtual IFormalParameterList get_Params();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IFormalParameterList SetParams(IFormalParameterList param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IFunction get_DeclaredElement();
    public abstract virtual bool get_IsChecked();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorExpression {
    public ITokenNode OperatorSign { get; }
    [NotNullAttribute]
public IList`1<ICSharpExpression> OperatorOperands { get; }
    [CanBeNullAttribute]
public IOperatorReference OperatorReference { get; }
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual IList`1<ICSharpExpression> get_OperatorOperands();
    public abstract virtual IOperatorReference get_OperatorReference();
    public abstract virtual bool IsValid();
    public abstract virtual IPsiServices GetPsiServices();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IOperatorReference {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IOrPattern {
    public ITokenNode OrKeyword { get; }
    public abstract virtual ITokenNode get_OrKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IOverflowCheckingStatement {
    public IBlock Body { get; }
    public abstract virtual IBlock get_Body();
    public abstract virtual IBlock SetBody(IBlock param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IOwnerQualification {
    public ITokenNode Dot { get; }
    public IReferenceName Qualifier { get; }
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual IReferenceName get_Qualifier();
    public abstract virtual IReferenceName SetQualifier(IReferenceName param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IParameterModifiersList {
    public TreeNodeCollection`1<ITokenNode> Modifiers { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Modifiers();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IParenthesizedExpression {
    public ICSharpExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IParenthesizedPattern {
    public ITokenNode LPar { get; }
    public IPattern Pattern { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual IPattern get_Pattern();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IPattern SetPattern(IPattern param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IParenthesizedVariableDesignation {
    public TreeNodeCollection`1<IVariableDesignation> ChildrenDesignations { get; }
    public TreeNodeEnumerable`1<IVariableDesignation> ChildrenDesignationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    [NotNullAttribute]
public IDeconstructionReference DeconstructionReference { get; }
    public abstract virtual TreeNodeCollection`1<IVariableDesignation> get_ChildrenDesignations();
    public abstract virtual TreeNodeEnumerable`1<IVariableDesignation> get_ChildrenDesignationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IDeconstructionReference get_DeconstructionReference();
    [PureAttribute]
public abstract virtual int IndexOfDesignation(IVariableDesignation designation);
    public abstract virtual bool IsValid();
    [NotNullAttribute]
public abstract virtual IPsiServices GetPsiServices();
    [NotNullAttribute]
public abstract virtual TVariableDesignation AddDesignationAfter(TVariableDesignation designation, IVariableDesignation anchor);
    [NotNullAttribute]
public abstract virtual TVariableDesignation AddDesignationBefore(TVariableDesignation designation, IVariableDesignation anchor);
    public abstract virtual void RemoveDesignation(IVariableDesignation designation);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPattern {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetPatternType(IResolveContext resolveContext);
    [PureAttribute]
public abstract virtual PatternMatchKind GetMatchKind(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPatternGuardClause {
    public ICSharpExpression Condition { get; }
    public ITokenNode WhenKeyword { get; }
    public abstract virtual ICSharpExpression get_Condition();
    public abstract virtual ITokenNode get_WhenKeyword();
    public abstract virtual ICSharpExpression SetCondition(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPatternWithDesignation {
    [CanBeNullAttribute]
public IVariableDesignation Designation { get; }
    public abstract virtual IVariableDesignation get_Designation();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPatternWithTypeUsage {
    [CanBeNullAttribute]
public ITypeUsage TypeUsage { get; }
    public abstract virtual ITypeUsage get_TypeUsage();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPointerTypeUsage {
    public ITypeUsage ElementType { get; }
    public TreeNodeCollection`1<IUnsafeCodePointer> PointerMarks { get; }
    public TreeNodeEnumerable`1<IUnsafeCodePointer> PointerMarksEnumerable { get; }
    public abstract virtual ITypeUsage get_ElementType();
    public abstract virtual TreeNodeCollection`1<IUnsafeCodePointer> get_PointerMarks();
    public abstract virtual TreeNodeEnumerable`1<IUnsafeCodePointer> get_PointerMarksEnumerable();
    public abstract virtual ITypeUsage SetElementType(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPostfixOperatorExpression {
    public IPrimaryExpression Operand { get; }
    public PostfixOperatorType PostfixOperatorType { get; }
    public abstract virtual IPrimaryExpression get_Operand();
    public abstract virtual IPrimaryExpression SetOperand(IPrimaryExpression param);
    public abstract virtual PostfixOperatorType get_PostfixOperatorType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPragmaDirective {
    public ITokenNode Message { get; }
    public abstract virtual ITokenNode get_Message();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPredefinedTypeExpression {
    public IPredefinedTypeReference PredefinedTypeName { get; }
    public abstract virtual IPredefinedTypeReference get_PredefinedTypeName();
    public abstract virtual IPredefinedTypeReference SetPredefinedTypeName(IPredefinedTypeReference param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPredefinedTypeReference {
    public ITokenNode TypeKeyword { get; }
    public IReference Reference { get; }
    public abstract virtual ITokenNode get_TypeKeyword();
    public abstract virtual IReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPredefinedTypeUsage {
    public IPredefinedTypeReference ScalarPredefinedTypeName { get; }
    public abstract virtual IPredefinedTypeReference get_ScalarPredefinedTypeName();
    public abstract virtual IPredefinedTypeReference SetScalarPredefinedTypeName(IPredefinedTypeReference param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPrefixOperatorExpression {
    public IUnaryExpression Operand { get; }
    public PrefixOperatorType PrefixOperatorType { get; }
    public abstract virtual IUnaryExpression get_Operand();
    public abstract virtual IUnaryExpression SetOperand(IUnaryExpression param);
    public abstract virtual PrefixOperatorType get_PrefixOperatorType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessor {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorAndExpression {
    public IPreprocessorExpression LeftOperand { get; }
    public ITokenNode OpSign { get; }
    public IPreprocessorExpression RightOperand { get; }
    public abstract virtual IPreprocessorExpression get_LeftOperand();
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IPreprocessorExpression get_RightOperand();
    public abstract virtual IPreprocessorExpression SetLeftOperand(IPreprocessorExpression param);
    public abstract virtual IPreprocessorExpression SetRightOperand(IPreprocessorExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorConditionalSymbol {
    public ITokenNode NameIdentifier { get; }
    [NotNullAttribute]
public string Name { get; }
    public abstract virtual ITokenNode get_NameIdentifier();
    public abstract virtual string get_Name();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorDirective {
    public ITokenNode Directive { get; }
    public ITokenNode NumberSign { get; }
    public PreprocessorDirectiveKind Kind { get; }
    public abstract virtual ITokenNode get_Directive();
    public abstract virtual ITokenNode get_NumberSign();
    public abstract virtual PreprocessorDirectiveKind get_Kind();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorEqualityExpression {
    public IPreprocessorExpression LeftOperand { get; }
    public ITokenNode OpSign { get; }
    public IPreprocessorExpression RightOperand { get; }
    public abstract virtual IPreprocessorExpression get_LeftOperand();
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IPreprocessorExpression get_RightOperand();
    public abstract virtual IPreprocessorExpression SetLeftOperand(IPreprocessorExpression param);
    public abstract virtual IPreprocessorExpression SetRightOperand(IPreprocessorExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorNegation {
    public ITokenNode OpSign { get; }
    public IPreprocessorUnaryExpression Operand { get; }
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IPreprocessorUnaryExpression get_Operand();
    public abstract virtual IPreprocessorUnaryExpression SetOperand(IPreprocessorUnaryExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorOrExpression {
    public IPreprocessorExpression LeftOperand { get; }
    public ITokenNode OpSign { get; }
    public IPreprocessorExpression RightOperand { get; }
    public abstract virtual IPreprocessorExpression get_LeftOperand();
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IPreprocessorExpression get_RightOperand();
    public abstract virtual IPreprocessorExpression SetLeftOperand(IPreprocessorExpression param);
    public abstract virtual IPreprocessorExpression SetRightOperand(IPreprocessorExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorParenthesizedExpression {
    public ITokenNode LPar { get; }
    public IPreprocessorExpression Operand { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual IPreprocessorExpression get_Operand();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IPreprocessorExpression SetOperand(IPreprocessorExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorPragmaBody {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPreprocessorUnaryExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPrimaryConstructorDeclaration {
    public ITokenNode LPar { get; }
    public IFormalParameterList Params { get; }
    public ITokenNode RPar { get; }
    [NullableAttribute("2")]
public IPrimaryConstructor DeclaredElement { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual IFormalParameterList get_Params();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IFormalParameterList SetParams(IFormalParameterList param);
    [NullableContextAttribute("2")]
public abstract virtual IPrimaryConstructor get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPrimaryExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyAssignment {
    public ITokenNode Operator { get; }
    public ICSharpIdentifier PropertyNameIdentifier { get; }
    public ICSharpExpression Source { get; }
    [NotNullAttribute]
public IReference Reference { get; }
    [CanBeNullAttribute]
public IAttribute ContainingAttribute { get; }
    public abstract virtual ITokenNode get_Operator();
    public abstract virtual ICSharpIdentifier get_PropertyNameIdentifier();
    public abstract virtual ICSharpExpression get_Source();
    public abstract virtual ICSharpIdentifier SetPropertyNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ICSharpExpression SetSource(ICSharpExpression param);
    public abstract virtual IReference get_Reference();
    public abstract virtual IAttribute get_ContainingAttribute();
    public abstract virtual void SetName(string name);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyDeclaration {
    public ITokenNode EquivalenceSign { get; }
    public IVariableInitializer Initial { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public IProperty DeclaredElement { get; }
    public bool IsAuto { get; }
    public bool HasBackingFieldReference { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsRequired { get; }
    public abstract virtual ITokenNode get_EquivalenceSign();
    public abstract virtual IVariableInitializer get_Initial();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IProperty get_DeclaredElement();
    public abstract virtual bool get_IsAuto();
    public abstract virtual bool get_HasBackingFieldReference();
    [PureAttribute]
public abstract virtual bool HasBackingFieldReferenceIn(AccessorKind accessorKind);
    public abstract virtual ReferenceKind get_ReturnKind();
    public abstract virtual bool get_IsRequired();
    public abstract virtual void SetRequired(bool value);
    public abstract virtual void SetReturnKind(ReferenceKind returnKind);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyInitializer {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IPropertyPatternClause {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<ISubpattern> Patterns { get; }
    public TreeNodeEnumerable`1<ISubpattern> PatternsEnumerable { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual TreeNodeCollection`1<ISubpattern> get_Patterns();
    public abstract virtual TreeNodeEnumerable`1<ISubpattern> get_PatternsEnumerable();
    public abstract virtual ITokenNode get_RBrace();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetSourceType(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetSubpatternType(ISubpattern subpattern, IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IProperTypeDeclaration {
    [CanBeNullAttribute]
public ITypeElement DeclaredElement { get; }
    [CanBeNullAttribute]
public abstract virtual IClassLikeDeclaration GetContainingClassLikeDeclaration();
    public abstract virtual ITypeElement get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryCastReference {
    public IQueryCastReferenceProvider Provider { get; }
    public abstract virtual IQueryCastReferenceProvider get_Provider();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryCastReferenceProvider {
    [CanBeNullAttribute]
public IQueryCastReference CastReference { get; }
    [CanBeNullAttribute]
public IType CastType { get; }
    public ITokenNode Keyword { get; }
    public ICSharpExpression Expression { get; }
    public abstract virtual IQueryCastReference get_CastReference();
    public abstract virtual IType get_CastType();
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual ICSharpExpression get_Expression();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryClause {
    public ITokenNode FirstKeyword { get; }
    [NotNullAttribute]
public IList`1<IQueryReference> QueryReferences { get; }
    [CanBeNullAttribute]
public IQueryClause PreviousClause { get; }
    [CanBeNullAttribute]
public IQueryClause NextClause { get; }
    [NotNullAttribute]
public IList`1<IQueryParameterPlatform> Platforms { get; }
    [CanBeNullAttribute]
public IGeneratedQueryArgument GeneratedArgument { get; }
    public abstract virtual ITokenNode get_FirstKeyword();
    public abstract virtual IList`1<IQueryReference> get_QueryReferences();
    public abstract virtual IQueryClause get_PreviousClause();
    public abstract virtual IQueryClause get_NextClause();
    public abstract virtual QueryKind GetKind();
    public abstract virtual IList`1<IQueryParameterPlatform> get_Platforms();
    public abstract virtual IGeneratedQueryArgument get_GeneratedArgument();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryClausesHolder {
    public TreeNodeCollection`1<IQueryClause> Clauses { get; }
    public TreeNodeEnumerable`1<IQueryClause> ClausesEnumerable { get; }
    [CanBeNullAttribute]
public IQueryClausesHolder Previous { get; }
    [CanBeNullAttribute]
public IQueryClausesHolder Next { get; }
    public abstract virtual TreeNodeCollection`1<IQueryClause> get_Clauses();
    public abstract virtual TreeNodeEnumerable`1<IQueryClause> get_ClausesEnumerable();
    public abstract virtual IQueryClausesHolder get_Previous();
    public abstract virtual IQueryClausesHolder get_Next();
    [NotNullAttribute]
public abstract virtual IQueryClause AddQueryClauseAfter(IQueryClause queryClause, IQueryClause anchor);
    [NotNullAttribute]
public abstract virtual IQueryClause AddQueryClauseBefore(IQueryClause queryClause, IQueryClause anchor);
    public abstract virtual void RemoveQueryClause(IQueryClause clause);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryContinuation {
    public IQueryRangeVariableDeclaration Declaration { get; }
    public ITokenNode IntoKeyword { get; }
    public string Name { get; }
    public abstract virtual IQueryRangeVariableDeclaration get_Declaration();
    public abstract virtual ITokenNode get_IntoKeyword();
    public abstract virtual IQueryRangeVariableDeclaration SetDeclaration(IQueryRangeVariableDeclaration param);
    public abstract virtual string get_Name();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryExpression {
    public TreeNodeCollection`1<IQueryContinuation> Continuations { get; }
    public TreeNodeEnumerable`1<IQueryContinuation> ContinuationsEnumerable { get; }
    public IQueryFirstFrom From { get; }
    public abstract virtual TreeNodeCollection`1<IQueryContinuation> get_Continuations();
    public abstract virtual TreeNodeEnumerable`1<IQueryContinuation> get_ContinuationsEnumerable();
    public abstract virtual IQueryFirstFrom get_From();
    public abstract virtual IQueryFirstFrom SetFrom(IQueryFirstFrom param);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<IQueryVariable> GetVariables(IQueryParameterPlatform platform);
    [NotNullAttribute]
public abstract virtual IScheme GetScheme(IQueryClause clause);
    public abstract virtual void RemoveContinuation(IQueryContinuation continuation);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryFirstFrom {
    public IQueryRangeVariableDeclaration Declaration { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode FromKeyword { get; }
    public ITokenNode InKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public string Name { get; }
    public abstract virtual IQueryRangeVariableDeclaration get_Declaration();
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_FromKeyword();
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IQueryRangeVariableDeclaration SetDeclaration(IQueryRangeVariableDeclaration param);
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual string get_Name();
    [CanBeNullAttribute]
public abstract virtual IReference GetReferenceQualifiedByExpression();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryFromClause {
    public IQueryRangeVariableDeclaration Declaration { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode FromKeyword { get; }
    public ITokenNode InKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public IQueryChainReference SelectReference { get; }
    public abstract virtual IQueryRangeVariableDeclaration get_Declaration();
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual ITokenNode get_FromKeyword();
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IQueryRangeVariableDeclaration SetDeclaration(IQueryRangeVariableDeclaration param);
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual string get_Name();
    public abstract virtual IQueryChainReference get_SelectReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryGroupClause {
    public ITokenNode ByKeyword { get; }
    public IQueryParameterPlatform Criteria { get; }
    public ITokenNode GroupKeyword { get; }
    public IQueryParameterPlatform Subject { get; }
    public IQueryReference GroupReference { get; }
    public abstract virtual ITokenNode get_ByKeyword();
    public abstract virtual IQueryParameterPlatform get_Criteria();
    public abstract virtual ITokenNode get_GroupKeyword();
    public abstract virtual IQueryParameterPlatform get_Subject();
    public abstract virtual IQueryParameterPlatform SetCriteria(IQueryParameterPlatform param);
    public abstract virtual IQueryParameterPlatform SetSubject(IQueryParameterPlatform param);
    public abstract virtual IQueryReference get_GroupReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryJoinClause {
    public IQueryParameterPlatform EqualsExpression { get; }
    public ITokenNode EqualsKeyword { get; }
    public ICSharpExpression InExpression { get; }
    public ITokenNode InKeyword { get; }
    public IQueryRangeVariableDeclaration IntoDeclaration { get; }
    public ITokenNode IntoKeyword { get; }
    public IQueryRangeVariableDeclaration JoinDeclaration { get; }
    public ITokenNode JoinKeyword { get; }
    public IQueryParameterPlatform OnExpression { get; }
    public ITokenNode OnKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    [NotNullAttribute]
public string VariableName { get; }
    [NotNullAttribute]
public string IntoName { get; }
    public IQueryChainReference JoinReference { get; }
    public abstract virtual IQueryParameterPlatform get_EqualsExpression();
    public abstract virtual ITokenNode get_EqualsKeyword();
    public abstract virtual ICSharpExpression get_InExpression();
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual IQueryRangeVariableDeclaration get_IntoDeclaration();
    public abstract virtual ITokenNode get_IntoKeyword();
    public abstract virtual IQueryRangeVariableDeclaration get_JoinDeclaration();
    public abstract virtual ITokenNode get_JoinKeyword();
    public abstract virtual IQueryParameterPlatform get_OnExpression();
    public abstract virtual ITokenNode get_OnKeyword();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IQueryParameterPlatform SetEqualsExpression(IQueryParameterPlatform param);
    public abstract virtual ICSharpExpression SetInExpression(ICSharpExpression param);
    public abstract virtual IQueryRangeVariableDeclaration SetIntoDeclaration(IQueryRangeVariableDeclaration param);
    public abstract virtual IQueryRangeVariableDeclaration SetJoinDeclaration(IQueryRangeVariableDeclaration param);
    public abstract virtual IQueryParameterPlatform SetOnExpression(IQueryParameterPlatform param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual string get_VariableName();
    public abstract virtual string get_IntoName();
    public abstract virtual IQueryChainReference get_JoinReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryLetClause {
    public IQueryRangeVariableDeclaration Declaration { get; }
    public ITokenNode EqSign { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode LetKeyword { get; }
    [NotNullAttribute]
public IQueryReference SelectReference { get; }
    [NotNullAttribute]
public string Name { get; }
    public abstract virtual IQueryRangeVariableDeclaration get_Declaration();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual ITokenNode get_LetKeyword();
    public abstract virtual IQueryRangeVariableDeclaration SetDeclaration(IQueryRangeVariableDeclaration param);
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public abstract virtual IQueryReference get_SelectReference();
    public abstract virtual string get_Name();
    [NotNullAttribute]
public abstract virtual IList`1<IQueryAnonymousTypeProperty> GetGeneratedProperties();
    [CanBeNullAttribute]
public abstract virtual IQueryAnonymousType GetAnonymousType();
    [CanBeNullAttribute]
public abstract virtual IQueryAnonymousType GetAnonymousType(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryOrderByClause {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode OrderByKeyword { get; }
    public TreeNodeCollection`1<IQueryOrdering> Orderings { get; }
    public TreeNodeEnumerable`1<IQueryOrdering> OrderingsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_OrderByKeyword();
    public abstract virtual TreeNodeCollection`1<IQueryOrdering> get_Orderings();
    public abstract virtual TreeNodeEnumerable`1<IQueryOrdering> get_OrderingsEnumerable();
    [NotNullAttribute]
public abstract virtual IQueryOrdering AddQueryOrderingAfter(IQueryOrdering queryOrdering, IQueryOrdering anchor);
    [NotNullAttribute]
public abstract virtual IQueryOrdering AddQueryOrderingBefore(IQueryOrdering queryOrdering, IQueryOrdering anchor);
    public abstract virtual void RemoveQueryOrdering(IQueryOrdering queryOrdering);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryOrdering {
    public ITokenNode AscendingKeyword { get; }
    public ITokenNode DescendingKeyword { get; }
    public IQueryParameterPlatform Expression { get; }
    public IQueryReference Reference { get; }
    public abstract virtual ITokenNode get_AscendingKeyword();
    public abstract virtual ITokenNode get_DescendingKeyword();
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public abstract virtual IQueryReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryParameterPlatform {
    public ICSharpExpression Value { get; }
    [NotNullAttribute]
public IType LambdaReturnType { get; }
    public abstract virtual ICSharpExpression get_Value();
    public abstract virtual ICSharpExpression SetValue(ICSharpExpression param);
    public abstract virtual bool IsValid();
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual IType get_LambdaReturnType();
    [NotNullAttribute]
public abstract virtual IType GetLambdaReturnType(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryRangeVariableDeclaration {
    public ICSharpIdentifier NameIdentifier { get; }
    [NotNullAttribute]
public IQueryRangeVariable DeclaredElement { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual QueryDeclarationKind GetKind();
    public abstract virtual IQueryRangeVariable get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQuerySelectClause {
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode SelectKeyword { get; }
    public IQueryReference SelectReference { get; }
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual ITokenNode get_SelectKeyword();
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public abstract virtual IQueryReference get_SelectReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IQueryWhereClause {
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode WhereKeyword { get; }
    public IQueryReference WhereReference { get; }
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual ITokenNode get_WhereKeyword();
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public abstract virtual IQueryReference get_WhereReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IRangeExpression {
    [CanBeNullAttribute]
public ICSharpExpression LeftOperand { get; }
    public ITokenNode OperatorSign { get; }
    [CanBeNullAttribute]
public ICSharpExpression RightOperand { get; }
    public RangeKind RangeKind { get; }
    [NotNullAttribute]
public IReference TypeReference { get; }
    public abstract virtual ICSharpExpression get_LeftOperand();
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual ICSharpExpression get_RightOperand();
    public abstract virtual ICSharpExpression SetLeftOperand(ICSharpExpression param);
    public abstract virtual ICSharpExpression SetRightOperand(ICSharpExpression param);
    public abstract virtual RangeKind get_RangeKind();
    public abstract virtual IReference get_TypeReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IRankSpecifier {
    public TreeNodeCollection`1<ITokenNode> Commas { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommasEnumerable { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Commas();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommasEnumerable();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IRecordDeclaration {
    public ITokenNode ClassModifier { get; }
    [CanBeNullAttribute]
public IExtendsList ExtendsList { get; }
    public ITokenNode RecordKeyword { get; }
    public ITokenNode StructModifier { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDestructorDeclaration> DestructorDeclarations { get; }
    public TreeNodeEnumerable`1<IDestructorDeclaration> DestructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> InheritedTypeUsages { get; }
    public TreeNodeEnumerable`1<ITypeUsage> InheritedTypeUsagesEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    public bool IsStruct { get; }
    [CanBeNullAttribute]
public IRecord DeclaredElement { get; }
    [CanBeNullAttribute]
public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<IFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public abstract virtual ITokenNode get_ClassModifier();
    public abstract virtual IExtendsList get_ExtendsList();
    public abstract virtual ITokenNode get_RecordKeyword();
    public abstract virtual ITokenNode get_StructModifier();
    public abstract virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IDestructorDeclaration> get_DestructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IDestructorDeclaration> get_DestructorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeUsage> get_InheritedTypeUsages();
    public abstract virtual TreeNodeEnumerable`1<ITypeUsage> get_InheritedTypeUsagesEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public abstract virtual IExtendsList SetExtendsList(IExtendsList param);
    public abstract virtual bool get_IsStruct();
    public abstract virtual IRecord get_DeclaredElement();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual void SetSuperRecord(IDeclaredType classType);
    public abstract virtual void SetKindKeyword(RecordDeclarationTypeKind typeKind);
    public abstract virtual TreeNodeCollection`1<IFieldDeclaration> get_FieldDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IFieldDeclaration> get_FieldDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IRecursivePattern {
    public IDeconstructionPatternClause DeconstructionPatternClause { get; }
    public IVariableDesignation Designation { get; }
    public IPropertyPatternClause PropertyPatternClause { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<ISubpattern> DeconstructionPatterns { get; }
    public TreeNodeEnumerable`1<ISubpattern> DeconstructionPatternsEnumerable { get; }
    public TreeNodeCollection`1<ISubpattern> PropertyPatterns { get; }
    public TreeNodeEnumerable`1<ISubpattern> PropertyPatternsEnumerable { get; }
    public abstract virtual IDeconstructionPatternClause get_DeconstructionPatternClause();
    public abstract virtual IVariableDesignation get_Designation();
    public abstract virtual IPropertyPatternClause get_PropertyPatternClause();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual TreeNodeCollection`1<ISubpattern> get_DeconstructionPatterns();
    public abstract virtual TreeNodeEnumerable`1<ISubpattern> get_DeconstructionPatternsEnumerable();
    public abstract virtual TreeNodeCollection`1<ISubpattern> get_PropertyPatterns();
    public abstract virtual TreeNodeEnumerable`1<ISubpattern> get_PropertyPatternsEnumerable();
    public abstract virtual IDeconstructionPatternClause SetDeconstructionPatternClause(IDeconstructionPatternClause param);
    public abstract virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    public abstract virtual IPropertyPatternClause SetPropertyPatternClause(IPropertyPatternClause param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpression {
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode Delimiter { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    public ICSharpArgument ContainerArgument { get; }
    public bool IsQualified { get; }
    [NotNullAttribute]
public IReferenceExpressionReference Reference { get; }
    [CanBeNullAttribute]
public ICSharpExpression QualifierExpression { get; }
    public abstract virtual IConditionalAccessSign get_ConditionalAccessSign();
    public abstract virtual ITokenNode get_Delimiter();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITypeArgumentList get_TypeArgumentList();
    public abstract virtual ICSharpArgument get_ContainerArgument();
    public abstract virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public abstract virtual bool get_IsQualified();
    public abstract virtual IReferenceExpressionReference get_Reference();
    public abstract virtual ICSharpExpression get_QualifierExpression();
    public abstract virtual void SetTypeArguments(ICollection`1<IType> typeArguments);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public abstract virtual ICSharpExpression SetQualifierExpression(ICSharpExpression expression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceExpressionReference {
    public abstract virtual ResolveResultWithInfo ResolveAsUnqualified(ISymbolTable symbolTable);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceName {
    public ITokenNode Delimiter { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    [NotNullAttribute]
public IReferenceNameReference Reference { get; }
    [NotNullAttribute]
public string ShortName { get; }
    [NotNullAttribute]
public string QualifiedName { get; }
    [CanBeNullAttribute]
public IReferenceName Qualifier { get; }
    public abstract virtual ITokenNode get_Delimiter();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITypeArgumentList get_TypeArgumentList();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public abstract virtual IReferenceNameReference get_Reference();
    public abstract virtual string get_ShortName();
    public abstract virtual string get_QualifiedName();
    public abstract virtual void AppendQualifiedName(StringBuilder builder);
    public abstract virtual IReferenceName get_Qualifier();
    [ContractAnnotationAttribute("null => null")]
public abstract virtual IReferenceName SetQualifier(IReferenceName newQualifier);
    [NotNullAttribute]
public abstract virtual IReferenceName ReplaceBy(IReferenceName name);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceNameReference {
    public abstract virtual ResolveResultWithInfo ResolveAsUnqualified(ISymbolTable symbolTable);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IReferenceTypeConstraint {
    public ITokenNode Keyword { get; }
    public INullableTypeMark NullableMark { get; }
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual INullableTypeMark get_NullableMark();
    public abstract virtual INullableTypeMark SetNullableMark(INullableTypeMark param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IRefExpression {
    public ICSharpExpression Expression { get; }
    public ITokenNode RefKeyword { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_RefKeyword();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    [PureAttribute]
public abstract virtual ReferenceKind GetExpectedReferenceKind(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IReftypeExpression {
    public ICSharpExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode ReftypeKeyword { get; }
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_ReftypeKeyword();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IRefvalueExpression {
    public ITokenNode Comma { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode RefvalueKeyword { get; }
    public ITypeUsage TargetType { get; }
    public abstract virtual ITokenNode get_Comma();
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_RefvalueKeyword();
    public abstract virtual ITypeUsage get_TargetType();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public abstract virtual ITypeUsage SetTargetType(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IRelationalExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IRelationalPattern {
    public ICSharpExpression Operand { get; }
    public ITokenNode Sign { get; }
    public RelationalPatternKind Kind { get; }
    [NotNullAttribute]
public ConstantValue ConstantValue { get; }
    public abstract virtual ICSharpExpression get_Operand();
    public abstract virtual ITokenNode get_Sign();
    public abstract virtual ICSharpExpression SetOperand(ICSharpExpression param);
    public abstract virtual RelationalPatternKind get_Kind();
    public abstract virtual ConstantValue get_ConstantValue();
    public abstract virtual bool IsValid();
    public abstract virtual IPsiServices GetPsiServices();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IResourceAcquisitionExpressionsList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ICSharpExpression> Expressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ExpressionsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ICSharpExpression> get_Expressions();
    public abstract virtual TreeNodeEnumerable`1<ICSharpExpression> get_ExpressionsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IReturnStatement {
    public ITokenNode ReturnKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ICSharpExpression Value { get; }
    public abstract virtual ITokenNode get_ReturnKeyword();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ICSharpExpression get_Value();
    public abstract virtual ICSharpExpression SetValue(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IReturnValueHolder {
    [CanBeNullAttribute]
public ICSharpExpression Value { get; }
    [CanBeNullAttribute]
public ITokenNode ReturnKeyword { get; }
    public abstract virtual ICSharpExpression get_Value();
    public abstract virtual ITokenNode get_ReturnKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IScalarTypeUsage {
    [NotNullAttribute]
public abstract virtual ITypeUsage ReplaceBy(ITypeUsage typeUsage);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITreeNode GetTypeCheckTypeUsageNode(IIsExpression isExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPatternMatching(IIsExpression isExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static PatternMatchKind GetPatternMatchKind(IIsExpression isExpression);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionKind : Enum {
    public int value__;
    public static IsExpressionKind Unknown;
    public static IsExpressionKind TypeCheck;
    public static IsExpressionKind PatternMatching;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.IsExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIsExpression GetByOperand(ICSharpExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIsExpression GetByPattern(IPattern param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIsExpression GetByTypeOperand(IReferenceExpression referenceExpression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIsExpression GetByTypeOperand(ITypeUsage typeUsage);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IShiftExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISignOperatorDeclaration {
    public ITokenNode OperatorSign { get; }
    public IModifiersList ModifiersList { get; }
    [CanBeNullAttribute]
public IFunction DeclaredElement { get; }
    public bool IsChecked { get; }
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IFunction get_DeclaredElement();
    public abstract virtual bool get_IsChecked();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISingleVariableDesignation {
    public bool IsVar { get; }
    [NotNullAttribute]
public IType Type { get; }
    [NotNullAttribute]
public ICSharpLocalVariable DeclaredElement { get; }
    public abstract virtual bool get_IsVar();
    public abstract virtual void SetVar();
    public abstract virtual IType get_Type();
    public abstract virtual ICSharpLocalVariable get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISlicePattern {
    public ITokenNode OperatorSign { get; }
    [CanBeNullAttribute]
public IPattern Pattern { get; }
    [NullableAttribute("1")]
public IListPatternReference RangeIndexerReference { get; }
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual IPattern get_Pattern();
    public abstract virtual IPattern SetPattern(IPattern param);
    [NullableContextAttribute("1")]
public abstract virtual IListPatternReference get_RangeIndexerReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISpecificCatchClause {
    [CanBeNullAttribute]
public ICatchVariableDeclaration ExceptionDeclaration { get; }
    public ITypeUsage ExceptionTypeUsage { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ICatchVariableDeclaration get_ExceptionDeclaration();
    public abstract virtual ITypeUsage get_ExceptionTypeUsage();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ICatchVariableDeclaration SetExceptionDeclaration(ICatchVariableDeclaration param);
    public abstract virtual ITypeUsage SetExceptionTypeUsage(ITypeUsage param);
    public abstract virtual void SetCaughtType(IType type);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISpreadElement {
    [CanBeNullAttribute]
public ICSharpExpression Collection { get; }
    public ITokenNode OperatorSign { get; }
    public IReference CountOrLengthReference { get; }
    public abstract virtual ICSharpExpression get_Collection();
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual ICSharpExpression SetCollection(ICSharpExpression param);
    public abstract virtual IReference get_CountOrLengthReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IStackAllocExpression {
    public IArrayInitializer ArrayInitializer { get; }
    public ICSharpExpression DimExpr { get; }
    public ITokenNode LBracket { get; }
    public ITokenNode RBracket { get; }
    public ITokenNode StackallocKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    [NotNullAttribute]
public IType PointerType { get; }
    public abstract virtual IArrayInitializer get_ArrayInitializer();
    public abstract virtual ICSharpExpression get_DimExpr();
    public abstract virtual ITokenNode get_LBracket();
    public abstract virtual ITokenNode get_RBracket();
    public abstract virtual ITokenNode get_StackallocKeyword();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IArrayInitializer SetArrayInitializer(IArrayInitializer param);
    public abstract virtual ICSharpExpression SetDimExpr(ICSharpExpression param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IType get_PointerType();
    public abstract virtual void SetPointerType(IPointerType type);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IStartRegion {
    public ITokenNode Message { get; }
    [NotNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public IEndRegion EndRegion { get; }
    public abstract virtual ITokenNode get_Message();
    public abstract virtual string get_Name();
    public abstract virtual IEndRegion get_EndRegion();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IStatementsOwner {
    public TreeNodeCollection`1<ICSharpStatement> Statements { get; }
    public TreeNodeEnumerable`1<ICSharpStatement> StatementsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ICSharpStatement> get_Statements();
    public abstract virtual TreeNodeEnumerable`1<ICSharpStatement> get_StatementsEnumerable();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpStatementsRange GetAllStatementsRange();
    [NotNullAttribute]
public abstract virtual TStatement AddStatementAfter(TStatement statement, ICSharpStatement anchor);
    [NotNullAttribute]
public abstract virtual TStatement AddStatementBefore(TStatement statement, ICSharpStatement anchor);
    public abstract virtual void RemoveStatement(ICSharpStatement param);
    [NotNullAttribute]
public abstract virtual TStatement AddStatementBeforeRange(TStatement statement, ICSharpStatementsRange anchor);
    [NotNullAttribute]
public abstract virtual TStatement AddStatementAfterRange(TStatement statement, ICSharpStatementsRange anchor);
    [NotNullAttribute]
public abstract virtual ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange range, ICSharpStatement anchor);
    [NotNullAttribute]
public abstract virtual ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange range, ICSharpStatement anchor);
    [NotNullAttribute]
public abstract virtual ICSharpStatementsRange AddStatementsRangeAfter(ICSharpStatementsRange range, ICSharpStatementsRange anchor);
    [NotNullAttribute]
public abstract virtual ICSharpStatementsRange AddStatementsRangeBefore(ICSharpStatementsRange range, ICSharpStatementsRange anchor);
    public abstract virtual void RemoveStatementsRange(ICSharpStatementsRange range);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IStatementWithBody {
    public ICSharpStatement Body { get; }
    public abstract virtual ICSharpStatement get_Body();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IStringLiteralOwner {
    [NotNullAttribute]
public IList`1<ITokenNode> StringLiterals { get; }
    public abstract virtual IList`1<ITokenNode> get_StringLiterals();
    public abstract virtual void SetText(string literalText);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IStructDeclaration {
    [CanBeNullAttribute]
public IExtendsList ImplementedInterfacesList { get; }
    public ITokenNode StructKeyword { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeUsage> ImplementedInterfaceUsages { get; }
    public TreeNodeEnumerable`1<ITypeUsage> ImplementedInterfaceUsagesEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> TypeParameterConstraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> TypeParameterConstraintsEnumerable { get; }
    [CanBeNullAttribute]
public IStruct DeclaredElement { get; }
    [CanBeNullAttribute]
public IModifiersList ModifiersList { get; }
    public bool IsByRefLike { get; }
    public TreeNodeCollection`1<IFieldDeclaration> FieldDeclarations { get; }
    public TreeNodeEnumerable`1<IFieldDeclaration> FieldDeclarationsEnumerable { get; }
    public abstract virtual IExtendsList get_ImplementedInterfacesList();
    public abstract virtual ITokenNode get_StructKeyword();
    public abstract virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeUsage> get_ImplementedInterfaceUsages();
    public abstract virtual TreeNodeEnumerable`1<ITypeUsage> get_ImplementedInterfaceUsagesEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_TypeParameterConstraints();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_TypeParameterConstraintsEnumerable();
    public abstract virtual IExtendsList SetImplementedInterfacesList(IExtendsList param);
    public abstract virtual IStruct get_DeclaredElement();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual bool get_IsByRefLike();
    public abstract virtual void SetIsByRefLike(bool value);
    public abstract virtual TreeNodeCollection`1<IFieldDeclaration> get_FieldDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IFieldDeclaration> get_FieldDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISubpattern {
    public ICSharpExpression AccessExpression { get; }
    public ITokenNode Colon { get; }
    public IPattern Pattern { get; }
    public abstract virtual ICSharpExpression get_AccessExpression();
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual IPattern get_Pattern();
    public abstract virtual ICSharpExpression SetAccessExpression(ICSharpExpression param);
    public abstract virtual IPattern SetPattern(IPattern param);
    public abstract virtual void SetSimpleMemberAccessName(string name);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISubpatternList {
    public TreeNodeCollection`1<ISubpattern> Patterns { get; }
    public abstract virtual TreeNodeCollection`1<ISubpattern> get_Patterns();
    [NotNullAttribute]
public abstract virtual ISubpattern AddSubpatternAfter(ISubpattern subpattern, ISubpattern anchor);
    [NotNullAttribute]
public abstract virtual ISubpattern AddSubpatternBefore(ISubpattern subpattern, ISubpattern anchor);
    public abstract virtual void RemoveSubpattern(ISubpattern subpattern);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISuppressNullableWarningExpression {
    public IPrimaryExpression Operand { get; }
    public ITokenNode OperatorSign { get; }
    public abstract virtual IPrimaryExpression get_Operand();
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual IPrimaryExpression SetOperand(IPrimaryExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchBlock {
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public TreeNodeCollection`1<ISwitchSection> Sections { get; }
    public TreeNodeEnumerable`1<ISwitchSection> SectionsEnumerable { get; }
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual TreeNodeCollection`1<ISwitchSection> get_Sections();
    public abstract virtual TreeNodeEnumerable`1<ISwitchSection> get_SectionsEnumerable();
    [NotNullAttribute]
public abstract virtual ISwitchSection AddSectionBefore(ISwitchSection switchSection, ISwitchSection anchor);
    [NotNullAttribute]
public abstract virtual ISwitchSection AddSectionAfter(ISwitchSection switchSection, ISwitchSection anchor);
    public abstract virtual void RemoveSection(ISwitchSection switchSection);
    public abstract virtual void RemoveSwitchCaseLabel(ISwitchCaseLabel switchCaseLabel);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchCaseLabel {
    public ITokenNode Colon { get; }
    [CanBeNullAttribute]
public IPatternGuardClause Guard { get; }
    public ITokenNode Keyword { get; }
    public IPattern Pattern { get; }
    public ICSharpExpression ValueExpression { get; }
    public bool IsDefault { get; }
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual IPatternGuardClause get_Guard();
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual IPattern get_Pattern();
    public abstract virtual ICSharpExpression get_ValueExpression();
    public abstract virtual IPatternGuardClause SetGuard(IPatternGuardClause param);
    public abstract virtual IPattern SetPattern(IPattern param);
    public abstract virtual ICSharpExpression SetValueExpression(ICSharpExpression param);
    public abstract virtual bool get_IsDefault();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchExpression {
    public TreeNodeCollection`1<ISwitchExpressionArm> Arms { get; }
    public TreeNodeEnumerable`1<ISwitchExpressionArm> ArmsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ICSharpExpression GoverningExpression { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode SwitchKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ISwitchExpressionArm> get_Arms();
    public abstract virtual TreeNodeEnumerable`1<ISwitchExpressionArm> get_ArmsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ICSharpExpression get_GoverningExpression();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual ITokenNode get_SwitchKeyword();
    public abstract virtual ICSharpExpression SetGoverningExpression(ICSharpExpression param);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetGoverningType();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetGoverningType(IResolveContext resolveContext);
    [NotNullAttribute]
public abstract virtual ISwitchExpressionArm AddSwitchExpressionArmAfter(ISwitchExpressionArm switchExpressionArm, ISwitchExpressionArm anchor);
    [NotNullAttribute]
public abstract virtual ISwitchExpressionArm AddSwitchExpressionArmBefore(ISwitchExpressionArm switchExpressionArm, ISwitchExpressionArm anchor);
    public abstract virtual void RemoveSwitchExpressionArm(ISwitchExpressionArm switchExpressionArm);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchExpressionArm {
    public ITokenNode BodyArrow { get; }
    public ICSharpExpression Expression { get; }
    [CanBeNullAttribute]
public IPatternGuardClause Guard { get; }
    [CanBeNullAttribute]
public IPattern Pattern { get; }
    public abstract virtual ITokenNode get_BodyArrow();
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual IPatternGuardClause get_Guard();
    public abstract virtual IPattern get_Pattern();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public abstract virtual IPatternGuardClause SetGuard(IPatternGuardClause param);
    public abstract virtual IPattern SetPattern(IPattern param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchSection {
    public TreeNodeCollection`1<ISwitchCaseLabel> CaseLabels { get; }
    public TreeNodeEnumerable`1<ISwitchCaseLabel> CaseLabelsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ISwitchCaseLabel> get_CaseLabels();
    public abstract virtual TreeNodeEnumerable`1<ISwitchCaseLabel> get_CaseLabelsEnumerable();
    [NotNullAttribute]
public abstract virtual ISwitchCaseLabel AddCaseLabelAfter(ISwitchCaseLabel caseLabel, ISwitchCaseLabel anchor);
    [NotNullAttribute]
public abstract virtual ISwitchCaseLabel AddCaseLabelBefore(ISwitchCaseLabel caseLabel, ISwitchCaseLabel anchor);
    public abstract virtual void RemoveCaseLabel(ISwitchCaseLabel caseLabel);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ISwitchStatement {
    public ISwitchBlock Block { get; }
    public ITokenNode SwitchKeyword { get; }
    public TreeNodeCollection`1<ISwitchSection> Sections { get; }
    public TreeNodeEnumerable`1<ISwitchSection> SectionsEnumerable { get; }
    public ITokenNode LParenth { get; }
    public ITokenNode RParenth { get; }
    public ICSharpExpression GoverningExpression { get; }
    public abstract virtual ISwitchBlock get_Block();
    public abstract virtual ITokenNode get_SwitchKeyword();
    public abstract virtual TreeNodeCollection`1<ISwitchSection> get_Sections();
    public abstract virtual TreeNodeEnumerable`1<ISwitchSection> get_SectionsEnumerable();
    public abstract virtual ISwitchBlock SetBlock(ISwitchBlock param);
    public abstract virtual ITokenNode get_LParenth();
    public abstract virtual ITokenNode get_RParenth();
    public abstract virtual ICSharpExpression get_GoverningExpression();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetGoverningType();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetGoverningType(IResolveContext resolveContext);
    [NotNullAttribute]
public abstract virtual ICSharpExpression SetGoverningExpression(ICSharpExpression governingExpression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITargetTypedExpressionsContainer {
    [NotNullAttribute]
public IEnumerable`1<ICSharpExpression> TargetTypedExpressions { get; }
    public abstract virtual IEnumerable`1<ICSharpExpression> get_TargetTypedExpressions();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IThisExpression {
    public ITokenNode This { get; }
    public abstract virtual ITokenNode get_This();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IThrowExpression {
    public ICSharpExpression Exception { get; }
    public ITokenNode ThrowKeyword { get; }
    public abstract virtual ICSharpExpression get_Exception();
    public abstract virtual ITokenNode get_ThrowKeyword();
    public abstract virtual ICSharpExpression SetException(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IThrowStatement {
    [CanBeNullAttribute]
public ICSharpExpression Exception { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode ThrowKeyword { get; }
    public abstract virtual ICSharpExpression get_Exception();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ITokenNode get_ThrowKeyword();
    public abstract virtual ICSharpExpression SetException(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITopLevelCode {
    [NotNullAttribute]
public ITopLevelEntryPoint DeclaredElement { get; }
    public bool IsAsync { get; }
    public bool IsOnValidPosition { get; }
    public abstract virtual ITopLevelEntryPoint get_DeclaredElement();
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsOnValidPosition();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITryStatement {
    public TreeNodeCollection`1<ICatchClause> Catches { get; }
    public TreeNodeEnumerable`1<ICatchClause> CatchesEnumerable { get; }
    public IBlock FinallyBlock { get; }
    public ITokenNode FinallyKeyword { get; }
    public IBlock Try { get; }
    public ITokenNode TryKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ICatchClause> get_Catches();
    public abstract virtual TreeNodeEnumerable`1<ICatchClause> get_CatchesEnumerable();
    public abstract virtual IBlock get_FinallyBlock();
    public abstract virtual ITokenNode get_FinallyKeyword();
    public abstract virtual IBlock get_Try();
    public abstract virtual ITokenNode get_TryKeyword();
    public abstract virtual IBlock SetFinallyBlock(IBlock param);
    public abstract virtual IBlock SetTry(IBlock param);
    [NotNullAttribute]
public abstract virtual TCatchClause AddCatchClause(TCatchClause clause);
    public abstract virtual void RemoveCatchClause(ICatchClause clause);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITupleComponent {
    [CanBeNullAttribute]
public ITokenNode Colon { get; }
    public ICSharpExpression Value { get; }
    [CanBeNullAttribute]
public ICSharpIdentifier NameIdentifier { get; }
    [CanBeNullAttribute]
public IReference NamedTupleComponentReference { get; }
    [CanBeNullAttribute]
public string ExplicitComponentName { get; }
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual ICSharpExpression get_Value();
    public abstract virtual ICSharpExpression SetValue(ICSharpExpression param);
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual IReference get_NamedTupleComponentReference();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetExpressionType();
    public abstract virtual string get_ExplicitComponentName();
    public abstract virtual void SetComponentName(string name);
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier name);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITupleComponentList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITupleComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleComponent> ComponentsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ITupleComponent> get_Components();
    public abstract virtual TreeNodeEnumerable`1<ITupleComponent> get_ComponentsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITupleExpression {
    public ITupleComponentList ComponentList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITupleComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleComponent> ComponentsEnumerable { get; }
    [NotNullAttribute]
public IDeconstructionReference DeconstructionReference { get; }
    public abstract virtual ITupleComponentList get_ComponentList();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<ITupleComponent> get_Components();
    public abstract virtual TreeNodeEnumerable`1<ITupleComponent> get_ComponentsEnumerable();
    public abstract virtual ITupleComponentList SetComponentList(ITupleComponentList param);
    public abstract virtual IDeconstructionReference get_DeconstructionReference();
    [PureAttribute]
public abstract virtual int IndexOfComponent(ITupleComponent component);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetComponentSourceExpressionType(ITupleComponent component, IResolveContext resolveContext);
    [NotNullAttribute]
public abstract virtual ITupleComponent AddComponentAfter(ITupleComponent component, ITupleComponent anchor);
    [NotNullAttribute]
public abstract virtual ITupleComponent AddComponentBefore(ITupleComponent component, ITupleComponent anchor);
    public abstract virtual void RemoveComponent(ITupleComponent component);
    public abstract virtual bool IsValid();
    [NotNullAttribute]
public abstract virtual IPsiServices GetPsiServices();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITupleTypeComponent {
    [CanBeNullAttribute]
public ICSharpIdentifier NameIdentifier { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public string ExplicitName { get; }
    [CanBeNullAttribute]
public IReference NamedTupleComponentReference { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual string get_ExplicitName();
    public abstract virtual void SetComponentName(string name);
    public abstract virtual IReference get_NamedTupleComponentReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITupleTypeComponentList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IList`1<ITupleTypeComponent> Components { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IEnumerable`1<ITupleTypeComponent> ComponentsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual IList`1<ITupleTypeComponent> get_Components();
    public abstract virtual IEnumerable`1<ITupleTypeComponent> get_ComponentsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITupleTypeUsage {
    public ITupleTypeComponentList ComponentList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IList`1<ITupleTypeComponent> Components { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IEnumerable`1<ITupleTypeComponent> ComponentsEnumerable { get; }
    public abstract virtual ITupleTypeComponentList get_ComponentList();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITupleTypeComponentList SetComponentList(ITupleTypeComponentList param);
    public abstract virtual IList`1<ITupleTypeComponent> get_Components();
    public abstract virtual IEnumerable`1<ITupleTypeComponent> get_ComponentsEnumerable();
    [NotNullAttribute]
public abstract virtual ITupleTypeComponent AddTupleComponentBefore(ITupleTypeComponent component, ITupleTypeComponent anchor);
    [NotNullAttribute]
public abstract virtual ITupleTypeComponent AddTupleComponentAfter(ITupleTypeComponent component, ITupleTypeComponent anchor);
    public abstract virtual void RemoveTupleComponent(ITupleTypeComponent component);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeArgumentList {
    public TreeNodeCollection`1<ITokenNode> Commas { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommasEnumerable { get; }
    public ITokenNode LAngle { get; }
    public ITokenNode RAngle { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IList`1<ITypeUsage> TypeArgumentNodes { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<IType> TypeArguments { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Commas();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommasEnumerable();
    public abstract virtual ITokenNode get_LAngle();
    public abstract virtual ITokenNode get_RAngle();
    public abstract virtual IList`1<ITypeUsage> get_TypeArgumentNodes();
    public abstract virtual IList`1<IType> get_TypeArguments();
    public abstract virtual void RemoveTypeArgument(ITypeUsage typeUsage);
    public abstract virtual void SetTypeArguments(IType[] types);
    public abstract virtual void SetTypeArguments(ITypeUsage[] typeUsages);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeConstraint {
    public ITypeUsage TypeUsage { get; }
    [NotNullAttribute]
public IType Constraint { get; }
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IType get_Constraint();
    public abstract virtual void SetType(IType type);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeMemberArglistParameterDeclaration {
    public ITokenNode ArglistKeyword { get; }
    public abstract virtual ITokenNode get_ArglistKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeMemberRegularParameterDeclaration {
    [CanBeNullAttribute]
public IReferenceName ScalarTypeName { get; }
    public abstract virtual IReferenceName get_ScalarTypeName();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeofExpression {
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeName { get; }
    public ITokenNode TypeofKeyword { get; }
    [NotNullAttribute]
public IType ArgumentType { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TypeName();
    public abstract virtual ITokenNode get_TypeofKeyword();
    public abstract virtual ITypeUsage SetTypeName(ITypeUsage param);
    public abstract virtual IType get_ArgumentType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraint {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterConstraintsClause {
    public ITokenNode Colon { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> Constraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> ConstraintsEnumerable { get; }
    public ITypeParameterReference TypeParameter { get; }
    public ITokenNode WhereKeyword { get; }
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_Constraints();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_ConstraintsEnumerable();
    public abstract virtual ITypeParameterReference get_TypeParameter();
    public abstract virtual ITokenNode get_WhereKeyword();
    public abstract virtual ITypeParameterReference SetTypeParameter(ITypeParameterReference param);
    [NotNullAttribute]
public abstract virtual TTypeParameterConstraint AddTypeParameterConstraint(TTypeParameterConstraint constraint);
    public abstract virtual void RemoveTypeParameterConstraint(ITypeParameterConstraint constraint);
    [NotNullAttribute]
public abstract virtual TTypeConstraint AddTypeConstraintAfter(TTypeConstraint constraint, ITypeConstraint anchor);
    [NotNullAttribute]
public abstract virtual TTypeConstraint AddTypeConstraintBefore(TTypeConstraint constraint, ITypeConstraint anchor);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterDeclaration {
    public ITokenNode InKeyword { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode OutKeyword { get; }
    [CanBeNullAttribute]
public ITypeParameter DeclaredElement { get; }
    public TypeParameterVariance Variance { get; }
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITokenNode get_OutKeyword();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual ITypeParameter get_DeclaredElement();
    public abstract virtual TypeParameterVariance get_Variance();
    public abstract virtual void SetVariance(TypeParameterVariance variance);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITypeParameterConstraintsClause GetConstraintsClause();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterOfLocalFunctionDeclaration {
    public ILocalFunctionDeclaration LocalFunctionDeclaration { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public abstract virtual ILocalFunctionDeclaration get_LocalFunctionDeclaration();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterOfLocalFunctionList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LAngle { get; }
    public ITokenNode RAngle { get; }
    public TreeNodeCollection`1<ITypeParameterOfLocalFunctionDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LAngle();
    public abstract virtual ITokenNode get_RAngle();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfLocalFunctionDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfLocalFunctionDeclaration> get_TypeParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterOfMethodDeclaration {
    public IMethodDeclaration MethodDeclaration { get; }
    public abstract virtual IMethodDeclaration get_MethodDeclaration();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterOfMethodList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LAngle { get; }
    public ITokenNode RAngle { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LAngle();
    public abstract virtual ITokenNode get_RAngle();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterOfTypeDeclaration {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterOfTypeList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LAngle { get; }
    public ITokenNode RAngle { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LAngle();
    public abstract virtual ITokenNode get_RAngle();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeParameterReference {
    public ICSharpIdentifier NameIdentifier { get; }
    public IReference Reference { get; }
    public string Name { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual IReference get_Reference();
    public abstract virtual string get_Name();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypePattern {
    public IVariableDesignation Designation { get; }
    public ITypeUsage TypeUsage { get; }
    public abstract virtual IVariableDesignation get_Designation();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVariableDesignation SetDesignation(IVariableDesignation param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.ITypeUsage {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnaryExpression {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnaryOperatorExpression {
    public IUnaryExpression Operand { get; }
    public UnaryOperatorType UnaryOperatorType { get; }
    public abstract virtual IUnaryExpression get_Operand();
    public abstract virtual IUnaryExpression SetOperand(IUnaryExpression param);
    public abstract virtual UnaryOperatorType get_UnaryOperatorType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUncheckedExpression {
    public ITokenNode LPar { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode RPar { get; }
    public ITokenNode UncheckedKeyword { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ICSharpExpression get_Operand();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_UncheckedKeyword();
    public abstract virtual ICSharpExpression SetOperand(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUncheckedStatement {
    public ITokenNode UncheckedKeyword { get; }
    public abstract virtual ITokenNode get_UncheckedKeyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUndefDirective {
    public ITokenNode Name { get; }
    [NotNullAttribute]
public string SymbolName { get; }
    public abstract virtual ITokenNode get_Name();
    public abstract virtual string get_SymbolName();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeAddressOfExpression {
    public ITokenNode Address { get; }
    public IUnaryExpression Operand { get; }
    public abstract virtual ITokenNode get_Address();
    public abstract virtual IUnaryExpression get_Operand();
    public abstract virtual IUnaryExpression SetOperand(IUnaryExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerDeclaration {
    public ITokenNode EquivalenceSign { get; }
    public IVariableInitializer Initial { get; }
    public IUnsafeCodeFixedStatement DeclaringFixedStatement { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public IReferenceName ScalarTypeName { get; }
    [NotNullAttribute]
public ILocalVariable DeclaredElement { get; }
    [NotNullAttribute]
public IFixedPatternMethodReference FixedPatternReference { get; }
    public abstract virtual ITokenNode get_EquivalenceSign();
    public abstract virtual IVariableInitializer get_Initial();
    public abstract virtual IUnsafeCodeFixedStatement get_DeclaringFixedStatement();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVariableInitializer SetInitial(IVariableInitializer param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IReferenceName get_ScalarTypeName();
    public abstract virtual ILocalVariable get_DeclaredElement();
    public abstract virtual IFixedPatternMethodReference get_FixedPatternReference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedPointerInitializer {
    public ITokenNode AddressOp { get; }
    public ICSharpExpression Value { get; }
    public abstract virtual ITokenNode get_AddressOp();
    public abstract virtual ICSharpExpression get_Value();
    public abstract virtual ICSharpExpression SetValue(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeFixedStatement {
    public ICSharpStatement Body { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode FixedKeyword { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<IUnsafeCodeFixedPointerDeclaration> PointerDeclarations { get; }
    public TreeNodeEnumerable`1<IUnsafeCodeFixedPointerDeclaration> PointerDeclarationsEnumerable { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    public abstract virtual ICSharpStatement get_Body();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_FixedKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual TreeNodeCollection`1<IUnsafeCodeFixedPointerDeclaration> get_PointerDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IUnsafeCodeFixedPointerDeclaration> get_PointerDeclarationsEnumerable();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ICSharpStatement SetBody(ICSharpStatement param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual void RemovePointerDeclaration(IUnsafeCodeFixedPointerDeclaration pointerDeclaration);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodePointer {
    public ITokenNode Sign { get; }
    public abstract virtual ITokenNode get_Sign();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodePointerAccessExpression {
    public ICSharpIdentifier NameIdentifier { get; }
    public ITokenNode OperatorSign { get; }
    public IPrimaryExpression PointerExpression { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    public IManagedTwoPhaseReference Reference { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ITokenNode get_OperatorSign();
    public abstract virtual IPrimaryExpression get_PointerExpression();
    public abstract virtual ITypeArgumentList get_TypeArgumentList();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual IPrimaryExpression SetPointerExpression(IPrimaryExpression param);
    public abstract virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public abstract virtual IManagedTwoPhaseReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodePointerIndirectionExpression {
    public ITokenNode Indirection { get; }
    public IUnaryExpression Operand { get; }
    public abstract virtual ITokenNode get_Indirection();
    public abstract virtual IUnaryExpression get_Operand();
    public abstract virtual IUnaryExpression SetOperand(IUnaryExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeSizeOfExpression {
    public ITokenNode LPar { get; }
    public ITypeUsage Operand { get; }
    public ITokenNode RPar { get; }
    public ITokenNode SizeofKeyword { get; }
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITypeUsage get_Operand();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_SizeofKeyword();
    public abstract virtual ITypeUsage SetOperand(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUnsafeCodeUnsafeStatement {
    public IBlock Body { get; }
    public ITokenNode UnsafeKeyword { get; }
    public abstract virtual IBlock get_Body();
    public abstract virtual ITokenNode get_UnsafeKeyword();
    public abstract virtual IBlock SetBody(IBlock param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUserTypeUsage {
    public IReferenceName ScalarTypeName { get; }
    public abstract virtual IReferenceName get_ScalarTypeName();
    public abstract virtual IReferenceName SetScalarTypeName(IReferenceName param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUsingAliasDirective {
    public ICSharpIdentifier Alias { get; }
    public ITokenNode EquivalenceSign { get; }
    public ITypeUsage NamespaceOrType { get; }
    [NullableAttribute("1")]
public string AliasName { get; }
    [NullableAttribute("1")]
public ISymbolAlias DeclaredElement { get; }
    public abstract virtual ICSharpIdentifier get_Alias();
    public abstract virtual ITokenNode get_EquivalenceSign();
    public abstract virtual ITypeUsage get_NamespaceOrType();
    public abstract virtual ICSharpIdentifier SetAlias(ICSharpIdentifier param);
    public abstract virtual ITypeUsage SetNamespaceOrType(ITypeUsage param);
    [NullableContextAttribute("1")]
public abstract virtual string get_AliasName();
    [NullableContextAttribute("1")]
public abstract virtual ISymbolAlias get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUsingDirective {
    [CanBeNullAttribute]
public ITokenNode GlobalKeyword { get; }
    public ITokenNode Semicolon { get; }
    [CanBeNullAttribute]
public ITokenNode StaticKeyword { get; }
    [CanBeNullAttribute]
public ITokenNode UnsafeKeyword { get; }
    public ITokenNode UsingKeyword { get; }
    public bool IsStatic { get; }
    public bool IsGlobal { get; }
    public bool IsUnsafe { get; }
    public bool IsAlias { get; }
    public abstract virtual ITokenNode get_GlobalKeyword();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ITokenNode get_StaticKeyword();
    public abstract virtual ITokenNode get_UnsafeKeyword();
    public abstract virtual ITokenNode get_UsingKeyword();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsGlobal();
    public abstract virtual bool get_IsUnsafe();
    public abstract virtual bool get_IsAlias();
    public abstract virtual void SetStatic(bool isStatic);
    public abstract virtual void SetGlobal(bool isGlobal);
    public abstract virtual void SetUnsafe(bool isUnsafe);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUsingList {
    public TreeNodeCollection`1<IExternAliasDirective> ExternAliases { get; }
    public TreeNodeEnumerable`1<IExternAliasDirective> ExternAliasesEnumerable { get; }
    public TreeNodeCollection`1<IUsingDirective> Imports { get; }
    public TreeNodeEnumerable`1<IUsingDirective> ImportsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IExternAliasDirective> get_ExternAliases();
    public abstract virtual TreeNodeEnumerable`1<IExternAliasDirective> get_ExternAliasesEnumerable();
    public abstract virtual TreeNodeCollection`1<IUsingDirective> get_Imports();
    public abstract virtual TreeNodeEnumerable`1<IUsingDirective> get_ImportsEnumerable();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUsingStatement {
    public ITokenNode AwaitKeyword { get; }
    public ICSharpStatement Body { get; }
    public IMultipleLocalVariableDeclaration Declaration { get; }
    public IResourceAcquisitionExpressionsList ExpressionsList { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode UsingKeyword { get; }
    public TreeNodeCollection`1<ICSharpExpression> Expressions { get; }
    public TreeNodeEnumerable`1<ICSharpExpression> ExpressionsEnumerable { get; }
    public TreeNodeCollection`1<ILocalVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<ILocalVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public bool IsAwait { get; }
    public UsingDeclarationKind Kind { get; }
    public abstract virtual ITokenNode get_AwaitKeyword();
    public abstract virtual ICSharpStatement get_Body();
    public abstract virtual IMultipleLocalVariableDeclaration get_Declaration();
    public abstract virtual IResourceAcquisitionExpressionsList get_ExpressionsList();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_UsingKeyword();
    public abstract virtual TreeNodeCollection`1<ICSharpExpression> get_Expressions();
    public abstract virtual TreeNodeEnumerable`1<ICSharpExpression> get_ExpressionsEnumerable();
    public abstract virtual TreeNodeCollection`1<ILocalVariableDeclaration> get_VariableDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalVariableDeclaration> get_VariableDeclarationsEnumerable();
    public abstract virtual ICSharpStatement SetBody(ICSharpStatement param);
    public abstract virtual IMultipleLocalVariableDeclaration SetDeclaration(IMultipleLocalVariableDeclaration param);
    public abstract virtual IResourceAcquisitionExpressionsList SetExpressionsList(IResourceAcquisitionExpressionsList param);
    public abstract virtual bool get_IsAwait();
    public abstract virtual void SetAwait(bool isAwait);
    public abstract virtual UsingDeclarationKind get_Kind();
    [NotNullAttribute]
public abstract virtual ILocalVariableDeclaration AddVariableDeclarationBefore(ILocalVariableDeclaration variableDeclaration, ILocalVariableDeclaration anchor);
    [NotNullAttribute]
public abstract virtual ILocalVariableDeclaration AddVariableDeclarationAfter(ILocalVariableDeclaration variableDeclaration, ILocalVariableDeclaration anchor);
    public abstract virtual void RemoveVariableDeclaration(ILocalVariableDeclaration variableDeclaration);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
public abstract virtual TExpression SetExpression(TExpression expression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IUsingSymbolDirective {
    public IReferenceName ImportedSymbolName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DeclaredElementInstance`1<IDeclaredElement> ImportedSymbol { get; }
    public abstract virtual IReferenceName get_ImportedSymbolName();
    public abstract virtual IReferenceName SetImportedSymbolName(IReferenceName param);
    public abstract virtual DeclaredElementInstance`1<IDeclaredElement> get_ImportedSymbol();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IValueTypeConstraint {
    public ITokenNode Keyword { get; }
    public abstract virtual ITokenNode get_Keyword();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IVarDeconstructionPattern {
    public IParenthesizedVariableDesignation Designation { get; }
    public ITokenNode VarKeyword { get; }
    public abstract virtual IParenthesizedVariableDesignation get_Designation();
    public abstract virtual ITokenNode get_VarKeyword();
    public abstract virtual IParenthesizedVariableDesignation SetDesignation(IParenthesizedVariableDesignation param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDeclaration {
    public ICSharpIdentifier NameIdentifier { get; }
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDesignation {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IVariableDesignationContainer {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetSourceType(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetSourceExpressionType(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetDesignationType(IVariableDesignation designation, IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetDesignationExpressionType(IVariableDesignation designation, IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IVariableInitializer {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IVarPattern {
    public IVariableDesignation Designation { get; }
    public ITokenNode VarKeyword { get; }
    public abstract virtual IVariableDesignation get_Designation();
    public abstract virtual ITokenNode get_VarKeyword();
    public abstract virtual IVariableDesignation SetDesignation(IVariableDesignation param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IWarningAction {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IWarningDirective {
    public ITokenNode Message { get; }
    public abstract virtual ITokenNode get_Message();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IWarningList {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IWhileStatement {
    public ICSharpStatement Body { get; }
    public ICSharpExpression Condition { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode WhileKeyword { get; }
    public abstract virtual ICSharpStatement get_Body();
    public abstract virtual ICSharpExpression get_Condition();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_WhileKeyword();
    public abstract virtual ICSharpStatement SetBody(ICSharpStatement param);
    public abstract virtual ICSharpExpression SetCondition(ICSharpExpression param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IWithExpression {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IWithInitializerAssignment> Initializers { get; }
    public TreeNodeEnumerable`1<IWithInitializerAssignment> InitializersEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ICSharpExpression Operand { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode WithKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IWithInitializerAssignment> get_Initializers();
    public abstract virtual TreeNodeEnumerable`1<IWithInitializerAssignment> get_InitializersEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ICSharpExpression get_Operand();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual ITokenNode get_WithKeyword();
    public abstract virtual ICSharpExpression SetOperand(ICSharpExpression param);
    [NotNullAttribute]
public abstract virtual IWithInitializerAssignment AddWithInitializerAssignmentAfter(IWithInitializerAssignment withInitializerAssignment, IWithInitializerAssignment anchor);
    [NotNullAttribute]
public abstract virtual IWithInitializerAssignment AddWithInitializerAssignmentBefore(IWithInitializerAssignment withInitializerAssignment, IWithInitializerAssignment anchor);
    public abstract virtual void RemoveWithInitializerAssignment(IWithInitializerAssignment switchExpressionArm);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IWithInitializerAssignment {
    public ITokenNode Eq { get; }
    public ICSharpExpression Expression { get; }
    public ICSharpIdentifier NameIdentifier { get; }
    [NotNullAttribute]
public IManagedReference MemberReference { get; }
    [NotNullAttribute]
public string MemberName { get; }
    public abstract virtual ITokenNode get_Eq();
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ICSharpIdentifier get_NameIdentifier();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public abstract virtual ICSharpIdentifier SetNameIdentifier(ICSharpIdentifier param);
    public abstract virtual IManagedReference get_MemberReference();
    public abstract virtual string get_MemberName();
    public abstract virtual void SetMemberName(string name);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.IYieldStatement {
    public ITokenNode BreakKeyword { get; }
    public ICSharpExpression Expression { get; }
    public ITokenNode ReturnKeyword { get; }
    public ITokenNode Semicolon { get; }
    public ITokenNode YieldKeyword { get; }
    public YieldStatementType StatementType { get; }
    public abstract virtual ITokenNode get_BreakKeyword();
    public abstract virtual ICSharpExpression get_Expression();
    public abstract virtual ITokenNode get_ReturnKeyword();
    public abstract virtual ITokenNode get_Semicolon();
    public abstract virtual ITokenNode get_YieldKeyword();
    public abstract virtual ICSharpExpression SetExpression(ICSharpExpression param);
    public abstract virtual YieldStatementType get_StatementType();
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.KeywordNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LabelDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILabelDeclaration GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LabelReferenceElementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILabelReferenceElement GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LabelStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILabelStatement GetByLabel(ILabelDeclaration param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LambdaExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLinqExpressionTreeLambda(ILambdaExpression lambdaExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLinqExpressionTreeLambda(ILambdaExpression lambdaExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnderLinqExpressionTree(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnderLinqExpressionTree(ITreeNode node, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasAnyAttributes(ILambdaExpression lambdaExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSignatureParenthesesRedundant(ILambdaExpression lambdaExpression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LambdaExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetByAttributeSectionList(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetByBodyBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetByBodyExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetByParameterDeclaration(ILocalRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetByReturnType(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetBySignature(ILambdaSignature param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LambdaSignatureNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaSignature GetByParameterDeclaration(ILocalRegularParameterDeclaration param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LineDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILineDirective GetByLineIndicator(ILineIndicator param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LineIndicatorNavigator : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ListPatternExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmptyListPattern(IListPattern listPattern);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<Index> TryGetIndexOfListPatternItemPattern(IPattern itemPattern);
    [ExtensionAttribute]
[PureAttribute]
public static IType GetElementType(IListPattern listPattern, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool OnlyChecksForLengthInSyntax(IListPattern listPattern);
    [ExtensionAttribute]
[PureAttribute]
public static ListPatternInfo GetPatternInfo(IListPattern listPattern);
    [ExtensionAttribute]
[PureAttribute]
public static ListPatternItemInfo GetPatternItemInfo(IListPattern listPattern, IPattern itemPattern);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Tree.ListPatternInfo : ValueType {
    public static ListPatternInfo Invalid;
    [CompilerGeneratedAttribute]
private int <MinimalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ISlicePattern <SlicePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountBeforeSlice>k__BackingField;
    public bool IsWellFormed { get; }
    public int MinimalCount { get; }
    public bool CountIsExact { get; }
    public ISlicePattern SlicePattern { get; }
    public int CountBeforeSlice { get; }
    public int CountAfterSlice { get; }
    internal ListPatternInfo(int minimalCount, ISlicePattern slicePattern, int countBeforeSlice);
    private static ListPatternInfo();
    public bool get_IsWellFormed();
    [CompilerGeneratedAttribute]
public int get_MinimalCount();
    public bool get_CountIsExact();
    [CompilerGeneratedAttribute]
public ISlicePattern get_SlicePattern();
    [CompilerGeneratedAttribute]
public int get_CountBeforeSlice();
    public int get_CountAfterSlice();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Tree.ListPatternItemInfo : ValueType {
    [DebuggerBrowsableAttribute("0")]
private int myHeadIndex;
    [DebuggerBrowsableAttribute("0")]
private int myTailIndex;
    public static ListPatternItemInfo Invalid;
    public bool IsValid { get; }
    public Nullable`1<Index> ItemIndex { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<int, int>> SliceRange { get; }
    internal ListPatternItemInfo(int headIndex, int tailIndex);
    private static ListPatternItemInfo();
    public bool get_IsValid();
    public Nullable`1<Index> get_ItemIndex();
    public Nullable`1<ValueTuple`2<int, int>> get_SliceRange();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ListPatternNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IListPattern GetByDesignation(IVariableDesignation param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IListPattern GetByPattern(IPattern param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalArglistParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalArglistParameterDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalArglistParameterDeclaration GetByAttributeSectionList(IAttributeSectionList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalConstantDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalConstantDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<ILocalConstantDeclaration> GetByTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalConstantDeclaration GetByValueExpression(ICSharpExpression param);
    [NullableContextAttribute("0")]
[PureAttribute]
[ItemCanBeNullAttribute]
public static TreeNodeCollection`1<ILocalConstantDeclaration> GetByScalarTypeName(IReferenceName scalarTypeName);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalFormalParameterListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFormalParameterList GetByParameterDeclaration(ILocalParameterDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalFunctionDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByAttributeSectionList(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByParameterDeclaration(ILocalParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByParameterList(ILocalFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByTypeParameterConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByTypeParameterDeclaration(ITypeParameterOfLocalFunctionDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByTypeParameterList(ITypeParameterOfLocalFunctionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByTypeUsage(ITypeUsage param);
    [PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalFunctionDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalParameterDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDiscardByName(ILocalParameterDeclaration localParameterDeclaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDiscardThatCannotBeReferenced(ILocalParameterDeclaration localParameterDeclaration);
    [ExtensionAttribute]
public static ILocalParameterDeclaration SetScope(ILocalParameterDeclaration declaration, ScopedKind scope, Nullable`1<bool> requiredUnscopedRefAttribute, IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
internal static bool <SetScope>g__SetExplicitType|2_0(ILocalParameterDeclaration& declaration, IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
internal static void <SetScope>g__RemoveUnscopedRefAttributes|2_1(ILocalParameterDeclaration declaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalParameterDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalParameterDeclaration GetByAttributeSectionList(IAttributeSectionList param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalRegularParameterDeclarationExtensions : object {
    [ExtensionAttribute]
public static void SetScopedKeyword(ILocalRegularParameterDeclaration declaration, bool addScopedKeyword);
    [ExtensionAttribute]
public static ILocalParameterDeclaration SetScope(ILocalRegularParameterDeclaration cSharpRegularParameterDeclaration, ScopedKind scope, Nullable`1<bool> requiredUnscopedRefAttribute, IResolveContext resolveContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalRegularParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalRegularParameterDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalRegularParameterDeclaration GetByAttributeSectionList(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalRegularParameterDeclaration GetByDefaultValue(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalRegularParameterDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalRegularParameterDeclaration GetByParameterModifiersList(IParameterModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalRegularParameterDeclaration GetByTypeUsage(ITypeUsage param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalVariableDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUsingVariable(ILocalVariableDeclaration localVariableDeclaration);
    [ExtensionAttribute]
[PureAttribute]
public static UsingDeclarationKind GetDeclarationOrStatementUsingKind(ILocalVariableDeclaration localVariableDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LocalVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalVariableDeclaration GetByInitial(IVariableInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalVariableDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<ILocalVariableDeclaration> GetByTypeUsage(ITypeUsage param);
    [NullableContextAttribute("0")]
[PureAttribute]
[ItemCanBeNullAttribute]
public static TreeNodeCollection`1<ILocalVariableDeclaration> GetByScalarTypeName(IReferenceName scalarTypeName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LockStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILockStatement GetByBody(ICSharpStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILockStatement GetByMonitor(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.LoopStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILoopStatement GetByBody(ICSharpStatement statement);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILoopStatement GetByBreakStatement(IBreakStatement breakStatement);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILoopStatement GetByContinueStatement(IContinueStatement continueStatement);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MakerefExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMakerefExpression GetByExpression(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MemberInitializerExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInitOnlyMemberInitializer(IMemberInitializer initializer);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsMandatoryInitializerOfRequiredMember(IMemberInitializer initializer);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MemberInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInitializedMemberInitializer GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInitializedMemberInitializer GetByInitializer(ICreationExpressionInitializer param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MemberOwnerBodyNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MemberOwnerDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMemberOwnerDeclaration GetByBody(IMemberOwnerBody body);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MethodDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPartialMethodDeclaration(IMethodDeclaration methodDeclaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPartialMethodDefinition(IMethodDeclaration methodDeclaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsOverrideOrExplicitImplementation(IMethodDeclaration methodDeclaration);
    [ExtensionAttribute]
public static void RemoveTypeParameterConstraintsClauses(IMethodDeclaration methodDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MethodDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByAttributeSectionList(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByTypeParameterDeclaration(ITypeParameterOfMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByTypeParameterList(ITypeParameterOfMethodList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MissingDesignationNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ModifierListOwnerNavigator : object {
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModifiersListOwner GetByModifiersList(IModifiersList modifiersList);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModifiersListOwner GetByModifiersOwner(ICSharpModifiersOwnerDeclaration modifiersOwnerDeclaration);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ModifiersListExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindFirstModifier(IModifiersList modifiersList, TokenNodeType tokenType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindLastModifier(IModifiersList modifiersList, TokenNodeType tokenType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindPreviousModifier(IModifiersList modifiersList, ITreeNode anchor);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindNextModifier(IModifiersList modifiersList, ITreeNode anchor);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasModifier(IModifiersList modifiersList, TokenNodeType tokenType);
    [ExtensionAttribute]
public static void RemoveIfEmpty(IModifiersList modifiersList);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.ModifiersListExtensions/<ModifiersWithoutTailRefReturnKind>d__6")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
internal static IEnumerable`1<ITokenNode> ModifiersWithoutTailRefReturnKind(IModifiersList modifiersList);
    [CompilerGeneratedAttribute]
internal static bool <ModifiersWithoutTailRefReturnKind>g__CanHaveRefReturnKind|6_0(<>c__DisplayClass6_0& );
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ModifiersListNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultipleConstantDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleConstantDeclaration GetByAttributes(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleConstantDeclaration GetByDeclarator(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleConstantDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleConstantDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultipleDeclarationMemberNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleDeclarationMember GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultipleDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleDeclaration GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultipleEventDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleEventDeclaration GetByAttributes(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleEventDeclaration GetByDeclarator(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleEventDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleEventDeclaration GetByTypeUsage(ITypeUsage param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleEventDeclaration GetByDeclaredTypeUsage(ITypeUsage typeUsage);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultipleFieldDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleFieldDeclaration GetByAttributes(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleFieldDeclaration GetByDeclarator(IFieldDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleFieldDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleFieldDeclaration GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultipleLocalConstantDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleLocalConstantDeclaration GetByDeclarator(ILocalConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleLocalConstantDeclaration GetByTypeUsage(ITypeUsage param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultipleLocalVariableDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static UsingDeclarationKind GetDeclarationOrStatementUsingKind(IMultipleLocalVariableDeclaration multipleLocalVariableDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultipleLocalVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleLocalVariableDeclaration GetByDeclarator(ILocalVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleLocalVariableDeclaration GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.MultiplicativeExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultiplicativeExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultiplicativeExpression GetByRightOperand(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.NamedMemberInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyInitializer GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyInitializer GetByInitializer(ICreationExpressionInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyInitializer GetByNameIdentifier(ICSharpIdentifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.NamespaceBodyNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INamespaceBody GetByImportsList(IUsingList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INamespaceBody GetByNamespaceDeclarationNode(ICSharpNamespaceDeclaration param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.NegatedPatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INegatedPattern GetByPattern(IPattern param);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Tree.NullableContextCache : object {
    private static NullableContextCache ourEmptyCache;
    private Region[] myRegions;
    private TreeOffset myFirstDirectiveStartOffset;
    private TreeOffset myLastDirectiveStartOffset;
    private NullableContextCache(Region[] regions, TreeOffset firstDirectiveStartOffset, TreeOffset lastDirectiveStartOffset);
    private static NullableContextCache();
    [PureAttribute]
public static NullableContextCache TryBuild(IArrayOfTokens tokens);
    [PureAttribute]
public static NullableContextCache Build(ICSharpFile file);
    [PureAttribute]
private static NullableContextCache Build(TreeOffset firstDirectiveStartOffset, TreeOffset lastDirectiveStartOffset, LocalList`1& regions, ITreeNode nodeToProcess);
    [PureAttribute]
public NullableContextInfo GetNullableContextAt(TreeOffset& offset);
    [PureAttribute]
public NullableContextInfo GetMergedNullableContext(TreeTextRange& range, bool isGeneratedFile, NullableContextInfo& moduleNullableContext, Func`3<NullableContext, NullableContext, NullableContext> merge);
    [PureAttribute]
public bool HasNullableContextChangesIn(TreeTextRange& range);
    [PureAttribute]
public bool HasNullableDirectivesAfter(TreeOffset& offset);
    [PureAttribute]
public bool HasNullableDirectivesBefore(TreeOffset& offset);
    private bool TryGetRegionBounds(TreeTextRange& range, Int32& startIndex, Int32& endIndex);
    public void Write(UnsafeWriter writer);
    [PureAttribute]
public static NullableContextCache Read(UnsafeReader reader);
    [PureAttribute]
public NullableContextCache InvalidateOnSubTreeChange(ICSharpFile file, ITreeNode changedNode);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.NullableDirectiveNavigator : object {
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.NullableDirectiveSettingKind : Enum {
    public int value__;
    public static NullableDirectiveSettingKind Enable;
    public static NullableDirectiveSettingKind Disable;
    public static NullableDirectiveSettingKind Restore;
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.NullableDirectiveTargetKind : Enum {
    public int value__;
    public static NullableDirectiveTargetKind Annotations;
    public static NullableDirectiveTargetKind Warnings;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.NullableTypeMarkNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.NullableTypeUsageNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INullableTypeUsage GetByNullableMark(INullableTypeMark param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INullableTypeUsage GetByUnderlyingType(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.NullCoalescingExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INullCoalescingExpression GetByLeftOperand(ICSharpExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INullCoalescingExpression GetByRightOperand(ICSharpExpression param);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static INullCoalescingExpression GetByAnyOperand(ICSharpExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ObjectCreationExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsArgumentListRedundant(IObjectCreationExpression creationExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasEmptyArgumentList(IObjectCreationExpression creationExpression);
    [ExtensionAttribute]
public static void RemoveArgumentList(IObjectCreationExpression objectCreation);
    [ExtensionAttribute]
public static void RemoveInitializer(IObjectCreationExpression objectCreation);
    [ExtensionAttribute]
public static void SetCreatedType(IObjectCreationExpression expression, IDeclaredType declaredType);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ObjectCreationExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByArgument(ICSharpArgument param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByArgumentList(IArgumentList param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByInitializer(ICreationExpressionInitializer param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByTypeUsage(ITypeUsage param);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static IObjectCreationExpression GetByReference(IReference reference);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static IObjectCreationExpression GetByCreatedTypeUsage(ITypeUsage typeUsage);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static IObjectCreationExpression GetByTypeName(IReferenceName referenceName);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("initializerElement: null => null")]
public static IObjectCreationExpression GetRootByInitializerElement(IInitializerElement initializerElement);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ObjectInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectInitializer GetByMemberInitializer(IMemberInitializer param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.OperatorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.OperatorExpressionNavigator : object {
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static IOperatorExpression GetByOperand(ICSharpExpression operand);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.OrPatternNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOrPattern GetByLeftPattern(IPattern param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOrPattern GetByRightPattern(IPattern param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.OverflowCheckingStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOverflowCheckingStatement GetByBody(IBlock param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.OwnerQualificationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOwnerQualification GetByQualifier(IReferenceName param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ParameterModifiersListExtensions : object {
    [ExtensionAttribute]
public static ScopedKind GetDeclarationScope(IParameterModifiersList modifiersList);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindFirstModifier(IParameterModifiersList modifiersList, TokenNodeType tokenType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindFirstParameterModeModifier(IParameterModifiersList modifiersList);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindLastModifier(IParameterModifiersList modifiersList, TokenNodeType tokenType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindPreviousModifier(IParameterModifiersList modifiersList, ITreeNode anchor);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindNextModifier(IParameterModifiersList modifiersList, ITreeNode anchor);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasModifier(IParameterModifiersList modifiersList, TokenNodeType tokenType);
    [ExtensionAttribute]
public static void RemoveIfEmpty(IParameterModifiersList modifiersList);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ParameterModifiersListNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ParenthesizedExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IParenthesizedExpression GetByExpression(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ParenthesizedPatternExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IDeconstructionReference GetPossibleDeconstructionReference(IParenthesizedPattern parenthesizedPattern);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IDeconstructionReference TryGetPossibleDeconstructionReference(IParenthesizedExpression parenthesizedExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ParenthesizedPatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IParenthesizedPattern GetByPattern(IPattern param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ParenthesizedVariableDesignationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsWellFormed(IParenthesizedVariableDesignation designation);
    public static void ToTupleLikeForm(IParenthesizedVariableDesignation parenthesizedDesignation, FactoryArgumentsBuilder& builder, bool recursiveRewrite);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ParenthesizedVariableDesignationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IParenthesizedVariableDesignation GetByChildrenDesignation(IVariableDesignation param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IParenthesizedVariableDesignation GetByVariableDesignationRecursively(IVariableDesignation variableDesignation);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PatternExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool ChecksInputForNull(IPattern this);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasNotNullOutput(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanChangeNarrowedType(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFineToChangeTheInputType(IPattern pattern, bool allowToBreakDag);
    [ExtensionAttribute]
[PureAttribute]
public static PatternMatchKind Negate(PatternMatchKind matchKind);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IPattern GetPatternThroughParentheses(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IPattern GetContainingParenthesizedPattern(IPattern pattern);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPattern UnwrapFromSandbox(IPattern pattern);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetDispatchType(IPattern pattern, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExpressionType GetDispatchExpressionType(IPattern pattern, IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
private static IExpressionType GetDispatchExpressionTypeByParentNode(ITreeNode parentNode, IResolveContext resolveContext);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression TryGetDispatchExpression(IPattern pattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static TPattern ReplaceBy(IPattern pattern, TPattern newPattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool NeedToParenthesize(IPattern pattern, IPattern replacedBy);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanUseDiscardPattern(IPattern patternContext);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool HasExplicitTypeChecking(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> true, typeCheckType: notnull, pattern: notnull")]
[ContractAnnotationAttribute("=> false, typeCheckType: null")]
public static bool HasExplicitTypeChecking(IPattern pattern, IType& typeCheckType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsOldIsTypeCheckPattern(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsConstantPattern(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsConstantPattern(IPattern pattern, ConstantValue& constantValue);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDiscardOrDiscardedVarPattern(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPatternTypeCapturedForNextPatterns(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanDeclareDesignation(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsITupleDeconstructionPattern(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasDesignationsUnderNegatedPattern(IPattern pattern);
    [ExtensionAttribute]
public static bool IsUnfinished(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasSingleVariableDesignations(IPattern pattern);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.PatternExtensions/<GetSingleVariableDesignations>d__27")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<ISingleVariableDesignation> GetSingleVariableDesignations(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNegatedNullNotNullCheckPattern(IPattern pattern);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.PatternExtensions/<GetOrPatternOperands>d__29")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemCanBeNullAttribute]
public static IEnumerable`1<IPattern> GetOrPatternOperands(IPattern pattern);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.PatternExtensions/<GetAndPatternOperands>d__30")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemCanBeNullAttribute]
public static IEnumerable`1<IPattern> GetAndPatternOperands(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNegated(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("pattern: null => null, isNegated: false; pattern: notnull => notnull")]
public static IPattern GetContainingNegatedPattern(IPattern pattern, Boolean& isNegated);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("pattern: null => null, isNegated: false; pattern: notnull => notnull")]
public static IPattern GetPatternThroughNegations(IPattern pattern, Boolean& isNegated);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTopLevel(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("onlyIfReducesComplexity: false => notnull")]
[ContractAnnotationAttribute("onlyIfReducesComplexity: true => canbenull")]
public static IPattern CreateLogicallyNegatedPatternInCSharp9(IPattern pattern, bool onlyIfReducesComplexity);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSubjectOfIsExpressionInTernaryWithCollectionExpressionSyntaxAmbiguity(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static IPattern GetSyntacticallyMostRightNotParenthesizedPattern(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool SyntacticallyEndsWithTypeUsage(IPattern pattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNarrowedTypeCaptured(IPattern pattern);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static PooledHashSet`1<ISingleVariableDesignation> CollectDefinitelyAssignedPatternVariables(IPattern pattern, bool isTopLevelPattern);
    [CompilerGeneratedAttribute]
internal static bool <CanChangeNarrowedType>g__CanBeITupleDeconstruction|2_0(IDeconstructionReference deconstructionReference);
    [CompilerGeneratedAttribute]
internal static int <NeedToParenthesize>g__CalcPatternPriority|13_0(IPattern pattern);
    [CompilerGeneratedAttribute]
internal static bool <IsUnfinished>g__IsValidDeconstruction|25_0(IDeconstructionReference deconstructionReference);
    [CompilerGeneratedAttribute]
internal static void <CollectDefinitelyAssignedPatternVariables>g__CollectDefinitelyAssignPatternVariables|40_0(PooledHashSet`1& assignedVariables, IPattern pattern, bool isTopLevel);
    [CompilerGeneratedAttribute]
internal static void <CollectDefinitelyAssignedPatternVariables>g__Assign|40_1(PooledHashSet`1& assignedVariables, IVariableDesignation variableDesignation);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PatternGuardClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPatternGuardClause GetByCondition(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PatternGuardExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("patternGuardClause:null => true")]
public static bool IsAbsentOrAlwaysTrue(IPatternGuardClause patternGuardClause, IResolveContext resolveContext);
    [ExtensionAttribute]
public static void Remove(IPatternGuardClause patternGuardClause);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.PatternMatchKind : Enum {
    public int value__;
    public static PatternMatchKind MatchesAlways;
    public static PatternMatchKind CanOnlyMatchWhenNotNull;
    public static PatternMatchKind MatchesNull;
    public static PatternMatchKind Unknown;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PatternNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPatternWithDesignation GetByDesignationRecursively(IVariableDesignation variableDesignation);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPatternWithDesignation GetByDesignation(IVariableDesignation variableDesignation);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPatternWithTypeUsage GetByTypeUsage(ITypeUsage typeUsage);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PatternWithDesignationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanHaveNoDesignation(IPatternWithDesignation pattern);
    private static bool RequiresDesignationToAvoidResolvingIntoConstant(ITypePattern typePattern);
    private static bool RequiresDesignationToAvoidParsingAsCastExpression(ITypePattern typePattern);
    [ExtensionAttribute]
public static void RemoveDesignation(IPatternWithDesignation pattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static TDesignation SetDesignation(IPatternWithDesignation pattern, TDesignation designation);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPatternWithDesignation EnsureHasDesignation(IPattern pattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static IVarPattern ReplaceWithVarPattern(IPatternWithDesignation recursivePattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool DesignationIsOfDispatchType(IPatternWithDesignation patternWithDesignation);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PatternWithTypeCheckExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanRemoveTypeCheck(IPattern pattern);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PointerTypeUsageNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPointerTypeUsage GetByElementType(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPointerTypeUsage GetByPointerMark(IUnsafeCodePointer param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PostfixOperatorExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPostfixOperatorExpression GetByOperand(IPrimaryExpression param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.PostfixOperatorType : Enum {
    public int value__;
    public static PostfixOperatorType INVALID;
    public static PostfixOperatorType PLUSPLUS;
    public static PostfixOperatorType MINUSMINUS;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PragmaDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PredefinedTypeExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPredefinedTypeExpression GetByPredefinedTypeName(IPredefinedTypeReference param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PredefinedTypeReferenceNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PredefinedTypeUsageNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPredefinedTypeUsage GetByScalarPredefinedTypeName(IPredefinedTypeReference param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PrefixOperatorExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPrefixOperatorExpression GetByOperand(IUnaryExpression param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.PrefixOperatorType : Enum {
    public int value__;
    public static PrefixOperatorType INVALID;
    public static PrefixOperatorType PLUSPLUS;
    public static PrefixOperatorType MINUSMINUS;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorAndExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPreprocessorAndExpression GetByLeftOperand(IPreprocessorExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPreprocessorAndExpression GetByRightOperand(IPreprocessorExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorConditionalSymbolExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTrueConstant(IPreprocessorConditionalSymbol conditionalSymbol);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFalseConstant(IPreprocessorConditionalSymbol conditionalSymbol);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorConditionalSymbolNavigator : object {
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorDirectiveKind : Enum {
    public int value__;
    public static PreprocessorDirectiveKind INVALID;
    public static PreprocessorDirectiveKind DEFINE;
    public static PreprocessorDirectiveKind UNDEF;
    public static PreprocessorDirectiveKind ERROR;
    public static PreprocessorDirectiveKind WARNING;
    public static PreprocessorDirectiveKind IF;
    public static PreprocessorDirectiveKind ELIF;
    public static PreprocessorDirectiveKind ELSE;
    public static PreprocessorDirectiveKind ENDIF;
    public static PreprocessorDirectiveKind LINE;
    public static PreprocessorDirectiveKind REGION;
    public static PreprocessorDirectiveKind ENDREGION;
    public static PreprocessorDirectiveKind PRAGMA;
    public static PreprocessorDirectiveKind NULLABLE;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorDirectiveNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorEqualityExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPreprocessorEqualityExpression GetByLeftOperand(IPreprocessorExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPreprocessorEqualityExpression GetByRightOperand(IPreprocessorExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorExpressionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorNegationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPreprocessorNegation GetByOperand(IPreprocessorUnaryExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorOrExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPreprocessorOrExpression GetByLeftOperand(IPreprocessorExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPreprocessorOrExpression GetByRightOperand(IPreprocessorExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorParenthesizedExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPreprocessorParenthesizedExpression GetByOperand(IPreprocessorExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorPragmaBodyNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PreprocessorUnaryExpressionNavigator : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PrimaryConstructorDeclarationExtension : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("declaration: null => null")]
public static IExtendedType GetBaseClassInitializer(IPrimaryConstructorDeclaration declaration, bool requireArgumentList);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("declaration: null => null")]
public static IExtendedType GetBaseClassInitializer(IClassLikeDeclaration declaration, bool requireArgumentList);
    [ExtensionAttribute]
public static ICSharpParametersOwnerDeclaration GetContainingConstructorDeclaration(ICSharpTreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInContextWhereReferenceToPrimaryParameterIsAFormalParameterReference(ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsMutableAccessReferenceExpression(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static IParameter TryGetPrimaryConstructorParameterUsedAsValue(ICSharpArgument argument, ICSharpTypeConversionRule conversionRule, IReferenceExpression& primaryParameterReferenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static IParameter TryGetPrimaryConstructorParameterUsedAsValue(IExpressionInitializer expressionInitializer, ICSharpTypeMemberDeclaration typeMemberDeclaration, ICSharpTypeConversionRule conversionRule, IReferenceExpression& primaryParameterReferenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static PrimaryParameterUsageKind ClassifyPrimaryParameterUsages(IParameter primaryParameter, IUsagesProvider usagesProvider);
    [ExtensionAttribute]
[PureAttribute]
public static IPrimaryConstructorDeclaration TryGetContainingPrimaryConstructorDeclarationFromExtendedTypeArguments(ITreeNode node, bool returnThis);
    [CompilerGeneratedAttribute]
internal static bool <ClassifyPrimaryParameterUsages>g__IsDelayedReadFromClosure|7_0(IReferenceExpression primaryParameterUsage);
    [CompilerGeneratedAttribute]
internal static bool <ClassifyPrimaryParameterUsages>g__IsCapturedIntoInstanceField|7_1(IReferenceExpression primaryParameterUsage, IParameter primaryParameter);
    [CompilerGeneratedAttribute]
internal static bool <ClassifyPrimaryParameterUsages>g__IsCapturedIntoInstanceStateByCompilerLogic|7_2(IReferenceExpression primaryParameterUsage, IParameter primaryParameter, ITypeConversionRule& conversionRule);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PrimaryConstructorDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPrimaryConstructorDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPrimaryConstructorDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPrimaryConstructorDeclaration GetByExtendedType(IExtendedType extendedType);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PrimaryExpressionNavigator : object {
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Tree.PrimaryParameterUsageKind : Enum {
    public int value__;
    public static PrimaryParameterUsageKind NoUsages;
    public static PrimaryParameterUsageKind ReadUsageInInitializerScope;
    public static PrimaryParameterUsageKind MutationUsageInInitializerScope;
    public static PrimaryParameterUsageKind AnyUsageInInitializerScope;
    public static PrimaryParameterUsageKind ReadUsageInCaptureScope;
    public static PrimaryParameterUsageKind MutationUsageInCaptureScope;
    public static PrimaryParameterUsageKind AnyUsageInCaptureScope;
    public static PrimaryParameterUsageKind NameUsage;
    [ObsoleteAttribute("Not reliable, won't be returned for usages outside of type part declarations")]
public static PrimaryParameterUsageKind NamedArgumentOrDocumentationUsage;
    public static PrimaryParameterUsageKind DelayedUsageInInitializerScope;
    public static PrimaryParameterUsageKind DirectInitializationOfInstanceField;
    public static PrimaryParameterUsageKind HasMultipleCapturesIntoInstanceStateByCompilersLogic;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PropertyAssignmentNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyAssignment GetByPropertyNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyAssignment GetBySource(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PropertyDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAutoOrSemiAuto(IPropertyDeclaration propertyDeclaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PropertyDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByAccessorDeclaration(IAccessorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByInitial(IVariableInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByTypeUsage(ITypeUsage param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByScalarTypeName(IReferenceName scalarTypeName);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByExpression(ICSharpExpression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PropertyInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyInitializer GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyInitializer GetByInitializer(ICreationExpressionInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyInitializer GetByNameIdentifier(ICSharpIdentifier param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PropertyPatternClauseExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetSourceType(IPropertyPatternClause propertyPatternClause);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmpty(IPropertyPatternClause propertyPatternClause);
    [ExtensionAttribute]
public static void RemoveIfEmptyAndRedundant(IPropertyPatternClause propertyPatternClause);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.PropertyPatternClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyPatternClause GetByPattern(ISubpattern param);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.IGeneratedQueryArgument {
    [NotNullAttribute]
public IPsiModule Module { get; }
    [NotNullAttribute]
public abstract virtual IList`1<IQueryAnonymousTypeProperty> GetGeneratedProperties();
    [NotNullAttribute]
public abstract virtual IQueryAnonymousType GetAnonymousType();
    [NotNullAttribute]
public abstract virtual IQueryAnonymousType GetAnonymousType(IResolveContext resolveContext);
    public abstract virtual IPsiModule get_Module();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.IQueryAnonymousTypeProperty {
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.IQueryArgumentInfo {
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<IQueryVariable> GetVariables();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.IQueryChainReference {
    [NotNullAttribute]
public abstract virtual IQueryClause GetElement();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.IQueryDeclaredElement {
    [CanBeNullAttribute]
public IQueryRangeVariableDeclaration Declaration { get; }
    public abstract virtual IQueryRangeVariableDeclaration get_Declaration();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.IQueryReference {
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.IQueryVariable {
    [NotNullAttribute]
public ICSharpTreeNode Element { get; }
    public bool IsTransparent { get; }
    public abstract virtual ICSharpTreeNode get_Element();
    public abstract virtual bool get_IsTransparent();
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.IScheme {
    [NotNullAttribute]
public abstract virtual Scheme CreateScheme(IQueryRangeVariableDeclaration declaration);
    [NotNullAttribute]
public abstract virtual IQueryVariable CreateVariable(IQueryParameterPlatform platform);
    [NotNullAttribute]
public abstract virtual IQueryVariable CreateVariable(IQueryClause element, IGeneratedQueryArgument argumentInfo);
}
public interface JetBrains.ReSharper.Psi.CSharp.Tree.Query.ITransparentVariable {
    [NotNullAttribute]
public Scheme Scheme { get; }
    public abstract virtual Scheme get_Scheme();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.Query.QueryParameterPlatformExtension : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.Query.QueryParameterPlatformExtension/<AllVisibleRangeVariables>d__0")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<IQueryRangeVariable> AllVisibleRangeVariables(IQueryParameterPlatform platform);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.Query.QueryRangeVariableDeclarationExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
internal static IQueryVariable CreateVariable(IQueryRangeVariableDeclaration declaration, IQueryParameterPlatform platform);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string Name(IQueryRangeVariableDeclaration declaration);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.Query.QueryReferenceExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IType GetReturnType(IQueryReference queryReference, IResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.CSharp.Tree.Query.Scheme : object {
    [NotNullAttribute]
[ItemCanBeNullAttribute]
private List`1<IQueryRangeVariableDeclaration> myList;
    private int myIndex;
    [NotNullAttribute]
private string Name { get; }
    public bool HasNext { get; }
    internal Scheme(List`1<IQueryRangeVariableDeclaration> list, int index);
    public sealed virtual Scheme CreateScheme(IQueryRangeVariableDeclaration declaration);
    public sealed virtual IQueryVariable CreateVariable(IQueryParameterPlatform platform);
    public sealed virtual IQueryVariable CreateVariable(IQueryClause element, IGeneratedQueryArgument argumentInfo);
    private string get_Name();
    public bool get_HasNext();
    [NotNullAttribute]
public Scheme GetNext();
    public bool HasName(string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.Query.Scheme/<AllVisibleRangeVariables>d__12")]
internal IEnumerable`1<IQueryRangeVariable> AllVisibleRangeVariables();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.CSharp.Tree.Query.SimpleScheme : object {
    [NotNullAttribute]
private IQueryRangeVariableDeclaration myDeclaration;
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public IQueryRangeVariableDeclaration Declaration { get; }
    public SimpleScheme(IQueryRangeVariableDeclaration declaration);
    public string get_Name();
    public IQueryRangeVariableDeclaration get_Declaration();
    public sealed virtual Scheme CreateScheme(IQueryRangeVariableDeclaration declaration);
    public sealed virtual IQueryVariable CreateVariable(IQueryParameterPlatform platform);
    public sealed virtual IQueryVariable CreateVariable(IQueryClause element, IGeneratedQueryArgument argumentInfo);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryClauseNavigator : object {
    [CanBeNullAttribute]
public static IQueryClause GetByPlatform(IQueryParameterPlatform platform);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryClausesHolderNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryClausesHolder GetByClause(IQueryClause param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryContinuationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryContinuation GetByClause(IQueryClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryContinuation GetByDeclaration(IQueryRangeVariableDeclaration param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.QueryDeclarationKind : Enum {
    public int value__;
    public static QueryDeclarationKind NOTHING;
    public static QueryDeclarationKind FIRST_FROM;
    public static QueryDeclarationKind FROM;
    public static QueryDeclarationKind JOIN;
    public static QueryDeclarationKind JOIN_INTO;
    public static QueryDeclarationKind LET;
    public static QueryDeclarationKind INTO;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryExpression GetByClause(IQueryClause param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryExpression GetByContinuation(IQueryContinuation param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryExpression GetByFrom(IQueryFirstFrom param);
    [CanBeNullAttribute]
public static IQueryExpression GetByClauseThroughInto(IQueryClause clause);
    [CanBeNullAttribute]
public static IQueryExpression GetByPlatform(IQueryParameterPlatform platform);
    [CanBeNullAttribute]
public static ICSharpExpression GetQualifierExpression(IQueryClause clause);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryFirstFromNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryFirstFrom GetByDeclaration(IQueryRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryFirstFrom GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryFirstFrom GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryFromClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryFromClause GetByDeclaration(IQueryRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryFromClause GetByExpression(IQueryParameterPlatform param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryFromClause GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryGroupClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryGroupClause GetByCriteria(IQueryParameterPlatform param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryGroupClause GetBySubject(IQueryParameterPlatform param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryJoinClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryJoinClause GetByEqualsExpression(IQueryParameterPlatform param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryJoinClause GetByInExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryJoinClause GetByIntoDeclaration(IQueryRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryJoinClause GetByJoinDeclaration(IQueryRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryJoinClause GetByOnExpression(IQueryParameterPlatform param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryJoinClause GetByTypeUsage(ITypeUsage param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.QueryKind : Enum {
    public int value__;
    public static QueryKind FROM;
    public static QueryKind FROM_SELECT;
    public static QueryKind LET;
    public static QueryKind WHERE;
    public static QueryKind JOIN;
    public static QueryKind JOIN_SELECT;
    public static QueryKind JOIN_INTO;
    public static QueryKind JOIN_INTO_SELECT;
    public static QueryKind ORDERBY;
    public static QueryKind SELECT;
    public static QueryKind SELECT_EMPTY;
    public static QueryKind GROUPBY;
    public static QueryKind GROUPBY_SHORT;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryLetClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryLetClause GetByDeclaration(IQueryRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryLetClause GetByExpression(IQueryParameterPlatform param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryOrderByClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryOrderByClause GetByOrdering(IQueryOrdering param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryOrderingNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryOrdering GetByExpression(IQueryParameterPlatform param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryParameterPlatformExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLinqExpressionTreeQuery(IQueryParameterPlatform parameterPlatform);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLinqExpressionTreeQuery(IQueryParameterPlatform parameterPlatform, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetImplicitlyConvertedTo(IQueryParameterPlatform parameterPlatform);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetImplicitlyConvertedTo(IQueryParameterPlatform parameterPlatform, IResolveContext resolveContext);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryParameterPlatformNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryParameterPlatform GetByValue(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryRangeVariableDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryRangeVariableDeclaration GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QuerySelectClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQuerySelectClause GetByExpression(IQueryParameterPlatform param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.QueryWhereClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryWhereClause GetByExpression(IQueryParameterPlatform param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RangeExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRangeExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRangeExpression GetByRightOperand(ICSharpExpression param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.RangeKind : Enum {
    public int value__;
    public static RangeKind FromStart;
    public static RangeKind ToEnd;
    public static RangeKind FromStartToEnd;
    public static RangeKind Full;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RankSpecifierNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RecordDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByDestructorDeclaration(IDestructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByExtendsList(IExtendsList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByFieldDeclaration(IFieldDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByIndexerDeclaration(IIndexerDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByInheritedTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByNestedTypeDeclaration(ICSharpTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByOperatorDeclaration(IOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByTypeParameterConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecordDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.RecordDeclarationTypeKind : Enum {
    public int value__;
    public static RecordDeclarationTypeKind ImplicitClass;
    public static RecordDeclarationTypeKind ExplicitClass;
    public static RecordDeclarationTypeKind ExplicitStruct;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RecursivePatternExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool OnlyChecksForNullInSyntax(IRecursivePattern recursivePattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool OnlyChecksForNull(IRecursivePattern recursivePattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasNoActualChecks(IRecursivePattern recursivePattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasSubpatterns(IRecursivePattern recursivePattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanResolveDeconstructionIntoITuple(IRecursivePattern recursivePattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanRemovePropertyPatternClause(IRecursivePattern recursivePattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPattern RemovePropertyPatternClause(IRecursivePattern recursivePattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPattern RemoveDeconstructionPatternClause(IRecursivePattern recursivePattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPropertyPatternClause EnsureHasPropertyPatternClause(IRecursivePattern recursivePattern);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RecursivePatternNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecursivePattern GetByDeconstructionPattern(ISubpattern param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecursivePattern GetByDeconstructionPatternClause(IDeconstructionPatternClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecursivePattern GetByDesignation(IVariableDesignation param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecursivePattern GetByPropertyPattern(ISubpattern param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecursivePattern GetByPropertyPatternClause(IPropertyPatternClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRecursivePattern GetByTypeUsage(ITypeUsage param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IRecursivePattern GetBySubpattern(IPattern pattern);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanReferenceInstanceMemberOfContainingType(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanReferenceInstanceMemberOfContainingTypeOrBaseMembers(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExtensionMethodInvocation(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnderImplicitNameCapture(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
public static void MakeImplicitNameCaptureExplicit(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IType QualifierType(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ICSharpExpression GetExtensionQualifier(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IType GetExtensionQualifierType(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IType GetExtensionQualifierType(IReferenceExpression referenceExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static string QualifyingExternAliasName(IReferenceExpressionReference reference);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static string QualifyingExternAliasName(IReferenceExpressionReference reference, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNameofOperatorTopArgument(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNameofOperatorTopArgument(IReferenceExpression referenceExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTypeUsageOfTypePattern(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDiscardReferenceExpression(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDiscardReferenceExpression(IReferenceExpression referenceExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPropertyFieldKeywordReferenceExpression(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPropertyFieldKeywordReferenceExpression(IReferenceExpression referenceExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCodeCompletionUnfinishedReferenceExpression(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
internal static bool IsReferenceExpressionCanBeDiscard(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
internal static bool IsReferenceExpressionCanBePropertyFieldKeyword(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
internal static bool IsReferenceExpressionCanBeDynamicTypeUsage(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSimpleNameReference(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> true, tokenText: notnull; => false, tokenText: null")]
public static bool IsSimpleNameReference(IReferenceExpression referenceExpression, String& tokenText);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSimpleNameReference(IReferenceExpression referenceExpression, string expectedTokenText);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSimpleQualifiedNameReference(IReferenceExpression referenceExpression, bool allowThis);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsReferenceNameLike(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool CheckCanUseDiscardReferenceExpression(ICSharpTreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool CheckCanUseBackingFieldReferenceExpression(ICSharpTreeNode context);
    [ExtensionAttribute]
public static void SetName(IReferenceExpression referenceExpression, string name);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSubpatternMemberAccessPart(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSubpatternMostContainingMemberAccess(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnfinishedSubpatternMemberAccessPart(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPureReferenceToStableValue(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IType TryGetSubpatternQualifierType(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNativeNumericTypeReference(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsReferenceToCapturedPrimaryParameter(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFluentMethodInvocation(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFieldLikeEventFromCurrentType(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVariableValueThatIsSafeToEvaluateMultipleTimes(IReferenceExpression referenceExpression);
    [CompilerGeneratedAttribute]
internal static bool <CheckCanUseBackingFieldReferenceExpression>g__CheckCanResolveToFieldKeyword|28_0(IReferenceExpression referenceExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceExpression GetByConditionalAccessSign(IConditionalAccessSign param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceExpression GetByNameIdentifier(ICSharpIdentifier param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceExpression GetByTypeArgumentList(ITypeArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceExpression GetByQualifierExpression(ICSharpExpression expression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IReferenceExpression GetTopByQualifierExpression(IReferenceExpression referenceExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceNameNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceName GetByNameIdentifier(ICSharpIdentifier param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceName GetByTypeArgumentList(ITypeArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceName GetByQualifier(IReferenceName referenceName);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IReferenceName GetTopByQualifier(IReferenceName referenceName);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceNameReferenceExtension : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static string GetExternAliasName(IReferenceNameReference reference);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSimpleNameReference(IReferenceName referenceName);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSimpleNameReference(IReferenceName referenceName, string expectedText);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNativeNumericTypeReference(IReferenceName referenceName);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReferenceTypeConstraintNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceTypeConstraint GetByNullableMark(INullableTypeMark param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RefExpressionExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpExpression UnwrapFromRefExpressionIfAny(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RefExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRefExpression GetByExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReftypeExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReftypeExpression GetByExpression(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RefvalueExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRefvalueExpression GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRefvalueExpression GetByTargetType(ITypeUsage param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RegularParameterDeclarationExtensions : object {
    [ExtensionAttribute]
public static void SetThis(ICSharpRegularParameterDeclaration declaration, bool addThis);
    [ExtensionAttribute]
public static void SetParamArray(ICSharpRegularParameterDeclaration declaration, bool addParamArray);
    [ExtensionAttribute]
public static void SetScopedKeyword(ICSharpRegularParameterDeclaration declaration, bool addScopedKeyword);
    [ExtensionAttribute]
public static void SetKind(ICSharpRegularParameterDeclaration declaration, ParameterKind kind);
    [ExtensionAttribute]
public static ICSharpParameterDeclaration SetScope(ICSharpRegularParameterDeclaration cSharpRegularParameterDeclaration, ScopedKind scope, Nullable`1<bool> requiredUnscopedRefAttribute, IResolveContext resolveContext);
    [ExtensionAttribute]
public static DefaultValue GetDefaultValue(ICSharpRegularParameterDeclaration regularParameterDeclaration, ICSharpExpression& defaultValueExpression);
    [ExtensionAttribute]
public static DocumentRange GetParameterKindDocumentRange(ICSharpRegularParameterDeclaration regularParameterDeclaration);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static ValueTuple`2<TokenNodeType, TokenNodeType> <SetKind>g__ParameterKind2ModeTokens|3_0(ParameterKind parameterKind);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RelationalExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRelationalExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRelationalExpression GetByRightOperand(ICSharpExpression param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.RelationalPatternKind : Enum {
    public int value__;
    public static RelationalPatternKind Unknown;
    public static RelationalPatternKind GreaterThan;
    public static RelationalPatternKind LessThan;
    public static RelationalPatternKind GreaterThanOrEqual;
    public static RelationalPatternKind LessThanOrEqual;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.RelationalPatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRelationalPattern GetByOperand(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ResourceAcquisitionExpressionsListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IResourceAcquisitionExpressionsList GetByExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReturnStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReturnStatement GetByValue(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReturnValueHolderExtensions : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => null; expression: notnull => notnull")]
public static ICSharpExpression SetValue(IReturnValueHolder returnValueHolder, ICSharpExpression expression);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReturnStatement EnsureReturnStatement(IReturnValueHolder returnHolder);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFinished(IReturnValueHolder returnValueHolder);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ReturnValueHolderNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReturnValueHolder GetByValue(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ScalarTypeUsageNavigator : object {
}
internal static class JetBrains.ReSharper.Psi.CSharp.Tree.SharedParameterModifiersListUtil`1 : object {
    public static ScopedKind GetDeclarationScope(TParameterModifiersList modifiersList);
    [CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindFirstModifier(TParameterModifiersList modifiersList, TokenNodeType tokenType);
    [CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindFirstParameterModeModifier(TParameterModifiersList modifiersList);
    [CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindLastModifier(TParameterModifiersList modifiersList, TokenNodeType tokenType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ShiftExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IShiftExpression GetByLeftOperand(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IShiftExpression GetByRightOperand(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SignOperatorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByArrowClause(IArrowExpressionClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByInterfaceQualification(IOwnerQualification param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByInterfaceQualificationReference(IReferenceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByParameterDeclaration(ICSharpParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByParams(IFormalParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SingleVariableDesignationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISingleVariableDesignation GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SlicePatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISlicePattern GetByPattern(IPattern param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SpecificCatchClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISpecificCatchClause GetByBody(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISpecificCatchClause GetByExceptionDeclaration(ICatchVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISpecificCatchClause GetByExceptionTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISpecificCatchClause GetByFilter(IExceptionFilterClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISpecificCatchClause GetByFilterCondition(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SpreadElementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISpreadElement GetByCollection(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.StackAllocExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStackAllocExpression GetByArrayInitializer(IArrayInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStackAllocExpression GetByDimExpr(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStackAllocExpression GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.StartRegionNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.StatementsOwnerExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetTheMostLeftNodeBeforeStatements(IStatementsOwner statementsOwner);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetTheMostRightNodeAfterStatements(IStatementsOwner statementsOwner);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpStatementsRange GetStatementsRange(IStatementsOwner statementsOwner, TreeTextRange treeTextRange);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpStatementsRange GetStatementsRange(IStatementsOwner statementsOwner, ICSharpStatement first, ICSharpStatement last);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpStatementsRange GetAllStatementsRangeExcludingTailLocalFunctions(IStatementsOwner statementsOwner);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpStatementsRange GetTailLocalFunctionsRange(IStatementsOwner statementsOwner, bool ignorePreprocessor);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.StatementsOwnerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStatementsOwner GetByStatement(ICSharpStatement param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.StringLiteralOwnerExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<ITokenNode, ITokenNode> GetBorderTokens(IStringLiteralOwner stringLiteralOwner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.StructDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByFieldDeclaration(IFieldDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByImplementedInterfaceUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByImplementedInterfacesList(IExtendsList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByIndexerDeclaration(IIndexerDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByNestedTypeDeclaration(ICSharpTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByOperatorDeclaration(IOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByTypeParameter(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByTypeParameterConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByTypeParameterConstraintsClause(ITypeParameterConstraintsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SubpatternExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool HasWellFormedAccessExpression(ISubpattern subpattern);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISubpattern UnwrapFromSandbox(ISubpattern subpattern);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasSimpleMemberAccess(ISubpattern subpattern);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IReference TryGetSimpleMemberReference(ISubpattern subpattern);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IReferenceExpression TryGetTopLevelMemberAccess(ISubpattern subpattern);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IReference TryGetTopLevelMemberReference(ISubpattern subpattern);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IReference TryGetMostInnerMemberReference(ISubpattern subpattern);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static string TryGetSimpleMemberAccessName(ISubpattern subpattern);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("=> null, memberReference: null; => notnull, memberReference: notnull")]
[PureAttribute]
public static string TryGetSimpleMemberAccessName(ISubpattern subpattern, IReference& memberReference);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetExpectedPositionalName(ISubpattern subpattern);
    [ExtensionAttribute]
public static void RemoveCheckForPatternAndOptimizeWhatsLeft(ISubpattern subpattern);
}
public class JetBrains.ReSharper.Psi.CSharp.Tree.SubpatternListNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static ISubpatternList GetBySubpattern(ISubpattern subpattern);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SubpatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISubpattern GetByAccessExpression(ICSharpExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISubpattern GetByPattern(IPattern param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static ISubpattern GetByMostInnerMemberAccessExpression(IReferenceExpression referenceExpression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static ISubpattern GetByAnyPartOfMemberAccessExpression(IReferenceExpression referenceExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SuppressNullableWarningExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISuppressNullableWarningExpression GetByOperand(IPrimaryExpression param);
    [PureAttribute]
[CanBeNullAttribute]
public static ISuppressNullableWarningExpression GetByOperand(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchBlockNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchBlock GetBySection(ISwitchSection param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchCaseLabelExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static PatternMatchKind GetMatchKind(ISwitchCaseLabel switchCaseLabel, IType governingType, IResolveContext resolveContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchCaseLabelNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchCaseLabel GetByGuard(IPatternGuardClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchCaseLabel GetByPattern(IPattern param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchCaseLabel GetByValueExpression(ICSharpExpression param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchCaseLabel GetByGuardCondition(ICSharpExpression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchExpressionArmNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchExpressionArm GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchExpressionArm GetByGuard(IPatternGuardClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchExpressionArm GetByPattern(IPattern param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTargetTyped(ISwitchExpression switchExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTargetTyped(ISwitchExpression switchExpression, IResolveContext resolveContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchExpression GetByArm(ISwitchExpressionArm param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchExpression GetByGoverningExpression(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchSectionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchSection GetByCaseLabel(ISwitchCaseLabel param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchSection GetByStatement(ICSharpStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchSection GetByBreakStatement(IBreakStatement breakStatement);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchSection GetBySingleCaseLabel(ISwitchCaseLabel caseLabel);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchStatementExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsGotoCase(ISwitchStatement switchStatement);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.SwitchStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchStatement GetByBlock(ISwitchBlock param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchStatement GetBySection(ISwitchSection param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchStatement GetBySwitchCaseLabel(ISwitchCaseLabel switchCaseLabel);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchStatement GetByGoverningExpression(ICSharpExpression cSharpExpression);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchStatement GetByGotoCaseStatement(IGotoCaseStatement gotoCaseStatement);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISwitchStatement GetByInnerStatement(ICSharpStatement statement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TargetTypedExpressionsContainerUtil : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.TargetTypedExpressionsContainerUtil/<GetNonConvertibleSubExpressionsRecursively>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<ICSharpExpression, Conversion>> GetNonConvertibleSubExpressionsRecursively(ICSharpExpression expression, IType targetType, Conversion expressionConversion, ICSharpTypeConversionRule conversionRule);
    public static ICSharpExpression GetContainingTargetTypedExpressionIfAny(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ThisExpressionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ThrowExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IThrowExpression GetByException(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ThrowStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IThrowStatement GetByException(ICSharpExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TopLevelCodeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnfinished(ITopLevelCode topLevelCode);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TopLevelCodeNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITopLevelCode GetByStatement(ICSharpStatement param);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Tree.TreeNodeVisitor : object {
    public virtual void VisitNode(ITreeNode node);
    public virtual void VisitAccessorDeclaration(IAccessorDeclaration accessorDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements accessorOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitAccessorOwnerDeclaration(IAccessorOwnerDeclaration accessorOwnerDeclarationParam);
    public virtual void VisitAdditiveExpression(IAdditiveExpression additiveExpressionParam);
    public virtual void VisitAllowsRefStructConstraint(IAllowsRefStructConstraint allowsRefStructConstraintParam);
    public virtual void VisitAndPattern(IAndPattern andPatternParam);
    public virtual void VisitAnonymousMemberDeclaration(IAnonymousMemberDeclaration anonymousMemberDeclarationParam);
    public virtual void VisitAnonymousMethodExpression(IAnonymousMethodExpression anonymousMethodExpressionParam);
    public virtual void VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreationExpressionParam);
    public virtual void VisitAnonymousObjectInitializer(IAnonymousObjectInitializer anonymousObjectInitializerParam);
    public virtual void VisitArglistExpression(IArglistExpression arglistExpressionParam);
    public virtual void VisitArgumentList(IArgumentList argumentListParam);
    public virtual void VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpressionParam);
    public virtual void VisitArrayInitializer(IArrayInitializer arrayInitializerParam);
    public virtual void VisitArrayTypeUsage(IArrayTypeUsage arrayTypeUsageParam);
    public virtual void VisitArrowExpressionClause(IArrowExpressionClause arrowExpressionClauseParam);
    public virtual void VisitAsExpression(IAsExpression asExpressionParam);
    public virtual void VisitAssignmentExpression(IAssignmentExpression assignmentExpressionParam);
    public virtual void VisitAttribute(IAttribute attributeParam);
    public virtual void VisitAttributeList(IAttributeList attributeListParam);
    public virtual void VisitAttributeSection(IAttributeSection attributeSectionParam);
    public virtual void VisitAttributeSectionList(IAttributeSectionList attributeSectionListParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributesOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitAttributesOwnerDeclaration(IAttributesOwnerDeclaration attributesOwnerDeclarationParam);
    public virtual void VisitAwaitExpression(IAwaitExpression awaitExpressionParam);
    public virtual void VisitBaseExpression(IBaseExpression baseExpressionParam);
    public virtual void VisitBinaryExpression(IBinaryExpression binaryExpressionParam);
    public virtual void VisitBinaryPattern(IBinaryPattern binaryPatternParam);
    public virtual void VisitBitwiseAndExpression(IBitwiseAndExpression bitwiseAndExpressionParam);
    public virtual void VisitBitwiseExclusiveOrExpression(IBitwiseExclusiveOrExpression bitwiseExclusiveOrExpressionParam);
    public virtual void VisitBitwiseInclusiveOrExpression(IBitwiseInclusiveOrExpression bitwiseInclusiveOrExpressionParam);
    public virtual void VisitBlock(IBlock blockParam);
    public virtual void VisitBreakStatement(IBreakStatement breakStatementParam);
    public virtual void VisitCSharpArgument(ICSharpArgument cSharpArgumentParam);
    [ObsoleteAttribute("There are Nodes in PSI [collectionElementInitializer, elementAccessExpression, indexerInitializer, invocationExpression, objectCreationExpression] that directly implements cSharpArgumentsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpArgumentsOwner(ICSharpArgumentsOwner cSharpArgumentsOwnerParam);
    [ObsoleteAttribute("There are Nodes in PSI [cSharpNamespaceDeclaration] that directly implements cSharpDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpDeclaration(ICSharpDeclaration cSharpDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [assignmentExpression, queryExpression] that directly implements cSharpExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpExpression(ICSharpExpression cSharpExpressionParam);
    public virtual void VisitCSharpFile(ICSharpFile cSharpFileParam);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration, destructorDeclaration, methodDeclaration] that directly implements cSharpFunctionDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpFunctionDeclaration(ICSharpFunctionDeclaration cSharpFunctionDeclarationParam);
    public virtual void VisitCSharpLiteralExpression(ICSharpLiteralExpression cSharpLiteralExpressionParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements cSharpModifiersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitCSharpModifiersOwnerDeclaration(ICSharpModifiersOwnerDeclaration cSharpModifiersOwnerDeclarationParam);
    public virtual void VisitCSharpNamespaceDeclaration(ICSharpNamespaceDeclaration cSharpNamespaceDeclarationParam);
    public virtual void VisitCSharpParameterDeclaration(ICSharpParameterDeclaration cSharpParameterDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration, delegateDeclaration, destructorDeclaration, indexerDeclaration, localFunctionDeclaration, methodDeclaration] that directly implements cSharpParametersOwnerDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpParametersOwnerDeclaration(ICSharpParametersOwnerDeclaration cSharpParametersOwnerDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration] that directly implements cSharpRegularParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpRegularParameterDeclaration(ICSharpRegularParameterDeclaration cSharpRegularParameterDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [block] that directly implements cSharpStatement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpStatement(ICSharpStatement cSharpStatementParam);
    [ObsoleteAttribute("There are Nodes in PSI [cSharpNamespaceDeclaration] that directly implements cSharpTypeAndNamespaceHolderDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpTypeAndNamespaceHolderDeclaration(ICSharpTypeAndNamespaceHolderDeclaration cSharpTypeAndNamespaceHolderDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements cSharpTypeDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitCSharpTypeDeclaration(ICSharpTypeDeclaration cSharpTypeDeclarationParam);
    public virtual void VisitCSharpTypeMemberDeclaration(ICSharpTypeMemberDeclaration cSharpTypeMemberDeclarationParam);
    public virtual void VisitCastExpression(ICastExpression castExpressionParam);
    public virtual void VisitCatchClause(ICatchClause catchClauseParam);
    public virtual void VisitCatchVariableDeclaration(ICatchVariableDeclaration catchVariableDeclarationParam);
    public virtual void VisitCheckedExpression(ICheckedExpression checkedExpressionParam);
    public virtual void VisitCheckedStatement(ICheckedStatement checkedStatementParam);
    public virtual void VisitClassBody(IClassBody classBodyParam);
    public virtual void VisitClassDeclaration(IClassDeclaration classDeclarationParam);
    public virtual void VisitClassLikeDeclaration(IClassLikeDeclaration classLikeDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements classMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitClassMemberDeclaration(IClassMemberDeclaration classMemberDeclarationParam);
    public virtual void VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam);
    public virtual void VisitCollectionExpression(ICollectionExpression collectionExpressionParam);
    public virtual void VisitCollectionExpressionElement(ICollectionExpressionElement collectionExpressionElementParam);
    public virtual void VisitCollectionInitializer(ICollectionInitializer collectionInitializerParam);
    public virtual void VisitConditionalAccessSign(IConditionalAccessSign conditionalAccessSignParam);
    public virtual void VisitConditionalAndExpression(IConditionalAndExpression conditionalAndExpressionParam);
    public virtual void VisitConditionalOrExpression(IConditionalOrExpression conditionalOrExpressionParam);
    public virtual void VisitConditionalTernaryExpression(IConditionalTernaryExpression conditionalTernaryExpressionParam);
    public virtual void VisitConstantDeclaration(IConstantDeclaration constantDeclarationParam);
    public virtual void VisitConstantOrTypePattern(IConstantOrTypePattern constantOrTypePatternParam);
    public virtual void VisitConstructorConstraint(IConstructorConstraint constructorConstraintParam);
    public virtual void VisitConstructorDeclaration(IConstructorDeclaration constructorDeclarationParam);
    public virtual void VisitConstructorInitializer(IConstructorInitializer constructorInitializerParam);
    public virtual void VisitContinueStatement(IContinueStatement continueStatementParam);
    public virtual void VisitConversionOperatorDeclaration(IConversionOperatorDeclaration conversionOperatorDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [objectCreationExpression] that directly implements creationExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCreationExpression(ICreationExpression creationExpressionParam);
    [ObsoleteAttribute("There are Nodes in PSI [arrayInitializer] that directly implements creationExpressionInitializer and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCreationExpressionInitializer(ICreationExpressionInitializer creationExpressionInitializerParam);
    public virtual void VisitDeclarationExpression(IDeclarationExpression declarationExpressionParam);
    public virtual void VisitDeclarationStatement(IDeclarationStatement declarationStatementParam);
    public virtual void VisitDeconstructionPatternClause(IDeconstructionPatternClause deconstructionPatternClauseParam);
    public virtual void VisitDefaultConstraint(IDefaultConstraint defaultConstraintParam);
    public virtual void VisitDefaultExpression(IDefaultExpression defaultExpressionParam);
    public virtual void VisitDefineDirective(IDefineDirective defineDirectiveParam);
    public virtual void VisitDelegateDeclaration(IDelegateDeclaration delegateDeclarationParam);
    public virtual void VisitDestructorDeclaration(IDestructorDeclaration destructorDeclarationParam);
    public virtual void VisitDiscardDesignation(IDiscardDesignation discardDesignationParam);
    public virtual void VisitDiscardPattern(IDiscardPattern discardPatternParam);
    public virtual void VisitDoStatement(IDoStatement doStatementParam);
    public virtual void VisitDocCRefElement(IDocCRefElement docCRefElementParam);
    public virtual void VisitDocCRefExpression(IDocCRefExpression docCRefExpressionParam);
    public virtual void VisitDocCRefParameter(IDocCRefParameter docCRefParameterParam);
    public virtual void VisitDocCRefParameterType(IDocCRefParameterType docCRefParameterTypeParam);
    public virtual void VisitDocCRefParameterTypeName(IDocCRefParameterTypeName docCRefParameterTypeNameParam);
    public virtual void VisitDocCRefSignature(IDocCRefSignature docCRefSignatureParam);
    public virtual void VisitDocCRefTypeParameter(IDocCRefTypeParameter docCRefTypeParameterParam);
    public virtual void VisitDocCRefTypeParameterList(IDocCRefTypeParameterList docCRefTypeParameterListParam);
    public virtual void VisitElementAccessExpression(IElementAccessExpression elementAccessExpressionParam);
    public virtual void VisitElifDirective(IElifDirective elifDirectiveParam);
    public virtual void VisitElseDirective(IElseDirective elseDirectiveParam);
    public virtual void VisitEmptyStatement(IEmptyStatement emptyStatementParam);
    public virtual void VisitEndRegion(IEndRegion endRegionParam);
    public virtual void VisitEndifDirective(IEndifDirective endifDirectiveParam);
    public virtual void VisitEnumBase(IEnumBase enumBaseParam);
    public virtual void VisitEnumBody(IEnumBody enumBodyParam);
    public virtual void VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam);
    public virtual void VisitEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclarationParam);
    public virtual void VisitEqualityExpression(IEqualityExpression equalityExpressionParam);
    public virtual void VisitErrorDirective(IErrorDirective errorDirectiveParam);
    public virtual void VisitEventDeclaration(IEventDeclaration eventDeclarationParam);
    public virtual void VisitExceptionFilterClause(IExceptionFilterClause exceptionFilterClauseParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements expressionBodyOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitExpressionBodyOwnerDeclaration(IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclarationParam);
    public virtual void VisitExpressionElement(IExpressionElement expressionElementParam);
    public virtual void VisitExpressionInitializer(IExpressionInitializer expressionInitializerParam);
    public virtual void VisitExpressionStatement(IExpressionStatement expressionStatementParam);
    public virtual void VisitExtendedType(IExtendedType extendedTypeParam);
    public virtual void VisitExtendsList(IExtendsList extendsListParam);
    public virtual void VisitExternAliasDirective(IExternAliasDirective externAliasDirectiveParam);
    public virtual void VisitFieldDeclaration(IFieldDeclaration fieldDeclarationParam);
    public virtual void VisitForInitializer(IForInitializer forInitializerParam);
    public virtual void VisitForIterator(IForIterator forIteratorParam);
    public virtual void VisitForStatement(IForStatement forStatementParam);
    public virtual void VisitForeachHeader(IForeachHeader foreachHeaderParam);
    public virtual void VisitForeachStatement(IForeachStatement foreachStatementParam);
    public virtual void VisitFormalParameterList(IFormalParameterList formalParameterListParam);
    public virtual void VisitFunctionPointerCallingConvention(IFunctionPointerCallingConvention functionPointerCallingConventionParam);
    public virtual void VisitFunctionPointerParameter(IFunctionPointerParameter functionPointerParameterParam);
    public virtual void VisitFunctionPointerParameterModifiers(IFunctionPointerParameterModifiers functionPointerParameterModifiersParam);
    public virtual void VisitFunctionPointerTypeUsage(IFunctionPointerTypeUsage functionPointerTypeUsageParam);
    public virtual void VisitGeneralCatchClause(IGeneralCatchClause generalCatchClauseParam);
    public virtual void VisitGotoCaseStatement(IGotoCaseStatement gotoCaseStatementParam);
    public virtual void VisitGotoStatement(IGotoStatement gotoStatementParam);
    public virtual void VisitIfDirective(IIfDirective ifDirectiveParam);
    public virtual void VisitIfStatement(IIfStatement ifStatementParam);
    public virtual void VisitIndexFromEndExpression(IIndexFromEndExpression indexFromEndExpressionParam);
    public virtual void VisitIndexerDeclaration(IIndexerDeclaration indexerDeclarationParam);
    public virtual void VisitIndexerInitializer(IIndexerInitializer indexerInitializerParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements initializedMemberInitializer interface, so this visitor member will not be invoked")]
public virtual void VisitInitializedMemberInitializer(IInitializedMemberInitializer initializedMemberInitializerParam);
    [ObsoleteAttribute("There are Nodes in PSI [collectionElementInitializer] that directly implements initializerElement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitInitializerElement(IInitializerElement initializerElementParam);
    public virtual void VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements interfaceQualificationOwner interface, so this visitor member will not be invoked")]
public virtual void VisitInterfaceQualificationOwner(IInterfaceQualificationOwner interfaceQualificationOwnerParam);
    public virtual void VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam);
    public virtual void VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam);
    public virtual void VisitInvalidDirective(IInvalidDirective invalidDirectiveParam);
    public virtual void VisitInvocationExpression(IInvocationExpression invocationExpressionParam);
    public virtual void VisitIsExpression(IIsExpression isExpressionParam);
    public virtual void VisitKeyword(IKeyword keywordParam);
    public virtual void VisitLabelDeclaration(ILabelDeclaration labelDeclarationParam);
    public virtual void VisitLabelReferenceElement(ILabelReferenceElement labelReferenceElementParam);
    public virtual void VisitLabelStatement(ILabelStatement labelStatementParam);
    public virtual void VisitLambdaExpression(ILambdaExpression lambdaExpressionParam);
    public virtual void VisitLambdaSignature(ILambdaSignature lambdaSignatureParam);
    public virtual void VisitLineDirective(ILineDirective lineDirectiveParam);
    public virtual void VisitLineIndicator(ILineIndicator lineIndicatorParam);
    public virtual void VisitListPattern(IListPattern listPatternParam);
    public virtual void VisitLocalArglistParameterDeclaration(ILocalArglistParameterDeclaration localArglistParameterDeclarationParam);
    public virtual void VisitLocalConstantDeclaration(ILocalConstantDeclaration localConstantDeclarationParam);
    public virtual void VisitLocalFormalParameterList(ILocalFormalParameterList localFormalParameterListParam);
    public virtual void VisitLocalFunctionDeclaration(ILocalFunctionDeclaration localFunctionDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration] that directly implements localParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitLocalParameterDeclaration(ILocalParameterDeclaration localParameterDeclarationParam);
    public virtual void VisitLocalRegularParameterDeclaration(ILocalRegularParameterDeclaration localRegularParameterDeclarationParam);
    public virtual void VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam);
    public virtual void VisitLockStatement(ILockStatement lockStatementParam);
    public virtual void VisitMakerefExpression(IMakerefExpression makerefExpressionParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements memberInitializer interface, so this visitor member will not be invoked")]
public virtual void VisitMemberInitializer(IMemberInitializer memberInitializerParam);
    public virtual void VisitMemberOwnerBody(IMemberOwnerBody memberOwnerBodyParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements memberOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitMemberOwnerDeclaration(IMemberOwnerDeclaration memberOwnerDeclarationParam);
    public virtual void VisitMethodDeclaration(IMethodDeclaration methodDeclarationParam);
    public virtual void VisitMissingDesignation(IMissingDesignation missingDesignationParam);
    public virtual void VisitModifiersList(IModifiersList modifiersListParam);
    public virtual void VisitMultipleConstantDeclaration(IMultipleConstantDeclaration multipleConstantDeclarationParam);
    public virtual void VisitMultipleDeclaration(IMultipleDeclaration multipleDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [constantDeclaration, eventDeclaration, fieldDeclaration] that directly implements multipleDeclarationMember and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitMultipleDeclarationMember(IMultipleDeclarationMember multipleDeclarationMemberParam);
    public virtual void VisitMultipleEventDeclaration(IMultipleEventDeclaration multipleEventDeclarationParam);
    public virtual void VisitMultipleFieldDeclaration(IMultipleFieldDeclaration multipleFieldDeclarationParam);
    public virtual void VisitMultipleLocalConstantDeclaration(IMultipleLocalConstantDeclaration multipleLocalConstantDeclarationParam);
    public virtual void VisitMultipleLocalVariableDeclaration(IMultipleLocalVariableDeclaration multipleLocalVariableDeclarationParam);
    public virtual void VisitMultiplicativeExpression(IMultiplicativeExpression multiplicativeExpressionParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements namedMemberInitializer interface, so this visitor member will not be invoked")]
public virtual void VisitNamedMemberInitializer(INamedMemberInitializer namedMemberInitializerParam);
    public virtual void VisitNamespaceBody(INamespaceBody namespaceBodyParam);
    public virtual void VisitNegatedPattern(INegatedPattern negatedPatternParam);
    public virtual void VisitNullCoalescingExpression(INullCoalescingExpression nullCoalescingExpressionParam);
    public virtual void VisitNullableDirective(INullableDirective nullableDirectiveParam);
    public virtual void VisitNullableTypeMark(INullableTypeMark nullableTypeMarkParam);
    public virtual void VisitNullableTypeUsage(INullableTypeUsage nullableTypeUsageParam);
    public virtual void VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam);
    public virtual void VisitObjectInitializer(IObjectInitializer objectInitializerParam);
    public virtual void VisitOperatorDeclaration(IOperatorDeclaration operatorDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements operatorExpression interface, so this visitor member will not be invoked")]
public virtual void VisitOperatorExpression(IOperatorExpression operatorExpressionParam);
    public virtual void VisitOrPattern(IOrPattern orPatternParam);
    public virtual void VisitOverflowCheckingStatement(IOverflowCheckingStatement overflowCheckingStatementParam);
    public virtual void VisitOwnerQualification(IOwnerQualification ownerQualificationParam);
    public virtual void VisitParameterModifiersList(IParameterModifiersList parameterModifiersListParam);
    public virtual void VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam);
    public virtual void VisitParenthesizedPattern(IParenthesizedPattern parenthesizedPatternParam);
    public virtual void VisitParenthesizedVariableDesignation(IParenthesizedVariableDesignation parenthesizedVariableDesignationParam);
    public virtual void VisitPattern(IPattern patternParam);
    public virtual void VisitPatternGuardClause(IPatternGuardClause patternGuardClauseParam);
    public virtual void VisitPointerTypeUsage(IPointerTypeUsage pointerTypeUsageParam);
    public virtual void VisitPostfixOperatorExpression(IPostfixOperatorExpression postfixOperatorExpressionParam);
    public virtual void VisitPragmaDirective(IPragmaDirective pragmaDirectiveParam);
    public virtual void VisitPredefinedTypeExpression(IPredefinedTypeExpression predefinedTypeExpressionParam);
    public virtual void VisitPredefinedTypeReference(IPredefinedTypeReference predefinedTypeReferenceParam);
    public virtual void VisitPredefinedTypeUsage(IPredefinedTypeUsage predefinedTypeUsageParam);
    public virtual void VisitPrefixOperatorExpression(IPrefixOperatorExpression prefixOperatorExpressionParam);
    public virtual void VisitPreprocessor(IPreprocessor preprocessorParam);
    public virtual void VisitPreprocessorAndExpression(IPreprocessorAndExpression preprocessorAndExpressionParam);
    public virtual void VisitPreprocessorConditionalSymbol(IPreprocessorConditionalSymbol preprocessorConditionalSymbolParam);
    public virtual void VisitPreprocessorDirective(IPreprocessorDirective preprocessorDirectiveParam);
    public virtual void VisitPreprocessorEqualityExpression(IPreprocessorEqualityExpression preprocessorEqualityExpressionParam);
    public virtual void VisitPreprocessorExpression(IPreprocessorExpression preprocessorExpressionParam);
    public virtual void VisitPreprocessorNegation(IPreprocessorNegation preprocessorNegationParam);
    public virtual void VisitPreprocessorOrExpression(IPreprocessorOrExpression preprocessorOrExpressionParam);
    public virtual void VisitPreprocessorParenthesizedExpression(IPreprocessorParenthesizedExpression preprocessorParenthesizedExpressionParam);
    public virtual void VisitPreprocessorPragmaBody(IPreprocessorPragmaBody preprocessorPragmaBodyParam);
    public virtual void VisitPreprocessorUnaryExpression(IPreprocessorUnaryExpression preprocessorUnaryExpressionParam);
    public virtual void VisitPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration primaryConstructorDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [elementAccessExpression, invocationExpression, lambdaExpression, postfixOperatorExpression] that directly implements primaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitPrimaryExpression(IPrimaryExpression primaryExpressionParam);
    public virtual void VisitPropertyAssignment(IPropertyAssignment propertyAssignmentParam);
    public virtual void VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam);
    public virtual void VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam);
    public virtual void VisitPropertyPatternClause(IPropertyPatternClause propertyPatternClauseParam);
    public virtual void VisitQueryClause(IQueryClause queryClauseParam);
    [ObsoleteAttribute("There are Nodes in PSI [queryExpression] that directly implements queryClausesHolder and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitQueryClausesHolder(IQueryClausesHolder queryClausesHolderParam);
    public virtual void VisitQueryContinuation(IQueryContinuation queryContinuationParam);
    public virtual void VisitQueryExpression(IQueryExpression queryExpressionParam);
    public virtual void VisitQueryFirstFrom(IQueryFirstFrom queryFirstFromParam);
    public virtual void VisitQueryFromClause(IQueryFromClause queryFromClauseParam);
    public virtual void VisitQueryGroupClause(IQueryGroupClause queryGroupClauseParam);
    public virtual void VisitQueryJoinClause(IQueryJoinClause queryJoinClauseParam);
    public virtual void VisitQueryLetClause(IQueryLetClause queryLetClauseParam);
    public virtual void VisitQueryOrderByClause(IQueryOrderByClause queryOrderByClauseParam);
    public virtual void VisitQueryOrdering(IQueryOrdering queryOrderingParam);
    public virtual void VisitQueryParameterPlatform(IQueryParameterPlatform queryParameterPlatformParam);
    public virtual void VisitQueryRangeVariableDeclaration(IQueryRangeVariableDeclaration queryRangeVariableDeclarationParam);
    public virtual void VisitQuerySelectClause(IQuerySelectClause querySelectClauseParam);
    public virtual void VisitQueryWhereClause(IQueryWhereClause queryWhereClauseParam);
    public virtual void VisitRangeExpression(IRangeExpression rangeExpressionParam);
    public virtual void VisitRankSpecifier(IRankSpecifier rankSpecifierParam);
    public virtual void VisitRecordDeclaration(IRecordDeclaration recordDeclarationParam);
    public virtual void VisitRecursivePattern(IRecursivePattern recursivePatternParam);
    public virtual void VisitRefExpression(IRefExpression refExpressionParam);
    public virtual void VisitReferenceExpression(IReferenceExpression referenceExpressionParam);
    public virtual void VisitReferenceName(IReferenceName referenceNameParam);
    public virtual void VisitReferenceTypeConstraint(IReferenceTypeConstraint referenceTypeConstraintParam);
    public virtual void VisitReftypeExpression(IReftypeExpression reftypeExpressionParam);
    public virtual void VisitRefvalueExpression(IRefvalueExpression refvalueExpressionParam);
    public virtual void VisitRelationalExpression(IRelationalExpression relationalExpressionParam);
    public virtual void VisitRelationalPattern(IRelationalPattern relationalPatternParam);
    public virtual void VisitResourceAcquisitionExpressionsList(IResourceAcquisitionExpressionsList resourceAcquisitionExpressionsListParam);
    public virtual void VisitReturnStatement(IReturnStatement returnStatementParam);
    public virtual void VisitScalarTypeUsage(IScalarTypeUsage scalarTypeUsageParam);
    public virtual void VisitShiftExpression(IShiftExpression shiftExpressionParam);
    public virtual void VisitSignOperatorDeclaration(ISignOperatorDeclaration signOperatorDeclarationParam);
    public virtual void VisitSingleVariableDesignation(ISingleVariableDesignation singleVariableDesignationParam);
    public virtual void VisitSlicePattern(ISlicePattern slicePatternParam);
    public virtual void VisitSpecificCatchClause(ISpecificCatchClause specificCatchClauseParam);
    public virtual void VisitSpreadElement(ISpreadElement spreadElementParam);
    public virtual void VisitStackAllocExpression(IStackAllocExpression stackAllocExpressionParam);
    public virtual void VisitStartRegion(IStartRegion startRegionParam);
    [ObsoleteAttribute("There are Nodes in PSI [block] that directly implements statementsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitStatementsOwner(IStatementsOwner statementsOwnerParam);
    public virtual void VisitStructDeclaration(IStructDeclaration structDeclarationParam);
    public virtual void VisitSubpattern(ISubpattern subpatternParam);
    public virtual void VisitSuppressNullableWarningExpression(ISuppressNullableWarningExpression suppressNullableWarningExpressionParam);
    public virtual void VisitSwitchBlock(ISwitchBlock switchBlockParam);
    public virtual void VisitSwitchCaseLabel(ISwitchCaseLabel switchCaseLabelParam);
    public virtual void VisitSwitchExpression(ISwitchExpression switchExpressionParam);
    public virtual void VisitSwitchExpressionArm(ISwitchExpressionArm switchExpressionArmParam);
    public virtual void VisitSwitchSection(ISwitchSection switchSectionParam);
    public virtual void VisitSwitchStatement(ISwitchStatement switchStatementParam);
    public virtual void VisitThisExpression(IThisExpression thisExpressionParam);
    public virtual void VisitThrowExpression(IThrowExpression throwExpressionParam);
    public virtual void VisitThrowStatement(IThrowStatement throwStatementParam);
    public virtual void VisitTopLevelCode(ITopLevelCode topLevelCodeParam);
    public virtual void VisitTryStatement(ITryStatement tryStatementParam);
    public virtual void VisitTupleComponent(ITupleComponent tupleComponentParam);
    public virtual void VisitTupleComponentList(ITupleComponentList tupleComponentListParam);
    public virtual void VisitTupleExpression(ITupleExpression tupleExpressionParam);
    public virtual void VisitTupleTypeComponent(ITupleTypeComponent tupleTypeComponentParam);
    public virtual void VisitTupleTypeComponentList(ITupleTypeComponentList tupleTypeComponentListParam);
    public virtual void VisitTupleTypeUsage(ITupleTypeUsage tupleTypeUsageParam);
    public virtual void VisitTypeArgumentList(ITypeArgumentList typeArgumentListParam);
    public virtual void VisitTypeConstraint(ITypeConstraint typeConstraintParam);
    public virtual void VisitTypeMemberArglistParameterDeclaration(ITypeMemberArglistParameterDeclaration typeMemberArglistParameterDeclarationParam);
    public virtual void VisitTypeMemberRegularParameterDeclaration(ITypeMemberRegularParameterDeclaration typeMemberRegularParameterDeclarationParam);
    public virtual void VisitTypeParameterConstraint(ITypeParameterConstraint typeParameterConstraintParam);
    public virtual void VisitTypeParameterConstraintsClause(ITypeParameterConstraintsClause typeParameterConstraintsClauseParam);
    [ObsoleteAttribute("There are Nodes in PSI [typeParameterOfMethodDeclaration, typeParameterOfTypeDeclaration] that directly implements typeParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitTypeParameterDeclaration(ITypeParameterDeclaration typeParameterDeclarationParam);
    public virtual void VisitTypeParameterOfLocalFunctionDeclaration(ITypeParameterOfLocalFunctionDeclaration typeParameterOfLocalFunctionDeclarationParam);
    public virtual void VisitTypeParameterOfLocalFunctionList(ITypeParameterOfLocalFunctionList typeParameterOfLocalFunctionListParam);
    public virtual void VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam);
    public virtual void VisitTypeParameterOfMethodList(ITypeParameterOfMethodList typeParameterOfMethodListParam);
    public virtual void VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam);
    public virtual void VisitTypeParameterOfTypeList(ITypeParameterOfTypeList typeParameterOfTypeListParam);
    public virtual void VisitTypeParameterReference(ITypeParameterReference typeParameterReferenceParam);
    public virtual void VisitTypePattern(ITypePattern typePatternParam);
    public virtual void VisitTypeUsage(ITypeUsage typeUsageParam);
    public virtual void VisitTypeofExpression(ITypeofExpression typeofExpressionParam);
    [ObsoleteAttribute("There are Nodes in PSI [prefixOperatorExpression, unaryOperatorExpression] that directly implements unaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitUnaryExpression(IUnaryExpression unaryExpressionParam);
    public virtual void VisitUnaryOperatorExpression(IUnaryOperatorExpression unaryOperatorExpressionParam);
    public virtual void VisitUncheckedExpression(IUncheckedExpression uncheckedExpressionParam);
    public virtual void VisitUncheckedStatement(IUncheckedStatement uncheckedStatementParam);
    public virtual void VisitUndefDirective(IUndefDirective undefDirectiveParam);
    public virtual void VisitUnsafeCodeAddressOfExpression(IUnsafeCodeAddressOfExpression unsafeCodeAddressOfExpressionParam);
    public virtual void VisitUnsafeCodeFixedPointerDeclaration(IUnsafeCodeFixedPointerDeclaration unsafeCodeFixedPointerDeclarationParam);
    public virtual void VisitUnsafeCodeFixedPointerInitializer(IUnsafeCodeFixedPointerInitializer unsafeCodeFixedPointerInitializerParam);
    public virtual void VisitUnsafeCodeFixedStatement(IUnsafeCodeFixedStatement unsafeCodeFixedStatementParam);
    public virtual void VisitUnsafeCodePointer(IUnsafeCodePointer unsafeCodePointerParam);
    public virtual void VisitUnsafeCodePointerAccessExpression(IUnsafeCodePointerAccessExpression unsafeCodePointerAccessExpressionParam);
    public virtual void VisitUnsafeCodePointerIndirectionExpression(IUnsafeCodePointerIndirectionExpression unsafeCodePointerIndirectionExpressionParam);
    public virtual void VisitUnsafeCodeSizeOfExpression(IUnsafeCodeSizeOfExpression unsafeCodeSizeOfExpressionParam);
    public virtual void VisitUnsafeCodeUnsafeStatement(IUnsafeCodeUnsafeStatement unsafeCodeUnsafeStatementParam);
    public virtual void VisitUserTypeUsage(IUserTypeUsage userTypeUsageParam);
    public virtual void VisitUsingAliasDirective(IUsingAliasDirective usingAliasDirectiveParam);
    public virtual void VisitUsingDirective(IUsingDirective usingDirectiveParam);
    public virtual void VisitUsingList(IUsingList usingListParam);
    public virtual void VisitUsingStatement(IUsingStatement usingStatementParam);
    public virtual void VisitUsingSymbolDirective(IUsingSymbolDirective usingSymbolDirectiveParam);
    public virtual void VisitValueTypeConstraint(IValueTypeConstraint valueTypeConstraintParam);
    public virtual void VisitVarDeconstructionPattern(IVarDeconstructionPattern varDeconstructionPatternParam);
    public virtual void VisitVarPattern(IVarPattern varPatternParam);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration, propertyDeclaration, singleVariableDesignation] that directly implements variableDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVariableDeclaration(IVariableDeclaration variableDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [singleVariableDesignation] that directly implements variableDesignation and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVariableDesignation(IVariableDesignation variableDesignationParam);
    [ObsoleteAttribute("There are Nodes in PSI [arrayInitializer] that directly implements variableInitializer and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVariableInitializer(IVariableInitializer variableInitializerParam);
    public virtual void VisitWarningAction(IWarningAction warningActionParam);
    public virtual void VisitWarningDirective(IWarningDirective warningDirectiveParam);
    public virtual void VisitWarningList(IWarningList warningListParam);
    public virtual void VisitWhileStatement(IWhileStatement whileStatementParam);
    public virtual void VisitWithExpression(IWithExpression withExpressionParam);
    public virtual void VisitWithInitializerAssignment(IWithInitializerAssignment withInitializerAssignmentParam);
    public virtual void VisitYieldStatement(IYieldStatement yieldStatementParam);
    public virtual void VisitInactivePreprocessorBranchNode(IInactivePreprocessorBranch inactivePreprocessorBranchNode);
    public virtual void VisitDocCommentBlockNode(IDocCommentBlock xmlDoc);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Tree.TreeNodeVisitor`1 : object {
    public virtual void VisitNode(ITreeNode node, TContext context);
    public virtual void VisitAccessorDeclaration(IAccessorDeclaration accessorDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements accessorOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitAccessorOwnerDeclaration(IAccessorOwnerDeclaration accessorOwnerDeclarationParam, TContext context);
    public virtual void VisitAdditiveExpression(IAdditiveExpression additiveExpressionParam, TContext context);
    public virtual void VisitAllowsRefStructConstraint(IAllowsRefStructConstraint allowsRefStructConstraintParam, TContext context);
    public virtual void VisitAndPattern(IAndPattern andPatternParam, TContext context);
    public virtual void VisitAnonymousMemberDeclaration(IAnonymousMemberDeclaration anonymousMemberDeclarationParam, TContext context);
    public virtual void VisitAnonymousMethodExpression(IAnonymousMethodExpression anonymousMethodExpressionParam, TContext context);
    public virtual void VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreationExpressionParam, TContext context);
    public virtual void VisitAnonymousObjectInitializer(IAnonymousObjectInitializer anonymousObjectInitializerParam, TContext context);
    public virtual void VisitArglistExpression(IArglistExpression arglistExpressionParam, TContext context);
    public virtual void VisitArgumentList(IArgumentList argumentListParam, TContext context);
    public virtual void VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpressionParam, TContext context);
    public virtual void VisitArrayInitializer(IArrayInitializer arrayInitializerParam, TContext context);
    public virtual void VisitArrayTypeUsage(IArrayTypeUsage arrayTypeUsageParam, TContext context);
    public virtual void VisitArrowExpressionClause(IArrowExpressionClause arrowExpressionClauseParam, TContext context);
    public virtual void VisitAsExpression(IAsExpression asExpressionParam, TContext context);
    public virtual void VisitAssignmentExpression(IAssignmentExpression assignmentExpressionParam, TContext context);
    public virtual void VisitAttribute(IAttribute attributeParam, TContext context);
    public virtual void VisitAttributeList(IAttributeList attributeListParam, TContext context);
    public virtual void VisitAttributeSection(IAttributeSection attributeSectionParam, TContext context);
    public virtual void VisitAttributeSectionList(IAttributeSectionList attributeSectionListParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributesOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitAttributesOwnerDeclaration(IAttributesOwnerDeclaration attributesOwnerDeclarationParam, TContext context);
    public virtual void VisitAwaitExpression(IAwaitExpression awaitExpressionParam, TContext context);
    public virtual void VisitBaseExpression(IBaseExpression baseExpressionParam, TContext context);
    public virtual void VisitBinaryExpression(IBinaryExpression binaryExpressionParam, TContext context);
    public virtual void VisitBinaryPattern(IBinaryPattern binaryPatternParam, TContext context);
    public virtual void VisitBitwiseAndExpression(IBitwiseAndExpression bitwiseAndExpressionParam, TContext context);
    public virtual void VisitBitwiseExclusiveOrExpression(IBitwiseExclusiveOrExpression bitwiseExclusiveOrExpressionParam, TContext context);
    public virtual void VisitBitwiseInclusiveOrExpression(IBitwiseInclusiveOrExpression bitwiseInclusiveOrExpressionParam, TContext context);
    public virtual void VisitBlock(IBlock blockParam, TContext context);
    public virtual void VisitBreakStatement(IBreakStatement breakStatementParam, TContext context);
    public virtual void VisitCSharpArgument(ICSharpArgument cSharpArgumentParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [collectionElementInitializer, elementAccessExpression, indexerInitializer, invocationExpression, objectCreationExpression] that directly implements cSharpArgumentsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpArgumentsOwner(ICSharpArgumentsOwner cSharpArgumentsOwnerParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [cSharpNamespaceDeclaration] that directly implements cSharpDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpDeclaration(ICSharpDeclaration cSharpDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [assignmentExpression, queryExpression] that directly implements cSharpExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpExpression(ICSharpExpression cSharpExpressionParam, TContext context);
    public virtual void VisitCSharpFile(ICSharpFile cSharpFileParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration, destructorDeclaration, methodDeclaration] that directly implements cSharpFunctionDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpFunctionDeclaration(ICSharpFunctionDeclaration cSharpFunctionDeclarationParam, TContext context);
    public virtual void VisitCSharpLiteralExpression(ICSharpLiteralExpression cSharpLiteralExpressionParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements cSharpModifiersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitCSharpModifiersOwnerDeclaration(ICSharpModifiersOwnerDeclaration cSharpModifiersOwnerDeclarationParam, TContext context);
    public virtual void VisitCSharpNamespaceDeclaration(ICSharpNamespaceDeclaration cSharpNamespaceDeclarationParam, TContext context);
    public virtual void VisitCSharpParameterDeclaration(ICSharpParameterDeclaration cSharpParameterDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration, delegateDeclaration, destructorDeclaration, indexerDeclaration, localFunctionDeclaration, methodDeclaration] that directly implements cSharpParametersOwnerDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpParametersOwnerDeclaration(ICSharpParametersOwnerDeclaration cSharpParametersOwnerDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration] that directly implements cSharpRegularParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpRegularParameterDeclaration(ICSharpRegularParameterDeclaration cSharpRegularParameterDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [block] that directly implements cSharpStatement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpStatement(ICSharpStatement cSharpStatementParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [cSharpNamespaceDeclaration] that directly implements cSharpTypeAndNamespaceHolderDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCSharpTypeAndNamespaceHolderDeclaration(ICSharpTypeAndNamespaceHolderDeclaration cSharpTypeAndNamespaceHolderDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements cSharpTypeDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitCSharpTypeDeclaration(ICSharpTypeDeclaration cSharpTypeDeclarationParam, TContext context);
    public virtual void VisitCSharpTypeMemberDeclaration(ICSharpTypeMemberDeclaration cSharpTypeMemberDeclarationParam, TContext context);
    public virtual void VisitCastExpression(ICastExpression castExpressionParam, TContext context);
    public virtual void VisitCatchClause(ICatchClause catchClauseParam, TContext context);
    public virtual void VisitCatchVariableDeclaration(ICatchVariableDeclaration catchVariableDeclarationParam, TContext context);
    public virtual void VisitCheckedExpression(ICheckedExpression checkedExpressionParam, TContext context);
    public virtual void VisitCheckedStatement(ICheckedStatement checkedStatementParam, TContext context);
    public virtual void VisitClassBody(IClassBody classBodyParam, TContext context);
    public virtual void VisitClassDeclaration(IClassDeclaration classDeclarationParam, TContext context);
    public virtual void VisitClassLikeDeclaration(IClassLikeDeclaration classLikeDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements classMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitClassMemberDeclaration(IClassMemberDeclaration classMemberDeclarationParam, TContext context);
    public virtual void VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam, TContext context);
    public virtual void VisitCollectionExpression(ICollectionExpression collectionExpressionParam, TContext context);
    public virtual void VisitCollectionExpressionElement(ICollectionExpressionElement collectionExpressionElementParam, TContext context);
    public virtual void VisitCollectionInitializer(ICollectionInitializer collectionInitializerParam, TContext context);
    public virtual void VisitConditionalAccessSign(IConditionalAccessSign conditionalAccessSignParam, TContext context);
    public virtual void VisitConditionalAndExpression(IConditionalAndExpression conditionalAndExpressionParam, TContext context);
    public virtual void VisitConditionalOrExpression(IConditionalOrExpression conditionalOrExpressionParam, TContext context);
    public virtual void VisitConditionalTernaryExpression(IConditionalTernaryExpression conditionalTernaryExpressionParam, TContext context);
    public virtual void VisitConstantDeclaration(IConstantDeclaration constantDeclarationParam, TContext context);
    public virtual void VisitConstantOrTypePattern(IConstantOrTypePattern constantOrTypePatternParam, TContext context);
    public virtual void VisitConstructorConstraint(IConstructorConstraint constructorConstraintParam, TContext context);
    public virtual void VisitConstructorDeclaration(IConstructorDeclaration constructorDeclarationParam, TContext context);
    public virtual void VisitConstructorInitializer(IConstructorInitializer constructorInitializerParam, TContext context);
    public virtual void VisitContinueStatement(IContinueStatement continueStatementParam, TContext context);
    public virtual void VisitConversionOperatorDeclaration(IConversionOperatorDeclaration conversionOperatorDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [objectCreationExpression] that directly implements creationExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCreationExpression(ICreationExpression creationExpressionParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [arrayInitializer] that directly implements creationExpressionInitializer and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitCreationExpressionInitializer(ICreationExpressionInitializer creationExpressionInitializerParam, TContext context);
    public virtual void VisitDeclarationExpression(IDeclarationExpression declarationExpressionParam, TContext context);
    public virtual void VisitDeclarationStatement(IDeclarationStatement declarationStatementParam, TContext context);
    public virtual void VisitDeconstructionPatternClause(IDeconstructionPatternClause deconstructionPatternClauseParam, TContext context);
    public virtual void VisitDefaultConstraint(IDefaultConstraint defaultConstraintParam, TContext context);
    public virtual void VisitDefaultExpression(IDefaultExpression defaultExpressionParam, TContext context);
    public virtual void VisitDefineDirective(IDefineDirective defineDirectiveParam, TContext context);
    public virtual void VisitDelegateDeclaration(IDelegateDeclaration delegateDeclarationParam, TContext context);
    public virtual void VisitDestructorDeclaration(IDestructorDeclaration destructorDeclarationParam, TContext context);
    public virtual void VisitDiscardDesignation(IDiscardDesignation discardDesignationParam, TContext context);
    public virtual void VisitDiscardPattern(IDiscardPattern discardPatternParam, TContext context);
    public virtual void VisitDoStatement(IDoStatement doStatementParam, TContext context);
    public virtual void VisitDocCRefElement(IDocCRefElement docCRefElementParam, TContext context);
    public virtual void VisitDocCRefExpression(IDocCRefExpression docCRefExpressionParam, TContext context);
    public virtual void VisitDocCRefParameter(IDocCRefParameter docCRefParameterParam, TContext context);
    public virtual void VisitDocCRefParameterType(IDocCRefParameterType docCRefParameterTypeParam, TContext context);
    public virtual void VisitDocCRefParameterTypeName(IDocCRefParameterTypeName docCRefParameterTypeNameParam, TContext context);
    public virtual void VisitDocCRefSignature(IDocCRefSignature docCRefSignatureParam, TContext context);
    public virtual void VisitDocCRefTypeParameter(IDocCRefTypeParameter docCRefTypeParameterParam, TContext context);
    public virtual void VisitDocCRefTypeParameterList(IDocCRefTypeParameterList docCRefTypeParameterListParam, TContext context);
    public virtual void VisitElementAccessExpression(IElementAccessExpression elementAccessExpressionParam, TContext context);
    public virtual void VisitElifDirective(IElifDirective elifDirectiveParam, TContext context);
    public virtual void VisitElseDirective(IElseDirective elseDirectiveParam, TContext context);
    public virtual void VisitEmptyStatement(IEmptyStatement emptyStatementParam, TContext context);
    public virtual void VisitEndRegion(IEndRegion endRegionParam, TContext context);
    public virtual void VisitEndifDirective(IEndifDirective endifDirectiveParam, TContext context);
    public virtual void VisitEnumBase(IEnumBase enumBaseParam, TContext context);
    public virtual void VisitEnumBody(IEnumBody enumBodyParam, TContext context);
    public virtual void VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam, TContext context);
    public virtual void VisitEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclarationParam, TContext context);
    public virtual void VisitEqualityExpression(IEqualityExpression equalityExpressionParam, TContext context);
    public virtual void VisitErrorDirective(IErrorDirective errorDirectiveParam, TContext context);
    public virtual void VisitEventDeclaration(IEventDeclaration eventDeclarationParam, TContext context);
    public virtual void VisitExceptionFilterClause(IExceptionFilterClause exceptionFilterClauseParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements expressionBodyOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitExpressionBodyOwnerDeclaration(IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclarationParam, TContext context);
    public virtual void VisitExpressionElement(IExpressionElement expressionElementParam, TContext context);
    public virtual void VisitExpressionInitializer(IExpressionInitializer expressionInitializerParam, TContext context);
    public virtual void VisitExpressionStatement(IExpressionStatement expressionStatementParam, TContext context);
    public virtual void VisitExtendedType(IExtendedType extendedTypeParam, TContext context);
    public virtual void VisitExtendsList(IExtendsList extendsListParam, TContext context);
    public virtual void VisitExternAliasDirective(IExternAliasDirective externAliasDirectiveParam, TContext context);
    public virtual void VisitFieldDeclaration(IFieldDeclaration fieldDeclarationParam, TContext context);
    public virtual void VisitForInitializer(IForInitializer forInitializerParam, TContext context);
    public virtual void VisitForIterator(IForIterator forIteratorParam, TContext context);
    public virtual void VisitForStatement(IForStatement forStatementParam, TContext context);
    public virtual void VisitForeachHeader(IForeachHeader foreachHeaderParam, TContext context);
    public virtual void VisitForeachStatement(IForeachStatement foreachStatementParam, TContext context);
    public virtual void VisitFormalParameterList(IFormalParameterList formalParameterListParam, TContext context);
    public virtual void VisitFunctionPointerCallingConvention(IFunctionPointerCallingConvention functionPointerCallingConventionParam, TContext context);
    public virtual void VisitFunctionPointerParameter(IFunctionPointerParameter functionPointerParameterParam, TContext context);
    public virtual void VisitFunctionPointerParameterModifiers(IFunctionPointerParameterModifiers functionPointerParameterModifiersParam, TContext context);
    public virtual void VisitFunctionPointerTypeUsage(IFunctionPointerTypeUsage functionPointerTypeUsageParam, TContext context);
    public virtual void VisitGeneralCatchClause(IGeneralCatchClause generalCatchClauseParam, TContext context);
    public virtual void VisitGotoCaseStatement(IGotoCaseStatement gotoCaseStatementParam, TContext context);
    public virtual void VisitGotoStatement(IGotoStatement gotoStatementParam, TContext context);
    public virtual void VisitIfDirective(IIfDirective ifDirectiveParam, TContext context);
    public virtual void VisitIfStatement(IIfStatement ifStatementParam, TContext context);
    public virtual void VisitIndexFromEndExpression(IIndexFromEndExpression indexFromEndExpressionParam, TContext context);
    public virtual void VisitIndexerDeclaration(IIndexerDeclaration indexerDeclarationParam, TContext context);
    public virtual void VisitIndexerInitializer(IIndexerInitializer indexerInitializerParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements initializedMemberInitializer interface, so this visitor member will not be invoked")]
public virtual void VisitInitializedMemberInitializer(IInitializedMemberInitializer initializedMemberInitializerParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [collectionElementInitializer] that directly implements initializerElement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitInitializerElement(IInitializerElement initializerElementParam, TContext context);
    public virtual void VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements interfaceQualificationOwner interface, so this visitor member will not be invoked")]
public virtual void VisitInterfaceQualificationOwner(IInterfaceQualificationOwner interfaceQualificationOwnerParam, TContext context);
    public virtual void VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam, TContext context);
    public virtual void VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam, TContext context);
    public virtual void VisitInvalidDirective(IInvalidDirective invalidDirectiveParam, TContext context);
    public virtual void VisitInvocationExpression(IInvocationExpression invocationExpressionParam, TContext context);
    public virtual void VisitIsExpression(IIsExpression isExpressionParam, TContext context);
    public virtual void VisitKeyword(IKeyword keywordParam, TContext context);
    public virtual void VisitLabelDeclaration(ILabelDeclaration labelDeclarationParam, TContext context);
    public virtual void VisitLabelReferenceElement(ILabelReferenceElement labelReferenceElementParam, TContext context);
    public virtual void VisitLabelStatement(ILabelStatement labelStatementParam, TContext context);
    public virtual void VisitLambdaExpression(ILambdaExpression lambdaExpressionParam, TContext context);
    public virtual void VisitLambdaSignature(ILambdaSignature lambdaSignatureParam, TContext context);
    public virtual void VisitLineDirective(ILineDirective lineDirectiveParam, TContext context);
    public virtual void VisitLineIndicator(ILineIndicator lineIndicatorParam, TContext context);
    public virtual void VisitListPattern(IListPattern listPatternParam, TContext context);
    public virtual void VisitLocalArglistParameterDeclaration(ILocalArglistParameterDeclaration localArglistParameterDeclarationParam, TContext context);
    public virtual void VisitLocalConstantDeclaration(ILocalConstantDeclaration localConstantDeclarationParam, TContext context);
    public virtual void VisitLocalFormalParameterList(ILocalFormalParameterList localFormalParameterListParam, TContext context);
    public virtual void VisitLocalFunctionDeclaration(ILocalFunctionDeclaration localFunctionDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration] that directly implements localParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitLocalParameterDeclaration(ILocalParameterDeclaration localParameterDeclarationParam, TContext context);
    public virtual void VisitLocalRegularParameterDeclaration(ILocalRegularParameterDeclaration localRegularParameterDeclarationParam, TContext context);
    public virtual void VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam, TContext context);
    public virtual void VisitLockStatement(ILockStatement lockStatementParam, TContext context);
    public virtual void VisitMakerefExpression(IMakerefExpression makerefExpressionParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements memberInitializer interface, so this visitor member will not be invoked")]
public virtual void VisitMemberInitializer(IMemberInitializer memberInitializerParam, TContext context);
    public virtual void VisitMemberOwnerBody(IMemberOwnerBody memberOwnerBodyParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements memberOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitMemberOwnerDeclaration(IMemberOwnerDeclaration memberOwnerDeclarationParam, TContext context);
    public virtual void VisitMethodDeclaration(IMethodDeclaration methodDeclarationParam, TContext context);
    public virtual void VisitMissingDesignation(IMissingDesignation missingDesignationParam, TContext context);
    public virtual void VisitModifiersList(IModifiersList modifiersListParam, TContext context);
    public virtual void VisitMultipleConstantDeclaration(IMultipleConstantDeclaration multipleConstantDeclarationParam, TContext context);
    public virtual void VisitMultipleDeclaration(IMultipleDeclaration multipleDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [constantDeclaration, eventDeclaration, fieldDeclaration] that directly implements multipleDeclarationMember and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitMultipleDeclarationMember(IMultipleDeclarationMember multipleDeclarationMemberParam, TContext context);
    public virtual void VisitMultipleEventDeclaration(IMultipleEventDeclaration multipleEventDeclarationParam, TContext context);
    public virtual void VisitMultipleFieldDeclaration(IMultipleFieldDeclaration multipleFieldDeclarationParam, TContext context);
    public virtual void VisitMultipleLocalConstantDeclaration(IMultipleLocalConstantDeclaration multipleLocalConstantDeclarationParam, TContext context);
    public virtual void VisitMultipleLocalVariableDeclaration(IMultipleLocalVariableDeclaration multipleLocalVariableDeclarationParam, TContext context);
    public virtual void VisitMultiplicativeExpression(IMultiplicativeExpression multiplicativeExpressionParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements namedMemberInitializer interface, so this visitor member will not be invoked")]
public virtual void VisitNamedMemberInitializer(INamedMemberInitializer namedMemberInitializerParam, TContext context);
    public virtual void VisitNamespaceBody(INamespaceBody namespaceBodyParam, TContext context);
    public virtual void VisitNegatedPattern(INegatedPattern negatedPatternParam, TContext context);
    public virtual void VisitNullCoalescingExpression(INullCoalescingExpression nullCoalescingExpressionParam, TContext context);
    public virtual void VisitNullableDirective(INullableDirective nullableDirectiveParam, TContext context);
    public virtual void VisitNullableTypeMark(INullableTypeMark nullableTypeMarkParam, TContext context);
    public virtual void VisitNullableTypeUsage(INullableTypeUsage nullableTypeUsageParam, TContext context);
    public virtual void VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam, TContext context);
    public virtual void VisitObjectInitializer(IObjectInitializer objectInitializerParam, TContext context);
    public virtual void VisitOperatorDeclaration(IOperatorDeclaration operatorDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements operatorExpression interface, so this visitor member will not be invoked")]
public virtual void VisitOperatorExpression(IOperatorExpression operatorExpressionParam, TContext context);
    public virtual void VisitOrPattern(IOrPattern orPatternParam, TContext context);
    public virtual void VisitOverflowCheckingStatement(IOverflowCheckingStatement overflowCheckingStatementParam, TContext context);
    public virtual void VisitOwnerQualification(IOwnerQualification ownerQualificationParam, TContext context);
    public virtual void VisitParameterModifiersList(IParameterModifiersList parameterModifiersListParam, TContext context);
    public virtual void VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam, TContext context);
    public virtual void VisitParenthesizedPattern(IParenthesizedPattern parenthesizedPatternParam, TContext context);
    public virtual void VisitParenthesizedVariableDesignation(IParenthesizedVariableDesignation parenthesizedVariableDesignationParam, TContext context);
    public virtual void VisitPattern(IPattern patternParam, TContext context);
    public virtual void VisitPatternGuardClause(IPatternGuardClause patternGuardClauseParam, TContext context);
    public virtual void VisitPointerTypeUsage(IPointerTypeUsage pointerTypeUsageParam, TContext context);
    public virtual void VisitPostfixOperatorExpression(IPostfixOperatorExpression postfixOperatorExpressionParam, TContext context);
    public virtual void VisitPragmaDirective(IPragmaDirective pragmaDirectiveParam, TContext context);
    public virtual void VisitPredefinedTypeExpression(IPredefinedTypeExpression predefinedTypeExpressionParam, TContext context);
    public virtual void VisitPredefinedTypeReference(IPredefinedTypeReference predefinedTypeReferenceParam, TContext context);
    public virtual void VisitPredefinedTypeUsage(IPredefinedTypeUsage predefinedTypeUsageParam, TContext context);
    public virtual void VisitPrefixOperatorExpression(IPrefixOperatorExpression prefixOperatorExpressionParam, TContext context);
    public virtual void VisitPreprocessor(IPreprocessor preprocessorParam, TContext context);
    public virtual void VisitPreprocessorAndExpression(IPreprocessorAndExpression preprocessorAndExpressionParam, TContext context);
    public virtual void VisitPreprocessorConditionalSymbol(IPreprocessorConditionalSymbol preprocessorConditionalSymbolParam, TContext context);
    public virtual void VisitPreprocessorDirective(IPreprocessorDirective preprocessorDirectiveParam, TContext context);
    public virtual void VisitPreprocessorEqualityExpression(IPreprocessorEqualityExpression preprocessorEqualityExpressionParam, TContext context);
    public virtual void VisitPreprocessorExpression(IPreprocessorExpression preprocessorExpressionParam, TContext context);
    public virtual void VisitPreprocessorNegation(IPreprocessorNegation preprocessorNegationParam, TContext context);
    public virtual void VisitPreprocessorOrExpression(IPreprocessorOrExpression preprocessorOrExpressionParam, TContext context);
    public virtual void VisitPreprocessorParenthesizedExpression(IPreprocessorParenthesizedExpression preprocessorParenthesizedExpressionParam, TContext context);
    public virtual void VisitPreprocessorPragmaBody(IPreprocessorPragmaBody preprocessorPragmaBodyParam, TContext context);
    public virtual void VisitPreprocessorUnaryExpression(IPreprocessorUnaryExpression preprocessorUnaryExpressionParam, TContext context);
    public virtual void VisitPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration primaryConstructorDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [elementAccessExpression, invocationExpression, lambdaExpression, postfixOperatorExpression] that directly implements primaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitPrimaryExpression(IPrimaryExpression primaryExpressionParam, TContext context);
    public virtual void VisitPropertyAssignment(IPropertyAssignment propertyAssignmentParam, TContext context);
    public virtual void VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam, TContext context);
    public virtual void VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam, TContext context);
    public virtual void VisitPropertyPatternClause(IPropertyPatternClause propertyPatternClauseParam, TContext context);
    public virtual void VisitQueryClause(IQueryClause queryClauseParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [queryExpression] that directly implements queryClausesHolder and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitQueryClausesHolder(IQueryClausesHolder queryClausesHolderParam, TContext context);
    public virtual void VisitQueryContinuation(IQueryContinuation queryContinuationParam, TContext context);
    public virtual void VisitQueryExpression(IQueryExpression queryExpressionParam, TContext context);
    public virtual void VisitQueryFirstFrom(IQueryFirstFrom queryFirstFromParam, TContext context);
    public virtual void VisitQueryFromClause(IQueryFromClause queryFromClauseParam, TContext context);
    public virtual void VisitQueryGroupClause(IQueryGroupClause queryGroupClauseParam, TContext context);
    public virtual void VisitQueryJoinClause(IQueryJoinClause queryJoinClauseParam, TContext context);
    public virtual void VisitQueryLetClause(IQueryLetClause queryLetClauseParam, TContext context);
    public virtual void VisitQueryOrderByClause(IQueryOrderByClause queryOrderByClauseParam, TContext context);
    public virtual void VisitQueryOrdering(IQueryOrdering queryOrderingParam, TContext context);
    public virtual void VisitQueryParameterPlatform(IQueryParameterPlatform queryParameterPlatformParam, TContext context);
    public virtual void VisitQueryRangeVariableDeclaration(IQueryRangeVariableDeclaration queryRangeVariableDeclarationParam, TContext context);
    public virtual void VisitQuerySelectClause(IQuerySelectClause querySelectClauseParam, TContext context);
    public virtual void VisitQueryWhereClause(IQueryWhereClause queryWhereClauseParam, TContext context);
    public virtual void VisitRangeExpression(IRangeExpression rangeExpressionParam, TContext context);
    public virtual void VisitRankSpecifier(IRankSpecifier rankSpecifierParam, TContext context);
    public virtual void VisitRecordDeclaration(IRecordDeclaration recordDeclarationParam, TContext context);
    public virtual void VisitRecursivePattern(IRecursivePattern recursivePatternParam, TContext context);
    public virtual void VisitRefExpression(IRefExpression refExpressionParam, TContext context);
    public virtual void VisitReferenceExpression(IReferenceExpression referenceExpressionParam, TContext context);
    public virtual void VisitReferenceName(IReferenceName referenceNameParam, TContext context);
    public virtual void VisitReferenceTypeConstraint(IReferenceTypeConstraint referenceTypeConstraintParam, TContext context);
    public virtual void VisitReftypeExpression(IReftypeExpression reftypeExpressionParam, TContext context);
    public virtual void VisitRefvalueExpression(IRefvalueExpression refvalueExpressionParam, TContext context);
    public virtual void VisitRelationalExpression(IRelationalExpression relationalExpressionParam, TContext context);
    public virtual void VisitRelationalPattern(IRelationalPattern relationalPatternParam, TContext context);
    public virtual void VisitResourceAcquisitionExpressionsList(IResourceAcquisitionExpressionsList resourceAcquisitionExpressionsListParam, TContext context);
    public virtual void VisitReturnStatement(IReturnStatement returnStatementParam, TContext context);
    public virtual void VisitScalarTypeUsage(IScalarTypeUsage scalarTypeUsageParam, TContext context);
    public virtual void VisitShiftExpression(IShiftExpression shiftExpressionParam, TContext context);
    public virtual void VisitSignOperatorDeclaration(ISignOperatorDeclaration signOperatorDeclarationParam, TContext context);
    public virtual void VisitSingleVariableDesignation(ISingleVariableDesignation singleVariableDesignationParam, TContext context);
    public virtual void VisitSlicePattern(ISlicePattern slicePatternParam, TContext context);
    public virtual void VisitSpecificCatchClause(ISpecificCatchClause specificCatchClauseParam, TContext context);
    public virtual void VisitSpreadElement(ISpreadElement spreadElementParam, TContext context);
    public virtual void VisitStackAllocExpression(IStackAllocExpression stackAllocExpressionParam, TContext context);
    public virtual void VisitStartRegion(IStartRegion startRegionParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [block] that directly implements statementsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitStatementsOwner(IStatementsOwner statementsOwnerParam, TContext context);
    public virtual void VisitStructDeclaration(IStructDeclaration structDeclarationParam, TContext context);
    public virtual void VisitSubpattern(ISubpattern subpatternParam, TContext context);
    public virtual void VisitSuppressNullableWarningExpression(ISuppressNullableWarningExpression suppressNullableWarningExpressionParam, TContext context);
    public virtual void VisitSwitchBlock(ISwitchBlock switchBlockParam, TContext context);
    public virtual void VisitSwitchCaseLabel(ISwitchCaseLabel switchCaseLabelParam, TContext context);
    public virtual void VisitSwitchExpression(ISwitchExpression switchExpressionParam, TContext context);
    public virtual void VisitSwitchExpressionArm(ISwitchExpressionArm switchExpressionArmParam, TContext context);
    public virtual void VisitSwitchSection(ISwitchSection switchSectionParam, TContext context);
    public virtual void VisitSwitchStatement(ISwitchStatement switchStatementParam, TContext context);
    public virtual void VisitThisExpression(IThisExpression thisExpressionParam, TContext context);
    public virtual void VisitThrowExpression(IThrowExpression throwExpressionParam, TContext context);
    public virtual void VisitThrowStatement(IThrowStatement throwStatementParam, TContext context);
    public virtual void VisitTopLevelCode(ITopLevelCode topLevelCodeParam, TContext context);
    public virtual void VisitTryStatement(ITryStatement tryStatementParam, TContext context);
    public virtual void VisitTupleComponent(ITupleComponent tupleComponentParam, TContext context);
    public virtual void VisitTupleComponentList(ITupleComponentList tupleComponentListParam, TContext context);
    public virtual void VisitTupleExpression(ITupleExpression tupleExpressionParam, TContext context);
    public virtual void VisitTupleTypeComponent(ITupleTypeComponent tupleTypeComponentParam, TContext context);
    public virtual void VisitTupleTypeComponentList(ITupleTypeComponentList tupleTypeComponentListParam, TContext context);
    public virtual void VisitTupleTypeUsage(ITupleTypeUsage tupleTypeUsageParam, TContext context);
    public virtual void VisitTypeArgumentList(ITypeArgumentList typeArgumentListParam, TContext context);
    public virtual void VisitTypeConstraint(ITypeConstraint typeConstraintParam, TContext context);
    public virtual void VisitTypeMemberArglistParameterDeclaration(ITypeMemberArglistParameterDeclaration typeMemberArglistParameterDeclarationParam, TContext context);
    public virtual void VisitTypeMemberRegularParameterDeclaration(ITypeMemberRegularParameterDeclaration typeMemberRegularParameterDeclarationParam, TContext context);
    public virtual void VisitTypeParameterConstraint(ITypeParameterConstraint typeParameterConstraintParam, TContext context);
    public virtual void VisitTypeParameterConstraintsClause(ITypeParameterConstraintsClause typeParameterConstraintsClauseParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [typeParameterOfMethodDeclaration, typeParameterOfTypeDeclaration] that directly implements typeParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitTypeParameterDeclaration(ITypeParameterDeclaration typeParameterDeclarationParam, TContext context);
    public virtual void VisitTypeParameterOfLocalFunctionDeclaration(ITypeParameterOfLocalFunctionDeclaration typeParameterOfLocalFunctionDeclarationParam, TContext context);
    public virtual void VisitTypeParameterOfLocalFunctionList(ITypeParameterOfLocalFunctionList typeParameterOfLocalFunctionListParam, TContext context);
    public virtual void VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam, TContext context);
    public virtual void VisitTypeParameterOfMethodList(ITypeParameterOfMethodList typeParameterOfMethodListParam, TContext context);
    public virtual void VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam, TContext context);
    public virtual void VisitTypeParameterOfTypeList(ITypeParameterOfTypeList typeParameterOfTypeListParam, TContext context);
    public virtual void VisitTypeParameterReference(ITypeParameterReference typeParameterReferenceParam, TContext context);
    public virtual void VisitTypePattern(ITypePattern typePatternParam, TContext context);
    public virtual void VisitTypeUsage(ITypeUsage typeUsageParam, TContext context);
    public virtual void VisitTypeofExpression(ITypeofExpression typeofExpressionParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [prefixOperatorExpression, unaryOperatorExpression] that directly implements unaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitUnaryExpression(IUnaryExpression unaryExpressionParam, TContext context);
    public virtual void VisitUnaryOperatorExpression(IUnaryOperatorExpression unaryOperatorExpressionParam, TContext context);
    public virtual void VisitUncheckedExpression(IUncheckedExpression uncheckedExpressionParam, TContext context);
    public virtual void VisitUncheckedStatement(IUncheckedStatement uncheckedStatementParam, TContext context);
    public virtual void VisitUndefDirective(IUndefDirective undefDirectiveParam, TContext context);
    public virtual void VisitUnsafeCodeAddressOfExpression(IUnsafeCodeAddressOfExpression unsafeCodeAddressOfExpressionParam, TContext context);
    public virtual void VisitUnsafeCodeFixedPointerDeclaration(IUnsafeCodeFixedPointerDeclaration unsafeCodeFixedPointerDeclarationParam, TContext context);
    public virtual void VisitUnsafeCodeFixedPointerInitializer(IUnsafeCodeFixedPointerInitializer unsafeCodeFixedPointerInitializerParam, TContext context);
    public virtual void VisitUnsafeCodeFixedStatement(IUnsafeCodeFixedStatement unsafeCodeFixedStatementParam, TContext context);
    public virtual void VisitUnsafeCodePointer(IUnsafeCodePointer unsafeCodePointerParam, TContext context);
    public virtual void VisitUnsafeCodePointerAccessExpression(IUnsafeCodePointerAccessExpression unsafeCodePointerAccessExpressionParam, TContext context);
    public virtual void VisitUnsafeCodePointerIndirectionExpression(IUnsafeCodePointerIndirectionExpression unsafeCodePointerIndirectionExpressionParam, TContext context);
    public virtual void VisitUnsafeCodeSizeOfExpression(IUnsafeCodeSizeOfExpression unsafeCodeSizeOfExpressionParam, TContext context);
    public virtual void VisitUnsafeCodeUnsafeStatement(IUnsafeCodeUnsafeStatement unsafeCodeUnsafeStatementParam, TContext context);
    public virtual void VisitUserTypeUsage(IUserTypeUsage userTypeUsageParam, TContext context);
    public virtual void VisitUsingAliasDirective(IUsingAliasDirective usingAliasDirectiveParam, TContext context);
    public virtual void VisitUsingDirective(IUsingDirective usingDirectiveParam, TContext context);
    public virtual void VisitUsingList(IUsingList usingListParam, TContext context);
    public virtual void VisitUsingStatement(IUsingStatement usingStatementParam, TContext context);
    public virtual void VisitUsingSymbolDirective(IUsingSymbolDirective usingSymbolDirectiveParam, TContext context);
    public virtual void VisitValueTypeConstraint(IValueTypeConstraint valueTypeConstraintParam, TContext context);
    public virtual void VisitVarDeconstructionPattern(IVarDeconstructionPattern varDeconstructionPatternParam, TContext context);
    public virtual void VisitVarPattern(IVarPattern varPatternParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration, propertyDeclaration, singleVariableDesignation] that directly implements variableDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVariableDeclaration(IVariableDeclaration variableDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [singleVariableDesignation] that directly implements variableDesignation and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVariableDesignation(IVariableDesignation variableDesignationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [arrayInitializer] that directly implements variableInitializer and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVariableInitializer(IVariableInitializer variableInitializerParam, TContext context);
    public virtual void VisitWarningAction(IWarningAction warningActionParam, TContext context);
    public virtual void VisitWarningDirective(IWarningDirective warningDirectiveParam, TContext context);
    public virtual void VisitWarningList(IWarningList warningListParam, TContext context);
    public virtual void VisitWhileStatement(IWhileStatement whileStatementParam, TContext context);
    public virtual void VisitWithExpression(IWithExpression withExpressionParam, TContext context);
    public virtual void VisitWithInitializerAssignment(IWithInitializerAssignment withInitializerAssignmentParam, TContext context);
    public virtual void VisitYieldStatement(IYieldStatement yieldStatementParam, TContext context);
    public virtual void VisitInactivePreprocessorBranchNode(IInactivePreprocessorBranch inactivePreprocessorBranchNode, TContext context);
    public virtual void VisitDocCommentBlockNode(IDocCommentBlock xmlDoc, TContext context);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Tree.TreeNodeVisitor`2 : object {
    public virtual TReturn VisitNode(ITreeNode node, TContext context);
    public virtual TReturn VisitAccessorDeclaration(IAccessorDeclaration accessorDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements accessorOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitAccessorOwnerDeclaration(IAccessorOwnerDeclaration accessorOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitAdditiveExpression(IAdditiveExpression additiveExpressionParam, TContext context);
    public virtual TReturn VisitAllowsRefStructConstraint(IAllowsRefStructConstraint allowsRefStructConstraintParam, TContext context);
    public virtual TReturn VisitAndPattern(IAndPattern andPatternParam, TContext context);
    public virtual TReturn VisitAnonymousMemberDeclaration(IAnonymousMemberDeclaration anonymousMemberDeclarationParam, TContext context);
    public virtual TReturn VisitAnonymousMethodExpression(IAnonymousMethodExpression anonymousMethodExpressionParam, TContext context);
    public virtual TReturn VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreationExpressionParam, TContext context);
    public virtual TReturn VisitAnonymousObjectInitializer(IAnonymousObjectInitializer anonymousObjectInitializerParam, TContext context);
    public virtual TReturn VisitArglistExpression(IArglistExpression arglistExpressionParam, TContext context);
    public virtual TReturn VisitArgumentList(IArgumentList argumentListParam, TContext context);
    public virtual TReturn VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpressionParam, TContext context);
    public virtual TReturn VisitArrayInitializer(IArrayInitializer arrayInitializerParam, TContext context);
    public virtual TReturn VisitArrayTypeUsage(IArrayTypeUsage arrayTypeUsageParam, TContext context);
    public virtual TReturn VisitArrowExpressionClause(IArrowExpressionClause arrowExpressionClauseParam, TContext context);
    public virtual TReturn VisitAsExpression(IAsExpression asExpressionParam, TContext context);
    public virtual TReturn VisitAssignmentExpression(IAssignmentExpression assignmentExpressionParam, TContext context);
    public virtual TReturn VisitAttribute(IAttribute attributeParam, TContext context);
    public virtual TReturn VisitAttributeList(IAttributeList attributeListParam, TContext context);
    public virtual TReturn VisitAttributeSection(IAttributeSection attributeSectionParam, TContext context);
    public virtual TReturn VisitAttributeSectionList(IAttributeSectionList attributeSectionListParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributesOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitAttributesOwnerDeclaration(IAttributesOwnerDeclaration attributesOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitAwaitExpression(IAwaitExpression awaitExpressionParam, TContext context);
    public virtual TReturn VisitBaseExpression(IBaseExpression baseExpressionParam, TContext context);
    public virtual TReturn VisitBinaryExpression(IBinaryExpression binaryExpressionParam, TContext context);
    public virtual TReturn VisitBinaryPattern(IBinaryPattern binaryPatternParam, TContext context);
    public virtual TReturn VisitBitwiseAndExpression(IBitwiseAndExpression bitwiseAndExpressionParam, TContext context);
    public virtual TReturn VisitBitwiseExclusiveOrExpression(IBitwiseExclusiveOrExpression bitwiseExclusiveOrExpressionParam, TContext context);
    public virtual TReturn VisitBitwiseInclusiveOrExpression(IBitwiseInclusiveOrExpression bitwiseInclusiveOrExpressionParam, TContext context);
    public virtual TReturn VisitBlock(IBlock blockParam, TContext context);
    public virtual TReturn VisitBreakStatement(IBreakStatement breakStatementParam, TContext context);
    public virtual TReturn VisitCSharpArgument(ICSharpArgument cSharpArgumentParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [collectionElementInitializer, elementAccessExpression, indexerInitializer, invocationExpression, objectCreationExpression] that directly implements cSharpArgumentsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCSharpArgumentsOwner(ICSharpArgumentsOwner cSharpArgumentsOwnerParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [cSharpNamespaceDeclaration] that directly implements cSharpDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCSharpDeclaration(ICSharpDeclaration cSharpDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [assignmentExpression, queryExpression] that directly implements cSharpExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCSharpExpression(ICSharpExpression cSharpExpressionParam, TContext context);
    public virtual TReturn VisitCSharpFile(ICSharpFile cSharpFileParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration, destructorDeclaration, methodDeclaration] that directly implements cSharpFunctionDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCSharpFunctionDeclaration(ICSharpFunctionDeclaration cSharpFunctionDeclarationParam, TContext context);
    public virtual TReturn VisitCSharpLiteralExpression(ICSharpLiteralExpression cSharpLiteralExpressionParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements cSharpModifiersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitCSharpModifiersOwnerDeclaration(ICSharpModifiersOwnerDeclaration cSharpModifiersOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitCSharpNamespaceDeclaration(ICSharpNamespaceDeclaration cSharpNamespaceDeclarationParam, TContext context);
    public virtual TReturn VisitCSharpParameterDeclaration(ICSharpParameterDeclaration cSharpParameterDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration, delegateDeclaration, destructorDeclaration, indexerDeclaration, localFunctionDeclaration, methodDeclaration] that directly implements cSharpParametersOwnerDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCSharpParametersOwnerDeclaration(ICSharpParametersOwnerDeclaration cSharpParametersOwnerDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration] that directly implements cSharpRegularParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCSharpRegularParameterDeclaration(ICSharpRegularParameterDeclaration cSharpRegularParameterDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [block] that directly implements cSharpStatement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCSharpStatement(ICSharpStatement cSharpStatementParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [cSharpNamespaceDeclaration] that directly implements cSharpTypeAndNamespaceHolderDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCSharpTypeAndNamespaceHolderDeclaration(ICSharpTypeAndNamespaceHolderDeclaration cSharpTypeAndNamespaceHolderDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements cSharpTypeDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitCSharpTypeDeclaration(ICSharpTypeDeclaration cSharpTypeDeclarationParam, TContext context);
    public virtual TReturn VisitCSharpTypeMemberDeclaration(ICSharpTypeMemberDeclaration cSharpTypeMemberDeclarationParam, TContext context);
    public virtual TReturn VisitCastExpression(ICastExpression castExpressionParam, TContext context);
    public virtual TReturn VisitCatchClause(ICatchClause catchClauseParam, TContext context);
    public virtual TReturn VisitCatchVariableDeclaration(ICatchVariableDeclaration catchVariableDeclarationParam, TContext context);
    public virtual TReturn VisitCheckedExpression(ICheckedExpression checkedExpressionParam, TContext context);
    public virtual TReturn VisitCheckedStatement(ICheckedStatement checkedStatementParam, TContext context);
    public virtual TReturn VisitClassBody(IClassBody classBodyParam, TContext context);
    public virtual TReturn VisitClassDeclaration(IClassDeclaration classDeclarationParam, TContext context);
    public virtual TReturn VisitClassLikeDeclaration(IClassLikeDeclaration classLikeDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements classMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitClassMemberDeclaration(IClassMemberDeclaration classMemberDeclarationParam, TContext context);
    public virtual TReturn VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam, TContext context);
    public virtual TReturn VisitCollectionExpression(ICollectionExpression collectionExpressionParam, TContext context);
    public virtual TReturn VisitCollectionExpressionElement(ICollectionExpressionElement collectionExpressionElementParam, TContext context);
    public virtual TReturn VisitCollectionInitializer(ICollectionInitializer collectionInitializerParam, TContext context);
    public virtual TReturn VisitConditionalAccessSign(IConditionalAccessSign conditionalAccessSignParam, TContext context);
    public virtual TReturn VisitConditionalAndExpression(IConditionalAndExpression conditionalAndExpressionParam, TContext context);
    public virtual TReturn VisitConditionalOrExpression(IConditionalOrExpression conditionalOrExpressionParam, TContext context);
    public virtual TReturn VisitConditionalTernaryExpression(IConditionalTernaryExpression conditionalTernaryExpressionParam, TContext context);
    public virtual TReturn VisitConstantDeclaration(IConstantDeclaration constantDeclarationParam, TContext context);
    public virtual TReturn VisitConstantOrTypePattern(IConstantOrTypePattern constantOrTypePatternParam, TContext context);
    public virtual TReturn VisitConstructorConstraint(IConstructorConstraint constructorConstraintParam, TContext context);
    public virtual TReturn VisitConstructorDeclaration(IConstructorDeclaration constructorDeclarationParam, TContext context);
    public virtual TReturn VisitConstructorInitializer(IConstructorInitializer constructorInitializerParam, TContext context);
    public virtual TReturn VisitContinueStatement(IContinueStatement continueStatementParam, TContext context);
    public virtual TReturn VisitConversionOperatorDeclaration(IConversionOperatorDeclaration conversionOperatorDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [objectCreationExpression] that directly implements creationExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCreationExpression(ICreationExpression creationExpressionParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [arrayInitializer] that directly implements creationExpressionInitializer and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitCreationExpressionInitializer(ICreationExpressionInitializer creationExpressionInitializerParam, TContext context);
    public virtual TReturn VisitDeclarationExpression(IDeclarationExpression declarationExpressionParam, TContext context);
    public virtual TReturn VisitDeclarationStatement(IDeclarationStatement declarationStatementParam, TContext context);
    public virtual TReturn VisitDeconstructionPatternClause(IDeconstructionPatternClause deconstructionPatternClauseParam, TContext context);
    public virtual TReturn VisitDefaultConstraint(IDefaultConstraint defaultConstraintParam, TContext context);
    public virtual TReturn VisitDefaultExpression(IDefaultExpression defaultExpressionParam, TContext context);
    public virtual TReturn VisitDefineDirective(IDefineDirective defineDirectiveParam, TContext context);
    public virtual TReturn VisitDelegateDeclaration(IDelegateDeclaration delegateDeclarationParam, TContext context);
    public virtual TReturn VisitDestructorDeclaration(IDestructorDeclaration destructorDeclarationParam, TContext context);
    public virtual TReturn VisitDiscardDesignation(IDiscardDesignation discardDesignationParam, TContext context);
    public virtual TReturn VisitDiscardPattern(IDiscardPattern discardPatternParam, TContext context);
    public virtual TReturn VisitDoStatement(IDoStatement doStatementParam, TContext context);
    public virtual TReturn VisitDocCRefElement(IDocCRefElement docCRefElementParam, TContext context);
    public virtual TReturn VisitDocCRefExpression(IDocCRefExpression docCRefExpressionParam, TContext context);
    public virtual TReturn VisitDocCRefParameter(IDocCRefParameter docCRefParameterParam, TContext context);
    public virtual TReturn VisitDocCRefParameterType(IDocCRefParameterType docCRefParameterTypeParam, TContext context);
    public virtual TReturn VisitDocCRefParameterTypeName(IDocCRefParameterTypeName docCRefParameterTypeNameParam, TContext context);
    public virtual TReturn VisitDocCRefSignature(IDocCRefSignature docCRefSignatureParam, TContext context);
    public virtual TReturn VisitDocCRefTypeParameter(IDocCRefTypeParameter docCRefTypeParameterParam, TContext context);
    public virtual TReturn VisitDocCRefTypeParameterList(IDocCRefTypeParameterList docCRefTypeParameterListParam, TContext context);
    public virtual TReturn VisitElementAccessExpression(IElementAccessExpression elementAccessExpressionParam, TContext context);
    public virtual TReturn VisitElifDirective(IElifDirective elifDirectiveParam, TContext context);
    public virtual TReturn VisitElseDirective(IElseDirective elseDirectiveParam, TContext context);
    public virtual TReturn VisitEmptyStatement(IEmptyStatement emptyStatementParam, TContext context);
    public virtual TReturn VisitEndRegion(IEndRegion endRegionParam, TContext context);
    public virtual TReturn VisitEndifDirective(IEndifDirective endifDirectiveParam, TContext context);
    public virtual TReturn VisitEnumBase(IEnumBase enumBaseParam, TContext context);
    public virtual TReturn VisitEnumBody(IEnumBody enumBodyParam, TContext context);
    public virtual TReturn VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam, TContext context);
    public virtual TReturn VisitEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclarationParam, TContext context);
    public virtual TReturn VisitEqualityExpression(IEqualityExpression equalityExpressionParam, TContext context);
    public virtual TReturn VisitErrorDirective(IErrorDirective errorDirectiveParam, TContext context);
    public virtual TReturn VisitEventDeclaration(IEventDeclaration eventDeclarationParam, TContext context);
    public virtual TReturn VisitExceptionFilterClause(IExceptionFilterClause exceptionFilterClauseParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements expressionBodyOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitExpressionBodyOwnerDeclaration(IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitExpressionElement(IExpressionElement expressionElementParam, TContext context);
    public virtual TReturn VisitExpressionInitializer(IExpressionInitializer expressionInitializerParam, TContext context);
    public virtual TReturn VisitExpressionStatement(IExpressionStatement expressionStatementParam, TContext context);
    public virtual TReturn VisitExtendedType(IExtendedType extendedTypeParam, TContext context);
    public virtual TReturn VisitExtendsList(IExtendsList extendsListParam, TContext context);
    public virtual TReturn VisitExternAliasDirective(IExternAliasDirective externAliasDirectiveParam, TContext context);
    public virtual TReturn VisitFieldDeclaration(IFieldDeclaration fieldDeclarationParam, TContext context);
    public virtual TReturn VisitForInitializer(IForInitializer forInitializerParam, TContext context);
    public virtual TReturn VisitForIterator(IForIterator forIteratorParam, TContext context);
    public virtual TReturn VisitForStatement(IForStatement forStatementParam, TContext context);
    public virtual TReturn VisitForeachHeader(IForeachHeader foreachHeaderParam, TContext context);
    public virtual TReturn VisitForeachStatement(IForeachStatement foreachStatementParam, TContext context);
    public virtual TReturn VisitFormalParameterList(IFormalParameterList formalParameterListParam, TContext context);
    public virtual TReturn VisitFunctionPointerCallingConvention(IFunctionPointerCallingConvention functionPointerCallingConventionParam, TContext context);
    public virtual TReturn VisitFunctionPointerParameter(IFunctionPointerParameter functionPointerParameterParam, TContext context);
    public virtual TReturn VisitFunctionPointerParameterModifiers(IFunctionPointerParameterModifiers functionPointerParameterModifiersParam, TContext context);
    public virtual TReturn VisitFunctionPointerTypeUsage(IFunctionPointerTypeUsage functionPointerTypeUsageParam, TContext context);
    public virtual TReturn VisitGeneralCatchClause(IGeneralCatchClause generalCatchClauseParam, TContext context);
    public virtual TReturn VisitGotoCaseStatement(IGotoCaseStatement gotoCaseStatementParam, TContext context);
    public virtual TReturn VisitGotoStatement(IGotoStatement gotoStatementParam, TContext context);
    public virtual TReturn VisitIfDirective(IIfDirective ifDirectiveParam, TContext context);
    public virtual TReturn VisitIfStatement(IIfStatement ifStatementParam, TContext context);
    public virtual TReturn VisitIndexFromEndExpression(IIndexFromEndExpression indexFromEndExpressionParam, TContext context);
    public virtual TReturn VisitIndexerDeclaration(IIndexerDeclaration indexerDeclarationParam, TContext context);
    public virtual TReturn VisitIndexerInitializer(IIndexerInitializer indexerInitializerParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements initializedMemberInitializer interface, so this visitor member will not be invoked")]
public virtual TReturn VisitInitializedMemberInitializer(IInitializedMemberInitializer initializedMemberInitializerParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [collectionElementInitializer] that directly implements initializerElement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitInitializerElement(IInitializerElement initializerElementParam, TContext context);
    public virtual TReturn VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements interfaceQualificationOwner interface, so this visitor member will not be invoked")]
public virtual TReturn VisitInterfaceQualificationOwner(IInterfaceQualificationOwner interfaceQualificationOwnerParam, TContext context);
    public virtual TReturn VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam, TContext context);
    public virtual TReturn VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam, TContext context);
    public virtual TReturn VisitInvalidDirective(IInvalidDirective invalidDirectiveParam, TContext context);
    public virtual TReturn VisitInvocationExpression(IInvocationExpression invocationExpressionParam, TContext context);
    public virtual TReturn VisitIsExpression(IIsExpression isExpressionParam, TContext context);
    public virtual TReturn VisitKeyword(IKeyword keywordParam, TContext context);
    public virtual TReturn VisitLabelDeclaration(ILabelDeclaration labelDeclarationParam, TContext context);
    public virtual TReturn VisitLabelReferenceElement(ILabelReferenceElement labelReferenceElementParam, TContext context);
    public virtual TReturn VisitLabelStatement(ILabelStatement labelStatementParam, TContext context);
    public virtual TReturn VisitLambdaExpression(ILambdaExpression lambdaExpressionParam, TContext context);
    public virtual TReturn VisitLambdaSignature(ILambdaSignature lambdaSignatureParam, TContext context);
    public virtual TReturn VisitLineDirective(ILineDirective lineDirectiveParam, TContext context);
    public virtual TReturn VisitLineIndicator(ILineIndicator lineIndicatorParam, TContext context);
    public virtual TReturn VisitListPattern(IListPattern listPatternParam, TContext context);
    public virtual TReturn VisitLocalArglistParameterDeclaration(ILocalArglistParameterDeclaration localArglistParameterDeclarationParam, TContext context);
    public virtual TReturn VisitLocalConstantDeclaration(ILocalConstantDeclaration localConstantDeclarationParam, TContext context);
    public virtual TReturn VisitLocalFormalParameterList(ILocalFormalParameterList localFormalParameterListParam, TContext context);
    public virtual TReturn VisitLocalFunctionDeclaration(ILocalFunctionDeclaration localFunctionDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration] that directly implements localParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitLocalParameterDeclaration(ILocalParameterDeclaration localParameterDeclarationParam, TContext context);
    public virtual TReturn VisitLocalRegularParameterDeclaration(ILocalRegularParameterDeclaration localRegularParameterDeclarationParam, TContext context);
    public virtual TReturn VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam, TContext context);
    public virtual TReturn VisitLockStatement(ILockStatement lockStatementParam, TContext context);
    public virtual TReturn VisitMakerefExpression(IMakerefExpression makerefExpressionParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements memberInitializer interface, so this visitor member will not be invoked")]
public virtual TReturn VisitMemberInitializer(IMemberInitializer memberInitializerParam, TContext context);
    public virtual TReturn VisitMemberOwnerBody(IMemberOwnerBody memberOwnerBodyParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements memberOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitMemberOwnerDeclaration(IMemberOwnerDeclaration memberOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitMethodDeclaration(IMethodDeclaration methodDeclarationParam, TContext context);
    public virtual TReturn VisitMissingDesignation(IMissingDesignation missingDesignationParam, TContext context);
    public virtual TReturn VisitModifiersList(IModifiersList modifiersListParam, TContext context);
    public virtual TReturn VisitMultipleConstantDeclaration(IMultipleConstantDeclaration multipleConstantDeclarationParam, TContext context);
    public virtual TReturn VisitMultipleDeclaration(IMultipleDeclaration multipleDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [constantDeclaration, eventDeclaration, fieldDeclaration] that directly implements multipleDeclarationMember and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitMultipleDeclarationMember(IMultipleDeclarationMember multipleDeclarationMemberParam, TContext context);
    public virtual TReturn VisitMultipleEventDeclaration(IMultipleEventDeclaration multipleEventDeclarationParam, TContext context);
    public virtual TReturn VisitMultipleFieldDeclaration(IMultipleFieldDeclaration multipleFieldDeclarationParam, TContext context);
    public virtual TReturn VisitMultipleLocalConstantDeclaration(IMultipleLocalConstantDeclaration multipleLocalConstantDeclarationParam, TContext context);
    public virtual TReturn VisitMultipleLocalVariableDeclaration(IMultipleLocalVariableDeclaration multipleLocalVariableDeclarationParam, TContext context);
    public virtual TReturn VisitMultiplicativeExpression(IMultiplicativeExpression multiplicativeExpressionParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements namedMemberInitializer interface, so this visitor member will not be invoked")]
public virtual TReturn VisitNamedMemberInitializer(INamedMemberInitializer namedMemberInitializerParam, TContext context);
    public virtual TReturn VisitNamespaceBody(INamespaceBody namespaceBodyParam, TContext context);
    public virtual TReturn VisitNegatedPattern(INegatedPattern negatedPatternParam, TContext context);
    public virtual TReturn VisitNullCoalescingExpression(INullCoalescingExpression nullCoalescingExpressionParam, TContext context);
    public virtual TReturn VisitNullableDirective(INullableDirective nullableDirectiveParam, TContext context);
    public virtual TReturn VisitNullableTypeMark(INullableTypeMark nullableTypeMarkParam, TContext context);
    public virtual TReturn VisitNullableTypeUsage(INullableTypeUsage nullableTypeUsageParam, TContext context);
    public virtual TReturn VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam, TContext context);
    public virtual TReturn VisitObjectInitializer(IObjectInitializer objectInitializerParam, TContext context);
    public virtual TReturn VisitOperatorDeclaration(IOperatorDeclaration operatorDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements operatorExpression interface, so this visitor member will not be invoked")]
public virtual TReturn VisitOperatorExpression(IOperatorExpression operatorExpressionParam, TContext context);
    public virtual TReturn VisitOrPattern(IOrPattern orPatternParam, TContext context);
    public virtual TReturn VisitOverflowCheckingStatement(IOverflowCheckingStatement overflowCheckingStatementParam, TContext context);
    public virtual TReturn VisitOwnerQualification(IOwnerQualification ownerQualificationParam, TContext context);
    public virtual TReturn VisitParameterModifiersList(IParameterModifiersList parameterModifiersListParam, TContext context);
    public virtual TReturn VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam, TContext context);
    public virtual TReturn VisitParenthesizedPattern(IParenthesizedPattern parenthesizedPatternParam, TContext context);
    public virtual TReturn VisitParenthesizedVariableDesignation(IParenthesizedVariableDesignation parenthesizedVariableDesignationParam, TContext context);
    public virtual TReturn VisitPattern(IPattern patternParam, TContext context);
    public virtual TReturn VisitPatternGuardClause(IPatternGuardClause patternGuardClauseParam, TContext context);
    public virtual TReturn VisitPointerTypeUsage(IPointerTypeUsage pointerTypeUsageParam, TContext context);
    public virtual TReturn VisitPostfixOperatorExpression(IPostfixOperatorExpression postfixOperatorExpressionParam, TContext context);
    public virtual TReturn VisitPragmaDirective(IPragmaDirective pragmaDirectiveParam, TContext context);
    public virtual TReturn VisitPredefinedTypeExpression(IPredefinedTypeExpression predefinedTypeExpressionParam, TContext context);
    public virtual TReturn VisitPredefinedTypeReference(IPredefinedTypeReference predefinedTypeReferenceParam, TContext context);
    public virtual TReturn VisitPredefinedTypeUsage(IPredefinedTypeUsage predefinedTypeUsageParam, TContext context);
    public virtual TReturn VisitPrefixOperatorExpression(IPrefixOperatorExpression prefixOperatorExpressionParam, TContext context);
    public virtual TReturn VisitPreprocessor(IPreprocessor preprocessorParam, TContext context);
    public virtual TReturn VisitPreprocessorAndExpression(IPreprocessorAndExpression preprocessorAndExpressionParam, TContext context);
    public virtual TReturn VisitPreprocessorConditionalSymbol(IPreprocessorConditionalSymbol preprocessorConditionalSymbolParam, TContext context);
    public virtual TReturn VisitPreprocessorDirective(IPreprocessorDirective preprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitPreprocessorEqualityExpression(IPreprocessorEqualityExpression preprocessorEqualityExpressionParam, TContext context);
    public virtual TReturn VisitPreprocessorExpression(IPreprocessorExpression preprocessorExpressionParam, TContext context);
    public virtual TReturn VisitPreprocessorNegation(IPreprocessorNegation preprocessorNegationParam, TContext context);
    public virtual TReturn VisitPreprocessorOrExpression(IPreprocessorOrExpression preprocessorOrExpressionParam, TContext context);
    public virtual TReturn VisitPreprocessorParenthesizedExpression(IPreprocessorParenthesizedExpression preprocessorParenthesizedExpressionParam, TContext context);
    public virtual TReturn VisitPreprocessorPragmaBody(IPreprocessorPragmaBody preprocessorPragmaBodyParam, TContext context);
    public virtual TReturn VisitPreprocessorUnaryExpression(IPreprocessorUnaryExpression preprocessorUnaryExpressionParam, TContext context);
    public virtual TReturn VisitPrimaryConstructorDeclaration(IPrimaryConstructorDeclaration primaryConstructorDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [elementAccessExpression, invocationExpression, lambdaExpression, postfixOperatorExpression] that directly implements primaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitPrimaryExpression(IPrimaryExpression primaryExpressionParam, TContext context);
    public virtual TReturn VisitPropertyAssignment(IPropertyAssignment propertyAssignmentParam, TContext context);
    public virtual TReturn VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam, TContext context);
    public virtual TReturn VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam, TContext context);
    public virtual TReturn VisitPropertyPatternClause(IPropertyPatternClause propertyPatternClauseParam, TContext context);
    public virtual TReturn VisitQueryClause(IQueryClause queryClauseParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [queryExpression] that directly implements queryClausesHolder and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitQueryClausesHolder(IQueryClausesHolder queryClausesHolderParam, TContext context);
    public virtual TReturn VisitQueryContinuation(IQueryContinuation queryContinuationParam, TContext context);
    public virtual TReturn VisitQueryExpression(IQueryExpression queryExpressionParam, TContext context);
    public virtual TReturn VisitQueryFirstFrom(IQueryFirstFrom queryFirstFromParam, TContext context);
    public virtual TReturn VisitQueryFromClause(IQueryFromClause queryFromClauseParam, TContext context);
    public virtual TReturn VisitQueryGroupClause(IQueryGroupClause queryGroupClauseParam, TContext context);
    public virtual TReturn VisitQueryJoinClause(IQueryJoinClause queryJoinClauseParam, TContext context);
    public virtual TReturn VisitQueryLetClause(IQueryLetClause queryLetClauseParam, TContext context);
    public virtual TReturn VisitQueryOrderByClause(IQueryOrderByClause queryOrderByClauseParam, TContext context);
    public virtual TReturn VisitQueryOrdering(IQueryOrdering queryOrderingParam, TContext context);
    public virtual TReturn VisitQueryParameterPlatform(IQueryParameterPlatform queryParameterPlatformParam, TContext context);
    public virtual TReturn VisitQueryRangeVariableDeclaration(IQueryRangeVariableDeclaration queryRangeVariableDeclarationParam, TContext context);
    public virtual TReturn VisitQuerySelectClause(IQuerySelectClause querySelectClauseParam, TContext context);
    public virtual TReturn VisitQueryWhereClause(IQueryWhereClause queryWhereClauseParam, TContext context);
    public virtual TReturn VisitRangeExpression(IRangeExpression rangeExpressionParam, TContext context);
    public virtual TReturn VisitRankSpecifier(IRankSpecifier rankSpecifierParam, TContext context);
    public virtual TReturn VisitRecordDeclaration(IRecordDeclaration recordDeclarationParam, TContext context);
    public virtual TReturn VisitRecursivePattern(IRecursivePattern recursivePatternParam, TContext context);
    public virtual TReturn VisitRefExpression(IRefExpression refExpressionParam, TContext context);
    public virtual TReturn VisitReferenceExpression(IReferenceExpression referenceExpressionParam, TContext context);
    public virtual TReturn VisitReferenceName(IReferenceName referenceNameParam, TContext context);
    public virtual TReturn VisitReferenceTypeConstraint(IReferenceTypeConstraint referenceTypeConstraintParam, TContext context);
    public virtual TReturn VisitReftypeExpression(IReftypeExpression reftypeExpressionParam, TContext context);
    public virtual TReturn VisitRefvalueExpression(IRefvalueExpression refvalueExpressionParam, TContext context);
    public virtual TReturn VisitRelationalExpression(IRelationalExpression relationalExpressionParam, TContext context);
    public virtual TReturn VisitRelationalPattern(IRelationalPattern relationalPatternParam, TContext context);
    public virtual TReturn VisitResourceAcquisitionExpressionsList(IResourceAcquisitionExpressionsList resourceAcquisitionExpressionsListParam, TContext context);
    public virtual TReturn VisitReturnStatement(IReturnStatement returnStatementParam, TContext context);
    public virtual TReturn VisitScalarTypeUsage(IScalarTypeUsage scalarTypeUsageParam, TContext context);
    public virtual TReturn VisitShiftExpression(IShiftExpression shiftExpressionParam, TContext context);
    public virtual TReturn VisitSignOperatorDeclaration(ISignOperatorDeclaration signOperatorDeclarationParam, TContext context);
    public virtual TReturn VisitSingleVariableDesignation(ISingleVariableDesignation singleVariableDesignationParam, TContext context);
    public virtual TReturn VisitSlicePattern(ISlicePattern slicePatternParam, TContext context);
    public virtual TReturn VisitSpecificCatchClause(ISpecificCatchClause specificCatchClauseParam, TContext context);
    public virtual TReturn VisitSpreadElement(ISpreadElement spreadElementParam, TContext context);
    public virtual TReturn VisitStackAllocExpression(IStackAllocExpression stackAllocExpressionParam, TContext context);
    public virtual TReturn VisitStartRegion(IStartRegion startRegionParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [block] that directly implements statementsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitStatementsOwner(IStatementsOwner statementsOwnerParam, TContext context);
    public virtual TReturn VisitStructDeclaration(IStructDeclaration structDeclarationParam, TContext context);
    public virtual TReturn VisitSubpattern(ISubpattern subpatternParam, TContext context);
    public virtual TReturn VisitSuppressNullableWarningExpression(ISuppressNullableWarningExpression suppressNullableWarningExpressionParam, TContext context);
    public virtual TReturn VisitSwitchBlock(ISwitchBlock switchBlockParam, TContext context);
    public virtual TReturn VisitSwitchCaseLabel(ISwitchCaseLabel switchCaseLabelParam, TContext context);
    public virtual TReturn VisitSwitchExpression(ISwitchExpression switchExpressionParam, TContext context);
    public virtual TReturn VisitSwitchExpressionArm(ISwitchExpressionArm switchExpressionArmParam, TContext context);
    public virtual TReturn VisitSwitchSection(ISwitchSection switchSectionParam, TContext context);
    public virtual TReturn VisitSwitchStatement(ISwitchStatement switchStatementParam, TContext context);
    public virtual TReturn VisitThisExpression(IThisExpression thisExpressionParam, TContext context);
    public virtual TReturn VisitThrowExpression(IThrowExpression throwExpressionParam, TContext context);
    public virtual TReturn VisitThrowStatement(IThrowStatement throwStatementParam, TContext context);
    public virtual TReturn VisitTopLevelCode(ITopLevelCode topLevelCodeParam, TContext context);
    public virtual TReturn VisitTryStatement(ITryStatement tryStatementParam, TContext context);
    public virtual TReturn VisitTupleComponent(ITupleComponent tupleComponentParam, TContext context);
    public virtual TReturn VisitTupleComponentList(ITupleComponentList tupleComponentListParam, TContext context);
    public virtual TReturn VisitTupleExpression(ITupleExpression tupleExpressionParam, TContext context);
    public virtual TReturn VisitTupleTypeComponent(ITupleTypeComponent tupleTypeComponentParam, TContext context);
    public virtual TReturn VisitTupleTypeComponentList(ITupleTypeComponentList tupleTypeComponentListParam, TContext context);
    public virtual TReturn VisitTupleTypeUsage(ITupleTypeUsage tupleTypeUsageParam, TContext context);
    public virtual TReturn VisitTypeArgumentList(ITypeArgumentList typeArgumentListParam, TContext context);
    public virtual TReturn VisitTypeConstraint(ITypeConstraint typeConstraintParam, TContext context);
    public virtual TReturn VisitTypeMemberArglistParameterDeclaration(ITypeMemberArglistParameterDeclaration typeMemberArglistParameterDeclarationParam, TContext context);
    public virtual TReturn VisitTypeMemberRegularParameterDeclaration(ITypeMemberRegularParameterDeclaration typeMemberRegularParameterDeclarationParam, TContext context);
    public virtual TReturn VisitTypeParameterConstraint(ITypeParameterConstraint typeParameterConstraintParam, TContext context);
    public virtual TReturn VisitTypeParameterConstraintsClause(ITypeParameterConstraintsClause typeParameterConstraintsClauseParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [typeParameterOfMethodDeclaration, typeParameterOfTypeDeclaration] that directly implements typeParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitTypeParameterDeclaration(ITypeParameterDeclaration typeParameterDeclarationParam, TContext context);
    public virtual TReturn VisitTypeParameterOfLocalFunctionDeclaration(ITypeParameterOfLocalFunctionDeclaration typeParameterOfLocalFunctionDeclarationParam, TContext context);
    public virtual TReturn VisitTypeParameterOfLocalFunctionList(ITypeParameterOfLocalFunctionList typeParameterOfLocalFunctionListParam, TContext context);
    public virtual TReturn VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam, TContext context);
    public virtual TReturn VisitTypeParameterOfMethodList(ITypeParameterOfMethodList typeParameterOfMethodListParam, TContext context);
    public virtual TReturn VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam, TContext context);
    public virtual TReturn VisitTypeParameterOfTypeList(ITypeParameterOfTypeList typeParameterOfTypeListParam, TContext context);
    public virtual TReturn VisitTypeParameterReference(ITypeParameterReference typeParameterReferenceParam, TContext context);
    public virtual TReturn VisitTypePattern(ITypePattern typePatternParam, TContext context);
    public virtual TReturn VisitTypeUsage(ITypeUsage typeUsageParam, TContext context);
    public virtual TReturn VisitTypeofExpression(ITypeofExpression typeofExpressionParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [prefixOperatorExpression, unaryOperatorExpression] that directly implements unaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitUnaryExpression(IUnaryExpression unaryExpressionParam, TContext context);
    public virtual TReturn VisitUnaryOperatorExpression(IUnaryOperatorExpression unaryOperatorExpressionParam, TContext context);
    public virtual TReturn VisitUncheckedExpression(IUncheckedExpression uncheckedExpressionParam, TContext context);
    public virtual TReturn VisitUncheckedStatement(IUncheckedStatement uncheckedStatementParam, TContext context);
    public virtual TReturn VisitUndefDirective(IUndefDirective undefDirectiveParam, TContext context);
    public virtual TReturn VisitUnsafeCodeAddressOfExpression(IUnsafeCodeAddressOfExpression unsafeCodeAddressOfExpressionParam, TContext context);
    public virtual TReturn VisitUnsafeCodeFixedPointerDeclaration(IUnsafeCodeFixedPointerDeclaration unsafeCodeFixedPointerDeclarationParam, TContext context);
    public virtual TReturn VisitUnsafeCodeFixedPointerInitializer(IUnsafeCodeFixedPointerInitializer unsafeCodeFixedPointerInitializerParam, TContext context);
    public virtual TReturn VisitUnsafeCodeFixedStatement(IUnsafeCodeFixedStatement unsafeCodeFixedStatementParam, TContext context);
    public virtual TReturn VisitUnsafeCodePointer(IUnsafeCodePointer unsafeCodePointerParam, TContext context);
    public virtual TReturn VisitUnsafeCodePointerAccessExpression(IUnsafeCodePointerAccessExpression unsafeCodePointerAccessExpressionParam, TContext context);
    public virtual TReturn VisitUnsafeCodePointerIndirectionExpression(IUnsafeCodePointerIndirectionExpression unsafeCodePointerIndirectionExpressionParam, TContext context);
    public virtual TReturn VisitUnsafeCodeSizeOfExpression(IUnsafeCodeSizeOfExpression unsafeCodeSizeOfExpressionParam, TContext context);
    public virtual TReturn VisitUnsafeCodeUnsafeStatement(IUnsafeCodeUnsafeStatement unsafeCodeUnsafeStatementParam, TContext context);
    public virtual TReturn VisitUserTypeUsage(IUserTypeUsage userTypeUsageParam, TContext context);
    public virtual TReturn VisitUsingAliasDirective(IUsingAliasDirective usingAliasDirectiveParam, TContext context);
    public virtual TReturn VisitUsingDirective(IUsingDirective usingDirectiveParam, TContext context);
    public virtual TReturn VisitUsingList(IUsingList usingListParam, TContext context);
    public virtual TReturn VisitUsingStatement(IUsingStatement usingStatementParam, TContext context);
    public virtual TReturn VisitUsingSymbolDirective(IUsingSymbolDirective usingSymbolDirectiveParam, TContext context);
    public virtual TReturn VisitValueTypeConstraint(IValueTypeConstraint valueTypeConstraintParam, TContext context);
    public virtual TReturn VisitVarDeconstructionPattern(IVarDeconstructionPattern varDeconstructionPatternParam, TContext context);
    public virtual TReturn VisitVarPattern(IVarPattern varPatternParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [localRegularParameterDeclaration, propertyDeclaration, singleVariableDesignation] that directly implements variableDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitVariableDeclaration(IVariableDeclaration variableDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [singleVariableDesignation] that directly implements variableDesignation and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitVariableDesignation(IVariableDesignation variableDesignationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [arrayInitializer] that directly implements variableInitializer and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitVariableInitializer(IVariableInitializer variableInitializerParam, TContext context);
    public virtual TReturn VisitWarningAction(IWarningAction warningActionParam, TContext context);
    public virtual TReturn VisitWarningDirective(IWarningDirective warningDirectiveParam, TContext context);
    public virtual TReturn VisitWarningList(IWarningList warningListParam, TContext context);
    public virtual TReturn VisitWhileStatement(IWhileStatement whileStatementParam, TContext context);
    public virtual TReturn VisitWithExpression(IWithExpression withExpressionParam, TContext context);
    public virtual TReturn VisitWithInitializerAssignment(IWithInitializerAssignment withInitializerAssignmentParam, TContext context);
    public virtual TReturn VisitYieldStatement(IYieldStatement yieldStatementParam, TContext context);
    public virtual TReturn VisitInactivePreprocessorBranchNode(IInactivePreprocessorBranch inactivePreprocessorBranchNode, TContext context);
    public virtual TReturn VisitDocCommentBlockNode(IDocCommentBlock xmlDoc, TContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TryStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITryStatement GetByCatche(ICatchClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITryStatement GetByFinallyBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITryStatement GetByTry(IBlock param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleComponentExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static string GetInferredName(ITupleComponent tupleComponent, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static int IndexOf(ITupleComponent tupleComponent);
    [ExtensionAttribute]
[PureAttribute]
public static bool ActuallyHasInferredName(ITupleComponent tupleComponent);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleComponentListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleComponentList GetByComponent(ITupleComponent param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleComponentNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleComponent GetByValue(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleComponent GetByNameIdentifier(ICSharpIdentifier identifier);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLValueTupleExpression(ITupleExpression tupleExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFullyDiscardedDeconstruction(ITupleExpression tupleExpression);
    [ExtensionAttribute]
[PureAttribute]
public static TupleExpressionKind GetTupleExpressionKind(ITupleExpression tupleExpression);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ICSharpExpression FindFirstComponent(ITupleExpression tupleExpression, Predicate`1<ICSharpExpression> predicate, bool recursive);
    [ExtensionAttribute]
public static bool HasOnlyDeclarationsAndDiscards(ITupleExpression tupleExpression);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.TupleExpressionKind : Enum {
    public int value__;
    public static TupleExpressionKind Expression;
    public static TupleExpressionKind Declaration;
    public static TupleExpressionKind Mixed;
    public static TupleExpressionKind AllDiscards;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleExpression GetByComponent(ITupleComponent param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleExpression GetByComponentList(ITupleComponentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static ITupleExpression GetByComponentValue(ICSharpExpression tupleComponentValue);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static ITupleExpression GetRootByTupleComponent(ITupleComponent tupleComponent);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static ITupleExpression GetRootByTupleComponentValue(ICSharpExpression tupleComponentValue);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleTypeComponentListNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static ITupleTypeComponentList GetByComponent(ITupleTypeComponent component);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleTypeComponentNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleTypeComponent GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleTypeComponent GetByTypeUsage(ITypeUsage param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleTypeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static int IndexOfComponent(ITupleTypeUsage tupleTypeUsage, ITupleTypeComponent tupleTypeComponent);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TupleTypeUsageNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleTypeUsage GetByComponentList(ITupleTypeComponentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static ITupleTypeUsage GetByComponent(ITupleTypeComponent tupleTypeComponent);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeArgumentListNavigator : object {
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeArgumentList GetByTypeArgument(ITypeUsage typeArgument);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeArgumentList GetBySingleTypeArgument(ITypeUsage typeArgument);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeConstraintNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeConstraint GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeMemberArglistParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberArglistParameterDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberArglistParameterDeclaration GetByAttributeSectionList(IAttributeSectionList param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeMemberParameterDeclarationExtensions : object {
    [ExtensionAttribute]
public static void SetScope(ITypeMemberRegularParameterDeclaration declaration, ScopedKind scope, Nullable`1<bool> requiredUnscopedRefAttribute, IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
internal static void <SetScope>g__SetScopedKeyword|0_0(IParameter parameter, bool addScopedKeyword);
    [CompilerGeneratedAttribute]
internal static void <SetScope>g__RemoveUnscopedRefAttributes|0_1(IParameter parameter);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.TypeMemberParameterDeclarationExtensions/<<SetScope>g__GetParameterDeclarations|0_2>d")]
[CompilerGeneratedAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
internal static IEnumerable`1<ICSharpRegularParameterDeclaration> <SetScope>g__GetParameterDeclarations|0_2(IParameter parameter);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeMemberRegularParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberRegularParameterDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberRegularParameterDeclaration GetByAttributeSectionList(IAttributeSectionList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberRegularParameterDeclaration GetByDefaultValue(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberRegularParameterDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberRegularParameterDeclaration GetByParameterModifiersList(IParameterModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberRegularParameterDeclaration GetByTypeUsage(ITypeUsage param);
    [NullableContextAttribute("0")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberRegularParameterDeclaration GetByScalarTypeName(IReferenceName scalarTypeName);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeofExpressionExt : object {
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<bool> IsOpenType(ITypeofExpression typeofExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeofExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeofExpression GetByTypeName(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterConstraintNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterConstraintsClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterConstraintsClause GetByConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterConstraintsClause GetByTypeParameter(ITypeParameterReference param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static TreeNodeCollection`1<IAttribute> GetAttributes(ITypeParameterDeclaration declaration);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterDeclaration GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterOfLocalFunctionDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfLocalFunctionDeclaration GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterOfLocalFunctionListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfLocalFunctionList GetByTypeParameterDeclaration(ITypeParameterOfLocalFunctionDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterOfMethodDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfMethodDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfMethodDeclaration GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterOfMethodListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfMethodList GetByTypeParameterDeclaration(ITypeParameterOfMethodDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterOfTypeDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfTypeDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfTypeDeclaration GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterOfTypeListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfTypeList GetByTypeParameterDeclaration(ITypeParameterOfTypeDeclaration param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeParameterReferenceNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterReference GetByNameIdentifier(ICSharpIdentifier param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypePatternExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IRecursivePattern ReplaceWithRecursivePattern(ITypePattern typePattern);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypePatternNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypePattern GetByDesignation(IVariableDesignation param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypePattern GetByTypeUsage(ITypeUsage param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeUsageExtensions : object {
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsTopmostTypeUsage(ITypeUsage typeUsage, string message);
    [ExtensionAttribute]
[NotNullAttribute]
public static IArrayTypeUsage ReplaceWithArrayTypeUsage(ITypeUsage underlyingTypeUsage, Int32[] ranks);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITypeUsage ReplaceByUnderlyingElementType(INullableTypeUsage nullableTypeUsage);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITypeUsage ReplaceByElementType(IArrayTypeUsage arrayTypeUsage);
    [ExtensionAttribute]
[NotNullAttribute]
public static INullableTypeUsage ReplaceWithNullableTypeUsage(ITypeUsage underlyingTypeUsage);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPointerTypeUsage ReplaceWithPointerTypeUsage(ITypeUsage underlyingTypeUsage, int pointerMarksCount);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static ITypeUsage GetNonNullableTypeUsage(ITypeUsage typeUsage);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static ITypeUsage GetTopmostTypeUsage(ITypeUsage typeUsage);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IScalarTypeUsage GetScalarTypeUsage(ITypeUsage typeUsage);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeParsedAsAnExpression(ITypeUsage typeUsage);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static ITypeUsage <GetTopmostTypeUsage>g__GetNextTypeUsage|7_0(<>c__DisplayClass7_0& );
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.TypeUsageNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnaryExpressionNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnaryOperatorExpressionExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(IUnaryOperatorExpression unaryExpression, ICSharpExpression& operand);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnaryOperatorExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnaryOperatorExpression GetByOperand(IUnaryExpression param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.UnaryOperatorType : Enum {
    public int value__;
    public static UnaryOperatorType INVALID;
    public static UnaryOperatorType PLUS;
    public static UnaryOperatorType MINUS;
    public static UnaryOperatorType EXCL;
    public static UnaryOperatorType TILDE;
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UncheckedExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUncheckedExpression GetByOperand(ICSharpExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UncheckedStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUncheckedStatement GetByBody(IBlock param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UndefDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodeAddressOfExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeAddressOfExpression GetByOperand(IUnaryExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodeFixedPointerDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeFixedPointerDeclaration GetByInitial(IVariableInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeFixedPointerDeclaration GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IUnsafeCodeFixedPointerDeclaration> GetByTypeUsage(ITypeUsage param);
    [NullableContextAttribute("0")]
[PureAttribute]
[ItemCanBeNullAttribute]
public static TreeNodeCollection`1<IUnsafeCodeFixedPointerDeclaration> GetByScalarTypeName(IReferenceName scalarTypeName);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodeFixedPointerInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeFixedPointerInitializer GetByValue(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodeFixedStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeFixedStatement GetByBody(ICSharpStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeFixedStatement GetByPointerDeclaration(IUnsafeCodeFixedPointerDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeFixedStatement GetByTypeUsage(ITypeUsage param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodePointerAccessExpressionExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IType GetExtensionQualifierType(IUnsafeCodePointerAccessExpression expression);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IType GetExtensionQualifierType(IUnsafeCodePointerAccessExpression expression, IResolveContext resolveContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodePointerAccessExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodePointerAccessExpression GetByNameIdentifier(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodePointerAccessExpression GetByPointerExpression(IPrimaryExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodePointerAccessExpression GetByTypeArgumentList(ITypeArgumentList param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodePointerIndirectionExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodePointerIndirectionExpression GetByOperand(IUnaryExpression param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodePointerNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodeSizeOfExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeSizeOfExpression GetByOperand(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UnsafeCodeUnsafeStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnsafeCodeUnsafeStatement GetByBody(IBlock param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UserTypeUsageExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSimpleScalar(IUserTypeUsage typeUsage);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSimpleNameReference(IUserTypeUsage typeUsage);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSimpleNameReference(IUserTypeUsage typeUsage, string referenceName);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UserTypeUsageNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUserTypeUsage GetByScalarTypeName(IReferenceName param);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUserTypeUsage GetByTypeArgument(ITypeUsage typeArgument);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUserTypeUsage GetBySingleTypeArgument(ITypeUsage typeArgument);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UsingAliasDirectiveExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetNamespaceOrTypeShortName(IUsingAliasDirective usingAliasDirective);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UsingAliasDirectiveNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingAliasDirective GetByAlias(ICSharpIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingAliasDirective GetByNamespaceOrType(ITypeUsage param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.UsingDeclarationKind : Enum {
    public byte value__;
    public static UsingDeclarationKind Regular;
    public static UsingDeclarationKind Using;
    public static UsingDeclarationKind AwaitUsing;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UsingDirectiveExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetExternAliasName(IUsingDirective usingDirective, bool allowResolve);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <GetExternAliasName>g__GetExternAliasNoResolve|0_0(IReferenceName referenceName);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UsingDirectiveNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UsingListExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsParsedButEmpty(IUsingList usingList);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UsingListNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingList GetByExternAliase(IExternAliasDirective param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingList GetByImport(IUsingDirective param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UsingStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingStatement GetByBody(ICSharpStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingStatement GetByDeclaration(IMultipleLocalVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingStatement GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingStatement GetByExpressionsList(IResourceAcquisitionExpressionsList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingStatement GetByVariableDeclaration(ILocalVariableDeclaration param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.UsingSymbolDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingSymbolDirective GetByImportedSymbolName(IReferenceName param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.ValueTypeConstraintNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VarDeconstructionPatternExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("is IVarDeconstructionPattern is enough")]
public static bool IsDeconstructionPattern(IPattern pattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRecursivePattern ToRecursivePattern(IVarDeconstructionPattern varDeconstructionPattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRecursivePattern ReplaceByRecursivePattern(IVarDeconstructionPattern varDeconstructionPattern);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VarDeconstructionPatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVarDeconstructionPattern GetByDesignation(IParenthesizedVariableDesignation param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVarDeconstructionPattern GetByVariableDesignationRecursively(IVariableDesignation variableDesignation);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VariableDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVariableDeclaration GetByNameIdentifier(ICSharpIdentifier param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VariableDesignationContainerNavigator : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetSourceType(IVariableDesignationContainer container);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVariableDesignationContainer GetByVariableDesignation(IVariableDesignation variableDesignation);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Tree.VariableDesignationContainerNavigator/<GetAllSingleVariableDesignations>d__2")]
[ExtensionAttribute]
[PureAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<ISingleVariableDesignation> GetAllSingleVariableDesignations(IVariableDesignationContainer container);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VariableDesignationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsForeachDesignation(IVariableDesignation variableDesignation);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFullyDiscardedDesignation(IVariableDesignation variableDesignation);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNullOrDiscard(IVariableDesignation variableDesignation);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IType Type(ISingleVariableDesignation variableDesignation, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IType Type(IVariableDesignation variableDesignation, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
public static TVariableDesignation ReplaceBy(IVariableDesignation variableDesignation, TVariableDesignation newVariableDesignation);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPartOfPatternMatching(IVariableDesignation variableDesignation);
    [ExtensionAttribute]
[PureAttribute]
public static ResolveResultWithInfo ResolveSourceMemberOrParameter(IVariableDesignation variableDesignation);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDesignationSourceAnnotatedAsNotNull(IVariableDesignation variableDesignation);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<ISingleVariableDesignation> GetSingleVariableDesignations(IVariableDesignation variableDesignation);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VariableDesignationNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VariableInitializerNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VarPatternExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("is IVarPattern is enough")]
public static bool IsVariablePattern(IPattern pattern);
    [ExtensionAttribute]
[NotNullAttribute]
public static IRecursivePattern ReplaceWithRecursivePattern(IVarPattern varPattern);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.VarPatternNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVarPattern GetByDesignation(IVariableDesignation param);
    [ObsoleteAttribute("Use VarDeconstructionPatternNavigator", "True")]
public static IVarPattern GetByDesignation(IParenthesizedVariableDesignation param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.WarningActionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.WarningDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.WarningListNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.WhileStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWhileStatement GetByBody(ICSharpStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWhileStatement GetByCondition(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.WithExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWithExpression GetByInitializer(IWithInitializerAssignment param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWithExpression GetByOperand(ICSharpExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Tree.WithInitializerAssignmentNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWithInitializerAssignment GetByExpression(ICSharpExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWithInitializerAssignment GetByNameIdentifier(ICSharpIdentifier param);
}
public static class JetBrains.ReSharper.Psi.CSharp.Tree.YieldStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IYieldStatement GetByExpression(ICSharpExpression param);
}
public enum JetBrains.ReSharper.Psi.CSharp.Tree.YieldStatementType : Enum {
    public int value__;
    public static YieldStatementType UNKNOWN;
    public static YieldStatementType YIELD_RETURN;
    public static YieldStatementType YIELD_BREAK;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.TypeElementWithPrimaryConstructorExtensions : object {
    private static ObjectPool`1<PooledList`1<IParameter>> ourParameterListPool;
    private static TypeElementWithPrimaryConstructorExtensions();
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static bool IsCapturedPrimaryConstructorParameter(IParameter parameter);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static IReadOnlyCollection`1<IParameter> GetAllCapturedParameters(ITypeElement typeElement);
}
public static class JetBrains.ReSharper.Psi.CSharp.TypeParameterConstraintsUtil : object {
    [PureAttribute]
public static bool AreConstraintsEqual(ITypeParameter parameter1, ISubstitution substitution1, ITypeParameter parameter2, ISubstitution substitution2, PredefinedType predefinedType, bool checkNullability);
    [NotNullAttribute]
[PureAttribute]
private static IEnumerable`1<IType> GetAllConstraints(ITypeParameter typeParameter, ISubstitution substitution, HashSet`1<ITypeParameter> visited, IEqualityComparer`1<IType> typeEqualityComparer);
    [NotNullAttribute]
[PureAttribute]
private static HashSet`1<IType> CalculateEffectiveBaseTypes(ITypeParameter typeParameter, ISubstitution substitution, PredefinedType predefinedType, IEqualityComparer`1<IType> typeEqualityComparer, bool ignoreTopLevelNullability);
    [CompilerGeneratedAttribute]
internal static void <CalculateEffectiveBaseTypes>g__AddToEffectiveSet|2_0(IType type, <>c__DisplayClass2_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Types.AliasTypeDecoration : TypeDecoration {
    [CompilerGeneratedAttribute]
private ISymbolAlias <TypeAlias>k__BackingField;
    public ISymbolAlias TypeAlias { get; }
    public IType AliasedType { get; }
    public AliasTypeDecoration(ISymbolAlias typeAlias);
    [CompilerGeneratedAttribute]
public ISymbolAlias get_TypeAlias();
    public IType get_AliasedType();
    public virtual ITypeDecorationPointer CreatePointer();
    public virtual TypeDecoration TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual RichText PresentType(IType decoratedType, PsiLanguageType language, TypePresentationStyle style);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeDecoration other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Types.AliasTypeDecorationExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAliasedType(IType type, ISymbolAlias& typeAlias);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Types.AnonymousFunctionTypeUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IType InferredResultTypeWithAsync(IAnonymousFunctionType anonymousFunctionType, DeclaredElementInstance`1<IDelegate> delegate, CSharpLanguageLevel languageLevel);
    [ExtensionAttribute]
public static bool VerifyFunctionType(IAnonymousFunctionType anonymousFunctionType, IResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.CSharp.Types.CSharpFunctionTypeDecoration : TypeDecoration {
    public static CSharpFunctionTypeDecoration Instance;
    private static CSharpFunctionTypeDecoration();
    public virtual ITypeDecorationPointer CreatePointer();
    private sealed virtual override TypeDecoration JetBrains.ReSharper.Psi.ITypeDecorationPointer.Find();
    public virtual TypeDecoration OnDecorate(IType underlyingType);
    public virtual bool Equals(TypeDecoration other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Types.CSharpFunctionTypeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsCSharpFunctionType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IType UnwrapFromFunctionType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => canbenull")]
public static IType NullIfFunctionType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IExpressionType UnwrapFromFunctionType(IExpressionType expressionType);
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IAddressOfMethodGroupType {
    public abstract virtual bool ImplicitConversionExists(IFunctionPointerType functionPointerType);
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo Resolve(IFunctionPointerType functionPointerType);
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionType {
    public bool IsAsync { get; }
    [NotNullAttribute]
public IReadOnlyList`1<IParameter> Parameters { get; }
    [CanBeNullAttribute]
public IReadOnlyList`1<Pair`2<IType, ParameterKind>> ParameterTypesAndKinds { get; }
    public bool HasParametersList { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    [NotNullAttribute]
public ICollection`1<IExpressionType> ReturnValues { get; }
    [CanBeNullAttribute]
public ITreeNode VerificationScope { get; }
    [CanBeNullAttribute]
public IType ExplicitReturnType { get; }
    public ReferenceKind ExplicitReturnKind { get; }
    public abstract virtual bool get_IsAsync();
    public abstract virtual IReadOnlyList`1<IParameter> get_Parameters();
    public abstract virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> get_ParameterTypesAndKinds();
    public abstract virtual bool get_HasParametersList();
    public abstract virtual CSharpLanguageLevel get_LanguageLevel();
    public abstract virtual ICollection`1<IExpressionType> get_ReturnValues();
    [CanBeNullAttribute]
public abstract virtual IType InferredResultTypeWithoutAsync();
    [CanBeNullAttribute]
public abstract virtual IType InferredResultTypeWithoutAsync(bool allowFunctionTypes, Boolean& isRefReturn, ICollection`1& returnValues);
    public abstract virtual ITreeNode get_VerificationScope();
    [CanBeNullAttribute]
public abstract virtual IReadOnlyList`1<IParameter> GetImplicitLambdaParameters();
    public abstract virtual bool HasImplicitLambdaParameters();
    public abstract virtual IType get_ExplicitReturnType();
    public abstract virtual ReferenceKind get_ExplicitReturnKind();
    public abstract virtual bool IsReturnTypeConvertibleTo(IDelegate delegate, ISubstitution substitution);
    public abstract virtual bool IsSignatureConvertibleTo(IDelegate delegate, ISubstitution substitution);
    public abstract virtual bool VerifyFunctionType(IDelegate delegate, ISubstitution substitution);
    [NotNullAttribute]
public abstract virtual IAnonymousFunctionType CopyWithNewContext(IResolveContext newResolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousFunctionTypeImpl {
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IList`1<IExpressionType> GetReturnTypes(IResolveContext resolveContext, Boolean& isPossibleStatement, Boolean& isRefReturn);
    public abstract virtual bool CanHaveNaturalType();
    [CanBeNullAttribute]
public abstract virtual IType TryComputeNaturalTypeFromExplicitSignature();
    [CanBeNullAttribute]
public abstract virtual IType TryComputeImplicitNaturalType(ICollection`1<IExpressionType> returnTypes, bool hasRefReturn);
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IAnonymousMethodType {
    public bool HasReturnStatements { get; }
    public abstract virtual bool get_HasReturnStatements();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IAnyExpressionType {
    [NotNullAttribute]
public IPsiModule Module { get; }
    public abstract virtual IPsiModule get_Module();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.ICollectionExpressionType {
    public IReadOnlyList`1<IExpressionType> ElementTypes { get; }
    public ICollectionExpression CollectionExpression { get; }
    public abstract virtual IReadOnlyList`1<IExpressionType> get_ElementTypes();
    public abstract virtual ICollectionExpression get_CollectionExpression();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IConditionalExpressionType {
    [NotNullAttribute]
public IExpressionType ThenExpressionType { get; }
    [NotNullAttribute]
public IExpressionType ElseExpressionType { get; }
    public bool ConditionalConversionSupported { get; }
    public abstract virtual IExpressionType get_ThenExpressionType();
    public abstract virtual IExpressionType get_ElseExpressionType();
    public abstract virtual bool get_ConditionalConversionSupported();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.ICSharpConstantType {
    [NotNullAttribute]
public ConstantValue ConstantValue { get; }
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IType GetDefaultType();
    public abstract virtual ConstantValue get_ConstantValue();
    [PureAttribute]
public abstract virtual bool IsNullType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.ICSharpInterpolatedStringExpressionType {
    [PureAttribute]
public abstract virtual IType GetConvertedType(IResolveContext resolveContext);
    [PureAttribute]
public abstract virtual InterpolatedStringKind GetInterpolatedStringKind(IResolveContext resolveContext);
    [PureAttribute]
[NotNullAttribute]
public abstract virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IDefaultLiteralExpressionType {
    public bool HasNullableWarningsSuppression { get; }
    public abstract virtual bool get_HasNullableWarningsSuppression();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IInterpolatedStringConcatenationType {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetConvertedType(IResolveContext resolveContext);
    [PureAttribute]
public abstract virtual InterpolatedStringKind GetInterpolatedStringKind(IResolveContext resolveContext);
    [PureAttribute]
[NotNullAttribute]
public abstract virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.ILambdaExpressionType {
    public bool HasUnfinishedReturnExpression { get; }
    public abstract virtual bool get_HasUnfinishedReturnExpression();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IMethodGroupType {
    public string MethodShortName { get; }
    public CSharpLanguageLevel LanguageLevel { get; }
    public abstract virtual string get_MethodShortName();
    public abstract virtual CSharpLanguageLevel get_LanguageLevel();
    public abstract virtual bool IsApplicableTo(IDelegate delegate, ISubstitution substitution);
    [NotNullAttribute]
public abstract virtual ISymbolTable GetMethodsSymbolTable();
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo Resolve(IList`1<ICSharpArgumentInfo> arguments);
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo Resolve(IDelegate delegate, ISubstitution substitution);
    public abstract virtual bool ImplicitConversionExists(IDelegate delegate, ISubstitution substitution);
    [NotNullAttribute]
public abstract virtual IAddressOfMethodGroupType TakeAddressOf();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IStackAllocExpressionType {
    [CanBeNullAttribute]
public abstract virtual IPointerType ToPointerType();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.ISwitchExpressionType {
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IExpressionType> ArmsExpressionTypes { get; }
    public abstract virtual IReadOnlyList`1<IExpressionType> get_ArmsExpressionTypes();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.ITargetTypedObjectCreationExpressionType {
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IExpressionType> ArgumentExpressionTypes { get; }
    public abstract virtual IReadOnlyList`1<IExpressionType> get_ArgumentExpressionTypes();
}
public interface JetBrains.ReSharper.Psi.CSharp.Types.IThrowExpressionType {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Types.MethodGroupTypeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsApplicableTo(IMethodGroupType methodGroupType, DeclaredElementInstance`1<IDelegate> delegateInstance);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IMethod> ChooseSingleMethod(IMethodGroupType methodGroupType, IDelegate delegate, ISubstitution substitution);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.AliasUtil : object {
    public static IReadOnlyList`1<string> GetPossibleAliasesForElement(IClrDeclaredElement declaredElement, string name);
    public static IReadOnlyList`1<string> GetPossibleAliasesForElement(IClrDeclaredElement declaredElement);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static bool <GetPossibleAliasesForElement>g__MayHaveAttributeAlias|0_0(IDeclaredElement declaredElement, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.ApiInformationTypeMemberReference : CheckedReferenceBase`1<ICSharpLiteralExpression> {
    private ISymbolFilter myFilter;
    internal ApiInformationTypeMemberReference(ICSharpLiteralExpression literal, DeclaredElementType expectedDeclaredElementType);
    public virtual string GetName();
    public virtual TreeTextRange GetTreeTextRange();
    [NullableContextAttribute("2")]
private ITypeElement GetTypeFromTypeNameArgument();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public sealed virtual ISymbolTable GetCompletionSymbolTable();
    public virtual ISymbolFilter[] GetSymbolFilters();
    public virtual IAccessContext GetAccessContext();
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IReference BindTo(IDeclaredElement element);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ArgumentModificationUtil : object {
    public static ICSharpArgument AddParameter(ICSharpArgumentsOwner argumentsOwner, IResolveResult argumentsOwnerReference, IParameter parameter, ICSharpExpression value);
    public static ICSharpArgument RemoveParameter(ICSharpArgumentsOwner argumentsOwner, IParameter parameter);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.ArgumentsUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static IList`1<ITokenNode> GetCommas(ICSharpArgument argument);
    [PureAttribute]
public static int GetArgumentNumber(ICSharpArgumentsOwner argumentsOwner, TreeOffset treeOffset);
    [NotNullAttribute]
[PureAttribute]
public static IType GetParameterType(ICSharpArgumentInfo argumentInfo, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IType GetParameterType(ICSharpArgumentInfo argumentInfo, IResolveContext resolveContext, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IType GetParameterType(ICSharpArgumentInfo argumentInfo, IExpressionType argumentType, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IType GetParameterMultitype(ICSharpArgumentInfo argumentInfo, IResolveContext resolveContext, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IType GetParameterType(ICSharpArgumentInfo argumentInfo, IExpressionType argumentType, IResolveContext resolveContext, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IType GetParameterMultitype(ICSharpArgumentInfo argumentInfo, IExpressionType argumentType, IResolveContext resolveContext, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IType GetParameterType(CSharpParameterInstance parameterInstance, IExpressionType argumentType, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
public static CSharpParameterInstance GetParameter(ICSharpArgumentInfo argumentInfo);
    [CanBeNullAttribute]
[PureAttribute]
public static CSharpParameterInstance GetParameter(IResolveContext resolveContext, ICSharpArgumentInfo argumentInfo);
    [CanBeNullAttribute]
[PureAttribute]
private static CSharpParameterInstance GetParameterImpl(IResolveContext resolveContext, ICSharpArgumentInfo argumentInfo);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<CSharpParameterInstance> GetPossibleParameters(ICSharpArgumentInfo argumentInfo);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExpanded(ArgumentMatch match, ISubstitution parameterSubstitution, IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<CSharpParameterInstance> GetPossibleParameters(IResolveContext resolveContext, ICSharpArgumentInfo argumentInfo);
    [CanBeNullAttribute]
private static CSharpParameterInstance GetPossibleParameter(ICSharpArgumentInfo argumentInfo, IList`1<IParameter> parameters, ISubstitution substitution);
    [CanBeNullAttribute]
[PureAttribute]
public static CSharpParameterInstance GetPossibleParameter(ICSharpArgumentInfo argument, int argumentIndex, int argumentsCount, IList`1<IParameter> parameters, ISubstitution substitution);
    [CanBeNullAttribute]
[PureAttribute]
public static CSharpParameterInstance GetParameter(ICSharpArgumentInfo argumentInfo, IList`1<IParameter> parameters, ISubstitution substitution, bool isExtensionMethod, bool isEventSubscription);
    [NotNullAttribute]
[ObsoleteAttribute]
private static IList`1<T> Shift(IList`1<T> list, int count);
    [NotNullAttribute]
private static IEnumerable`1<ExtensionInstance`1<IParametersOwner>> GetParametersOwners(IResolveContext resolveContext, IResolveResult resolveResult);
    public static bool CheckParametersCount(IList`1<ICSharpArgumentInfo> arguments, IParametersOwner parametersOwner);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.ArgumentsUtil/<Match>d__21")]
[ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<ArgumentMatch> Match(IList`1<ICSharpArgumentInfo> arguments, IList`1<IParameter> parameters, bool treatAsExpandedIfPossible);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<ArgumentMatch> MatchNonStrict(IList`1<ICSharpArgumentInfo> arguments, IList`1<IParameter> parameters);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IList`1<ArgumentMatch> MatchStrict(IList`1<ICSharpArgumentInfo> arguments, IList`1<IParameter> parameters, CSharpLanguageLevel languageLevel);
    public static bool MatchKind(ParameterKind argumentKind, IParameter parameter, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    public static bool MatchKind(ArgumentMatch match, CSharpLanguageLevel languageLevel, CSharpLanguageLevel latestSupportedLanguageLevel);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpArgumentInfo GetExtensionQualifierByValue(ICSharpExpression expression, IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<ICSharpArgumentInfo> GetMatchingArguments(IParametersOwner parametersOwner, ICSharpInvocationInfo invocation, IResolveContext resolveContext);
    [CanBeNullAttribute]
public static ICSharpExpression GetInnerArgumentValueExpression(ICSharpArgument argument);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.AsCheckStaticAnalysisResultExtensions : object {
    [ExtensionAttribute]
public static bool IsCompilerError(AsExpressionStaticAnalysisResult analysisResult);
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.AsExpressionStaticAnalysisResult : Enum {
    public int value__;
    public static AsExpressionStaticAnalysisResult Unknown;
    public static AsExpressionStaticAnalysisResult AlwaysSuccessful;
    public static AsExpressionStaticAnalysisResult CompilerWarningAlwaysNull;
    public static AsExpressionStaticAnalysisResult CompilerErrorNoExplicitBuiltinConversion;
    public static AsExpressionStaticAnalysisResult CompilerErrorAsWithTypeParameter;
    public static AsExpressionStaticAnalysisResult CompilerErrorAsWithPointer;
    public static AsExpressionStaticAnalysisResult CompilerErrorAsMustHaveReferenceType;
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.AsExpressionUtil : object {
    public static AsExpressionStaticAnalysisResult CompileTimeResult(IExpressionType innerType, IType castType, ITreeNode context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.BooleanCheckUtil : object {
    [PureAttribute]
[ContractAnnotationAttribute("condition:null => comparedExpression:null")]
public static Kind GetConditionKind(ICSharpExpression condition, ICSharpExpression& comparedExpression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static bool TryGetStatementExecutedAfterLastExpressionInCondition(IIfStatement ifStatement, bool targetValueOfLastExpression, ICSharpExpression& lastExpression, ICSharpExpression& conditionPart, ICSharpStatement& statement, Boolean& isThenBranch);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static bool TryGetExpressionExecutedAfterLastExpressionInCondition(IConditionalTernaryExpression conditionalTernaryExpression, bool targetValueOfLastExpression, ICSharpExpression& lastExpression, ICSharpExpression& conditionPart, ICSharpExpression& statement, Boolean& isThenBranch);
    [NullableContextAttribute("2")]
private static Nullable`1<bool> TryGetTargetBranch(TokenNodeType polyadicSignToken, ICSharpExpression condition, bool targetValueOfLastExpression, ICSharpExpression& lastExpression, ICSharpExpression& conditionPart);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static ICSharpStatement <TryGetStatementExecutedAfterLastExpressionInCondition>g__GetEffectiveElseBranch|2_0(<>c__DisplayClass2_0& );
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CallingConventionsUtil : object {
    [NotNullAttribute]
private static Key`1<ICollection`1<string>> CALLING_CONVENTIONS;
    private static CallingConventionsUtil();
    [NotNullAttribute]
[PureAttribute]
public static ICollection`1<string> GetAvailable(IPsiModule psiModule);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CancellationTypeUtil : object {
    [NotNullAttribute]
private static IClrTypeName ourLifetimeTypeName;
    private static CancellationTypeUtil();
    [PureAttribute]
public static CancellationTypeChecker CreateCancellationTypeChecker(PredefinedType predefinedType);
    [PureAttribute]
public static Kind GetCancellationTypeKind(IType type, ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CharacterLiteralUtil : object {
    [PureAttribute]
public static int GetRegularCharacterPresentationLength(string presentation, int index);
    [PureAttribute]
public static int GetRegularCharacterCompiledValueLength(string presentation, int index);
    [MustUseReturnValueAttribute]
public static bool TryConvertRegularCharacterPresentationToValue(string presentation, int index, int characterLength, StringBuilder valueBuilder, CSharpLanguageLevel languageLevel);
    [MustUseReturnValueAttribute]
public static bool TryConvertCharacterPresentationInRegularStringLiteralToValue(string presentation, int index, int characterLength, StringBuilder valueBuilder, CSharpLanguageLevel languageLevel);
    public static void ConvertValueToCharacterPresentation(char value, StringVerbatimity presentationForm, StringBuilder presentationBuilder, CSharpLanguageLevel languageLevel);
    public static void ConvertValueToVerbatimCharacterPresentation(char value, StringBuilder presentationBuilder);
    public static void ConvertValueToRegularCharacterPresentation(char value, StringBuilder presentationBuilder, CSharpLanguageLevel languageLevel);
    public static bool TryEscapeChar(char value, CSharpLanguageLevel languageLevel, String& escapedChar);
    public static bool TryUnescapeChar(char escapeKeyChar, CSharpLanguageLevel languageLevel, String& unescapedChar);
}
internal enum JetBrains.ReSharper.Psi.CSharp.Util.CodeRegionPosition : Enum {
    public int value__;
    public static CodeRegionPosition BeforeContextNode;
    public static CodeRegionPosition AlongsideContextNode;
    public static CodeRegionPosition AfterContextNode;
}
public class JetBrains.ReSharper.Psi.CSharp.Util.CollectionExpressionPresenceChecker : TargetTypedExpressionPresenceChecker {
    public static CollectionExpressionPresenceChecker Instance;
    private static CollectionExpressionPresenceChecker();
    protected virtual bool IsRequiredExpression(ITreeNode node, ICSharpExpression& expression);
    protected virtual bool CheckClosedChameleonNode(ILexer lexer, Boolean& evidentOnly);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.CommentsBag : object {
    [NotNullAttribute]
public static CommentsBag Empty;
    public bool IsEmpty { get; }
    private static CommentsBag();
    [PureAttribute]
public static CommentsBag FromRange(ITreeRange treeRange, bool before);
    [PureAttribute]
public static CommentsBag FromList(IReadOnlyList`1<ICommentNode> comments);
    [NotNullAttribute]
[PureAttribute]
public CommentsBag AndBefore(ITreeNode node);
    [NotNullAttribute]
[PureAttribute]
public CommentsBag AndAfter(ITreeNode node);
    public virtual bool get_IsEmpty();
    public void TransferTo(ITreeNode anchor);
    public void TransferBefore(ITreeNode anchor);
    public void TransferAfter(ITreeNode anchor);
    public void TransferAfterNextTokenIfPossible(ITreeNode anchor, TokenNodeType tokenType);
    private void TransferTo(ITreeNode anchor, Nullable`1<bool> before);
    protected abstract virtual void TransferToImpl(ITreeNode anchor, Nullable`1<bool> before);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CommentsUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsComments(ITreeRange range);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsComments(ITreeNode node, ITreeNode nodeToSkip);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasCommentSiblingsAround(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasCommentSiblingsBefore(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasCommentSiblingsAfter(ITreeNode node);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static CommentsBag GetAndDeleteCommentSiblingsBeforeStatement(IStatement anchor);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static CommentsBag GetAndDeleteCommentSiblingsBefore(ITreeNode anchor, StopAt stopAt);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static CommentsBag GetAndDeleteCommentSiblingsAfter(ITreeNode anchor, StopAt stopAt);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static CommentsBag GetAndDeleteCommentSiblingsAfterNextToken(ITreeNode anchor, TokenNodeType tokenType);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static CommentsBag GetAndDeleteCommentSiblingsAround(ITreeNode anchor, StopAt stopAt);
    [NotNullAttribute]
public static ITreeRange GetCommentSiblingsRangeBeforeStatement(IStatement anchor);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static CommentsBag GetAndDeleteCommentsFromLinesAbove(ITreeNode anchor);
    [NotNullAttribute]
public static ITreeRange GetCommentSiblingsRangeBefore(ITreeNode anchor, StopAt stopAt);
    [NotNullAttribute]
public static ITreeRange GetCommentSiblingsRangeAfter(ITreeNode anchor, StopAt stopAt);
    [NotNullAttribute]
private static ITreeRange GetCommentSiblingsRange(ITreeNode anchor, bool before, StopAt stopAt);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private static CommentsBag GetAndDeleteCommentSiblings(ITreeNode anchor, bool before, StopAt stopAt);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static CommentsBag GetAndDeleteAllDescendantCommentsIn(ITreeNode anchor, Func`2<ITreeNode, bool> interiorShouldBeProcessed);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
internal static TreeRange <GetAndDeleteCommentsFromLinesAbove>g__GetCommentsFromLinesAboveRange|11_0(ITreeNode anchor);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ConditionalDirectives.ConditionalDirectiveUtil : object {
    private static PreprocessorDirectiveKind[] ourConditionalBranches;
    private static ConditionalDirectiveUtil();
    public static ITreeNode GetBlockEnd(IPreprocessorDirective directive, PreprocessorDirectiveKind nexDirectiveType);
    public static DocumentOffset GetBodyOffset(IPreprocessorDirective directive);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ConditionalTernaryExpressionUtil : object {
    public static DerivedType DeriveType(IExpressionType thenExpressionType, IExpressionType elseExpressionType, ICSharpTypeConversionRule conversionRule, ITreeNode context);
    [PureAttribute]
private static DerivedType DeriveFromNullConversion(ICSharpConstantType nullExpressionType, IExpressionType elseExpressionType, ICSharpTypeConversionRule conversionRule);
    private static DerivedType DeriveIType(IType thenType, IType elseType, ICSharpTypeConversionRule conversionRule, ITreeNode context);
    private static Nullable`1<DerivedType> NormalizeType(IType thenType, IType elseType, ITreeNode context, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
private static DerivedType ChooseResultType(IExpressionType thenExpressionType, IExpressionType elseExpressionType, IType thenIType, IType elseIType, ICSharpTypeConversionRule conversionRule);
    [CanBeNullAttribute]
[PureAttribute]
private static IType CreateCandidateType(IExpressionType left, IExpressionType right);
    [CompilerGeneratedAttribute]
internal static bool <ChooseResultType>g__IsConvertible|6_0(IExpressionType source, IType target, <>c__DisplayClass6_0& );
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.ConfigureAwaitType : Enum {
    public int value__;
    public static ConfigureAwaitType CaptureContext;
    public static ConfigureAwaitType DoNotCaptureContext;
    public static ConfigureAwaitType OnlyContextCapturingConfiguration;
    public static ConfigureAwaitType Any;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.ConfigureAwaitUtil : object {
    private static string TaskAsyncEnumerableExtensionsFqn;
    private static string ConfiguredCancelableAsyncEnumerableFqn;
    [PureAttribute]
private static ResolveResultWithInfo TryToResolveExpressionReference(ICSharpExpression expression);
    private static Nullable`1<bool> AnnotatedWithCanBeNull(ICSharpExpression expression);
    private static Nullable`1<bool> ExpressionDefinitelyCanBeNull(ICSharpExpression expression);
    [PureAttribute]
private static bool EqualsOrDescendantOf(ITypeElement sourceTypeElement, IDeclaredType declaredType);
    private static bool IsConfiguredCancelableAsyncEnumerable(IPsiModule module, ITypeElement sourceTypeElement);
    private static IMethod GetConfigureAwaitExtensionMethod(ICSharpExpression expression, IDeclaredType thisType);
    [PureAttribute]
private static bool IsInstanceConfigureAwaitMethod(IMethod method);
    [PureAttribute]
private static bool IsExtensionConfigureAwaitMethod(IMethod method, ITypeElement thisTypeElement);
    [PureAttribute]
private static bool CanHaveInstanceConfigureAwaitMethod(IPsiModule module, ITypeElement sourceTypeElement);
    [PureAttribute]
private static bool CanHaveExtensionConfigureAwaitMethod(IPsiModule module, ITypeElement sourceTypeElement);
    [PureAttribute]
private static bool BaseTypeCanHaveInstanceConfigureAwaitMethod(IPsiModule module, ITypeElement sourceTypeElement);
    [PureAttribute]
private static bool BaseTypeCanHaveExtensionConfigureAwaitMethod(IPsiModule module, ITypeElement sourceTypeElement);
    [PureAttribute]
private static bool IsPredefinedConfigureAwaitTypeElement(IPsiModule module, ITypeElement sourceTypeElement);
    [PureAttribute]
private static bool IsDescendantOfPredefinedConfigureAwaitTypeElement(IPsiModule module, ITypeElement sourceTypeElement);
    [PureAttribute]
private static bool CanUseConfigureAwaitForTypeElement(IPsiModule module, ITypeElement sourceTypeElement);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInvocationExpression GetContainingConfigureAwaitInvocation(ICSharpExpression expression);
    [PureAttribute]
private static bool IsConfigureAwaitInvocation(IInvocationExpression invocationExpression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ICSharpExpression TryGetContainingConfigureAwaitInvocation(ICSharpExpression expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ICSharpExpression GetOperandThroughMatchingConfigureAwait(ICSharpExpression expression, ConfigureAwaitType configureAwaitType);
    [NullableContextAttribute("2")]
[PureAttribute]
public static IInvocationExpression TryGetConfigureAwaitInvocationExpression(ICSharpExpression taskExpression, ConfigureAwaitType configureAwaitType);
    [PureAttribute]
private static bool IsMatchingConfigureAwaitInvocation(IInvocationExpression invocationExpression, ConfigureAwaitType configureAwaitType);
    [PureAttribute]
public static IMethod GetConfigureAwaitMethod(ICSharpTreeNode awaitOwner, ICSharpExpression taskExpression);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool IsConfigureAwaitMethod(IMethod method);
    [PureAttribute]
public static bool CanUseConfigureAwaitForExpression(IAwaitReferencesOwner awaitOwner, ICSharpExpression expression);
    [PureAttribute]
public static bool IsAsyncDisposableAwaitExpression(IAwaitReferencesOwner awaitOwner, ICSharpExpression expression);
    public static IList`1<ICSharpExpression> GetAwaitedExpressionsWithMissingConfigureAwait(IAwaitReferencesOwner awaitOwner);
    public static IList`1<ICSharpExpression> GetAwaitedExpressions(IAwaitReferencesOwner awaitOwner);
    [NullableContextAttribute("2")]
public static IAwaitExpression TryUnwrapFromConfigureAwaitAndAwaitExpressionSyntactically(ICSharpExpression expression);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ICSharpExpression TryUnwrapFromConfigureAwait(ICSharpExpression taskExpression, ConfigureAwaitType configureAwaitType);
    [CompilerGeneratedAttribute]
internal static bool <IsMatchingConfigureAwaitInvocation>g__IsParameterConstantBool|22_0(bool targetValue, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
internal static IList`1<ICSharpExpression> <GetAwaitedExpressions>g__GetInitializerExpressions|28_0(IMultipleLocalVariableDeclaration declaration);
    [CompilerGeneratedAttribute]
internal static IList`1<ICSharpExpression> <GetAwaitedExpressions>g__GetExpressionsList|28_1(IUsingStatement usingStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Util.ConfiguredCancelableUtil : object {
    [PureAttribute]
public static IMethod GetWithCancellationMethod(ICSharpExpression whichCancellationReceiver);
    public static WithCancellationReceiverKind GetWithCancellationReceiverKind(ICSharpExpression receiver);
    public static IMethod GetAsyncEnumerableWithCancellationMethod(ITreeNode context);
    public static IMethod GetConfiguredCancellableAsyncEnumerableWithCancellationMethod(ITreeNode context);
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.ConstantContextKind : Enum {
    public int value__;
    public static ConstantContextKind NotStatic;
    public static ConstantContextKind ConstantExpression;
    public static ConstantContextKind Pattern;
    public static ConstantContextKind Attribute;
    public static ConstantContextKind ParameterDefaultValue;
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.ConstraintContextualKeywordKind : Enum {
    public int value__;
    public static ConstraintContextualKeywordKind None;
    public static ConstraintContextualKeywordKind Unmanaged;
    public static ConstraintContextualKeywordKind NotNull;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.ConstraintsUtil : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsTypeKindConstraint(ITypeParameterConstraint constraint);
    public static void RemoveConstraint(ITypeParameterConstraint constraint);
    public static void RemoveConstraint(ITypeParameterConstraintsClause clause, ITypeParameterConstraint constraint);
    public static IEnumerable`1<ITypeParameterConstraint> AddConstructorConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddValueConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddClassConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddUnmanagedConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddDefaultConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddNotNullConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddAllowsRefStructConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddTypeConstraint(ITypeParameter typeParameter, IType type);
    private static IEnumerable`1<ITypeParameterConstraint> AddConstraint(string constraintText, ITypeParameter typeParameter, Action`1<ITypeParameterConstraint> onTempConstraintCreated);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.ConstraintsUtil/<GetClauses>d__12")]
public static IEnumerable`1<ITypeParameterConstraintsClause> GetClauses(ITypeParameter typeParameter);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.ConstraintsUtil/<GetAllClauses>d__13")]
public static IEnumerable`1<ValueTuple`2<IEnumerable`1<ITypeParameterConstraintsClause>, ISubstitution>> GetAllClauses(ITypeParameter typeParameter);
    [CanBeNullAttribute]
[PureAttribute]
public static ITypeParameter GetTypeParameter(ITypeParameterConstraintsClause clause);
    public static bool AreEqual(ITypeParameterConstraint constraint1, ISubstitution substitution1, ITypeParameterConstraint constraint2, ISubstitution substitution2);
    public static bool AreEqual(ITypeParameterConstraint constraint1, ITypeParameterConstraint constraint2);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameter FindSuperTypeParameter(ITypeParameter typeParameter);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ContextualKeywordUtil : object {
    private static HashSet`1<string> ourAccessors;
    private static HashSet`1<string> ourAttributeTargets;
    private static string ValueKeyword;
    private static string GlobalKeyword;
    private static string NameofKeyword;
    private static string UnmanagedKeyword;
    private static string FieldKeyword;
    private static HashSet`1<string> ourIdentifierContextualKeywords;
    private static string DotToken;
    private static string ColonToken;
    private static string DoubleColonToken;
    private static ContextualKeywordUtil();
    public static bool ShouldBeHighlightedAsKeyword(CSharpTokenBase token, bool highlightAccessors);
    private static bool DotOnTheLeft(ITreeNode element);
    private static bool DoubleColonOnTheRight(ITreeNode element);
    private static bool ColonOnTheRight(ITreeNode element);
    private static bool InsideAccessor(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpArgumentsOwnerInvocationClrWrapper : object {
    [NotNullAttribute]
private ICSharpArgumentsOwner myArgumentsOwner;
    [CanBeNullAttribute]
protected IReadOnlyList`1<IExpression> myArguments;
    public IParametersOwner InvokedFunction { get; }
    public IReadOnlyList`1<IParametersOwner> InvokedFunctionCandidates { get; }
    public IArgumentsOwner ArgumentsOwner { get; }
    public IReadOnlyList`1<IExpression> Arguments { get; }
    public bool ArgumentsByValueAndPositional { get; }
    public CSharpArgumentsOwnerInvocationClrWrapper(ICSharpArgumentsOwner argumentsOwner);
    public sealed virtual IParametersOwner get_InvokedFunction();
    public sealed virtual IReadOnlyList`1<IParametersOwner> get_InvokedFunctionCandidates();
    public sealed virtual IArgumentsOwner get_ArgumentsOwner();
    public virtual IReadOnlyList`1<IExpression> get_Arguments();
    public sealed virtual bool get_ArgumentsByValueAndPositional();
    public virtual void AddArgument(IExpression newArgumentExpression, int newArgumentIndex);
    public virtual void ChangeInvokedMethod(IMethod newFunction);
    public virtual void RemoveArgumentAt(int argumentToDeleteIndex);
    public virtual void SetArgumentAt(int currentItemIndex, IExpression argumentExpression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpAsyncUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeAsync(ICSharpDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAsync(ICSharpDeclaration declaration);
    [ExtensionAttribute]
public static void SetAsync(ICSharpDeclaration declaration, bool isAsync);
    [CanBeNullAttribute]
public static ITokenNode GetAsyncKeyword(ICSharpDeclaration declaration);
    [ExtensionAttribute]
public static void EnsureAsyncModifierAndTaskReturnType(ICSharpDeclaration returnOwnerDeclaration);
    private static void EnsureTaskReturnType(IParametersOwnerDeclaration declaration);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpAttributeUtil : object {
    public static void JoinAttributes(IEnumerable`1<IAttributeSection> attributeSections);
    public static void SplitAttributes(IEnumerable`1<IAttribute> attributesToRemove);
    [NotNullAttribute]
[PureAttribute]
private static OneToListMap`2<string, IAttributeSection> BuildAttributeSectionGroup(IEnumerable`1<IAttributeSection> sections);
    [ExtensionAttribute]
[PureAttribute]
public static bool Is(IAttribute attribute, IClrTypeName expectedAttributeClrTypeName);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpCodeBody : ValueType {
    [CanBeNullAttribute]
private ICSharpTreeNode myBlockOrExpression;
    public static CSharpCodeBody Empty;
    [CanBeNullAttribute]
public IBlock BlockBody { get; }
    [CanBeNullAttribute]
public ICSharpExpression ExpressionBody { get; }
    public bool IsEmpty { get; }
    public CSharpCodeBody(IBlock blockBody);
    public CSharpCodeBody(ICSharpExpression expression);
    private static CSharpCodeBody();
    public IBlock get_BlockBody();
    public ICSharpExpression get_ExpressionBody();
    public bool get_IsEmpty();
    [PureAttribute]
[CanBeNullAttribute]
public ICSharpTreeNode GetAnyTreeNode();
    [PureAttribute]
public bool IsFinished();
}
internal static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpCodeRegionUtil : object {
    [CanBeNullAttribute]
public static ITreeNode FindLastPreprocessorNode(ICodeRegion region);
    public static ITreeNode FindFirstPreprocessorNode(ICodeRegion region);
    public static bool IsPreprocessorRegion(ICodeRegion region);
    public static bool IsConditionalPreprocessorRegion(ICodeRegion region);
    public static bool IsReSharperControlConstructRegion(ICodeRegion region);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpCodeStyleUtil : object {
    public static void ApplyReturnValueCodeStyles(CSharpCodeBody body);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.CSharpCollectionTypeHelper : object {
    public sealed virtual IType ElementTypeByCollectionType(IType type, IAccessContext accessContext, ITreeNode context, bool isAsyncContext);
    public sealed virtual DeclaredElementInstance`1<IMethod> GetEnumeratorMethod(IType type, IAccessContext accessContext, ITreeNode context, bool isAsyncContext);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpCollectionTypeUtil : object {
    public static bool CanInitializeWithCollectionInitializer(IType type, ITreeNode context, Boolean& needSupportForRefStructInterfaces);
    [CanBeNullAttribute]
[PureAttribute]
public static IType ElementTypeByCollectionType(IType type, IAccessContext accessContext, ITreeNode context, bool isAsyncContext);
    [CanBeNullAttribute]
[PureAttribute]
public static IType GetConvertedCollectionType(IType type, ITreeNode context, bool isAsyncContext);
    [PureAttribute]
private static CollectionTypeInfo CalculateCollectionTypeInfo(IType type, IAccessContext accessContext, ITreeNode context, bool isAsyncContext);
    [PureAttribute]
public static CollectionExpressionTargetTypeInfo GetCollectionExpressionTargetTypeInfo(IType type, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IMethod> GetEnumeratorMethod(bool isAsyncEnumerator, IType type, IAccessContext accessContext, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
private static DeclaredElementInstance`1<IMethod> GetInstanceGetEnumeratorMethod(bool isAsyncEnumerator, IType type, IAccessContext accessContext, ITreeNode context, IList`1& candidates);
    [NotNullAttribute]
[PureAttribute]
public static ResolveResultWithInfo ResolveEnumeratorMethod(bool isAsyncEnumerator, IType type, IAccessContext accessContext, ITreeNode context);
    public static bool GetCurrentAndMoveNextMethods(bool isAsyncEnumerator, DeclaredElementInstance`1<IMethod> getEnumeratorMethod, IAccessContext currentAccessContext, ITreeNode context, DeclaredElementInstance`1& currentProperty, DeclaredElementInstance`1& moveNextMethod);
    private static bool GetEnumeratorMembers(bool isAsyncEnumerator, DeclaredElementInstance`1<IMethod> getEnumeratorMethod, IAccessContext currentAccessContext, ITreeNode context, DeclaredElementInstance`1& currentProperty, DeclaredElementInstance`1& moveNextMethod);
    [CanBeNullAttribute]
[PureAttribute]
private static DeclaredElementInstance`1<IMethod> GetEnumeratorMethodByCollectionType(bool isAsyncEnumerator, IType collectionType, IAccessContext accessContext);
    [NotNullAttribute]
[PureAttribute]
private static ResolveResultWithInfo TryResolveExtensionGetEnumeratorMethodByCollectionType(bool isAsyncEnumerator, IType collectionType, IAccessContext accessContext, ITreeNode context);
    [CompilerGeneratedAttribute]
internal static IType <CalculateCollectionTypeInfo>g__CreateTypeFromConstituents|4_0(LocalList`1& constituents, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetCollectionExpressionTargetTypeInfo>g__ImplementsInterface|5_0(ITypeElement typeElement, IInterface interface);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpConcatenationWrapperProvider : object {
    public sealed virtual IStringConcatenationClrWrapper TryCreateWidestContaining(IExpression expression);
    public sealed virtual IStringConcatenationClrWrapper TryCreate(IExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpConstructorUtil : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Key`1<CachedPsiValue`1<ClassInitializationInfo>> INITIALIZATION_INFO;
    private static CSharpConstructorUtil();
    [NullableContextAttribute("2")]
[PureAttribute]
public static ClassInitializationInfo TryGetOrBuildInfo(ICSharpDeclaration constructorDeclaration);
    private static ClassInitializationInfo BuildInfoImpl(ICSharpDeclaration declaration);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool MemberCanHaveState(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmptyConstructorDeclaration(IConstructorDeclaration constructorDeclaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanEmptyConstructorBeRedundantSemantically(IConstructorDeclaration constructorDeclaration);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpContainingNodesWalker : ContainingNodesWalker {
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.CSharpContainingNodesWalker/<WalkThroughFirstDeclaredElements>d__0")]
public virtual IEnumerable`1<IDeclaredElement> WalkThroughFirstDeclaredElements(ITreeNode treeNode, bool returnThis);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpContextUtil : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static bool IsInStaticContext(ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInConstantContext(ITreeNode context, bool returnThis, bool excludeAttributes);
    [ExtensionAttribute]
[PureAttribute]
public static ConstantContextKind GetConstantContextKind(ITreeNode context, bool returnThis);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpDeclaredElementUtil : object {
    public static string TRANSPARENT_VARIABLE_NAME;
    private static HashSet`1<string> ourOperatorNames;
    [NotNullAttribute]
private static ClrTypeName ourEventRegistrationTokenName;
    private static CSharpDeclaredElementUtil();
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIndexer(IDeclaredElement declaredElement);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsProperty(IDeclaredElement declaredElement);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIndexedProperty(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLocalFunction(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsEffectivelyReadonlyMemberOfStruct(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsCSharpIndexer(IDeclaredElement declaredElement);
    [ExtensionAttribute]
public static bool DefaultMemberIsCSharpIndexer(ITypeElement type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsCSharpProperty(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsCSharpIndexedProperty(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsStaticClass(IClass classType);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSealedClass(IClass classType);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsCSharpTypeMember(ITypeMember member);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsMemberWithWellFormedName(ITypeMember member);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsDestructor(IDeclaredElement declaredElement);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsValue(IDeclaredElement element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAutoOrSemiAuto(IProperty property);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasBackingFieldAttributeInstance(IDeclaredElement declaredElement, IClrTypeName clrTypeName);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<IAttributeInstance> GetBackingFieldAttributeInstances(IDeclaredElement declaredElement);
    [PureAttribute]
[ContractAnnotationAttribute("declaredElement: null => false")]
public static bool IsCollectionInitializerAddMethod(IDeclaredElement declaredElement, ITreeNode context);
    [ContractAnnotationAttribute("=> true, elementType:notnull; => false, elementType:null")]
public static bool IsForeachEnumerableType(IType type, IType& elementType);
    [ContractAnnotationAttribute("=> true, elementType:notnull; => false, elementType:null")]
private static bool IsForeachEnumeratorPatternType(IDeclaredType declaredType, IType& elementType);
    [PureAttribute]
public static bool IsForeachEnumeratorPatternType(ITypeElement typeElement);
    [PureAttribute]
[ContractAnnotationAttribute("declaredElement: null => false")]
public static bool IsDisposableDisposeMethod(IDeclaredElement declaredElement, bool isAsync);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsForeachEnumeratorPatternMember(IDeclaredElement declaredElement);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
private static bool IsForeachGetEnumeratorMethodCandidate(IMethod method);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
private static bool IsForeachMoveNextMethodCandidate(IMethod method);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
private static bool IsForeachCurrentPropertyCandidate(IProperty property);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDeclaredType InterfaceQualification(IOverridableMember member);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPartial(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPartialWithImplementation(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPrimary(IConstructor constructor);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<IParameter> GetParametersOfDefiningPart(IMethod method);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool CanBeOverloaded(ITypeMember typeMember);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanHaveMembersWithBody(ITypeElement typeElement, ITreeNode usageContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanHaveNamedArguments(IParametersOwner parametersOwner);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPrivateFunction(IParametersOwner parametersOwner);
    [NotNullAttribute]
public static IEnumerable`1<DeclaredElementInstance`1<IParametersOwner>> FindSignatureOwners(IResolveContext resolveContext, IClrDeclaredElement declaredElement, ISubstitution substitution, Boolean& switchedToDelegateValue, Boolean& isDynamicValue);
    [NotNullAttribute]
public static IEnumerable`1<DeclaredElementInstance`1<IParametersOwner>> FindSignatureOwners(IClrDeclaredElement declaredElement, ISubstitution substitution);
    [PureAttribute]
public static bool IsTreatedLikeEvent(IEvent event, ITreeNode usageContext);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIteratorFunction(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsAsyncFunction(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsAsyncMethod(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsAutoProperty(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsFieldLikeEvent(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsMemberWithState(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsRefMember(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("declaredElement: null => false")]
public static bool MemberCanHaveInitializer(IDeclaredElement declaredElement, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanHaveInstanceMemberInitializers(ITypeElement typeElement, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool CSharpMemberHasInitializer(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("declaredElement: null => false")]
public static bool CSharpMemberHasInitializer(IDeclaredElement declaredElement, IInitializerOwnerDeclaration& declaration);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsWinRTEvent(IDeclaredElement element);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsCSharpField(IField field);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsFixedSizeBufferField(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsClosureVariable(IDeclaredElement declaredElement, IReferenceExpression accessExpression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool HasRecordCloneMethod(ITypeElement typeElement);
    [CanBeNullAttribute]
[PureAttribute]
public static CSharpByRangeIndexer GetRangeIndexer(IType qualifierType, ITreeNode context);
    [PureAttribute]
public static bool ArePatternIndexerWellKnownTypesAvailable(IPsiModule psiModule);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasInstanceConstructorsDeclared(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool AllParametersHaveNames(IParametersOwner parametersOwner);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFileLocalType(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeImplementImplicitlyIn(IOverridableMember overridableMember, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsByRefLikeOrAllowsByRefLikeType(ITypeElement typeElement);
    [ExtensionAttribute]
public static bool IsParameterArrayLike(IParameter parameter, ITreeNode context);
    [ExtensionAttribute]
public static bool IsParameterArrayLike(IParameter parameter, CSharpLanguageLevel languageLevel);
    public static bool IsValidParamsParameterType(IType parameterType, ITreeNode context, IType& elementType);
    [CompilerGeneratedAttribute]
internal static bool <MemberCanHaveInitializer>g__TypeCanDeclareInitializers|48_0(ITypeMember typeMember, <>c__DisplayClass48_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpDefaultValueExt : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static DefaultValue GetDefaultValue(ICSharpExpression expression, IType parameterType, IType expressionType);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static DefaultValue Normalize(DefaultValue value);
    [ExtensionAttribute]
public static bool CompareTo(DefaultValue value, DefaultValue otherValue);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpExpression CreateExpressionByDefaultValueSmart(CSharpElementFactory factory, DefaultValue value, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static RichText Present(DefaultValue defaultValue, TypePresentationStyle presentationStyle, string badValuePresentation);
    [CompilerGeneratedAttribute]
internal static bool <CompareTo>g__IsPureDefaultValue|4_0(DefaultValue defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpDisposeUtil : object {
    public static DeclaredElementInstance`1<IMethod> GetDisposeMethod(IType resourceType, bool isAsync, IAccessContext accessContext, ITreeNode context, IResolveContext resolveContext);
    public static DeclaredElementInstance`1<IMethod> GetDisposePatternMethod(IDeclaredType resourceType, bool isAsync, IAccessContext accessContext, ITreeNode context, IResolveContext resolveContext);
    [NullableContextAttribute("2")]
private static IDeclaredType GetCompatibleDisposableInterface(bool isAsync, IDeclaredType type, IPsiModule psiModule, CSharpLanguageLevel languageLevel);
    private static DeclaredElementInstance`1<IMethod> FindDisposableInterfaceMethodImplementation(IDeclaredType disposableInterface, IDeclaredType declaredType, bool isAsync, IPsiModule psiModule);
    public static bool IsDisposableType(IDeclaredType type, ITreeNode context, bool isAsync, IDeclaredType& disposableInterface);
    [NullableContextAttribute("2")]
public static bool IsDisposeMethodCandidate(IMethod method, bool isAsync, bool isPatternBased);
    [NullableContextAttribute("2")]
public static bool CanConvertToUsingStatementOrDeclaration(ILocalVariableDeclaration variableDeclaration);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpEntryPointFeaturesProvider : object {
    [PureAttribute]
public static EntryPointFeatures GetEntryPointFeatures(CSharpLanguageLevel languageLevel);
    public sealed virtual EntryPointFeatures GetEntryPointFeatures(IPsiModule module);
    public sealed virtual EntryPointFeatures GetEntryPointFeatures(ITreeNode context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpEnumUtil : object {
    [PureAttribute]
public static IList`1<IField> CalculateEnumMembers(ConstantValue constantValue, IEnum enum);
    private static bool CheckEnumFlags(ConstantValue constantValue, IEnum enum, IList`1<IField> flags, CSharpConstantCalculator constantCalculator);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil : object {
    private static int SHIFT_EXPRESSION_PRIORITY;
    private static int NULL_COALESCING_PRIORITY;
    private static IClrTypeName CodeContractsClass;
    private static CSharpExpressionUtil();
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableWarningsSuppressed(ICSharpExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, suppressionExpression:notnull; => false, suppressionExpression:null")]
public static bool IsNullableWarningsSuppressed(ICSharpExpression expression, ISuppressNullableWarningExpression& suppressionExpression);
    [CanBeNullAttribute]
public static ICSharpStatement GetStatementToBeVisibleFromAll(IReadOnlyCollection`1<ITreeNode> elements);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanCreateExpressionFrom(IVariableInitializer initializer);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpExpression GetOrCreateExpressionFromInitializer(IVariableInitializer initializer);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICSharpExpression CreateExpressionFromInitializer(IArrayInitializer arrayInitializer);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTrivialExpressionInitializer(IInitializerOwnerDeclaration initializerOwner);
    [NotNullAttribute]
public static ICSharpExpression ReplaceExpression(ICSharpExpression oldExpression, ICSharpExpression newExpression);
    [ExtensionAttribute]
[NotNullAttribute]
public static void RemoveBooleanCondition(ICSharpExpression booleanConditionExpression);
    [PureAttribute]
public static bool IsCondition(ICSharpExpression expression, IOperator& customTrueOperator, IConversionOperator& customImplicitCastOperator);
    [PureAttribute]
public static bool IsCondition(IResolveContext resolveContext, ICSharpExpression expression, IOperator& customTrueOperator, IConversionOperator& customImplicitCastOperator);
    [ExtensionAttribute]
public static bool IsFirstExpressionToExecuteInStatementLike(ICSharpExpression expression);
    [ExtensionAttribute]
public static bool IsFirstExpressionToExecuteInStatementLike(ICSharpExpression expression, ICSharpExpression& topmostParentExpression);
    private static bool IsLikelyToHaveNoSideEffectsExpression(ICSharpExpression destination);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetOperandThroughParenthesis(ICSharpExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetOperandThroughParenthesisStrict(ICSharpExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => null, isNegated: false; expression: notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetOperandThroughNegations(ICSharpExpression expression, Boolean& isNegated);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => null, isNegated: false; expression: notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetContainingNegatedExpression(ICSharpExpression expression, Boolean& isNegated);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetOperandThroughNullCheck(ICSharpExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => null; expression: notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetOperandThroughNullCheck(ICSharpExpression expression, Boolean& hasNullCheck);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetOperandThroughRefExpression(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
[CanBeNullAttribute]
public static ICSharpExpression GetContainingNullCheckExpression(ICSharpExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetOperandThroughIdentityConversionCast(ICSharpExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetContainingIdentityConversionCast(ICSharpExpression expression);
    [PureAttribute]
private static bool IsNotNullExtensionInvocation(IInvocationExpression invocationExpression, ICSharpExpression& qualifierExpression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetOperandThroughNullableValueAccess(ICSharpExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetContainingParenthesizedExpression(ICSharpExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICSharpExpression GetContainingParenthesizedExpressionStrict(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRValueExpression(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanIntroduceVariableFrom(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInExplicitVariableReferenceCapturePosition(ICSharpExpression expression, IResolveContext resolveContext);
    [PureAttribute]
[CanBeNullAttribute]
public static string GetKindOfExplicitVariableReferenceCapture(ICSharpExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExpressionLikelyToBeUnfinished(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool ExpressionCanBeStatement(ICSharpExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool ExpressionShouldBeStatement(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange GetStringLiteralContentTreeRange(ICSharpLiteralExpression literalExpression);
    [PureAttribute]
private static int CalcExpressionPriority(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRedundant(IParenthesizedExpression parenthesizedExpression);
    [PureAttribute]
public static bool NeedToParenthesize(ICSharpExpression replacedExpression, ICSharpExpression newExpression);
    private static bool NearbyTokensConfuseParser(ITokenNode firstToken, ITokenNode secondToken);
    private static bool IsRequiredToBeParenthesizedForParser(T relationalExpressionHolder, IRelationalExpression relationalExpression1, ICSharpExpression replacedExpression, Func`2<T, IRelationalExpression> getRelationalExpression);
    [PureAttribute]
public static bool IsMeaningfulToBeSurroundedWithParenthesesWhenReplaced(ICSharpExpression replacedExpression, ICSharpExpression newExpression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsThisOrNull(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsThisOrBaseOrNull(ICSharpExpression expression);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInvocationExpression GetContainingInvocation(ICSharpExpression expression);
    [PureAttribute]
private static bool IsUnderEquationalOperatorDeclaration(ICSharpExpression expression);
    private static bool IsUnderRelationalOperatorDeclaration(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFloatingPointOperator(IRelationalExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => null; expression: notnull => notnull")]
public static ICSharpExpression CreateLogicallyNegatedExpression(ICSharpExpression expression, bool applyCodeFormatter);
    [ExtensionAttribute]
public static bool IsCheckOfCodeInvariant(ICSharpExpression expression);
    internal static bool IsCheckOfCodeInvariant(ICSharpExpression expression, IResolveContext resolveContext, Predicate`1<IMethod> isAssertionMethod);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCheckOfCodeInvariant(ICSharpStatement statement);
    private static bool IsCheckOfCodeInvariant(ICSharpStatement statement, IResolveContext resolveContext, Predicate`1<IMethod> isAssertionMethod);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IExpressionType GetRuntimeExpressionType(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ICSharpExpression TryUnwrapNullableDotValueAndGetQualifier(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ICSharpExpression TryUnwrapNullableDotValue(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanDeclareExpressionVariable(ICSharpTreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool DeclaresVariables(ICSharpExpression expression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil/<GetDeclaredVariables>d__61")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<ILocalVariable> GetDeclaredVariables(ICSharpExpression expression);
    public static bool CanUseArrayInitializer(IArrayCreationExpression arrayCreation);
    [ExtensionAttribute]
[NotNullAttribute]
public static IQualifierWithTypeElement AsQualifier(ICSharpExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExpressionValueIgnored(ICSharpExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
public static void RemoveIgnoredExpression(ICSharpExpression expression);
    [PureAttribute]
public static int GetTypeQualifierDepth(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool IsNullLiteral(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool IsDefaultLiteral(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool IsTrueLiteral(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool IsFalseLiteral(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool IsLiteral(ICSharpExpression expression, TokenNodeType tokenType);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static JetHashSet`1<ILocalVariable> GetDeclaredExpressionVariables(ICSharpTreeNode treeNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.CSharpExpressionUtil/<IterateSingleVariableDesignations>d__73")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<ISingleVariableDesignation> IterateSingleVariableDesignations(ICSharpExpression rootExpression);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ConstantValue GetImplicitlyConvertedToConstantValue(ICSharpExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
public static IType GetTargetType(ICSharpExpression expression);
    [ExtensionAttribute]
[NotNullAttribute]
public static IType GetTargetType(ICSharpExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInContextWhereTargetTypeIsInSteadyState(ICSharpExpression expression);
    [CanBeNullAttribute]
public static ICSharpExpression TryMakeExpressionNaturallyTyped(ICSharpExpression expression, IType oldType, bool canRewriteSimplePredefinedDefaults, bool canApplyTypeCast, bool prepareForTargetTypeChange);
    [ExtensionAttribute]
public static NullableAnnotation GetLValueNullableAnnotation(ICSharpExpression expression, bool ignoreOverrideByFlowAnnotations);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceKind GetReferenceKind(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceKind GetReferenceKind(ICSharpExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCompileTimeBooleanConstantExpressionWithNamedConstant(ICSharpExpression expression, bool expectedValue);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInterpolatedStringHandlerExpression(ICSharpExpression expression, IResolveContext resolveContext);
    [CanBeNullAttribute]
[PureAttribute]
public static ITypeUsage TryGetTargetTypeUsageForExpression(ICSharpExpression expression);
    [CompilerGeneratedAttribute]
internal static bool <IsNotNullExtensionInvocation>g__IsNotNullMethod|24_0(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsNotNullExtensionInvocation>g__IsMethodTypeParameterType|24_1(IType type);
    [CompilerGeneratedAttribute]
internal static bool <GetOperandThroughNullableValueAccess>g__IsNullableReferenceAccess|25_0(IReferenceExpression referenceExpression, string expectedName, ICSharpExpression& qualifierExpression);
    [CompilerGeneratedAttribute]
internal static bool <GetOperandThroughNullableValueAccess>g__IsTypeMemberFromNullableType|25_1(IReference reference);
    [CompilerGeneratedAttribute]
internal static bool <IsRequiredToBeParenthesizedForParser>g__IsReferenceNameLike|42_0(ICSharpExpression expression, <>c__DisplayClass42_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <IsCheckOfCodeInvariant>g__IsMethodFromCodeContracts|55_0(IMethod method);
    [CompilerGeneratedAttribute]
internal static bool <GetRuntimeExpressionType>g__CanUnwrapCast|56_0(ICSharpExpression castExpression, ICSharpExpression operand);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpFunctionInvocationClrWrapper : CSharpArgumentsOwnerInvocationClrWrapper {
    [NotNullAttribute]
private IInvocationExpression myArgumentsOwner;
    private bool myIsExtensionMethod;
    public IReadOnlyList`1<IExpression> Arguments { get; }
    public CSharpFunctionInvocationClrWrapper(IInvocationExpression argumentsOwner);
    public virtual IReadOnlyList`1<IExpression> get_Arguments();
    public virtual void AddArgument(IExpression newArgumentExpression, int newArgumentIndex);
    public virtual void ChangeInvokedMethod(IMethod newFunction);
    public virtual void RemoveArgumentAt(int argumentToDeleteIndex);
    public virtual void SetArgumentAt(int currentItemIndex, IExpression argumentExpression);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpFunctionInvocationProvider : object {
    public sealed virtual IFunctionInvocationClrWrapper GetFunctionInvocationByArgument(IExpression expression);
    public sealed virtual IFunctionInvocationClrWrapper GetFunctionInvocationByArgumentsOwner(IArgumentsOwner argumentsOwner);
    public sealed virtual IExpression GetNarrowestContainingArgumentExpression(IExpression expression);
    public sealed virtual IFunctionInvocationClrWrapper SurroundWithStaticMethodInvocation(IFunction method, IExpression surroundedExpression, IPsiModule psiModule);
    public sealed virtual bool IsArgumentOfMethodThatHasSimilarFormattingMethod(IExpression argumentExpression, IFunction& properFormattingMethod);
    public sealed virtual bool IsArgumentOfFormattingFunction(IExpression argumentExpression, FormattingFunctionKind& formattingFunctionKind);
    public sealed virtual bool ExpressionCanBeReplacedByMethodInvocation(IExpression expression);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpLanguageFeatures : object {
    public sealed virtual bool AutoPropertiesAreSupported(ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpMainMethodUtil : object {
    [PureAttribute]
public static bool CanBeMainMethod(IMethodDeclaration declaration);
    [PureAttribute]
public static bool CanBeMainMethod(IMethod method);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpModificationUtil : object {
    public static bool IsToAddImportsToDeepestScope(ITreeNode context);
    public static bool IsQualifiedUsingAtNestedScope(ITreeNode context);
    public static bool IsQualifiedUsingAtNestedScope(ITreeNode context, IContextBoundSettingsStore settingsStore);
    [NotNullAttribute]
public static ThisQualifierSettingsKey GetThisQualifierStyle(ITreeNode context, IContextBoundSettingsStore settingsStore);
    public static bool CanRemoveUsing(IDocument document, IUsingDirective usingDirective);
    public static bool CanUseAliases(ITreeNode context);
    [NotNullAttribute]
public static ICSharpCustomModificationHandler CreateService(ITreeNode context);
    public static ITreeRange HandleChangeStatements(ITreeRange rangeBeforeChange, Func`1<ITreeRange> changeAction, bool strict);
    public static void HandleChangeExpressionInStatement(IStatement statement, Action changeAction);
    [ExtensionAttribute]
public static IBlock GetMethodBodyVisibleForUser(ICSharpFunctionDeclaration method);
    public static bool PreferQualifiedReference(IQualifiableReference reference, IDeclaredElement targetElement);
    [CanBeNullAttribute]
public static string GetSpecialElementType(DeclaredElementPresenterStyle presenter, IDeclaredElement declaredElement, ISubstitution substitution);
    [NotNullAttribute]
public static IEnumerable`1<ITreeRange> GetHolderBlockRanges(ITreeNode treeNode);
    public static void DeleteCommentChild(ICommentNode commentNode);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpNamespaceUtil : object {
    public static void ConvertToFileScoped(ICSharpNamespaceDeclaration namespaceDeclaration);
    public static void ConvertToBlockScoped(ICSharpNamespaceDeclaration namespaceDeclaration);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode GetTrailingSemicolon(ICSharpNamespaceDeclaration namespaceDeclaration);
    [PureAttribute]
public static bool CanChangeStyle(ICSharpNamespaceDeclaration namespaceDeclaration, bool checkInAllContexts);
    [PureAttribute]
public static bool CanAddFileScopedNamespaceDeclaration(ICSharpFile csharpFile);
    [PureAttribute]
public static bool IsFileScopedNamespaceBodyStylePreferred(ITreeNode context);
    [CompilerGeneratedAttribute]
internal static LocalList`1<IPreprocessor> <ConvertToBlockScoped>g__CollectPreprocessorNodesBetween|1_0(ITreeNode start, ITreeNode end);
    [CompilerGeneratedAttribute]
internal static void <ConvertToBlockScoped>g__MoveProcessorNodesAfter|1_1(LocalList`1<IPreprocessor> preprocessorNodes, ITreeNode parent, ITreeNode anchor);
    [CompilerGeneratedAttribute]
internal static void <ConvertToBlockScoped>g__MoveProcessorNodesBefore|1_2(LocalList`1<IPreprocessor> preprocessorNodes, ITreeNode parent, ITreeNode anchor);
    [CompilerGeneratedAttribute]
internal static bool <CanChangeStyle>g__CanChangeStyleInFile|3_1(IFile file, bool isFileScopedNamespace);
    [CompilerGeneratedAttribute]
internal static bool <CanChangeStyle>g__AreIfDirectivesAround|3_2(ICSharpNamespaceDeclaration namespaceDeclaration);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpNullableDirectiveIdentity : object {
    [CompilerGeneratedAttribute]
private NullableDirectiveTargetKind <Kind>k__BackingField;
    public NullableDirectiveTargetKind Kind { get; }
    public CSharpNullableDirectiveIdentity(NullableDirectiveTargetKind kind);
    [CompilerGeneratedAttribute]
public NullableDirectiveTargetKind get_Kind();
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.CSharpNullLiteralProvider : object {
    public sealed virtual IExpression CreateNullLiteral(IPsiModule psiModule);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpOperatorUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsApplicable(IOperator operator, ISubstitution substitution, IList`1<IExpressionType> argumentTypes, IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsLiftable(IOperator operator, ISubstitution substitution, bool circularOperatorForm);
    [ExtensionAttribute]
public static ISignOperator Unlift(ISignOperator signOperator);
    [ExtensionAttribute]
[NotNullAttribute]
public static IExpressionType OperatorExpressionExpressionType(IOperatorExpression operatorExpression, IResolveContext resolveContext);
    [NotNullAttribute]
private static string ModuleToString(IPsiModule module);
    [NotNullAttribute]
private static string Logging(IType type);
    internal static bool CheckCustomConversionValidity(IType source, IType target);
    [NotNullAttribute]
internal static IEnumerable`1<ISymbolInfo> CustomConversionOperators(IType type, IPsiModule module, bool explicit);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpParameterDeclarationSearchDomainUtil : object {
    public sealed virtual bool SearchParameterUsagesInTypeDeclaration(IConstructor constructor);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpPolyadicExpressionBuilder : object {
    public sealed virtual ICSharpExpression GetBinaryOperator(ICSharpExpression binaryNode);
    public sealed virtual TokenNodeType GetBinaryOperatorSign(ICSharpExpression binaryNode);
    public sealed virtual ICSharpExpression GetContainingParenthesizedNode(ICSharpExpression node);
    public sealed virtual ICSharpExpression GetContainingNode(ICSharpExpression node);
    public sealed virtual bool AreOperatorsEquivalent(ICSharpExpression binaryNode, ICSharpExpression otherNode, bool skipSemanticCheck);
    private static bool AreOperatorsEquivalentSemantically(IBinaryExpression leftBinary, IBinaryExpression rightBinary);
    public sealed virtual void GetBinaryOperands(ICSharpExpression binaryNode, ICSharpExpression& leftOperand, ICSharpExpression& rightOperand, ITokenNode& sign);
    public sealed virtual void CollectOperands(ICSharpExpression rootBinaryNode, ICSharpExpression node, ICollection`1<ICSharpExpression> operands, ICollection`1<ITokenNode> operatorSigns, bool skipSemanticCheck);
    public sealed virtual ICSharpExpression BuildChain(IList`1<ICSharpExpression> operands, List`1<ITokenNode> signs, ITokenNodeType operatorSign, Polyadic`1<ICSharpExpression> originalPolyadicForFormattingInference);
    public sealed virtual void SetCombinedFormatting(ITokenNode middleSignNode, Polyadic`1<ICSharpExpression> left, Polyadic`1<ICSharpExpression> right);
    [CompilerGeneratedAttribute]
internal static WhitespaceAndCommentsAround <BuildChain>g__InferCommonStyleFromPhysicalSigns|8_1(<>c__DisplayClass8_0& );
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpPolyadicPatternProvider : object {
    public sealed virtual IPattern GetBinaryOperator(IPattern binaryNode);
    public sealed virtual TokenNodeType GetBinaryOperatorSign(IPattern binaryNode);
    public sealed virtual IPattern GetContainingParenthesizedNode(IPattern node);
    public sealed virtual IPattern GetContainingNode(IPattern node);
    public sealed virtual bool AreOperatorsEquivalent(IPattern binaryNode, IPattern otherNode, bool skipSemanticCheck);
    public sealed virtual void GetBinaryOperands(IPattern binaryNode, IPattern& leftOperand, IPattern& rightOperand, ITokenNode& sign);
    public sealed virtual void CollectOperands(IPattern rootBinaryNode, IPattern node, ICollection`1<IPattern> operands, ICollection`1<ITokenNode> operatorSigns, bool skipSemanticCheck);
    public sealed virtual IPattern BuildChain(IList`1<IPattern> operands, List`1<ITokenNode> signs, ITokenNodeType keyword, Polyadic`1<IPattern> originalPolyadicForFormattingInference);
    public sealed virtual void SetCombinedFormatting(ITokenNode middleSignNode, Polyadic`1<IPattern> left, Polyadic`1<IPattern> right);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpPreprocessorRegionIdentity : object {
    public static ICodeRegionIdentity Instance;
    private static CSharpPreprocessorRegionIdentity();
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.CSharpRawStringLiteralAlterer : object {
    private string myPresentation;
    private List`1<TextRange> myValueSegmentsInPresentation;
    private List`1<int> myCompiledValueOffsets;
    [CompilerGeneratedAttribute]
private ICSharpLiteralExpression <LiteralExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLiteralType <LiteralType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeTextRange <UnderQuotesRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompiledValue>k__BackingField;
    public ICSharpLiteralExpression LiteralExpression { get; private set; }
    public CSharpLiteralType LiteralType { get; private set; }
    public StringVerbatimity PresentationForm { get; }
    public bool IsValid { get; private set; }
    public ILiteralExpression Expression { get; }
    public TreeTextRange UnderQuotesRange { get; private set; }
    public string CompiledValue { get; private set; }
    public CSharpRawStringLiteralAlterer(ICSharpLiteralExpression literalExpression);
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpLiteralExpression get_LiteralExpression();
    [CompilerGeneratedAttribute]
private void set_LiteralExpression(ICSharpLiteralExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual CSharpLiteralType get_LiteralType();
    [CompilerGeneratedAttribute]
private void set_LiteralType(CSharpLiteralType value);
    public sealed virtual StringVerbatimity get_PresentationForm();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    public sealed virtual ILiteralExpression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual TreeTextRange get_UnderQuotesRange();
    [CompilerGeneratedAttribute]
private void set_UnderQuotesRange(TreeTextRange value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CompiledValue();
    [CompilerGeneratedAttribute]
private void set_CompiledValue(string value);
    private void RefreshData();
    private void FillValueRanges(string presentation, CSharpLiteralType literalType, CSharpLanguageLevel languageLevel);
    public sealed virtual DocumentRange ValueTextRangeToPresentationDocumentRange(TextRange range);
    public sealed virtual TreeTextRange ValueTextRangeToPresentationTreeTextRange(TextRange range);
    [PureAttribute]
private TextRange ValueTextRangeToPresentationRangeWithinLiteral(TextRange range);
    [PureAttribute]
private int ValueOffsetToPresentationOffset(int valueOffset);
    public sealed virtual int PresentationDocumentOffsetToValueOffset(DocumentOffset documentOffset);
    public sealed virtual int PresentationTreeOffsetToValueOffset(TreeOffset treeOffset);
    [PureAttribute]
private int PresentationInsideOffsetToValueOffset(int presentationOffset);
    public sealed virtual void Insert(int valueOffset, string valueToInsert);
    public sealed virtual void Replace(string oldValue, string newValue);
    public sealed virtual void Remove(TextRange valueRange);
    public sealed virtual IStringLiteralAlterer Substring(TextRange valueRange);
    public sealed virtual ICSharpStringLiteralAlterer Concat(ICSharpStringLiteralAlterer other);
    [PureAttribute]
private ICSharpLiteralExpression CreateExpression(string value, Nullable`1<Utf8Suffix> suffix);
    private void UpdateExpression(ICSharpLiteralExpression newExpression);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpRegionIdentity : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public CSharpRegionIdentity(IStartRegion node);
    public CSharpRegionIdentity(IEndRegion node);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpRegionStructureProvider : object {
    public sealed virtual void ProcessNode(ITreeNode node, IRegionStructureAcceptor acceptor);
    public sealed virtual bool IsSpecialComment(IComment comment);
    protected virtual bool ProcessNodeCore(ITreeNode node, IRegionStructureAcceptor acceptor);
    private static bool TryProcess(T node, Action`1<T> action);
    private static bool TryProcess(IComment comment, IRegionStructureAcceptor acceptor);
    private static bool TryProcess(ICSharpFile file, IRegionStructureAcceptor acceptor);
    private static bool TryProcess(INullableDirective pragma, IRegionStructureAcceptor acceptor);
    private static bool TryProcess(IPragmaDirective pragma, IRegionStructureAcceptor acceptor);
    private static bool TryProcess(IClassMemberDeclaration member, IRegionStructureAcceptor acceptor);
    private static bool TryProcess(IMultipleDeclaration declaration, IRegionStructureAcceptor acceptor);
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.CSharpRegularVerbatimStringLiteralAlterer : object {
    [NotNullAttribute]
private List`1<int> myPresentationIndexToValueRange;
    [NotNullAttribute]
private List`1<TextRange> myValueRangesInPresentation;
    [NotNullAttribute]
private string myPresentation;
    private bool myHasValidBorders;
    [CompilerGeneratedAttribute]
private ICSharpLiteralExpression <LiteralExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLiteralType <LiteralType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompiledValue>k__BackingField;
    [CompilerGeneratedAttribute]
private StringVerbatimity <PresentationForm>k__BackingField;
    public ICSharpLiteralExpression LiteralExpression { get; private set; }
    public CSharpLiteralType LiteralType { get; private set; }
    public bool IsValid { get; }
    public string CompiledValue { get; private set; }
    public StringVerbatimity PresentationForm { get; private set; }
    public ILiteralExpression Expression { get; }
    public TreeTextRange UnderQuotesRange { get; }
    [NotNullAttribute]
private string LiteralPrefix { get; }
    public CSharpRegularVerbatimStringLiteralAlterer(ICSharpLiteralExpression literalExpression);
    [CompilerGeneratedAttribute]
public sealed virtual ICSharpLiteralExpression get_LiteralExpression();
    [CompilerGeneratedAttribute]
private void set_LiteralExpression(ICSharpLiteralExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual CSharpLiteralType get_LiteralType();
    [CompilerGeneratedAttribute]
private void set_LiteralType(CSharpLiteralType value);
    public sealed virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual string get_CompiledValue();
    [CompilerGeneratedAttribute]
private void set_CompiledValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual StringVerbatimity get_PresentationForm();
    [CompilerGeneratedAttribute]
private void set_PresentationForm(StringVerbatimity value);
    private void RefreshData();
    public sealed virtual ILiteralExpression get_Expression();
    public sealed virtual TreeTextRange get_UnderQuotesRange();
    private string get_LiteralPrefix();
    private bool FillCharacterRangesForRegularString(string presentation);
    private bool FillCharacterRangesForVerbatimString(string presentation);
    public sealed virtual DocumentRange ValueTextRangeToPresentationDocumentRange(TextRange range);
    public sealed virtual TreeTextRange ValueTextRangeToPresentationTreeTextRange(TextRange range);
    [PureAttribute]
private TextRange ValueTextRangeToPresentationRangeWithinLiteral(TextRange range);
    public sealed virtual int PresentationDocumentOffsetToValueOffset(DocumentOffset documentOffset);
    public sealed virtual int PresentationTreeOffsetToValueOffset(TreeOffset treeOffset);
    private int PresentationInsideOffsetToValueOffset(int presentationOffsetWithin);
    public sealed virtual void Insert(int valueOffset, string valueToInsert);
    public sealed virtual void Replace(string oldValue, string newValue);
    public sealed virtual void Remove(TextRange valueRange);
    public sealed virtual IStringLiteralAlterer Substring(TextRange valueRange);
    public sealed virtual ICSharpStringLiteralAlterer Concat(ICSharpStringLiteralAlterer other);
    private ICSharpLiteralExpression ReplaceBy(ICSharpLiteralExpression expression);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.CSharpStatementVisibleForAllCalculator`1 : StatementVisibleForAllCalculator`1<TStatement> {
    [CompilerGeneratedAttribute]
private static StatementVisibleForAllCalculator`1<ICSharpStatement> <Statements>k__BackingField;
    [CompilerGeneratedAttribute]
private static StatementVisibleForAllCalculator`1<ICSharpTreeNode> <StatementLikeConvertibleToStatements>k__BackingField;
    [NotNullAttribute]
public static StatementVisibleForAllCalculator`1<ICSharpStatement> Statements { get; }
    [NotNullAttribute]
public static StatementVisibleForAllCalculator`1<ICSharpTreeNode> StatementLikeConvertibleToStatements { get; }
    private static CSharpStatementVisibleForAllCalculator`1();
    [CompilerGeneratedAttribute]
public static StatementVisibleForAllCalculator`1<ICSharpStatement> get_Statements();
    [CompilerGeneratedAttribute]
public static StatementVisibleForAllCalculator`1<ICSharpTreeNode> get_StatementLikeConvertibleToStatements();
    [PureAttribute]
protected virtual bool IsStatementOwnerParent(ITreeNode singleParent, HashSet`1<ITreeNode> childNodes);
    protected virtual ITreeNode ChooseFirstStatementInStatementOwner(ITreeNode singleParent, HashSet`1<ITreeNode> childNodes);
    private static ICSharpStatement FindLabelReferencesAboveFirstLine(TreeNodeCollection`1<ICSharpStatement> statements, ICSharpStatement firstStatement, LocalList`1<ILabel> labelsToCheck);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpStaticUtil : object {
    public static bool HasProblemWithStatic(IReference reference);
    public static bool HasProblemWithStatic(IReference reference, IAccessContext accessContext);
    [CompilerGeneratedAttribute]
internal static bool <HasProblemWithStatic>g__HasProblemWithStaticUnderNameof|1_0(<>c__DisplayClass1_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpStringConcatenationClrWrapper : object {
    [NotNullAttribute]
private ICSharpExpression myExpression;
    [CanBeNullAttribute]
private IList`1<IExpression> myArguments;
    public IExpression Expression { get; }
    public IList`1<IExpression> Arguments { get; }
    public CSharpStringConcatenationClrWrapper(ICSharpExpression expression);
    public sealed virtual IExpression get_Expression();
    public sealed virtual IList`1<IExpression> get_Arguments();
    public sealed virtual void SetArgumentAt(int index, IExpression argument);
    private void ReplaceSourceExpressionWithNewConcatenation(IList`1<ICSharpExpression> concatenationArguments);
    public sealed virtual void TryMergeArgumentWithNext(int index);
    public sealed virtual void ReplaceInAllLiterals(string oldValue, string newValue);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.CSharpStringConcatenationClrWrapper/<GetWidestConstantValues>d__11")]
public sealed virtual IEnumerable`1<string> GetWidestConstantValues();
    public sealed virtual void RemoveAtValueRange(TextRange range);
    public sealed virtual void ReplaceAtValueRange(TextRange range, string newValue);
    public sealed virtual IEnumerable`1<IExpression> GetConcatenationArgumentsThatContainValueRange(TextRange range);
    public sealed virtual IList`1<IExpression> GetConcatenationArgumentsThatContainValueRange(TextRange range, IList`1& appropriateValueRanges, bool includeNonLiterals);
    public sealed virtual void InsertAtValueIndex(int index, string newValue);
    private static void CollectConcatenationArguments(ICSharpExpression expression, LocalList`1& consumer);
    [PureAttribute]
[CanBeNullAttribute]
public static ICSharpExpression GetWidestStringConcatenationExpression(ICSharpExpression csharpExpression);
    [CompilerGeneratedAttribute]
private IList`1<IExpression> <GetConcatenationArgumentsThatContainValueRange>g__GetSourceExpressionWithValueRange|15_0(IList`1& valueRanges, <>c__DisplayClass15_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpStringConcatenationUtil : object {
    [PureAttribute]
public static bool IsConcatenationOperatorExpression(IAdditiveExpression additiveExpression);
    public static bool IsStringConcatInvocation(IInvocationExpression invocationExpression);
    [CanBeNullAttribute]
public static ICSharpExpression MakeSamePresentation(IStringConcatenationClrWrapper concatWrapper, TextRange valueRange, CSharpElementFactory factory, bool removeRedundantVerbatimity);
    [NotNullAttribute]
private static List`1<object> FindPresentedExpressionsRecursive(IStringConcatenationClrWrapper concatWrapper, TextRange valueRange, CSharpElementFactory factory, bool removeRedundantVerbatimity);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICSharpExpression TryFindConstantInitializationExpression(IReferenceExpression referenceExpression);
    [NotNullAttribute]
private static ICSharpExpression CreateLiteralAsIs(CSharpElementFactory factory, bool removeRedundantVerbatimity, ICSharpLiteralExpression literal, TextRange localRange);
    [CompilerGeneratedAttribute]
internal static bool <CreateLiteralAsIs>g__IsVerbatimityRedundant|5_0(string value, StringVerbatimity verbatimity);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpStringLiteralAlterer : object {
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpStringLiteralAlterer TryCreateByLiteralExpression(ICSharpLiteralExpression literalExpression);
    [NotNullAttribute]
[PureAttribute]
public static ICSharpStringLiteralAlterer CreateByLiteralExpression(ICSharpLiteralExpression literalExpression);
    [NotNullAttribute]
[PureAttribute]
public static ICSharpStringLiteralAlterer CreateByValue(string value, StringVerbatimity presentationForm, CSharpElementFactory factory, CSharpLanguageLevel languageLevel);
    [NotNullAttribute]
public static ICSharpStringLiteralAlterer Concat(ICSharpStringLiteralAlterer left, ICSharpStringLiteralAlterer right);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpStringLiteralAltererProvider : object {
    public sealed virtual IStringLiteralAlterer CreateStringLiteralByCompiledValue(string value, ITreeNode context);
    public sealed virtual IStringLiteralAlterer TryCreateStringLiteralByExpression(IExpression expression);
    public sealed virtual IStringLiteralAlterer CreateStringLiteralByExpression(IExpression expression);
}
[ExtensionAttribute]
[LocalizableAttribute("False")]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpStringLiteralParser : object {
    private static RangeTranslator ourEmptyRangeTranslator;
    private static CSharpStringLiteralParser();
    [ExtensionAttribute]
public static StringSlice ExtractStringValue(ICSharpLiteralExpression expression);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string ParseStringLiteral(ICSharpLiteralExpression expression);
    [CanBeNullAttribute]
public static string ParseStringLiteral(string literalText, RangeTranslator& translator);
    [CanBeNullAttribute]
public static string ParseVerbatimLiteralValue(string text, RangeTranslator& translator, bool isStringInterpolation);
    [CanBeNullAttribute]
public static string ParseRegularLiteralValue(string text, RangeTranslator& translator, bool isStringInterpolation);
    [CanBeNullAttribute]
private static string ParseRawLiteral(string literalText, RangeTranslator& translator);
    private static CharSequence GetHexEscapeSequence(string value, int start);
    private static CharSequence GetUnicodeSmallEscapeSequence(string value, int start);
    private static CharSequence GetUnicodeLargeEscapeSequence(string value, int start);
    private static CharSequence GetEscapeSequence(string value, int start, int min, int max);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpTargetTypedExpressionRewriter : object {
    [NullableAttribute("2")]
private ICSharpExpression myExpression;
    [NullableAttribute("2")]
private IType myOldType;
    [NullableAttribute("2")]
private CSharpElementFactory myFactory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<ICSharpExpression> myQueue;
    [CompilerGeneratedAttribute]
private bool <CanRewriteSimplePredefinedDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanApplyTypeCast>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TargetTypeWillChange>k__BackingField;
    public bool CanRewriteSimplePredefinedDefaults { get; public set; }
    public bool CanApplyTypeCast { get; public set; }
    public bool TargetTypeWillChange { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CanRewriteSimplePredefinedDefaults();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanRewriteSimplePredefinedDefaults(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanApplyTypeCast();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanApplyTypeCast(bool value);
    [CompilerGeneratedAttribute]
public bool get_TargetTypeWillChange();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetTypeWillChange(bool value);
    public ICSharpExpression TryExecute(ICSharpExpression expression, IType oldType);
    private bool NaturalExpressionTypeEquals(IExpression expression, IType type);
    private ICSharpExpression TryMakeNaturallyTyped(ICSharpExpression currentExpression);
    private bool TryMakeExpressionNaturallyTyped(ICSharpExpression nextExpression, ICSharpExpression& newCurrentExpression);
    private bool TryRewriteTupleExpression(ITupleExpression tupleExpression, DecoratedType`1<TupleTypeDecoration> tupleType, ICSharpExpression& newCurrentExpression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpTasklikeUtil : object {
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("type: null => null")]
public static IType GetTasklikeUnderlyingType(IType type, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("type: null => null")]
public static IType GetTasklikeUnderlyingType(IType type, CSharpLanguageLevel latestSupportedLanguageLevel);
    [ExtensionAttribute]
[PureAttribute]
public static TasklikeKind GetTasklikeKind(IType type, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static TasklikeKind GetTasklikeKind(IType type, CSharpLanguageLevel latestSupportedLanguageLevel);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNonGenericTasklike(IType type, CSharpLanguageLevel latestSupportedLanguageLevel);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNonGenericTasklike(IType type, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTasklike(IType type, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTasklike(IType type, CSharpLanguageLevel latestSupportedLanguageLevel);
    [PureAttribute]
private static TasklikeKind GetCustomTasklikeKind(IType type);
    [PureAttribute]
private static bool HasValidAsyncMethodBuilderAttribute(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTasklike(TasklikeKind kind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsGenericTasklike(TasklikeKind kind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNonGenericTasklike(TasklikeKind kind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPredefined(TasklikeKind kind);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeConstraintUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static ConstraintContextualKeywordKind GetPossibleContextualKeywordConstraintKind(IReferenceName referenceName);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnmanagedConstraint(ITypeParameterConstraint typeParameterConstraint);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNotNullConstraint(ITypeParameterConstraint typeParameterConstraint);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyContextualKeywordConstraint(ITypeParameterConstraint typeParameterConstraint);
    [ExtensionAttribute]
[PureAttribute]
public static ConstraintContextualKeywordKind GetConstraintContextualKeywordKind(ITypeParameterConstraint typeParameterConstraint, bool checkResolve);
    [ExtensionAttribute]
[PureAttribute]
public static ICSharpIdentifier GetConstraintContextualKeyword(ITypeParameterConstraint typeParameterConstraint);
    [CanBeNullAttribute]
[PureAttribute]
private static IReferenceName GetScalarName(ITypeParameterConstraint typeParameterConstraint);
    [PureAttribute]
private static ConstraintContextualKeywordKind GetConstraintContextualKeywordKind(IReferenceName referenceName);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeMemberDeclarationService : object {
    public sealed virtual IDeclaration FindDeclarationByOffset(DocumentRange documentRange, IFile file);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool RequiresUnsafeContext(IType type, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool RequiresUnsafeContext(IType type, CSharpLanguageLevel latestSupportedLanguageLevel);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool HasPointerTypeInStructure(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type: null => false")]
public static bool IsUnmanagedType(IType type, CSharpLanguageLevel languageLevel);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type: null => false")]
public static bool CanUseExplicitly(IType type, ITreeNode context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtil/<IsVariantSafe>d__6")]
[PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<VarianceFailure> IsVariantSafe(IType type, TypeParameterVariance safetyType, Func`2<ITypeParameter, TypeParameterVariance> provider);
    [CanBeNullAttribute]
public static IDelegate GetDelegateTypeConsiderTypeParameters(IType type, ISubstitution& substitution);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullConstantType(IExpressionType expressionType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNullConstantOrDefaultLiteralType(IExpressionType expressionType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDefaultLiteralOrTargetTypedObjectCreationType(IExpressionType expressionType);
    [ExtensionAttribute]
public static bool CanDeclareVolatileFieldWith(IType type);
    [NotNullAttribute]
[PureAttribute]
public static IType GetReturnTypeByFunction(IType returnType, bool isAsyncFunction, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeEnumeratedInForeach(IType type, ITreeNode context, bool isAwaitForeach);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type: null => false")]
public static bool CanBeIteratorReturnType(IType type, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsValidFunctionTypeConversionTarget(IType type);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IType GetFunctionType(IExpressionType expressionType);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsInlineArray(ITypeElement typeElement);
    [ExtensionAttribute]
[ContractAnnotationAttribute("typeElement:null => false")]
public static bool IsInlineArray(ITypeElement typeElement, Int32& length);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IType TryGetInlineArrayElementFieldType(ITypeElement structOrRecord);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IType TryGetPossiblyUnsupportedByLanguageInlineArrayElementFieldType(ITypeElement structOrRecord, InlineArrayElementTypeVerificationResult& verificationResult);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IDeclaredType TryGetAssignableStandardDelegateType(IAnonymousDelegate anonymousDelegateType);
    [CompilerGeneratedAttribute]
internal static bool <RequiresUnsafeContext>g__IsUnsafeType|1_0(IType type);
    [CompilerGeneratedAttribute]
internal static bool <IsUnmanagedType>g__IsUnmanagedTypeCore|4_0(IType typeToCheck, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUnmanagedType>g__IsUnmanagedStruct|4_1(IStruct structElement, ISubstitution substitution, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUnmanagedType>g__IsSpecialUnmanagedType|4_2(IType typeToCheck);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.CSharp.CSharpLanguage", "16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.CSharpTypeUtilLanguageService : object {
    public sealed virtual bool CanUseExplicitly(IType type, ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpUsageCheckingUtil : object {
    [PureAttribute]
public static bool CanMultipleEnumerationContributeToUsageAnalysis(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
public static IDeclaredElement GetEnumerationSourceByVariableInitializer(ILocalVariableDeclaration localVariableDeclaration);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
private static IDeclaredElement ResolveInitilizerElement(ICSharpExpression initializerExpression);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
private static bool ShouldTrackReturnValueEnumerations(IDeclaredElement initializerElement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.CSharpUsingOwnerUtil : object {
    public static void SetAwait(ICSharpTreeNode usingOwner, bool isAwaitUsing);
    [ExtensionAttribute]
[NotNullAttribute]
public static IMultipleLocalVariableDeclaration ConvertToUsingDeclaration(IUsingStatement usingStatement, INamesSuggestion& namesSuggestion);
    [PureAttribute]
public static bool AlwaysEndsWithScopeExit(IUsingStatement usingStatement);
    [CompilerGeneratedAttribute]
internal static bool <AlwaysEndsWithScopeExit>g__CannotDependOnResourceExpression|2_0(ICSharpExpression expression);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DagState : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<DagTempVariable, IValueSet> <RemainingValues>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<StateForCase> Cases;
    [CompilerGeneratedAttribute]
private DagTest <SelectedTest>k__BackingField;
    [CompilerGeneratedAttribute]
private DagState <TrueBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private DagState <FalseBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private DecisionDagNode <DagNode>k__BackingField;
    [NotNullAttribute]
public IReadOnlyDictionary`2<DagTempVariable, IValueSet> RemainingValues { get; private set; }
    [CanBeNullAttribute]
public DagTest SelectedTest { get; public set; }
    [CanBeNullAttribute]
public DagState TrueBranch { get; public set; }
    [CanBeNullAttribute]
public DagState FalseBranch { get; public set; }
    [CanBeNullAttribute]
public DecisionDagNode DagNode { get; public set; }
    public DagState(IReadOnlyList`1<StateForCase> cases, IReadOnlyDictionary`2<DagTempVariable, IValueSet> remainingValues);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<DagTempVariable, IValueSet> get_RemainingValues();
    [CompilerGeneratedAttribute]
private void set_RemainingValues(IReadOnlyDictionary`2<DagTempVariable, IValueSet> value);
    [CompilerGeneratedAttribute]
public DagTest get_SelectedTest();
    [CompilerGeneratedAttribute]
public void set_SelectedTest(DagTest value);
    [CompilerGeneratedAttribute]
public DagState get_TrueBranch();
    [CompilerGeneratedAttribute]
public void set_TrueBranch(DagState value);
    [CompilerGeneratedAttribute]
public DagState get_FalseBranch();
    [CompilerGeneratedAttribute]
public void set_FalseBranch(DagState value);
    [CompilerGeneratedAttribute]
public DecisionDagNode get_DagNode();
    [CompilerGeneratedAttribute]
public void set_DagNode(DecisionDagNode value);
    [NotNullAttribute]
internal DagTest ComputeSelectedTest();
    internal void UpdateRemainingValues(IReadOnlyDictionary`2<DagTempVariable, IValueSet> newRemainingValues);
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DagStateEquivalence : object {
    [NotNullAttribute]
public static DagStateEquivalence Instance;
    private static DagStateEquivalence();
    public sealed virtual bool Equals(DagState x, DagState y);
    public sealed virtual int GetHashCode(DagState x);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DagTempVariable : object {
    [CompilerGeneratedAttribute]
private int <IndexInDeconstruction>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private DagEvaluation <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <TreeNode>k__BackingField;
    public int IndexInDeconstruction { get; }
    [NullableAttribute("1")]
public IType Type { get; }
    public DagEvaluation Source { get; }
    public bool IsOriginalInput { get; }
    public ITreeNode TreeNode { get; public set; }
    [NullableContextAttribute("1")]
public DagTempVariable(IType type, DagEvaluation source, int indexInDeconstruction);
    [CompilerGeneratedAttribute]
public int get_IndexInDeconstruction();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public DagEvaluation get_Source();
    public bool get_IsOriginalInput();
    [CompilerGeneratedAttribute]
public ITreeNode get_TreeNode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TreeNode(ITreeNode value);
    [NullableContextAttribute("1")]
public static DagTempVariable ForOriginalInput(IType variableType);
    [NullableContextAttribute("1")]
private bool Equals(DagTempVariable other);
    [NullableContextAttribute("1")]
public bool IsEquivalentTo(DagTempVariable other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DagTempVariable left, DagTempVariable right);
    public static bool op_Inequality(DagTempVariable left, DagTempVariable right);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DagTempVariableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static DagTempVariable GetOriginalVariable(DagTempVariable variable);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DagTestVisitor`2 : object {
    public TResult Apply(TContext context, IControlFlowElement element);
    public TResult Apply(TContext context, DagTest dag);
    public bool IsVariableBinding(IControlFlowElement element);
    public virtual TResult VisitVariableBinding(TContext context, IReadOnlyList`1<PatternBinding> bindingElementBindings, DecisionDagConclusion bindingElementDagConclusion, WhenDecisionDagNode bindingElementWhenDagNode);
    public virtual TResult VisitDagTest(TContext context, DagTest dagTest);
    public virtual TResult VisitDagEvaluation(TContext context, DagEvaluation dagEvaluation);
    public virtual TResult VisitDagValueTest(TContext context, DagTest dagTest, ConstantValue constantValue);
    public virtual TResult VisitDagTypeTest(TContext context, DagTypeTest dagTypeTest);
    public virtual TResult VisitExplicitNullTest(TContext context, DagExplicitNullTest dagTest);
    public virtual TResult VisitDagNonNullTest(TContext context, DagNonNullTest dagTest);
    public virtual TResult VisitDagRelationalTest(TContext context, DagTest dagRelationalTest, ValueSetOperation relation, ConstantValue value);
    public virtual TResult VisitDagDeconstructEvaluation(TContext context, DagDeconstructEvaluation dagDeconstructEvaluation);
    public virtual TResult VisitDagTypeEvaluation(TContext context, DagTypeEvaluation dagTypeEvaluation);
    public virtual TResult VisitDagFieldEvaluation(TContext context, DagFieldEvaluation dagFieldEvaluation, IField declaredElement);
    public virtual TResult VisitDagPropertyEvaluation(TContext context, DagPropertyEvaluation dagPropertyEvaluation, IProperty declaredElement);
    public virtual TResult VisitDagIndexEvaluation(TContext context, DagIndexEvaluation dagIndexEvaluation, int index);
    public virtual TResult VisitDagTupleComponentEvaluation(TContext context, DagTupleComponentEvaluation dagTupleComponent);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DecisionDag : object {
    [CanBeNullAttribute]
private HashSet`1<DecisionDagConclusion> myReachableConclusions;
    [CanBeNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<DecisionDagNode> myTopologicallySortedNodes;
    [CompilerGeneratedAttribute]
private DecisionDagNode <RootNode>k__BackingField;
    [NotNullAttribute]
public DecisionDagNode RootNode { get; }
    [NotNullAttribute]
public HashSet`1<DecisionDagConclusion> ReachableConclusions { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<DecisionDagNode> TopologicallySortedNodes { get; }
    public DecisionDag(DecisionDagNode rootNode);
    [CompilerGeneratedAttribute]
public DecisionDagNode get_RootNode();
    [NotNullAttribute]
public static DecisionDag ForSwitchStatement(ISwitchStatement switchStatement, IResolveContext resolveContext);
    [NotNullAttribute]
public static DecisionDag ForSwitchExpression(ISwitchExpression switchExpression, IResolveContext resolveContext);
    [NotNullAttribute]
public static DecisionDag ForIsExpression(IIsExpression isExpression, IResolveContext resolveContext);
    public static bool IsSwitchEndpointReachable(ISwitchExpression switchExpression);
    public HashSet`1<DecisionDagConclusion> get_ReachableConclusions();
    public IReadOnlyList`1<DecisionDagNode> get_TopologicallySortedNodes();
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IReadOnlyList`1<DecisionDagNode> Successors(DecisionDagNode node);
    [PureAttribute]
[NotNullAttribute]
public DecisionDag SimplifyDecisionDagIfConstantInput(ICSharpExpression input, IResolveContext resolveContext);
    [NotNullAttribute]
private DecisionDag Rewrite(Func`3<DecisionDagNode, Func`2<DecisionDagNode, DecisionDagNode>, DecisionDagNode> makeReplacement);
    [NotNullAttribute]
private static DecisionDagNode TrivialReplacement(DecisionDagNode dag, Func`2<DecisionDagNode, DecisionDagNode> replacement);
    [NotNullAttribute]
internal string Dump();
    [CompilerGeneratedAttribute]
internal static string <Dump>g__Dump|18_0(DagTest d, <>c__DisplayClass18_0& );
    [CompilerGeneratedAttribute]
internal static string <Dump>g__PresentValue|18_3(ConstantValue constantValue);
    [CompilerGeneratedAttribute]
internal static string <Dump>g__PresentRelation|18_4(ValueSetOperation operation);
    [CompilerGeneratedAttribute]
internal static int <Dump>g__TempIdentifier|18_1(DagEvaluation e, <>c__DisplayClass18_0& );
    [CompilerGeneratedAttribute]
internal static string <Dump>g__TempName|18_2(DagTempVariable t, <>c__DisplayClass18_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DecisionDagBuilder : object {
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private PredefinedType myPredefinedType;
    [NotNullAttribute]
private ICSharpTypeConversionRule myTypeConversionRule;
    private CSharpLanguageLevel myLanguageLevel;
    [CompilerGeneratedAttribute]
private IPattern <PatternToRemove>k__BackingField;
    [CanBeNullAttribute]
public IPattern PatternToRemove { get; public set; }
    public DecisionDagBuilder(ITreeNode context, IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
public IPattern get_PatternToRemove();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PatternToRemove(IPattern value);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public DecisionDag CreateDecisionDagFor(ITreeNode sourceElement);
    [NotNullAttribute]
public DecisionDag CreateDecisionDagForSwitchStatement(ISwitchStatement switchStatement);
    [NotNullAttribute]
public DecisionDag CreateDecisionDagForSwitchExpression(ISwitchExpression switchExpression);
    [NotNullAttribute]
public DecisionDag CreateDecisionDagForIsExpression(IIsExpression isExpression);
    [NotNullAttribute]
public StateForCase MakeTestsForPattern(int index, DagTempVariable input, IPattern pattern, ICSharpExpression guardClauseExpression, DecisionDagConclusion decisionDagConclusion);
    [NotNullAttribute]
public StateForCase MakeTestsForTypeCheck(int index, DagTempVariable input, IType type, ICSharpExpression guardClauseExpression, DecisionDagConclusion decisionDagConclusion);
    [NotNullAttribute]
public StateForCase MakeTestsForConstantValueCheck(int index, DagTempVariable input, ConstantValue constantValue, ICSharpExpression guardClauseExpression, DecisionDagConclusion decisionDagConclusion, ITreeNode context, bool isNegated);
    [NotNullAttribute]
public StateForCase MakeTestsForRelationalCheck(int index, DagTempVariable input, ConstantValue constantValue, RelationalPatternKind relationalPatternKind, ICSharpExpression guardClauseExpression, DecisionDagConclusion decisionDagConclusion, ITreeNode context);
    [NotNullAttribute]
public DecisionDag MakeDecisionDag(List`1<StateForCase> casesForRootNode, LeafDecisionDagNode defaultDecision);
    private void SplitCases(DagState dagState, DagTest test, IReadOnlyList`1& whenTrue, IReadOnlyList`1& whenFalse, IReadOnlyDictionary`2& whenTrueValues, IReadOnlyDictionary`2& whenFalseValues, Boolean& foundExplicitNullTest);
    private void SplitCase(DagState dagState, StateForCase stateForCase, DagTest test, IValueSet whenTrueValues, IValueSet whenFalseValues, StateForCase& whenTrue, StateForCase& whenFalse, Boolean& foundExplicitNullTest);
    private ValueTuple`4<IReadOnlyDictionary`2<DagTempVariable, IValueSet>, IReadOnlyDictionary`2<DagTempVariable, IValueSet>, bool, bool> SplitValues(IReadOnlyDictionary`2<DagTempVariable, IValueSet> values, DagTest test);
    [NotNullAttribute]
private static Dictionary`2<TKey, TValue> Clone(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    internal void CheckConsistentDecision(DagTest test, DagTest other, IValueSet whenTrueValues, IValueSet whenFalseValues, Boolean& trueTestPermitsTrueOther, Boolean& falseTestPermitsTrueOther, Boolean& trueTestImpliesTrueOther, Boolean& falseTestImpliesTrueOther, Boolean& foundExplicitNullTest);
    internal bool CheckInputRelation(DagState state, DagTest test, DagTest other, Tests& relationCondition, Tests& relationEffect);
    private Nullable`1<bool> ExpressionOfTypeMatchesPatternTypeForLearningFromSuccessfulTypeTest(IType expressionType, IType patternType);
    [NotNullAttribute]
private static IReadOnlyList`1<StateForCase> RemoveEvaluation(IReadOnlyList`1<StateForCase> cases, DagEvaluation dagEvaluation);
    [NotNullAttribute]
private static Tests SimplifyTestsAndBindings(Tests tests, IReadOnlyList`1<PatternBinding> bindingsBuilder);
    private Tests MakeTestsAndBindings(DagTempVariable input, IPattern pattern, List`1<PatternBinding> bindings);
    private Tests MakeTestsAndBindings(DagTempVariable input, IPattern pattern, DagTempVariable& output, List`1<PatternBinding> bindings);
    private Tests MakeTestsAndBindingsForListPattern(DagTempVariable input, IListPattern listPattern, DagTempVariable& output, List`1<PatternBinding> bindings);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForRelationalPattern(DagTempVariable input, IRelationalPattern relationalPattern, DagTempVariable& output);
    [NotNullAttribute]
private Tests MakeRelationalTest(DagTempVariable input, ConstantValue constantValue, RelationalPatternKind relationalPatternKind, ITreeNode context, DagTempVariable& output);
    [PureAttribute]
[CanBeNullAttribute]
public static IValueSet CreateValueSet(ConstantValue constantValue, ValueSetOperation relation, ITreeNode context);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForNegatedPattern(DagTempVariable input, INegatedPattern negatedPattern, List`1<PatternBinding> bindings, DagTempVariable& output);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForRecursivePattern(DagTempVariable input, IRecursivePattern recursivePattern, List`1<PatternBinding> bindings, DagTempVariable& output);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForBinaryPattern(DagTempVariable input, IBinaryPattern binaryPattern, List`1<PatternBinding> bindings, DagTempVariable& output);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForDeconstructionClause(DagTempVariable input, IDeconstructionPatternClause deconstructionClause, List`1<PatternBinding> bindings, DagTempVariable& output);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForPropertyClause(DagTempVariable input, IPropertyPatternClause propertyClause, List`1<PatternBinding> bindings);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForTypePattern(DagTempVariable input, ITypePattern typePattern, List`1<PatternBinding> bindings, DagTempVariable& output);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForVarPattern(DagTempVariable input, IVarPattern varPattern, List`1<PatternBinding> bindings, DagTempVariable& output);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForVarDeconstructionPattern(DagTempVariable input, IVarDeconstructionPattern varDeconstructionPattern, List`1<PatternBinding> bindings, DagTempVariable& output);
    [NotNullAttribute]
private Tests MakeTestsAndBindingsForDeconstructingDeclarationPattern(IParenthesizedVariableDesignation parenthesizedVariableDesignation, DagTempVariable input, List`1<PatternBinding> bindings, DagTempVariable& output);
    [ContractAnnotationAttribute("=> false; => true, getItemProperty: notnull")]
private bool MakeTestsForITupleLengthCheck(IPsiModule psiModule, DagTempVariable input, List`1<Tests> tests, int patternLength, DagTempVariable& valueAsITuple, IProperty& getItemProperty, DagTempVariable& output);
    [NotNullAttribute]
private DagTempVariable MakeConvertToType(DagTempVariable input, IType type, List`1<Tests> tests, bool isExplicitTest);
    private static void MakeCheckNotNull(DagTempVariable input, List`1<Tests> tests, bool isExplicitTest);
    private Tests MakeTestsForConstantOrTypePattern(IConstantOrTypePattern constantOrTypePattern, DagTempVariable input, DagTempVariable& output);
    private Tests MakeConstantValueTest(ITreeNode context, DagTempVariable input, ConstantValue constantValue, DagTempVariable& output);
    [CompilerGeneratedAttribute]
internal static DagState <MakeDecisionDag>g__UniqifyState|17_0(IReadOnlyList`1<StateForCase> cases, IReadOnlyDictionary`2<DagTempVariable, IValueSet> remainingValues, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static DecisionDagNode <MakeDecisionDag>g__FinalState|17_1(DecisionDagConclusion label, IReadOnlyList`1<PatternBinding> bindings, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static StateForCase <SplitCase>g__MakeNext|19_0(Tests remainingTests, <>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
private ValueTuple`4<IReadOnlyDictionary`2<DagTempVariable, IValueSet>, IReadOnlyDictionary`2<DagTempVariable, IValueSet>, bool, bool> <SplitValues>g__ResultForRelation|20_0(ValueSetOperation relation, ConstantValue value, <>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
internal static void <CheckConsistentDecision>g__HandleRelationWithValue|22_0(ValueSetOperation relation, ConstantValue value, Boolean& trueTestPermitsTrueOther, Boolean& falseTestPermitsTrueOther, Boolean& trueTestImpliesTrueOther, Boolean& falseTestImpliesTrueOther, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
internal static ValueTuple`3<DagTempVariable, DagTempVariable, int> <CheckInputRelation>g__GetCanonicalInput|23_0(DagIndexerEvaluation e);
    [CompilerGeneratedAttribute]
internal static Tests <SimplifyTestsAndBindings>g__ScanAndSimplify|26_0(Tests tests, <>c__DisplayClass26_0& );
    [CompilerGeneratedAttribute]
private bool <MakeTestsAndBindingsForPropertyClause>g__TryMakeSubpatternMemberTests|37_0(IReferenceExpression accessExpression, DagTempVariable& output, <>c__DisplayClass37_0& );
    [CompilerGeneratedAttribute]
private DagTempVariable <MakeTestsAndBindingsForPropertyClause>g__EvaluateComponent|37_2(<>c__DisplayClass37_0& , <>c__DisplayClass37_1& , <>c__DisplayClass37_2& );
    [CompilerGeneratedAttribute]
private bool <MakeTestsAndBindingsForPropertyClause>g__IsIndexableCollectionLength|37_1(ResolveResultWithInfo resolveResult, IType dispatchType, <>c__DisplayClass37_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DecisionDagConclusion : ValueType {
    [NullableAttribute("2")]
private object myDecisionTarget;
    public bool IsSwitchDefaultLabel { get; }
    public bool IsSwitchEndpoint { get; }
    public bool IsIsExpressionTrueExit { get; }
    public bool IsIsExpressionFalseExit { get; }
    [NullableContextAttribute("2")]
private DecisionDagConclusion(object decisionTarget);
    [PureAttribute]
public static DecisionDagConclusion ForSwitchCaseLabel(ISwitchCaseLabel switchCaseLabel);
    [PureAttribute]
public static DecisionDagConclusion ForSwitchExpressionArm(ISwitchExpressionArm switchExpressionArm);
    [PureAttribute]
public static DecisionDagConclusion ForSwitchEndpoint(ISwitchStatement switchStatement);
    [PureAttribute]
public static DecisionDagConclusion ForSwitchEndpoint(ISwitchExpression switchExpression);
    [PureAttribute]
public static DecisionDagConclusion ForIsExpressionTrueExit(IIsExpression isExpression);
    [PureAttribute]
public static DecisionDagConclusion ForIsExpressionFalseExit(IIsExpression isExpression);
    [PureAttribute]
public static DecisionDagConclusion ForVirtualCaseLabel(object labelSource);
    public bool get_IsSwitchDefaultLabel();
    public bool get_IsSwitchEndpoint();
    public bool get_IsIsExpressionTrueExit();
    public bool get_IsIsExpressionFalseExit();
    public bool Equals(DecisionDagConclusion other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DecisionDagConclusion left, DecisionDagConclusion right);
    public static bool op_Inequality(DecisionDagConclusion left, DecisionDagConclusion right);
    [NullableContextAttribute("2")]
[PureAttribute]
public IPattern TryGetPattern();
    internal string Dump();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DecisionDagExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDefaultLabelOrEndpointReachable(DecisionDag decisionDag);
    [ExtensionAttribute]
[PureAttribute]
public static IReadOnlyList`1<IPattern> ScanForRedundantPatterns(DecisionDag decisionDag, IDecisionDagOwner decisionDagOwner);
    [CompilerGeneratedAttribute]
internal static void <ScanForRedundantPatterns>g__CheckInnerPatterns|1_0(IPattern rootPattern, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <ScanForRedundantPatterns>g__FindDagValueTests|1_1(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <ScanForRedundantPatterns>g__IsConstantToHandle|1_2(ConstantValue constantValue);
    [CompilerGeneratedAttribute]
internal static bool <ScanForRedundantPatterns>g__IsRedundantPatternCandidate|1_3(IPattern pattern);
    [CompilerGeneratedAttribute]
internal static bool <ScanForRedundantPatterns>g__SpeculativeCheckByPatternRemoval|1_4(IPattern patternToRemove, <>c__DisplayClass1_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.DecisionStateDag : object {
    [CompilerGeneratedAttribute]
private DagState <RootNode>k__BackingField;
    public DagState RootNode { get; }
    public DecisionStateDag(DagState initialState);
    [CompilerGeneratedAttribute]
public DagState get_RootNode();
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<DagState> Successor(DagState state);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<DagState> TopologicallySortedReachableStates();
    [NotNullAttribute]
internal string Dump();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.IValueSet {
    public bool IsEmpty { get; }
    public abstract virtual IValueSet Intersect(IValueSet other);
    public abstract virtual IValueSet Union(IValueSet other);
    public abstract virtual IValueSet Complement();
    public abstract virtual bool Any(ValueSetOperation relation, ConstantValue value);
    public abstract virtual bool All(ValueSetOperation relation, ConstantValue value);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual ConstantValue GetSample(IPsiModule module);
}
[NullableContextAttribute("1")]
internal interface JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.IValueSet`1 {
    public abstract virtual IValueSet`1<T> Intersect(IValueSet`1<T> other);
    public abstract virtual IValueSet`1<T> Union(IValueSet`1<T> other);
    public abstract virtual IValueSet`1<T> Complement();
    public abstract virtual bool Any(ValueSetOperation relation, T value);
    public abstract virtual bool All(ValueSetOperation relation, T value);
}
[NullableContextAttribute("1")]
internal interface JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.IValueSetFactory {
    public IValueSet AllValues { get; }
    public IValueSet NoValues { get; }
    public abstract virtual IValueSet Related(ValueSetOperation relation, ConstantValue value);
    public abstract virtual bool Related(ValueSetOperation relation, ConstantValue left, ConstantValue right);
    public abstract virtual IValueSet get_AllValues();
    public abstract virtual IValueSet get_NoValues();
}
internal interface JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.IValueSetFactory`1 {
    [NullableContextAttribute("1")]
public abstract virtual IValueSet`1<T> Related(ValueSetOperation relation, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagAssignmentEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private DagTempVariable <Target>k__BackingField;
    public DagTempVariable Target { get; }
    [NullableAttribute("2")]
public IDeclaredElement DeclaredElement { get; }
    [NullableAttribute("2")]
public ISubstitution Substitution { get; }
    public DagAssignmentEvaluation(DagTempVariable target, DagTempVariable input);
    [CompilerGeneratedAttribute]
public DagTempVariable get_Target();
    [NullableContextAttribute("2")]
public virtual IDeclaredElement get_DeclaredElement();
    [NullableContextAttribute("2")]
public virtual ISubstitution get_Substitution();
    protected virtual bool IsEquivalentToImpl(DagEvaluation other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagDeconstructEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private IMethod <DeconstructMethod>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    public IDeclaredElement DeclaredElement { get; }
    public IMethod DeconstructMethod { get; }
    [NullableAttribute("2")]
public ISubstitution Substitution { get; }
    public DagDeconstructEvaluation(IMethod deconstructMethod, ISubstitution substitution, DagTempVariable input);
    public virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public IMethod get_DeconstructMethod();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual ISubstitution get_Substitution();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagEvaluation : DagTest {
    [NullableAttribute("2")]
public IDeclaredElement DeclaredElement { get; }
    [NullableAttribute("2")]
public ISubstitution Substitution { get; }
    protected DagEvaluation(DagTempVariable input);
    [NullableContextAttribute("2")]
public abstract virtual IDeclaredElement get_DeclaredElement();
    [NullableContextAttribute("2")]
public abstract virtual ISubstitution get_Substitution();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsEquivalentTo(DagEvaluation other);
    protected virtual bool IsEquivalentToImpl(DagEvaluation other);
    public virtual bool AreSemanticallyEquivalent(DagTest other);
    public DagTempVariable GetOriginalInput();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagExplicitNullTest : DagTest {
    [NullableContextAttribute("1")]
public DagExplicitNullTest(DagTempVariable input);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagFieldEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    public IDeclaredElement DeclaredElement { get; }
    [NullableAttribute("2")]
public ISubstitution Substitution { get; }
    public DagFieldEvaluation(IField field, ISubstitution substitution, DagTempVariable input);
    [CompilerGeneratedAttribute]
public virtual IDeclaredElement get_DeclaredElement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual ISubstitution get_Substitution();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagIndexerEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private DagTempVariable <LengthTemp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public DagTempVariable LengthTemp { get; }
    public int Index { get; }
    public IType IndexerType { get; }
    public DagIndexerEvaluation(IProperty indexer, ISubstitution indexerSubstitution, DagTempVariable lengthTemp, int index, DagTempVariable input);
    [CompilerGeneratedAttribute]
public virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public virtual ISubstitution get_Substitution();
    [CompilerGeneratedAttribute]
public DagTempVariable get_LengthTemp();
    [CompilerGeneratedAttribute]
public int get_Index();
    public IType get_IndexerType();
    protected virtual bool IsEquivalentToImpl(DagEvaluation other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagIndexEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    public int Index { get; }
    public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public DagIndexEvaluation(IProperty getItemProperty, int index, DagTempVariable valueAsITuple);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public virtual IDeclaredElement get_DeclaredElement();
    public virtual ISubstitution get_Substitution();
    protected virtual bool IsEquivalentToImpl(DagEvaluation other);
    public virtual int GetHashCode();
    public virtual bool AreSemanticallyEquivalent(DagTest other);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagNonNullTest : DagTest {
    [CompilerGeneratedAttribute]
private bool <IsExplicitTest>k__BackingField;
    public bool IsExplicitTest { get; }
    [NullableContextAttribute("1")]
public DagNonNullTest(DagTempVariable input, bool isExplicitTest);
    [CompilerGeneratedAttribute]
public bool get_IsExplicitTest();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagPropertyEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private ITreeNode <TreeNode>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLengthOrCount>k__BackingField;
    public ITreeNode TreeNode { get; public set; }
    [NullableAttribute("1")]
public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public bool IsLengthOrCount { get; }
    [NullableContextAttribute("1")]
public DagPropertyEvaluation(IProperty property, ISubstitution substitution, bool isLengthOrCount, DagTempVariable input);
    [NullableContextAttribute("1")]
public DagPropertyEvaluation(IAnonymousTypeProperty property, ISubstitution substitution, DagTempVariable input);
    [CompilerGeneratedAttribute]
public ITreeNode get_TreeNode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TreeNode(ITreeNode value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public virtual ISubstitution get_Substitution();
    [CompilerGeneratedAttribute]
public bool get_IsLengthOrCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagRelationalTest : DagTest {
    [CompilerGeneratedAttribute]
private ConstantValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueSetOperation <Relation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITreeNode <TreeNode>k__BackingField;
    public ConstantValue Value { get; }
    public ValueSetOperation Relation { get; }
    [NullableAttribute("2")]
public ITreeNode TreeNode { get; }
    public DagRelationalTest(ConstantValue constantValue, ValueSetOperation relation, DagTempVariable input, ITreeNode treeNode);
    [CompilerGeneratedAttribute]
public ConstantValue get_Value();
    [CompilerGeneratedAttribute]
public ValueSetOperation get_Relation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ITreeNode get_TreeNode();
    private bool Equals(DagRelationalTest other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual bool AreSemanticallyEquivalent(DagTest other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagSliceEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private DagTempVariable <LengthTemp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndIndex>k__BackingField;
    public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public DagTempVariable LengthTemp { get; }
    public int StartIndex { get; }
    public int EndIndex { get; }
    public IType SliceType { get; }
    public DagSliceEvaluation(IProperty indexer, ISubstitution indexerSubstitution, DagTempVariable lengthTemp, int startIndex, int endIndex, DagTempVariable input);
    [CompilerGeneratedAttribute]
public virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public virtual ISubstitution get_Substitution();
    [CompilerGeneratedAttribute]
public DagTempVariable get_LengthTemp();
    [CompilerGeneratedAttribute]
public int get_StartIndex();
    [CompilerGeneratedAttribute]
public int get_EndIndex();
    public IType get_SliceType();
    protected virtual bool IsEquivalentToImpl(DagEvaluation other);
    public virtual bool AreSemanticallyEquivalent(DagTest other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CannotApplyEqualityOperatorAttribute]
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagTest : object {
    [CompilerGeneratedAttribute]
private DagTempVariable <Input>k__BackingField;
    public DagTempVariable Input { get; }
    protected DagTest(DagTempVariable input);
    [CompilerGeneratedAttribute]
public DagTempVariable get_Input();
    protected bool Equals(DagTest other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual bool AreSemanticallyEquivalent(DagTest other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagTupleComponentEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private int <ComponentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    public int ComponentIndex { get; }
    public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    [NullableContextAttribute("1")]
public DagTupleComponentEvaluation(DecoratedType`1<TupleTypeDecoration> tupleType, int componentIndex, DagTempVariable input);
    [CompilerGeneratedAttribute]
public int get_ComponentIndex();
    [CompilerGeneratedAttribute]
public virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public virtual ISubstitution get_Substitution();
    [NullableContextAttribute("1")]
protected virtual bool IsEquivalentToImpl(DagEvaluation other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagTypeEvaluation : DagEvaluation {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public IType Type { get; }
    [NullableAttribute("2")]
public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public DagTypeEvaluation(IType type, DagTempVariable input);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [NullableContextAttribute("2")]
public virtual IDeclaredElement get_DeclaredElement();
    public virtual ISubstitution get_Substitution();
    protected virtual bool IsEquivalentToImpl(DagEvaluation other);
    public virtual bool AreSemanticallyEquivalent(DagTest other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagTypeTest : DagTest {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public IType Type { get; }
    public DagTypeTest(IType type, DagTempVariable input);
    [CompilerGeneratedAttribute]
public IType get_Type();
    private bool Equals(DagTypeTest other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool AreSemanticallyEquivalent(DagTest other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DagValueTest : DagTest {
    [CompilerGeneratedAttribute]
private ConstantValue <Value>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITreeNode <TreeNode>k__BackingField;
    public ConstantValue Value { get; }
    [NullableAttribute("2")]
public ITreeNode TreeNode { get; }
    public DagValueTest(ConstantValue constantValue, DagTempVariable input, ITreeNode treeNode);
    [CompilerGeneratedAttribute]
public ConstantValue get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ITreeNode get_TreeNode();
    private bool Equals(DagValueTest other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool AreSemanticallyEquivalent(DagTest other);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.DecisionDagNode : object {
    [NullableContextAttribute("1")]
public abstract virtual bool AreSemanticallyEquivalent(DecisionDagNode other, Dictionary`2<DecisionDagNode, int> indexInDag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.EvaluationDecisionDagNode : DecisionDagNode {
    [CompilerGeneratedAttribute]
private DagEvaluation <Evaluation>k__BackingField;
    [CompilerGeneratedAttribute]
private DecisionDagNode <Next>k__BackingField;
    public DagEvaluation Evaluation { get; }
    public DecisionDagNode Next { get; }
    public EvaluationDecisionDagNode(DagEvaluation dagEvaluation, DecisionDagNode next);
    [CompilerGeneratedAttribute]
public DagEvaluation get_Evaluation();
    [CompilerGeneratedAttribute]
public DecisionDagNode get_Next();
    public EvaluationDecisionDagNode Update(DagEvaluation evaluation, DecisionDagNode next);
    public virtual bool AreSemanticallyEquivalent(DecisionDagNode other, Dictionary`2<DecisionDagNode, int> indexInDag);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.LeafDecisionDagNode : DecisionDagNode {
    public DecisionDagConclusion DecisionDagConclusion;
    public LeafDecisionDagNode(DecisionDagConclusion decisionDagConclusion);
    [NullableContextAttribute("1")]
public virtual bool AreSemanticallyEquivalent(DecisionDagNode other, Dictionary`2<DecisionDagNode, int> indexInDag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.TestDecisionDagNode : DecisionDagNode {
    [CompilerGeneratedAttribute]
private DagTest <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private DecisionDagNode <WhenTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private DecisionDagNode <WhenFalse>k__BackingField;
    public DagTest Test { get; }
    public DecisionDagNode WhenTrue { get; }
    public DecisionDagNode WhenFalse { get; }
    public TestDecisionDagNode(DagTest dagTest, DecisionDagNode whenTrue, DecisionDagNode whenFalse);
    [CompilerGeneratedAttribute]
public DagTest get_Test();
    [CompilerGeneratedAttribute]
public DecisionDagNode get_WhenTrue();
    [CompilerGeneratedAttribute]
public DecisionDagNode get_WhenFalse();
    public TestDecisionDagNode Update(DagTest test, DecisionDagNode whenTrue, DecisionDagNode whenFalse);
    public virtual bool AreSemanticallyEquivalent(DecisionDagNode other, Dictionary`2<DecisionDagNode, int> indexInDag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Nodes.WhenDecisionDagNode : DecisionDagNode {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PatternBinding> <Bindings>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICSharpExpression <WhenClause>k__BackingField;
    [CompilerGeneratedAttribute]
private DecisionDagNode <WhenTrue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DecisionDagNode <WhenFalse>k__BackingField;
    [CompilerGeneratedAttribute]
private DecisionDagConclusion <Conclusion>k__BackingField;
    public IReadOnlyList`1<PatternBinding> Bindings { get; }
    [NullableAttribute("2")]
public ICSharpExpression WhenClause { get; }
    public DecisionDagNode WhenTrue { get; }
    [NullableAttribute("2")]
public DecisionDagNode WhenFalse { get; }
    public DecisionDagConclusion Conclusion { get; }
    public WhenDecisionDagNode(IReadOnlyList`1<PatternBinding> firstBindings, ICSharpExpression whenClause, DecisionDagNode whenTrue, DecisionDagNode whenFalse, DecisionDagConclusion conclusion);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PatternBinding> get_Bindings();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICSharpExpression get_WhenClause();
    [CompilerGeneratedAttribute]
public DecisionDagNode get_WhenTrue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DecisionDagNode get_WhenFalse();
    [CompilerGeneratedAttribute]
public DecisionDagConclusion get_Conclusion();
    public WhenDecisionDagNode Update(IReadOnlyList`1<PatternBinding> bindings, ICSharpExpression whenClause, DecisionDagNode whenTrue, DecisionDagNode whenFalse);
    public virtual bool AreSemanticallyEquivalent(DecisionDagNode other, Dictionary`2<DecisionDagNode, int> indexInDag);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.PatternBinding : object {
    [CompilerGeneratedAttribute]
private ICSharpLocalVariable <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private DagTempVariable <TempContainingValue>k__BackingField;
    [NotNullAttribute]
public ICSharpLocalVariable Variable { get; }
    [NotNullAttribute]
public DagTempVariable TempContainingValue { get; }
    public PatternBinding(ICSharpLocalVariable variable, DagTempVariable input);
    [CompilerGeneratedAttribute]
public ICSharpLocalVariable get_Variable();
    [CompilerGeneratedAttribute]
public DagTempVariable get_TempContainingValue();
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.PatternExplainer : object {
    public static string SamplePatternForPathToDagNode(DagTempVariable rootIdentifier, IReadOnlyList`1<DecisionDagNode> nodes, DecisionDagNode targetNode, bool allowNullInputs, Boolean& requiresFalseWhenClause, Boolean& unnamedEnumValue);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<DecisionDagNode> ShortestPathToNode(IReadOnlyList`1<DecisionDagNode> nodes, DecisionDagNode targetNode, bool allowNullInputs, Boolean& requiresFalseWhenClause);
    private static string SamplePatternForTemp(DagTempVariable input, Dictionary`2<DagTempVariable, List`1<ValueTuple`2<DagTest, bool>>> constraintMap, Dictionary`2<DagTempVariable, List`1<DagEvaluation>> evaluationMap, bool requireExactType, Boolean& unnamedEnumValue);
    [NotNullAttribute]
private static string SampleValueString(IValueSet remainingValues, IType type, bool requireExactType, Boolean& unnamedEnumValue);
    [NotNullAttribute]
private static string ValueString(ConstantValue value, IType type, bool requireExactType);
    [NotNullAttribute]
private static string PrimitiveValueString(ConstantValue value);
    [CompilerGeneratedAttribute]
internal static int <ShortestPathToNode>g__Distance|1_0(DecisionDagNode fromNode, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__TryHandleSingleTest|2_0(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__TryHandleTypeTestAndTypeEvaluation|2_1(Boolean& unnamedEnumValue, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__TryHandleUnboxNullableValueType|2_2(Boolean& unnamedEnumValue, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__TryHandleTuplePattern|2_3(Boolean& unnamedEnumValue, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__TryHandleNumericLimits|2_4(Boolean& unnamedEnumValue, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__TryHandleRecursivePattern|2_5(Boolean& unnamedEnumValue, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__TryHandleListPattern|2_6(Boolean& unnamedEnumValue, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__ProduceFallbackPattern|2_7(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static IValueSet <SamplePatternForTemp>g__ComputeRemainingValues|2_8(IValueSetFactory valueFactory, IReadOnlyList`1<ValueTuple`2<DagTest, bool>> constraints);
    [CompilerGeneratedAttribute]
internal static void <SamplePatternForTemp>g__AddRelation|2_15(ValueSetOperation relation, ConstantValue value, <>c__DisplayClass2_1& , <>c__DisplayClass2_2& );
    [CompilerGeneratedAttribute]
internal static string <SamplePatternForTemp>g__MakeConjunct|2_9(string oldPattern, string newPattern);
    [CompilerGeneratedAttribute]
internal static bool <ValueString>g__TypeHasExactTypeLiteral|4_0(IType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.StateForCase : object {
    public int Index;
    public DecisionDagConclusion DecisionDagConclusion;
    public Tests RemainingTests;
    public IReadOnlyList`1<PatternBinding> Bindings;
    [NullableAttribute("2")]
public ICSharpExpression GuardClauseExpression;
    public bool PatternIsSatisfied { get; }
    public bool IsImpossible { get; }
    public StateForCase(int index, Tests remainingTests, IReadOnlyList`1<PatternBinding> bindings, ICSharpExpression guardClauseExpression, DecisionDagConclusion decisionDagConclusion);
    public bool IsFullyMatched(IResolveContext resolveContext);
    public bool get_PatternIsSatisfied();
    public bool get_IsImpossible();
    public StateForCase WithRemainingTests(Tests newRemainingTests);
    public StateForCase RewriteNestedLengthTests();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(StateForCase other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.Tests : object {
    public abstract virtual void Filter(DecisionDagBuilder builder, DagTest test, DagState dagState, IValueSet whenTrueValues, IValueSet whenFalseValues, Tests& whenTrue, Tests& whenFalse, Boolean& foundExplicitNullTest);
    public virtual DagTest ComputeSelectedTest();
    public virtual Tests RemoveEvaluation(DagEvaluation e);
    public virtual Tests RewriteNestedLengthTests();
    public abstract virtual string Dump(Func`2<DagTest, string> dump);
    private static ValueTuple`2<DagTempVariable, int> TryGetTopLevelLengthTemp(DagPropertyEvaluation e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.ValueSetFactory : object {
    internal static IValueSetFactory`1<byte> ForByte;
    internal static IValueSetFactory`1<sbyte> ForSByte;
    internal static IValueSetFactory`1<char> ForChar;
    internal static IValueSetFactory`1<short> ForShort;
    internal static IValueSetFactory`1<ushort> ForUShort;
    internal static IValueSetFactory`1<int> ForInt;
    internal static IValueSetFactory`1<UInt32> ForUInt;
    internal static IValueSetFactory`1<long> ForLong;
    internal static IValueSetFactory`1<ulong> ForULong;
    internal static IValueSetFactory`1<bool> ForBool;
    internal static IValueSetFactory`1<float> ForFloat;
    internal static IValueSetFactory`1<double> ForDouble;
    internal static IValueSetFactory`1<string> ForString;
    internal static IValueSetFactory`1<decimal> ForDecimal;
    internal static IValueSetFactory`1<int> ForNint;
    internal static IValueSetFactory`1<UInt32> ForNuint;
    internal static IValueSetFactory`1<int> ForLength;
    private static ValueSetFactory();
    public static IValueSetFactory ForSpecialType(IType type, PredefinedType predefinedType, bool isNative);
    public static IValueSetFactory ForType(IType type, PredefinedType predefinedType);
    public static IValueSetFactory ForInput(DagTempVariable input, PredefinedType predefinedType);
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.DecisionDag.ValueSetOperation : Enum {
    public int value__;
    public static ValueSetOperation Equal;
    public static ValueSetOperation NotEqual;
    public static ValueSetOperation GreaterThan;
    public static ValueSetOperation LessThan;
    public static ValueSetOperation GreaterThanOrEqual;
    public static ValueSetOperation LessThanOrEqual;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {Components.Count}")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Deconstruction.DeconstructionByDeconstructMethod : object {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IDeconstructionComponent> <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethod <DeconstructMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <MethodSubstitution>k__BackingField;
    public IType Type { get; }
    public IReadOnlyList`1<IDeconstructionComponent> Components { get; }
    public IMethod DeconstructMethod { get; }
    public ISubstitution MethodSubstitution { get; }
    public DeconstructionByDeconstructMethod(IType type, IReadOnlyList`1<IDeconstructionComponent> components, IMethod deconstructMethod, ISubstitution methodSubstitution);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IDeconstructionComponent> get_Components();
    [CompilerGeneratedAttribute]
public IMethod get_DeconstructMethod();
    [CompilerGeneratedAttribute]
public ISubstitution get_MethodSubstitution();
    public sealed virtual bool IsValid();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {Components.Count}")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Deconstruction.DeconstructionFromTupleType : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private DecoratedType`1<TupleTypeDecoration> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IDeconstructionComponent> <Components>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DecoratedType`1<TupleTypeDecoration> Type { get; }
    public IReadOnlyList`1<IDeconstructionComponent> Components { get; }
    [DebuggerBrowsableAttribute("0")]
private IType JetBrains.ReSharper.Psi.Util.Deconstruction.IDeconstructionComponent.Type { get; }
    public DeconstructionFromTupleType(DecoratedType`1<TupleTypeDecoration> type, IReadOnlyList`1<IDeconstructionComponent> components);
    [CompilerGeneratedAttribute]
public DecoratedType`1<TupleTypeDecoration> get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IDeconstructionComponent> get_Components();
    private sealed virtual override IType JetBrains.ReSharper.Psi.Util.Deconstruction.IDeconstructionComponent.get_Type();
    public sealed virtual bool IsValid();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Util.Deconstruction.DeconstructionIndex : ValueType {
    public int Position;
    [CanBeNullAttribute]
public ResolveResultWithInfo DeconstructionResolveResult;
    public bool IsDeconstruction { get; }
    private DeconstructionIndex(int position, ResolveResultWithInfo deconstructionMethod);
    public bool get_IsDeconstruction();
    [PureAttribute]
public static DeconstructionIndex Create(int index, IDeconstructionReference deconstructionReference, IResolveContext resolveContext);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.Deconstruction.DeconstructionNavigationUtil : object {
    [CanBeNullAttribute]
public static ICSharpExpression TryFindInitializationExpression(IVariableDesignation variableDesignation);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("=> null, rootAssignmentExpression:canbenull; => notnull, rootAssignmentExpression:notnull")]
public static ICSharpExpression TryFindInitializationExpression(IVariableDesignation variableDesignation, IResolveContext resolveContext, IAssignmentExpression& rootAssignmentExpression);
    [CanBeNullAttribute]
public static ICSharpExpression TryFindInitializationExpression(ITupleComponent tupleComponent);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("=> null, rootAssignmentExpression:canbenull; => notnull, rootAssignmentExpression:notnull")]
public static ICSharpExpression TryFindInitializationExpression(ITupleComponent tupleComponent, IResolveContext resolveContext, IAssignmentExpression& rootAssignmentExpression);
    [PureAttribute]
[CanBeNullAttribute]
public static ICSharpTreeNode TryFindDestination(ITupleComponent tupleComponent);
    [PureAttribute]
public static DeconstructionPartIndices GetPositionInDeconstruction(IVariableDesignation designation, IResolveContext resolveContext);
    [PureAttribute]
public static DeconstructionPartIndices GetPositionInDeconstruction(ICSharpExpression topmostExpression, IResolveContext resolveContext);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static ICSharpExpression FindDeconstructionSourceExpression(ICSharpExpression declarationRoot);
    [PureAttribute]
public static Nullable`1<DeconstructionPartIndices> FindExpressionInTuple(DeconstructionPartIndices deconstructionPartIndices);
    [PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<DeconstructionIndex> GetPositionInDeconstruction(ITupleTypeComponent tupleTypeComponent, ITupleTypeUsage& topmostTypeUsage);
    [NotNullAttribute]
[PureAttribute]
public static IExpressionType FindSourceComponentType(IExpressionType topmostExpressionType, IReadOnlyList`1<DeconstructionIndex> indices);
    [PureAttribute]
public static Nullable`1<TupleExpressionTypeComponent> FindTupleTypeComponent(IExpressionType topmostExpressionType, IReadOnlyList`1<DeconstructionIndex> indices);
    [PureAttribute]
private static DeconstructionPartIndices GetSubtreeIndices(DeconstructionPartIndices source, ICSharpExpression subtreeRoot, int subtreeDepth);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<ICSharpExpression, LocalList`1<int>> <TryFindDestination>g__GetPositionInSource|4_0(ITupleComponent tupleComponent);
    [CompilerGeneratedAttribute]
internal static ICSharpTreeNode <TryFindDestination>g__GetDestinationByIndicies|4_1(ICSharpTreeNode node, LocalList`1<int> indicies);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Util.Deconstruction.DeconstructionPartIndices : ValueType {
    [NotNullAttribute]
public ICSharpExpression TopmostExpression;
    [NotNullAttribute]
public IReadOnlyList`1<DeconstructionIndex> Indices;
    public DeconstructionPartIndices(ICSharpExpression topmostExpression, IReadOnlyList`1<DeconstructionIndex> indices);
}
[DebuggerDisplayAttribute("{ExplicitName}:{Type}")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Deconstruction.SingleVariableDeconstructionComponent : object {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <SourceElement>k__BackingField;
    public IType Type { get; }
    [CanBeNullAttribute]
public string ExplicitName { get; }
    [CanBeNullAttribute]
public IDeclaredElement SourceElement { get; }
    public SingleVariableDeconstructionComponent(IType type, string explicitName, IDeclaredElement sourceElement);
    public SingleVariableDeconstructionComponent(TupleTypeComponent component);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public string get_ExplicitName();
    [CompilerGeneratedAttribute]
public IDeclaredElement get_SourceElement();
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.DeconstructionUsageSearcher : object {
    public static Deconstructions Process(IFile psiFile);
    [PureAttribute]
private static int LookaheadNextNonWhitespaceToken(CachingLexer lexer);
    [PureAttribute]
private static int GetClosingBraceTokenIndex(int nodeTypeIndex);
    [PureAttribute]
private static byte ComponentsCountToMask(int componentsCount);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.DefaultUsagesProvider : object {
    [NotNullAttribute]
public static DefaultUsagesProvider Instance;
    private static DefaultUsagesProvider();
    public sealed virtual IEnumerable`1<ITreeNode> GetUsages(IDeclaredElement declaredElement, ITreeNode scope);
    public sealed virtual IEnumerable`1<ITreeNode> GetUsages(IDeclaredElement declaredElement, IEnumerable`1<ITreeNode> scope);
    public sealed virtual IEnumerable`1<ITreeNode> GetUsages(ICollection`1<TDeclaredElement> declaredElements, ITreeNode scope);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.EnumFieldByConstantValueEqualityComparer : object {
    public static IEqualityComparer`1<IField> Instance;
    private static EnumFieldByConstantValueEqualityComparer();
    public sealed virtual bool Equals(IField x, IField y);
    public sealed virtual int GetHashCode(IField field);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.GeneratedAndCanBeIgnoredMethodsDetector : object {
    [PureAttribute]
public static bool IsGeneratedAndCanBeIgnoredMethod(string name);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsGeneratedAndCanBeIgnoredStatement(ITreeNode element);
    [PureAttribute]
public static bool IsGeneratedAndCanBeIgnoredExpression(ICSharpExpression expression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Util.IApiInformationTypeMemberReference {
}
public interface JetBrains.ReSharper.Psi.CSharp.Util.ICSharpStringLiteralAlterer {
    [NotNullAttribute]
public ICSharpLiteralExpression LiteralExpression { get; }
    public CSharpLiteralType LiteralType { get; }
    public StringVerbatimity PresentationForm { get; }
    public bool IsValid { get; }
    public abstract virtual ICSharpLiteralExpression get_LiteralExpression();
    public abstract virtual CSharpLiteralType get_LiteralType();
    public abstract virtual StringVerbatimity get_PresentationForm();
    public abstract virtual bool get_IsValid();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICSharpStringLiteralAlterer Concat(ICSharpStringLiteralAlterer other);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.IfStatementUtil : object {
    [PureAttribute]
public static bool HasInnerEmbeddedIfStatementWithoutElse(ICSharpStatement statement, bool processBlocks);
    [PureAttribute]
public static bool IsEmbeddedIntoThenBodyOfContainingIfStatementWithElse(ICSharpStatement statement, bool processBlocks);
}
public interface JetBrains.ReSharper.Psi.CSharp.Util.ILocalFunctionDataCollector`2 {
    [NotNullAttribute]
public ILocalFunction LocalFunction { get; }
    public abstract virtual ILocalFunction get_LocalFunction();
    [NotNullAttribute]
public abstract virtual TLocalFunctionInfo RunLocalFunctionDataCollection(ILocalFunctionDeclaration declaration, TContext context);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.ImplementationFinder : object {
    private IDeclaredType myType;
    private IDeclaredType myInterfaceType;
    public ImplementationFinder(IDeclaredType lowestType, IDeclaredType interfaceType);
    [CanBeNullAttribute]
public static DeclaredElementInstance FindImplementation(IOverridableMember member, ISubstitution substitution, IDeclaredType lowestType, IPsiModule module);
    private IList`1<ValueTuple`2<ITypeElement, bool>> PrepareSuperClasses();
    private bool ImplementsMyInterface(IDeclaredType type);
    private bool IsMyInterface(IDeclaredType type);
    private OneToListMap`2<ITypeElement, ISymbolInfo> PrepareInfos(List`1<ISymbolInfo> candidates);
    [CanBeNullAttribute]
private ISymbolInfo FindImplementationOverride(List`1<ISymbolInfo> candidates);
    private bool IsOther(ISymbolInfo info);
    private bool IsOverriden(ISymbolInfo info);
    private bool IsImplicitImplementation(ISymbolInfo info);
    private bool IsExplicitImplementation(ISymbolInfo info);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.IndexUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static IIndexInfo GetIndexInfo(ICSharpExpression expression);
    [NotNullAttribute]
[PureAttribute]
public static IIndexInfo GetIndexInfo(ICSharpExpression expression, PredefinedType predefinedType, ICSharpTypeConversionRule typeConversionRule);
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.InlineArrayElementTypeVerificationResult : Enum {
    public int value__;
    public static InlineArrayElementTypeVerificationResult OK;
    public static InlineArrayElementTypeVerificationResult CANNOT_BE_TYPE_ARGUMENT;
    public static InlineArrayElementTypeVerificationResult REF_TYPE_MEMBER;
    public static InlineArrayElementTypeVerificationResult NOT_EXACTLY_ONE_FIELD;
}
public class JetBrains.ReSharper.Psi.CSharp.Util.InsertionAnchorResult : object {
    [CompilerGeneratedAttribute]
private BeforeOrAfter <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IClassMemberDeclaration <Declaration>k__BackingField;
    public BeforeOrAfter Type { get; }
    public IClassMemberDeclaration Declaration { get; }
    public InsertionAnchorResult(BeforeOrAfter type, IClassMemberDeclaration declaration);
    [CompilerGeneratedAttribute]
public sealed virtual BeforeOrAfter get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IClassMemberDeclaration get_Declaration();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Util.IntegerLiteralSuffix : Enum {
    public int value__;
    public static IntegerLiteralSuffix None;
    public static IntegerLiteralSuffix Unsigned;
    public static IntegerLiteralSuffix Long;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.InvocationExpressionUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSkippedByCompiler(ResolveResultWithInfo resolveResult, IInvocationExpression invocationExpression);
    [PureAttribute]
private static bool IsExpressionValueCanBeIgnored(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSkippedPartialMethod(ResolveResultWithInfo resolveResult, bool includeErrors);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsConditionalFunction(ResolveResultWithInfo resolveResult, ITreeNode context);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSkippedConditionalFunction(ResolveResultWithInfo resolveResult, ITreeNode context);
    [PureAttribute]
private static bool HasConditionalSymbolDefined(IReadOnlyList`1<string> conditionalSymbols, ITreeNode context);
    [PureAttribute]
private static bool IsPartialMethodWithoutDefinition(IMethod method);
    [PureAttribute]
[CanBeNullAttribute]
public static ExtensionInstance`1<IMethod> GetInvokedMethod(IInvocationExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLocalFunctionInvocation(IInvocationExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.IteratorUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsIterator(ICSharpDeclaration declaration);
}
public interface JetBrains.ReSharper.Psi.CSharp.Util.IUsagesProvider {
    [MustUseReturnValueAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<ITreeNode> GetUsages(IDeclaredElement declaredElement, ITreeNode scope);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<ITreeNode> GetUsages(IDeclaredElement declaredElement, IEnumerable`1<ITreeNode> scope);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<ITreeNode> GetUsages(ICollection`1<TDeclaredElement> declaredElements, ITreeNode scope);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.Literals.<CSharpLiteralTypeUtil>F48038B535922E130E841C61B0D6D261DCCB7EA72723A47938317C3A146FE96E7__BorderInfoProcessor : CSharpLiteralTypeProcessorBase`2<ITokenNode, BorderInfo> {
    private bool myIncludeDollarAndAtSigns;
    public static <CSharpLiteralTypeUtil>F48038B535922E130E841C61B0D6D261DCCB7EA72723A47938317C3A146FE96E7__BorderInfoProcessor InstanceWithDollarAndAtSigns;
    public static <CSharpLiteralTypeUtil>F48038B535922E130E841C61B0D6D261DCCB7EA72723A47938317C3A146FE96E7__BorderInfoProcessor InstanceWithoutDollarAndAtSigns;
    private <CSharpLiteralTypeUtil>F48038B535922E130E841C61B0D6D261DCCB7EA72723A47938317C3A146FE96E7__BorderInfoProcessor(bool includeDollarAndAtSigns);
    private static <CSharpLiteralTypeUtil>F48038B535922E130E841C61B0D6D261DCCB7EA72723A47938317C3A146FE96E7__BorderInfoProcessor();
    private static BorderInfo Create(ITokenNode tokenNode, int startOffset, int startLength, int endOffset, int endLength);
    protected virtual BorderInfo ProcessLiteralType(CSharpLiteralType literalType, ITokenNode context);
    public virtual BorderInfo ProcessRegularString(RegularStringLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessVerbatimString(VerbatimStringLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessRegularInterpolatedString(RegularInterpolatedStringLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessVerbatimInterpolatedString(VerbatimInterpolatedStringLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessRegularInterpolatedStringStart(RegularInterpolatedStringStartLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessRegularInterpolatedStringMiddle(RegularInterpolatedStringMiddleLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessRegularInterpolatedStringEnd(RegularInterpolatedStringEndLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessVerbatimInterpolatedStringStart(VerbatimInterpolatedStringStartLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessVerbatimInterpolatedStringMiddle(VerbatimInterpolatedStringMiddleLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessVerbatimInterpolatedStringEnd(VerbatimInterpolatedStringEndLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessSingleLineRawString(SingleLineRawStringLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessMultiLineRawString(MultiLineRawStringLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessSingleLineRawInterpolatedStringStart(SingleLineRawInterpolatedStringStartLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessSingleLineRawInterpolatedStringEnd(SingleLineRawInterpolatedStringEndLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessMultiLineRawInterpolatedStringStart(MultiLineRawInterpolatedStringStartLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessMultiLineRawInterpolatedStringEnd(MultiLineRawInterpolatedStringEndLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessRawInterpolatedStringInsertStart(RawInterpolatedStringInsertStartLiteral literalType, ITokenNode context);
    public virtual BorderInfo ProcessRawInterpolatedStringInsertEnd(RawInterpolatedStringInsertEndLiteral literalType, ITokenNode context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CSharp.Util.Literals.<CSharpLiteralTypeUtil>F48038B535922E130E841C61B0D6D261DCCB7EA72723A47938317C3A146FE96E7__RegularVerbatimLiteralTypeInversion : CSharpLiteralTypeProcessorBase`2<Unit, CSharpLiteralType> {
    public static <CSharpLiteralTypeUtil>F48038B535922E130E841C61B0D6D261DCCB7EA72723A47938317C3A146FE96E7__RegularVerbatimLiteralTypeInversion Instance;
    private static <CSharpLiteralTypeUtil>F48038B535922E130E841C61B0D6D261DCCB7EA72723A47938317C3A146FE96E7__RegularVerbatimLiteralTypeInversion();
    public virtual CSharpLiteralType ProcessRegularString(RegularStringLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessVerbatimString(VerbatimStringLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessRegularInterpolatedString(RegularInterpolatedStringLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessVerbatimInterpolatedString(VerbatimInterpolatedStringLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessRegularInterpolatedStringStart(RegularInterpolatedStringStartLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessRegularInterpolatedStringMiddle(RegularInterpolatedStringMiddleLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessRegularInterpolatedStringEnd(RegularInterpolatedStringEndLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessRegularInterpolatedFormat(RegularInterpolatedFormatLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessVerbatimInterpolatedStringStart(VerbatimInterpolatedStringStartLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessVerbatimInterpolatedStringMiddle(VerbatimInterpolatedStringMiddleLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessVerbatimInterpolatedStringEnd(VerbatimInterpolatedStringEndLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessVerbatimInterpolatedFormat(VerbatimInterpolatedFormatLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessSingleLineRawString(SingleLineRawStringLiteral literalType, Unit context);
    public virtual CSharpLiteralType ProcessMultiLineRawString(MultiLineRawStringLiteral literalType, Unit context);
    private static CSharpLiteralType ProcessRawStringLiteral(CSharpLiteralType literalType);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CharacterEscaper : CSharpLiteralEscaper {
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <languageLevel>P;
    public CharacterEscaper(CSharpLanguageLevel languageLevel);
    [NullableContextAttribute("1")]
public virtual string PresentChar(char value);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpInjectedBufferWrapper : InjectedLanguageBufferWrapper {
    [CompilerGeneratedAttribute]
private CSharpLiteralType <LiteralType>k__BackingField;
    public CSharpLiteralType LiteralType { get; }
    public CSharpInjectedBufferWrapper(IBuffer originalBuffer, CSharpLiteralType literalType);
    [CompilerGeneratedAttribute]
public CSharpLiteralType get_LiteralType();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpInjectedLanguageLexerFactory : object {
    private ILexerFactory myOriginalFactory;
    public CSharpInjectedLanguageLexerFactory(ILexerFactory originalFactory);
    public sealed virtual ILexer CreateLexer(IBuffer buffer);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpInjectedLanguageLexerWithTranslation : InjectedLanguageLexerWithTranslationBase {
    private ILexerFactory myOriginalFactory;
    private static string Border;
    public CSharpInjectedLanguageLexerWithTranslation(ILexerFactory originalFactory, IBuffer originalBuffer);
    [CanBeNullAttribute]
private static CSharpLiteralType GuessLiteralTypeFromBuffer(IBuffer originalBuffer);
    protected virtual ILexer CreateRawLexer(IBuffer originalBuffer, RangeTranslator& rangeTranslator);
    protected ILexer CreateNativeLexer(IBuffer buffer);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpInterpolatedLiteralInjectionTarget : object {
    [NotNullAttribute]
private CSharpLiteralInjectionTarget myBaseInjectionTarget;
    [NotNullAttribute]
private NodeTypeSet myAllowedTokens;
    public PsiLanguageType Language { get; }
    public bool SupportsRegeneration { get; }
    public Char[] LiteralBorderCharacters { get; }
    public CSharpInterpolatedLiteralInjectionTarget(CSharpLiteralInjectionTarget baseInjectionTarget);
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual bool get_SupportsRegeneration();
    public sealed virtual Char[] get_LiteralBorderCharacters();
    public static ValueTuple`2<ITokenNode, ITokenNode> GetTargetTokens(ITreeNode originalNode);
    public sealed virtual ILexerFactory CreateLexerFactory(LanguageService languageService);
    public sealed virtual IBuffer CreateBuffer(ITreeNode originalNode, string text, object options);
    public sealed virtual bool ShouldInjectByAnnotation(ITreeNode originalNode, String& prefix, String& suffix);
    public sealed virtual int GetStartOffsetForString(ITreeNode originalNode);
    public sealed virtual int GetEndOffsetForString(ITreeNode originalNode);
    public sealed virtual ITreeNode UpdateNode(IFile generatedFile, ITreeNode generatedNode, ITreeNode originalNode, Int32& length, string prefix, string suffix, int startOffset, int endOffset);
    public sealed virtual TreeTextRange FixValueRangeForLiteral(ITreeNode element);
    public sealed virtual bool IsPrimaryLanguageApplicable(IPsiSourceFile sourceFile);
    public sealed virtual InjectableLiteralsPresence ContainsInjectableLiterals(ITreeNode element);
    public sealed virtual bool IsInjectionAllowed(ITreeNode literalNode);
    public sealed virtual bool IsInjectionAllowed(TokenNodeType tokenType);
    public sealed virtual bool AllowsLineBreaks(ITreeNode originalNode);
    public sealed virtual bool IsWhitespaceToken(ITokenNode token);
    public sealed virtual string GetCorrespondingCommentTextForLiteral(ITreeNode originalNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralEscaper : object {
    public abstract virtual string PresentChar(char value);
    public virtual string Escape(string value);
    public static CSharpLiteralEscaper GetForStringLiteral(StringVerbatimity verbatimity, CSharpLanguageLevel languageLevel);
    public static CSharpLiteralEscaper GetForInterpolatedString(StringVerbatimity verbatimity, CSharpLanguageLevel languageLevel);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralInjectionTarget : CSharpLiteralInjectionTargetBase {
    private static NodeTypeSet ourAllowedLiterals;
    private static CSharpLiteralInjectionTarget();
    protected virtual ITreeNode UpdateText(ITreeNode originalNode, string newText, Int32& length);
    protected virtual ITokenNode GetTargetToken(ITreeNode originalNode);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralInjectionTargetBase : object {
    [CompilerGeneratedAttribute]
private Char[] <LiteralBorderCharacters>k__BackingField;
    protected NodeTypeSet AllowedTokens;
    public Char[] LiteralBorderCharacters { get; }
    public bool SupportsRegeneration { get; }
    public PsiLanguageType Language { get; }
    protected CSharpLiteralInjectionTargetBase(NodeTypeSet allowedTokens);
    protected abstract virtual ITokenNode GetTargetToken(ITreeNode originalNode);
    protected abstract virtual ITreeNode UpdateText(ITreeNode originalNode, string newText, Int32& length);
    public sealed virtual bool IsInjectionAllowed(ITreeNode literalNode);
    public sealed virtual bool IsInjectionAllowed(TokenNodeType tokenType);
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_LiteralBorderCharacters();
    public sealed virtual IBuffer CreateBuffer(ITreeNode originalNode, string text, object options);
    public sealed virtual ITreeNode UpdateNode(IFile generatedFile, ITreeNode generatedNode, ITreeNode originalNode, Int32& length, string prefix, string suffix, int startOffset, int endOffset);
    public sealed virtual bool ShouldInjectByAnnotation(ITreeNode originalNode, String& prefix, String& suffix);
    public sealed virtual int GetStartOffsetForString(ITreeNode originalNode);
    public sealed virtual int GetEndOffsetForString(ITreeNode originalNode);
    public sealed virtual string GetCorrespondingCommentTextForLiteral(ITreeNode originalNode);
    public sealed virtual bool get_SupportsRegeneration();
    public sealed virtual InjectableLiteralsPresence ContainsInjectableLiterals(ITreeNode element);
    public sealed virtual bool IsPrimaryLanguageApplicable(IPsiSourceFile sourceFile);
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual ILexerFactory CreateLexerFactory(LanguageService languageService);
    public sealed virtual bool IsWhitespaceToken(ITokenNode token);
    public sealed virtual bool AllowsLineBreaks(ITreeNode originalNode);
    public sealed virtual TreeTextRange FixValueRangeForLiteral(ITreeNode element);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralInjectionUtil : object {
    public static ILexerFactory CreateLexerFactory(ILexerFactory originalFactory);
    public static bool CanBePartOfQuotes(char c);
    public static bool IsWhitespace(ITokenNode token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralType : object {
    private static string Indent0;
    private static string Indent1;
    private static string Indent2;
    private static string Indent3;
    private static string Indent4;
    private static string Indent5;
    private static string Indent6;
    private static string Indent7;
    private static string Indent8;
    private static string Indent9;
    private static string Indent10;
    private static string Indent11;
    private static string Indent12;
    private static string Indent13;
    private static string Indent14;
    private static string Indent15;
    private static string Indent16;
    private static string Indent17;
    private static string Indent18;
    private static string Indent19;
    private static string Indent20;
    private static string TripleQuotes;
    public static CompiledStringLiteral CompiledString;
    public static CharacterLiteral Character;
    public static RegularStringLiteral RegularString;
    public static RegularStringLiteral RegularStringUtf8Lowercase;
    public static RegularStringLiteral RegularStringUtf8Uppercase;
    public static VerbatimStringLiteral VerbatimString;
    public static VerbatimStringLiteral VerbatimStringUtf8Lowercase;
    public static VerbatimStringLiteral VerbatimStringUtf8Uppercase;
    public static RegularInterpolatedStringLiteral RegularInterpolatedString;
    public static VerbatimInterpolatedStringLiteral VerbatimInterpolatedString;
    public static VerbatimInterpolatedStringLiteral VerbatimInterpolatedStringWithAlternativePrefix;
    public static RegularInterpolatedStringStartLiteral RegularInterpolatedStringStart;
    public static RegularInterpolatedStringMiddleLiteral RegularInterpolatedStringMiddle;
    public static RegularInterpolatedStringEndLiteral RegularInterpolatedStringEnd;
    public static VerbatimInterpolatedStringStartLiteral VerbatimInterpolatedStringStart;
    public static VerbatimInterpolatedStringStartLiteral VerbatimInterpolatedStringStartWithAlternativePrefix;
    public static VerbatimInterpolatedStringMiddleLiteral VerbatimInterpolatedStringMiddle;
    public static VerbatimInterpolatedStringEndLiteral VerbatimInterpolatedStringEnd;
    public static RegularInterpolatedFormatLiteral RegularInterpolatedFormat;
    public static VerbatimInterpolatedFormatLiteral VerbatimInterpolatedFormat;
    public static RawInterpolatedStringFormatLiteral RawInterpolatedStringFormat;
    private static SingleLineRawStringLiteral ourSingleLineRawStringTripleQuotes;
    private static string CrLf;
    private static string TripleQuotesCrLf;
    private static Dictionary`2<string, MultiLineRawStringLiteral> ourMultiLineRawStringWithTripleQuotes;
    private static SingleLineRawInterpolatedStringStartLiteral ourSingleLineRawInterpolatedStringStartDollarTripleQuotes;
    private static SingleLineRawInterpolatedStringStartLiteral ourSingleLineRawInterpolatedStringStartDoubleDollarTripleQuotes;
    private static MultiLineRawInterpolatedStringStartLiteral ourMultiLineRawInterpolatedStringStartDollarTripleQuotes;
    private static MultiLineRawInterpolatedStringStartLiteral ourMultiLineRawInterpolatedStringStartDoubleDollarTripleQuotes;
    private static SingleLineRawInterpolatedStringEndLiteral ourSingleLineRawInterpolatedStringEndTripleQuotes;
    private static Dictionary`2<string, MultiLineRawInterpolatedStringEndLiteral> ourMultiLineRawInterpolatedStringEndTripleQuotes;
    private static RawInterpolatedStringInsertStartLiteral ourRawInsertStartSingleOpenBrace;
    private static RawInterpolatedStringInsertStartLiteral ourRawInsertStartDoubleOpenBrace;
    private static RawInterpolatedStringInsertEndLiteral ourRawInsertEndSingleOpenBrace;
    private static RawInterpolatedStringInsertEndLiteral ourRawInsertEndDoubleOpenBrace;
    public Utf8Suffix Utf8Suffix { get; }
    public bool IsUtf8 { get; }
    public bool IsInterpolatedString { get; }
    public bool IsInterpolationFormatSpecifier { get; }
    public StringVerbatimity Verbatimity { get; }
    public int QuoteCount { get; }
    public string StartBorder { get; }
    public string EndBorder { get; }
    public int StartBorderLength { get; }
    public int EndBorderLength { get; }
    public TokenNodeType TokenType { get; }
    private static CSharpLiteralType();
    public abstract virtual Utf8Suffix get_Utf8Suffix();
    public bool get_IsUtf8();
    public abstract virtual bool get_IsInterpolatedString();
    public virtual bool get_IsInterpolationFormatSpecifier();
    public abstract virtual StringVerbatimity get_Verbatimity();
    public abstract virtual int get_QuoteCount();
    public abstract virtual string get_StartBorder();
    public abstract virtual string get_EndBorder();
    public int get_StartBorderLength();
    public int get_EndBorderLength();
    public abstract virtual TokenNodeType get_TokenType();
    public abstract virtual CSharpLiteralEscaper GetEscaper(CSharpLanguageLevel languageLevel);
    [PureAttribute]
public abstract virtual ICSharpStringLexer CreateLexer(IBuffer buffer);
    [NullableContextAttribute("2")]
[PureAttribute]
public abstract virtual TResult Process(ICSharpLiteralTypeProcessor`2<TContext, TResult> processor, TContext context);
    [PureAttribute]
public string TrimBorders(string text);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual CSharpLiteralType TryGetInterpolatedVariant();
    [NullableContextAttribute("2")]
public virtual bool Equals(CSharpLiteralType other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(CSharpLiteralType x, CSharpLiteralType y);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CSharpLiteralType x, CSharpLiteralType y);
    public virtual string ToString();
    [PureAttribute]
public static SingleLineRawStringLiteral CreateSingleLineRawString(string delimiter, Utf8Suffix utf8Suffix);
    [PureAttribute]
public static MultiLineRawStringLiteral CreateMultiLineRawString(int quoteCount, string startBorderWithFirstLineBreak, string endBorderFromLastLineBreak);
    [PureAttribute]
public static SingleLineRawInterpolatedStringStartLiteral CreateSingleLineRawInterpolatedStringStart(int dollarSignCount, int quoteCount, string startDelimiter);
    [PureAttribute]
public static MultiLineRawInterpolatedStringStartLiteral CreateMultiLineRawInterpolatedStringStart(int dollarSignCount, int quoteCount, string startBorderWithFirstLineBreak);
    [PureAttribute]
public static SingleLineRawInterpolatedStringEndLiteral CreateSingleLineRawInterpolatedStringEnd(int quoteCount, string endDelimiter);
    [PureAttribute]
public static MultiLineRawInterpolatedStringEndLiteral CreateMultiLineRawInterpolatedStringEnd(int quoteCount, string endBorderFromLastLineBreak);
    [PureAttribute]
public static RawInterpolatedStringInsertStartLiteral CreateRawInterpolatedStringInsertStart(string insertStart);
    [PureAttribute]
public static RawInterpolatedStringInsertEndLiteral CreateRawInterpolatedStringInsertEnd(string insertEnd);
    [PureAttribute]
public static RawInterpolatedStringTextLiteral CreateRawInterpolatedStringText(ITokenNode tokenNode);
    [PureAttribute]
public static RawInterpolatedStringTextLiteral CreateRawInterpolatedStringText(CachingLexer lexer);
    private static bool TryGetRawInterpolatedStringInfoFromStartToken(ITokenNode tokenNode, Boolean& hasInsertsBefore, RawInterpolatedStringInfo& info);
    private static bool TryGetRawInterpolatedStringInfoFromStartToken(CachingLexer lexer, Boolean& hasInsertsBefore, RawInterpolatedStringInfo& info);
    private static ITokenNode TryGetRawInterpolatedStringEndToken(ITokenNode tokenNode);
    private static string TryGetRawInterpolatedStringEndTokenText(ITokenNode tokenNode);
    private static string TryGetRawInterpolatedStringEndTokenText(CachingLexer lexer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralTypeProcessorBase`2 : object {
    protected virtual TResult ProcessLiteralType(CSharpLiteralType literalType, TContext context);
    public virtual TResult ProcessCompiledString(CompiledStringLiteral literalType, TContext context);
    public virtual TResult ProcessCharacter(CharacterLiteral literalType, TContext context);
    public virtual TResult ProcessRegularString(RegularStringLiteral literalType, TContext context);
    public virtual TResult ProcessVerbatimString(VerbatimStringLiteral literalType, TContext context);
    public virtual TResult ProcessRegularInterpolatedString(RegularInterpolatedStringLiteral literalType, TContext context);
    public virtual TResult ProcessVerbatimInterpolatedString(VerbatimInterpolatedStringLiteral literalType, TContext context);
    public virtual TResult ProcessRegularInterpolatedStringStart(RegularInterpolatedStringStartLiteral literalType, TContext context);
    public virtual TResult ProcessRegularInterpolatedStringMiddle(RegularInterpolatedStringMiddleLiteral literalType, TContext context);
    public virtual TResult ProcessRegularInterpolatedStringEnd(RegularInterpolatedStringEndLiteral literalType, TContext context);
    public virtual TResult ProcessRegularInterpolatedFormat(RegularInterpolatedFormatLiteral literalType, TContext context);
    public virtual TResult ProcessVerbatimInterpolatedStringStart(VerbatimInterpolatedStringStartLiteral literalType, TContext context);
    public virtual TResult ProcessVerbatimInterpolatedStringMiddle(VerbatimInterpolatedStringMiddleLiteral literalType, TContext context);
    public virtual TResult ProcessVerbatimInterpolatedStringEnd(VerbatimInterpolatedStringEndLiteral literalType, TContext context);
    public virtual TResult ProcessVerbatimInterpolatedFormat(VerbatimInterpolatedFormatLiteral literalType, TContext context);
    public virtual TResult ProcessSingleLineRawString(SingleLineRawStringLiteral literalType, TContext context);
    public virtual TResult ProcessMultiLineRawString(MultiLineRawStringLiteral literalType, TContext context);
    public virtual TResult ProcessSingleLineRawInterpolatedStringStart(SingleLineRawInterpolatedStringStartLiteral literalType, TContext context);
    public virtual TResult ProcessSingleLineRawInterpolatedStringEnd(SingleLineRawInterpolatedStringEndLiteral literalType, TContext context);
    public virtual TResult ProcessMultiLineRawInterpolatedStringStart(MultiLineRawInterpolatedStringStartLiteral literalType, TContext context);
    public virtual TResult ProcessMultiLineRawInterpolatedStringEnd(MultiLineRawInterpolatedStringEndLiteral literalType, TContext context);
    public virtual TResult ProcessRawInterpolatedStringText(RawInterpolatedStringTextLiteral literalType, TContext context);
    public virtual TResult ProcessRawInterpolatedStringInsertStart(RawInterpolatedStringInsertStartLiteral literalType, TContext context);
    public virtual TResult ProcessRawInterpolatedStringInsertEnd(RawInterpolatedStringInsertEndLiteral literalType, TContext context);
    public virtual TResult ProcessRawInterpolatedStringFormat(RawInterpolatedStringFormatLiteral literalType, TContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralTypeUtil : object {
    public static string VERBATIM_INTERPOLATED_START_BORDER;
    public static string VERBATIM_INTERPOLATED_START_BORDER_REVERSED;
    private static Dictionary`2<NodeType, StringVerbatimity> ourAnyStringLiteralSet;
    private static CSharpLiteralTypeUtil();
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyStringLiteral(ITokenNode literalToken);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyStringLiteral(TokenNodeType tokenNodeType);
    [ExtensionAttribute]
public static bool TryGetStringVerbatimity(TokenNodeType tokenNodeType, StringVerbatimity& verbatimity);
    [ExtensionAttribute]
[PureAttribute]
public static StringVerbatimity GetStringVerbatimity(TokenNodeType tokenNodeType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUtf8StringLiteral(ITokenNode tokenNode);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUtf8StringLiteral(CachingLexer lexer);
    [PureAttribute]
private static bool IsUtf8StringLiteral(TokenNodeType tokenType, string tokenText);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInterpolatedStringLiteral(ITokenNode literalToken);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsInterpolatedStringLiteral(TokenNodeType tokenNodeType);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpLiteralType TryGetLiteralType(ITokenNode literalToken);
    [ExtensionAttribute]
[PureAttribute]
public static CSharpLiteralType TryGetLiteralType(CachingLexer lexer);
    [PureAttribute]
private static CSharpLiteralType GetLiteralType(string literalText, TokenNodeType literalTokenType, ITokenNode tokenNode, CachingLexer lexer);
    public static void CountDollarSignAndQuotesInRawInterpolatedStringStart(string startTokenText, Int32& dollarSignCount, Int32& quoteCount);
    [PureAttribute]
public static string GetMultilineRawStringIndent(string text);
    [PureAttribute]
public static string GetTrailingLineEnding(string text);
    [PureAttribute]
private static string GetRawStringPrefixQuotes(string text);
    public static void GetMultiLineRawStringBorders(string text, Int32& quoteCount, String& startBorderWithFirstLineBreak, String& endBorderFromLastLineBreak);
    [PureAttribute]
private static int CountInterpolatedRawStringSuffixQuotes(string text);
    [PureAttribute]
public static CSharpLiteralType ToRegularOrVerbatimCounterpart(CSharpLiteralType literalType);
    public static BorderInfo GetBorderInfo(ITokenNode tokenNode, bool includeDollarAndAtSigns);
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralWrapper : object {
    [CompilerGeneratedAttribute]
private ITokenNode <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuffer <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLiteralType <Type>k__BackingField;
    private Nullable`1<bool> myIsValidLiteralOpt;
    public ITokenNode Token { get; }
    public IBuffer Buffer { get; }
    public CSharpLiteralType Type { get; }
    public bool IsValidLiteral { get; }
    public bool HasValidBorders { get; }
    public CSharpLiteralWrapper(IBuffer buffer, CSharpLiteralType literalType, ITokenNode tokenNode);
    public sealed virtual string GetText();
    [CompilerGeneratedAttribute]
public ITokenNode get_Token();
    [CompilerGeneratedAttribute]
public sealed virtual IBuffer get_Buffer();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpLiteralType get_Type();
    public sealed virtual bool get_IsValidLiteral();
    public sealed virtual bool get_HasValidBorders();
    private static bool CheckValidity(IBuffer buffer, CSharpLiteralType literalType, ITokenNode tokenNode);
    public sealed virtual string ToCompiledString(string customStartBorder, string customEndBorder);
    public sealed virtual string ToString(CSharpLiteralType targetType, CSharpLanguageLevel languageLevel, string customStartBorder, string customEndBorder);
    public sealed virtual ValueTuple`2<string, RangeTranslator> ConvertTo(CSharpLiteralType targetType, CSharpLanguageLevel languageLevel, string customStartBorder, string customEndBorder);
    public sealed virtual ValueTuple`2<string, RangeTranslator> ConvertToCompiledString(bool withSignificantIndent, string customStartBorder, string customEndBorder);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralWrapperExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpStringLexer CreateLexer(ICSharpLiteralWrapper wrapper);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsOffsetValid(ICSharpLiteralWrapper wrapper, int literalOffset);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpLiteralWrapperFactory : object {
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpLiteralWrapper TryCreate(ITokenNode literalToken);
    [NotNullAttribute]
[PureAttribute]
public static ICSharpLiteralWrapper Create(string value, CSharpLiteralType literalType);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpLiteralWrapper TryCreate(CachingLexer lexer);
    [NotNullAttribute]
[PureAttribute]
public static ICSharpLiteralWrapper Create(IBuffer buffer, CSharpLiteralType literalType, ITokenNode tokenNode);
}
[ReferenceProviderFactoryAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpPathReferenceFactory : InjectedReferenceProviderFactory {
    private CSharpPathReferenceProvider myProvider;
    public CSharpPathReferenceFactory(CSharpPathReferenceProvider provider, Lifetime lifetime);
    protected virtual ReferenceCollection CreateReferences(ITreeNode element, IInjectorProviderInLiterals provider, ILiteralsInjectionDataProvider data, IPsiSourceFile sourceFile, string prefix, string suffix, object options);
    protected virtual bool HasName(ITreeNode element, IReferenceNameContainer names);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpPathReferenceProvider : ReferenceInjectorProviderInLiteralsWithRangeMarkersBase`2<IStringLiteralOwner, CSharpLiteralInjectionTarget> {
    public IconId Icon { get; }
    public string ProvidedInjectionID { get; }
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public CSharpPathReferenceProvider(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, InjectionNodeProvidersViewer providersViewer, CSharpLiteralInjectionTarget injectionTargetLanguage);
    public virtual IconId get_Icon();
    public virtual string get_ProvidedInjectionID();
    public virtual PsiLanguageType get_SupportedOriginalLanguage();
    public sealed virtual IEnumerable`1<Tuple`2<TreeTextRange, string>> GetPathReferenceInfos(ITreeNode element);
    private static Tuple`2<string, RangeTranslator> ParseLiteral(string arg);
    public sealed virtual IReference BindReference(UniversalPathReference universalPathReference, IDeclaredElement declaredElement);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.CSharpRouteTemplateLiteralInjectionTarget : CSharpLiteralInjectionTargetBase {
    private static NodeTypeSet ourAllowedLiterals;
    private static CSharpRouteTemplateLiteralInjectionTarget();
    protected virtual ITreeNode UpdateText(ITreeNode originalNode, string newText, Int32& length);
    protected virtual ITokenNode GetTargetToken(ITreeNode originalNode);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CSharp.Util.Literals.ICSharpLiteralTypeProcessor`2 {
    public abstract virtual TResult ProcessCompiledString(CompiledStringLiteral literalType, TContext context);
    public abstract virtual TResult ProcessCharacter(CharacterLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRegularString(RegularStringLiteral literalType, TContext context);
    public abstract virtual TResult ProcessVerbatimString(VerbatimStringLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRegularInterpolatedString(RegularInterpolatedStringLiteral literalType, TContext context);
    public abstract virtual TResult ProcessVerbatimInterpolatedString(VerbatimInterpolatedStringLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRegularInterpolatedStringStart(RegularInterpolatedStringStartLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRegularInterpolatedStringMiddle(RegularInterpolatedStringMiddleLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRegularInterpolatedStringEnd(RegularInterpolatedStringEndLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRegularInterpolatedFormat(RegularInterpolatedFormatLiteral literalType, TContext context);
    public abstract virtual TResult ProcessVerbatimInterpolatedStringStart(VerbatimInterpolatedStringStartLiteral literalType, TContext context);
    public abstract virtual TResult ProcessVerbatimInterpolatedStringMiddle(VerbatimInterpolatedStringMiddleLiteral literalType, TContext context);
    public abstract virtual TResult ProcessVerbatimInterpolatedStringEnd(VerbatimInterpolatedStringEndLiteral literalType, TContext context);
    public abstract virtual TResult ProcessVerbatimInterpolatedFormat(VerbatimInterpolatedFormatLiteral literalType, TContext context);
    public abstract virtual TResult ProcessSingleLineRawString(SingleLineRawStringLiteral literalType, TContext context);
    public abstract virtual TResult ProcessMultiLineRawString(MultiLineRawStringLiteral literalType, TContext context);
    public abstract virtual TResult ProcessSingleLineRawInterpolatedStringStart(SingleLineRawInterpolatedStringStartLiteral literalType, TContext context);
    public abstract virtual TResult ProcessSingleLineRawInterpolatedStringEnd(SingleLineRawInterpolatedStringEndLiteral literalType, TContext context);
    public abstract virtual TResult ProcessMultiLineRawInterpolatedStringStart(MultiLineRawInterpolatedStringStartLiteral literalType, TContext context);
    public abstract virtual TResult ProcessMultiLineRawInterpolatedStringEnd(MultiLineRawInterpolatedStringEndLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRawInterpolatedStringText(RawInterpolatedStringTextLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRawInterpolatedStringInsertStart(RawInterpolatedStringInsertStartLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRawInterpolatedStringInsertEnd(RawInterpolatedStringInsertEndLiteral literalType, TContext context);
    public abstract virtual TResult ProcessRawInterpolatedStringFormat(RawInterpolatedStringFormatLiteral literalType, TContext context);
}
public interface JetBrains.ReSharper.Psi.CSharp.Util.Literals.ICSharpLiteralWrapper {
    [NotNullAttribute]
public IBuffer Buffer { get; }
    [NotNullAttribute]
public CSharpLiteralType Type { get; }
    public bool IsValidLiteral { get; }
    public bool HasValidBorders { get; }
    public abstract virtual IBuffer get_Buffer();
    [NotNullAttribute]
public abstract virtual string GetText();
    public abstract virtual CSharpLiteralType get_Type();
    public abstract virtual bool get_IsValidLiteral();
    public abstract virtual bool get_HasValidBorders();
    [PureAttribute]
public abstract virtual string ToCompiledString(string customStartBorder, string customEndBorder);
    [PureAttribute]
public abstract virtual string ToString(CSharpLiteralType targetType, CSharpLanguageLevel languageLevel, string customStartBorder, string customEndBorder);
    [PureAttribute]
public abstract virtual ValueTuple`2<string, RangeTranslator> ConvertTo(CSharpLiteralType targetType, CSharpLanguageLevel languageLevel, string customStartBorder, string customEndBorder);
    [PureAttribute]
public abstract virtual ValueTuple`2<string, RangeTranslator> ConvertToCompiledString(bool withSignificantIndent, string customStartBorder, string customEndBorder);
}
public interface JetBrains.ReSharper.Psi.CSharp.Util.Literals.ICSharpStringLexer {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.CharacterExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToRegularString(char element, CSharpLanguageLevel languageLevel, bool isInterpolated, IFormatProvider customFormatProvider);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToVerbatimString(char element, bool isInterpolated, IFormatProvider customFormatProvider);
    [ExtensionAttribute]
[NotNullAttribute]
public static string ToPresentationString(char element, CSharpLanguageLevel languageLevel, IFormatProvider customFormatProvider);
    [ExtensionAttribute]
public static bool IsBackslash(char c);
    [ExtensionAttribute]
public static bool IsQuote(char c);
    [ExtensionAttribute]
public static bool IsHexadecimalEscape(char c);
    [ExtensionAttribute]
public static bool IsUnicodeEscapeShort(char c);
    [ExtensionAttribute]
public static bool IsUnicodeEscapeLong(char c);
    [ExtensionAttribute]
public static bool IsNewLine(char c);
    [ExtensionAttribute]
public static bool IsEscape(char c);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.CharacterLexer : RegularLiteralLexer {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    protected UInt32 MaxUnicodeCodePoint { get; }
    public CharacterLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual UInt32 get_MaxUnicodeCodePoint();
    protected virtual TokenNodeType AdvanceInternal();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.CompiledStringLexer : StringLexerBase {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public CompiledStringLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual TokenNodeType AdvanceInternal();
    protected virtual string ParseEscapeCharacter(string value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.CSharpStringTokenTypes : object {
    [NullableAttribute("1")]
public static TokenNodeType MULTI_LINE_RAW_STRING_START_TRIVIA;
    [NullableAttribute("1")]
public static TokenNodeType MULTI_LINE_RAW_STRING_INDENT_TRIVIA;
    [NullableAttribute("1")]
public static TokenNodeType MULTI_LINE_RAW_STRING_LINE_BREAK_TRIVIA;
    private static CSharpStringTokenTypes();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsIgnorableTrivia(TokenNodeType tokenType);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.MultiLineRawInterpolatedStringEndLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    protected int QuoteCount { get; }
    protected bool IsMultiLine { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public MultiLineRawInterpolatedStringEndLexer(int startOffset, IBuffer buffer);
    protected virtual int get_QuoteCount();
    protected virtual bool get_IsMultiLine();
    [CompilerGeneratedAttribute]
protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.MultiLineRawInterpolatedStringStartLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    protected int QuoteCount { get; }
    protected int DollarSignCount { get; }
    protected bool IsMultiLine { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public MultiLineRawInterpolatedStringStartLexer(int startOffset, IBuffer buffer);
    protected virtual int get_QuoteCount();
    protected virtual int get_DollarSignCount();
    protected virtual bool get_IsMultiLine();
    [CompilerGeneratedAttribute]
protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.MultiLineRawInterpolatedStringTextLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DollarSignCount>k__BackingField;
    [CompilerGeneratedAttribute]
private State <StartState>k__BackingField;
    protected int QuoteCount { get; }
    protected string Indent { get; }
    protected int DollarSignCount { get; }
    protected State StartState { get; }
    protected bool IsMultiLine { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public MultiLineRawInterpolatedStringTextLexer(int quoteCount, int dollarSignCount, string indent, bool isFirstText, IBuffer buffer);
    [CompilerGeneratedAttribute]
protected virtual int get_QuoteCount();
    [CompilerGeneratedAttribute]
protected virtual string get_Indent();
    [CompilerGeneratedAttribute]
protected virtual int get_DollarSignCount();
    [CompilerGeneratedAttribute]
protected virtual State get_StartState();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
    protected virtual bool get_IsMultiLine();
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.MultiLineRawStringLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    protected int QuoteCount { get; }
    protected string Indent { get; }
    protected bool IsMultiLine { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public MultiLineRawStringLexer(int startOffset, int endOffset, int quoteCount, string indent, IBuffer buffer);
    [CompilerGeneratedAttribute]
protected virtual int get_QuoteCount();
    [CompilerGeneratedAttribute]
protected virtual string get_Indent();
    protected virtual bool get_IsMultiLine();
    [CompilerGeneratedAttribute]
protected virtual int get_StartOffset();
    [CompilerGeneratedAttribute]
protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.MultiLineRawStringUtf8Lexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    protected int QuoteCount { get; }
    protected string Indent { get; }
    protected bool IsUtf8 { get; }
    protected bool IsMultiLine { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public MultiLineRawStringUtf8Lexer(int startOffset, int endOffset, int quoteCount, string indent, IBuffer buffer);
    [CompilerGeneratedAttribute]
protected virtual int get_QuoteCount();
    [CompilerGeneratedAttribute]
protected virtual string get_Indent();
    protected virtual bool get_IsUtf8();
    protected virtual bool get_IsMultiLine();
    [CompilerGeneratedAttribute]
protected virtual int get_StartOffset();
    [CompilerGeneratedAttribute]
protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawInterpolatedStringInsertEndLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    protected int QuoteCount { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public RawInterpolatedStringInsertEndLexer(int closeBracesCount, IBuffer buffer);
    protected virtual int get_QuoteCount();
    [CompilerGeneratedAttribute]
protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawInterpolatedStringInsertStartLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    protected int QuoteCount { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    protected State StartState { get; }
    public RawInterpolatedStringInsertStartLexer(int openBracesCount, IBuffer buffer);
    protected virtual int get_QuoteCount();
    [CompilerGeneratedAttribute]
protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual State get_StartState();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RawStringLexerBase : object {
    [CompilerGeneratedAttribute]
private IBuffer <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private State <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenNodeType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TokenStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TokenEnd>k__BackingField;
    [NotNullAttribute]
public IBuffer Buffer { get; }
    private int Position { get; private set; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    protected int QuoteCount { get; }
    protected int DollarSignCount { get; }
    protected bool IsMultiLine { get; }
    [CanBeNullAttribute]
protected string Indent { get; }
    protected bool IsUtf8 { get; }
    private int MultiLineContentEndIndex { get; }
    protected State CurrentState { get; private set; }
    protected State StartState { get; }
    public TokenNodeType TokenType { get; private set; }
    public int TokenStart { get; private set; }
    public int TokenEnd { get; private set; }
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public string CompiledChars { get; }
    public bool CanAdvance { get; }
    protected RawStringLexerBase(IBuffer buffer);
    [CompilerGeneratedAttribute]
public sealed virtual IBuffer get_Buffer();
    [CompilerGeneratedAttribute]
private int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    protected abstract virtual int get_StartOffset();
    protected abstract virtual int get_EndOffset();
    protected abstract virtual int get_QuoteCount();
    protected virtual int get_DollarSignCount();
    protected virtual bool get_IsMultiLine();
    protected virtual string get_Indent();
    protected virtual bool get_IsUtf8();
    private int get_MultiLineContentEndIndex();
    [CompilerGeneratedAttribute]
protected State get_CurrentState();
    [CompilerGeneratedAttribute]
private void set_CurrentState(State value);
    protected virtual State get_StartState();
    [CompilerGeneratedAttribute]
public sealed virtual TokenNodeType get_TokenType();
    [CompilerGeneratedAttribute]
private void set_TokenType(TokenNodeType value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TokenStart();
    [CompilerGeneratedAttribute]
private void set_TokenStart(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TokenEnd();
    [CompilerGeneratedAttribute]
private void set_TokenEnd(int value);
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public virtual string get_CompiledChars();
    public sealed virtual bool get_CanAdvance();
    public sealed virtual void Start();
    protected abstract virtual ValueTuple`2<State, TokenNodeType> StartCore();
    public sealed virtual void Advance();
    private void FixTokenBorders();
    private ValueTuple`2<State, TokenNodeType> AdvanceCore();
    private TokenNodeType AdvanceToEnd();
    [PureAttribute]
private bool CheckPosition(int position);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RegularInterpolatedFormatLexer : RegularInterpolatedStringLexer {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public RegularInterpolatedFormatLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RegularInterpolatedStringLexer : RegularStringLexer {
    protected RegularInterpolatedStringLexer(IBuffer buffer);
    protected virtual TokenNodeType AdvanceInternal();
    protected virtual string ParseEscapeCharacter(string value);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RegularInterpolatedStringMiddleEndLexer : RegularInterpolatedStringLexer {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public RegularInterpolatedStringMiddleEndLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RegularInterpolatedStringStartLexer : RegularInterpolatedStringLexer {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public RegularInterpolatedStringStartLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RegularLiteralLexer : StringLexerBase {
    protected UInt32 MaxUnicodeCodePoint { get; }
    protected RegularLiteralLexer(IBuffer buffer);
    protected virtual TokenNodeType AdvanceInternal();
    protected virtual TokenNodeType ProcessEscapeSequence();
    protected TokenNodeType ProcessLongHexEscapeSequence();
    protected virtual UInt32 get_MaxUnicodeCodePoint();
    protected virtual string ParseEscapeCharacter(string value);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RegularStringLexer : RegularLiteralLexer {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public RegularStringLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.RegularStringUtf8Lexer : RegularStringLexer {
    protected int EndOffset { get; }
    public RegularStringUtf8Lexer(IBuffer buffer);
    protected virtual int get_EndOffset();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.SingleLineRawInterpolatedStringEndLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    protected int QuoteCount { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public SingleLineRawInterpolatedStringEndLexer(int quoteCount, IBuffer buffer);
    [CompilerGeneratedAttribute]
protected virtual int get_QuoteCount();
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.SingleLineRawInterpolatedStringStartLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    protected int QuoteCount { get; }
    protected int DollarSignCount { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public SingleLineRawInterpolatedStringStartLexer(int startOffset, IBuffer buffer);
    protected virtual int get_QuoteCount();
    protected virtual int get_DollarSignCount();
    [CompilerGeneratedAttribute]
protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.SingleLineRawInterpolatedStringTextLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DollarSignCount>k__BackingField;
    protected int QuoteCount { get; }
    protected int DollarSignCount { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    protected State StartState { get; }
    public SingleLineRawInterpolatedStringTextLexer(int quoteCount, int dollarSignCount, IBuffer buffer);
    [CompilerGeneratedAttribute]
protected virtual int get_QuoteCount();
    [CompilerGeneratedAttribute]
protected virtual int get_DollarSignCount();
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual State get_StartState();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.SingleLineRawStringLexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    protected int QuoteCount { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public SingleLineRawStringLexer(int quoteCount, IBuffer buffer);
    [CompilerGeneratedAttribute]
protected virtual int get_QuoteCount();
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.SingleLineRawStringUtf8Lexer : RawStringLexerBase {
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    protected int QuoteCount { get; }
    protected bool IsUtf8 { get; }
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public SingleLineRawStringUtf8Lexer(int quoteCount, IBuffer buffer);
    [CompilerGeneratedAttribute]
protected virtual int get_QuoteCount();
    protected virtual bool get_IsUtf8();
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual ValueTuple`2<State, TokenNodeType> StartCore();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.VerbatimInterpolatedFormatLexer : VerbatimInterpolatedStringLexer {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public VerbatimInterpolatedFormatLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.VerbatimInterpolatedStringLexer : VerbatimStringLexer {
    protected VerbatimInterpolatedStringLexer(IBuffer buffer);
    protected virtual TokenNodeType AdvanceInternal();
    protected virtual string ParseEscapeCharacter(string value);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.VerbatimInterpolatedStringMiddleEndLexer : VerbatimInterpolatedStringLexer {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public VerbatimInterpolatedStringMiddleEndLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.VerbatimInterpolatedStringStartLexer : VerbatimInterpolatedStringLexer {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public VerbatimInterpolatedStringStartLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.VerbatimStringLexer : StringLexerBase {
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public VerbatimStringLexer(IBuffer buffer);
    protected virtual int get_StartOffset();
    protected virtual int get_EndOffset();
    protected virtual TokenNodeType AdvanceInternal();
    protected virtual string ParseEscapeCharacter(string value);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Impl.VerbatimStringUtf8Lexer : VerbatimStringLexer {
    protected int EndOffset { get; }
    public VerbatimStringUtf8Lexer(IBuffer buffer);
    protected virtual int get_EndOffset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.RawStringEscaper : CSharpLiteralEscaper {
    public static RawStringEscaper Instance;
    private static RawStringEscaper();
    public virtual string PresentChar(char value);
    public virtual string Escape(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.RegularInterpolatedStringEscaper : CSharpLiteralEscaper {
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <languageLevel>P;
    private static RegularInterpolatedStringEscaper ourCSharp12Escaper;
    private static RegularInterpolatedStringEscaper ourCSharpLatestEscaper;
    public RegularInterpolatedStringEscaper(CSharpLanguageLevel languageLevel);
    private static RegularInterpolatedStringEscaper();
    public static CSharpLiteralEscaper GetOrCreate(CSharpLanguageLevel languageLevel);
    public virtual string PresentChar(char value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.RegularStringEscaper : CSharpLiteralEscaper {
    [CompilerGeneratedAttribute]
private CSharpLanguageLevel <languageLevel>P;
    private static RegularStringEscaper ourCSharp12Escaper;
    private static RegularStringEscaper ourCSharpLatestEscaper;
    public RegularStringEscaper(CSharpLanguageLevel languageLevel);
    private static RegularStringEscaper();
    public static CSharpLiteralEscaper GetOrCreate(CSharpLanguageLevel languageLevel);
    public virtual string PresentChar(char value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.Literals.StringExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<StringVerbatimity> TryGetStringVerbatimity(ICSharpLiteralExpression literalExpression);
    [ExtensionAttribute]
[PureAttribute]
public static StringVerbatimity GetStringVerbatimity(ICSharpLiteralExpression literalExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUtf8StringLiteral(ICSharpLiteralExpression literalExpression);
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.Literals.Utf8Suffix : Enum {
    public int value__;
    public static Utf8Suffix None;
    public static Utf8Suffix Lowercase;
    public static Utf8Suffix Uppercase;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.Literals.Utf8SuffixUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static string ToText(Utf8Suffix suffix);
    [PureAttribute]
public static Utf8Suffix GetUtf8Suffix(string text, bool isRegularString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.VerbatimInterpolatedStringEscaper : CSharpLiteralEscaper {
    public static VerbatimInterpolatedStringEscaper Instance;
    private static VerbatimInterpolatedStringEscaper();
    public virtual string PresentChar(char value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.Literals.VerbatimStringEscaper : CSharpLiteralEscaper {
    public static VerbatimStringEscaper Instance;
    private static VerbatimStringEscaper();
    public virtual string PresentChar(char value);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.LocalFunctionAnalysis`3 : object {
    [NotNullAttribute]
private Dictionary`2<ILocalFunction, TLocalFunctionInfo> myLocalFunctionInfos;
    [NotNullAttribute]
private Dictionary`2<ILocalFunction, TLocalFunctionInfo> myLocalFunctionIncompleteInfos;
    [NotNullAttribute]
private Stack`1<TLocalFunctionDataCollector> myLocalFunctionAnalysisStack;
    [NotNullAttribute]
private Stack`1<CallStackElement<TLocalFunctionInfo, TLocalFunctionDataCollector, TContext>> myLocalFunctionCalls;
    [CompilerGeneratedAttribute]
private Dictionary`2<ILocalFunction, TLocalFunctionDataCollector> <LocalFunctionDataCollectors>k__BackingField;
    [NotNullAttribute]
protected TLocalFunctionInfo RecursiveInfo { get; }
    [NotNullAttribute]
protected TLocalFunctionInfo EmptyInfo { get; }
    [NotNullAttribute]
protected TLocalFunctionInfo IncompleteRecursiveInfo { get; }
    [NotNullAttribute]
protected Dictionary`2<ILocalFunction, TLocalFunctionDataCollector> LocalFunctionDataCollectors { get; }
    public bool IsInLocalFunctionAnalysis { get; }
    protected abstract virtual TLocalFunctionInfo get_RecursiveInfo();
    protected abstract virtual TLocalFunctionInfo get_EmptyInfo();
    protected virtual TLocalFunctionInfo get_IncompleteRecursiveInfo();
    [NotNullAttribute]
[ItemNotNullAttribute]
protected IEnumerable`1<ILocalFunction> GetLocalFunctionAnalysisCallStack();
    [CompilerGeneratedAttribute]
protected Dictionary`2<ILocalFunction, TLocalFunctionDataCollector> get_LocalFunctionDataCollectors();
    [NotNullAttribute]
protected abstract virtual TLocalFunctionDataCollector CreateLocalFunctionDataCollector(ILocalFunction localFunction);
    [NotNullAttribute]
public TLocalFunctionInfo GetOrCreateLocalFunctionInfo(TContext context, ILocalFunction localFunction);
    protected bool HasInAnalysisStack(ILocalFunction localFunction);
    protected virtual void OnRecursiveCall(ILocalFunction localFunction, PooledHashSet`1<ILocalFunction> recursiveStackPart, bool viaClosure);
    public bool get_IsInLocalFunctionAnalysis();
    [CanBeNullAttribute]
protected TLocalFunctionDataCollector GetTopmostCallDataCollector();
    protected void OnClosureAnalysisStarted(ICSharpClosure closure);
    protected void OnClosureAnalysisFinished(ICSharpClosure closure);
    protected bool IsInCallStack(ILocalFunction localFunction, PooledHashSet`1<ILocalFunction> recursiveStackPart, Boolean& viaClosure);
    private void AddCall(ILocalFunction localFunction, bool isRecursive);
    private void RemoveCall(ILocalFunction localFunction);
    [CanBeNullAttribute]
private TLocalFunctionDataCollector TryPopFromAnalysisStack(ILocalFunction localFunction);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.LocalFunctionUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static ICSharpClosure GetContainingStaticLocalFunctionOrStaticLambda(ITreeNode treeNode);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.MemberInserter : object {
    [CompilerGeneratedAttribute]
private IInsertionAnchorResult`1<IClassMemberDeclaration> <Anchor>k__BackingField;
    protected IClassMemberDeclaration InsertedDeclaration { get; }
    protected IClassLikeDeclaration TargetDeclaration { get; }
    public IInsertionAnchorResult`1<IClassMemberDeclaration> Anchor { get; private set; }
    protected abstract virtual IClassMemberDeclaration get_InsertedDeclaration();
    protected abstract virtual IClassLikeDeclaration get_TargetDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual IInsertionAnchorResult`1<IClassMemberDeclaration> get_Anchor();
    [CompilerGeneratedAttribute]
private void set_Anchor(IInsertionAnchorResult`1<IClassMemberDeclaration> value);
    public sealed virtual bool TryFindDeclarationAnchor();
    protected IInsertionAnchorResult`1<IClassMemberDeclaration> FindDeclarationAnchor();
    public sealed virtual IClassMemberDeclaration InsertMethod();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.MoveInitializerUtil : object {
    [PureAttribute]
public static bool CanExtractInitializer(TMember typeMemberDeclaration);
    [PureAttribute]
public static int CountTargetConstructorsCount(ICSharpTypeMemberDeclaration typeMemberDeclaration);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private static IReadOnlyList`1<IConstructorDeclaration> PrepareTargetConstructorDeclarations(ICSharpTypeMemberDeclaration typeMemberDeclaration);
    [NotNullAttribute]
private static IReadOnlyList`1<IConstructorDeclaration> FindTargetConstructors(ICSharpTypeMemberDeclaration typeMemberDeclaration);
    [CanBeNullAttribute]
[PureAttribute]
public static IVariableInitializer FindInitializer(ICSharpTypeMemberDeclaration typeMemberDeclaration);
    public static void Extract(IReadOnlyList`1<ICSharpTypeMemberDeclaration> membersWithInitializers, bool enforceCompoundAssignmentForEvents);
    [CanBeNullAttribute]
private static ICSharpStatement TryFindAnchorStatement(IConstructorDeclaration constructorDeclaration, HashSet`1<ITypeMember> typeMembers, HashSet`1<ITypeMember> membersBefore);
    [ExtensionAttribute]
public static void RemoveInitializer(ICSharpTypeMemberDeclaration typeMemberDeclaration);
    [NotNullAttribute]
[PureAttribute]
private static Dictionary`2<ICSharpTypeMemberDeclaration, ICSharpExpression> PrepareInitializationValues(IReadOnlyCollection`1<ICSharpTypeMemberDeclaration> typeMemberDeclarations);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.NameofUtil : object {
    [PureAttribute]
public static bool IsAvailable(ITreeNode context);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpExpression ToLiteralOrNameofExpression(IDeclaredElement element, ITreeNode context, CSharpElementFactory elementFactory);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ICSharpExpression ToLiteralOrNameofExpression(ICSharpExpression expression, CSharpElementFactory elementFactory);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNameofTopArgumentReference(IReference reference, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNameofPartArgumentReference(IReference reference, IResolveContext resolveContext);
    [PureAttribute]
public static bool CanBeNameofOperatorIdentifier(IPrimaryExpression expression);
    [PureAttribute]
public static bool CanBeNameofOperatorIdentifier(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNameofOperatorArgumentPart(ICSharpExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNameofOperatorArgumentPart(ICSharpExpression expression, IReferenceExpression& nameofOperatorTopArgument, IResolveContext resolveContext);
    [PureAttribute]
public static bool CanBeUsedAsNameofOperatorArgument(ICSharpExpression rootExpression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.NullableDirectiveUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static INullableDirective AddNullableDirective(ICSharpFile file, INullableDirective nullableDirective);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.NullableDirectiveUtil/<CreateNullableDirectives>d__1")]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<INullableDirective> CreateNullableDirectives(CSharpElementFactory factory, bool requiredWarningContext, bool requiredAnnotationContext, Nullable`1<bool> actualWarningContext, Nullable`1<bool> actualAnnotationContext);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.NullableReferenceTypeChecker : AggregatingTypeVisitor`2<object, bool> {
    private static NullableReferenceTypeChecker ourInstance;
    private static NullableReferenceTypeChecker();
    [PureAttribute]
public static bool IsWellFormed(IType type);
    public virtual bool VisitPointerType(IPointerType pointerType, object context);
    public virtual bool VisitDeclaredType(IDeclaredType declaredType, object context);
    public virtual bool VisitTypeArgument(ITypeElement typeElement, ITypeParameter typeParameter, IType typeArgument, object unused);
    public virtual bool IsProcessingFinished(bool hasError, object context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.NullableReferenceTypesUtil : object {
    [ExtensionAttribute]
public static NullableAnnotation GetConstantExpressionNullableAnnotation(ICSharpExpression expression);
    [NotNullAttribute]
public static ISubstitution InferAnnotatedTypes(ISubstitution qualifierSubstitution, ICSharpTreeNode invocationExpression, ICSharpInvocationInfo invocationInfo, TParametersOwner parametersOwner, IResolveContext resolveContext);
    public static ValueTuple`2<IType, IReadOnlyList`1<IType>> GetAnnotatedParameterType(IType parameterType, ITypeOwner sourceTypeOwner, Nullable`1<NullableAnnotation> incomingValueAnnotation, Nullable`1<NullableAnnotation> outgoingValueAnnotation, ParameterKind kind, ITreeNode context);
    public static void CopyNullabilityAttributes(IClassMemberDeclaration implementingMember, IOverridableMember baseMember, ISubstitution baseMemberSubstitution);
    private static Nullable`1<NullableAnnotation> GetParameterAnnotation(IType parameterType, ITypeOwner sourceTypeOwner, Nullable`1<NullableAnnotation> incomingValueAnnotation, Nullable`1<NullableAnnotation> outgoingValueAnnotation, ParameterKind kind, ITreeNode context);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IReadOnlyList`1<IType> GetParameterAttributes(IType parameterType, Nullable`1<NullableAnnotation> incomingValueAnnotation, Nullable`1<NullableAnnotation> outgoingValueAnnotation, ParameterKind kind, ITreeNode context);
    [CompilerGeneratedAttribute]
internal static Nullable`1<NullableAnnotation> <GetParameterAnnotation>g__CoalesceAllowedAnnotations|4_0(Nullable`1<NullableAnnotation> annotation, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetParameterAttributes>g__ParameterTypeIsExplicitlyNullable|5_0(<>c__DisplayClass5_0& );
}
public class JetBrains.ReSharper.Psi.CSharp.Util.NullChecks.NullCheckData : object {
    [CompilerGeneratedAttribute]
private ICSharpExpression <CheckedExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private NullCheckKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEqualsNullCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPredefined>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResolved>k__BackingField;
    [NotNullAttribute]
public ICSharpExpression CheckedExpression { get; }
    public NullCheckKind Kind { get; }
    public bool IsEqualsNullCheck { get; }
    public bool IsNotNullCheck { get; }
    public bool IsPredefined { get; }
    public bool IsResolved { get; }
    public NullCheckData(ICSharpExpression checkedExpression, NullCheckKind kind, bool isResolved, bool isEqualsNullCheck, bool isPredefinedNullCheck);
    [CompilerGeneratedAttribute]
public ICSharpExpression get_CheckedExpression();
    [CompilerGeneratedAttribute]
public NullCheckKind get_Kind();
    [CompilerGeneratedAttribute]
public bool get_IsEqualsNullCheck();
    public bool get_IsNotNullCheck();
    [CompilerGeneratedAttribute]
public bool get_IsPredefined();
    [CompilerGeneratedAttribute]
public bool get_IsResolved();
    [PureAttribute]
public TreeTextRange GetNullCheckRange();
    [PureAttribute]
public DisjointedTreeTextRange ThenNullCheckRange(DisjointedTreeTextRange checkedExpressionRange);
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.NullChecks.NullCheckKind : Enum {
    public int value__;
    public static NullCheckKind EqualityExpression;
    public static NullCheckKind StaticEqualsNull;
    public static NullCheckKind StaticReferenceEqualsNull;
    public static NullCheckKind NullableHasValue;
    public static NullCheckKind NullPattern;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.NullChecks.NullCheckUtil : object {
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => null")]
public static NullCheckData GetNullCheckThroughParenthesisAndNegations(ICSharpExpression expression, bool allowUserDefinedAndUnresolvedChecks);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => null")]
public static NullCheckData GetNullCheckFromExpression(ICSharpExpression expression, bool allowUserDefinedAndUnresolvedChecks);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => null")]
[ContractAnnotationAttribute("=> notnull, nullCheckExpression: notnull")]
[ContractAnnotationAttribute("=> null, nullCheckExpression:null")]
public static NullCheckData GetNullCheckByCheckedExpression(ICSharpExpression expression, ICSharpExpression& nullCheckExpression, bool allowUserDefinedAndUnresolvedChecks);
    [PureAttribute]
public static bool IsPureNullCheckingOperator(IEqualityExpression expression);
    [PureAttribute]
public static bool IsPureOrDynamicNullCheckingOperator(IEqualityExpression expression);
    [PureAttribute]
public static EqualityExpressionNullCheckOperatorKind IsNullCheckingOperator(IEqualityExpression expression);
    [PureAttribute]
public static bool IsNullCheckTransitiveOperator(ISignOperator signOperator);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => null")]
private static NullCheckData GetNullCheckThroughParenthesisAndNegationsImpl(ICSharpExpression expression, bool isInverted);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("expression: null => null")]
private static NullCheckData GetNullCheckFromExpressionImpl(ICSharpExpression expression, bool isInverted);
    [CanBeNullAttribute]
[PureAttribute]
private static NullCheckData TryBuildEqualsNullCheck(IInvocationExpression invocationExpression, bool isInverted);
    [CanBeNullAttribute]
[PureAttribute]
private static NullCheckData TryBuildNullPatternCheck(IIsExpression isExpression, bool isInverted);
    [CanBeNullAttribute]
[PureAttribute]
private static NullCheckData TryBuildNullCheck(IEqualityExpression equalityExpression, bool isInverted);
    [CanBeNullAttribute]
[PureAttribute]
private static NullCheckData TryBuildNullableCheck(IReferenceExpression referenceExpression, bool isInverted);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("firstCandidate: null => null; secondCandidate: null => null")]
private static ICSharpExpression FindCheckedExpression(ICSharpExpression firstCandidate, ICSharpExpression secondCandidate);
    [ExtensionAttribute]
[PureAttribute]
private static bool IsNonExternalConstantNull(ICSharpExpression expression, ICSharpExpression checkedExpression);
    [PureAttribute]
[NotNullAttribute]
public static string GetNullCheckExpressionTemplate(NullCheckKind desiredKind, bool isNotNullCheck);
    [CanBeNullAttribute]
[PureAttribute]
public static IMethod TryGetArgumentNullExceptionThrowIfNullMethod(ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
public static IMethod TryGetArgumentNullExceptionThrowIfNullMethod(PredefinedType predefinedType);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Util.NullCoalescingExpressionInfo : ValueType {
    [NotNullAttribute]
public IType NullCoalescingExpressionType;
    public Nullable`1<TypeConversionInfo> LeftOperand;
    public Nullable`1<TypeConversionInfo> RightOperand;
    public NullCoalescingExpressionInfo(IType nullCoalescingExpressionType, Nullable`1<TypeConversionInfo> leftOperand, Nullable`1<TypeConversionInfo> rightOperand);
    public static NullCoalescingExpressionInfo CreateUnknown(IExpressionType leftType, IExpressionType rightType, ITreeNode context);
    public static NullCoalescingExpressionInfo CreateMultitype(IType leftType, IType rightType, ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.NullCoalescingExpressionUtil : object {
    [NotNullAttribute]
public static IType DeriveType(ICSharpExpression leftOperand, ICSharpExpression rightOperand, ITreeNode context, IResolveContext resolveContext);
    [NotNullAttribute]
public static IType DeriveType(IExpressionType leftExpressionType, IExpressionType rightExpressionType, ITreeNode context);
    public static NullCoalescingExpressionInfo CalculateTypeWithConversions(IExpressionType leftExpressionType, IExpressionType rightExpressionType, ITreeNode context);
    private static TypeConversionInfo GetImplicitConversionWithTypes(IExpressionType from, IType to, ICSharpTypeConversionRule conversionRule);
    private static TypeConversionInfo CreateIdentityConversionInfo(IExpressionType from, IType to);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.NumericLiteralUtil : object {
    private static int Binary;
    private static int Decimal;
    private static int Hexadecimal;
    [PureAttribute]
public static TextRange GetIntegerLiteralDigitsRange(string literalText);
    [PureAttribute]
public static TextRange GetRealLiteralDigitsRange(string literalText);
    [PureAttribute]
public static ValueTuple`2<int, int> GetIntegerDigitsStartOffsetAndBase(string literalText);
    [PureAttribute]
public static ValueTuple`2<int, IntegerLiteralSuffix> GetIntegerDigitsEndOffsetAndType(string literalText);
    [PureAttribute]
private static int GetRealDigitsEndOffset(string literalText);
    [PureAttribute]
public static TextRange GetRealLiteralIntegerDigitsRange(string literalText);
    [NotNullAttribute]
[PureAttribute]
public static string SeparateLiteralText(string literalText, TextRange digitsRange, int eachDigitToSeparate, bool separatePrefix);
    [CompilerGeneratedAttribute]
internal static IntegerLiteralSuffix <GetIntegerDigitsEndOffsetAndType>g__GetSuffixFlag|6_0(char symbol);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.NUnitConstraintsUtil : object {
    private static ClrTypeName NUnitIsTypeName;
    private static ClrTypeName NUnitIzTypeName;
    private static NUnitConstraintsUtil();
    [PureAttribute]
private static ConstraintKind GetKindFromConstraintArgument(ICSharpExpression constraintExpression);
    [CanBeNullAttribute]
[PureAttribute]
private static IReferenceExpression GetQualifierReferenceThroughSimpleReference(ICSharpExpression expression, string expectedName);
    [PureAttribute]
private static bool IsNUnitIsTypeReference(IReferenceExpression referenceExpression);
    public static ConstraintKind GetConstraintCheckKind(IMethod invokedMethod, IInvocationExpression invocationExpression, ICSharpArgument& checkedArgument);
    private static ConstraintKind GetConstrainValue(ICSharpExpression csharpExpression);
    private static bool IsAssertionLikeMethod(IMethod invokedMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.ObjectCreationToTupleExpressionConverter : object {
    private IReadOnlyList`1<TupleTypeComponent> myTupleTypeComponents;
    private CSharpElementFactory myFactory;
    private ComponentInfo[] myMatchedComponents;
    private List`1<ComponentInfo> myUnmatchedComponents;
    private ObjectCreationToTupleExpressionConverter(DecoratedType`1<TupleTypeDecoration> tupleType, CSharpElementFactory factory);
    public static ITupleExpression ConvertAndReplace(IObjectCreationExpression objectCreationExpression, DecoratedType`1<TupleTypeDecoration> tupleType);
    public static ITupleExpression Convert(IObjectCreationExpression objectCreationExpression, DecoratedType`1<TupleTypeDecoration> tupleType);
    [NullableContextAttribute("2")]
private void AddMatched(int tupleComponentIndex, ICSharpExpression value);
    [NullableContextAttribute("2")]
private void AddUnmatched(string argumentName, ICSharpExpression value);
    private void MatchArgumentsWithTupleType(IObjectCreationExpression expression, int baseComponentIndex);
    private static Nullable`1<int> ArgumentNameToParameterIndex(string name);
    [NullableContextAttribute("2")]
private void MatchRestExpression(ICSharpExpression restExpression, int baseComponentIndex);
    private void MatchTupleExpression(ITupleExpression tupleExpression, int baseComponentIndex);
    [CompilerGeneratedAttribute]
internal static void <Convert>g__ProcessComponentInfo|7_0(ComponentInfo componentInfo, <>c__DisplayClass7_0& );
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ObjectInitializerUtil : object {
    [PureAttribute]
public static bool CanBeInitialized(IDeclaredElement declaredElement, ISubstitution substitution, ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ObjectPatternUtils : object {
    [PureAttribute]
public static bool CanQualifierExpressionBeNull(ICSharpExpression expression, Boolean& isTrueValueType);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ParamsCollectionUtil : object {
    [NullableContextAttribute("2")]
public static IParameter GetParamsParameterByReference(IReference reference, IResolveContext resolveContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CSharp.Util.PartialDeclarationsUtil : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static IEnumerable`1<ValueTuple`2<IDeclaration, IAttribute>> GetAllPartialAttributes(IDeclaration declaration);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.PartialDeclarationsUtil/<GetAllTypeAttributes>d__1")]
[PureAttribute]
private static IEnumerable`1<ValueTuple`2<IDeclaration, IAttribute>> GetAllTypeAttributes(IClassLikeDeclaration classLikeDeclaration);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.PartialDeclarationsUtil/<GetAllMethodAttributes>d__2")]
[PureAttribute]
private static IEnumerable`1<ValueTuple`2<IDeclaration, IAttribute>> GetAllMethodAttributes(IMethodDeclaration methodDeclaration);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.PartialDeclarationsUtil/<GetAllParameterAttributes>d__3")]
[PureAttribute]
private static IEnumerable`1<ValueTuple`2<IDeclaration, IAttribute>> GetAllParameterAttributes(ITypeMemberRegularParameterDeclaration parameterDeclaration);
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.PreprocessorCondition : object {
    [NotNullAttribute]
public static PreprocessorCondition UnknownCondition;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PreprocessorConditionPart> <ConditionParts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConjunction>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<PreprocessorConditionPart> ConditionParts { get; }
    private bool IsConjunction { get; }
    private bool IsDisjunction { get; }
    public PreprocessorCondition(PreprocessorConditionPart conditionPart);
    private PreprocessorCondition(List`1<PreprocessorConditionPart> conditionParts, bool isConjunction);
    private static PreprocessorCondition();
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PreprocessorConditionPart> get_ConditionParts();
    [CompilerGeneratedAttribute]
private bool get_IsConjunction();
    private bool get_IsDisjunction();
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("secondCondition: null => null; secondCondition: notnull => notnull")]
public PreprocessorCondition And(PreprocessorCondition secondCondition);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("secondCondition: null => null; secondCondition: notnull => notnull")]
public PreprocessorCondition Or(PreprocessorCondition secondCondition);
    [NotNullAttribute]
[PureAttribute]
public PreprocessorCondition Not();
    [PureAttribute]
public bool IsSubsetOf(PreprocessorCondition superset);
    [PureAttribute]
public bool ExactlyMatch(PreprocessorCondition other);
    [NotNullAttribute]
[PureAttribute]
private string Materialize();
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("secondCondition: null => null; secondCondition: notnull => notnull")]
private PreprocessorCondition AddCondition(PreprocessorCondition secondCondition, bool isConjunction);
    [CompilerGeneratedAttribute]
internal static bool <AddCondition>g__IsMatchingOperation|17_0(PreprocessorCondition preprocessorCondition, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static IReadOnlyList`1<PreprocessorConditionPart> <AddCondition>g__CollectSymbolsFrom|17_1(PreprocessorCondition preprocessorCondition, <>c__DisplayClass17_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.PreprocessorConditionParser : object {
    [NotNullAttribute]
private IRegionStructure myRegionStructure;
    public PreprocessorConditionParser(IRegionStructure regionStructure);
    [CanBeNullAttribute]
internal PreprocessorCondition GetContainingPreprocessorBranchCondition(ITreeNode targetContext, CodeRegionPosition codeRegionPosition, Predicate`1<ICodeRegion> acceptRegion);
    [CanBeNullAttribute]
private PreprocessorCondition GetPreprocessorCondition(ICodeRegion codeRegion);
    [CanBeNullAttribute]
private static PreprocessorCondition ParseCondition(IPreprocessorExpression expression);
    [CompilerGeneratedAttribute]
internal static bool <GetContainingPreprocessorBranchCondition>g__StartsWithTargetNode|2_0(ICodeRegion region, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetContainingPreprocessorBranchCondition>g__EndsWithTargetNode|2_1(ICodeRegion region, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
private PreprocessorCondition <GetPreprocessorCondition>g__FindConditionByElseBranch|3_0(IPreprocessorDirective elseDirective);
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.PreprocessorConditionPart : object {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNegated>k__BackingField;
    [NotNullAttribute]
public string Expression { get; }
    public bool IsNegated { get; }
    public PreprocessorConditionPart(string expression, bool isNegated);
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public bool get_IsNegated();
    [NotNullAttribute]
[PureAttribute]
public PreprocessorConditionPart Negate();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PreprocessorConditionPart left, PreprocessorConditionPart right);
    public static bool op_Inequality(PreprocessorConditionPart left, PreprocessorConditionPart right);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.PreprocessorUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static PreProcessingDirective[] GetPPDirectivesAtPoint(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsPreprocessorDirectiveChildren(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsPreprocessorDirectiveOrCommentChildren(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsPreprocessorDirectiveOrErrorChildren(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsPreprocessorDirectiveOrCommentOrErrorChildren(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsPreprocessorDirectives(ITreeRange range);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsPreprocessorDirectives(ITreeNode node, ITreeNode nodeToSkip);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsPreprocessorDirectives(ITreeNode node, Func`2<IPreprocessor, bool> predicate, ITreeNode nodeToSkip);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsPreprocessorDirectiveOrCommentOrError(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode FindPreprocessorDirectiveOrCommentOrError(ITreeNode node);
    [PureAttribute]
internal static bool CheckIfThereIsNoCharInDocument(ITreeNode node, char ch);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasPreprocessorNodesAround(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasPreprocessorSiblingsBefore(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasPreprocessorSiblingsAfter(ITreeNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.RawStringModificationUtil : object {
    public static void AddQuotes(IStringLiteralOwner stringLiteralOwner, int amount);
    public static void RemoveQuotes(IStringLiteralOwner stringLiteralOwner, int amount);
    public static void AddDollars(IInterpolatedStringExpression expression, int amount);
    public static void RemoveDollars(IInterpolatedStringExpression expression, int amount);
    public static void ConvertToSingleLine(IStringLiteralOwner stringLiteralOwner);
    public static void ConvertToMultiLine(IStringLiteralOwner stringLiteralOwner);
    private static void InvertMultiLinePresentation(ICSharpLiteralExpression expression);
    private static void InvertMultiLinePresentation(IInterpolatedStringExpression expression);
    private static void AddRemoveQuotes(IStringLiteralOwner stringLiteralOwner, int quotesDelta);
    [ExtensionAttribute]
private static void AddRemoveQuotes(ICSharpLiteralExpression expression, int quotesDelta);
    [ExtensionAttribute]
private static void AddRemoveQuotes(IInterpolatedStringExpression expression, int quotesDelta);
    [ExtensionAttribute]
private static void AddRemoveDollars(IInterpolatedStringExpression expression, int dollarsDelta);
    private static void SetNewTokenText(ITokenNode literal, string newText);
    private static void AppendTextBetweenBorders(StringBuilder sb, string text, CSharpLiteralType literalType);
    private static void AppendMultiple(StringBuilder sb, char ch, int count);
    private static void AppendSubstring(StringBuilder sb, string text, TextRange textRange);
    private static void AddRemoveAtOffset(ITokenNode literal, char ch, int offset, int delta);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Util.RawStringPresentationParameters : ValueType {
    [CompilerGeneratedAttribute]
private bool <MultiLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DollarSignCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LineEnding>k__BackingField;
    [CompilerGeneratedAttribute]
private Utf8Suffix <StringSuffix>k__BackingField;
    public static RawStringPresentationParameters Default;
    public bool MultiLine { get; public set; }
    public int QuoteCount { get; public set; }
    public int DollarSignCount { get; public set; }
    public string Indent { get; public set; }
    public string LineEnding { get; public set; }
    public Utf8Suffix StringSuffix { get; public set; }
    private static RawStringPresentationParameters();
    [CompilerGeneratedAttribute]
public bool get_MultiLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MultiLine(bool value);
    [CompilerGeneratedAttribute]
public int get_QuoteCount();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QuoteCount(int value);
    [CompilerGeneratedAttribute]
public int get_DollarSignCount();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DollarSignCount(int value);
    [CompilerGeneratedAttribute]
public string get_Indent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Indent(string value);
    [CompilerGeneratedAttribute]
public string get_LineEnding();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineEnding(string value);
    [CompilerGeneratedAttribute]
public Utf8Suffix get_StringSuffix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StringSuffix(Utf8Suffix value);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.RawStringPresentationUtil : object {
    [PureAttribute]
public static string ConvertValueToRawPresentation(string value, ICSharpLiteralExpression valueOwner);
    [PureAttribute]
public static string ConvertValueToRawPresentation(string value, IInterpolatedStringExpression valueOwner, bool createInterpolatedString);
    [NotNullAttribute]
[PureAttribute]
public static string ConvertValueToRawPresentation(string value, RawStringPresentationParameters& parameters, bool optimizeParameters);
    public static void AppendStart(StringBuilder builder, RawStringPresentationParameters& parameters);
    public static void AppendValue(StringBuilder builder, RawStringPresentationParameters& parameters, string value, bool isLastValuePart);
    public static void AppendEnd(StringBuilder builder, RawStringPresentationParameters& parameters);
    [PureAttribute]
public static ValueTuple`2<string, string> CreateInterpolationBorders(RawStringPresentationParameters parameters);
    [PureAttribute]
public static string OpenBraces(int count);
    [PureAttribute]
public static string CloseBraces(int count);
    [PureAttribute]
public static RawStringPresentationParameters GetPresentationParametersFrom(ITreeNode context);
    [PureAttribute]
public static RawStringPresentationParameters GetPresentationParametersFrom(ICSharpLiteralExpression expression);
    [PureAttribute]
[NotNullAttribute]
private static string GetIndentByNode(ITreeNode expression);
    [PureAttribute]
public static RawStringPresentationParameters GetPresentationParametersFrom(IInterpolatedStringExpression expression);
    [PureAttribute]
private static string GetLineEnding(ITreeNode context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.RecursiveExpressionUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool HasRecursion(ICSharpExpression expression);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("Use overload with IDeclaredElement")]
public static bool HasRecursion(ICSharpExpression expression, ICSharpDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasRecursion(ICSharpExpression expression, IDeclaredElement containerElement);
    [PureAttribute]
private static bool HasReferenceExpressionRecursion(IReferenceExpression referenceExpression, IDeclaredElement containerElement);
    [PureAttribute]
private static bool HasElementAccessRecursion(IElementAccessExpression elementAccessExpression, IDeclaredElement containerElement);
    [PureAttribute]
private static bool HasOperatorExpressionRecursion(IOperatorExpression operatorExpression, IDeclaredElement containerElement);
    [PureAttribute]
private static bool HasConstructorRecursion(IObjectCreationExpression objectCreationExpression, IDeclaredElement containerElement);
    [PureAttribute]
private static bool HasConversionRecursion(ICSharpExpression expression, IConversionOperator conversionOperator);
    [PureAttribute]
private static bool HasDeconstructionRecursion(ICSharpExpression expression, IMethod deconstructMethod);
    [PureAttribute]
private static IDeclaredElement GetContainerElement(ITreeNode element);
    [CompilerGeneratedAttribute]
internal static bool <HasReferenceExpressionRecursion>g__HasAccessorRecursion|3_0(<>c__DisplayClass3_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <HasDeconstructionRecursion>g__HasDeconstructionRecursionInPattern|8_0(IPattern pattern, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <HasDeconstructionRecursion>g__HasDesignationDeconstructionRecursion|8_1(IVariableDesignation variableDesignation, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static IConstructor <GetContainerElement>g__GetSingleInstanceConstructor|9_0(ITypeMember typeMember);
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.RegionStructureTreeNodeNavigator : object {
    [NotNullAttribute]
private ITreeNode mySourceNode;
    public RegionStructureTreeNodeNavigator(ITreeNode sourceNode);
    [NotNullAttribute]
public sealed virtual ITreeRange GetRange(ITreeNode node);
    public sealed virtual TreeNodeActionType GetAction(ITreeNode node);
    public sealed virtual bool IsSignificant(ITreeNode node);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ReturnStatementUtil : object {
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICSharpDeclaration FindReturnOwnerDeclaration(ITreeNode returnContext);
    [NotNullAttribute]
[PureAttribute]
public static IType FindRealReturnType(ICSharpDeclaration returnOwner);
    [NotNullAttribute]
[PureAttribute]
public static IType FindExpectedReturnType(IReturnValueHolder returnHolder, IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public static IType FindExpectedReturnType(ICSharpDeclaration returnOwner, IResolveContext resolveContext);
    [CanBeNullAttribute]
[PureAttribute]
public static IType GetIteratorElementType(IType returnType, ITreeNode context);
    [PureAttribute]
public static bool CanBecomeIteratorDeclaration(ICSharpDeclaration returnOwnerDeclaration);
    [PureAttribute]
public static bool CanBecomeAsyncDeclaration(ICSharpDeclaration returnOwnerDeclaration);
    [PureAttribute]
public static bool IsIteratorDeclaration(ICSharpDeclaration returnOwnerDeclaration);
    [PureAttribute]
public static bool IsAsyncDeclaration(ICSharpDeclaration returnOwnerDeclaration);
    [PureAttribute]
public static ReferenceKind GetReturnKind(ICSharpDeclaration returnOwnerDeclaration, IResolveContext resolveContext);
    [PureAttribute]
public static ReferenceKind GetReturnKind(IAnonymousFunctionExpression anonymousFunctionExpression, IResolveContext resolveContext);
    [PureAttribute]
public static bool IsDefinitelyVoidReturnDeclaration(ICSharpDeclaration returnOwnerDeclaration, IResolveContext resolveContext);
    [PureAttribute]
public static bool IsDefinitelyVoidReturnMethod(IMethodDeclaration methodDeclaration);
    [PureAttribute]
public static bool IsDefinitelyVoidReturnLocalFunction(ILocalFunctionDeclaration localFunctionDeclaration);
    [PureAttribute]
private static bool IsVoidKeyword(ITypeUsage typeUsage);
    [CanBeNullAttribute]
[PureAttribute]
public static IUserTypeUsage GetContainingGenericTaskTypeUsage(ITypeUsage taskTypeArgument);
    [CanBeNullAttribute]
[PureAttribute]
public static IUserTypeUsage GetContainingGenericEnumerableTypeUsage(ITypeUsage enumerableTypeArgument);
    public static bool HasOtherReturnStatements(ICSharpDeclaration functionLikeDeclaration, IReturnValueHolder knownReturnStatement);
    [PureAttribute]
public static bool HasTryFinallyCodeToExecuteAfterReturn(ICSharpStatement returnStatement);
    [PureAttribute]
public static bool IsTailStatementInReturnOwner(ICSharpStatement statement);
    [CompilerGeneratedAttribute]
internal static ReferenceKind <GetReturnKind>g__Merge|10_0(Nullable`1<ReferenceKind> was, ReferenceKind now);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.ReturnTypeCollector : TreeNodeVisitor {
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [CompilerGeneratedAttribute]
private List`1<IExpressionType> <CollectedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRefReturn>k__BackingField;
    [NotNullAttribute]
public List`1<IExpressionType> CollectedTypes { get; }
    public bool IsRefReturn { get; private set; }
    public bool ProcessingIsFinished { get; }
    public ReturnTypeCollector(IResolveContext resolveContext);
    [CompilerGeneratedAttribute]
public List`1<IExpressionType> get_CollectedTypes();
    [CompilerGeneratedAttribute]
public bool get_IsRefReturn();
    [CompilerGeneratedAttribute]
private void set_IsRefReturn(bool value);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public virtual void VisitReturnStatement(IReturnStatement returnStatementParam);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.ScopingUtil : object {
    private static Char[] ourDigits;
    private static ObjectPool`1<PooledHashSet`1<IDeclaredElement>> ourHashSetPool;
    private static ScopingUtil();
    [PureAttribute]
public static Dictionary`2<IDeclaredElement, string> CollectConflictsAndSuggestRenames(ITreeNode nodeToMove, ITreeNode targetScope);
    [PureAttribute]
public static Dictionary`2<IDeclaredElement, string> CollectConflictsAndSuggestRenames(IEnumerable`1<ITreeNode> nodesToMove, ITreeNode targetScope);
    public static void PerformRenameToAvoidConflicts(ITreeNode nodeToMoveScope, Dictionary`2<IDeclaredElement, string> renames);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanUnwrapWithoutNamingCollisionsInto(IBlock block, IStatementsOwner parentStatementsOwner);
    [PureAttribute]
public static bool CanReplaceStatementByBodyWithoutNamingCollisions(IStatementsOwner statementsOwner, ICSharpStatement statement, ICSharpStatement statementBody);
    private static PooledHashSet`1<string> CollectDeclarationNames(ITreeNode root, ITreeNode nodeToSkip, bool traverseInnerScopes);
    [PureAttribute]
private static PooledHashSet`1<IDeclaredElement> CollectDeclarations(IEnumerable`1<ITreeNode> searchRoots, bool traverseInnerScopes);
    [PureAttribute]
public static ITreeNode FindParameterScopeNode(IParameter parameter, IReferenceExpression referenceExpression);
    [CompilerGeneratedAttribute]
internal static bool <CollectConflictsAndSuggestRenames>g__HasConflictingElements|1_1(<>c__DisplayClass1_0& , <>c__DisplayClass1_1& , <>c__DisplayClass1_2& );
    [CompilerGeneratedAttribute]
internal static string <CollectConflictsAndSuggestRenames>g__SuggestNameWithIndexSuffix|1_2(<>c__DisplayClass1_0& , <>c__DisplayClass1_2& );
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<ILocalScope> <CollectConflictsAndSuggestRenames>g__GetTargetScopes|1_0(ILocalScope localScope);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static ITreeNode <FindParameterScopeNode>g__FromFunctionDeclaration|9_0(ICSharpFunctionDeclaration functionDeclaration);
    [CompilerGeneratedAttribute]
[PureAttribute]
internal static IQueryParameterPlatform <FindParameterScopeNode>g__FindParameterPlatformOfRangeVariableInContext|9_1(IQueryRangeVariableDeclaration rangeVariableDeclaration, ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.StackAllocExpressionUtil : object {
    [PureAttribute]
public static bool IsAllowedContext(ICSharpExpression expression);
    [PureAttribute]
public static bool IsAllowedCSharp72Context(ICSharpExpression expression, IExpressionInitializer& expressionInitializer);
    [PureAttribute]
public static bool IsManaged(IStackAllocExpression stackAllocExpression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.StatementSpacingUtil : object {
    private static ControlStatementKind GetControlStatementKind(ICSharpStatement statement);
    [PureAttribute]
public static ControlStatementKind FindControlStatement(ICSharpStatement statement, Int32& level);
    public static bool ShouldSeparate(ICSharpStatement firstStatement, ICSharpStatement secondStatement);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Util.StatementToExpressionConversion : ValueType {
    public static StatementToExpressionConversion None;
    [CompilerGeneratedAttribute]
private ICSharpStatement <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private Kind <ConversionKind>k__BackingField;
    public ICSharpStatement Statement { get; }
    public Kind ConversionKind { get; }
    public bool IsAvailable { get; }
    private StatementToExpressionConversion(int dummy);
    internal StatementToExpressionConversion(ICSharpStatement statement, bool ignorePreprocessor, bool allowConversionFromInvalidCode);
    private static StatementToExpressionConversion();
    [CompilerGeneratedAttribute]
public ICSharpStatement get_Statement();
    [CompilerGeneratedAttribute]
public Kind get_ConversionKind();
    public bool get_IsAvailable();
    [NullableContextAttribute("1")]
[PureAttribute]
public ICSharpExpression Execute();
    [PureAttribute]
public ICSharpExpression ExtractExpressionFromStatement();
    [PureAttribute]
public bool IsNiceEnoughForExpressionBody();
    private static bool IsNiceEnoughForExpressionBody(ExpressionNiceCheckContext context);
    [NullableContextAttribute("1")]
public static bool IsExpressionBodyNiceFor(IExpressionBodyOwnerDeclaration declaration, ICSharpExpression expression, Kind possibleConversionKind);
    [NullableContextAttribute("1")]
public ITreeNode GetNodeToHighlight();
    [PureAttribute]
private static Kind GetConversionKind(ICSharpStatement statement, bool ignorePreprocessor, bool allowConversionFromInvalidCode);
    [NullableContextAttribute("1")]
[PureAttribute]
private static ITreeNode GetHighlightingNodeFromExpressionStatement(IExpressionStatement statement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.StatementUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("statement:null => null")]
public static ICSharpStatement GetPreviousStatement(ICSharpStatement statement, bool skipPreprocessor);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("statement:null => null")]
public static ICSharpStatement GetPreviousStatement(ICSharpStatement statement, Boolean& hasPreprocessor);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("statement:null => null")]
public static ICSharpStatement GetNextStatement(ICSharpStatement statement, bool skipPreprocessor);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("statement:null => null")]
public static ICSharpStatement GetNextStatement(ICSharpStatement statement, Boolean& hasPreprocessor);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICSharpStatementsRange ReplaceWithBlock(ICSharpStatement statementToReplace, IBlock blockToInsert);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICSharpStatementsRange ReplaceWithBody(ICSharpStatement statementToReplace, ICSharpStatement statementBody);
    public static TStatement InsertStatement(TStatement statement, TAnchorStatement& anchor, bool before);
    [NotNullAttribute]
public static TStatement Replace(ICSharpStatementsRange statementsRange, TStatement statement);
    public static TStatement InsertStatement(TStatement statement, ICSharpStatementsRange anchor, bool before);
    private static TStatement InsertNearLoneStatement(TStatement statement, bool before, TAnchor& anchorStatement);
    [CanBeNullAttribute]
public static ICSharpStatementsRange GetStatementsRange(ISolution solution, DocumentRange documentRange);
    [CanBeNullAttribute]
public static ICSharpStatementsRange GetStatementsRange(IFile file, TreeTextRange range);
    private static bool MustSkipTokens(ITreeNode elementAtRangeSkipedTokens, ITreeNode elementAtRange);
    private static TreeTextRange GetJoinedRange(IFile file, TreeTextRange range, bool skipTokens);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
[PureAttribute]
public static bool ContainsExecutableCode(ICSharpStatement statement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICSharpStatement GetParentStatementByBody(ICSharpStatement statement, bool includeObligatoryBlocks);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICSharpTreeNode GetBlockParentNode(IBlock block);
    [CanBeNullAttribute]
public static ICSharpStatement GetStatementUnderBlock(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool AlwaysEndsWithControlJump(ICSharpStatement statement);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("statement: null => null")]
public static ICSharpStatement GetSingleStatement(ICSharpStatement statement, bool ignorePreprocessor);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("statement: null => null")]
public static ICSharpStatement GetFirstStatementThroughBlocks(ICSharpStatement statement);
    [CanBeNullAttribute]
[PureAttribute]
public static ICSharpStatement GetSingleStatementOfStatementOwner(IStatementsOwner statementsOwner, bool ignorePreprocessor);
    [ExtensionAttribute]
[PureAttribute]
public static StatementToExpressionConversion GetStatementToExpressionConversion(ICSharpStatement statement, bool ignorePreprocessor, bool allowConversionFromInvalidCode);
    [ExtensionAttribute]
[PureAttribute]
public static StatementToExpressionConversion GetStatementToExpressionConversion(IBlock block, bool ignorePreprocessor, bool allowConversionFromInvalidCode);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ICSharpExpression TryGetSingleReturnedExpression(CSharpCodeBody codeBody);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("treeNode: null => null")]
public static ICSharpTreeNode GetContainingStatementLike(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("treeNode: null => null")]
public static ICSharpTreeNode FindContainingStatementEnsureableNode(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmptyOrNotImplemented(CSharpCodeBody codeBody);
    [PureAttribute]
private static bool IsNotImplementedExceptionCreationExpression(ICSharpExpression expression);
    [PureAttribute]
private static bool IsTodoReferenceExpression(ICSharpExpression expression);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBlock EnsureStatementLambda(ILambdaExpression lambdaExpression, bool enforceReturnStatement);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBlock EnsureStatementMemberBody(IExpressionBodyOwnerDeclaration expressionBodyOwnerDeclaration, bool enforceReturnStatement);
    [ExtensionAttribute]
public static void EnsureHasExplicitAccessorDeclarations(IAccessorOwnerDeclaration accessorOwnerDeclaration);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TCSharpExpression EnsureStatementExpression(TCSharpExpression expression);
    [CanBeNullAttribute]
public static TCSharpExpression EnsureStatementNode(TCSharpExpression expression);
    [CanBeNullAttribute]
public static TTreeNode EnsureStatementNode(ICSharpTreeNode statementLike, TTreeNode expression, ICSharpStatement& resultingStatement);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanEnsureStatementExpression(ICSharpExpression expression);
    public static bool CanEnsureStatementNode(ICSharpTreeNode statementLike, ITreeNode treeNode);
    [ExtensionAttribute]
[NotNullAttribute]
public static IBlock EnsureStatementInBlock(ICSharpStatement statement);
    [ExtensionAttribute]
[NotNullAttribute]
public static IStatementsOwner EnsureStatementInStatementsOwner(ICSharpStatement statement);
    [NotNullAttribute]
private static IBlock WrapStatementIntoBlock(ICSharpStatement statement);
    [ExtensionAttribute]
[NotNullAttribute]
public static ICSharpStatement EnsureExpressionInStatement(ICSharpExpression expression);
    [NotNullAttribute]
public static ILocalVariableDeclaration MoveExpressionToVariable(ICSharpExpression expression, ICSharpStatement anchorStatement, bool removeUsageWhenTrivial);
    [NotNullAttribute]
public static ILocalVariableDeclaration MoveExpressionToVariable(ICSharpExpression expression, ICSharpStatement anchorStatement, IReferenceExpression& variableUsage, INamesSuggestion& namesSuggestion, bool removeUsageWhenTrivial);
    [NotNullAttribute]
private static IBlock ConvertToStatementBody(ICSharpExpression bodyExpression, ICSharpDeclaration returnOwner, Nullable`1<bool> convertToReturnStatement);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IThrowStatement ToStatement(IThrowExpression throwExpression);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IThrowExpression ToExpression(IThrowStatement throwStatement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool HasTrailingSemicolon(ICSharpStatement statement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsBlockWithNonParsableElement(IBlock block);
    [ExtensionAttribute]
[PureAttribute]
public static BidirectionalStatementsEnumerator GetSiblingStatementsEnumerator(ICSharpStatement statement);
    [PureAttribute]
public static bool ContainsYieldReturnOrAwait(ITreeNode body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Util.StringAnalysisUtil : object {
    private static NodeTypeSet ourNonContentInterpolatedStringTokens;
    public static Regex LineBreakRegex;
    private static StringAnalysisUtil();
    public static VerbatimitySuggestion AnalyzeVerbatimity(IStringLiteralOwner element);
    private static VerbatimitySuggestion AnalyzeVerbatimity(ICSharpLiteralExpression element);
    private static VerbatimitySuggestion AnalyzeVerbatimity(IInterpolatedStringExpression element);
    private static VerbatimitySuggestion AnalyzeVerbatimity(IStringLiteralOwner stringLiteralOwner, SpecialCharactersUsageInfo& usageInfo, StringVerbatimity verbatimity);
    [NullableContextAttribute("2")]
private static VerbatimitySuggestion AnalyzeRegularString(SpecialCharactersUsageInfo& usageInfo);
    private static VerbatimitySuggestion AnalyzeVerbatimString(IStringLiteralOwner stringLiteralOwner, SpecialCharactersUsageInfo& usageInfo);
    private static VerbatimitySuggestion AnalyzeRawString(IStringLiteralOwner stringLiteralOwner, SpecialCharactersUsageInfo& usageInfo);
    public static bool IsVerbatimityRedundant(StringVerbatimity verbatimity, SpecialCharactersUsageInfo& usageInfo, bool isInterpolatedString);
    [NullableContextAttribute("0")]
private static ValueTuple`2<int, int> GetRawStringQuoteAndDollarSignCounts(ITokenNode startToken);
    public static bool IsMultiLineRawString(IStringLiteralOwner stringLiteralOwner);
    private static bool IsMultiLineRawString(ICSharpLiteralExpression expression);
    private static bool IsMultiLineRawString(IInterpolatedStringExpression expression);
    public static bool CanRawStringBeMadeSingleLine(IStringLiteralOwner stringLiteralOwner);
    private static bool CanRawStringBeMadeSingleLine(ICSharpLiteralExpression expression);
    private static bool CanRawStringBeMadeSingleLine(IInterpolatedStringExpression expression);
    private static bool ContainsLineBreak(string stringValue);
    [PureAttribute]
public static IList`1<ILineBreakError> GetLineBreakErrors(IInterpolatedStringExpression expression);
    [PureAttribute]
public static IList`1<ILineBreakError> GetPotentialLineBreakErrors(IInterpolatedStringExpression expression);
    [PureAttribute]
private static IList`1<ILineBreakError> GetExpressionLineBreakErrors(ICSharpExpression expression);
    private static void GetLineBreakErrorsImpl(ITreeNode treeNode, LocalList`1& errors, Boolean& hasPreprocessorBefore);
    [PureAttribute]
private static IList`1<ILineBreakError> GetInterpolationLineBreakErrorsImpl(IInterpolatedStringExpression expression);
    public static void FixLineBreaksWhenReplacingExpression(ICSharpExpression expression);
    public static void RemoveLineBreaks(IInterpolatedStringExpression interpolatedString, IList`1<ILineBreakError> errors);
    private static void InvertTokenVerbatimity(ITokenNode literalNode);
    [PureAttribute]
public static SpecialCharactersUsageInfo GetSpecialCharactersUsage(string value);
    private static void IncreaseOrResetCharacterCounter(char value, char expected, Int32& counter, Int32& maxValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.StringInterpolationUtil : object {
    public static NodeTypeSet VerbatimLiteralTokenTypes;
    public static NodeTypeSet MultilineRawLiteralTokenTypes;
    private static NodeTypeDictionary`1<BraceKind> ourParenthesesLeftTokenTypes;
    private static NodeTypeDictionary`1<BraceKind> ourParenthesesRightTokenTypes;
    private static NodeTypeSet ourColonTokenTypes;
    private static NodeTypeSet ourBraceAtEndInterpolationTokenTypes;
    private static NodeTypeSet ourBraceAtStartInterpolationTokenTypes;
    private static StringInterpolationUtil();
    [ExtensionAttribute]
public static IInterpolatedStringExpression GetContainingRegularInterpolatedString(ITreeNode expression);
    [ExtensionAttribute]
public static IInterpolatedStringExpression GetContainingInterpolatedString(ITreeNode expression);
    [PureAttribute]
private static bool ContainsColonToken(ITreeNode expression);
    private static bool IsColonAlreadyEscaped(ICSharpExpression insertExpression, ICSharpExpression replacedExpression);
    [NullableContextAttribute("0")]
private static void TrackBraceBalance(TokenNodeType tokenType, LocalList`1& parentheses);
    [NullableContextAttribute("2")]
public static bool NeedsColonTokenEscaping(ICSharpExpression replacedExpression, ICSharpExpression newExpression);
    public static bool IsOffsetInsideHole(ITokenNode tokenNode, TreeOffset treeOffset);
    [PureAttribute]
public static string GetStringLiteralOrTrivialInterpolationValue(ICSharpExpression expression);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.StringLiteralUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static string ConvertValueToPresentation(string value, StringVerbatimity presentationForm, CSharpLanguageLevel languageLevel);
    [NotNullAttribute]
[PureAttribute]
public static string ConvertValueToRegularPresentation(string value, CSharpLanguageLevel languageLevel);
    [NotNullAttribute]
[PureAttribute]
public static string ConvertValueToVerbatimPresentation(string value);
    [NotNullAttribute]
public static ICSharpLiteralExpression ReplaceWithStringLiteral(ICSharpExpression expression, string value);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.StronglyConnectedComponentsTarjan : StronglyConnectedComponentsTarjanBase {
    public StronglyConnectedComponentsTarjan(IControlFlowGraph graph);
    protected virtual void Prepare();
    [NotNullAttribute]
protected virtual IList`1<IControlFlowElement> GetAdditionalTargets(IControlFlowElement element);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.StronglyConnectedComponentsTarjanBase : object {
    [NotNullAttribute]
private Int32[] myLowLinks;
    [NotNullAttribute]
private Byte[] myComponents;
    [NotNullAttribute]
private Stack`1<IControlFlowElement> myStack;
    [CanBeNullAttribute]
private Stack`1<IControlFlowElement> myPoolStack;
    private byte myComponentId;
    private bool myHasComponents;
    private int myVisitId;
    [NotNullAttribute]
protected IControlFlowGraph Graph;
    [CompilerGeneratedAttribute]
private bool <TooManyComponents>k__BackingField;
    public bool TooManyComponents { get; private set; }
    public StronglyConnectedComponentsTarjanBase(IControlFlowGraph graph);
    [CompilerGeneratedAttribute]
public bool get_TooManyComponents();
    [CompilerGeneratedAttribute]
private void set_TooManyComponents(bool value);
    [CanBeNullAttribute]
public Byte[] Run();
    protected abstract virtual void Prepare();
    protected void Traverse(IControlFlowElement element);
    protected abstract virtual IList`1<IControlFlowElement> GetAdditionalTargets(IControlFlowElement element);
    protected void StoreComponent(IControlFlowElement element);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.SwitchStatementUtil : object {
    [NotNullAttribute]
public static IType ComputeGoverningType(ICSharpExpression switchExpression);
    [NotNullAttribute]
[PureAttribute]
public static IType ComputeGoverningTypeOldWay(IExpressionType switchExpressionType, IPsiModule module);
    [PureAttribute]
[NotNullAttribute]
public static IType ComputeGoverningTypeCSharp7Way(IExpressionType switchExpressionType, IPsiModule module);
    [PureAttribute]
[CanBeNullAttribute]
public static IType FindImplicitConversionTypeViaCustomOperator(IExpressionType conditionExpressionType);
    [CanBeNullAttribute]
[PureAttribute]
private static IType TryFindSuitableOperator(IDeclaredType conditionType, ITypeElement typeElement);
    [PureAttribute]
private static bool IsValidGoverningType(IType type);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<IField> GetMissingCases(ISwitchStatement switchStatement, Boolean& defaultCaseIsMissing, Boolean& nullCaseIsMissing);
    public static PatternMatchKind GetMatchKind(ISwitchStatement switchStatement, CaseLabelPatternMatchInfo& lastCaseLabelInfo, Boolean& areThereReachableCasesNotDiscard);
    [CompilerGeneratedAttribute]
internal static bool <TryFindSuitableOperator>g__IsValidCSharp6SwitchGoverningType|4_0(IType operatorType);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.TargetTypedExpressionPresenceChecker : object {
    [PureAttribute]
protected abstract virtual bool IsRequiredExpression(ITreeNode node, ICSharpExpression& expression);
    [PureAttribute]
protected abstract virtual bool CheckClosedChameleonNode(ILexer lexer, Boolean& evidentOnly);
    [PureAttribute]
public bool PossiblyContains(ICSharpFile file, Boolean& evidentOnly);
    [PureAttribute]
public bool PossiblyContains(IChameleonNode closedChameleonNode, Boolean& evidentOnly);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TargetTypedNewPresenceChecker : TargetTypedExpressionPresenceChecker {
    public static TargetTypedNewPresenceChecker Instance;
    private static TargetTypedNewPresenceChecker();
    protected virtual bool IsRequiredExpression(ITreeNode node, ICSharpExpression& expression);
    protected virtual bool CheckClosedChameleonNode(ILexer lexer, Boolean& evidentOnly);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TaskNormalizer : TypeNormalizerBase {
    private CSharpLanguageLevel myLanguageLevel;
    public TaskNormalizer(CSharpLanguageLevel languageLevel);
    [NotNullAttribute]
public IType Normalize(IType type);
    protected virtual IType ProcessTypeElement(IType type, IType context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.ThrowStatementExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICatchClause GetContainingCatchClauseToRethrowException(IThrowStatement throwStatement);
    [ExtensionAttribute]
public static bool IsInsideFinallyAndCatch(IThrowStatement statement);
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.TypeCheckStaticAnalysisKind : Enum {
    public int value__;
    public static TypeCheckStaticAnalysisKind UnknownTarget;
    public static TypeCheckStaticAnalysisKind IsTypeCheck;
    public static TypeCheckStaticAnalysisKind NotNullOfType;
    public static TypeCheckStaticAnalysisKind IntroduceVar;
    public static TypeCheckStaticAnalysisKind NotNull;
    public static TypeCheckStaticAnalysisKind NotNullAndMore;
    public static TypeCheckStaticAnalysisKind NotNullOfTypeAndMore;
    public static TypeCheckStaticAnalysisKind IsNotNullValueOfType;
    public static TypeCheckStaticAnalysisKind IsNull;
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.TypeCheckStaticAnalysisResult : Enum {
    public int value__;
    public static TypeCheckStaticAnalysisResult Unknown;
    public static TypeCheckStaticAnalysisResult UnknownCanCompareConstant;
    public static TypeCheckStaticAnalysisResult CompilerErrorSourceExpressionHasNoType;
    public static TypeCheckStaticAnalysisResult CompilerErrorInvalidPatternOperand;
    public static TypeCheckStaticAnalysisResult CompilerErrorInvalidPatternType;
    public static TypeCheckStaticAnalysisResult CompilerErrorInvalidIsOperator;
    public static TypeCheckStaticAnalysisResult CompilerErrorStaticClassPatternType;
    public static TypeCheckStaticAnalysisResult CompilerErrorNullablePatternType;
    public static TypeCheckStaticAnalysisResult CompilerErrorDynamicPatternType;
    public static TypeCheckStaticAnalysisResult CompilerErrorBadConstantValue;
    public static TypeCheckStaticAnalysisResult AlwaysTrueCompilerWarning;
    public static TypeCheckStaticAnalysisResult AlwaysTrue;
    public static TypeCheckStaticAnalysisResult AlwaysTrueIntroducesVariable;
    public static TypeCheckStaticAnalysisResult AlwaysTrueWhenNotNullCompilerWarningDynamic;
    public static TypeCheckStaticAnalysisResult AlwaysTrueWhenNotNull;
    public static TypeCheckStaticAnalysisResult TypeCheckTrue;
    public static TypeCheckStaticAnalysisResult TypeCheckTrueWhenNotNull;
    public static TypeCheckStaticAnalysisResult AlwaysFalseCompilerWarning;
    public static TypeCheckStaticAnalysisResult AlwaysFalse;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.TypeCheckStaticAnalysisUtil : object {
    [PureAttribute]
public static TypeCheckStaticAnalysisResult CompileTimeResult(IIsExpression isExpression, IResolveContext resolveContext);
    [PureAttribute]
public static TypeCheckStaticAnalysisResult CompileTimeResult2(IIsExpression isExpression, ICSharpTypeConversionRule conversionRule, CSharpLanguageLevel languageLevel, IResolveContext resolveContext);
    [PureAttribute]
public static TypeCheckStaticAnalysisResult CompileTimeResultImpl(IExpressionType sourceExpressionType, IType typeCheckType, ICSharpTypeConversionRule conversionRule, TypeCheckStaticAnalysisKind analysisKind, CSharpLanguageLevel languageLevel);
    [PureAttribute]
private static TypeCheckStaticAnalysisResult CompileTimeResultForConstantType(ICSharpConstantType sourceConstantType, IType typeCheckType, TypeCheckStaticAnalysisKind analysisKind, CSharpLanguageLevel languageLevel, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
private static TypeCheckStaticAnalysisResult CompileTimeResultForNullLiteral(TypeCheckStaticAnalysisKind analysisKind);
    [PureAttribute]
private static TypeCheckStaticAnalysisResult CompileTimeResultIfHasNoIType(IExpressionType sourceExpressionType, TypeCheckStaticAnalysisKind analysisKind, CSharpLanguageLevel languageLevel);
    [PureAttribute]
private static Nullable`1<TypeCheckStaticAnalysisResult> CompileTimePatternAnalysis(IType sourceType, IExpressionType patternExpressionType, TypeCheckStaticAnalysisKind analysisKind, CSharpLanguageLevel languageLevel, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
private static TypeCheckStaticAnalysisResult CompileTimeResultForConstantTypeCheckForTypeParameterType(ICSharpConstantType sourceConstantType, IType typeCheckType, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
private static TypeCheckStaticAnalysisResult CompileTimeResultOfTypeCheckForTypeParameterType(ITypeParameter isTypeParameter, IType operandType, ITypeElement operandTypeElement, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
private static TypeCheckStaticAnalysisResult CompileTimeResultOfTypeParameterTypeTypeCheck(IType isType, ITypeParameter operandTypeParameter, IDeclaredType operandType, ICSharpTypeConversionRule conversionRule);
    [PureAttribute]
public static TypeCheckStaticAnalysisKind GetAnalysisKind(IIsExpression isExpression, IResolveContext resolveContext);
    [PureAttribute]
public static TypeCheckStaticAnalysisKind GetAnalysisKind(IPattern pattern, IResolveContext resolveContext);
    [PureAttribute]
public static TypeCheckStaticAnalysisKind GetConstantCheckAnalysisKind(ConstantValue constantValue);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPatternMatching(TypeCheckStaticAnalysisKind analysisKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsConstantPattern(TypeCheckStaticAnalysisKind analysisKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAlwaysTrue(TypeCheckStaticAnalysisKind analysisKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsFalseWhenNull(TypeCheckStaticAnalysisKind analysisKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTrueWhenNull(TypeCheckStaticAnalysisKind analysisKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAlwaysTrue(TypeCheckStaticAnalysisResult result);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAlwaysTrueWhenNotNull(TypeCheckStaticAnalysisResult result);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAlwaysFalse(TypeCheckStaticAnalysisResult result);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsErrorneous(TypeCheckStaticAnalysisResult result);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCompilerWarning(TypeCheckStaticAnalysisResult result);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.TypeParameterOracle : object {
    [ExtensionAttribute]
[PureAttribute]
public static Classification ClassifyAdvanced(ITypeParameter typeParameter);
    [ExtensionAttribute]
[PureAttribute]
public static Classification ClassifyTypeAdvanced(IType type);
    [PureAttribute]
private static bool CanBeNullable(ITypeParameter typeParameter, JetHashSet`1<ITypeParameter> visited);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CSharp.Util.TypeParameterOracle/<EnumerateSuperTypeParameters>d__3")]
[ItemNotNullAttribute]
private static IEnumerable`1<ITypeParameter> EnumerateSuperTypeParameters(ITypeParameter typeParameter);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeValueType(Classification classification);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeReferenceType(Classification classification);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.AmbiguousConversionResult : TypeMismatchResult {
    public AmbiguousConversionResult(ITypeComparisonContext context);
    public virtual RichText GetDescription();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.ArrayTypeComparisonContext : TypeComparisonContext {
    [CompilerGeneratedAttribute]
private Int32[] <ArrayDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeNodeCollection`1<IUnsafeCodePointer> <UnsafeCodePointers>k__BackingField;
    [CompilerGeneratedAttribute]
private INullableTypeMark <NullableMark>k__BackingField;
    [NotNullAttribute]
public Int32[] ArrayDimensions { get; }
    private TreeNodeCollection`1<IUnsafeCodePointer> UnsafeCodePointers { get; }
    private INullableTypeMark NullableMark { get; }
    public ArrayTypeComparisonContext(Pair`2<ITreeNode, ITreeNode> typeUsageNode, IExpression actualTypeSource, IType actualUnderlyingType, IType actualType, IType expectedType, Pair`2<ITreeNode, ITreeNode> typeElementRange, ITypeArgumentList typeArgumentList, INullableTypeMark nullableMark, Int32[] arrayDimensions, TreeNodeCollection`1<IUnsafeCodePointer> unsafeCodePointers);
    [CompilerGeneratedAttribute]
public Int32[] get_ArrayDimensions();
    [CompilerGeneratedAttribute]
private TreeNodeCollection`1<IUnsafeCodePointer> get_UnsafeCodePointers();
    [CompilerGeneratedAttribute]
private INullableTypeMark get_NullableMark();
    public virtual TypeComparisonResultBase MatchTypeExact(IEqualityComparer`1<IType> comparer);
    private bool MatchArrayDimensions();
    public virtual TypeComparisonResultBase MatchImplicitConversion(Nullable`1<TypeParameterVariance> variance);
    private bool MatchListToArray(IList`1<ITypeUsage> typeArguments, TypeComparisonResultBase& typeComparisonResultBase);
    private bool MatchArrayToList(TypeComparisonResultBase& typeComparisonResultBase);
    [PureAttribute]
private ITypeComparisonContext TrimSingleRankSpecifier(IType elementType, IType expectedElementType);
    protected virtual ITypeComparisonContext TrimRankSpecifiers(IType elementType, IType expectedElementType);
    [NotNullAttribute]
public static Int32[] GetDimensions(TreeNodeCollection`1<IRankSpecifier> rankSpecifiers);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.ExpressionTypeDeterminantUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static IExpression GetExpressionTypeDeterminant(IExpression expression, IType expectedType);
    [CanBeNullAttribute]
public static ITypeUsage GetTypeUsageFromExpression(IExpression expression);
}
public interface JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.ITypeComparisonContext {
    public Pair`2<ITreeNode, ITreeNode> TypeUsageRange { get; }
    [CanBeNullAttribute]
public IExpression ActualTypeSource { get; }
    [NotNullAttribute]
public IType ActualType { get; }
    [NotNullAttribute]
public IType ExpectedType { get; }
    public abstract virtual Pair`2<ITreeNode, ITreeNode> get_TypeUsageRange();
    public abstract virtual IExpression get_ActualTypeSource();
    public abstract virtual IType get_ActualType();
    public abstract virtual IType get_ExpectedType();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual TypeComparisonResultBase MatchTypeExact(IEqualityComparer`1<IType> comparer);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual TypeComparisonResultBase MatchImplicitConversion(Nullable`1<TypeParameterVariance> variance);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual TypeComparisonResultBase MatchNullability();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.MissingTupleTypeComponentResult : TypeComparisonResultBase {
    private TupleTypeComponent myMissingComponent;
    public MissingTupleTypeComponentResult(ITupleComponent actualComponent, TupleTypeComponent missingComponent, ITupleExpression tupleExpression, IType actualType, IType suggestedExpectedType);
    public virtual RichText GetDescription();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.NullableTypeComparisonContext : TypeComparisonContext {
    private INullableTypeMark myNullableMark;
    [CompilerGeneratedAttribute]
private bool <IsActualUnderlyingTypeNullable>k__BackingField;
    private bool IsActualUnderlyingTypeNullable { get; }
    public NullableTypeComparisonContext(Pair`2<ITreeNode, ITreeNode> typeUsageNode, IExpression actualTypeSource, IType actualUnderlyingType, IType actualType, IType expectedType, Pair`2<ITreeNode, ITreeNode> typeElementRange, ITypeArgumentList typeArgumentList, INullableTypeMark nullableMark);
    [CompilerGeneratedAttribute]
private bool get_IsActualUnderlyingTypeNullable();
    public virtual TypeComparisonResultBase MatchTypeExact(IEqualityComparer`1<IType> comparer);
    public virtual TypeComparisonResultBase MatchImplicitConversion(Nullable`1<TypeParameterVariance> variance);
    [PureAttribute]
private ITypeComparisonContext TrimNullableMark(IType expectedType);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.PointerTypeComparisonContext : TypeComparisonContext {
    [CompilerGeneratedAttribute]
private TreeNodeCollection`1<IUnsafeCodePointer> <UnsafeCodePointers>k__BackingField;
    [CompilerGeneratedAttribute]
private INullableTypeMark <NullableMark>k__BackingField;
    public TreeNodeCollection`1<IUnsafeCodePointer> UnsafeCodePointers { get; }
    private INullableTypeMark NullableMark { get; }
    public PointerTypeComparisonContext(Pair`2<ITreeNode, ITreeNode> typeUsageNode, IExpression actualTypeSource, IType actualUnderlyingType, IType actualType, IType expectedType, Pair`2<ITreeNode, ITreeNode> typeElementRange, ITypeArgumentList typeArgumentList, INullableTypeMark nullableMark, TreeNodeCollection`1<IUnsafeCodePointer> unsafeCodePointers);
    [CompilerGeneratedAttribute]
public TreeNodeCollection`1<IUnsafeCodePointer> get_UnsafeCodePointers();
    [CompilerGeneratedAttribute]
private INullableTypeMark get_NullableMark();
    public virtual TypeComparisonResultBase MatchTypeExact(IEqualityComparer`1<IType> comparer);
    public virtual TypeComparisonResultBase MatchImplicitConversion(Nullable`1<TypeParameterVariance> variance);
    [CanBeNullAttribute]
private TypeComparisonResultBase MatchPointerTypes(IEqualityComparer`1<IType> comparer, bool requireExactMatch);
    private static int GetPointerArity(IPointerType pointerType);
    [PureAttribute]
public ITypeComparisonContext TrimUnsafeCodePointers(IType elementType, IType expectedElementType);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.RedundantTupleTypeComponentResult : TypeComparisonResultBase {
    [CompilerGeneratedAttribute]
private ITupleComponent <ActualComponent>k__BackingField;
    [NotNullAttribute]
public ITupleComponent ActualComponent { get; }
    public RedundantTupleTypeComponentResult(ITupleComponent tupleComponent, ITupleExpression tupleExpression, IType actualType, IType suggestedExpectedType);
    [CompilerGeneratedAttribute]
public ITupleComponent get_ActualComponent();
    public virtual RichText GetDescription();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.RedundantTypeParameterResult : TypeComparisonResultBase {
    [CompilerGeneratedAttribute]
private IType <TypeParameterType>k__BackingField;
    [NotNullAttribute]
public IType TypeParameterType { get; }
    public RedundantTypeParameterResult(ITypeUsage typeParameterUsage, IType suggestedType, IType suggestedExpectedType, IExpression actualTypeSource);
    [CompilerGeneratedAttribute]
public IType get_TypeParameterType();
    public virtual RichText GetDescription();
    [NotNullAttribute]
private RichText GetPresentableTypeParameterName();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TupleExpressionComparisonContext : object {
    [NotNullAttribute]
private ITupleExpression myTupleExpression;
    [CompilerGeneratedAttribute]
private IExpression <ActualTypeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ActualType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExpectedType>k__BackingField;
    public Pair`2<ITreeNode, ITreeNode> TypeUsageRange { get; }
    [NotNullAttribute]
public IExpression ActualTypeSource { get; }
    public IType ActualType { get; }
    public IType ExpectedType { get; }
    public TupleExpressionComparisonContext(ITupleExpression tupleExpression, IType expectedType);
    public sealed virtual Pair`2<ITreeNode, ITreeNode> get_TypeUsageRange();
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_ActualTypeSource();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ActualType();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpectedType();
    public sealed virtual TypeComparisonResultBase MatchTypeExact(IEqualityComparer`1<IType> comparer);
    public sealed virtual TypeComparisonResultBase MatchImplicitConversion(Nullable`1<TypeParameterVariance> variance);
    public sealed virtual TypeComparisonResultBase MatchNullability();
    [CanBeNullAttribute]
[PureAttribute]
private TypeComparisonResultBase CompareComponents(TreeNodeCollection`1<ITupleComponent> actualComponents, IReadOnlyList`1<TupleTypeComponent> expectedComponents);
    [NotNullAttribute]
private static IReadOnlyList`1<TupleTypeComponent> GetExpectedTupleComponents(IDeclaredType expectedType);
    [CompilerGeneratedAttribute]
private TypeComparisonResultBase <CompareComponents>g__CompareCore|16_0(int actualStartIndex, int expectedStartIndex, bool canTryAlternative, <>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
private TypeComparisonResultBase <CompareComponents>g__MakeComparisonResultForSingleMismatchedComponent|16_1(int componentIndex, ICSharpExpression tupleComponentValue, IType actualComponentType, TupleTypeComponent expectedComponent, IType expectedComponentType, <>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
private IType <CompareComponents>g__MakeSuggestedExpectedTypeWithRedundantComponent|16_2(ITupleComponent redundantComponent, int redundantComponentIndex, <>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
private IType <CompareComponents>g__MakeSuggestedExpectedTypeWithoutMissingComponent|16_3(int redundantTupleComponentIndex, <>c__DisplayClass16_0& );
}
internal class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TupleTypeComparisonContext : object {
    private ITupleTypeComponentList myTupleComponentList;
    [CompilerGeneratedAttribute]
private Pair`2<ITreeNode, ITreeNode> <TypeUsageRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <ActualTypeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ActualType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExpectedType>k__BackingField;
    public Pair`2<ITreeNode, ITreeNode> TypeUsageRange { get; }
    public IExpression ActualTypeSource { get; }
    public IType ActualType { get; }
    public IType ExpectedType { get; }
    public TupleTypeComparisonContext(ITupleTypeUsage typeUsageNode, ITupleTypeComponentList tupleComponentList, IType actualType, IType expectedType, IExpression actualTypeSource);
    [CompilerGeneratedAttribute]
public sealed virtual Pair`2<ITreeNode, ITreeNode> get_TypeUsageRange();
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_ActualTypeSource();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ActualType();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpectedType();
    public sealed virtual TypeComparisonResultBase MatchTypeExact(IEqualityComparer`1<IType> comparer);
    public sealed virtual TypeComparisonResultBase MatchImplicitConversion(Nullable`1<TypeParameterVariance> variance);
    public sealed virtual TypeComparisonResultBase MatchNullability();
    [CanBeNullAttribute]
[ContractAnnotationAttribute("candidate:notnull => notnull;")]
internal static TypeComparisonResultBase MatchTupleTypeImplicitConversion(Nullable`1<TypeParameterVariance> variance, IList`1<Pair`2<string, ITypeUsage>> typeArguments, IType expectedType, ITypeComparisonContext context, TypeComparisonResultBase candidate);
    [CanBeNullAttribute]
private static IReadOnlyList`1<TupleTypeComponent> TryGetTupleComponentsFromType(IType type);
    [CanBeNullAttribute]
private TypeComparisonResultBase MatchTupleComponentExactly(IEqualityComparer`1<IType> comparer, ITupleTypeComponent actualComponent, TupleTypeComponent expectedComponent);
    [NotNullAttribute]
private static IType GetSuggestionForImplicitConversionMismatch(IList`1<Pair`2<string, ITypeUsage>> typeArguments, int mismatchedComponentIndex, IType suggestedComponentType);
    [NotNullAttribute]
private static IType GetExpectedSuggestionForImplicitConversionMismatch(IType expectedType, int mismatchedComponentIndex, IType suggestedComponentType, IPsiModule psiModule);
    [NotNullAttribute]
private static IType ReplaceSubstitutionElement(int index, IType type, IType newSubstitution);
    [NotNullAttribute]
private static IType SuggestExpectedTypeByExpectedTRest(IType expectedType, IType suggestedExpectedRestType);
    [NotNullAttribute]
private static IType SuggestTypeByTRest(IList`1<Pair`2<string, ITypeUsage>> typeArguments, IType suggestedRestType);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TupleTypeComponentMismatchResult : TypeComparisonResultBase {
    [CompilerGeneratedAttribute]
private TupleTypeComponent <ActualComponent>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TupleTypeComponent> <ExpectedComponent>k__BackingField;
    public TupleTypeComponent ActualComponent { get; }
    public Nullable`1<TupleTypeComponent> ExpectedComponent { get; }
    public TupleTypeComponentMismatchResult(ITupleTypeComponent actualComponent, Nullable`1<TupleTypeComponent> expectedComponent, ITypeComparisonContext context);
    public TupleTypeComponentMismatchResult(ITypeUsage componentTypeUsage, Nullable`1<TupleTypeComponent> expectedComponent, ITypeComparisonContext context);
    [CompilerGeneratedAttribute]
public TupleTypeComponent get_ActualComponent();
    [CompilerGeneratedAttribute]
public Nullable`1<TupleTypeComponent> get_ExpectedComponent();
    public virtual RichText GetDescription();
    [NotNullAttribute]
private RichText PresentComponent(TupleTypeComponent component);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TupleTypeNameMismatchResult : TypeComparisonResultBase {
    [CompilerGeneratedAttribute]
private string <ActualName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpectedName>k__BackingField;
    [CanBeNullAttribute]
public string ActualName { get; }
    [CanBeNullAttribute]
public string ExpectedName { get; }
    public TupleTypeNameMismatchResult(ITreeNode errorNode, string actualName, string expectedName, ITypeComparisonContext context);
    [CompilerGeneratedAttribute]
public string get_ActualName();
    [CompilerGeneratedAttribute]
public string get_ExpectedName();
    public virtual RichText GetDescription();
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TypeComparisonContext : object {
    [CompilerGeneratedAttribute]
private Pair`2<ITreeNode, ITreeNode> <TypeUsageRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <ActualTypeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ActualUnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ActualType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExpectedType>k__BackingField;
    [CompilerGeneratedAttribute]
private Pair`2<ITreeNode, ITreeNode> <TypeElementRange>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeArgumentList <TypeArgumentList>k__BackingField;
    public Pair`2<ITreeNode, ITreeNode> TypeUsageRange { get; }
    public IExpression ActualTypeSource { get; }
    [NotNullAttribute]
public IType ActualUnderlyingType { get; }
    public IType ActualType { get; }
    public IType ExpectedType { get; }
    public Pair`2<ITreeNode, ITreeNode> TypeElementRange { get; protected set; }
    [CanBeNullAttribute]
public ITypeArgumentList TypeArgumentList { get; }
    public TypeComparisonContext(Pair`2<ITreeNode, ITreeNode> typeUsageNode, IExpression actualTypeSource, IType actualUnderlyingType, IType actualType, IType expectedType, Pair`2<ITreeNode, ITreeNode> typeElementRange, ITypeArgumentList typeArgumentList);
    [CompilerGeneratedAttribute]
public sealed virtual Pair`2<ITreeNode, ITreeNode> get_TypeUsageRange();
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_ActualTypeSource();
    [CompilerGeneratedAttribute]
public IType get_ActualUnderlyingType();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ActualType();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpectedType();
    [CompilerGeneratedAttribute]
public Pair`2<ITreeNode, ITreeNode> get_TypeElementRange();
    [CompilerGeneratedAttribute]
protected void set_TypeElementRange(Pair`2<ITreeNode, ITreeNode> value);
    [CompilerGeneratedAttribute]
public ITypeArgumentList get_TypeArgumentList();
    [CanBeNullAttribute]
public virtual TypeComparisonResultBase MatchTypeExact(IEqualityComparer`1<IType> comparer);
    [CanBeNullAttribute]
public virtual TypeComparisonResultBase MatchImplicitConversion(Nullable`1<TypeParameterVariance> variance);
    public sealed virtual TypeComparisonResultBase MatchNullability();
    [CanBeNullAttribute]
private TypeComparisonResultBase MatchTypeArgumentsExact(IEqualityComparer`1<IType> comparer, bool typeElementMismatch, ITypeElement actualTypeElement, TypeComparisonResultBase& candidate);
    [NotNullAttribute]
protected static IType GetElementType(IType type);
}
internal static class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TypeComparisonContextFactory : object {
    [CanBeNullAttribute]
public static ITypeComparisonContext CreateContext(ITreeNode typeUsageNode, IType expectedType);
    [CanBeNullAttribute]
internal static ITypeComparisonContext CreateFromTypeUsage(ITypeUsage typeUsage, IType expectedType, IExpression actualTypeSource);
    [CanBeNullAttribute]
internal static ITypeComparisonContext CreateFromTypeUsage(ITypeUsage typeUsage, Pair`2<ITreeNode, ITreeNode> matchingRange, IType expectedType, IType actualType, IExpression actualTypeSource);
    [CanBeNullAttribute]
private static ITypeComparisonContext CreateFromObjectCreationExpression(IObjectCreationExpression expression, IType expectedType);
    [CanBeNullAttribute]
private static ITypeComparisonContext CreateFromArrayCreationExpression(IArrayCreationExpression expression, IType expectedType);
    [CanBeNullAttribute]
private static ITypeComparisonContext CreateFromTupleExpression(ITupleExpression tupleExpression, IType expectedType);
    private static Pair`2<ITreeNode, ITreeNode> GetTypeElementRange(IScalarTypeUsage declaredTypeUsage);
    [CanBeNullAttribute]
private static ITypeComparisonContext CreateFromTupleTypeUsage(ITupleTypeUsage tupleTypeUsage, Pair`2<ITreeNode, ITreeNode> matchingRange, IType actualType, IType expectedType, IExpression actualTypeSource, INullableTypeMark nullableTypeMark, TreeNodeCollection`1<IRankSpecifier> rankSpecifiers, TreeNodeCollection`1<IUnsafeCodePointer> unsafeCodePointers);
    [CanBeNullAttribute]
private static ITypeComparisonContext CreateFromUserTypeUsage(IUserTypeUsage userTypeUsage, Pair`2<ITreeNode, ITreeNode> matchingRange, IType actualType, IType expectedType, IExpression actualTypeSource, INullableTypeMark nullableTypeMark, TreeNodeCollection`1<IRankSpecifier> rankSpecifiers, TreeNodeCollection`1<IUnsafeCodePointer> unsafeCodePointers);
    [CanBeNullAttribute]
private static ITypeComparisonContext CreateFromPredefinedTypeUsage(IPredefinedTypeUsage predefinedTypeUsage, Pair`2<ITreeNode, ITreeNode> matchingRange, IType actualType, IType expectedType, IExpression actualTypeSource, INullableTypeMark nullableTypeMark, TreeNodeCollection`1<IRankSpecifier> rankSpecifiers, TreeNodeCollection`1<IUnsafeCodePointer> unsafeCodePointers);
    [NotNullAttribute]
internal static ITypeComparisonContext CreateTypeComparisonContext(ITreeNode typeUsageNode, Pair`2<ITreeNode, ITreeNode> mathcingRange, IExpression actualTypeSource, IType actualUnderlyingType, IType actualType, IType expectedType, Pair`2<ITreeNode, ITreeNode> typeElementRange, ITypeArgumentList typeArgumentList, INullableTypeMark nullableMark, TreeNodeCollection`1<IRankSpecifier> rankSpecifiers, TreeNodeCollection`1<IUnsafeCodePointer> unsafeCodePointers);
    [NotNullAttribute]
internal static ITypeComparisonContext CreateTypeComparisonContext(Pair`2<ITreeNode, ITreeNode> typeUsageNode, IExpression actualTypeSource, IType actualUnderlyingType, IType actualType, IType expectedType, Pair`2<ITreeNode, ITreeNode> typeElementRange, ITypeArgumentList typeArgumentList, INullableTypeMark nullableMark, Int32[] arrayDimensions, TreeNodeCollection`1<IUnsafeCodePointer> unsafeCodePointers);
    [NotNullAttribute]
internal static ITypeComparisonContext CreateTypeComparisonContext(Pair`2<ITreeNode, ITreeNode> typeUsageNode, IExpression actualTypeSource, IType actualUnderlyingType, IType actualType, IType expectedType, Pair`2<ITreeNode, ITreeNode> typeElementRange, ITypeArgumentList typeArgumentList, INullableTypeMark nullableMark, TreeNodeCollection`1<IUnsafeCodePointer> unsafeCodePointers);
}
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TypeComparisonResultBase : object {
    [CompilerGeneratedAttribute]
private Pair`2<ITreeNode, ITreeNode> <MismatchingRange>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasShortDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <SuggestedType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <SuggestedExpectedType>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <ActualTypeSource>k__BackingField;
    protected Pair`2<ITreeNode, ITreeNode> MismatchingRange { get; }
    public bool HasShortDescription { get; public set; }
    [NotNullAttribute]
public IType SuggestedType { get; public set; }
    [NotNullAttribute]
public IType SuggestedExpectedType { get; public set; }
    [CanBeNullAttribute]
public IExpression ActualTypeSource { get; public set; }
    protected TypeComparisonResultBase(ITreeNode mismatchingNode, IType suggestedType, IType suggestedExpectedType, IExpression actualTypeSource);
    protected TypeComparisonResultBase(ITreeNode firstMismatchingNode, ITreeNode lastMismatchingNode, IType suggestedType, IType suggestedExpectedType, IExpression actualTypeSource);
    protected TypeComparisonResultBase(Pair`2<ITreeNode, ITreeNode> mismatchingRange, IType suggestedType, IType suggestedExpectedType, IExpression actualTypeSource);
    [CompilerGeneratedAttribute]
protected Pair`2<ITreeNode, ITreeNode> get_MismatchingRange();
    [CompilerGeneratedAttribute]
public bool get_HasShortDescription();
    [CompilerGeneratedAttribute]
public void set_HasShortDescription(bool value);
    [CompilerGeneratedAttribute]
public IType get_SuggestedType();
    [CompilerGeneratedAttribute]
public void set_SuggestedType(IType value);
    [CompilerGeneratedAttribute]
public IType get_SuggestedExpectedType();
    [CompilerGeneratedAttribute]
public void set_SuggestedExpectedType(IType value);
    [CompilerGeneratedAttribute]
public IExpression get_ActualTypeSource();
    [CompilerGeneratedAttribute]
public void set_ActualTypeSource(IExpression value);
    [NotNullAttribute]
public abstract virtual RichText GetDescription();
    public virtual DocumentRange GetMismatchingRange();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TypeComparisonResultExtensions : object {
    [ExtensionAttribute]
public static DocumentRange GetMismatchingRange(TypeComparisonResultBase comparisonResult, DocumentRange defaultRange);
    [ExtensionAttribute]
[NotNullAttribute]
public static RichText GetErrorMessage(TypeComparisonResultBase comparisonResult, RichText originalMessage);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("fallbackType:notnull => notnull")]
public static IType TryGetTypeSuggestion(TypeComparisonResultBase comparisonResult, IType fallbackType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("fallbackType:notnull => notnull")]
public static IType TryGetExpectedTypeSuggestion(TypeComparisonResultBase comparisonResult, IType fallbackType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("comparisonResult:null => null")]
public static IType TryGetSmartTypeSuggestion(TypeComparisonResultBase comparisonResult, IType defaultSuggestion);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("comparisonResult:null => null")]
public static IType TryGetSmartExpectedTypeSuggestion(TypeComparisonResultBase comparisonResult, IType defaultSuggestion);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("defaultExpression:notnull => notnull")]
public static IExpression TryGetMismatchedExpression(TypeComparisonResultBase comparisonResult, IExpression defaultExpression);
    private static bool CanSuggestType(IType value);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TypeComparisonUtil : object {
    [PureAttribute]
public static bool ShouldCompareTypes(ITreeNode typeUsageNode, IType expectedType);
    [CanBeNullAttribute]
public static TypeComparisonResultBase MatchImplicitConversion(ITreeNode typeUsageNode, IType expectedType, Conversion conversion);
    [CanBeNullAttribute]
public static TypeComparisonResultBase MatchIdentityConversionWithTupleNames(ITreeNode typeUsageNode, IType expectedType);
    [CanBeNullAttribute]
public static TypeComparisonResultBase MatchNullability(ITypeUsage typeUsage, IType expectedType);
    internal static bool MatchTypeElementExact(ITypeElement actualTypeElement, ITypeElement expectedTypeElement);
    internal static bool IsImplicitConversionMatch(IType actualType, IType expectedType, ICSharpTypeConversionRule typeConversionRule, Nullable`1<TypeParameterVariance> variance);
    private static bool IsVariantConvertible(IType actualType, IType expectedType, ICSharpTypeConversionRule typeConversionRule, TypeParameterVariance variance);
    [CanBeNullAttribute]
internal static TypeComparisonResultBase MatchTypeArgumentsImplicitConversion(IType actualType, IType expectedType, IExpression actualTypeSource, Pair`2<ITreeNode, ITreeNode> possibleMismatchRange, ITypeElement actualTypeElement, ITypeElement expectedTypeElement, IList`1<ITypeUsage> typeArguments, Nullable`1<TypeParameterVariance> variance, ITypeComparisonContext typeComparisonContext, ICSharpTypeConversionRule typeConversionRule, TypeComparisonResultBase& candidate);
    [CanBeNullAttribute]
internal static TypeComparisonResultBase MatchTypeElementImplicitConversion(IType expectedType, IExpression actualTypeSource, Pair`2<ITreeNode, ITreeNode> typeElementRange, ITypeElement actualTypeElement, ITypeElement expectedTypeElement, IList`1<ITypeUsage> typeArguments, Nullable`1<TypeParameterVariance> variance, ICSharpTypeConversionRule typeConversionRule);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TypeElementMismatchResult : TypeComparisonResultBase {
    [CompilerGeneratedAttribute]
private ITypeElement <ActualTypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <ExpectedTypeElement>k__BackingField;
    [NotNullAttribute]
public ITypeElement ActualTypeElement { get; }
    [NotNullAttribute]
public ITypeElement ExpectedTypeElement { get; }
    public TypeElementMismatchResult(Pair`2<ITreeNode, ITreeNode> mismatchingRange, ITypeElement actualTypeElement, ITypeElement expectedTypeElement, IType suggestedType, IType suggestedExpectedType, IExpression actualTypeSource);
    [CompilerGeneratedAttribute]
public ITypeElement get_ActualTypeElement();
    [CompilerGeneratedAttribute]
public ITypeElement get_ExpectedTypeElement();
    public virtual RichText GetDescription();
    [NotNullAttribute]
[StringFormatMethodAttribute("format")]
private static RichText FormatTypeElementNames(string format, ITypeElement actualElement, ITypeElement expectedElement);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.TypeUsage.TypeMismatchResult : TypeComparisonResultBase {
    [CompilerGeneratedAttribute]
private IType <ActualType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExpectedType>k__BackingField;
    [NotNullAttribute]
public IType ActualType { get; }
    [NotNullAttribute]
public IType ExpectedType { get; }
    private TypeMismatchResult(Pair`2<ITreeNode, ITreeNode> mismatchingNodeRange, IType actualType, IType expectedType, IExpression actualTypeSource);
    private TypeMismatchResult(ITreeNode mismatchingNode, IType actualType, IType expectedType, IExpression actualTypeSource);
    public TypeMismatchResult(ITypeComparisonContext context);
    public TypeMismatchResult(ITypeComparisonContext context, Pair`2<ITreeNode, ITreeNode> mismatchingNodeRange);
    public TypeMismatchResult(ITypeComparisonContext context, ITreeNode mismatchingNode);
    public TypeMismatchResult(Pair`2<ITreeNode, ITreeNode> mismatchingRange, IType actualType, IType expectedType, IType suggestedType, IType suggestedExpectedType, IExpression actualTypeSource);
    [CompilerGeneratedAttribute]
public IType get_ActualType();
    [CompilerGeneratedAttribute]
public IType get_ExpectedType();
    public virtual RichText GetDescription();
    [NotNullAttribute]
private static RichText GetPresentableName(IType type, PsiLanguageType language);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.CSharp.Util.UniversalWindowsPlatformApiInformationUtil : object {
    private static Dictionary`2<string, DeclaredElementType> ourSecondParameterType;
    private static UniversalWindowsPlatformApiInformationUtil();
    [PureAttribute]
public static bool IsApiInformationInvocationArgument(ICSharpArgument argument, bool allowResolve);
    public static bool TryGetExpectedReferenceType(ICSharpArgument argument, DeclaredElementType& declaredElementType);
    private static bool IsFirstArgumentStringLiteral(IInvocationExpression invocationExpression);
    public static ReferenceCollection CreateReferenceForTypeMemberParameter(ICSharpLiteralExpression literal, DeclaredElementType expectedDeclaredElementType, ReferenceCollection oldReferences);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.UnsafeCodeUtil : object {
    private static Key`1<ConcurrentDictionary`2<ITreeNode, Dictionary`2<ICSharpDeclaration, bool>>> ClosuresKey;
    private static UnsafeCodeUtil();
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnsafeContext(ICSharpTreeNode element);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false; => true, unsafeContextDeclarator: notnull")]
public static bool IsUnsafeContext(ICSharpTreeNode element, ITreeNode& unsafeContextDeclarator);
    [PureAttribute]
public static bool ContainsUnsafeCode(ITreeNode node);
    [PureAttribute]
public static bool IsFixedPointerInitializer(ICSharpExpression expression);
    [PureAttribute]
public static bool IsExpressionClassifiedAsMoveable(ICSharpExpression expression, IUserDataHolder cache);
    private static bool IsVariableCapturedInClosure(IDeclaredElement declaredElement, IReferenceExpression referenceExpression, IUserDataHolder cache);
    [CompilerGeneratedAttribute]
internal static bool <IsUnsafeContext>g__IsIteratorBody|1_0(ITreeNode node);
    [CompilerGeneratedAttribute]
internal static bool <IsVariableCapturedInClosure>g__IsCapturedVariable|6_0(ITreeNode scopeNode, ICSharpDeclaration variableDeclaration, IDeclaredElement variable, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsVariableCapturedInClosure>g__CalcIsCapturedVariable|6_1(ITreeNode scopeNode, IDeclaredElement variable);
    [CompilerGeneratedAttribute]
internal static bool <IsVariableCapturedInClosure>g__IsInsideClosure|6_4(ITreeNode usage, ITreeNode scopeNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.UsingAliasUtil : object {
    [ExtensionAttribute]
public static bool IsAccessableFrom(ISymbolAlias symbolAlias, ITreeNode context);
    public static IReadOnlyList`1<ITreeNode> FindTypeAliasUsageOpportunities(ISymbolAlias symbolAlias, ITreeNode scope);
    public static bool ShouldBeCheckedForTypeAliasOpportunity(IReferenceName referenceName);
    public static bool ShouldBeCheckedForTypeAliasOpportunity(IReferenceExpression referenceExpression);
    public static Predicate`1<IPsiSourceFile> GetAliasedSymbolPresencePredicate(ISymbolAlias symbolAlias);
    public static IReadOnlyList`1<ITreeNode> ReplaceWithAliasUsage(IReadOnlyList`1<ITreeNode> nodesToReplace, ISymbolAlias symbolAlias, bool collectReplacedNodes);
    public static ITreeNode ReplaceWithAliasUsage(ITreeNode nodeToReplace, ISymbolAlias symbolAlias);
    public static IReadOnlyList`1<ValueTuple`2<string, string>> CollectAliasesInFile(ICSharpFile file);
    public static bool CheckResolvedToAliasIfReplaced(ITreeNode node, ISymbolAlias symbolAlias);
    public static bool CheckResolvedToAliasIfReplaced(ITypeUsage typeUsage, ISymbolAlias symbolAlias);
    public static bool CheckResolvedToAliasIfReplaced(IReferenceName referenceName, ISymbolAlias symbolAlias);
    public static bool CheckResolvedToAliasIfReplaced(IReferenceExpression expression, ISymbolAlias symbolAlias);
    public static bool CheckResolvedToAliasIfReplaced(IPredefinedTypeExpression expression, ISymbolAlias symbolAlias);
    [CompilerGeneratedAttribute]
internal static void <CollectAliasesInFile>g__CollectLocalAliases|9_0(ICSharpTypeAndNamespaceHolderDeclaration holder, LocalList`1& result);
}
public class JetBrains.ReSharper.Psi.CSharp.Util.UsingRegionsInspector : object {
    [NotNullAttribute]
private IUsingList myImportsList;
    [CanBeNullAttribute]
private ITreeNode myUsageContext;
    [NotNullAttribute]
private IRegionStructure myRegionStructure;
    [CanBeNullAttribute]
private PreprocessorCondition myUsageContextPreprocessorCondition;
    [NotNullAttribute]
private PreprocessorConditionParser myPreprocessorConditionParser;
    [NotNullAttribute]
[ItemNotNullAttribute]
private JetHashSet`1<ICodeRegion> myImportsListParentRegions;
    public UsingRegionsInspector(ICSharpTypeAndNamespaceHolderDeclaration scope, ITreeNode usageContext);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static JetHashSet`1<ICodeRegion> GetImportsListParentRegions(IRegionStructure regionStructure, IUsingList importsList);
    [NotNullAttribute]
private TreeRange GetImportsListTreeRange();
    public sealed virtual Nullable`1<bool> IsContainingPreprocessorRegionRecommended(ITreeNode treeNode);
    private Nullable`1<bool> IsEnclosingPreprocessorRegionRecommended(ITreeNode treeNode, CodeRegionPosition codeRegionPosition);
    private bool IsEnclosingReSharperConstructRegionRecommended(ITreeNode treeNode, CodeRegionPosition codeRegionPosition);
    public sealed virtual ITreeRange FindUsingListStartBorder();
    public sealed virtual ITreeRange FindUsingListEndBorder();
    public sealed virtual ICodeRegion FindStartAnchorRegion(ITreeNode anchorImport);
    public sealed virtual ICodeRegion FindEndAnchorRegion(ITreeNode anchorImport);
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__HasPreprocessorDirectivesAround|6_0(ITreeNode node);
    [CompilerGeneratedAttribute]
private bool <IsContainingPreprocessorRegionRecommended>b__9_1(ICodeRegion x);
    [CompilerGeneratedAttribute]
private bool <IsEnclosingPreprocessorRegionRecommended>b__10_0(ICodeRegion x);
    [CompilerGeneratedAttribute]
private bool <FindUsingListStartBorder>b__12_1(ITreeNode x);
    [CompilerGeneratedAttribute]
private bool <FindUsingListEndBorder>b__13_1(ITreeNode x);
}
public static class JetBrains.ReSharper.Psi.CSharp.Util.ValidityChecker : object {
    private static ICSharpParser CreateParser(string text);
    private static ITypeUsage DeclaredTypeUsage(string declaredTypeUsage);
    private static ITypeUsage TypeUsage(string typeUsage);
    private static ICSharpExpression Expression(string expr);
    public static bool IsValidIdentifier(string identifier);
    public static bool IsValidName(string identifier);
    public static bool IsValidNamespaceOrTypeName(string qualifiedName);
    public static bool IsValidType(string typeUsage);
    public static bool IsValidExpression(string expression);
    public static bool IsTypeElementName(string qualifiedTypeName);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CSharp.Util.ValueAccessClassification : ValueType {
    [CompilerGeneratedAttribute]
private ValueAccessKind <AccessKind>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueAccessProperties <Properties>k__BackingField;
    public ValueAccessKind AccessKind { get; }
    public ValueAccessProperties Properties { get; }
    public bool IsPureInvocation { get; }
    public bool ExecutesUserCode { get; }
    public bool IsProbablyMutating { get; }
    public ValueAccessClassification(ValueAccessKind accessKind, ValueAccessProperties accessProperties);
    [CompilerGeneratedAttribute]
public ValueAccessKind get_AccessKind();
    [CompilerGeneratedAttribute]
public ValueAccessProperties get_Properties();
    public bool get_IsPureInvocation();
    public bool get_ExecutesUserCode();
    public bool get_IsProbablyMutating();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.CSharp.Util.ValueAccessKind : Enum {
    public int value__;
    public static ValueAccessKind ReadWholeValue;
    public static ValueAccessKind ReadWholeValueAndCaptureElementName;
    public static ValueAccessKind ReadWholeValueForTemporaryToCaptureReadonlyReferenceToRead;
    public static ValueAccessKind ReadWholeValueForTemporaryToInvokePossiblyMutableInstanceMember;
    public static ValueAccessKind ReadWholeValueForShallowCopyToInvokePossiblyMutableInstanceMember;
    public static ValueAccessKind WriteWholeValue;
    public static ValueAccessKind ReadAndWriteWholeValue;
    public static ValueAccessKind ReferenceReassignment;
    public static ValueAccessKind CaptureElementName;
    public static ValueAccessKind CaptureInnerElementName;
    public static ValueAccessKind CaptureReadonlyReferenceToRead;
    public static ValueAccessKind CaptureMutableReferenceToRead;
    public static ValueAccessKind CaptureMutableReferenceToWrite;
    public static ValueAccessKind CaptureMutableReferenceToReadAndWrite;
    public static ValueAccessKind ExplicitCaptureOfReadonlyReference;
    public static ValueAccessKind ExplicitCaptureOfMutableReference;
    public static ValueAccessKind PointerCaptureForRandomAccess;
    public static ValueAccessKind CaptureMutableReferenceToInvokePossiblyMutatingMethod;
    public static ValueAccessKind UnresolvedReferenceToSomething;
    public static ValueAccessKind NotValueAccess;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.ValueAccessKindUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static ValueAccessClassification ClassifyValueAccess(ICSharpExpression accessedExpression, IResolveContext optionalResolveContext);
    [PureAttribute]
private static IReference TryGetImplicitInvocationReference(ICSharpExpression expression);
    [PureAttribute]
private static ValueAccessKind ClassifyInnerFieldAccess(ICSharpExpression innerFieldAccess, ExpressionClassification qualifierClassification, IResolveContext resolveContext, ValueAccessProperties& properties);
    [PureAttribute]
private static ValueAccessKind ClassifyStructPropertyAccess(IProperty property, WriteKind writeKind, QualifierTypeKind receiverType, ICSharpExpression qualifierExpression, ExpressionClassification qualifierClassification, ICSharpTreeNode context, IResolveContext resolveContext);
    [PureAttribute]
private static ValueAccessKind ClassifyStructEventAccess(IEvent event, WriteKind writeKind, QualifierTypeKind receiverType, ICSharpExpression qualifierExpression, ExpressionClassification qualifierClassification, IResolveContext resolveContext);
    [PureAttribute]
private static ValueAccessKind ClassifyStructMethodInvocation(IReferenceExpression methodGroupReference, ICSharpExpression qualifierExpression, ExpressionClassification qualifierClassification, IResolveContext resolveContext, ValueAccessProperties& properties);
    [PureAttribute]
private static ValueAccessKind ClassifyStructMethodInvocation(IReference invocationReference, ICSharpExpression qualifierExpression, ExpressionClassification qualifierClassification, IResolveContext resolveContext, ValueAccessProperties& properties);
    [PureAttribute]
private static bool CheckMemberRequiresToCopyTheReadonlyValueToPreventPossibleModification(ITypeMember typeMember, ICSharpExpression qualifierExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static ValueAccessKind ClassifyStructThisAccess(ICSharpExpression expression, IResolveContext resolveContext);
    [PureAttribute]
private static QualifierTypeKind ClassifyType(ICSharpExpression expression, IResolveContext resolveContext);
    [PureAttribute]
internal static WriteKind ClassifyWriteBySyntax(ICSharpExpression expression, IProperty property);
    [CompilerGeneratedAttribute]
internal static ValueAccessKind <ClassifyValueAccess>g__ClassifyPossiblyStructPropertyAccess|0_0(IConditionalAccessExpression accessorAccessExpression, IProperty property, <>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static ValueAccessKind <ClassifyValueAccess>g__ClassifyReferenceAccess|0_1(IReferenceExpression reference, QualifierTypeKind qualifierType, <>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static ValueAccessKind <ClassifyValueAccess>g__ClassifyIndexerAccess|0_2(IElementAccessExpression elementAccess, <>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static ValueAccessKind <ClassifyValueAccess>g__ClassifyArgumentPass|0_3(ICSharpArgument arg, <>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static bool <ClassifyValueAccess>g__IsUnsafeAsRefArgument|0_7(<>c__DisplayClass0_0& , <>c__DisplayClass0_1& );
    [CompilerGeneratedAttribute]
internal static ValueAccessKind <ClassifyValueAccess>g__ClassifyOperatorReadOperand|0_4(IOperatorExpression operatorExpression, int operandIndex, <>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static bool <ClassifyValueAccess>g__IsUnderImplicitNameCapture|0_5(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static bool <ClassifyValueAccess>g__IsUnderReferenceReassignment|0_6(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static bool <ClassifyStructMethodInvocation>g__IsPureMethodInvocation|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static bool <CheckMemberRequiresToCopyTheReadonlyValueToPreventPossibleModification>g__IsNotAssignableButMutableVariableQualifier|7_0(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static ValueAccessKind <ClassifyStructThisAccess>g__ClassifyStructInstanceMemberAccess|8_0(ITypeMember typeMember, IReferenceExpression referenceExpression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static ValueAccessKind <ClassifyStructThisAccess>g__ClassifyStructPrimaryParameterAccess|8_1(IReferenceExpression referenceExpression, <>c__DisplayClass8_0& );
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CSharp.Util.ValueAccessProperties : Enum {
    public ushort value__;
    public static ValueAccessProperties None;
    public static ValueAccessProperties ExecutesUserCode;
    public static ValueAccessProperties ExecutedCodeIsPure;
    public static ValueAccessProperties QualifierOfUnconstrainedGenericType;
    public static ValueAccessProperties ExplicitCaptureOfMutableReferenceForOutArgument;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CSharp.Util.WhitespaceAndCommentsAround : object {
    public bool IsEmpty { get; }
    public static WhitespaceAndCommentsAround Empty { get; }
    public abstract virtual bool get_IsEmpty();
    public static WhitespaceAndCommentsAround get_Empty();
    [PureAttribute]
public abstract virtual WhitespaceAndCommentsAround AndAfter(ITreeNode source);
    [PureAttribute]
public abstract virtual WhitespaceAndCommentsAround AndBefore(ITreeNode source);
    [PureAttribute]
public abstract virtual WhitespaceAndCommentsAround TrimMultipleNewlines();
    [PureAttribute]
public abstract virtual WhitespaceAndCommentsAround AddNewlineAfterIfThereIsNone();
    public abstract virtual void TransferTo(ITreeNode destination);
    protected abstract virtual bool HasLineBreaks(bool before, Trivia& lineBreak);
    [PureAttribute]
public WhitespaceAndCommentsAround UnifyToNewLinesOnly(WhitespaceAndCommentsAround other);
    [PureAttribute]
public static WhitespaceAndCommentsAround From(ITreeNode source);
    [PureAttribute]
public static WhitespaceAndCommentsAround Before(ITreeNode source);
    [PureAttribute]
public static WhitespaceAndCommentsAround After(ITreeNode source);
    private static IReadOnlyList`1<Trivia> CollectPrevTrivia(ITreeNode source);
    private static IReadOnlyList`1<Trivia> CollectNextTrivia(ITreeNode source);
    private static bool IsTriviaNode(ITreeNode node);
    private static void TrimTailWhitespace(List`1<ITreeNode> nodes);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CSharp.Util.XmlDocTemplateUtil : object {
    [ExtensionAttribute]
private static void AppendLine(StringBuilder that, string text, int ln, Func`2<int, string> linePrefix, string lineSeparator);
    [NotNullAttribute]
public static string GetDocTemplate(IDocCommentBlockOwner owner, Int32& cursor);
    [NotNullAttribute]
public static string GetDocTemplate(IDocCommentBlockOwner owner, Int32& cursor, Func`2<int, string> linePrefix, string lineSeparator);
    [NotNullAttribute]
private static string EscapeExceptionPresentableName(string presentableName);
    [NotNullAttribute]
private static HashSet`1<IType> CollectExceptionsFromBodies(ITreeNode node);
    private static void CollectExceptions(ITreeNode node, HashSet`1<IType> exceptions);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDocCommentBlockOwner FindDocCommentOwner(ITypeMemberDeclaration declaration);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Psi.CSharp.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.Diagnostics.CodeAnalysis.<InterceptorInfo>F81DF6E5BED43A6C1253D87435556B83FD738D816CBA4D40A15AAE1F73F4F76D8__NotNullAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
