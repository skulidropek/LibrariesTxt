[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.ArgumentInfoExtension : object {
    [ExtensionAttribute]
public static IType GetImplicitlyConvertedTo(IVBArgumentInfo vbArgumentInfo);
    [ExtensionAttribute]
public static bool IsClassifiedAsVariable(IVBArgumentInfo vbArgumentInfo);
}
public enum JetBrains.ReSharper.Psi.VB.ArgumentKind : Enum {
    public int value__;
    public static ArgumentKind Positional;
    public static ArgumentKind Empty;
    public static ArgumentKind Named;
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Caches.VBAnnotatedMembersCacheProcessor : TreeNodeVisitor`1<Pair`2<ICollection`1<string>, AnnotatedEntitiesSet>> {
    public sealed virtual void Process(IFile file, HashSet`1<string> attributeNames, AnnotatedEntitiesSet context);
}
public interface JetBrains.ReSharper.Psi.VB.CodeStyle.ICustomIndentHandler {
    public abstract virtual string Indent(ITreeNode node, CustomIndentType indentType, FmtSettingsClassic`1<VBFormatSettingsKey> settings);
}
public interface JetBrains.ReSharper.Psi.VB.CodeStyle.IVBCodeFormatter {
    public abstract virtual void FormatDocComment(IDocCommentBlock docCommentBlock);
}
[CodeStyleSettingsAttribute("VB")]
public class JetBrains.ReSharper.Psi.VB.CodeStyle.SettingsUpgrade.VBCodeStyleSettings : object {
    private CodeStyleSettingsObsolete myOwner;
    private VBFormatSettingsObsolete myFormatSettings;
    private VBImportsSettingsObsolete myImportsSettings;
    public VBFormatSettingsObsolete FormatSettings { get; public set; }
    public VBImportsSettingsObsolete ImportsSettings { get; public set; }
    public VBCodeStyleSettings(CodeStyleSettingsObsolete owner);
    public VBFormatSettingsObsolete get_FormatSettings();
    public void set_FormatSettings(VBFormatSettingsObsolete value);
    public VBImportsSettingsObsolete get_ImportsSettings();
    public void set_ImportsSettings(VBImportsSettingsObsolete value);
    public sealed virtual void ReadFromXml(XmlElement element);
    public sealed virtual object Clone();
}
public class JetBrains.ReSharper.Psi.VB.CodeStyle.SettingsUpgrade.VBFormatSettingsObsolete : object {
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_INVOCATION_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_EMPTY_INVOCATION_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_METHOD_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_EMPTY_METHOD_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_INVOCATION_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_EMPTY_INVOCATION_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_METHOD_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_EMPTY_METHOD_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_TYPE_PARAMETER_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_TYPE_PARAMETER_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_EXPRESSION_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_COMMA;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_COMMA;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_ATTRIBUTE_ANGLES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_ATTRIBUTE_TARGET_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AFTER_ATTRIBUTE_TARGET_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_ARRAY_RANK_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_ARRAY_RANK_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_ARRAY_RANK_EMPTY_PARENTHESES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_WITHIN_ARRAY_INITIALIZATION_BRACES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_ASSIGNMENT_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_RELATIONAL_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_ADDITIVE_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_MULTIPLICATIVE_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_SHIFT_OP;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_DOT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_BEFORE_LABEL_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool SPACE_AROUND_STMT_COLON;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int KEEP_BLANK_LINES_IN_DECLARATIONS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int KEEP_BLANK_LINES_IN_CODE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool KEEP_USER_LINEBREAKS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AFTER_OPTIONS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AFTER_IMPORTS;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_GLOBAL_ATTRIBUTE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_NAMESPACE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_TYPE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_FIELD;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_INVOCABLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_SINGLE_LINE_INVOCABLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_SINGLE_LINE_FIELD;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_AROUND_REGION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int BLANK_LINES_INSIDE_REGION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_LINES;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public int WRAP_LIMIT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_INVOCATION_LPAR;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_DECLARATION_LPAR;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool WRAP_BEFORE_BINARY_OPSIGN;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_PARAMETERS_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_ARGUMENTS_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_EXTENDS_LIST_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public WrapStyle WRAP_MULTIPLE_DECLARATION_STYLE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_PARAMETER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_ARGUMENT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_IMPLEMENTS_LIST;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_EXPRESSION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTILINE_ARRAY_INITIALIZER;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool ALIGN_MULTIPLE_DECLARATION;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_TYPE_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_METHOD_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_PROPERTY_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_EVENT_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PLACE_FIELD_ATTRIBUTE_ON_SAME_LINE;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool INDENT_CASE_FROM_SELECT;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool STICK_COMMENT;
    public sealed virtual void ReadFromXml(XmlElement element);
    public VBFormatSettingsObsolete Clone();
}
[SolutionSettingsUpgraderAttribute("0")]
[GlobalSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.CodeStyle.SettingsUpgrade.VBFormatSettingsUpgrade : CodeStyleSettingsUpgrade {
    public VBFormatSettingsUpgrade(ShellPartCatalogSet partsSet, ISolution solution);
    protected virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore contextBoundSettingsStore);
}
[SolutionSettingsUpgraderAttribute("0")]
[GlobalSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.CodeStyle.SettingsUpgrade.VBImportSettingsUpgrade : CodeStyleSettingsUpgrade {
    public VBImportSettingsUpgrade(ShellPartCatalogSet partsSet, ISolution solution);
    protected virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore boundSettingsStore);
}
public class JetBrains.ReSharper.Psi.VB.CodeStyle.SettingsUpgrade.VBImportsSettingsObsolete : object {
    private bool myAllowAlias;
    private bool myPreferQualifiedReference;
    private bool myKeepNontrivialAlias;
    private String[] myKeepImports;
    private String[] myMandatoryImports;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool AllowAlias { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool PreferQualifiedReference { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public String[] KeepImports { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public String[] MandatoryImports { get; public set; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public bool KeepNontrivialAlias { get; public set; }
    public bool get_AllowAlias();
    public void set_AllowAlias(bool value);
    public bool get_PreferQualifiedReference();
    public void set_PreferQualifiedReference(bool value);
    public String[] get_KeepImports();
    public void set_KeepImports(String[] value);
    public String[] get_MandatoryImports();
    public void set_MandatoryImports(String[] value);
    public bool get_KeepNontrivialAlias();
    public void set_KeepNontrivialAlias(bool value);
    public sealed virtual void ReadFromXml(XmlElement element);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.VB.CodeStyle.SettingsUpgrade.VBSpaceAfterUnaryMigration : object {
    private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.CodeStyle.SettingsUpgrade.VBSpaceAfterUnaryMigration/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetKeysToMigrate>d__1")]
private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.CodeStyle.VBCodeCleanupUtil : object {
    [ExtensionAttribute]
public static void OptimizeImports(IVBFile file, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static void ShortenQualifiedReferences(IVBFile file, IRangeMarker rangeMarker, IProgressIndicator progressIndicator);
    public static void Optimize(IVBFile file, IRangeMarker rangeMarker, bool optimizeImports, bool shortenQualifiedReferences, IProgressIndicator progressIndicator);
}
public class JetBrains.ReSharper.Psi.VB.CodeStyle.VBFormatProfile : object {
    private ProfileOptions myMask;
    public bool Format { get; }
    public bool DecorateModifiers { get; }
    public bool DontKeepLinebreaks { get; }
    public bool DontWrap { get; }
    public VBFormatProfile(ProfileOptions mask);
    public bool get_Format();
    public bool get_DecorateModifiers();
    public bool get_DontKeepLinebreaks();
    public bool get_DontWrap();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.CodeStyle.CodeFormattingSettingsKey", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "CodeFormattingInVBNETSettingDescription")]
[EditorConfigKeyAttribute("vb")]
public class JetBrains.ReSharper.Psi.VB.CodeStyle.VBFormatSettingsKey : FormatSettingsKeyBase {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeInvocationParenthesesSettingDescription")]
public bool SPACE_BEFORE_INVOCATION_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeEmptyInvocationParenthesesSettingDescription")]
public bool SPACE_BEFORE_EMPTY_INVOCATION_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeMethodDeclarationParenthesesSettingDescription")]
public bool SPACE_BEFORE_METHOD_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeEmptyMethodDeclarationParenthesesSettingDescription")]
public bool SPACE_BEFORE_EMPTY_METHOD_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinInvocationParenthesesSettingDescription")]
public bool SPACE_WITHIN_INVOCATION_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinEmptyInvocationParenthesesSettingDescription")]
public bool SPACE_WITHIN_EMPTY_INVOCATION_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinMethodDeclarationParenthesesSettingDescription")]
public bool SPACE_WITHIN_METHOD_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinEmptyMethodDeclarationParenthesesSettingDescription")]
public bool SPACE_WITHIN_EMPTY_METHOD_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinTupleParenthesesSettingDescription")]
public bool SPACE_WITHIN_TUPLE_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeTypeParameterParenthesesSettingDescription")]
public bool SPACE_BEFORE_TYPE_PARAMETER_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinTypeParameterParenthesesSettingDescription")]
public bool SPACE_WITHIN_TYPE_PARAMETER_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinExpressionParenthesesSettingDescription")]
public bool SPACE_WITHIN_EXPRESSION_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeSettingDescription")]
public bool SPACE_BEFORE_COMMA;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AfterSettingDescription")]
public bool SPACE_AFTER_COMMA;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinAttributeAnglesSettingDescription")]
public bool SPACE_WITHIN_ATTRIBUTE_ANGLES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeAttributeTargetColonSettingDescription")]
public bool SPACE_BEFORE_ATTRIBUTE_TARGET_COLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AfterAttributeTargetColonSettingDescription")]
public bool SPACE_AFTER_ATTRIBUTE_TARGET_COLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeArrayRankParenthesesSettingDescription")]
public bool SPACE_BEFORE_ARRAY_RANK_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinArrayRankParenthesesSettingDescription")]
public bool SPACE_WITHIN_ARRAY_RANK_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinEmptyArrayRankParenthesesSettingDescription")]
public bool SPACE_WITHIN_ARRAY_RANK_EMPTY_PARENTHESES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WithinArrayInitializationBracesSettingDescription")]
public bool SPACE_WITHIN_ARRAY_INITIALIZATION_BRACES;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AssignmentOperatorsSettingDescription")]
public bool SPACE_AROUND_ASSIGNMENT_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "RelationalOperatorsSettingDescription")]
public bool SPACE_AROUND_RELATIONAL_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AdditiveOperatorsSettingDescription")]
public bool SPACE_AROUND_ADDITIVE_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "MultiplicativeOperatorsSettingDescription")]
public bool SPACE_AROUND_MULTIPLICATIVE_OP;
    [EditorConfigEntryAliasAttribute("space_around_binary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "ShiftOperatorsSettingDescription")]
public bool SPACE_AROUND_SHIFT_OP;
    [EditorConfigEntryAliasAttribute("space_after_unary_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AfterUnaryOperatorsSettingDescription")]
public bool SPACE_AFTER_UNARY_OP;
    [EditorConfigEntryAliasAttribute("space_around_member_access_operator", "2")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundSettingDescription")]
public bool SPACE_AROUND_DOT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "BeforeInLabelSettingDescription")]
public bool SPACE_BEFORE_LABEL_COLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundStatementSettingDescription")]
public bool SPACE_AROUND_STMT_COLON;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "KeepMaxBlankLinesInDeclarationsSettingDescription")]
public int KEEP_BLANK_LINES_IN_DECLARATIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "KeepMaxBlankLinesInCodeSettingDescription")]
public int KEEP_BLANK_LINES_IN_CODE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "KeepExistingLineBreaksSettingDescription")]
public bool KEEP_USER_LINEBREAKS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AfterFileOptionsSectionSettingDescription")]
public int BLANK_LINES_AFTER_OPTIONS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AfterImportsSectionSettingDescription")]
public int BLANK_LINES_AFTER_IMPORTS;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AfterGlobalAttributeSettingDescription")]
public int BLANK_LINES_AROUND_GLOBAL_ATTRIBUTE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundNamespaceSettingDescription")]
public int BLANK_LINES_AROUND_NAMESPACE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundTypeSettingDescription")]
public int BLANK_LINES_AROUND_TYPE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundMultilineFieldSettingDescription")]
public int BLANK_LINES_AROUND_FIELD;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundMultilineMethodSettingDescription")]
public int BLANK_LINES_AROUND_INVOCABLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundSingleLineMethodSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_INVOCABLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundSingleLineFieldSettingDescription")]
public int BLANK_LINES_AROUND_SINGLE_LINE_FIELD;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AroundRegionSettingDescription")]
public int BLANK_LINES_AROUND_REGION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "InsideRegionSettingDescription")]
public int BLANK_LINES_INSIDE_REGION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "VBFormatSettingsKey_WrapBeforeInvocationLpar_SettingsDescription")]
public bool WRAP_BEFORE_INVOCATION_LPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "VBFormatSettingsKey_WrapBeforeDeclarationLpar_SettingsDescription")]
public bool WRAP_BEFORE_DECLARATION_LPAR;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "PreferWrapBeforeOperatorInBinaryExpressionSettingDescription")]
public bool WRAP_BEFORE_BINARY_OPSIGN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WrapFormalParametersSettingDescription")]
public WrapStyle WRAP_PARAMETERS_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WrapInvocationArgumentsSettingDescription")]
public WrapStyle WRAP_ARGUMENTS_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WrapExtendsImplementsHandlesListSettingDescription")]
public WrapStyle WRAP_EXTENDS_LIST_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "WrapMultipleDeclarationsListSettingDescription")]
public WrapStyle WRAP_MULTIPLE_DECLARATION_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "MethodParametersSettingDescription")]
public bool ALIGN_MULTILINE_PARAMETER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "InvocationArgumentsSettingDescription")]
public bool ALIGN_MULTILINE_ARGUMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "ImplementsHandlesListSettingDescription")]
public bool ALIGN_MULTILINE_IMPLEMENTS_LIST;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "ExpressionSettingDescription")]
public bool ALIGN_MULTILINE_EXPRESSION;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "ArrayInitializerSettingDescription")]
public bool ALIGN_MULTILINE_ARRAY_INITIALIZER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "MultipleDeclarationListSettingDescription")]
public bool ALIGN_MULTIPLE_DECLARATION;
    [EditorConfigEntryAliasAttribute("", "4")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "PlaceTypeAttributeOnTheSameLineSettingDescription")]
public bool PLACE_TYPE_ATTRIBUTE_ON_SAME_LINE;
    [EditorConfigEntryAliasAttribute("", "4")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "PlaceMethodAttributeOnTheSameLineSettingDescription")]
public bool PLACE_METHOD_ATTRIBUTE_ON_SAME_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "PlacePropertyAttributeOnTheSameLineSettingDescription")]
public bool PLACE_PROPERTY_ATTRIBUTE_ON_SAME_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "PlaceEventAttributeOnTheSameLineSettingDescription")]
public bool PLACE_EVENT_ATTRIBUTE_ON_SAME_LINE;
    [EditorConfigEntryAliasAttribute("", "4")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "PlaceFieldAttributeOnTheSameLineSettingDescription")]
public bool PLACE_FIELD_ATTRIBUTE_ON_SAME_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "VBFormatSettingsKey_IndentCaseFromSelect")]
public bool INDENT_CASE_FROM_SELECT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "DontIndentCommentsStartedAtFirstColumnSettingDescription")]
public bool STICK_COMMENT;
    public VBFormatSettingsKey Clone();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "VBNETNamespaceImportSettingDescription")]
[EditorConfigKeyAttribute("vb")]
public class JetBrains.ReSharper.Psi.VB.CodeStyle.VBImportSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "AllowImportsAliasDirectiveSettingDescription")]
public bool AllowAlias;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "PreferFullyQualifiedReferencesSettingDescription")]
public bool PreferQualifiedReference;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "KeepNonTrivialImportAliasesSettingDescription")]
public bool KeepNontrivialAlias;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "RemoveUnusedOnlyImportAliasesSettingDescription")]
public bool RemoveUnusedOnlyAliases;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.VB.Resources.Strings", "KeepImportsDirectivesOnOptimizationSettingDescription")]
public IIndexedEntry`2<string, string> KeepImports;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.VB.Resources.Strings", "AddImportsDirectivesOnOptimizationSettingDescription")]
public IIndexedEntry`2<string, string> MandatoryImports;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.VB.Resources.Strings", "NamespacesThatShouldNotBeRemovedFromFullyQualifiedTypeNamesSettingDescription")]
public IIndexedEntry`2<string, string> NonRedundantNamespaces;
}
public static class JetBrains.ReSharper.Psi.VB.CodeStyle.VBImportSettingsAccessor : object {
    public static Expression`1<Func`2<VBImportSettings, bool>> AllowAlias;
    public static Expression`1<Func`2<VBImportSettings, bool>> PreferQualifiedReference;
    public static Expression`1<Func`2<VBImportSettings, IIndexedEntry`2<string, string>>> KeepImports;
    public static Expression`1<Func`2<VBImportSettings, IIndexedEntry`2<string, string>>> MandatoryImports;
    public static Expression`1<Func`2<VBImportSettings, IIndexedEntry`2<string, string>>> NonRedundantNamespaces;
    public static Expression`1<Func`2<VBImportSettings, bool>> KeepNontrivialAlias;
    public static Expression`1<Func`2<VBImportSettings, bool>> RemoveUnusedOnlyAliases;
    private static VBImportSettingsAccessor();
    public static AliasOptimizationPolicy GetAliasOptimizationPolicy(IContextBoundSettingsStore settingsStore);
}
public abstract class JetBrains.ReSharper.Psi.VB.ConstantValues.VBConstantCalculator : object {
    public static VBConstantCalculator Instance { get; }
    public static VBConstantCalculator get_Instance();
    public abstract virtual ConstantValue CalculateUnaryOperator(ISignOperator unaryOperator, ConstantValue value);
    public abstract virtual ConstantValue CalculateBinaryOperator(ISignOperator binaryOperator, ConstantValue leftValue, ConstantValue rightValue);
    public abstract virtual ConstantValue CalculateBinaryEnumOperator(string operatorName, IEnum enum, ConstantValue leftValue, ConstantValue rightValue);
    public abstract virtual ConstantValue ToTypeImplicit(ConstantValue value, IType type, bool strictOff, Boolean& strictnessFailed);
    public abstract virtual ConstantValue ToTypeExplicit(ConstantValue value, IType type);
    public abstract virtual ConstantValue Chr(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public abstract virtual ConstantValue ChrW(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public abstract virtual ConstantValue AscChar(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public abstract virtual ConstantValue AscString(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public abstract virtual ConstantValue AscWChar(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public abstract virtual ConstantValue AscWString(ConstantValue constantValue, IPsiModule module, bool strictOff);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.ConstantValues.VBConstantCalculatorExt : object {
    [ExtensionAttribute]
public static ConstantValue ToTypeImplicit(ConstantValue value, IType type, bool strictOff);
    [ExtensionAttribute]
public static ConstantValue ToTypeExplicit(ConstantValue value, IType type);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Psi.VB.ConstantValues.VBConstantCalculatorImpl : VBConstantCalculator {
    private bool myTablesInitialized;
    private Dictionary`2<OperatorInfo, BinaryOperationCalculator> myBinaryCalculators;
    private Dictionary`2<OperatorInfo, UnaryOperationCalculator> myUnaryCalculators;
    private Dictionary`2<Pair`2<string, string>, UnaryOperationCalculator> myStrictConversions;
    private Dictionary`2<Pair`2<string, string>, UnaryOperationCalculator> myStrictOffConversions;
    private VBConstantValueService myConstantValueService;
    public VBConstantCalculatorImpl(VBConstantValueService constantValueService);
    private void Initialize();
    private void InitializeConversions();
    private void InitializeTables();
    [NotNullAttribute]
private static string GetTypeString(IType type);
    public virtual ConstantValue CalculateUnaryOperator(ISignOperator unaryOperator, ConstantValue value);
    public virtual ConstantValue CalculateBinaryOperator(ISignOperator binaryOperator, ConstantValue leftValue, ConstantValue rightValue);
    private static bool ConstantTypeConversion(ConstantValue value, IType type);
    public virtual ConstantValue ToTypeImplicit(ConstantValue value, IType type, bool strictOff, Boolean& strictnessFailed);
    public virtual ConstantValue ToTypeExplicit(ConstantValue value, IType type);
    private ConstantValue ToTypeImplicit(ConstantValue value, IType type, bool isStrictOff);
    public virtual ConstantValue Chr(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public virtual ConstantValue ChrW(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public virtual ConstantValue AscChar(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public virtual ConstantValue AscString(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public virtual ConstantValue AscWChar(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public virtual ConstantValue AscWString(ConstantValue constantValue, IPsiModule module, bool strictOff);
    public virtual ConstantValue CalculateBinaryEnumOperator(string operatorName, IEnum enum, ConstantValue leftValue, ConstantValue rightValue);
    private static ConstantValue ErrorHandling(Calculator calculator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.ConstantValues.VBConstantValueFactory : object {
    public static ConstantValue CreateSbyteValue(sbyte x, IPsiModule module);
    public static ConstantValue CreateByteValue(byte x, IPsiModule module);
    public static ConstantValue CreateShortValue(short x, IPsiModule module);
    public static ConstantValue CreateUshortValue(ushort x, IPsiModule module);
    public static ConstantValue CreateIntValue(int x, IPsiModule module);
    public static ConstantValue CreateUintValue(UInt32 x, IPsiModule module);
    public static ConstantValue CreateLongValue(long x, IPsiModule module);
    public static ConstantValue CreateUlongValue(ulong x, IPsiModule module);
    public static ConstantValue CreateDecimalValue(decimal x, IPsiModule module);
    public static ConstantValue CreateFloatValue(float x, IPsiModule module);
    public static ConstantValue CreateDoubleValue(double x, IPsiModule module);
    public static ConstantValue CreateCharValue(char x, IPsiModule module);
    public static ConstantValue CreateBoolValue(bool x, IPsiModule module);
    public static ConstantValue CreateStringValue(string x, IPsiModule module);
    public static ConstantValue CreateEnumValue(IEnum enum, object value);
    public static ConstantValue CreateDateValue(DateTime x, IPsiModule module);
    public static ConstantValue CreateNothingValue(IType type, IPsiModule module);
    public static ConstantValue CreateNothingValue(IPsiModule module);
    public static ConstantValue CreateDefaultValue(IType type);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.ConstantValues.VBConstantValuePresenter : ClrConstantValuePresenter {
    public virtual RichText Present(PsiLanguageType language, ConstantValue constantValue, TypePresentationStyle typePresentationStyle);
    internal string PresentNothingValue(ConstantValue constantValue);
    internal string PresentBooleanValue(ConstantValue constantValue);
    internal string PresentString(ConstantValue constantValue);
    internal string PresentChar(ConstantValue constantValue);
    internal string PresentNumerable(ConstantValue constantValue);
    private static string PresentNumerableImpl(ConstantValue constantValue);
    private string PresentEnum(ConstantValue constantValue, IEnum enum);
    public static string PresentEnum(ConstantValue constantValue, IEnum enum, Func`3<StringBuilder, IField, StringBuilder> memberPresenter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.ConstantValues.VBConstantValueService : ClrConstantValueService {
    public VBConstantValueService(IConstantValuePresenter constantValuePresenter);
    public virtual ConstantValue GetDefaultValue(IType type);
}
public interface JetBrains.ReSharper.Psi.VB.ControlFlow.IVBControlFlowAnalysisResult {
    public OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, IVBExpression> PossibleMultipleEnumeration { get; }
    public bool IsFunctionValueInitializeOnImplicitReturn { get; }
    public abstract virtual OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, IVBExpression> get_PossibleMultipleEnumeration();
    public abstract virtual bool get_IsFunctionValueInitializeOnImplicitReturn();
}
public interface JetBrains.ReSharper.Psi.VB.ControlFlow.IVBControlFlowEdge {
    public IVBControlFlowElement Source { get; }
    public IVBControlFlowElement Target { get; public set; }
    public Nullable`1<bool> BooleanValue { get; public set; }
    public Nullable`1<bool> NullCoalescingCondition { get; public set; }
    public bool PassThroughFinally { get; }
    public IEnumerable`1<IUsingStatement> ExitFromUsings { get; }
    public abstract virtual IVBControlFlowElement get_Source();
    public abstract virtual IVBControlFlowElement get_Target();
    public abstract virtual void set_Target(IVBControlFlowElement value);
    public abstract virtual Nullable`1<bool> get_BooleanValue();
    public abstract virtual void set_BooleanValue(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_NullCoalescingCondition();
    public abstract virtual void set_NullCoalescingCondition(Nullable`1<bool> value);
    public abstract virtual bool get_PassThroughFinally();
    public abstract virtual IEnumerable`1<IUsingStatement> get_ExitFromUsings();
}
public interface JetBrains.ReSharper.Psi.VB.ControlFlow.IVBControlFlowElement {
}
public interface JetBrains.ReSharper.Psi.VB.ControlFlow.IVBControlFlowError {
    public VBControlFlowErrorType ErrorType { get; }
    public abstract virtual VBControlFlowErrorType get_ErrorType();
}
public interface JetBrains.ReSharper.Psi.VB.ControlFlow.IVBControlFlowGraph {
    public IDictionary`2<ITreeNode, VBControlFlowErrorType> ControlFlowErrors { get; }
    public ICollection`1<IVBControlFlowEdge> ReachableExits { get; }
    [CanBeNullAttribute]
public IVBControlFlowElement ImplicitReturn { get; }
    public abstract virtual IDictionary`2<ITreeNode, VBControlFlowErrorType> get_ControlFlowErrors();
    public abstract virtual ICollection`1<IVBControlFlowEdge> get_ReachableExits();
    public abstract virtual IVBControlFlowElement get_ImplicitReturn();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.ControlFlow.VBControlFlowBuilder : object {
    public sealed virtual bool CanBuildFrom(ITreeNode treeNode);
    public sealed virtual IControlFlowGraph GraphFromNode(ITreeNode graphOwner, IResolveContext context, bool buildExpressions);
}
public enum JetBrains.ReSharper.Psi.VB.ControlFlow.VBControlFlowErrorType : Enum {
    public int value__;
    public static VBControlFlowErrorType UNRESOLVED_JUMP;
    public static VBControlFlowErrorType JUMP_FROM_FINALLY;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.ControlFlow.VBControlFlowGraphExtensions : object {
    [ExtensionAttribute]
public static IVBControlFlowAnalysisResult Inspect(IVBControlFlowGraph graph);
}
public interface JetBrains.ReSharper.Psi.VB.DeclaredElements.Query.IQueryAnonymousTypeProperty {
}
public interface JetBrains.ReSharper.Psi.VB.DeclaredElements.Query.IQueryDeclaredElement {
}
public interface JetBrains.ReSharper.Psi.VB.DeclaredElements.Query.IQueryRangeVariable {
}
public abstract class JetBrains.ReSharper.Psi.VB.ExpectedTypes.ArgumentsMatchingPolicyFactory : object {
    public static IMatchingPolicy AllMatcher;
    public static IMatchingPolicy AllPartialMatcher;
    public static IMatchingPolicy UnaryOperatorMatcher;
    private static ArgumentsMatchingPolicyFactory();
    public static IMatchingPolicy OperatorMatcher(int argumentNumber);
    public static IMatchingPolicy PrefixMatcher(int prefixLength);
    public static IMatchingPolicy ExceptMatcher(int index);
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.CandidatesEngine : object {
    private IVBInvocationInfo myInvocation;
    private CandidatesEngineStrategy myStrategy;
    private IVBTypeConversionRule myTypeConversionRule;
    private IList`1<VBInvocationCandidate> myCandidates;
    private IList`1<VBInvocationCandidate> myApplicableCandidates;
    private IList`1<VBInvocationCandidate> myNotApplicableCandidates;
    public IList`1<VBInvocationCandidate> Candidates { get; }
    public IList`1<VBInvocationCandidate> ApplicableCandidates { get; }
    public IList`1<VBInvocationCandidate> NotApplicableCandidates { get; }
    public CandidatesEngine(IVBInvocationInfo invocation, CandidatesEngineStrategy strategy, IVBTypeConversionRule rule);
    public IList`1<VBInvocationCandidate> get_Candidates();
    public IList`1<VBInvocationCandidate> get_ApplicableCandidates();
    public IList`1<VBInvocationCandidate> get_NotApplicableCandidates();
    private IList`1<VBInvocationCandidate> CalculateCandidates();
    [CanBeNullAttribute]
private VBInvocationCandidate InferTypeArguments(InvokedSymbolInfo candidate);
    private IList`1<VBInvocationCandidate> CalculateApplicableCandidates();
    [CanBeNullAttribute]
private static VBInvocationCandidate CreateCandidate(InvokedSymbolInfo info);
    [CompilerGeneratedAttribute]
private bool <get_NotApplicableCandidates>b__12_0(VBInvocationCandidate x);
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.CandidatesEngineStrategy : ValueType {
    [CompilerGeneratedAttribute]
private IMatchingPolicy <Applicability>k__BackingField;
    [CompilerGeneratedAttribute]
private IMatchingPolicy <TypeInference>k__BackingField;
    public IMatchingPolicy Applicability { get; }
    public IMatchingPolicy TypeInference { get; }
    public CandidatesEngineStrategy(IMatchingPolicy typeInference, IMatchingPolicy applicability);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IMatchingPolicy get_Applicability();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IMatchingPolicy get_TypeInference();
}
public interface JetBrains.ReSharper.Psi.VB.ExpectedTypes.IMatchingPolicy {
    public bool IsPartial { get; }
    public abstract virtual ICollection`1<int> GetSubstantialIndices(int count);
    public abstract virtual bool get_IsPartial();
}
public interface JetBrains.ReSharper.Psi.VB.ExpectedTypes.IVBExpectedTypesProvider {
    [ItemNotNullAttribute]
public abstract virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(IVBExpression expression, ExpectedTypeMode mode);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(IDeclaredTypeUsage usage);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(ITypeUsage usage);
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBConvertibleToWithTypeInference : ConvertibleToWithTypeInference`2<ClrTypeConstraintsVerifier, IVBTypeConversionRule> {
    private IVBTypeConversionRule myRule;
    protected IVBTypeConversionRule TypeConversionRule { get; }
    public VBConvertibleToWithTypeInference(IType targetType, IVBTypeConversionRule rule, bool isExactType, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution ownerSubstitution);
    protected virtual IVBTypeConversionRule get_TypeConversionRule();
    protected virtual bool IsImplicitlyConvertible(IType type, IType inferredType);
    protected virtual IExpectedTypeConstraint CreateConvertibleFromConstraint(IType type);
    protected virtual IExpectedTypeConstraint CreateConvertibleToConstraint(IType type);
    protected virtual IExpectedTypeConstraint CreateConstraintForArrayElementType(IType elementType);
    protected virtual IExpectedTypeConstraint CreateConstraintForDelegateReturnType(IDelegate delegate, ISubstitution substitution, ReferenceKind& returnKind);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBExpectedTypeForDeclaredTypeUsageAnalyzer : object {
    private IVBExpectedTypesProvider myExpectedTypeProvider;
    private IDeclaredTypeUsage myDeclaredTypeUsageNode;
    public VBExpectedTypeForDeclaredTypeUsageAnalyzer(IVBExpectedTypesProvider expectedTypeProvider, IDeclaredTypeUsage declaredTypeUsageNode);
    [NotNullAttribute]
public IReadOnlyList`1<ExpectedType> Calc();
    private IReadOnlyList`1<ExpectedType> ObjectCreationExpression();
    private IReadOnlyList`1<ExpectedType> ArrayCreationExpression();
}
internal class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBExpectedTypeForExpressionAnalyzer : object {
    private static string IIf;
    private static string MicrosoftVisualBasicInteraction;
    private static string EQuals;
    private IVBExpression myExpression;
    private IVBTypeConversionRule myTypeConversionRule;
    private ExpectedTypeMode myMode;
    public VBExpectedTypeForExpressionAnalyzer(IVBExpression expression, IVBTypeConversionRule typeConversionRule, ExpectedTypeMode mode);
    public IReadOnlyList`1<ExpectedType> ReStart(IVBExpression expression);
    [NotNullAttribute]
public IReadOnlyList`1<ExpectedType> Calc();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> TupleExpression();
    [CanBeNullAttribute]
private ExpectedType CalculateTupleComponentExpectedType(IType type, int index, string name);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ParameterDeclaration();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> Yield();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AwaitExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ForeachStatement();
    private IReadOnlyList`1<ExpectedType> CollectionInitializer();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> UnaryExpression();
    private bool CheckExpectedTypes(IReadOnlyList`1<ExpectedType> expectedTypes, IType type);
    [NotNullAttribute]
private IEnumerable`1<IType> SimplePredefinedAndNullableTypes(IPsiModule module);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> BinaryExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> IsExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> IsNotExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> CaseExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> EnumMemberDeclaration();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> Lambda();
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> LambdaExpressionExpectedReturnType(ILambdaExpression lambdaExpression);
    private IReadOnlyList`1<ExpectedType> DominantTypeConstraint(IReadOnlyList`1<ExpectedType> contextExpectedTypes, IType otherType);
    private int ConditionalExpressionOtherIndex(IConditionalExpression conditionalExpression, IVBArgument argument);
    private IReadOnlyList`1<ExpectedType> ConditionalExpression(IVBArgument argument);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> IIfExpression(IVBArgument argument);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> EqualsExpression(IVBArgument argument);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> EmbeddedExpression();
    private IReadOnlyList`1<ExpectedType> EventHandler();
    private IReadOnlyList`1<ExpectedType> AnonymousArrayCreation();
    private IReadOnlyList`1<ExpectedType> MemberInitializer();
    [NotNullAttribute]
private IExpectedTypeConstraint IntersectExpectedTypes(IEnumerable`1<IReference> references);
    private IExpectedTypeConstraint CalcVariableConstraint(IVBLocalVariable variable, IVBTreeNode declaration);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> LocalVariableDeclarationInitializer();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> VariableDeclarationInitializer();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ConstantDeclarationInitializer();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> UsingVariableDeclaration();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ReturnValue();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> UsingResource();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AssignmentSource();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AssignmentTarget();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> MidAssignmentRValue();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> IfCondition();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> WhileCondition();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> LoopCondition();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ForBounds();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> Thrown();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> Erased();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ErrorCode();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> Redim();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ArrayBound();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> AddressOfAddressee();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ParenthesizedExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> CastExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> LikeExpression();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> MidAssignmentArgument(IVBArgument argument);
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> Argument();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> ArgumentedExpression(IVBArgumentInfo argument, IVBInvocationInfo argumentedExpression);
    private CandidatesEngineStrategy ArgumentInfoStrategy(int argumentIndex);
    private IReadOnlyList`1<ExpectedType> GetExpectedTypesWithCandidates(IVBArgumentInfo argument, IVBInvocationInfo argumentedExpression, CandidatesEngineStrategy strategy, bool mustBeConstant);
    private TailType CalcTailType(IVBArgumentInfo argumentInfo, IList`1<IParameter> parameters, int parameterIndex, IType elementType);
    private static HeadType CalcHeadType(IVBArgumentInfo argumentInfo, IParametersOwner parametersOwner);
    private IExpectedTypeConstraint DirectCastConvertibleTo(IType type);
    [NotNullAttribute]
private IExpectedTypeConstraint ImplicitlyConvertibleTo(IType type);
    [NotNullAttribute]
private IExpectedTypeConstraint ImplicitlyConvertibleFrom(IType type);
    [NotNullAttribute]
private IExpectedTypeConstraint ExplicitlyConvertibleTo(IType type);
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> ArrayOrObjectLValueExpectedType(Nullable`1<int> expectedRank);
    [NotNullAttribute]
private ExpectedType BoolExpectedType();
    [NotNullAttribute]
private PredefinedType PredefinedType();
    [CompilerGeneratedAttribute]
private bool <UnaryExpression>g__ReturnTypePredicate|16_0(IType type, <>c__DisplayClass16_0& );
}
internal class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBExpectedTypeForTypeUsageAnalyzer : object {
    private IVBExpectedTypesProvider myExpectedTypesProvider;
    private ITypeUsage myTypeUsage;
    public VBExpectedTypeForTypeUsageAnalyzer(IVBExpectedTypesProvider expectedTypesProvider, ITypeUsage typeUsage);
    [NotNullAttribute]
public IReadOnlyList`1<ExpectedType> Calc();
    [CanBeNullAttribute]
private IReadOnlyList`1<ExpectedType> TupleType();
    private IReadOnlyList`1<ExpectedType> CastExpression();
    private ExpectedType[] TypeArgument();
    [NotNullAttribute]
private IReadOnlyList`1<ExpectedType> ReStart(ITypeUsage typeUsage);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBExpectedTypesProvider : object {
    public sealed virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(IExpression expression, ExpectedTypeMode mode);
    [NotNullAttribute]
public virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(IVBExpression expression, ExpectedTypeMode mode);
    public sealed virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(IDeclaredTypeUsage usage);
    public sealed virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(ITypeUsage usage);
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBExplicitlyConvertibleToConstraint : ConvertibleToConstraint`1<ClrTypeConstraintsVerifier> {
    private IVBTypeConversionRule myRule;
    public VBExplicitlyConvertibleToConstraint(IType type, IVBTypeConversionRule rule);
    protected virtual IReadOnlyCollection`1<ISubstitution> SolveSubtypingForFrom(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleToConstraint(IType toType);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleFromConstraint(IType fromType);
    public virtual bool Accepts(IType type);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBHeadType : HeadType {
    public static HeadType LBrace;
    public static HeadType Await;
    protected VBHeadType(string name, string text);
    private static VBHeadType();
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBImplicitlyConvertibleFromConstraint : ConvertibleFromConstraint {
    private IVBTypeConversionRule myRule;
    public VBImplicitlyConvertibleFromConstraint(IType type, IVBTypeConversionRule rule);
    public virtual bool Accepts(IType type);
    protected virtual IExpectedTypeConstraint CreateConvertibleFromConstraint(IType fromType);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBImplicitlyConvertibleToConstraint : ConvertibleToConstraint`1<ClrTypeConstraintsVerifier> {
    private IVBTypeConversionRule myRule;
    public VBImplicitlyConvertibleToConstraint(IType type, IVBTypeConversionRule rule);
    protected virtual IReadOnlyCollection`1<ISubstitution> SolveSubtypingForFrom(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleToConstraint(IType toType);
    protected virtual IExpectedTypeConstraint CreateImplicitlyConvertibleFromConstraint(IType fromType);
    public virtual bool Accepts(IType type);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBInvocationCandidate : InvocationCandidate {
    private IArgumentsMatcher myMatcher;
    public IArgumentsMatcher Matcher { get; }
    public VBInvocationCandidate(IParametersOwner element, ISubstitution substitution, bool isExtensionMethodInvocation, IArgumentsMatcher matcher);
    public IArgumentsMatcher get_Matcher();
    public DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IVBArgumentInfo argumentInfo, DeclaredElementInstance`1<IParametersOwner> elementInstance);
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBSuperTypeConstraint : SuperTypeConstraint {
    private IVBTypeConversionRule myRule;
    public VBSuperTypeConstraint(IType type, IVBTypeConversionRule rule);
    protected virtual IExpectedTypeConstraint CreateConvertibleFrom(IType type);
    protected virtual IExpectedTypeConstraint CreateConvertibleTo(IType type);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBTailType : TailType {
    public static VBTailType Comma;
    public static VBTailType RParenth;
    public static VBTailType RBrace;
    public static VBTailType TypeArgumentListAndLeaveCaretWithin;
    public static VBTailType ParenthesesAndLeaveCaretWithin;
    public static VBTailType ParenthesesAndLeaveCaretAfter;
    public static VBTailType LParenth;
    public static VBTailType ParenthesesAndBracesAndLeaveCaretWithin;
    public static VBTailType Braces;
    public static VBTailType Dot;
    public static VBTailType ParenthesesAndLeaveCaretWithinAndComma;
    public static VBTailType ParenthesesAndLeaveCaretAfterAndComma;
    public static VBTailType ParenthesesAndLeaveCaretWithinAndRParenth;
    public static VBTailType ParenthesesAndLeaveCaretAfterAndRParenth;
    public static VBTailType ColonEq;
    private VBTailType(string name);
    private static VBTailType();
    public virtual TokenNodeType[] EvaluateTail(ISolution solution, IDocument document);
}
public class JetBrains.ReSharper.Psi.VB.ExpectedTypes.VBTypeArgumentAnalyzer : TypeArgumentAnalyzer`2<ITypeUsage, ITypeArgumentList> {
    private IVBExpectedTypesProvider myExpectedTypesProvider;
    public VBTypeArgumentAnalyzer(IVBExpectedTypesProvider expectedTypesProvider, ITypeUsage node);
    protected virtual IExpectedTypeConstraint CreateConstraint(IType type);
    protected virtual IExpectedTypeConstraint[] GetAdditionalTypes(IType type, IReadOnlyList`1<ITypeParameter> typeParameters);
    public virtual ITypeArgumentList GetTypeArgumentList(ITypeUsage typeUsage, Int32& index);
    protected virtual TailType GetTailType(int index, IReadOnlyList`1<ITypeParameter> typeParameters);
    public virtual IReadOnlyList`1<ExpectedType> GetTypeArgumentListContext(ITypeArgumentList typeArgumentList, List`1& types);
}
public static class JetBrains.ReSharper.Psi.VB.ExtensionMethods.VBExtensionMethodsHelper : object {
    [CanBeNullAttribute]
public static IType GetQualifierType(IVBArgumentInfo qualifier);
    [NotNullAttribute]
public static ResolveErrorType IsExtensionMethodApplicable(IMethod method, IVBArgumentInfo extensionArgument, IList`1<IVBArgumentInfo> arguments, IList`1<IType> typeArguments, IVBTreeNode context);
    public static ExtensionMethodAccessibility IsExtensionMethodAccessible(IMethod method, IAccessContext accessContext);
    public static bool SomeExtensionMethodIsAccessible(IVBArgumentInfo qualifier, IAccessContext accessContext, IVBTreeNode context, string name);
}
public abstract class JetBrains.ReSharper.Psi.VB.ExtensionMethods.VBExtensionMethodsRegistry : object {
    public static VBExtensionMethodsRegistry GetInstance(ISolution solution);
    public abstract virtual IExtensionMethodsQuery GetAllExtensionMethods();
}
public class JetBrains.ReSharper.Psi.VB.Gen.ErrorMessages : object {
    private static string ourMessage_0;
    private static string ourMessage_1;
    private static string ourMessage_2;
    private static string ourMessage_3;
    private static string ourMessage_4;
    private static string ourMessage_5;
    private static string ourMessage_6;
    private static string ourMessage_7;
    private static string ourMessage_8;
    private static string ourMessage_9;
    private static string ourMessage_10;
    private static string ourMessage_11;
    private static string ourMessage_12;
    private static string ourMessage_13;
    private static string ourMessage_14;
    private static string ourMessage_15;
    private static string ourMessage_16;
    private static string ourMessage_17;
    private static string ourMessage_18;
    private static string ourMessage_19;
    private static string ourMessage_20;
    private static string ourMessage_21;
    private static string ourMessage_22;
    private static string ourMessage_23;
    private static string ourMessage_24;
    private static string ourMessage_25;
    private static string ourMessage_26;
    private static string ourMessage_27;
    private static string ourMessage_28;
    private static string ourMessage_29;
    private static string ourMessage_30;
    private static string ourMessage_31;
    private static string ourMessage_32;
    private static string ourMessage_33;
    private static string ourMessage_34;
    private static string ourMessage_35;
    private static string ourMessage_36;
    private static string ourMessage_37;
    private static string ourMessage_38;
    private static string ourMessage_39;
    private static string ourMessage_40;
    private static string ourMessage_41;
    private static string ourMessage_42;
    private static string ourMessage_43;
    private static string ourMessage_44;
    private static string ourMessage_45;
    private static string ourMessage_46;
    private static string ourMessage_47;
    private static string ourMessage_48;
    private static string ourMessage_49;
    private static string ourMessage_50;
    private static string ourMessage_51;
    private static string ourMessage_52;
    private static string ourMessage_53;
    private static string ourMessage_54;
    private static string ourMessage_55;
    private static string ourMessage_56;
    private static string ourMessage_57;
    private static string ourMessage_58;
    private static string ourMessage_59;
    private static string ourMessage_60;
    private static string ourMessage_61;
    private static string ourMessage_62;
    private static string ourMessage_63;
    private static string ourMessage_64;
    private static string ourMessage_65;
    private static string ourMessage_66;
    private static string ourMessage_67;
    private static string ourMessage_68;
    private static string ourMessage_69;
    private static string ourMessage_70;
    private static string ourMessage_71;
    private static string ourMessage_72;
    private static string ourMessage_73;
    private static string ourMessage_74;
    private static string ourMessage_75;
    private static string ourMessage_76;
    private static string ourMessage_77;
    private static string ourMessage_78;
    private static string ourMessage_79;
    private static string ourMessage_80;
    private static string ourMessage_81;
    private static string ourMessage_82;
    private static string ourMessage_83;
    private static string ourMessage_84;
    private static string ourMessage_85;
    private static string ourMessage_86;
    private static string ourMessage_87;
    private static string ourMessage_88;
    private static string ourMessage_89;
    private static string ourMessage_90;
    private static string ourMessage_91;
    private static string ourMessage_92;
    private static string ourMessage_93;
    private static string ourMessage_94;
    private static string ourMessage_95;
    private static string ourMessage_96;
    private static string ourMessage_97;
    private static string ourMessage_98;
    private static string ourMessage_99;
    private static string ourMessage_100;
    private static string ourMessage_101;
    private static string ourMessage_102;
    private static string ourMessage_103;
    private static string ourMessage_104;
    private static string ourMessage_105;
    private static string ourMessage_106;
    private static string ourMessage_107;
    private static string ourMessage_108;
    private static string ourMessage_109;
    private static string ourMessage_110;
    private static string ourMessage_111;
    private static string ourMessage_112;
    private static string ourMessage_113;
    private static string ourMessage_114;
    private static string ourMessage_115;
    private static string ourMessage_116;
    private static string ourMessage_117;
    private static string ourMessage_118;
    private static string ourMessage_119;
    private static string ourMessage_120;
    private static string ourMessage_121;
    private static string ourMessage_122;
    private static string ourMessage_123;
    private static string ourMessage_124;
    private static string ourMessage_125;
    private static string ourMessage_126;
    private static string ourMessage_127;
    private static string ourMessage_128;
    private static string ourMessage_129;
    private static string ourMessage_130;
    private static string ourMessage_131;
    private static string ourMessage_132;
    private static string ourMessage_133;
    private static string ourMessage_134;
    private static string ourMessage_135;
    private static string ourMessage_136;
    private static string ourMessage_137;
    private static string ourMessage_138;
    private static string ourMessage_139;
    private static string ourMessage_140;
    private static string ourMessage_141;
    private static string ourMessage_142;
    private static string ourMessage_143;
    private static string ourMessage_144;
    private static string ourMessage_145;
    private static string ourMessage_146;
    private static string ourMessage_147;
    private static string ourMessage_148;
    private static string ourMessage_149;
    private static string ourMessage_150;
    private static string ourMessage_151;
    private static string ourMessage_152;
    private static string ourMessage_153;
    private static string ourMessage_154;
    private static string ourMessage_155;
    private static string ourMessage_156;
    private static string ourMessage_157;
    private static string ourMessage_158;
    private static string ourMessage_159;
    private static string ourMessage_160;
    private static string ourMessage_161;
    private static string ourMessage_162;
    private static string ourMessage_163;
    private static string ourMessage_164;
    private static string ourMessage_165;
    private static string ourMessage_166;
    private static string ourMessage_167;
    private static string ourMessage_168;
    private static string ourMessage_169;
    private static string ourMessage_170;
    private static string ourMessage_171;
    private static string ourMessage_172;
    private static string ourMessage_173;
    private static string ourMessage_174;
    private static string ourMessage_175;
    private static string ourMessage_176;
    private static string ourMessage_177;
    private static string ourMessage_178;
    private static string ourMessage_179;
    private static string ourMessage_180;
    private static string ourMessage_181;
    private static string ourMessage_182;
    private static string ourMessage_183;
    private static string ourMessage_184;
    private static string ourMessage_185;
    private static string ourMessage_186;
    private static string ourMessage_187;
    private static string ourMessage_188;
    private static string ourMessage_189;
    private static string ourMessage_190;
    private static string ourMessage_191;
    private static string ourMessage_192;
    private static string ourMessage_193;
    private static string ourMessage_194;
    private static string ourMessage_195;
    private static string ourMessage_196;
    private static string ourMessage_197;
    private static string ourMessage_198;
    private static string ourMessage_199;
    private static string ourMessage_200;
    private static string ourMessage_201;
    private static string ourMessage_202;
    private static string ourMessage_203;
    private static string ourMessage_204;
    private static string ourMessage_205;
    private static string ourMessage_206;
    private static string ourMessage_207;
    private static string ourMessage_208;
    private static string ourMessage_209;
    private static string ourMessage_210;
    private static string ourMessage_211;
    private static string ourMessage_212;
    private static string ourMessage_213;
    private static string ourMessage_214;
    private static string ourMessage_215;
    private static string ourMessage_216;
    private static string ourMessage_217;
    private static string ourMessage_218;
    private static string ourMessage_219;
    private static string ourMessage_220;
    private static string ourMessage_221;
    private static string ourMessage_222;
    private static string ourMessage_223;
    private static string ourMessage_224;
    private static string ourMessage_225;
    private static string ourMessage_226;
    private static string ourMessage_227;
    private static string ourMessage_228;
    private static string ourMessage_229;
    private static string ourMessage_230;
    private static string ourMessage_231;
    private static string ourMessage_232;
    private static string ourMessage_233;
    private static string ourMessage_234;
    private static string ourMessage_235;
    private static string ourMessage_236;
    private static string ourMessage_237;
    private static string ourMessage_238;
    private static string ourMessage_239;
    private static string ourMessage_240;
    private static string ourMessage_241;
    private static string ourMessage_242;
    private static string ourMessage_243;
    private static string ourMessage_244;
    private static string ourMessage_245;
    private static string ourMessage_246;
    private static string ourMessage_247;
    private static string ourMessage_248;
    private static string ourMessage_249;
    private static string ourMessage_250;
    private static string ourMessage_251;
    private static string ourMessage_252;
    private static string ourMessage_253;
    private static string ourMessage_254;
    private static string ourMessage_255;
    private static string ourMessage_256;
    public static string GetErrorMessage0();
    public static string GetErrorMessage1();
    public static string GetErrorMessage2();
    public static string GetErrorMessage3();
    public static string GetErrorMessage4();
    public static string GetErrorMessage5();
    public static string GetErrorMessage6();
    public static string GetErrorMessage7();
    public static string GetErrorMessage8();
    public static string GetErrorMessage9();
    public static string GetErrorMessage10();
    public static string GetErrorMessage11();
    public static string GetErrorMessage12();
    public static string GetErrorMessage13();
    public static string GetErrorMessage14();
    public static string GetErrorMessage15();
    public static string GetErrorMessage16();
    public static string GetErrorMessage17();
    public static string GetErrorMessage18();
    public static string GetErrorMessage19();
    public static string GetErrorMessage20();
    public static string GetErrorMessage21();
    public static string GetErrorMessage22();
    public static string GetErrorMessage23();
    public static string GetErrorMessage24();
    public static string GetErrorMessage25();
    public static string GetErrorMessage26();
    public static string GetErrorMessage27();
    public static string GetErrorMessage28();
    public static string GetErrorMessage29();
    public static string GetErrorMessage30();
    public static string GetErrorMessage31();
    public static string GetErrorMessage32();
    public static string GetErrorMessage33();
    public static string GetErrorMessage34();
    public static string GetErrorMessage35();
    public static string GetErrorMessage36();
    public static string GetErrorMessage37();
    public static string GetErrorMessage38();
    public static string GetErrorMessage39();
    public static string GetErrorMessage40();
    public static string GetErrorMessage41();
    public static string GetErrorMessage42();
    public static string GetErrorMessage43();
    public static string GetErrorMessage44();
    public static string GetErrorMessage45();
    public static string GetErrorMessage46();
    public static string GetErrorMessage47();
    public static string GetErrorMessage48();
    public static string GetErrorMessage49();
    public static string GetErrorMessage50();
    public static string GetErrorMessage51();
    public static string GetErrorMessage52();
    public static string GetErrorMessage53();
    public static string GetErrorMessage54();
    public static string GetErrorMessage55();
    public static string GetErrorMessage56();
    public static string GetErrorMessage57();
    public static string GetErrorMessage58();
    public static string GetErrorMessage59();
    public static string GetErrorMessage60();
    public static string GetErrorMessage61();
    public static string GetErrorMessage62();
    public static string GetErrorMessage63();
    public static string GetErrorMessage64();
    public static string GetErrorMessage65();
    public static string GetErrorMessage66();
    public static string GetErrorMessage67();
    public static string GetErrorMessage68();
    public static string GetErrorMessage69();
    public static string GetErrorMessage70();
    public static string GetErrorMessage71();
    public static string GetErrorMessage72();
    public static string GetErrorMessage73();
    public static string GetErrorMessage74();
    public static string GetErrorMessage75();
    public static string GetErrorMessage76();
    public static string GetErrorMessage77();
    public static string GetErrorMessage78();
    public static string GetErrorMessage79();
    public static string GetErrorMessage80();
    public static string GetErrorMessage81();
    public static string GetErrorMessage82();
    public static string GetErrorMessage83();
    public static string GetErrorMessage84();
    public static string GetErrorMessage85();
    public static string GetErrorMessage86();
    public static string GetErrorMessage87();
    public static string GetErrorMessage88();
    public static string GetErrorMessage89();
    public static string GetErrorMessage90();
    public static string GetErrorMessage91();
    public static string GetErrorMessage92();
    public static string GetErrorMessage93();
    public static string GetErrorMessage94();
    public static string GetErrorMessage95();
    public static string GetErrorMessage96();
    public static string GetErrorMessage97();
    public static string GetErrorMessage98();
    public static string GetErrorMessage99();
    public static string GetErrorMessage100();
    public static string GetErrorMessage101();
    public static string GetErrorMessage102();
    public static string GetErrorMessage103();
    public static string GetErrorMessage104();
    public static string GetErrorMessage105();
    public static string GetErrorMessage106();
    public static string GetErrorMessage107();
    public static string GetErrorMessage108();
    public static string GetErrorMessage109();
    public static string GetErrorMessage110();
    public static string GetErrorMessage111();
    public static string GetErrorMessage112();
    public static string GetErrorMessage113();
    public static string GetErrorMessage114();
    public static string GetErrorMessage115();
    public static string GetErrorMessage116();
    public static string GetErrorMessage117();
    public static string GetErrorMessage118();
    public static string GetErrorMessage119();
    public static string GetErrorMessage120();
    public static string GetErrorMessage121();
    public static string GetErrorMessage122();
    public static string GetErrorMessage123();
    public static string GetErrorMessage124();
    public static string GetErrorMessage125();
    public static string GetErrorMessage126();
    public static string GetErrorMessage127();
    public static string GetErrorMessage128();
    public static string GetErrorMessage129();
    public static string GetErrorMessage130();
    public static string GetErrorMessage131();
    public static string GetErrorMessage132();
    public static string GetErrorMessage133();
    public static string GetErrorMessage134();
    public static string GetErrorMessage135();
    public static string GetErrorMessage136();
    public static string GetErrorMessage137();
    public static string GetErrorMessage138();
    public static string GetErrorMessage139();
    public static string GetErrorMessage140();
    public static string GetErrorMessage141();
    public static string GetErrorMessage142();
    public static string GetErrorMessage143();
    public static string GetErrorMessage144();
    public static string GetErrorMessage145();
    public static string GetErrorMessage146();
    public static string GetErrorMessage147();
    public static string GetErrorMessage148();
    public static string GetErrorMessage149();
    public static string GetErrorMessage150();
    public static string GetErrorMessage151();
    public static string GetErrorMessage152();
    public static string GetErrorMessage153();
    public static string GetErrorMessage154();
    public static string GetErrorMessage155();
    public static string GetErrorMessage156();
    public static string GetErrorMessage157();
    public static string GetErrorMessage158();
    public static string GetErrorMessage159();
    public static string GetErrorMessage160();
    public static string GetErrorMessage161();
    public static string GetErrorMessage162();
    public static string GetErrorMessage163();
    public static string GetErrorMessage164();
    public static string GetErrorMessage165();
    public static string GetErrorMessage166();
    public static string GetErrorMessage167();
    public static string GetErrorMessage168();
    public static string GetErrorMessage169();
    public static string GetErrorMessage170();
    public static string GetErrorMessage171();
    public static string GetErrorMessage172();
    public static string GetErrorMessage173();
    public static string GetErrorMessage174();
    public static string GetErrorMessage175();
    public static string GetErrorMessage176();
    public static string GetErrorMessage177();
    public static string GetErrorMessage178();
    public static string GetErrorMessage179();
    public static string GetErrorMessage180();
    public static string GetErrorMessage181();
    public static string GetErrorMessage182();
    public static string GetErrorMessage183();
    public static string GetErrorMessage184();
    public static string GetErrorMessage185();
    public static string GetErrorMessage186();
    public static string GetErrorMessage187();
    public static string GetErrorMessage188();
    public static string GetErrorMessage189();
    public static string GetErrorMessage190();
    public static string GetErrorMessage191();
    public static string GetErrorMessage192();
    public static string GetErrorMessage193();
    public static string GetErrorMessage194();
    public static string GetErrorMessage195();
    public static string GetErrorMessage196();
    public static string GetErrorMessage197();
    public static string GetErrorMessage198();
    public static string GetErrorMessage199();
    public static string GetErrorMessage200();
    public static string GetErrorMessage201();
    public static string GetErrorMessage202();
    public static string GetErrorMessage203();
    public static string GetErrorMessage204();
    public static string GetErrorMessage205();
    public static string GetErrorMessage206();
    public static string GetErrorMessage207();
    public static string GetErrorMessage208();
    public static string GetErrorMessage209();
    public static string GetErrorMessage210();
    public static string GetErrorMessage211();
    public static string GetErrorMessage212();
    public static string GetErrorMessage213();
    public static string GetErrorMessage214();
    public static string GetErrorMessage215();
    public static string GetErrorMessage216();
    public static string GetErrorMessage217();
    public static string GetErrorMessage218();
    public static string GetErrorMessage219();
    public static string GetErrorMessage220();
    public static string GetErrorMessage221();
    public static string GetErrorMessage222();
    public static string GetErrorMessage223();
    public static string GetErrorMessage224();
    public static string GetErrorMessage225();
    public static string GetErrorMessage226();
    public static string GetErrorMessage227();
    public static string GetErrorMessage228();
    public static string GetErrorMessage229();
    public static string GetErrorMessage230();
    public static string GetErrorMessage231();
    public static string GetErrorMessage232();
    public static string GetErrorMessage233();
    public static string GetErrorMessage234();
    public static string GetErrorMessage235();
    public static string GetErrorMessage236();
    public static string GetErrorMessage237();
    public static string GetErrorMessage238();
    public static string GetErrorMessage239();
    public static string GetErrorMessage240();
    public static string GetErrorMessage241();
    public static string GetErrorMessage242();
    public static string GetErrorMessage243();
    public static string GetErrorMessage244();
    public static string GetErrorMessage245();
    public static string GetErrorMessage246();
    public static string GetErrorMessage247();
    public static string GetErrorMessage248();
    public static string GetErrorMessage249();
    public static string GetErrorMessage250();
    public static string GetErrorMessage251();
    public static string GetErrorMessage252();
    public static string GetErrorMessage253();
    public static string GetErrorMessage254();
    public static string GetErrorMessage255();
    public static string GetErrorMessage256();
}
public static class JetBrains.ReSharper.Psi.VB.Gen.TokenBitsets : object {
    public static NodeTypeSet TokenBitset_0;
    public static NodeTypeSet TokenBitset_1;
    public static NodeTypeSet TokenBitset_2;
    public static NodeTypeSet TokenBitset_3;
    public static NodeTypeSet TokenBitset_4;
    public static NodeTypeSet TokenBitset_5;
    public static NodeTypeSet TokenBitset_6;
    public static NodeTypeSet TokenBitset_7;
    public static NodeTypeSet TokenBitset_8;
    public static NodeTypeSet TokenBitset_9;
    public static NodeTypeSet TokenBitset_10;
    public static NodeTypeSet TokenBitset_11;
    public static NodeTypeSet TokenBitset_12;
    public static NodeTypeSet TokenBitset_13;
    public static NodeTypeSet TokenBitset_14;
    public static NodeTypeSet TokenBitset_15;
    public static NodeTypeSet TokenBitset_16;
    public static NodeTypeSet TokenBitset_17;
    public static NodeTypeSet TokenBitset_18;
    public static NodeTypeSet TokenBitset_19;
    public static NodeTypeSet TokenBitset_20;
    public static NodeTypeSet TokenBitset_21;
    public static NodeTypeSet TokenBitset_22;
    public static NodeTypeSet TokenBitset_23;
    public static NodeTypeSet TokenBitset_24;
    public static NodeTypeSet TokenBitset_25;
    public static NodeTypeSet TokenBitset_26;
    public static NodeTypeSet TokenBitset_27;
    public static NodeTypeSet TokenBitset_28;
    public static NodeTypeSet TokenBitset_29;
    public static NodeTypeSet TokenBitset_30;
    public static NodeTypeSet TokenBitset_31;
    public static NodeTypeSet TokenBitset_32;
    public static NodeTypeSet TokenBitset_33;
    public static NodeTypeSet TokenBitset_34;
    public static NodeTypeSet TokenBitset_35;
    public static NodeTypeSet TokenBitset_36;
    public static NodeTypeSet TokenBitset_37;
    public static NodeTypeSet TokenBitset_38;
    public static NodeTypeSet TokenBitset_39;
    public static NodeTypeSet TokenBitset_40;
    public static NodeTypeSet TokenBitset_41;
    public static NodeTypeSet TokenBitset_42;
    public static NodeTypeSet TokenBitset_43;
    public static NodeTypeSet TokenBitset_44;
    public static NodeTypeSet TokenBitset_45;
    public static NodeTypeSet TokenBitset_46;
    public static NodeTypeSet TokenBitset_47;
    public static NodeTypeSet TokenBitset_48;
    public static NodeTypeSet TokenBitset_49;
    public static NodeTypeSet TokenBitset_50;
    public static NodeTypeSet TokenBitset_51;
    public static NodeTypeSet TokenBitset_52;
    public static NodeTypeSet TokenBitset_53;
    public static NodeTypeSet TokenBitset_54;
    public static NodeTypeSet TokenBitset_55;
    public static NodeTypeSet TokenBitset_56;
    public static NodeTypeSet TokenBitset_57;
    public static NodeTypeSet TokenBitset_58;
    public static NodeTypeSet ElementBitset_0;
    public static NodeTypeSet ElementBitset_1;
    public static NodeTypeSet ElementBitset_2;
    public static NodeTypeSet ElementBitset_3;
    public static NodeTypeSet ElementBitset_4;
    public static NodeTypeSet ElementBitset_5;
    public static NodeTypeSet ElementBitset_6;
    public static NodeTypeSet ElementBitset_7;
    public static NodeTypeSet ElementBitset_8;
    public static NodeTypeSet ElementBitset_9;
    public static NodeTypeSet ElementBitset_10;
    public static NodeTypeSet ElementBitset_11;
    public static NodeTypeSet ElementBitset_12;
    public static NodeTypeSet ElementBitset_13;
    public static NodeTypeSet ElementBitset_14;
    public static NodeTypeSet ElementBitset_15;
    public static NodeTypeSet ElementBitset_16;
    public static NodeTypeSet ElementBitset_17;
    public static NodeTypeSet ElementBitset_18;
    public static NodeTypeSet ElementBitset_19;
    public static NodeTypeSet FIRST_namespaceOrTypeNameFull;
    public static NodeTypeSet FIRST_namespaceMemberDeclarationAux;
    public static NodeTypeSet FIRST_vBLiteralExpression;
    public static NodeTypeSet FIRST_castExpression;
    public static NodeTypeSet FIRST_simpleReferenceExpression;
    public static NodeTypeSet FIRST_vBXmlLiteralExpression;
    public static NodeTypeSet FIRST_interpolatedStringExpression;
    public static NodeTypeSet FIRST_statementAux;
    public static NodeTypeSet FIRST_queryOperator;
    public static NodeTypeSet FIRST_classBody;
    public static NodeTypeSet FIRST_regularTypeMemberDeclaration;
    public static NodeTypeSet FIRST_accessorDeclaration;
    public static NodeTypeSet FIRST_labelOrStatementAux;
    public static NodeTypeSet FIRST_localDeclarationStatement;
    public static NodeTypeSet FIRST_loopStatement;
    public static NodeTypeSet FIRST_assignmentOpSign;
    private static TokenBitsets();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Gen.VBParserGenerated : GeneratedParserBase`1<ILexer> {
    protected ParsingContext myCurrentContext;
    protected bool IsInFollow(TokenNodeType tokenType);
    protected virtual TreeElement Match(TokenNodeType tokenType);
    protected void Skip(CompositeElement parent);
    protected virtual void SkipErrorToken(CompositeElement parent);
    public abstract virtual void ParseOnErrorGotoLabelAux(CompositeElement result);
    protected virtual void ParseOnErrorGotoLabelAuxInternal(CompositeElement result);
    public virtual void ParseAccessModifier(CompositeElement result);
    public virtual TreeElement ParseAccessorDeclaration();
    protected virtual CompositeElement HandleErrorInAccessorDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseAccessorKeyword(CompositeElement result);
    public virtual TreeElement ParseAddHandlerStatement();
    protected virtual CompositeElement HandleErrorInAddHandlerStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAdditiveExpression();
    public virtual TreeElement ParseAddressOfExpression();
    protected virtual CompositeElement HandleErrorInAddressOfExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAggregateQueryOperator();
    protected virtual CompositeElement HandleErrorInAggregateQueryOperator(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseAggregatedRangeVariableDeclaration();
    protected virtual TreeElement ParseAggregatedRangeVariableDeclarationInternal();
    public virtual TreeElement ParseAggregatedRangeVariableDeclarationList();
    public virtual TreeElement ParseAliasClause();
    public virtual TreeElement ParseAnonymousArrayCreationExpression();
    protected virtual CompositeElement HandleErrorInAnonymousArrayCreationExpression(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseAnonymousMemberDeclaration();
    protected virtual TreeElement ParseAnonymousMemberDeclarationInternal();
    protected virtual CompositeElement HandleErrorInAnonymousMemberDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAnonymousObjectCreationExpression(TreeElement keyword);
    public virtual TreeElement ParseAnonymousObjectInitializer();
    protected virtual CompositeElement HandleErrorInAnonymousObjectInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseArgumentList();
    public virtual TreeElement ParseArrayBound();
    public virtual TreeElement ParseArrayCreationExpression(TreeElement keyword, TreeElement typeusage, TreeElement question);
    public virtual TreeElement ParseArrayModifier();
    protected virtual CompositeElement HandleErrorInArrayModifier(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseArrayModifiersList();
    public virtual void ParseAssignmentOpSign(CompositeElement result);
    public virtual TreeElement ParseAssignmentStatement(TreeElement expr);
    protected virtual CompositeElement HandleErrorInAssignmentStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAttribute();
    protected virtual CompositeElement HandleErrorInAttribute(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseAttributeList();
    protected virtual TreeElement ParseAttributeListInternal();
    protected virtual CompositeElement HandleErrorInAttributeList(CompositeElement result, SyntaxError error);
    public virtual void ParseAttributeSection(CompositeElement result);
    protected virtual CompositeElement HandleErrorInAttributeSection(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAwaitExpression();
    protected virtual CompositeElement HandleErrorInAwaitExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAwaitStatement();
    protected virtual CompositeElement HandleErrorInAwaitStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseBlock();
    protected virtual TreeElement ParseBlockInternal();
    protected virtual CompositeElement HandleErrorInBlock(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseBlockIfStatement(TreeElement ifKeyword, TreeElement expression);
    protected virtual CompositeElement HandleErrorInBlockIfStatement(CompositeElement result, SyntaxError error);
    [ParsingContextAttribute("0")]
public abstract virtual void ParseBody(CompositeElement result);
    [ParsingContextAttribute("0")]
protected virtual void ParseBodyInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInBody(CompositeElement result, SyntaxError error);
    public virtual void ParseBuiltInTypeName(CompositeElement result);
    public virtual TreeElement ParseCaseClause();
    public virtual TreeElement ParseCaseStatement();
    protected virtual CompositeElement HandleErrorInCaseStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCastExpression();
    public virtual void ParseCastTarget(CompositeElement result);
    public virtual TreeElement ParseCatchStatement();
    protected virtual CompositeElement HandleErrorInCatchStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCatchVariableDeclaration();
    protected virtual CompositeElement HandleErrorInCatchVariableDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseCatchVariableResource(CompositeElement result);
    public virtual TreeElement ParseCharsetModifier();
    public virtual TreeElement ParseClassBaseClause();
    public abstract virtual TreeElement ParseClassBody();
    protected virtual TreeElement ParseClassBodyInternal();
    protected virtual CompositeElement HandleErrorInClassBody(CompositeElement result, SyntaxError error);
    [ParsingContextAttribute("1")]
public virtual TreeElement ParseClassDeclaration(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInClassDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseCollectionElementInitializer();
    protected virtual CompositeElement HandleErrorInCollectionElementInitializer(CompositeElement result, SyntaxError error);
    public virtual void ParseComma(CompositeElement result);
    public virtual void ParseComparisonOperator(CompositeElement result);
    public virtual TreeElement ParseConcatenationExpression();
    public virtual TreeElement ParseConditionalAccessSign();
    public virtual TreeElement ParseConditionalExpression();
    protected virtual CompositeElement HandleErrorInConditionalExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseConstPreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInConstPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseConstantDeclaration();
    public virtual TreeElement ParseConstructorDeclaration(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInConstructorDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseContinueKind(CompositeElement result);
    public virtual TreeElement ParseContinueStatement();
    protected virtual CompositeElement HandleErrorInContinueStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseControlReference(TreeElement qualifier);
    public virtual TreeElement ParseConversionOperatorDeclaration(TreeElement attr, TreeElement mods, TreeElement op);
    protected virtual CompositeElement HandleErrorInConversionOperatorDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseCustomEventDeclarationHeaderAux(CompositeElement result, TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInCustomEventDeclarationHeaderAux(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseDeclarationTerminator(CompositeElement result);
    protected virtual void ParseDeclarationTerminatorInternal(CompositeElement result);
    public virtual TreeElement ParseDeclaredTypeUsage();
    [ParsingContextAttribute("2")]
public virtual TreeElement ParseDelegateDeclaration(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInDelegateDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseDictionaryAccessExpression(TreeElement expr);
    public virtual TreeElement ParseDisableWarningPreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInDisableWarningPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseDistinctQueryOperator();
    protected virtual CompositeElement HandleErrorInDistinctQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseDoLoopStatement();
    protected virtual CompositeElement HandleErrorInDoLoopStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseElseIfPreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInElseIfPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseElseIfStatement();
    protected virtual CompositeElement HandleErrorInElseIfStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseElsePreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInElsePreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseElseStatement();
    protected virtual CompositeElement HandleErrorInElseStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEmptyArgument();
    public virtual TreeElement ParseEnableWarningPreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInEnableWarningPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEndExternalSourcePreprocessorDirective(TreeElement sharp, TreeElement endKeyword);
    protected virtual CompositeElement HandleErrorInEndExternalSourcePreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEndIfPreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInEndIfPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEndRegionPreprocessorDirective(TreeElement sharp, TreeElement endKeyword);
    protected virtual CompositeElement HandleErrorInEndRegionPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEndStatement();
    public virtual TreeElement ParseEnumDeclaration(TreeElement attr, TreeElement mods);
    public virtual TreeElement ParseEnumMemberDeclaration();
    protected virtual CompositeElement HandleErrorInEnumMemberDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEraseStatement();
    protected virtual CompositeElement HandleErrorInEraseStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseErrorElement();
    public virtual TreeElement ParseErrorStatement();
    protected virtual CompositeElement HandleErrorInErrorStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseEventDeclaration(TreeElement attr, TreeElement mods);
    protected virtual TreeElement ParseEventDeclarationInternal(TreeElement attr, TreeElement mods);
    public virtual void ParseEventDeclarationBodyAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInEventDeclarationBodyAux(CompositeElement result, SyntaxError error);
    public virtual void ParseEventDeclarationHeaderAux(CompositeElement result, TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInEventDeclarationHeaderAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseEventSpecifier();
    public virtual void ParseExitKind(CompositeElement result);
    public virtual TreeElement ParseExitStatement();
    protected virtual CompositeElement HandleErrorInExitStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseExponentiationExpression();
    public virtual TreeElement ParseExpressionArgument();
    public abstract virtual TreeElement ParseExpressionRangeVariableDeclaration();
    protected virtual TreeElement ParseExpressionRangeVariableDeclarationInternal();
    public virtual TreeElement ParseExpressionRangeVariableDeclarationList();
    public virtual TreeElement ParseExpressionStatement();
    protected virtual CompositeElement HandleErrorInExpressionStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseExternalChecksumPreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInExternalChecksumPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseExternalMethodDeclaration(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInExternalMethodDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseExternalMethodDeclarationAux(CompositeElement result, TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInExternalMethodDeclarationAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseExternalSourcePreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInExternalSourcePreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual void ParseFakePreprocessorDirective(CompositeElement result);
    public virtual TreeElement ParseFinallyStatement();
    protected virtual CompositeElement HandleErrorInFinallyStatement(CompositeElement result, SyntaxError error);
    public virtual void ParseFloatingPointTypeName(CompositeElement result);
    public virtual TreeElement ParseForEachStatement(TreeElement forKeyword);
    protected virtual CompositeElement HandleErrorInForEachStatement(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseForLoopBodyAux(CompositeElement result);
    protected virtual void ParseForLoopBodyAuxInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInForLoopBodyAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseForStatement(TreeElement forKeyword);
    protected virtual CompositeElement HandleErrorInForStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseFromQueryOperator();
    protected virtual CompositeElement HandleErrorInFromQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseGetTypeExpression();
    protected virtual CompositeElement HandleErrorInGetTypeExpression(CompositeElement result, SyntaxError error);
    public virtual void ParseGetTypeExpressionTypeUsage(CompositeElement result);
    protected virtual CompositeElement HandleErrorInGetTypeExpressionTypeUsage(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseGetXmlNamespaceExpression();
    protected virtual CompositeElement HandleErrorInGetXmlNamespaceExpression(CompositeElement result, SyntaxError error);
    public virtual void ParseGetXmlNamespaceExpressionNamespace(CompositeElement result);
    protected virtual CompositeElement HandleErrorInGetXmlNamespaceExpressionNamespace(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseGotoStatement();
    protected virtual CompositeElement HandleErrorInGotoStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseGroupByQueryOperator(TreeElement keyword);
    protected virtual CompositeElement HandleErrorInGroupByQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseGroupJoinQueryOperator(TreeElement keyword);
    protected virtual CompositeElement HandleErrorInGroupJoinQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseHandlesClause();
    public virtual void ParseIdentifierModifier(CompositeElement result);
    public abstract virtual TreeElement ParseIdentifierOrKeyword();
    protected virtual TreeElement ParseIdentifierOrKeywordInternal();
    public virtual TreeElement ParseIfPreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInIfPreprocessorDirective(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseIfStatement(CompositeElement result);
    protected virtual void ParseIfStatementInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInIfStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseImplementsClause();
    public virtual void ParseImplicitLineContinuation(CompositeElement result);
    public virtual TreeElement ParseImportAliasClause();
    public abstract virtual TreeElement ParseImportClause();
    protected virtual TreeElement ParseImportClauseInternal();
    public virtual TreeElement ParseImportDirective();
    protected virtual CompositeElement HandleErrorInImportDirective(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseImportDirectivesSection();
    protected virtual TreeElement ParseImportDirectivesSectionInternal();
    public virtual TreeElement ParseImportNamespaceClause();
    public virtual TreeElement ParseImportXMLNamespaceClause();
    public virtual TreeElement ParseIndexExpression(TreeElement expr);
    public virtual TreeElement ParseInstanceExpression();
    public virtual TreeElement ParseIntegerDivisionExpression();
    public virtual void ParseIntegralTypeName(CompositeElement result);
    [ParsingContextAttribute("3")]
public virtual TreeElement ParseInterfaceDeclaration(TreeElement attr, TreeElement mods);
    public virtual TreeElement ParseInterfaceInheritsClause();
    public abstract virtual TreeElement ParseInterfaceMemberSpecifier();
    protected virtual TreeElement ParseInterfaceMemberSpecifierInternal();
    public virtual TreeElement ParseInterpolatedStringExpression();
    protected virtual CompositeElement HandleErrorInInterpolatedStringExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseInterpolatedStringInsert();
    protected virtual CompositeElement HandleErrorInInterpolatedStringInsert(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseIntoOfAggregateQueryOperator();
    protected virtual CompositeElement HandleErrorInIntoOfAggregateQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseInvocationStatement(TreeElement callKeyword, TreeElement expr);
    protected virtual CompositeElement HandleErrorInInvocationStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseIsExpression();
    public virtual TreeElement ParseIsNotExpression();
    public virtual TreeElement ParseJoinCollectionRangeVariableDeclaration();
    public virtual TreeElement ParseJoinCondition();
    protected virtual CompositeElement HandleErrorInJoinCondition(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseJoinQueryConditionsListFake();
    protected virtual CompositeElement HandleErrorInJoinQueryConditionsListFake(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseJoinQueryOperator();
    protected virtual CompositeElement HandleErrorInJoinQueryOperator(CompositeElement result, SyntaxError error);
    public virtual void ParseLBrace(CompositeElement result);
    public virtual void ParseLParenth(CompositeElement result);
    public virtual TreeElement ParseLabelDeclaration();
    public virtual TreeElement ParseLabelName();
    public abstract virtual void ParseLabelOrStatementAux(CompositeElement result);
    protected virtual void ParseLabelOrStatementAuxInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInLabelOrStatementAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLabelStatement();
    protected virtual CompositeElement HandleErrorInLabelStatement(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseLambdaBlock(CompositeElement result);
    protected virtual void ParseLambdaBlockInternal(CompositeElement result);
    public virtual TreeElement ParseLambdaExpression();
    public virtual TreeElement ParseLambdaFunctionExpression(TreeElement asyn, TreeElement iter);
    public virtual TreeElement ParseLambdaParameterDeclaration();
    public virtual TreeElement ParseLambdaSignature();
    protected virtual CompositeElement HandleErrorInLambdaSignature(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLambdaSubExpression(TreeElement asyn, TreeElement iter);
    [ParsingContextAttribute("4")]
public virtual void ParseLambdaSubStatement(CompositeElement result);
    protected virtual CompositeElement HandleErrorInLambdaSubStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLetQueryOperator();
    protected virtual CompositeElement HandleErrorInLetQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLibraryClause();
    public virtual TreeElement ParseLikeExpression();
    public virtual TreeElement ParseLineIfStatement(TreeElement ifKeyword, TreeElement expression);
    protected virtual CompositeElement HandleErrorInLineIfStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLineIfStatementBody();
    protected virtual CompositeElement HandleErrorInLineIfStatementBody(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseLineTerminators(CompositeElement result);
    protected virtual void ParseLineTerminatorsInternal(CompositeElement result);
    public virtual TreeElement ParseLocalDeclarationList();
    protected virtual CompositeElement HandleErrorInLocalDeclarationList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseLocalDeclarationStatement();
    public virtual TreeElement ParseLocalVariableDeclaration();
    public virtual TreeElement ParseLogicalAndExpression();
    public virtual TreeElement ParseLogicalNotExpression();
    public virtual TreeElement ParseLogicalOrExpression();
    public virtual TreeElement ParseLogicalXorExpression();
    public abstract virtual void ParseLoopControlVariable(CompositeElement result);
    protected virtual void ParseLoopControlVariableInternal(CompositeElement result);
    public virtual TreeElement ParseLoopControlVariableDeclaration();
    public virtual TreeElement ParseLoopStatement();
    public virtual TreeElement ParseMemberAccessExpression(TreeElement expr);
    protected virtual CompositeElement HandleErrorInMemberAccessExpression(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseMemberAccessExpressionError(TreeElement expr, TreeElement quest, TreeElement dot);
    protected virtual CompositeElement HandleErrorInMemberAccessExpressionError(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMemberInitializer();
    protected virtual CompositeElement HandleErrorInMemberInitializer(CompositeElement result, SyntaxError error);
    public virtual void ParseMemberInitializerList(CompositeElement result);
    protected virtual CompositeElement HandleErrorInMemberInitializerList(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseMethodDeclaration(TreeElement attr, TreeElement mods);
    protected virtual TreeElement ParseMethodDeclarationInternal(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInMethodDeclaration(CompositeElement result, SyntaxError error);
    public virtual void ParseMethodDeclarationHeaderAux(CompositeElement result, TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInMethodDeclarationHeaderAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMidAssignmentStatement();
    protected virtual CompositeElement HandleErrorInMidAssignmentStatement(CompositeElement result, SyntaxError error);
    public virtual void ParseModifier(CompositeElement result);
    public virtual TreeElement ParseModifiersList();
    [ParsingContextAttribute("5")]
public virtual TreeElement ParseModuleDeclaration(TreeElement attr, TreeElement mods);
    public virtual TreeElement ParseModulusExpression();
    public abstract virtual void ParseMultiArgumentCollectionElementInitializer(CompositeElement result);
    protected virtual void ParseMultiArgumentCollectionElementInitializerInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInMultiArgumentCollectionElementInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMultipleConstantDeclaration(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInMultipleConstantDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMultipleVariableDeclaration(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInMultipleVariableDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseMultiplicativeExpression();
    public abstract virtual void ParseNameWithTypeParameterAux(CompositeElement result);
    protected virtual void ParseNameWithTypeParameterAuxInternal(CompositeElement result);
    public abstract virtual void ParseNameWithTypeParameterOfMethodAux(CompositeElement result);
    protected virtual void ParseNameWithTypeParameterOfMethodAuxInternal(CompositeElement result);
    protected virtual CompositeElement HandleErrorInNameWithTypeParameterOfMethodAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseNamedArgument();
    protected virtual CompositeElement HandleErrorInNamedArgument(CompositeElement result, SyntaxError error);
    public virtual void ParseNamespaceMemberDeclarationAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInNamespaceMemberDeclarationAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseNamespaceMemberModifiersList();
    public virtual void ParseNamespaceOrTypeName(CompositeElement result, TreeElement id);
    public virtual void ParseNamespaceOrTypeNameFull(CompositeElement result);
    public virtual TreeElement ParseNamespacePrefixExpression();
    public abstract virtual TreeElement ParseNewExpression();
    protected virtual TreeElement ParseNewExpressionInternal();
    public virtual TreeElement ParseNextClause();
    public virtual void ParseNumericTypeName(CompositeElement result);
    public virtual TreeElement ParseObjectCollectionInitializer();
    protected virtual CompositeElement HandleErrorInObjectCollectionInitializer(CompositeElement result, SyntaxError error);
    public virtual void ParseObjectCollectionInitializerList(CompositeElement result);
    protected virtual CompositeElement HandleErrorInObjectCollectionInitializerList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseObjectCreationExpression(TreeElement keyword, TreeElement typeusage, TreeElement question);
    public abstract virtual void ParseObjectCreationExpressionInitializer(CompositeElement result);
    protected virtual void ParseObjectCreationExpressionInitializerInternal(CompositeElement result);
    public virtual TreeElement ParseObjectCreationInitializer();
    protected virtual CompositeElement HandleErrorInObjectCreationInitializer(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseOnErrorSpecialLabel();
    public virtual TreeElement ParseOnErrorStatement();
    protected virtual CompositeElement HandleErrorInOnErrorStatement(CompositeElement result, SyntaxError error);
    public virtual void ParseOperatorDeclarationAux(CompositeElement result, TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInOperatorDeclarationAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseOptionStatement();
    protected virtual CompositeElement HandleErrorInOptionStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseOptionStatementsSection();
    protected virtual TreeElement ParseOptionStatementsSectionInternal();
    public virtual TreeElement ParseOrderByQueryOperator();
    protected virtual CompositeElement HandleErrorInOrderByQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseOrderExpression();
    protected virtual CompositeElement HandleErrorInOrderExpression(CompositeElement result, SyntaxError error);
    public virtual void ParseOverloadOperatorSign(CompositeElement result);
    public virtual void ParseParameterModifier(CompositeElement result);
    public virtual TreeElement ParseParenthesizedExpression();
    public virtual TreeElement ParsePartitionQueryOperator();
    protected virtual CompositeElement HandleErrorInPartitionQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePositionalArgument();
    protected virtual CompositeElement HandleErrorInPositionalArgument(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePreprocessorDirective();
    protected virtual CompositeElement HandleErrorInPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePrimaryExpression();
    public virtual void ParsePrimitiveTypeName(CompositeElement result);
    public abstract virtual TreeElement ParsePropertyDeclaration(TreeElement attr, TreeElement mods);
    protected virtual TreeElement ParsePropertyDeclarationInternal(TreeElement attr, TreeElement mods);
    public virtual void ParsePropertyDeclarationBodyAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInPropertyDeclarationBodyAux(CompositeElement result, SyntaxError error);
    public virtual void ParsePropertyDeclarationHeaderAux(CompositeElement result, TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInPropertyDeclarationHeaderAux(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParsePropertyInitializer();
    protected virtual CompositeElement HandleErrorInPropertyInitializer(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseQualifiedNamespaceName();
    protected virtual TreeElement ParseQualifiedNamespaceNameInternal();
    public virtual TreeElement ParseQueryAggregatedParameterPlatform();
    protected virtual CompositeElement HandleErrorInQueryAggregatedParameterPlatform(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryCollectionRangeVariableDeclaration();
    public virtual TreeElement ParseQueryCollectionRangeVariableDeclarationList();
    public abstract virtual TreeElement ParseQueryConditionsList();
    protected virtual TreeElement ParseQueryConditionsListInternal();
    protected virtual CompositeElement HandleErrorInQueryConditionsList(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseQueryExpression();
    protected virtual TreeElement ParseQueryExpressionInternal();
    protected virtual CompositeElement HandleErrorInQueryExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryOperator();
    public virtual TreeElement ParseQueryParameter();
    protected virtual CompositeElement HandleErrorInQueryParameter(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseQueryParameterPlatform();
    protected virtual CompositeElement HandleErrorInQueryParameterPlatform(CompositeElement result, SyntaxError error);
    public virtual void ParseRBrace(CompositeElement result);
    public virtual void ParseRParenth(CompositeElement result);
    public virtual TreeElement ParseRaiseEventStatement();
    protected virtual CompositeElement HandleErrorInRaiseEventStatement(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseRedimClause();
    protected virtual TreeElement ParseRedimClauseInternal();
    protected virtual CompositeElement HandleErrorInRedimClause(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseRedimStatement();
    protected virtual CompositeElement HandleErrorInRedimStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseReferenceExpression(TreeElement expr, TreeElement quest, TreeElement dot);
    public abstract virtual TreeElement ParseReferenceName(TreeElement qualifier);
    protected virtual TreeElement ParseReferenceNameInternal(TreeElement qualifier);
    public virtual TreeElement ParseRegionPreprocessorDirective(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInRegionPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseRegularParameterDeclaration();
    public virtual TreeElement ParseRegularParameterList();
    protected virtual CompositeElement HandleErrorInRegularParameterList(CompositeElement result, SyntaxError error);
    public virtual void ParseRegularTypeMemberDeclaration(CompositeElement result);
    protected virtual CompositeElement HandleErrorInRegularTypeMemberDeclaration(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseRegularTypeMemberDeclarationAux(CompositeElement result, TreeElement attr, TreeElement mods);
    protected virtual void ParseRegularTypeMemberDeclarationAuxInternal(CompositeElement result, TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInRegularTypeMemberDeclarationAux(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseRegularTypeMemberDeclarationAuxError(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInRegularTypeMemberDeclarationAuxError(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseRelationalExpression();
    public virtual TreeElement ParseRemoveHandlerStatement();
    protected virtual CompositeElement HandleErrorInRemoveHandlerStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseResumeStatement();
    protected virtual CompositeElement HandleErrorInResumeStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseReturnAttributeList();
    protected virtual CompositeElement HandleErrorInReturnAttributeList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseReturnStatement();
    protected virtual CompositeElement HandleErrorInReturnStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseSelectQueryOperator();
    protected virtual CompositeElement HandleErrorInSelectQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseSelectStatement();
    protected virtual CompositeElement HandleErrorInSelectStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseShiftExpression();
    public virtual TreeElement ParseSignOperatorDeclaration(TreeElement attr, TreeElement mods, TreeElement op);
    protected virtual CompositeElement HandleErrorInSignOperatorDeclaration(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseSimpleControlReference();
    public abstract virtual TreeElement ParseSimpleReferenceExpression();
    public abstract virtual TreeElement ParseSimpleReferenceName();
    public virtual void ParseStatementAux(CompositeElement result);
    protected virtual CompositeElement HandleErrorInStatementAux(CompositeElement result, SyntaxError error);
    public abstract virtual void ParseStatementTerminator(CompositeElement result);
    protected virtual void ParseStatementTerminatorInternal(CompositeElement result);
    public virtual TreeElement ParseStopStatement();
    protected virtual CompositeElement HandleErrorInStopStatement(CompositeElement result, SyntaxError error);
    [ParsingContextAttribute("6")]
public virtual TreeElement ParseStructureDeclaration(TreeElement attr, TreeElement mods);
    public virtual TreeElement ParseSyncLockStatement();
    protected virtual CompositeElement HandleErrorInSyncLockStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseThrowStatement();
    protected virtual CompositeElement HandleErrorInThrowStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTryStatement();
    protected virtual CompositeElement HandleErrorInTryStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTupleComponent();
    protected virtual CompositeElement HandleErrorInTupleComponent(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTupleDeclaredTypeUsage();
    public virtual TreeElement ParseTupleExpression();
    public virtual TreeElement ParseTupleTypeComponent();
    public virtual TreeElement ParseTupleTypeUsage();
    public virtual TreeElement ParseTypeArgumentList();
    protected virtual CompositeElement HandleErrorInTypeArgumentList(CompositeElement result, SyntaxError error);
    public virtual void ParseTypeChar(CompositeElement result);
    public abstract virtual TreeElement ParseTypeDeclarationError(TreeElement attr, TreeElement mods);
    protected virtual CompositeElement HandleErrorInTypeDeclarationError(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeImplementsClause();
    public virtual TreeElement ParseTypeOfIsExpression();
    public virtual TreeElement ParseTypeParameterConstraint();
    public virtual TreeElement ParseTypeParameterConstraintList();
    public virtual TreeElement ParseTypeParameterDeclaration();
    public virtual TreeElement ParseTypeParameterOfMethodDeclaration();
    public virtual TreeElement ParseTypeParameterOfMethodList();
    protected virtual CompositeElement HandleErrorInTypeParameterOfMethodList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeParameterOfTypeDeclaration();
    public virtual TreeElement ParseTypeParameterOfTypeList();
    protected virtual CompositeElement HandleErrorInTypeParameterOfTypeList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseTypeUsage();
    public virtual TreeElement ParseUnaryNegationExpression();
    public abstract virtual TreeElement ParseUnknownPreprocessorDirective(TreeElement sharp);
    protected virtual TreeElement ParseUnknownPreprocessorDirectiveInternal(TreeElement sharp);
    protected virtual CompositeElement HandleErrorInUnknownPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseUserDeclaredTypeUsage();
    public virtual TreeElement ParseUserTypeUsage();
    public virtual TreeElement ParseUsingStatement();
    protected virtual CompositeElement HandleErrorInUsingStatement(CompositeElement result, SyntaxError error);
    public virtual void ParseUsingStatementDeclarationList(CompositeElement result);
    public abstract virtual void ParseUsingStatementResources(CompositeElement result);
    protected virtual void ParseUsingStatementResourcesInternal(CompositeElement result);
    public virtual TreeElement ParseUsingVariableDeclaration();
    protected virtual CompositeElement HandleErrorInUsingVariableDeclaration(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseVBArgument();
    protected virtual TreeElement ParseVBArgumentInternal();
    public virtual TreeElement ParseVBExpression();
    protected virtual CompositeElement HandleErrorInVBExpression(CompositeElement result, SyntaxError error);
    public virtual void ParseVBExpressionList(CompositeElement result);
    protected virtual CompositeElement HandleErrorInVBExpressionList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBFile();
    protected virtual CompositeElement HandleErrorInVBFile(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseVBIdentifier();
    protected virtual TreeElement ParseVBIdentifierInternal();
    public virtual TreeElement ParseVBLiteralExpression();
    public virtual TreeElement ParseVBNamespaceDeclaration();
    public virtual TreeElement ParseVBXmlAttribute();
    protected virtual CompositeElement HandleErrorInVBXmlAttribute(CompositeElement result, SyntaxError error);
    public virtual void ParseVBXmlAttributeAux(CompositeElement result);
    public virtual TreeElement ParseVBXmlCDataSection();
    protected virtual CompositeElement HandleErrorInVBXmlCDataSection(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBXmlComment();
    protected virtual CompositeElement HandleErrorInVBXmlComment(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBXmlDocument();
    protected virtual CompositeElement HandleErrorInVBXmlDocument(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseVBXmlElement();
    protected virtual TreeElement ParseVBXmlElementInternal();
    protected virtual CompositeElement HandleErrorInVBXmlElement(CompositeElement result, SyntaxError error);
    public virtual void ParseVBXmlElementContent(CompositeElement result);
    protected virtual CompositeElement HandleErrorInVBXmlElementContent(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBXmlElementFooter();
    protected virtual CompositeElement HandleErrorInVBXmlElementFooter(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBXmlElementHeader();
    protected virtual CompositeElement HandleErrorInVBXmlElementHeader(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBXmlEmbeddedExpression();
    protected virtual CompositeElement HandleErrorInVBXmlEmbeddedExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBXmlLiteralExpression();
    protected virtual CompositeElement HandleErrorInVBXmlLiteralExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBXmlMemberAccessExpression(TreeElement expr, TreeElement quest, TreeElement dot);
    protected virtual CompositeElement HandleErrorInVBXmlMemberAccessExpression(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVBXmlMisc();
    protected virtual CompositeElement HandleErrorInVBXmlMisc(CompositeElement result, SyntaxError error);
    public abstract virtual TreeElement ParseVBXmlProcessingInstruction();
    protected virtual TreeElement ParseVBXmlProcessingInstructionInternal();
    protected virtual CompositeElement HandleErrorInVBXmlProcessingInstruction(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseVariableDeclaration();
    public virtual TreeElement ParseVariableDeclarationList();
    public virtual TreeElement ParseWarningPreprocessorDirective(TreeElement sharp);
    public virtual TreeElement ParseWhereQueryOperator();
    protected virtual CompositeElement HandleErrorInWhereQueryOperator(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseWhileStatement();
    protected virtual CompositeElement HandleErrorInWhileStatement(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseWhileUntilCondition();
    public virtual TreeElement ParseWithStatement();
    protected virtual CompositeElement HandleErrorInWithStatement(CompositeElement result, SyntaxError error);
    public virtual void ParseXmlSpace(CompositeElement result);
    public virtual void ParseXmlText(CompositeElement result);
    public virtual TreeElement ParseYieldStatement();
    protected virtual CompositeElement HandleErrorInYieldStatement(CompositeElement result, SyntaxError error);
    protected abstract virtual TreeElement MatchAggregateKeyword();
    protected abstract virtual bool ExpectAggregateKeyword();
    protected abstract virtual TreeElement MatchKeySpecifier();
    protected abstract virtual bool ExpectKeySpecifier();
    protected abstract virtual TreeElement MatchvBAttributeTargert();
    protected abstract virtual bool ExpectvBAttributeTargert();
    protected abstract virtual TreeElement MatchAwaitKeyword();
    protected abstract virtual bool ExpectAwaitKeyword();
    protected abstract virtual TreeElement MatchAnsiKeyword();
    protected abstract virtual bool ExpectAnsiKeyword();
    protected abstract virtual TreeElement MatchUnicodeKeyword();
    protected abstract virtual bool ExpectUnicodeKeyword();
    protected abstract virtual TreeElement MatchAutoKeyword();
    protected abstract virtual bool ExpectAutoKeyword();
    protected abstract virtual TreeElement MatchisCustomKeyword();
    protected abstract virtual bool ExpectisCustomKeyword();
    protected abstract virtual TreeElement MatchDisablePPDirective();
    protected abstract virtual bool ExpectDisablePPDirective();
    protected abstract virtual TreeElement MatchWarningPPDirective();
    protected abstract virtual bool ExpectWarningPPDirective();
    protected abstract virtual TreeElement MatchDistinctKeyword();
    protected abstract virtual bool ExpectDistinctKeyword();
    protected abstract virtual TreeElement MatchEnablePPDirective();
    protected abstract virtual bool ExpectEnablePPDirective();
    protected abstract virtual TreeElement MatchexternalSourcePPDirective();
    protected abstract virtual bool ExpectexternalSourcePPDirective();
    protected abstract virtual TreeElement MatchregionPPDirective();
    protected abstract virtual bool ExpectregionPPDirective();
    protected abstract virtual TreeElement MatchexternalChecksumPPDirective();
    protected abstract virtual bool ExpectexternalChecksumPPDirective();
    protected abstract virtual TreeElement MatchFromKeyword();
    protected abstract virtual bool ExpectFromKeyword();
    protected abstract virtual TreeElement MatchByKeyword();
    protected abstract virtual bool ExpectByKeyword();
    protected abstract virtual TreeElement MatchIntoKeyword();
    protected abstract virtual bool ExpectIntoKeyword();
    protected abstract virtual TreeElement MatchImplicitLineContinuation();
    protected abstract virtual bool ExpectImplicitLineContinuation();
    protected abstract virtual TreeElement MatchEqualsKeyword();
    protected abstract virtual bool ExpectEqualsKeyword();
    protected abstract virtual TreeElement MatchJoinKeyword();
    protected abstract virtual bool ExpectJoinKeyword();
    protected abstract virtual TreeElement MatchAsyncKeyword();
    protected abstract virtual bool ExpectAsyncKeyword();
    protected abstract virtual TreeElement MatchIteratorKeyword();
    protected abstract virtual bool ExpectIteratorKeyword();
    protected abstract virtual TreeElement MatchMidKeyword();
    protected abstract virtual bool ExpectMidKeyword();
    protected abstract virtual TreeElement MatchOrderKeyword();
    protected abstract virtual bool ExpectOrderKeyword();
    protected abstract virtual TreeElement MatchAscendingKeyword();
    protected abstract virtual bool ExpectAscendingKeyword();
    protected abstract virtual TreeElement MatchDescendingKeyword();
    protected abstract virtual bool ExpectDescendingKeyword();
    protected abstract virtual TreeElement MatchIsTrueKeyword();
    protected abstract virtual bool ExpectIsTrueKeyword();
    protected abstract virtual TreeElement MatchIsFalseKeyword();
    protected abstract virtual bool ExpectIsFalseKeyword();
    protected abstract virtual TreeElement MatchTakeKeyword();
    protected abstract virtual bool ExpectTakeKeyword();
    protected abstract virtual TreeElement MatchSkipKeyword();
    protected abstract virtual bool ExpectSkipKeyword();
    protected abstract virtual TreeElement MatchGroupKeyword();
    protected abstract virtual bool ExpectGroupKeyword();
    protected abstract virtual TreeElement MatchisPreserveKeyword();
    protected abstract virtual bool ExpectisPreserveKeyword();
    protected abstract virtual TreeElement MatchOutKeyword();
    protected abstract virtual bool ExpectOutKeyword();
    protected abstract virtual TreeElement MatchWhereKeyword();
    protected abstract virtual bool ExpectWhereKeyword();
    protected abstract virtual TreeElement MatchUntilKeyword();
    protected abstract virtual bool ExpectUntilKeyword();
    protected abstract virtual TreeElement MatchYieldKeyword();
    protected abstract virtual bool ExpectYieldKeyword();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.GeneratedCode.VBGeneratedCodeRegionChecker : GeneratedCodeRegionChecker {
    public virtual IGeneratedCodeRegionDetector CreateDetector(IContextBoundSettingsStore settingsStore);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.VB.GeneratedCode.VBGeneratedCodeRegionDetector : object {
    private HashSet`1<string> mySkipRegions;
    private Stack`1<bool> myRegions;
    private Nullable`1<bool> myInGeneratedCode;
    public bool InGeneratedCode { get; }
    public VBGeneratedCodeRegionDetector(IContextBoundSettingsStore settingsStore);
    public sealed virtual bool get_InGeneratedCode();
    public sealed virtual void Process(ITreeNode node);
    public sealed virtual void Reset();
}
public interface JetBrains.ReSharper.Psi.VB.IAnonymousMethod {
}
public interface JetBrains.ReSharper.Psi.VB.ILambdaParameter {
    public bool IsImplicitlyTyped { get; }
    public bool IsExplicitlyTyped { get; }
    public abstract virtual bool get_IsImplicitlyTyped();
    public abstract virtual bool get_IsExplicitlyTyped();
}
[ZoneDefinitionAttribute]
public interface JetBrains.ReSharper.Psi.VB.ILanguageVBZone {
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.ClassPart : VBClassLikePart`1<IClassDeclaration> {
    private MemberPresenceFlag myMembersMask;
    private string myInheritsTypeName;
    private String[] myImplementsTypeNames;
    protected VBSerializationTag VBSerializationTag { get; }
    public ClassPart(IClassDeclaration declaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    public ClassPart(IReader reader);
    protected virtual void Write(IWriter writer);
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    protected virtual VBSerializationTag get_VBSerializationTag();
    public virtual IEnumerable`1<ITypeMember> GetTypeMembers();
    public virtual IDeclaredType GetBaseClassType();
    public virtual TypeElement CreateTypeElement();
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.DeclaredNamespacePart : NamespacePart {
    private string myNamespaceQualifier;
    protected byte SerializationTag { get; }
    public DeclaredNamespacePart(IVBNamespaceDeclaration namespaceDeclaration, ICacheBuilder cacheBuilder);
    public DeclaredNamespacePart(IReader reader);
    protected virtual void Write(IWriter writer);
    protected virtual ICachedDeclaration2 FindDeclaration(IFile file, ICachedDeclaration2 candidateDeclaration);
    public virtual string ToString();
    protected virtual byte get_SerializationTag();
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.DelegatePart : VBDeclarationTypePart`1<IDelegateDeclaration> {
    protected VBSerializationTag VBSerializationTag { get; }
    public IParameter[] Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public DelegatePart(IDelegateDeclaration declaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    public DelegatePart(IReader reader);
    protected virtual VBSerializationTag get_VBSerializationTag();
    public sealed virtual IParameter[] get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public virtual TypeElement CreateTypeElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.EnumPart : VBDeclarationTypePart`1<IEnumDeclaration> {
    protected VBSerializationTag VBSerializationTag { get; }
    public IEnumerable`1<IField> Fields { get; }
    public EnumPart(IEnumDeclaration declaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    public EnumPart(IReader reader);
    protected virtual VBSerializationTag get_VBSerializationTag();
    public sealed virtual IType GetUnderlyingType();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Cache2.EnumPart/<get_Fields>d__6")]
public sealed virtual IEnumerable`1<IField> get_Fields();
    public virtual TypeElement CreateTypeElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.EventHandlerDelegatePart : VBTypePart`1<IVBTypeDeclaration> {
    private TreeOffset myEventDeclarationOffset;
    private WeakReference myEventDeclaration;
    public String[] ExtendsListShortNames { get; }
    public bool CanBePartial { get; }
    [CanBeNullAttribute]
public IEventDeclaration EventDeclaration { get; }
    public IParameter[] Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    protected VBSerializationTag VBSerializationTag { get; }
    public EventHandlerDelegatePart(IEventDeclaration eventDeclaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    public EventHandlerDelegatePart(IReader reader);
    public virtual String[] get_ExtendsListShortNames();
    public virtual bool get_CanBePartial();
    private static MemberDecoration GetDecoration(IEventDeclaration declaration);
    public IEventDeclaration get_EventDeclaration();
    public sealed virtual IParameter[] get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    protected virtual VBSerializationTag get_VBSerializationTag();
    public virtual TypeElement CreateTypeElement();
    protected virtual void Write(IWriter writer);
    public virtual IEnumerable`1<IType> GetTypeParameterSuperTypes(int index);
    public virtual TypeParameterConstraintFlags GetTypeParameterConstraintFlags(int index);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.InterfacePart : VBClassLikePart`1<IInterfaceDeclaration> {
    private String[] myInheritsTypeNames;
    private MemberPresenceFlag myMembersMask;
    protected VBSerializationTag VBSerializationTag { get; }
    public InterfacePart(IInterfaceDeclaration declaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    public InterfacePart(IReader reader);
    protected virtual void Write(IWriter writer);
    protected virtual VBSerializationTag get_VBSerializationTag();
    public virtual TypeElement CreateTypeElement();
    public virtual IDeclaredType GetBaseClassType();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
public interface JetBrains.ReSharper.Psi.VB.Impl.Cache2.IVBClassLikePart {
    public String[] PartialMethodNames { get; }
    public abstract virtual String[] get_PartialMethodNames();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.ModulePart : VBClassLikePart`1<IModuleDeclaration> {
    private ExtensionMemberInfo[] myExtensionMethodInfos;
    public ExtensionMemberInfo[] ExtensionMemberInfos { get; }
    protected VBSerializationTag VBSerializationTag { get; }
    public ModulePart(IModuleDeclaration declaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    public ModulePart(IReader reader);
    protected virtual void Write(IWriter writer);
    public virtual ExtensionMemberInfo[] get_ExtensionMemberInfos();
    public virtual HybridCollection`1<ITypeMember> FindExtensionMethod(ExtensionMemberInfo info);
    public virtual IDeclaredType GetBaseClassType();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    protected virtual VBSerializationTag get_VBSerializationTag();
    public virtual TypeElement CreateTypeElement();
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.QualifiedNamespacePart : NamespacePart {
    protected byte SerializationTag { get; }
    public QualifiedNamespacePart(TreeOffset offset, string shortName);
    public QualifiedNamespacePart(IReader reader);
    public virtual IDeclaration GetDeclaration();
    public virtual string ToString();
    protected virtual byte get_SerializationTag();
    protected virtual ICachedDeclaration2 FindDeclaration(IFile file, ICachedDeclaration2 candidateDeclaration);
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.StructurePart : VBClassLikePart`1<IStructureDeclaration> {
    private MemberPresenceFlag myMembersMask;
    private String[] myImplementsTypeNames;
    private int myCloneableMemberCount;
    public bool IsReadonly { get; }
    public bool IsByRefLike { get; }
    public int CloneableMemberCount { get; }
    protected VBSerializationTag VBSerializationTag { get; }
    public StructurePart(IStructureDeclaration declaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    public StructurePart(IReader reader);
    protected virtual void Write(IWriter writer);
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsByRefLike();
    public sealed virtual int get_CloneableMemberCount();
    public virtual IDeclaredType GetBaseClassType();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    protected virtual VBSerializationTag get_VBSerializationTag();
    public virtual TypeElement CreateTypeElement();
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
    private static int CountCloneableMembers(IStructureDeclaration declaration);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBAttributesProvider : object {
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IFile ifile);
    public sealed virtual ITreeNode GetAttribute(IAttributeInstance attribute);
    internal static IList`1<IAttributeInstance> GetAttributeInstances0(IFile ifile);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBCacheProvider : object {
    [CompilerGeneratedAttribute]
private VBLanguage <vbLanguage>P;
    [CompilerGeneratedAttribute]
private ILogger <logger>P;
    private static NodeType[] SPECIAL_NODE_TYPES;
    public string TokenCacheUniqueId { get; }
    public string BufferCacheUniqueId { get; }
    public string TreeNodeCacheUniqueId { get; }
    public int NodeTypeCommonShift { get; }
    public VBCacheProvider(VBLanguage vbLanguage, ILogger logger);
    private static VBCacheProvider();
    public sealed virtual void BuildCache(IFile file, ICacheBuilder builder);
    public sealed virtual void BuildCache(ISandBox sandBox, ICacheBuilder builder);
    public sealed virtual bool NeedCacheUpdate(ITreeNode elementContainingChanges, PsiChangedElementType type);
    public sealed virtual bool IsCaseSensitive(IPsiModule module);
    public sealed virtual IEnumerable`1<IPsiSourceFile> GetAffectedOnPsiModulePropertiesChange(IPsiModule module);
    public sealed virtual string get_TokenCacheUniqueId();
    public sealed virtual string get_BufferCacheUniqueId();
    public sealed virtual string get_TreeNodeCacheUniqueId();
    public sealed virtual bool IsShrinkableTreeNode(int childNodeTypeIndex);
    public sealed virtual NodeType GetNodeType(int index);
    public sealed virtual Dictionary`2<int, TokenNodeType> GetIndexToTokenNodeTypeDictionary();
    public sealed virtual Dictionary`2<int, NodeType> GetIndexToNodeTypeDictionary();
    public sealed virtual NodeTypeDictionary`1<int> GetFixedTokenLengthsDictionary();
    public sealed virtual int get_NodeTypeCommonShift();
    public sealed virtual bool IsCacheableInClosedForm(IChameleonNode node);
    public sealed virtual TreeElement CreateClosedChameleonNode(NodeType nodeType, int textLength);
    public sealed virtual TreeElement CreateOpenedChameleonNode(NodeType nodeType);
    public sealed virtual void SerializeMetadata(IFile file, UnsafeWriter bufferWriter);
    public sealed virtual void RestoreMetadata(IFile file, UnsafeReader bufferReader);
    public sealed virtual bool IsInternableToken(TokenNodeType tokenNodeType);
    public sealed virtual Part ReadPart(byte tag, IReader reader);
    public sealed virtual ProjectFilePart LoadProjectFilePart(IPsiSourceFile sourceFile, ProjectFilePartsTree tree, IReader reader);
    internal static bool Matches(ExtensionMemberInfo info, IMethodDeclaration declaration);
    private static int CalcExtensionMethodHash(IMethodDeclaration declaration);
    [CanBeNullAttribute]
public static Nullable`1<ExtensionMemberInfo> CalculateExtensionMethodInfo(IMethodDeclaration methodDeclaration, Dictionary`2<string, string> aliasTable, TypePart owner);
    [NotNullAttribute]
private static CandidateType CalculateCandidateType(IRegularParameterDeclaration node, ITypeParameterOfMethodList list, Dictionary`2<string, string> aliasTable);
    private static IRegularParameterDeclaration GetThisParameter(IMethodDeclaration declaration);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBClassLikePart`1 : VBTypePart`1<TDeclaration> {
    private String[] myExtendsListNames;
    private String[] myPartialMethodNames;
    public String[] PartialMethodNames { get; }
    public String[] ExtendsListShortNames { get; }
    public bool CanBePartial { get; }
    protected VBClassLikePart`1(TDeclaration declaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    protected VBClassLikePart`1(IReader reader);
    protected virtual void Write(IWriter writer);
    public sealed virtual String[] get_PartialMethodNames();
    public virtual String[] get_ExtendsListShortNames();
    public virtual bool get_CanBePartial();
    public abstract virtual IDeclaredType GetBaseClassType();
    public abstract virtual MemberPresenceFlag GetMemberPresenceFlag();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBClassLikePart`1/<GetTypeMembers>d__13")]
public virtual IEnumerable`1<ITypeMember> GetTypeMembers();
    public sealed virtual IEnumerable`1<IDeclaredType> GetSuperTypes();
    protected static MemberPresenceFlag InvestigateMembers(IClassLikeDeclaration declaration, bool isStruct);
    private static bool CheckTypeIsNullOrOfGivenType(ITypeUsage typeUsage, IClrTypeName clrName);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBDeclarationTypePart`1 : VBTypePart`1<TDeclaration> {
    public String[] ExtendsListShortNames { get; }
    public bool CanBePartial { get; }
    protected VBDeclarationTypePart`1(TDeclaration declaration, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    protected VBDeclarationTypePart`1(IReader reader);
    public virtual String[] get_ExtendsListShortNames();
    public virtual bool get_CanBePartial();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBEventHandlerDelegate : Delegate {
    private EventHandlerDelegatePart Part { get; }
    [CanBeNullAttribute]
public IEvent Event { get; }
    public VBEventHandlerDelegate(EventHandlerDelegatePart part);
    private EventHandlerDelegatePart get_Part();
    public IEvent get_Event();
    public virtual string ToString();
    protected virtual bool AcceptsPart(TypePart part);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBInternalsVisibleToProvider : object {
    private static string ShortName;
    public sealed virtual IReadOnlyList`1<string> GetInternalsVisibleToArguments(IFile file);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBModule : Class {
    protected MemberDecoration Modifiers { get; }
    public VBModule(ModulePart part);
    public virtual string ToString();
    public virtual DeclaredElementType GetElementType();
    [NotNullAttribute]
public sealed virtual IDeclaredType GetBaseClassType();
    protected virtual MemberDecoration get_Modifiers();
    protected virtual LocalList`1<IDeclaredType> CalcSuperTypes();
    protected virtual bool AcceptsPart(TypePart part);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBProjectFilePart : ProjectFilePart {
    private Hash myImportedNamespacesHash;
    private string myDefaultNamespacePropertyValue;
    private String[] myAttributeNames;
    private String[] myImports;
    public Hash ImportedNamespacesHash { get; }
    public string DefaultNamespacePropertyValue { get; }
    public String[] AttributeClassNames { get; }
    public VBProjectFilePart(IVBFile file, Dictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    public VBProjectFilePart(IPsiSourceFile sourceFile, IReader reader);
    protected virtual void Write(IWriter writer);
    public Hash get_ImportedNamespacesHash();
    public string get_DefaultNamespacePropertyValue();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName);
    public virtual String[] get_AttributeClassNames();
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
internal enum JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBSerializationTag : Enum {
    public byte value__;
    public static VBSerializationTag QUALIFIED_NAMESPACE_PART;
    public static VBSerializationTag DECLARED_NAMESPACE_PART;
    public static VBSerializationTag CLASS_PART;
    public static VBSerializationTag STRUCT_PART;
    public static VBSerializationTag ENUM_PART;
    public static VBSerializationTag DELEGATE_PART;
    public static VBSerializationTag INTERFACE_PART;
    public static VBSerializationTag MODULE_PART;
    public static VBSerializationTag EVENT_HANDLER_DELEGATE_PART;
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Cache2.VBTypePart`1 : TypePartImplBase`1<TDeclaration> {
    private MemberDecoration myDecoration;
    private String[] myTypeParameterNames;
    private TypeParameterVariance[] myTypeParameterVariances;
    private String[] myAttributeClassNames;
    protected VBSerializationTag VBSerializationTag { get; }
    public MemberDecoration Modifiers { get; }
    public String[] AttributeClassNames { get; }
    protected byte SerializationTag { get; }
    protected VBTypePart`1(TDeclaration declaration, string shortName, int typeParametersCount, MemberDecoration memberDecoration, IDictionary`2<string, string> aliasTable, ICacheBuilder cacheBuilder);
    protected VBTypePart`1(IReader reader);
    public virtual string GetTypeParameterName(int index);
    public virtual TypeParameterVariance GetTypeParameterVariance(int index);
    public virtual IEnumerable`1<IType> GetTypeParameterSuperTypes(int index);
    public virtual bool IsNullableContextEnabledForTypeParameter(int index);
    private static FrugalLocalHashSet`1<string> BuildAttributeNames(IDictionary`2<string, string> aliasTable, TDeclaration declaration);
    protected virtual void AssignDeclaredElement(ICachedDeclaration2 declaration);
    protected virtual void Write(IWriter writer);
    protected abstract virtual VBSerializationTag get_VBSerializationTag();
    public virtual MemberDecoration get_Modifiers();
    public virtual String[] get_AttributeClassNames();
    public virtual IDeclaration GetTypeParameterDeclaration(int index);
    protected sealed virtual byte get_SerializationTag();
    public virtual string ToString();
    protected virtual ICachedDeclaration2 FindDeclaration(IFile file, ICachedDeclaration2 candidateDeclaration);
    protected virtual TDeclaration GetDeclaration();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName);
    public virtual bool HasAttributeInstance(IClrTypeName clrTypeName);
    public virtual IList`1<IAttributeInstance> GetTypeParameterAttributeInstances(int index, IClrTypeName typeName);
    public virtual bool HasTypeParameterAttributeInstance(int index, IClrTypeName typeName);
    public virtual TypeParameterConstraintFlags GetTypeParameterConstraintFlags(int index);
    private static ITypeParameterDeclaration GetTypeParameterDeclaration(ITypeParameterOfTypeOwnerDeclaration owner, int index);
    protected void BuildTypeParametersStub(StringBuilder text, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
public class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.Formatting.DummyVBCustomFormattingInfoProvider : object {
    public static IVBCustomFormattingInfoProvider Instance;
    private static DummyVBCustomFormattingInfoProvider();
    public sealed virtual SpaceType VisitImportAliasClause(IImportAliasClause clause, FormattingStageContext context);
    public sealed virtual FmtSettingsClassic`1<VBFormatSettingsKey> AdjustFormattingSettings(FmtSettingsClassic`1<VBFormatSettingsKey> settings, ISettingsOptimization settingsOptimization);
}
public interface JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.Formatting.IVBCustomFormattingInfoProvider {
    public abstract virtual SpaceType VisitImportAliasClause(IImportAliasClause clause, FormattingStageContext context);
    public abstract virtual FmtSettingsClassic`1<VBFormatSettingsKey> AdjustFormattingSettings(FmtSettingsClassic`1<VBFormatSettingsKey> settings, ISettingsOptimization settingsOptimization);
}
public enum JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.Formatting.SpaceType : Enum {
    public int value__;
    public static SpaceType Default;
    public static SpaceType NoSpace;
    public static SpaceType Horizontal;
    public static SpaceType Vertical;
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.Formatting.VBFormattingStage : object {
    private VBCodeFormattingContext myContext;
    private FormattingVisitor myFormattingVisitor;
    private VBCodeFormatter myFormatter;
    public VBCodeFormattingContext Context { get; }
    public VBFormattingStage(VBCodeFormattingContext context, FmtSettingsClassic`1<VBFormatSettingsKey> settings, VBFormatProfile profile);
    public VBCodeFormattingContext get_Context();
    public static void DoFormat(FormattingRange fmtRange, VBCodeFormattingContext context, FmtSettingsClassic`1<VBFormatSettingsKey> settings, VBFormatProfile profile, IProgressIndicator progress);
    private IEnumerable`1<VBWhitespace> CalcSpaces(FormattingStageContext context);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.Indenting.VBIndentingStage : object {
    private VBCodeFormatter myVBCodeFormatter;
    private IndentCache`1<ITreeNode> myIndentCache;
    private IndentVisitor myIndentVisitor;
    private CodeFormattingContext myFormattingContext;
    private FmtSettingsClassic`1<VBFormatSettingsKey> mySettings;
    public VBIndentingStage(CodeFormattingContext context, FmtSettingsClassic`1<VBFormatSettingsKey> settings);
    public static void DoIndent(FormattingRange indentRange, CodeFormattingContext context, FmtSettingsClassic`1<VBFormatSettingsKey> settings, IProgressIndicator progress);
    public void DoIndent(FormattingRange range);
    private string GetCustomIndent(ITreeNode node, CustomIndentType indentType, FmtSettingsClassic`1<VBFormatSettingsKey> settings);
    private string GetIndent(FormattingStageContext context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBCodeFormatter : CodeFormatterBase`1<VBFormatSettingsKey> {
    private Dictionary`2<CodeFormatProfile, VBFormatProfile> myFormatProfileTable;
    private NodeTypeSet mySetWithLineTerminator;
    private static NodeTypeSet LineTerminators;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICustomIndentHandler> <CustomIndentHandlers>k__BackingField;
    [NotNullAttribute]
internal IEnumerable`1<ICustomIndentHandler> CustomIndentHandlers { get; }
    public bool SupportsWrapping { get; }
    public VBCodeFormatter(Lifetime lifetime, VBLanguage language, IEnumerable`1<ICustomIndentHandler> customIdnentHandlers, CodeFormatterRequirements requirements);
    private static VBCodeFormatter();
    [CompilerGeneratedAttribute]
internal IEnumerable`1<ICustomIndentHandler> get_CustomIndentHandlers();
    public virtual bool IsNewLine(ITreeNode ws);
    public virtual bool get_SupportsWrapping();
    protected virtual bool IsWhitespaceTokenForFindFormattingRange(ITokenNode token);
    public virtual ITreeNode CreateSpace(string indent, NodeType replacedOrLeftSiblingType);
    public virtual ITreeNode CreateSpace();
    public virtual ITreeNode CreateNewLine(LineEnding lineEnding, NodeType lineBreakType);
    protected virtual bool IsFormatNextSpaces(CodeFormatProfile profile);
    protected virtual CodeFormattingContext CreateFormatterContext(AdditionalFormatterParameters parameters, ICustomFormatterInfoProvider provider, int tabWidth, SingleLangChangeAccu changeAccu, FormatTask[] formatTasks);
    public virtual ITreeRange Format(ITreeNode firstElement, ITreeNode lastElement, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    private static bool HasWhiteSpaceBefore(ITreeNode node);
    public virtual void FormatInsertedNodes(ITreeNode nodeFirst, ITreeNode nodeLast, bool formatSurround, bool indentSurround);
    public virtual ITreeRange FormatInsertedRange(ITreeNode nodeFirst, ITreeNode nodeLast, ITreeRange origin);
    private static bool IsWhiteSpace(ITreeNode node, NodeTypeSet set);
    public virtual void FormatDeletedNodes(ITreeNode parent, ITreeNode prevNode, ITreeNode nextNode);
    public sealed virtual void FormatDocComment(IDocCommentBlock docCommentBlock);
    private static void RemoveExtraLineTerminatorsOnTreeNodeDeleting(ITreeNode parent, ITreeNode& prevNode, ITreeNode& nextNode, NodeTypeSet set);
    public virtual void FormatReplacedNode(ITreeNode oldNode, ITreeNode newNode);
    public virtual void FormatReplacedRange(ITreeNode first, ITreeNode last, ITreeRange oldNodes);
    public virtual MinimalSeparatorType GetMinimalSeparatorByNodeTypes(TokenNodeType leftTokenType, TokenNodeType rightTokenType);
    [CompilerGeneratedAttribute]
private bool <FormatInsertedRange>b__19_0(ITokenNode token);
}
public class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBCodeFormattingContext : CodeFormattingContext {
    private IVBCustomFormattingInfoProvider myCustomFormattingInfoProvider;
    [NotNullAttribute]
public IVBCustomFormattingInfoProvider CustomFormattingInfoProvider { get; }
    public VBCodeFormattingContext(ICodeFormatterImpl codeFormatter, IFormatterDebugInfoLogger debugInfoLogger, AdditionalFormatterParameters parameters, int tabWidth, FormatTask[] formatTasks);
    public IVBCustomFormattingInfoProvider get_CustomFormattingInfoProvider();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBFormatterImplHelper : object {
    public static ITokenNode CreateSpace();
    public static ITokenNode CreateSpace(string spaceText);
    public static ITokenNode CreateLineContinuation(LineEnding lineEnding);
    public static ITokenNode CreateImplicitLineContinuation(LineEnding lineEnding);
    public static ITokenNode CreateNewLine(LineEnding lineEnding);
    public static void ReplaceSpaces(ITreeNode leftNode, ITreeNode rightNode, IEnumerable`1<VBWhitespace> wsTexts, VBCodeFormattingContext context, FmtSettingsClassic`1<VBFormatSettingsKey> settings);
    [ExtensionAttribute]
public static bool IsMultiline(ITreeNode node);
    [ExtensionAttribute]
public static bool IsWhitespace(ITreeNode node, NodeTypeSet set);
    [ExtensionAttribute]
public static bool HasWhitespaceBefore(ITreeNode node);
    [ExtensionAttribute]
public static int CalcLineContinuationsTo(ITreeNode fromNode, ITreeNode toNode);
    [ExtensionAttribute]
public static int CalcLineTerminatorsTo(ITreeNode fromNode, ITreeNode toNode);
    [ExtensionAttribute]
public static int CalcXmlNewLinesTo(ITreeNode fromNode, ITreeNode toNode);
    [ExtensionAttribute]
public static int CalcLineContinuations(FormattingStageContext context);
    [ExtensionAttribute]
public static int CalcLineTerminators(FormattingStageContext context);
    [ExtensionAttribute]
public static int CalcXmlNewLines(FormattingStageContext context);
    [ExtensionAttribute]
public static int CalcLineTerminatorsBefore(ITreeNode node);
    [ExtensionAttribute]
public static int CalcLineTerminatorsAfter(ITreeNode node, ITreeNode& stopToken);
    [ExtensionAttribute]
public static bool HasLineTerminatorBefore(ITreeNode node);
    [ExtensionAttribute]
public static bool HasLineTerminatorAfter(ITreeNode node);
    [ExtensionAttribute]
public static IEnumerable`1<ITokenNode> LeftWhitespaces(ITokenNode node);
    [ExtensionAttribute]
public static void MakeIndent(ITreeNode indentNode, string indent);
    [ExtensionAttribute]
public static bool IsStartOfBody(ITreeNode node);
    [ExtensionAttribute]
public static bool IsEndOfBody(ITreeNode node);
    [ExtensionAttribute]
public static bool IsInvocableDeclaration(ITreeNode node);
    [ExtensionAttribute]
public static bool IsFieldDeclaration(ITreeNode node);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBGenericWhitespace : VBWhitespace {
    private string myText;
    public VBGenericWhitespace(string text);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void CheckWhitespaceConsistency(string whitespace);
    public virtual ITokenNode CreateNode(LineEnding lineEnding);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBImplicitLineContinuation : VBWhitespace {
    public static VBWhitespace Instance;
    private static VBImplicitLineContinuation();
    public virtual ITokenNode CreateNode(LineEnding lineEnding);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBLineContinuation : VBWhitespace {
    public static VBWhitespace Instance;
    private static VBLineContinuation();
    public virtual ITokenNode CreateNode(LineEnding lineEnding);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBNewLine : VBWhitespace {
    public static VBWhitespace Instance;
    private static VBNewLine();
    public virtual ITokenNode CreateNode(LineEnding lineEnding);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBRemoveExtraLineTerminatorsStage : object {
    private FmtSettingsClassic`1<VBFormatSettingsKey> mySettings;
    private IProgressIndicator myProgressIndicator;
    private VBRemoveExtraLineTerminatorsStage(FmtSettingsClassic`1<VBFormatSettingsKey> settings, IProgressIndicator progressIndicator);
    public static void DoRemove(FormattingRange range, FmtSettingsClassic`1<VBFormatSettingsKey> settings, IProgressIndicator progress);
    public sealed virtual void Format(ITreeNode leftChild, ITreeNode rightChild);
    private static void DeleteLineTerminator(ITreeNode terminator);
    private int GetMaxBlankLines(ITreeNode child1, ITreeNode child2);
    private static bool IsEndOfDeclaration(ITreeNode node);
    [CanBeNullAttribute]
private static ITreeNode LeftMeaningfulNode(ITreeNode node);
    private static bool IsStartOfDeclaration(ITreeNode originalNode);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.VBWhitespace : object {
    public abstract virtual ITokenNode CreateNode(LineEnding lineEnding);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Formatter.Wrapping.VBWrappingStage : object {
    private CodeFormattingContext myFormattingContext;
    private WrappingVisitor myWrappingVisitor;
    private static NodeTypeSet ourNewLineTokens;
    public VBWrappingStage(CodeFormattingContext context, FmtSettingsClassic`1<VBFormatSettingsKey> settings);
    private static VBWrappingStage();
    public static bool DoWrap(FormattingRange wrapRange, CodeFormattingContext context, FmtSettingsClassic`1<VBFormatSettingsKey> settings, VBFormatProfile profile, IProgressIndicator progress);
    private bool ShouldWrap(FormattingStageContext context);
    private void BreakLines(ITreeNode leftChild, ITreeNode rightChild, LineEnding lineEnding);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.Qualifiers : object {
    private static Key ourIsRedundant;
    private static object ourYes;
    private static object ourNo;
    private static Qualifiers();
    [ExtensionAttribute]
public static bool IsQualifierRedundant(IReferenceName reference);
    [ExtensionAttribute]
public static bool IsQualifierRedundant(IQualifiableReference reference);
    [ExtensionAttribute]
public static void MarkAsRedundant(IReferenceName reference, bool isRedundant);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.VBOptimizeImportsAndReferencesEngine : OptimizeImportsAndReferencesEngine {
    [CompilerGeneratedAttribute]
private IVBFile <File>k__BackingField;
    private IVBFile File { get; }
    public VBOptimizeImportsAndReferencesEngine(IVBFile file, IRangeMarker rangeMarker);
    [CompilerGeneratedAttribute]
private IVBFile get_File();
    protected virtual IGeneratedCodeRegionDetector CreateGeneratedCodeRegionDetector();
    protected virtual HashSet`1<ITreeNode> GetUsedImports();
    protected virtual void RemoveImportsAndAddMandatory(HashSet`1<ITreeNode> usedImports);
    protected virtual void ReindentImports();
    protected virtual IQualifiableReference ShortenReferenceCore(IQualifiableReference reference, DeclaredElementInstance instance);
    protected virtual ReferenceOptimizationKind GetReferenceKind(IReference reference, IDeclaredElement target);
    protected virtual void ShortenStaticMemberReferences(Dictionary`2<IReference, IResolveResult> referenceResolveMap);
    protected virtual bool CanRequireImport(IReference reference);
    protected virtual void AddImportForExtensionMethodIfRequired(IReference reference, IMethod extensionMethod);
    private IQualifiableReference ShortenReference2(IQualifiableReference reference, DeclaredElementInstance target);
    private static bool CheckEqualResolve(TypeMemberInstance instance, IResolveResult result);
}
public class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.VBPreprocessorRegionIdentity : object {
    public static ICodeRegionIdentity Instance;
    private static VBPreprocessorRegionIdentity();
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.VBRegionIdentity : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public VBRegionIdentity(IRegionPreprocessorDirective node);
    public VBRegionIdentity(IEndRegionPreprocessorDirective node);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Psi.VB.Impl.CodeStyle.VBRegionStructureProvider : object {
    public sealed virtual void ProcessNode(ITreeNode node, IRegionStructureAcceptor acceptor);
    public sealed virtual bool IsSpecialComment(IComment comment);
    private bool ProcessNodeCore(ITreeNode node, IRegionStructureAcceptor acceptor);
    private static bool TryProcess(T node, Action`1<T> action);
    private static bool TryProcess(IComment comment, IRegionStructureAcceptor acceptor);
}
internal interface JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.ICompilerGeneratedFileProvider {
    [CanBeNullAttribute]
public IPsiSourceFile File { get; }
    public abstract virtual IPsiSourceFile get_File();
    public abstract virtual void OnProjectPropertiesChanged(PsiModuleChangeBuilder changeBuilder);
    public abstract virtual void OnExternalModuleSetChanged(PsiModuleChangeBuilder changeBuilder, PsiModuleChange psiModuleChange);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.MyApplicationDataProvider : object {
    private Dictionary`2<VirtualFileSystemPath, string> myData;
    private object myLock;
    public string GetMyFile(IPsiAssembly assembly);
    public string GetMyFile(VirtualFileSystemPath assemblyPath);
    public string GetMyXLinqFile();
    public string GetVBEmbeddedRuntimeFile();
    private static string GetMyResourceFromAssembly(VirtualFileSystemPath assemblyPath);
    public string GetMyTemplateTextFile();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.MyGeneratedFile : MySourceFileBase {
    private MyGeneratedFileProviderBase myProvider;
    public string Name { get; }
    public DateTime LastWriteTimeUtc { get; }
    public IModuleReferenceResolveContext ResolveContext { get; }
    public MyGeneratedFile(IInMemoryDocumentFactory documentFactory, IPsiModule module, MyGeneratedFileProviderBase provider);
    public sealed virtual bool IsValid();
    protected virtual string GetDocumentBody();
    public virtual string get_Name();
    public sealed virtual string GetPersistentID();
    public sealed virtual DateTime get_LastWriteTimeUtc();
    public sealed virtual IModuleReferenceResolveContext get_ResolveContext();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.MyGeneratedFileProvider : MyGeneratedFileProviderBase {
    internal string DocumentBody { get; }
    internal string PersistentIdMixin { get; }
    protected string AssemblyName { get; }
    internal string SourceFileName { get; }
    public MyGeneratedFileProvider(IInMemoryDocumentFactory documentFactory, IPsiModule ownerModule, IModuleReferenceResolveContext resolveContext);
    internal virtual string get_DocumentBody();
    internal virtual string get_PersistentIdMixin();
    protected virtual bool SourceFileShouldExist(VirtualFileSystemPath assemblyPath);
    protected virtual string get_AssemblyName();
    internal virtual string get_SourceFileName();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.MyGeneratedFileProviderBase : object {
    private IInMemoryDocumentFactory myDocumentFactory;
    internal IPsiModule OwnerModule;
    internal VirtualFileSystemPath VbAssemblyPath;
    internal IModuleReferenceResolveContext ResolveContext;
    internal MyApplicationDataProvider ApplicationDataProvider;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <File>k__BackingField;
    public IPsiSourceFile File { get; private set; }
    internal string PersistentIdMixin { get; }
    protected string AssemblyName { get; }
    internal string SourceFileName { get; }
    internal string DocumentBody { get; }
    protected MyGeneratedFileProviderBase(IInMemoryDocumentFactory documentFactory, IPsiModule ownerModule, IModuleReferenceResolveContext resolveContext);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_File();
    [CompilerGeneratedAttribute]
private void set_File(IPsiSourceFile value);
    public sealed virtual void OnProjectPropertiesChanged(PsiModuleChangeBuilder changeBuilder);
    public sealed virtual void OnExternalModuleSetChanged(PsiModuleChangeBuilder changeBuilder, PsiModuleChange psiModuleChange);
    private bool ContainsSignificantModuleChange(PsiModuleChange psiModuleChange);
    private void UpdateMyFilePropertiesAndApply(PsiModuleChangeBuilder changeBuilder);
    private Nullable`1<ChangeType> UpdateMyFileProperties();
    [CanBeNullAttribute]
protected VirtualFileSystemPath CalculateAssemblyPath();
    internal abstract virtual string get_PersistentIdMixin();
    protected abstract virtual bool SourceFileShouldExist(VirtualFileSystemPath assemblyPath);
    protected abstract virtual string get_AssemblyName();
    internal abstract virtual string get_SourceFileName();
    internal abstract virtual string get_DocumentBody();
    [CompilerGeneratedAttribute]
private bool <CalculateAssemblyPath>b__15_1(IAssemblyPsiModule a);
    [CompilerGeneratedAttribute]
private bool <CalculateAssemblyPath>b__15_3(IProjectToAssemblyReference reference);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.MyGeneratedInternalXmlHelperProvider : MyGeneratedFileProviderBase {
    internal string DocumentBody { get; }
    internal string PersistentIdMixin { get; }
    protected string AssemblyName { get; }
    internal string SourceFileName { get; }
    public MyGeneratedInternalXmlHelperProvider(IInMemoryDocumentFactory documentFactory, IPsiModule ownerModule, IModuleReferenceResolveContext resolveContext);
    internal virtual string get_DocumentBody();
    internal virtual string get_PersistentIdMixin();
    protected virtual bool SourceFileShouldExist(VirtualFileSystemPath assemblyPath);
    protected virtual string get_AssemblyName();
    internal virtual string get_SourceFileName();
}
internal static class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.MyGroupCollectorMembersProvider : object {
    private static IClrTypeName ourGroupCollectionAttribute;
    private static Char[] ourCommaSeparator;
    private static MyGroupCollectorMembersProvider();
    [NotNullAttribute]
public static IEnumerable`1<ITypeMember> GetGeneratedMembers(VBClassLikePart`1<T> part);
    [NotNullAttribute]
private static IEnumerable`1<ITypeElement> GetGroupTypes(IClassLikeDeclaration declaration);
    private static bool CanBeInstantiated(ITypeElement typeElement);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.MySourceFileBase : UserDataHolder {
    private IInMemoryDocumentFactory myDocumentFactory;
    protected IPsiModule myModule;
    private PsiSourceFileStorage myPsiSourceFileStorage;
    private JetWeakReference`1 modreq(System.Runtime.CompilerServices.IsVolatile) myDocument;
    public IPsiSourceFileStorage PsiStorage { get; }
    public string Name { get; }
    public string DisplayName { get; }
    public ProjectFileType LanguageType { get; }
    public PsiLanguageType PrimaryPsiLanguage { get; }
    public IPsiSourceFileProperties Properties { get; }
    public Nullable`1<ModificationStamp> InMemoryModificationStamp { get; }
    public Nullable`1<ModificationStamp> ExternalModificationStamp { get; }
    public IPsiModule PsiModule { get; }
    public IDocument Document { get; }
    protected MySourceFileBase(IInMemoryDocumentFactory documentFactory, IPsiModule module);
    public sealed virtual IPsiSourceFileStorage get_PsiStorage();
    public abstract virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual ProjectFileType get_LanguageType();
    public sealed virtual PsiLanguageType get_PrimaryPsiLanguage();
    public sealed virtual IPsiSourceFileProperties get_Properties();
    public sealed virtual Nullable`1<ModificationStamp> get_InMemoryModificationStamp();
    public sealed virtual Nullable`1<ModificationStamp> get_ExternalModificationStamp();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IDocument get_Document();
    protected abstract virtual string GetDocumentBody();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.VBGroupCollectionField : VBGroupCollectionMemberBase {
    private string myName;
    public string ShortName { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public VBGroupCollectionField(ITypeElement owner, ITypeElement referee, string name);
    public virtual string get_ShortName();
    public virtual DeclaredElementType GetElementType();
    public virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.VBGroupCollectionMemberBase : object {
    [CompilerGeneratedAttribute]
private ITypeElement <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <Referee>k__BackingField;
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public ISubstitution IdSubstitution { get; }
    public ITypeElement ContainingType { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public ITypeElement Owner { get; }
    public ITypeElement Referee { get; }
    protected VBGroupCollectionMemberBase(ITypeElement owner, ITypeElement referee);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiModule get_Module();
    public abstract virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public abstract virtual DeclaredElementType GetElementType();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public abstract virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeElement get_Owner();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeElement get_Referee();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.VBGroupCollectionProperty : VBGroupCollectionMemberBase {
    private string myName;
    public string ShortName { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IType Type { get; }
    [NotNullAttribute]
public IAccessor Getter { get; }
    [NotNullAttribute]
public IAccessor Setter { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public bool IsAuto { get; }
    public VBGroupCollectionProperty(ITypeElement owner, ITypeElement referee, string name);
    public virtual string get_ShortName();
    public virtual DeclaredElementType GetElementType();
    public virtual ITypeMember GetContainingTypeMember();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IType get_Type();
    public sealed virtual IAccessor get_Getter();
    public sealed virtual IAccessor get_Setter();
    public sealed virtual bool get_IsReadable();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsRequired();
    public sealed virtual bool get_IsAuto();
    private sealed virtual override string JetBrains.ReSharper.Psi.IProperty.GetDefaultPropertyMetadataName();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.My.VBGroupCollectionPropertyAccessor : VBGroupCollectionMemberBase {
    private VBGroupCollectionProperty myProperty;
    private AccessorKind myKind;
    public string ShortName { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public bool IsExtensionMethod { get; }
    public bool IsVarArg { get; }
    public bool IsAsync { get; }
    public IOverridableMember OwnerMember { get; }
    public AccessorKind Kind { get; }
    public bool IsAuto { get; }
    public bool IsInitOnly { get; }
    public IParameter ValueVariable { get; }
    public VBGroupCollectionPropertyAccessor(VBGroupCollectionProperty property, AccessorKind kind);
    public virtual string get_ShortName();
    public virtual DeclaredElementType GetElementType();
    public virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsAsync();
    public sealed virtual IOverridableMember get_OwnerMember();
    public sealed virtual AccessorKind get_Kind();
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual IParameter get_ValueVariable();
}
public class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.VBCompilerGeneratedFilesMixin : object {
    private ICompilerGeneratedFileProvider[] myProviders;
    public IEnumerable`1<IPsiSourceFile> Files { get; }
    public VBCompilerGeneratedFilesMixin(IInMemoryDocumentFactory documentFactory, IPsiModule ownerModule, IModuleReferenceResolveContext resolveContext);
    public IEnumerable`1<IPsiSourceFile> get_Files();
    public void OnProjectPropertiesChanged(PsiModuleChangeBuilder changeBuilder);
    public void OnExternalModuleSetChanged(PsiModuleChangeBuilder changeBuilder, PsiModuleChange result);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.VBCompilerGeneratedFilesProvider : object {
    private IInMemoryDocumentFactory myDocumentFactory;
    private ISolution mySolution;
    private ChangeManager myChangeManager;
    public VBCompilerGeneratedFilesProvider(IInMemoryDocumentFactory documentFactory, ISolution solution, ChangeManager changeManager);
    public sealed virtual Tuple`2<IProjectPsiModuleHandler, IPsiModuleDecorator> OverrideHandler(Lifetime lifetime, IProject project, IProjectPsiModuleHandler handler);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CompilerGeneratedFiles.VBEmbeddedRuntimeProvider : MyGeneratedFileProvider {
    internal string PersistentIdMixin { get; }
    internal string DocumentBody { get; }
    protected string AssemblyName { get; }
    internal string SourceFileName { get; }
    public VBEmbeddedRuntimeProvider(IInMemoryDocumentFactory documentFactory, IPsiModule ownerModule, IModuleReferenceResolveContext resolveContext);
    internal virtual string get_PersistentIdMixin();
    internal virtual string get_DocumentBody();
    protected virtual bool SourceFileShouldExist(VirtualFileSystemPath assemblyPath);
    protected virtual string get_AssemblyName();
    internal virtual string get_SourceFileName();
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBClosureExecutionBehaviorInspector : ClosureExecutionBehaviorInspectorBase {
    [CompilerGeneratedAttribute]
private VBControlFlowAnnotationCache <annotationsCache>P;
    public VBClosureExecutionBehaviorInspector(VBControlFlowAnnotationCache annotationsCache);
    protected virtual ExecutionBehavior AnalyzeLambdaExecutionContext(ITreeNode closureNode, ITreeNode& contextNode, IMethod& contextMethod);
    protected virtual ExecutionBehavior NextTunnelClauseContext(ITreeNode contextNode, ITreeNode& nextContextNode, IMethod& nextContextMethod);
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBClosureVariableInfo : VBVariableInfo {
    public VBClosureVariableInfo(IClrDeclaredElement element);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowAddHandlerStatement : VBControlFlowSimpleStatement {
    public VBControlFlowAddHandlerStatement(IAddHandlerStatement statement);
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowAnnotationCache : object {
    private LinqTunnelAnnotationProvider myLinqTunnelAnnotationProvider;
    private InstantHandleAnnotationProvider myInstantHandleAnnotationProvider;
    public VBControlFlowAnnotationCache(CodeAnnotationsCache annotationsCache);
    public bool GetInstantHandle(IParameter element);
    public bool GetLinqTunnel(IMethod method);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowAssignmentStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowAssignmentStatement(IAssignmentStatement statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowBlock : ControlFlowElement {
    private IBlock myBlock;
    private VBControlFlowStatement[] myStatements;
    public IBlock Block { get; }
    public VBControlFlowStatement[] Statements { get; }
    public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowBlock(IBlock block, VBControlFlowBuilderContext context);
    public IBlock get_Block();
    public VBControlFlowStatement[] get_Statements();
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowBlockIfStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowBlockIfStatement(IBlockIfStatement statement, VBControlFlowBuilderContext context);
    private VBControlFlowCondition CreateSection(IVBExpression expression, IBlock thenBlock, VBControlFlowBuilderContext context);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowBody : ControlFlowElement {
    private IVBControlFlowElement myBody;
    private VBControlFlowMultiplexor myImplicitReturn;
    private List`1<IControlFlowElement> myUnresolvedJumpErrors;
    public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public IVBControlFlowElement ImplicitReturn { get; }
    public VBControlFlowBody(IBlock body);
    public VBControlFlowBody(IVBExpression body);
    public VBControlFlowBody(IVBStatement body);
    private void ProcessBodyExits();
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public IVBControlFlowElement get_ImplicitReturn();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowBuilderContext : object {
    private Dictionary`2<ILabel, IVBControlFlowElement> myLables;
    public void RegisterLabelStatement(ILabelStatement statement, IVBControlFlowElement element);
    public IVBControlFlowElement GetLabelElement(ILabel label);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowCaseStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    private List`1<IControlFlowEdge> myBodyExits;
    private List`1<IControlFlowEdge> myBypassExits;
    internal List`1<IControlFlowEdge> BypassExits { get; }
    internal List`1<IControlFlowEdge> BodyExits { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowCaseStatement(ICaseStatement statement, VBControlFlowBuilderContext context);
    internal List`1<IControlFlowEdge> get_BypassExits();
    internal List`1<IControlFlowEdge> get_BodyExits();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowCatchStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowCatchStatement(ICatchStatement statement, VBControlFlowBuilderContext context);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowCondition : ControlFlowElement {
    private VBControlFlowExpression myExpression;
    private List`1<IControlFlowElement> myChildren;
    private Dictionary`2<bool, ConditionMultiplexor> myConditionMultiplexors;
    public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowCondition(IVBExpression expression);
    private ConditionMultiplexor CreateConditionMultiplexor(ITreeNode expression, bool condition);
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowCondition/<GetBooleanExits>d__9")]
public IEnumerable`1<IControlFlowEdge> GetBooleanExits(bool condition);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowContext : object {
    [NotNullAttribute]
private VBControlFlowContextFactory myContextFactory;
    [NotNullAttribute]
private VBVariableIndex myVariableIndex;
    [NotNullAttribute]
private ControlFlowVariableStateCollection myStates;
    [CompilerGeneratedAttribute]
private bool <RecursiveAtAllPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private VBControlFlowContext <ParentContext>k__BackingField;
    public bool RecursiveAtAllPaths { get; public set; }
    public VBVariableIndex VariableIndex { get; }
    public ControlFlowVariableAccessState Item { get; public set; }
    public ExecutionBehavior ExecutionBehavior { get; }
    public VBControlFlowContext ParentContext { get; }
    public VBControlFlowContext(VBControlFlowContextFactory contextFactory, VBVariableIndex variableIndex);
    public VBControlFlowContext(VBControlFlowContext context);
    public VBControlFlowContext(VBControlFlowContext context, VBControlFlowContext parent);
    public VBControlFlowContext(IList`1<VBControlFlowContext> contexts);
    [CompilerGeneratedAttribute]
public bool get_RecursiveAtAllPaths();
    [CompilerGeneratedAttribute]
public void set_RecursiveAtAllPaths(bool value);
    public VBVariableIndex get_VariableIndex();
    public sealed virtual void AddToRecentAssignmentsList(VBVariableInfo info, ITreeNode element);
    public sealed virtual void AddToRecentUsagesList(VBVariableInfo info, ITreeNode element);
    public sealed virtual void ClearRecentAssignmentsList(VBVariableInfo info);
    public sealed virtual IEnumerable`1<ITreeNode> GetRecentAssignmentsList(VBVariableInfo info);
    public sealed virtual IEnumerable`1<ITreeNode> GetUsagesOfRecentAssignments(VBVariableInfo info, ITreeNode assignment);
    public sealed virtual IEnumerable`1<ITreeNode> GetRecentAccessInClosure(VBVariableInfo info);
    public sealed virtual void AddRecentAccessInClosure(VBVariableInfo info, ITreeNode element);
    public sealed virtual void ClearRecentAccessInClosure(VBVariableInfo info);
    public sealed virtual ControlFlowVariableAccessState get_Item(VBVariableInfo info);
    public sealed virtual void set_Item(VBVariableInfo info, ControlFlowVariableAccessState value);
    public sealed virtual void SetAccessStates(IEnumerable`1<VBVariableInfo> infos, Func`2<ControlFlowVariableAccessState, ControlFlowVariableAccessState> mutator);
    public sealed virtual ExecutionBehavior get_ExecutionBehavior();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual VBVariableInfo GetVariableInfoByVariableInfoInChildContext(VBVariableInfo infoInChildContext);
    public sealed virtual IEnumerable`1<VBVariableInfo> EnumerateVariables();
    [CompilerGeneratedAttribute]
public sealed virtual VBControlFlowContext get_ParentContext();
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowContextFactory : object {
    private VBControlFlowGraph myControlFlowGraph;
    private VBControlFlowContext myInitialControlFlowContext;
    private ExecutionBehavior myExecutionBehavior;
    public ExecutionBehavior ExecutionBehavior { get; }
    public VBVariableIndex VariableIndex { get; }
    public VBControlFlowContext InitialContext { get; public set; }
    internal VBControlFlowContextFactory(VBControlFlowGraph controlFlowGraph, ExecutionBehavior executionBehavior);
    public ExecutionBehavior get_ExecutionBehavior();
    public VBVariableIndex get_VariableIndex();
    public virtual VBControlFlowContext get_InitialContext();
    public virtual void set_InitialContext(VBControlFlowContext value);
    public sealed virtual VBControlFlowContext CloneContext(VBControlFlowContext context);
    public sealed virtual VBControlFlowContext Merge(IList`1<VBControlFlowContext> contexts);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowContinueStatement : VBControlFlowStatement {
    public VBControlFlowContinueStatement(IContinueStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowDoLoopStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowDoLoopStatement(IDoLoopStatement statement, VBControlFlowBuilderContext context);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowEdge : ControlFlowEdge {
    private List`1<IUsingStatement> myExitFromUsings;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <BooleanValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NullCoalescingCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PassThroughFinally>k__BackingField;
    public IVBControlFlowElement Source { get; }
    public IVBControlFlowElement Target { get; public set; }
    public Nullable`1<bool> BooleanValue { get; public set; }
    public Nullable`1<bool> NullCoalescingCondition { get; public set; }
    public IEnumerable`1<IUsingStatement> ExitFromUsings { get; }
    public bool PassThroughFinally { get; public set; }
    public VBControlFlowEdge(ControlFlowEdgeType edgeType, IControlFlowElement source);
    public VBControlFlowEdge(ControlFlowEdgeType edgeType, IControlFlowElement source, IControlFlowElement target);
    public sealed virtual IVBControlFlowElement get_Source();
    public sealed virtual IVBControlFlowElement get_Target();
    public sealed virtual void set_Target(IVBControlFlowElement value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_BooleanValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BooleanValue(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_NullCoalescingCondition();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NullCoalescingCondition(Nullable`1<bool> value);
    public sealed virtual IEnumerable`1<IUsingStatement> get_ExitFromUsings();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PassThroughFinally();
    [CompilerGeneratedAttribute]
public void set_PassThroughFinally(bool value);
    public void AddExitFromUsing(IUsingStatement usingStatement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowEndStatement : VBControlFlowStatement {
    public VBControlFlowEndStatement(IEndStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowEraseStatement : VBControlFlowSimpleStatement {
    public VBControlFlowEraseStatement(IEraseStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowError : VBControlFlowMultiplexor {
    private VBControlFlowErrorType myErrorType;
    public VBControlFlowErrorType ErrorType { get; }
    public VBControlFlowError(VBControlFlowErrorType errorType, ITreeNode sourceElement);
    public sealed virtual VBControlFlowErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowErrorStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowErrorStatement(IErrorStatement statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowExitStatement : VBControlFlowStatement {
    public VBControlFlowExitStatement(IExitStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowExpression : ControlFlowElement {
    private IVBExpression myExpression;
    private List`1<IControlFlowElement> myChildren;
    public ITreeNode SourceElement { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowExpression(IVBExpression expression);
    public virtual ITreeNode get_SourceElement();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowFinallyStatement : VBControlFlowStatement {
    private VBControlFlowBlock myFinallyBlock;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowFinallyStatement(IFinallyStatement statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowForEachStatement : VBControlFlowForStatementBase {
    public VBControlFlowForEachStatement(IForEachStatement statement, VBControlFlowBuilderContext context);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowForStatement : VBControlFlowForStatementBase {
    public VBControlFlowForStatement(IForStatement statement, VBControlFlowBuilderContext context);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowForStatementBase : VBControlFlowStatement {
    protected List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    protected VBControlFlowForStatementBase(IVBStatement statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    protected void ResolveBodyExits(VBControlFlowBlock block, VBControlFlowMultiplexor endBodyPoint, VBControlFlowMultiplexor endLoopPoint);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowGotoStatement : VBControlFlowStatement {
    public VBControlFlowGotoStatement(IGotoStatement statement);
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowGraph : ControlFlowGraph {
    private IVBTreeNode myBlock;
    private IList`1<IParameter> myParameters;
    private VBControlFlowMultiplexor myEntryElement;
    private VBControlFlowBody myBodyElement;
    public IVBTreeNode Body { get; }
    public IList`1<IParameter> Parameters { get; }
    public IControlFlowElement EntryElement { get; }
    public IControlFlowElement BodyElement { get; }
    public ICollection`1<IVBControlFlowEdge> ReachableExits { get; }
    public IVBControlFlowElement ImplicitReturn { get; }
    public IDictionary`2<ITreeNode, VBControlFlowErrorType> ControlFlowErrors { get; }
    private VBControlFlowGraph(IVBTreeNode body, IList`1<IParameter> parameters, VBControlFlowBody bodyElement);
    public VBControlFlowGraph(IBlock block, IList`1<IParameter> parameters);
    public VBControlFlowGraph(IVBExpression expression, IList`1<IParameter> parameters);
    public VBControlFlowGraph(IVBStatement statement, IList`1<IParameter> parameters);
    public IVBTreeNode get_Body();
    public IList`1<IParameter> get_Parameters();
    public virtual IControlFlowElement get_EntryElement();
    public virtual IControlFlowElement get_BodyElement();
    public sealed virtual ICollection`1<IVBControlFlowEdge> get_ReachableExits();
    public sealed virtual IVBControlFlowElement get_ImplicitReturn();
    public sealed virtual IDictionary`2<ITreeNode, VBControlFlowErrorType> get_ControlFlowErrors();
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowGraphInspector : CommonLanguageControlFlowGraphInspector`3<VBControlFlowContextFactory, VBControlFlowContext, VBVariableInfo> {
    private OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, IVBExpression> myPossibleMultipleEnumeration;
    private VBControlFlowAnnotationCache myCodeAnnotationsCache;
    private ClosureAnalyzer myClosureAnalyzer;
    public ICollection`1<IDeclaredElement> UsedFieldsWithTrackedAccessState { get; }
    public bool HasTooManyVariables { get; }
    public OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, IVBExpression> PossibleMultipleEnumeration { get; }
    public bool IsFunctionValueInitializeOnImplicitReturn { get; }
    public VBControlFlowGraphInspector(VBControlFlowGraph controlFlowGraph, ExecutionBehavior executionBehavior);
    public virtual void Inspect();
    protected virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement element, VBControlFlowContext context);
    protected virtual bool ShouldInspectSingleLeaf(ControlFlowElement element);
    protected virtual IEnumerable`1<VBVariableInfo> EnumerateVariables();
    public virtual ICollection`1<IDeclaredElement> get_UsedFieldsWithTrackedAccessState();
    public virtual bool get_HasTooManyVariables();
    protected virtual bool IsForeachVariableDeclaration(IDeclaredElement declaredElement);
    private static bool IsPossibleEnumeration(IVBExpression expression, VBVariableInfo info);
    public sealed virtual OneToSetMap`2<Pair`2<IDeclaredElement, ITreeNode>, IVBExpression> get_PossibleMultipleEnumeration();
    private static void ResetStateOfOutOfScopeVariables(VBControlFlowContext context, IControlFlowEdge edge);
    private static void ResetOutOfScopeVariable(VBControlFlowContext context, IDeclaredElement localVariable);
    private static void ResetStateOfOutOfScopeVariables(VBControlFlowContext context, ITreeNode scope);
    private static void ResetOutOfScopeVariableState(VBControlFlowContext context, VBVariableInfo info);
    private void PostProcessAssignmentTable();
    public sealed virtual bool get_IsFunctionValueInitializeOnImplicitReturn();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowInvocationStatement : VBControlFlowSimpleStatement {
    public VBControlFlowInvocationStatement(IInvocationStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowLabelStatement : VBControlFlowSimpleStatement {
    public VBControlFlowLabelStatement(ILabelStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowLineIfStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowLineIfStatement(ILineIfStatement statement, VBControlFlowBuilderContext context);
    private VBControlFlowCondition CreateSection(IVBExpression expression, IEnumerable`1<IVBStatement> statements, VBControlFlowBuilderContext context);
    private IEnumerable`1<IControlFlowEdge> BuildStatementSequence(IEnumerable`1<IControlFlowEdge> entries, IEnumerable`1<IVBStatement> statements, VBControlFlowBuilderContext context);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowLocalDeclarationStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowLocalDeclarationStatement(ILocalDeclarationStatement statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowMidAssignmentStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowMidAssignmentStatement(IMidAssignmentStatement statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowMultiplexor : ControlFlowMultiplexor {
    public VBControlFlowMultiplexor(ITreeNode referencedElement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowOnErrorStatement : VBControlFlowSimpleStatement {
    public VBControlFlowOnErrorStatement(IOnErrorStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowQueryOperator : VBControlFlowMultiplexor {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowQueryOperator(IQueryOperator operator);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowRaiseEventStatement : VBControlFlowSimpleStatement {
    public VBControlFlowRaiseEventStatement(IRaiseEventStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowReDimStatement : VBControlFlowSimpleStatement {
    public VBControlFlowReDimStatement(IRedimStatement statement);
    private static IVBExpression[] GetExpressions(IRedimStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowRemoveHandlerStatement : VBControlFlowSimpleStatement {
    public VBControlFlowRemoveHandlerStatement(IRemoveHandlerStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowResumeStatement : VBControlFlowSimpleStatement {
    public VBControlFlowResumeStatement(IResumeStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowReturnStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowReturnStatement(IReturnStatement statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowSelectStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowSelectStatement(ISelectStatement statement, VBControlFlowBuilderContext context);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowSimpleBlockStatement`1 : VBControlFlowStatement {
    protected List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    protected VBControlFlowSimpleBlockStatement`1(T statement, IBlock block, VBControlFlowBuilderContext context);
    protected abstract virtual void BuildInitializer(T statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowSimpleStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowSimpleStatement(IVBStatement statement, IVBExpression[] expressions);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowStatement : ControlFlowElement {
    [CompilerGeneratedAttribute]
private IVBStatement <Statement>k__BackingField;
    public ITreeNode SourceElement { get; }
    public IVBStatement Statement { get; }
    protected VBControlFlowStatement(IVBStatement statement);
    public virtual ITreeNode get_SourceElement();
    [CompilerGeneratedAttribute]
public IVBStatement get_Statement();
    public static VBControlFlowStatement Build(IVBStatement statement, VBControlFlowBuilderContext context);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowStopStatement : VBControlFlowStatement {
    public VBControlFlowStopStatement(IStopStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowSyncLockStatement : VBControlFlowSimpleBlockStatement`1<ISyncLockStatement> {
    public VBControlFlowSyncLockStatement(ISyncLockStatement statement, VBControlFlowBuilderContext context);
    protected virtual void BuildInitializer(ISyncLockStatement statement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowThrowStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowThrowStatement(IThrowStatement statement);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowTryStatement : VBControlFlowStatement {
    private VBControlFlowMultiplexor myTryStartPoint;
    private VBControlFlowBlock myTryBlock;
    private VBControlFlowMultiplexor myTryRegularEndPoint;
    private ThrowEndPoint myTryUnexpectedThrowEndPoint;
    private List`1<IControlFlowElement> myCatches;
    private List`1<IControlFlowElement> myAllFinallyBlocks;
    private List`1<IControlFlowElement> myAllFinallyEndPoints;
    private List`1<IControlFlowElement> myErrors;
    public VBControlFlowBlock TryBlock { get; }
    public List`1<IControlFlowElement> Catches { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowTryStatement(ITryStatement statement, VBControlFlowBuilderContext context);
    public VBControlFlowBlock get_TryBlock();
    public List`1<IControlFlowElement> get_Catches();
    private void PassThroughFinally(IVBControlFlowEdge edge, IFinallyStatement finally);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowUsingStatement : VBControlFlowSimpleBlockStatement`1<IUsingStatement> {
    public VBControlFlowUsingStatement(IUsingStatement statement, VBControlFlowBuilderContext context);
    protected virtual void BuildInitializer(IUsingStatement statement);
}
internal static class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowUtil : object {
    public static T AppendElement(IList`1<IControlFlowElement> children, T element);
    public static VBControlFlowMultiplexor AppendMultiplexor(IList`1<IControlFlowElement> children, ITreeNode element);
    public static VBControlFlowExpression AppendExpression(IList`1<IControlFlowElement> children, IVBExpression expression);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowWhileStatement : VBControlFlowStatement {
    private List`1<IControlFlowElement> myChildren;
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public VBControlFlowWhileStatement(IWhileStatement statement, VBControlFlowBuilderContext context);
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBControlFlowWithStatement : VBControlFlowSimpleBlockStatement`1<IWithStatement> {
    public VBControlFlowWithStatement(IWithStatement statement, VBControlFlowBuilderContext context);
    protected virtual void BuildInitializer(IWithStatement statement);
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBVariableIndex : object {
    private List`1<VBVariableInfo> myAllVariables;
    private OneToListMap`2<IDeclaredElement, VBVariableInfo> myVariablesByElement;
    private Dictionary`2<IVBExpression, VBVariableInfo> myInfoByExpressionCache;
    [CompilerGeneratedAttribute]
private VBVariableInfo <FunctionValue>k__BackingField;
    public VBVariableInfo FunctionValue { get; public set; }
    public int Count { get; }
    [CompilerGeneratedAttribute]
public VBVariableInfo get_FunctionValue();
    [CompilerGeneratedAttribute]
public void set_FunctionValue(VBVariableInfo value);
    public int get_Count();
    public VBVariableInfo AddVariable(VBVariableInfo info);
    public VBVariableInfo FindLocalOrClosureVariable(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
public VBVariableInfo Find(IVBExpression expression);
    private VBVariableInfo FindByExpression(IVBExpression expression);
    public sealed virtual IEnumerator`1<VBVariableInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private bool <FindLocalOrClosureVariable>b__10_0(VBVariableInfo info);
}
public class JetBrains.ReSharper.Psi.VB.Impl.ControlFlow.VBVariableInfo : object {
    [CompilerGeneratedAttribute]
private IClrDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowVariableAccessState <InitialAccessState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldBeAssignedUponExit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public IClrDeclaredElement DeclaredElement { get; }
    public ControlFlowVariableAccessState InitialAccessState { get; public set; }
    public bool ShouldBeAssignedUponExit { get; public set; }
    public int Index { get; public set; }
    public VBVariableInfo Parent { get; }
    public IList`1<VBVariableInfo> NestedVariableInfos { get; }
    public bool CanBeAssignedFromStructFields { get; }
    public bool IsTrackedInValueAnalysis { get; }
    public bool IsTrackedInAccessStateAnalysis { get; }
    public VBVariableInfo(IClrDeclaredElement element, ControlFlowVariableAccessState initialState, bool shouldBeAssignedUponExit);
    [CompilerGeneratedAttribute]
public sealed virtual IClrDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public sealed virtual ControlFlowVariableAccessState get_InitialAccessState();
    [CompilerGeneratedAttribute]
public void set_InitialAccessState(ControlFlowVariableAccessState value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldBeAssignedUponExit();
    [CompilerGeneratedAttribute]
public void set_ShouldBeAssignedUponExit(bool value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    public sealed virtual VBVariableInfo get_Parent();
    public sealed virtual IList`1<VBVariableInfo> get_NestedVariableInfos();
    public sealed virtual bool get_CanBeAssignedFromStructFields();
    public sealed virtual bool get_IsTrackedInValueAnalysis();
    public sealed virtual bool get_IsTrackedInAccessStateAnalysis();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.CustomHandlers.IVBCustomModificationHandler {
    public bool CanUseAliases { get; }
    public abstract virtual bool CanRemoveUsing(IDocument document, IImportDirective usingDirective);
    public abstract virtual bool get_CanUseAliases();
    public abstract virtual void HandleRemoveStatementsRange(IPsiServices psiServices, ITreeRange treeRange, Action action);
    public abstract virtual IVBStatementsRange HandleAddStatementsRange(IPsiServices psiServices, IFile file, Func`1<IVBStatementsRange> addAction, bool before);
    public abstract virtual void HandleRemoveImport(IPsiServices psiServices, IVBTypeAndNamespaceHolderDeclaration scope, IImportDirective usingDirective, Action action);
    public abstract virtual IImportDirective HandleAddImport(IPsiServices psiServices, Func`1<IImportDirective> action, ITreeNode generatedAnchor, bool before, IFile generatedFile);
    public abstract virtual ITreeNode HandleAddTypeMember(IPsiServices psiServices, Func`1<ITreeNode> action, IFile generatedFile);
}
public class JetBrains.ReSharper.Psi.VB.Impl.CustomHandlers.VBCustomHandlersUtil : object {
    public static bool CanRemoveUsing(IImportDirective usingDirective);
    public static bool CanUseAliases(ITreeNode context);
    [NotNullAttribute]
public static IVBCustomModificationHandler CreateService(ITreeNode context);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.CustomHandlers.VBCustomModificationHandlerDummy : object {
    [NotNullAttribute]
public static VBCustomModificationHandlerDummy Instance;
    public bool CanUseAliases { get; }
    private static VBCustomModificationHandlerDummy();
    public sealed virtual bool CanRemoveUsing(IDocument document, IImportDirective usingDirective);
    public sealed virtual bool get_CanUseAliases();
    public sealed virtual void HandleRemoveStatementsRange(IPsiServices psiServices, ITreeRange treeRange, Action action);
    public sealed virtual IVBStatementsRange HandleAddStatementsRange(IPsiServices psiServices, IFile file, Func`1<IVBStatementsRange> addAction, bool before);
    public sealed virtual void HandleRemoveImport(IPsiServices psiServices, IVBTypeAndNamespaceHolderDeclaration scope, IImportDirective usingDirective, Action action);
    public sealed virtual IImportDirective HandleAddImport(IPsiServices psiServices, Func`1<IImportDirective> action, ITreeNode generatedAnchor, bool before, IFile generatedFile);
    public sealed virtual ITreeNode HandleAddTypeMember(IPsiServices psiServices, Func`1<ITreeNode> action, IFile generatedFile);
}
public class JetBrains.ReSharper.Psi.VB.Impl.DeclarationsRange : object {
    private ITreeRange myTreeRange;
    public ITreeRange TreeRange { get; }
    public IDeclaration[] Declarations { get; }
    public DeclarationsRange(ITreeRange treeRange);
    public sealed virtual ITreeRange get_TreeRange();
    public sealed virtual IDeclaration[] get_Declarations();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.AnonymousTypeProperty : object {
    private VBAnonymousType myAnonymousType;
    private int myIndex;
    private IAnonymousType JetBrains.ReSharper.Psi.IAnonymousTypeProperty.ContainingType { get; }
    public int Index { get; }
    public IList`1<AnonymousTypePropertyDescriptor> AnonymousTypePropertyDescriptor { get; }
    public bool IsKey { get; }
    public IAnonymousMemberDeclaration PropertyDeclaration { get; }
    public string ShortName { get; }
    public IType Type { get; }
    public IVBAnonymousType ContainingType { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public AnonymousTypeProperty(VBAnonymousType anonymousType, int index);
    private sealed virtual override IAnonymousType JetBrains.ReSharper.Psi.IAnonymousTypeProperty.get_ContainingType();
    public sealed virtual int get_Index();
    public sealed virtual IList`1<AnonymousTypePropertyDescriptor> get_AnonymousTypePropertyDescriptor();
    public sealed virtual bool get_IsKey();
    public sealed virtual IAnonymousMemberDeclaration get_PropertyDeclaration();
    public sealed virtual string get_ShortName();
    public sealed virtual IType get_Type();
    public sealed virtual IVBAnonymousType get_ContainingType();
    public sealed virtual IAnonymousTypeProperty SetName(string name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
}
public class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.ForeachImplicitlyTypedVariable : LoopControlImplicitlyTypedVariable {
    public ForeachImplicitlyTypedVariable(string shortName, IReferenceExpression loopControlVariableExpression);
    public virtual IImplicitLocalVariable SetName(string newName);
    public virtual IType CalculateType(IResolveContext resolveContext);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.ForImplicitlyTypedVariable : LoopControlImplicitlyTypedVariable {
    public ForImplicitlyTypedVariable(string shortName, IReferenceExpression loopControlVariableExpression);
    public virtual IImplicitLocalVariable SetName(string newName);
    public virtual IType CalculateType(IResolveContext resolveContext);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IImplicitLocalVariable {
    public ITreeNode DeclaringElement { get; }
    public abstract virtual ITreeNode get_DeclaringElement();
    public abstract virtual IImplicitLocalVariable SetName(string newName);
}
public interface JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.ILoopControlImplicitlyTypedVariable {
}
public class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.ImplicitLocalVariable : object {
    [NotNullAttribute]
private string myShortName;
    [NotNullAttribute]
private IReferenceExpression myFirstDeclaration;
    public ITreeNode DeclaringElement { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsConstant { get; }
    public bool IsWritable { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsImplicitlyTyped { get; }
    public IType Type { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public ImplicitLocalVariable(string shortName, IReferenceExpression firstDeclaration);
    public sealed virtual IImplicitLocalVariable SetName(string newName);
    public sealed virtual ITreeNode get_DeclaringElement();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual bool get_IsImplicitlyTyped();
    public bool Equals(ImplicitLocalVariable obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    public sealed virtual IType get_Type();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
}
public class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.ImplicitLocalVariablePointer`1 : object {
    private ITreeNodePointer`1<ITreeNode> myTreeNodePointer;
    private IImplicitLocalVariable myDeclaredElement;
    public ImplicitLocalVariablePointer`1(T variable);
    public sealed virtual T FindDeclaredElement();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IVBAnonymousTypeProperty {
    [CanBeNullAttribute]
public IAnonymousMemberDeclaration PropertyDeclaration { get; }
    public bool IsKey { get; }
    [CanBeNullAttribute]
public IVBAnonymousType ContainingType { get; }
    public abstract virtual IAnonymousMemberDeclaration get_PropertyDeclaration();
    public abstract virtual bool get_IsKey();
    public abstract virtual IVBAnonymousType get_ContainingType();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IVBEvent {
    public IField EventField { get; }
    public IDelegate EventHandlerDelegate { get; }
    public abstract virtual IField get_EventField();
    public abstract virtual IDelegate get_EventHandlerDelegate();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IVBField {
    [CanBeNullAttribute]
public IField WithEventsField { get; }
    public abstract virtual IField get_WithEventsField();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IVBGeneratedField {
    public ITypeMember Constitutive { get; }
    public abstract virtual ITypeMember get_Constitutive();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IVBMethod {
    public bool IsPartial { get; }
    public abstract virtual bool get_IsPartial();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IVBProperty {
    [CanBeNullAttribute]
public IField AutoField { get; }
    public bool IsAuto { get; }
    public abstract virtual IField get_AutoField();
    public abstract virtual bool get_IsAuto();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.LiftedOperator : object {
    [NotNullAttribute]
private ISignOperator myOperator;
    private IType myReturnType;
    private IParameter[] myParameters;
    [NotNullAttribute]
public ISignOperator GetBaseOperator { get; }
    public bool IsChecked { get; }
    public IList`1<IParameter> Parameters { get; }
    public ISubstitution IdSubstitution { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public MemberHidePolicy HidePolicy { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public string XMLDocId { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public LiftedOperator(ISignOperator operator);
    public ISignOperator get_GetBaseOperator();
    public sealed virtual bool get_IsChecked();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.LoopControlImplicitlyTypedVariable : object {
    [NotNullAttribute]
protected string myShortName;
    protected IReferenceExpression myLoopControlVariableExpression;
    private CachedPsiValue`1<IType> myCachedType;
    public ITreeNode DeclaringElement { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsConstant { get; }
    public bool IsWritable { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsImplicitlyTyped { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    protected LoopControlImplicitlyTypedVariable(string shortName, IReferenceExpression loopControlVariableExpression);
    public sealed virtual ITreeNode get_DeclaringElement();
    public abstract virtual IImplicitLocalVariable SetName(string newName);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual bool get_IsImplicitlyTyped();
    public abstract virtual IType CalculateType(IResolveContext resolveContext);
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBAccessor : VBOverridableMemberBase`1<AccessorDeclaration> {
    public bool IsExtensionMethod { get; }
    public bool IsVarArg { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IList`1<IParameter> Parameters { get; }
    public IParameter ValueVariable { get; }
    protected IImplementsClause ImplementsClause { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public IOverridableMember OwnerMember { get; }
    public AccessorKind Kind { get; }
    public bool IsAuto { get; }
    public bool IsInitOnly { get; }
    public bool IsStatic { get; }
    public bool IsUnsafe { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsVolatile { get; }
    public VBAccessor(AccessorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsync();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IParameter get_ValueVariable();
    protected virtual IImplementsClause get_ImplementsClause();
    public virtual bool get_IsExplicitImplementation();
    public virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IOverridableMember get_OwnerMember();
    public sealed virtual AccessorKind get_Kind();
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsInitOnly();
    public virtual bool get_IsStatic();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsVolatile();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBAnonymousDelegate : object {
    [NotNullAttribute]
private IReadOnlyList`1<Pair`2<IType, ParameterKind>> myParameterTypesAndKinds;
    [NotNullAttribute]
private IList`1<string> myParameterNames;
    [NotNullAttribute]
private IType myReturnType;
    [NotNullAttribute]
private IPsiModule myModule;
    [CanBeNullAttribute]
private IMethod modreq(System.Runtime.CompilerServices.IsVolatile) myInvokeMethod;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public string XMLDocId { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethod InvokeMethod { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public VBAnonymousDelegate(IReadOnlyList`1<Pair`2<IType, ParameterKind>> parameterTypesAndKinds, IList`1<string> parameterNames, IType returnType, IPsiModule module);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public sealed virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual IMethod get_InvokeMethod();
    public sealed virtual bool Equals(IAnonymousDelegate other, IEqualityComparer`1<IType> typeEqualityComparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBAutoPropertyField : VBGeneratedFieldsBase`1<VBProperty> {
    private static string myNamePrefix;
    public string ShortName { get; }
    public IType Type { get; }
    public VBAutoPropertyField(VBProperty property);
    public virtual string get_ShortName();
    public virtual IType get_Type();
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private AttributeValue[] <GetAttributeInstances>b__7_0();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBConstant : VBTypeMember`1<ConstantDeclaration> {
    private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    [ThreadStaticAttribute]
private static JetHashSet`1<VBConstant> ourTypeCalculationsInProgress;
    public bool IsRequired { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsField { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsStatic { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public VBConstant(ConstantDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsRequired();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsField();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public virtual bool get_IsStatic();
    public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBConstructor : VBTypeMember`1<ConstructorDeclaration> {
    public bool IsDefault { get; }
    public bool IsParameterless { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IList`1<IParameter> Parameters { get; }
    public VBConstructor(ConstructorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsParameterless();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsValueTypeZeroInit();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBConversionOperator : VBOperator`1<ConversionOperatorDeclaration> {
    public bool IsExplicitCast { get; }
    public bool IsImplicitCast { get; }
    public VBConversionOperator(ConversionOperatorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsExplicitCast();
    public sealed virtual bool get_IsImplicitCast();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBDeclaredElement`1 : CachedTypeMemberBase {
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    protected VBDeclaredElement`1(IDeclaration declaration);
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    [CanBeNullAttribute]
public TDeclaration GetDeclaration();
    protected virtual bool CanBindTo(IDeclaration declaration);
    public virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public abstract virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsSynthetic();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBEnumMember : VBTypeMember`1<EnumMemberDeclaration> {
    [NotNullAttribute]
private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    [ThreadStaticAttribute]
private static JetHashSet`1<VBEnumMember> ourConstantCalculationsInProgress;
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public VBEnumMember(EnumMemberDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBEvent : VBOverridableMemberBase`1<EventDeclaration> {
    [CanBeNullAttribute]
private IAccessor myImplicitAdder;
    [CanBeNullAttribute]
private IAccessor myImplicitRemover;
    [CanBeNullAttribute]
private IAccessor myImplicitRaiser;
    protected IImplementsClause ImplementsClause { get; }
    public IType Type { get; }
    public IAccessor Adder { get; }
    public IAccessor Remover { get; }
    public IAccessor Raiser { get; }
    public bool IsFieldLikeEvent { get; }
    public IField EventField { get; }
    public IDelegate EventHandlerDelegate { get; }
    public VBEvent(EventDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    protected virtual bool CanBindTo(IDeclaration declaration);
    protected virtual IImplementsClause get_ImplementsClause();
    public sealed virtual IType get_Type();
    public sealed virtual IAccessor get_Adder();
    public sealed virtual IAccessor get_Remover();
    public sealed virtual IAccessor get_Raiser();
    public sealed virtual bool get_IsFieldLikeEvent();
    public sealed virtual IField get_EventField();
    public sealed virtual IDelegate get_EventHandlerDelegate();
    private IAccessor GetAccessorOfKind(AccessorKind kind);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBEventHandlerField : VBGeneratedFieldsBase`1<VBEvent> {
    private static string myEventFieldPostfix;
    public string ShortName { get; }
    public IType Type { get; }
    public IEvent ConstitutiveEvent { get; }
    public VBEventHandlerField(VBEvent event);
    public virtual string get_ShortName();
    public virtual IType get_Type();
    public IEvent get_ConstitutiveEvent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBEventHandlerPointer`1 : object {
    private bool myIsDelegate;
    private IDeclaredElementPointer`1<IEvent> myEventPointer;
    public VBEventHandlerPointer`1(IEvent constitutiveEvent, bool isDelegate);
    public sealed virtual T FindDeclaredElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBExternalMethod : VBMethodBase`1<ExternalMethodDeclaration> {
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    protected IImplementsClause ImplementsClause { get; }
    public bool IsStatic { get; }
    public VBExternalMethod(ExternalMethodDeclaration declaration);
    public virtual bool get_IsIterator();
    public virtual bool get_IsAsync();
    protected virtual IImplementsClause get_ImplementsClause();
    public virtual bool get_IsStatic();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBField : VBTypeMember`1<VariableDeclaration> {
    public IType Type { get; }
    public IField WithEventsField { get; }
    public bool IsField { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public VBField(VariableDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IType get_Type();
    public sealed virtual IField get_WithEventsField();
    public sealed virtual bool get_IsField();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBGeneratedFieldsBase`1 : object {
    private TTypeMember myConstitutive;
    public IType Type { get; }
    public string ShortName { get; }
    protected TTypeMember Constitutive { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IVBGeneratedField.Constitutive { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public ConstantValue ConstantValue { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public string XMLDocId { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    protected VBGeneratedFieldsBase`1(TTypeMember constitutive);
    public abstract virtual IType get_Type();
    public abstract virtual string get_ShortName();
    protected TTypeMember get_Constitutive();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.IVBGeneratedField.get_Constitutive();
    public virtual bool get_IsField();
    public virtual bool get_IsConstant();
    public virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public virtual ConstantValue get_ConstantValue();
    public virtual Nullable`1<int> get_FixedBufferSize();
    public virtual AccessibilityDomain get_AccessibilityDomain();
    public virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public virtual MemberHidePolicy get_HidePolicy();
    public virtual Nullable`1<Hash> CalcHash();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual IList`1<IDeclaration> GetDeclarations();
    public virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public virtual bool get_CaseSensitiveName();
    public virtual DeclaredElementType GetElementType();
    public virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    public virtual ITypeElement GetContainingType();
    public virtual ITypeMember GetContainingTypeMember();
    public virtual string get_XMLDocId();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public virtual bool IsValid();
    public virtual bool IsSynthetic();
    public virtual PsiLanguageType get_PresentationLanguage();
    public virtual IPsiModule get_Module();
    public virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public virtual ISubstitution get_IdSubstitution();
    public virtual AccessRights GetAccessRights();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBMethod : VBMethodBase`1<MethodDeclaration> {
    private int myHashCode;
    public bool IsPartial { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    protected IImplementsClause ImplementsClause { get; }
    public bool IsExtensionMethod { get; }
    public VBMethod(MethodDeclaration declaration);
    public virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual bool get_IsPartial();
    public virtual bool get_IsIterator();
    public virtual bool get_IsAsync();
    private bool CanBePartial();
    private static bool CanBePartial(MethodDeclaration declaration);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual IImplementsClause get_ImplementsClause();
    public virtual bool get_IsExtensionMethod();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBMethodBase`1 : VBOverridableMemberBase`1<TDeclaration> {
    public bool IsExtensionMethod { get; }
    public bool IsVarArg { get; }
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    protected VBMethodBase`1(TDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsVarArg();
    public abstract virtual bool get_IsIterator();
    public abstract virtual bool get_IsAsync();
    public virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBOperator`1 : VBTypeMember`1<TDeclaration> {
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IList`1<IParameter> Parameters { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public bool IsChecked { get; }
    protected VBOperator`1(TDeclaration declaration);
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual bool get_IsChecked();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBOverridableMemberBase`1 : VBTypeMember`1<TDeclaration> {
    [CanBeNullAttribute]
protected IImplementsClause ImplementsClause { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    protected VBOverridableMemberBase`1(TDeclaration declaration);
    protected abstract virtual IImplementsClause get_ImplementsClause();
    public virtual bool get_IsExplicitImplementation();
    public virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBParameter : VBDeclaredElement`1<RegularParameterDeclaration> {
    public IType Type { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsValueVariable { get; }
    public ParameterKind Kind { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public VBParameter(IDeclaration declaration);
    public sealed virtual IType get_Type();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual ISubstitution get_IdSubstitution();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    private static XmlNode GetParameterSummary(IParametersOwner baseMember, int index, bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBProperty : VBOverridableMemberBase`1<PropertyDeclaration> {
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IType Type { get; }
    public bool IsAuto { get; }
    public IAccessor Getter { get; }
    public IAccessor Setter { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    protected IImplementsClause ImplementsClause { get; }
    public IList`1<IParameter> Parameters { get; }
    public IField AutoField { get; }
    public VBProperty(PropertyDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IType get_Type();
    public sealed virtual bool get_IsAuto();
    private IAccessor Accessor(AccessorKind kind);
    public sealed virtual IAccessor get_Getter();
    public sealed virtual IAccessor get_Setter();
    public sealed virtual bool get_IsReadable();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsRequired();
    private sealed virtual override string JetBrains.ReSharper.Psi.IProperty.GetDefaultPropertyMetadataName();
    protected virtual IImplementsClause get_ImplementsClause();
    public virtual IList`1<IParameter> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IField get_AutoField();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBSignOperator : VBOperator`1<SignOperatorDeclaration> {
    public VBSignOperator(SignOperatorDeclaration declaration);
    public virtual DeclaredElementType GetElementType();
    public static string GetShortName(ISignOperatorDeclaration declaration);
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBTypeMember`1 : VBDeclaredElement`1<TDeclaration> {
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public ISubstitution IdSubstitution { get; }
    public string XMLDocId { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    protected VBTypeMember`1(TDeclaration declaration);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual AccessRights GetAccessRights();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public virtual MemberHidePolicy get_HidePolicy();
    public virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public virtual string get_XMLDocId();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBTypeParameterOfMethod : VBDeclaredElement`1<TypeParameterOfMethodDeclaration> {
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public bool IsNotNullableValueOrReferenceType { get; }
    public TypeParameterNullability Nullability { get; }
    public bool HasTypeConstraints { get; }
    public IList`1<IType> TypeConstraints { get; }
    public TypeParameterConstraintFlags Constraints { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public ITypeParametersOwner Owner { get; }
    public ITypeElement OwnerType { get; }
    public IParametersOwner OwnerFunction { get; }
    public IMethod OwnerMethod { get; }
    [CanBeNullAttribute]
private IMethodDeclarationBase MethodDeclaration { get; }
    public int Index { get; }
    public TypeParameterVariance Variance { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsUnmanagedType { get; }
    public bool HasDefaultConstructor { get; }
    public bool AllowsByRefLikeType { get; }
    public ISubstitution IdSubstitution { get; }
    public VBTypeParameterOfMethod(TypeParameterOfMethodDeclaration declaration);
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual bool get_IsNotNullableValueOrReferenceType();
    public sealed virtual TypeParameterNullability get_Nullability();
    public sealed virtual TypeParameterNullability GetNullability(ISubstitution explicitInheritorSubstitution);
    public sealed virtual bool get_HasTypeConstraints();
    public sealed virtual IList`1<IType> get_TypeConstraints();
    public sealed virtual TypeParameterConstraintFlags get_Constraints();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual ITypeParametersOwner get_Owner();
    public sealed virtual ITypeElement get_OwnerType();
    public sealed virtual IParametersOwner get_OwnerFunction();
    public sealed virtual IMethod get_OwnerMethod();
    private IMethodDeclarationBase get_MethodDeclaration();
    public sealed virtual int get_Index();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsUnmanagedType();
    public sealed virtual bool get_HasDefaultConstructor();
    public sealed virtual bool get_AllowsByRefLikeType();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    [CanBeNullAttribute]
private static XmlNode GetTypeParameterSummary(IMethod method, int index);
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeMember GetContainingTypeMember();
    private sealed virtual override IPsiSourceFile JetBrains.ReSharper.Psi.ITypeElement.GetSingleOrDefaultSourceFile();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IClrDeclaredElement.get_Module();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.IClrDeclaredElement.GetContainingType();
    private sealed virtual override PsiLanguageType JetBrains.ReSharper.Psi.IDeclaredElement.get_PresentationLanguage();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IDeclaredElement.GetPsiServices();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DeclaredElements.VBWithEventsField : VBGeneratedFieldsBase`1<IField> {
    public string ShortName { get; }
    public IType Type { get; }
    public VBWithEventsField(IField field);
    public virtual string get_ShortName();
    public virtual IType get_Type();
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private AttributeValue[] <GetAttributeInstances>b__6_0();
}
public class JetBrains.ReSharper.Psi.VB.Impl.DocComments.VBDocCommentElementFactory : ClrDocCommentElementFactoryImpl {
    protected Key`1<object> XmlResolveKey { get; }
    public VBDocCommentElementFactory(IDocCommentXmlPsi xmlPsi);
    protected virtual Key`1<object> get_XmlResolveKey();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.DocComments.VBDocCommentXmlPsi : ClrDocCommentXmlPsi`1<DocCommentBlock> {
    [NotNullAttribute]
public static Key`1<object> XmlResolveKey;
    private VBDocCommentXmlPsi(InjectedPsiHolderNode docCommentsHolder, DocCommentBlock docCommentBlock, IXmlFile xmlFile, bool isShifted);
    private static VBDocCommentXmlPsi();
    [NotNullAttribute]
public static VBDocCommentXmlPsi BuildPsi(DocCommentBlock block);
    [NotNullAttribute]
public static IReadOnlyList`1<string> GetCommentLines(DocCommentBlock block);
    protected virtual IReadOnlyList`1<ITreeNode> GetDocCommentNodes();
    protected virtual string GetDocCommentStartText(ITreeNode commentNode);
    public virtual void SubTreeChanged();
}
public class JetBrains.ReSharper.Psi.VB.Impl.FixUsagesCase : object {
    [ThreadStaticAttribute]
private static bool ourPreferSaveCase;
    public sealed virtual void Dispose();
    public static bool IsPreferSaveCase();
}
public class JetBrains.ReSharper.Psi.VB.Impl.ImportDirectivesSectionTreeNavigator : object {
    private IImportDirectivesSection mySection;
    public ImportDirectivesSectionTreeNavigator(IImportDirectivesSection section);
    public sealed virtual ITreeRange GetRange(ITreeNode node);
    public sealed virtual TreeNodeActionType GetAction(ITreeNode node);
    public sealed virtual bool IsSignificant(ITreeNode node);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Operators.LiftedResolveResult : ResolveResultWithSubstitution {
    public ISignOperator LiftedOperator { get; }
    public ISignOperator[] LiftedCandidates { get; }
    public LiftedResolveResult(IDeclaredElement basicOperator, ISubstitution substitution);
    public LiftedResolveResult(IList`1<IDeclaredElement> candidates, IList`1<ISubstitution> substitutions);
    internal static IResolveResult Create(IResolveResult resolveResult);
    public ISignOperator get_LiftedOperator();
    public ISignOperator[] get_LiftedCandidates();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Operators.LiftedResolveResult/<GetLiftedParametersOwners>d__7")]
public IEnumerable`1<DeclaredElementInstance`1<IParametersOwner>> GetLiftedParametersOwners();
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
}
[DefaultMemberAttribute("Item")]
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.VB.Impl.Operators.VBOperatorTable : object {
    private Dictionary`2<string, Action> myBinaryOperatorGenerators;
    private Dictionary`2<string, Action> myUnaryOperatorGenerators;
    private Dictionary`2<string, Dictionary`2<Pair`2<string, string>, Pair`2<string, string>>> myBinaryOperators;
    private Dictionary`2<string, Dictionary`2<Pair`2<string, string>, Pair`2<string, string>>> myBinaryOperatorsStrictOff;
    private Dictionary`2<string, Dictionary`2<string, string>> myUnaryOperators;
    private Dictionary`2<string, Dictionary`2<string, string>> myUnaryOperatorsStrictOff;
    private Dictionary`2<string, string> myNothingOperators;
    private JetHashSet`1<string> myEnumOperatorsSet;
    private bool myIsInitialized;
    public static VBOperatorTable Instance { get; }
    public IResolveResult Item { get; }
    public static VBOperatorTable get_Instance();
    private void InitializeOnDemand();
    private void InitNothingOperators();
    private void InitUnaryPlus();
    private void InitUnaryMinus();
    private void InitUnaryNot();
    private void UnaryOperatorsInit();
    private static IType EvaluateType(IPsiModule module, IType type);
    private static string GetTypeString(IType type);
    private IResolveResult GetUnaryOperatorResult(IPsiModule module, string name, bool strictOff, IExpressionType operandType);
    private IResolveResult GetUnaryOperatorResultImpl(IPsiModule module, string name, bool strictOff, IExpressionType operandType);
    private IResolveResult GetBinaryOperatorResult(IPsiModule module, string name, bool strictOff, IExpressionType left, IExpressionType right);
    private IResolveResult ResolveEnumOperator(string name, IType[] types);
    private IResolveResult ResolveBinaryOperator(IPsiModule module, Dictionary`2<string, Dictionary`2<Pair`2<string, string>, Pair`2<string, string>>> operators, string name, IType leftType, IType rightType);
    private IResolveResult GetBinaryOperatorResultImpl(IPsiModule module, string name, bool strictOff, IExpressionType left, IExpressionType right);
    [CanBeNullAttribute]
public ISignOperator GetBinaryOperatorByParametrsClrNames(string operatorName, IClrTypeName firstParameter, IClrTypeName secondParamter, IPsiModule module);
    public IResolveResult get_Item(IPsiModule module, string name, bool strictOff, IList`1<IExpressionType> argumentTypes);
    private void BinaryOperatorsInit();
    private void Init_BinaryBitwiseAnd();
    private void Init_BinaryAndAlso();
    private void Init_BinaryConcatenate();
    private void Init_BinaryDivide();
    private void Init_BinaryEquality();
    private void Init_BinaryExponent();
    private void Init_BinaryGreaterOrEqual();
    private void Init_BinaryLessThan();
    private void Init_BinaryInequality();
    private void Init_BinaryIntDivision();
    private void Init_BinaryLessOrEqual();
    private void Init_BinaryLeftShift();
    private void Init_BinaryLike();
    private void Init_BinaryGreaterThan();
    private void Init_BinaryMinus();
    private void Init_BinaryModulus();
    private void Init_BinaryMultiply();
    private void Init_BinaryBitwiseOr();
    private void Init_BinaryOrElse();
    private void Init_BinaryPlus();
    private void Init_BinaryRightShift();
    private void Init_BinaryBitwiseXor();
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Query.PositionalArgumentInfoBase : VBArgumentInfoBase {
    public IManagedConvertible ManagedConvertible { get; }
    protected PositionalArgumentInfoBase(IVBInvocationInfo invocation, IVBTreeNode element);
    public virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    public bool Equals(PositionalArgumentInfoBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryCallChainUtil : object {
    [NotNullAttribute]
public static void AnalyseQualifierOfReferenceOwner(IResolveContext resolveContext, IQueryReferenceOwnerImpl element, IVBExpression& expression, IQueryReferenceImpl& queryReference);
    [NotNullAttribute]
public static void AnalyseQualifier(IResolveContext resolveContext, IQueryReferenceOwnerImpl prevOwner, IVBExpression& expression, IQueryReferenceImpl& queryReference);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainExpressionTypeBase : object {
    protected IPsiModule myModule;
    public IPsiModule Module { get; }
    protected QueryChainExpressionTypeBase(IPsiModule module);
    public abstract virtual IExpressionType ExpressionType(IResolveContext context);
    public abstract virtual bool IsValid();
    public IPsiModule get_Module();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainTypeBase : QueryChainExpressionTypeBase {
    public string ShortName { get; }
    protected QueryChainTypeBase(IPsiModule module);
    public virtual IExpressionType ExpressionType(IResolveContext context);
    public abstract virtual string get_ShortName();
    [NotNullAttribute]
public abstract virtual IType Type(IResolveContext context);
    [NotNullAttribute]
public abstract virtual QueryChainTypeBase Append(QueryChainTypeOfElements element);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainTypeComplex : QueryChainTypeBase {
    private IList`1<QueryChainTypeBase> myElements;
    public string ShortName { get; }
    public QueryChainTypeComplex(IPsiModule module, QueryChainTypeBase[] elements);
    public virtual string get_ShortName();
    public virtual IType Type(IResolveContext context);
    public virtual QueryChainTypeBase Append(QueryChainTypeOfElements element);
    public virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainTypeFromExpression : QueryChainTypeBase {
    private IVBExpression myExpression;
    public string ShortName { get; }
    public QueryChainTypeFromExpression(IVBExpression expression);
    public virtual string get_ShortName();
    public virtual IType Type(IResolveContext context);
    public virtual QueryChainTypeBase Append(QueryChainTypeOfElements element);
    public virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainTypeOfAggregate : QueryChainTypeBase {
    private AggregateQueryOperator myAggregate;
    public string ShortName { get; }
    public QueryChainTypeOfAggregate(AggregateQueryOperator aggregate);
    public virtual string get_ShortName();
    public virtual IType Type(IResolveContext context);
    public virtual QueryChainTypeBase Append(QueryChainTypeOfElements element);
    public virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainTypeOfElements : QueryChainTypeBase {
    private IList`1<IQueryDeclaredElement> myElements;
    public string ShortName { get; }
    public QueryChainTypeOfElements(IPsiModule module, IList`1<IQueryDeclaredElement> elements);
    public QueryChainTypeOfElements(IPsiModule module, IQueryDeclaredElement elements);
    public virtual string get_ShortName();
    public virtual IType Type(IResolveContext context);
    public virtual QueryChainTypeBase Append(QueryChainTypeOfElements element);
    public virtual bool IsValid();
    [CompilerGeneratedAttribute]
private QueryChainTypeOfElements <Append>b__6_0(IQueryDeclaredElement x);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainTypeOfExpression : QueryChainExpressionTypeBase {
    private IVBExpression myExpression;
    public QueryChainTypeOfExpression(IVBExpression expression);
    public virtual IExpressionType ExpressionType(IResolveContext context);
    public virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainTypeOfPossiblyCastedQueryCollection : QueryChainExpressionTypeBase {
    private ICollectionRangeVariableDeclaration myRangeVariableDeclaration;
    public QueryChainTypeOfPossiblyCastedQueryCollection(ICollectionRangeVariableDeclaration rangeVariableDeclaration);
    public virtual IExpressionType ExpressionType(IResolveContext context);
    public virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryChainTypeOfQueryCollection : QueryChainTypeBase {
    private IVBExpression myExpression;
    public string ShortName { get; }
    public QueryChainTypeOfQueryCollection(IVBExpression expression);
    public virtual bool IsValid();
    public virtual string get_ShortName();
    public virtual IType Type(IResolveContext context);
    public virtual QueryChainTypeBase Append(QueryChainTypeOfElements element);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryCollectionTypeUtil : object {
    private static string SelectMethodName;
    private static string AsQueryableMethodName;
    private static string AsEnumerableMethodName;
    private static string CastMethodName;
    [CompilerGeneratedAttribute]
private bool <CastMethodIsUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AsEnumerableMethodIsUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AsQueryableMethodIsUsed>k__BackingField;
    public bool CastMethodIsUsed { get; private set; }
    public bool AsEnumerableMethodIsUsed { get; private set; }
    public bool AsQueryableMethodIsUsed { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_CastMethodIsUsed();
    [CompilerGeneratedAttribute]
private void set_CastMethodIsUsed(bool value);
    [CompilerGeneratedAttribute]
public bool get_AsEnumerableMethodIsUsed();
    [CompilerGeneratedAttribute]
private void set_AsEnumerableMethodIsUsed(bool value);
    [CompilerGeneratedAttribute]
public bool get_AsQueryableMethodIsUsed();
    [CompilerGeneratedAttribute]
private void set_AsQueryableMethodIsUsed(bool value);
    [NotNullAttribute]
public IType GetElementType(IVBExpression value, IResolveContext resolveContext, IVBTreeNode context);
    [NotNullAttribute]
public IType GetElementType(IType type, IVBExpression expressionOfCollectionType, IResolveContext resolveContext, IVBTreeNode context, bool canRedirect, IType& redirectedCollectionType, bool canCast);
    private IType TryFromSelectMethod(IVBTreeNode context, IType type, ISymbolTable typeSymbolTable, QualifierAccessContext accessContext, IPsiModule module);
    private IType TryFromRedirectedMethod(IVBTreeNode context, IType type, ISymbolTable typeSymbolTable, QualifierAccessContext accessContext, IPsiModule module, IVBExpression value, IResolveContext resolveContext, IType& redirectedCollectionType);
    private IType TryFromCastMethod(IVBTreeNode context, IType type, ISymbolTable typeSymbolTable, QualifierAccessContext accessContext, IPsiModule module, IType& collectionType);
    private IType TryAddExtension(IType type, IVBTreeNode context, string name, Func`3<IMethod, List`1<IType>, bool> action, Func`2<IType, IType> createValueOfCandidate);
    private IType TryAddInstance(ISymbolTable typeSymbolTable, QualifierAccessContext accessContext, IPsiModule module, string name, Func`3<IMethod, List`1<IType>, bool> addAction, Func`2<IType, IType> createValueOfCandidate);
    private bool AddExtensionCastMethod(IMethod method, List`1<IType> candidates, ITreeNode context, IType& castCollectionType);
    private bool AddInstanceCastMethod(IMethod method, List`1<IType> candidates, ITreeNode context, IType& castCollectionType);
    private bool AddInstanceRedirection(IType type, IMethod method, List`1<IType> redirectedCandidates, ITypeConversionRule typeConversionRule, IType& redirectedType);
    private bool AddExtensionRedirected(IMethod method, IType type, List`1<IType> redirectedCandidates, ITypeConversionRule typeConversionRule, IType& redirectedType);
    private bool AddExtensionSelect(IMethod method, List`1<IType> selectCandidates, IType type, ITypeConversionRule typeConversionRule);
    private bool AddInstanceSelect(IMethod method, List`1<IType> selectCandidates, IType type, ITypeConversionRule typeConversionRule);
    private bool AddSelect(IType actualType, ICollection`1<IType> selectCandidates, IParameter parameter, IType formalType, ITypeConversionRule typeConversionRule);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryEqualsSideSelector : object {
    private string myName;
    private bool myHasReference;
    public bool ProcessingIsFinished { get; }
    private QueryEqualsSideSelector(string name);
    public static bool HasReferenceTo(IVBExpression expression, string name);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public static class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryIndexerUtil : object {
    private static string ElementAtOrDefaultName;
    public static ResolveResultWithInfo TryResolveQueryIndexer(IResolveContext resolveContext, IType type, IVBInvocationInfo invocation, IVBExpression expressionOfCollectionType, IAccessContext accessContext);
    private static ResolveResultWithInfo ResolveQueryIndexer(IResolveContext resolveContext, IType type, IAccessContext accessContext, IVBInvocationInfo invocation, IVBTreeNode element);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryLambdaArgument : PositionalArgumentInfoBase {
    private IList`1<QueryChainTypeBase> myParameterTypes;
    private QueryChainExpressionTypeBase myReturnType;
    private int myEqualityIndex;
    public QueryLambdaArgument(IList`1<QueryChainTypeBase> parametersChainTypes, IVBInvocationInfo invocation, IVBTreeNode owner, QueryChainExpressionTypeBase returnType, int index);
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public bool Equals(QueryLambdaArgument obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryLambdaExpressionType : VBLambdaExpressionTypeBase {
    private IList`1<QueryChainTypeBase> myLambdaParameterTypes;
    private QueryChainExpressionTypeBase myLambdaReturnType;
    [CompilerGeneratedAttribute]
private IVBTreeNode <VerificationScope>k__BackingField;
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public IVBTreeNode VerificationScope { get; }
    public QueryLambdaExpressionType(IResolveContext context, IList`1<QueryChainTypeBase> lambdaParameterTypes, QueryChainExpressionTypeBase lambdaReturnType, IVBTreeNode scope);
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    [CompilerGeneratedAttribute]
public virtual IVBTreeNode get_VerificationScope();
    public virtual IReadOnlyList`1<ILambdaParameter> GetImplicitLambdaParameters();
    public virtual IType CreateFunctionType();
    public virtual bool HasImplicitLambdaParameters();
    public virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> GetParameterTypesAndKinds();
    protected virtual IExpressionType InferResultType();
    public virtual bool IsValid();
    [CompilerGeneratedAttribute]
private Pair`2<IType, ParameterKind> <GetParameterTypesAndKinds>b__13_0(QueryChainTypeBase x);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.QueryVariablesCache : object {
    private QueryExpression myExpression;
    [CompilerGeneratedAttribute]
private OneToListMap`2<IQueryCallsChainOwner, IQueryReferenceOwner> <OwnersToChainsMap>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<IQueryParameterPlatform, IQueryDeclaredElement> <Variables>k__BackingField;
    [NotNullAttribute]
private Dictionary`2<IQueryReferenceOwner, QueryChainTypeBase> myChainTypes;
    private Stack`1<IEnumerable`1<IQueryDeclaredElement>> myGlobalScopes;
    [NotNullAttribute]
public OneToListMap`2<IQueryCallsChainOwner, IQueryReferenceOwner> OwnersToChainsMap { get; private set; }
    [NotNullAttribute]
public OneToListMap`2<IQueryParameterPlatform, IQueryDeclaredElement> Variables { get; private set; }
    internal QueryVariablesCache(QueryExpression expression);
    [CompilerGeneratedAttribute]
public OneToListMap`2<IQueryCallsChainOwner, IQueryReferenceOwner> get_OwnersToChainsMap();
    [CompilerGeneratedAttribute]
private void set_OwnersToChainsMap(OneToListMap`2<IQueryCallsChainOwner, IQueryReferenceOwner> value);
    [CompilerGeneratedAttribute]
public OneToListMap`2<IQueryParameterPlatform, IQueryDeclaredElement> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(OneToListMap`2<IQueryParameterPlatform, IQueryDeclaredElement> value);
    [CanBeNullAttribute]
public QueryChainTypeBase GetQueryChainType(IQueryReferenceOwner owner);
    public void Build();
    private void BuildChainTypes();
    private void Visit(IQueryExpression expression, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitOperator(IQueryOperator operator, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitFrom(IFromQueryOperator fromClause, IEnumerable`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitGroupJoin(IGroupJoinQueryOperator groupJoin, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitGroup(IGroupByQueryOperator group, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitOrder(IOrderByQueryOperator order, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitPartition(IPartitionQueryOperator partition, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitDistinct(IDistinctQueryOperator distinct, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitWhere(IWhereQueryOperator where, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitSelect(ISelectQueryOperator select, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitLet(ILetQueryOperator let, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private List`1<IQueryDeclaredElement> VisitJoin(IJoinQueryOperator join, List`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner, bool underGroupJoin);
    private List`1<IQueryDeclaredElement> VisitAggregate(IAggregateQueryOperator aggregateQueryOperator, IEnumerable`1<IQueryDeclaredElement> scopeElements, IQueryCallsChainOwner chainOwner);
    private GlobalDeclarationsScope GlobalContext(IEnumerable`1<IQueryDeclaredElement> scopeElements);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Query.QueryVariablesCache/<WithGlobal>d__29")]
private IEnumerable`1<IQueryDeclaredElement> WithGlobal(IEnumerable`1<IQueryDeclaredElement> scopeElements);
    public IQueryReferenceOwnerImpl GetPreviousOperator(IQueryReferenceOwner queryReferenceOwner);
    public IQueryReferenceOwnerImpl GetNextOperator(IQueryReferenceOwner queryReferenceOwner);
    public int GetPositionInChain(IQueryReferenceOwnerImpl owner);
    [NotNullAttribute]
public IExpressionType GetChainReturnType(IQueryCallsChainOwner chainOwner, IResolveContext resolveContext);
    [NotNullAttribute]
public IExpressionType GetReturnType(IQueryReferenceOwnerImpl owner, IResolveContext resolveContext);
    public IQueryReferenceOwnerImpl GetLastChainReferenceOwner(IQueryCallsChainOwner expression);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Query.UnliftedChainType : QueryChainExpressionTypeBase {
    private QueryChainExpressionTypeBase myReturnType;
    public UnliftedChainType(QueryChainExpressionTypeBase returnType);
    public virtual IExpressionType ExpressionType(IResolveContext context);
    public virtual bool IsValid();
}
public enum JetBrains.ReSharper.Psi.VB.Impl.ReSharperSettingsVBLanguageLevel : Enum {
    public int value__;
    public static ReSharperSettingsVBLanguageLevel Default;
    public static ReSharperSettingsVBLanguageLevel Vb8;
    public static ReSharperSettingsVBLanguageLevel Vb9;
    public static ReSharperSettingsVBLanguageLevel Vb10;
    public static ReSharperSettingsVBLanguageLevel Vb11;
    public static ReSharperSettingsVBLanguageLevel Vb12;
    public static ReSharperSettingsVBLanguageLevel Vb14;
    public static ReSharperSettingsVBLanguageLevel Vb15;
    public static ReSharperSettingsVBLanguageLevel Vb15_3;
    public static ReSharperSettingsVBLanguageLevel Vb15_5;
    public static ReSharperSettingsVBLanguageLevel Vb16;
    public static ReSharperSettingsVBLanguageLevel Vb16_9;
    public static ReSharperSettingsVBLanguageLevel Latest;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Impl.ReSharperSettingsVBLanguageLevelExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<VBLanguageLevel> ToPsiLanguageLevel(ReSharperSettingsVBLanguageLevel languageLevel);
    [ExtensionAttribute]
[PureAttribute]
public static ReSharperSettingsVBLanguageLevel ToSettingsLanguageLevel(VBLanguageLevel languageLevel);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ArgumentMatch : ValueType {
    [CompilerGeneratedAttribute]
private IParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IVBArgumentInfo <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpandedKind <Expanded>k__BackingField;
    [CanBeNullAttribute]
public IParameter Parameter { get; }
    public IVBArgumentInfo Argument { get; }
    internal ExpandedKind Expanded { get; private set; }
    internal ArgumentMatch(IVBArgumentInfo argument, IParameter parameter, ExpandedKind expanded);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IParameter get_Parameter();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IVBArgumentInfo get_Argument();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal ExpandedKind get_Expanded();
    [CompilerGeneratedAttribute]
private void set_Expanded(ExpandedKind value);
    internal void FixExpanded(bool expanded);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ArgumentsMatcher : object {
    private IList`1<IVBArgumentInfo> myArguments;
    public ArgumentsMatcher(IList`1<IVBArgumentInfo> arguments);
    public bool CheckParametersCount(IList`1<IParameter> parameters);
    internal Nullable`1<ArgumentsMatchResult> ResolveMatch(DeclaredElementInstance`1<IParametersOwner> parametersOwner, IMatchingPolicy matchingPolicy, VBLanguageLevel languageLevel);
    internal Nullable`1<ArgumentsMatchResult> ResolveMatch(IList`1<IParameter> parameters, IMatchingPolicy matchingPolicy, VBLanguageLevel languageLevel);
    public Nullable`1<ArgumentsMatchResult> Match(IParametersOwner owner, VBLanguageLevel languageLevel);
    [NotNullAttribute]
public static IType GetParameterMultitype(IResolveContext resolveContext, IVBArgumentInfo argumentInfo);
    [NotNullAttribute]
public static IType GetParameterType(IResolveContext resolveContext, IVBArgumentInfo argumentInfo);
    [NotNullAttribute]
public static IType GetParameterInstanceType(IResolveContext resolveContext, DeclaredElementInstance`1<IParameter> parameterInstance, IVBArgumentInfo argumentInfo);
    [NotNullAttribute]
public static IType GetParameterInstanceType(IResolveContext resolveContext, DeclaredElementInstance`1<IParameter> parameterInstance, IVBArgumentInfo argumentInfo, Boolean& isExpanded);
    public static DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IResolveContext resolveContext, IVBArgumentInfo argumentInfo);
    public static IArgumentsMatcher CreateResolveMatcher(IList`1<IVBArgumentInfo> arguments, bool isExtension);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Resolve.ArgumentsMatcher/<GetAllParametersMatchingArgument>d__12")]
public static IEnumerable`1<DeclaredElementInstance`1<IParameter>> GetAllParametersMatchingArgument(IResolveContext resolveContext, IVBArgumentInfo argumentInfo);
    public static DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IVBArgumentInfo argumentInfo, DeclaredElementInstance`1<IParametersOwner> elementInstance);
    internal static DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IVBArgumentInfo argumentInfo, IList`1<IParameter> parameters, ISubstitution substitution);
    public static bool IsInvocationExpanded(IVBInvocationInfo invocation);
    public static bool IsExpanded(IVBArgumentInfo argumentInfo);
    public static bool IsExpanded(DeclaredElementInstance`1<IParameter> parameterInstance, IVBArgumentInfo argumentInfo);
    public static IList`1<IVBArgumentInfo> GetArgumentMatchingParameter(IParameter parameter, IVBInvocationInfo invocation, Boolean& isExpanded);
    public static DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IVBArgumentInfo argumentInfo);
    public static IEnumerable`1<DeclaredElementInstance`1<IParameter>> GetAllParametersMatchingArgument(IVBArgumentInfo argumentInfo);
    public static IType GetParameterInstanceType(DeclaredElementInstance`1<IParameter> instance, IVBArgumentInfo argumentInfo, Boolean& expanded);
    public static IType GetParameterType(IVBArgumentInfo argumentInfo);
    public static IType GetParameterMultitype(IVBArgumentInfo argumentInfo);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ArgumentsMatcherExtensions : object {
    [ExtensionAttribute]
public static DeclaredElementInstance`1<IParameter> GetMatchingParameter(IVBArgumentInfo argumentInfo, DeclaredElementInstance`1<IParametersOwner> elementInstance);
    [ExtensionAttribute]
public static DeclaredElementInstance`1<IParameter> GetMatchingParameter(IVBArgumentInfo argumentInfo, IResolveContext resolveContext);
    [ExtensionAttribute]
public static DeclaredElementInstance`1<IParameter> GetMatchingParameter(IVBArgumentInfo argumentInfo);
    [ExtensionAttribute]
public static IEnumerable`1<DeclaredElementInstance`1<IParameter>> GetAllMatchingParameters(IVBArgumentInfo argumentInfo, IResolveContext resolveContext);
    [ExtensionAttribute]
public static IEnumerable`1<DeclaredElementInstance`1<IParameter>> GetAllMatchingParameters(IVBArgumentInfo argumentInfo);
    [ExtensionAttribute]
[NotNullAttribute]
public static IType GetParameterType(IVBArgumentInfo argumentInfo, IResolveContext resolveContext);
    [ExtensionAttribute]
public static IType GetParameterType(IVBArgumentInfo argumentInfo);
    [ExtensionAttribute]
[NotNullAttribute]
public static IType GetParameterMultitype(IVBArgumentInfo argumentInfo, IResolveContext resolveContext);
    [ExtensionAttribute]
public static IType GetParameterMultitype(IVBArgumentInfo argumentInfo);
    [ExtensionAttribute]
public static bool IsExpanded(IVBArgumentInfo argumentInfo, DeclaredElementInstance`1<IParameter> parameterInstance);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Resolve.ArgumentsMatcherExtensions/<MatchResultWithTypes>d__10")]
[ExtensionAttribute]
public static IEnumerable`1<ArgumentMatchWithType> MatchResultWithTypes(ArgumentsMatchResult matchResult, IResolveContext resolveContext, ISubstitution inferedSubstitution);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Resolve.ArgumentsMatcherExtensions/<MatchThrouhtTuples>d__11")]
[ExtensionAttribute]
public static IEnumerable`1<ArgumentMatchWithType> MatchThrouhtTuples(IEnumerable`1<ArgumentMatchWithType> matchResultWithTypes);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Resolve.ArgumentsMatcherExtensions/<Processor>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<Tuple`4<IVBArgumentInfo, IParameter, IType, bool>> Processor(ArgumentsMatchResult matchResult);
    public static int GetParameterIndexByName(IList`1<IParameter> parameters, string name, int startIndex);
    public static int GetParameterIndexByName(IParametersOwner owner, string name);
    [NotNullAttribute]
public static IType GetParameterType(IParameter parameter, bool isExpanded);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ArgumentsMatchResult : ValueType {
    private ArgumentMatch[] myArgumentsMatch;
    internal ArgumentsMatchResult(ArgumentMatch[] argumentsMatch);
    [PureAttribute]
public ArgumentMatch GetMatchedByArgumentIndex(int argumentIndex);
    [PureAttribute]
public Nullable`1<ArgumentMatch> GetMatchedByArgument(IVBArgumentInfo argumentInfo);
    [PureAttribute]
public ICollection`1<ArgumentMatch> GetMatched();
    internal void FixExpandedLast(bool expanded);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.BadArgumentInfo : object {
    private IVBInvocationInfo myInvocation;
    public DeclaredElementInstance`1<IParameter> MatchingParameter { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public IPsiModule PsiModule { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public IVBInvocationInfo Invocation { get; }
    public ArgumentKind Kind { get; }
    public string ArgumentName { get; }
    public IManagedConvertible ManagedConvertible { get; }
    public BadArgumentInfo(IVBInvocationInfo invocation);
    public sealed virtual DeclaredElementInstance`1<IParameter> get_MatchingParameter();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual DocumentRange GetDocumentRange();
    public sealed virtual bool IsValid();
    public sealed virtual IVBInvocationInfo get_Invocation();
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual string get_ArgumentName();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    public bool Equals(BadArgumentInfo obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ConditionalExtensionArgumentInfoWithQualifier : ExtensionArgumentInfoWithQualifier {
    public ConditionalExtensionArgumentInfoWithQualifier(IVBExpression expression, IVBInvocationInfo invocation);
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ConstructorQualifier : object {
    [NotNullAttribute]
private IVBExpression myQualifier;
    public bool Resolved { get; }
    public ConstructorQualifier(IVBExpression qualifier);
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public static ISymbolTable CreateSymbolTable(IVBExpression qualifier, SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public sealed virtual ITypeElement GetQualifierTypeElement();
}
public enum JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExpandedKind : Enum {
    public int value__;
    public static ExpandedKind NoneExpanded;
    public static ExpandedKind IsExpanded;
    public static ExpandedKind CanBeExpanded;
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExpressionAccessContext : object {
    private IVBExpression myExpression;
    private IQualifierWithTypeElement myQualifier;
    public ExpressionAccessContext(IVBExpression expression, IQualifierWithTypeElement qualifier);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExpressionArgumentInfo : PositionalArgumentInfoBase {
    public IVBExpression Expression { get; }
    public ExpressionArgumentInfo(IVBInvocationInfo invocation, IVBExpression expression);
    public IVBExpression get_Expression();
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
    public bool Equals(ExpressionArgumentInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExpressionQualifier : object {
    [NotNullAttribute]
private IResolveContext myResolveContext;
    [NotNullAttribute]
private IVBExpression myExpression;
    public bool Resolved { get; }
    public ExpressionQualifier(IVBExpression expression);
    public ExpressionQualifier(IResolveContext resolveContext, IVBExpression expression);
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    [NotNullAttribute]
public sealed virtual IExpressionType GetQualifierExpressionType();
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionArgumentInfoBase : object {
    private IVBInvocationInfo myInvocation;
    public DeclaredElementInstance`1<IParameter> MatchingParameter { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public IPsiModule PsiModule { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public IManagedConvertible ManagedConvertible { get; }
    public IVBInvocationInfo Invocation { get; }
    public ArgumentKind Kind { get; }
    public string ArgumentName { get; }
    protected ExtensionArgumentInfoBase(IVBInvocationInfo invocation);
    public sealed virtual DeclaredElementInstance`1<IParameter> get_MatchingParameter();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public virtual DocumentRange GetDocumentRange();
    public virtual bool IsValid();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public abstract virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
    public sealed virtual IVBInvocationInfo get_Invocation();
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual string get_ArgumentName();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    public bool Equals(ExtensionArgumentInfoBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionArgumentInfoWithQualifier : ExtensionArgumentInfoBase {
    private IVBExpression myExpression;
    protected IVBExpression Expression { get; }
    public ExtensionArgumentInfoWithQualifier(IVBExpression expression, IVBInvocationInfo invocation);
    protected IVBExpression get_Expression();
    public virtual DocumentRange GetDocumentRange();
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
    public virtual bool IsValid();
    public bool Equals(ExtensionArgumentInfoWithQualifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionArgumentInfoWithType : ExtensionArgumentInfoBase {
    private IType myQualifierType;
    public ExtensionArgumentInfoWithType(IType qualifierType, IVBInvocationInfo invocation);
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool IsValid();
    public bool Equals(ExtensionArgumentInfoWithType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethodArgumentsMatcher : object {
    private ArgumentsMatcher myArgumentsMatcher;
    public ExtensionMethodArgumentsMatcher(IList`1<IVBArgumentInfo> arguments);
    public sealed virtual bool CheckParametersCount(IList`1<IParameter> parameters);
    public sealed virtual Nullable`1<ArgumentsMatchResult> Match(DeclaredElementInstance`1<IParametersOwner> parametersOwner, IMatchingPolicy matchingPolicy, VBLanguageLevel languageLevel);
    public sealed virtual DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IVBArgumentInfo argumentInfo, DeclaredElementInstance`1<IParametersOwner> elementInstance);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethods.ExtensionMethodsSymbolTableBuilder : object {
    [NotNullAttribute]
private IType myType;
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IList`1<Tuple`3<INamespace, IImportNamespaceClause, int>> myImportedNamespaces;
    [NotNullAttribute]
private IList`1<Tuple`3<ITypeElement, IImportNamespaceClause, int>> myImportedTypes;
    [NotNullAttribute]
private IExtensionMethodsQuery myQuery;
    public ExtensionMethodsSymbolTableBuilder(IVBTreeNode element, IType type);
    public bool HasExtensionMethod(string shortName);
    [NotNullAttribute]
public ISymbolTable GetSymbolTable();
    [NotNullAttribute]
public ISymbolTable GetSymbolTable(string shortName);
    [NotNullAttribute]
public IEnumerable`1<DeclaredElementInstance`1<IMethod>> GetExtensionMethods(string shortName);
    [NotNullAttribute]
private IEnumerable`1<ISymbolInfo> EnumerateExtensionMethods(string shortName);
    [NotNullAttribute]
private static ISymbolInfo CreateSymbolInfo(IMethod method, ISubstitution substitution, IImportNamespaceClause clause, int level);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethods.ExtensionMethodsSymbolTableBuilder/<EnumerateExtensionMethods>d__12`1")]
[NotNullAttribute]
private IEnumerable`1<T> EnumerateExtensionMethods(string shortName, Func`5<IMethod, ISubstitution, IImportNamespaceClause, int, T> creator);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethods.ExtensionMethodsSymbolTableBuilder/<EnumerateExtensionMethods>d__13`1")]
private IEnumerable`1<T> EnumerateExtensionMethods(IEnumerable`1<IMethod> methods, Func`3<IMethod, ISubstitution, T> creator);
    [CanBeNullAttribute]
public static ISubstitution InferSubstitution(IMethod method, IType type, IPsiModule module);
    public static bool CheckExtensionMethodConsistency(IMethod method);
    public static ExtensionMethodAccessibility IsExtensionMethodAccessible(IPsiModule module, IMethod method);
}
public static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethods.VBBaseTypesIteratorUtil : object {
    public static List`1<IType> GetBaseTypes(IType type);
    public static List`1<IType> GetBaseTypes(IType type, bool includeThisType);
    public static bool IterateBaseTypes(IType type, Func`2<IType, bool> consumer, bool includeThisType);
    private static IType GetElemetnType(IArrayType arrayType);
    private static bool NonArrayBases(IType type, Func`2<IType, bool> consumer);
    private static bool VisitDeclaredType(IDeclaredType declaredType, Func`2<IType, bool> consumer);
    private static bool VisitDeclaredType(IDeclaredType type, JetHashSet`1<ITypeElement> visited, Func`2<IType, bool> consumer);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethods.VBExtensionMethodsRegistryImpl : VBExtensionMethodsRegistry {
    [NotNullAttribute]
private ISolution mySolution;
    public VBExtensionMethodsRegistryImpl(ISolution solution);
    public virtual IExtensionMethodsQuery GetAllExtensionMethods();
}
public static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethods.VBExtensionMethodUtil : object {
    [CanBeNullAttribute]
public static IType GetQualifierType(IVBArgumentInfo qualifier, IResolveContext resolveContext);
    [NotNullAttribute]
public static IReadOnlyList`1<ITypeParameter> InferableTypeParametersOfExtensionMethod(IMethod method);
    public static Pair`2<IList`1<Tuple`3<INamespace, IImportNamespaceClause, int>>, IList`1<Tuple`3<ITypeElement, IImportNamespaceClause, int>>> AllExtensionMethodsProviders(IVBTreeNode element);
    private static Pair`2<IList`1<Tuple`3<INamespace, IImportNamespaceClause, int>>, IList`1<Tuple`3<ITypeElement, IImportNamespaceClause, int>>> ImportedDirectives(IVBTreeNode element, int level);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethods.VBExtensionMethodUtil/<EnumerateModuleExtensionMethods>d__4")]
[NotNullAttribute]
public static IEnumerable`1<IMethod> EnumerateModuleExtensionMethods(ITypeElement typeElement, string shortName);
    public static bool SomeExtensionMethodIsAccessible(IVBArgumentInfo qualifier, IResolveContext resolveContext, IAccessContext accessContext, IVBTreeNode context, string name);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ExtensionMethods.VBRequest : object {
    [NotNullAttribute]
public static IRequest Empty;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<INamespace> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITypeElement> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <ForModule>k__BackingField;
    [CanBeNullAttribute]
private IReadOnlyList`1<IType> myBaseTypes;
    public string Name { get; }
    public bool IsCaseSensitive { get; }
    public IType ExpressionType { get; }
    public IReadOnlyList`1<INamespace> Namespaces { get; }
    public IReadOnlyList`1<ITypeElement> Types { get; }
    public IPsiModule ForModule { get; }
    public IReadOnlyList`1<IType> BaseExpressionTypes { get; }
    private VBRequest(string name, IType expressionType, IReadOnlyList`1<INamespace> namespaces, IReadOnlyList`1<ITypeElement> types, IPsiModule forModule, IReadOnlyList`1<IType> baseTypes);
    private static VBRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpressionType();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<INamespace> get_Namespaces();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ITypeElement> get_Types();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_ForModule();
    public sealed virtual IReadOnlyList`1<IType> get_BaseExpressionTypes();
    public sealed virtual IRequest WithName(string newName);
    public sealed virtual IRequest WithExpressionType(IType newType);
    public sealed virtual IRequest WithModule(IPsiModule psiModule);
    public sealed virtual IRequest WithNamespaces(IReadOnlyList`1<INamespace> newNamespaces);
    public sealed virtual IRequest WithTypes(IReadOnlyList`1<ITypeElement> newTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.AllEventsFilter : SimpleSymbolFilter {
    public static AllEventsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static AllEventsFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.AllFieldsFilter : AllFilter`1<IField> {
    public static AllFieldsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static AllFieldsFilter();
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.AllFilter`1 : object {
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public abstract virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.AllMethodsFilter : AllFilter`1<IMethod> {
    public static AllMethodsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static AllMethodsFilter();
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.AllNotOperatorsFilter : SimpleSymbolFilter {
    public static AllNotOperatorsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static AllNotOperatorsFilter();
    public virtual ResolveErrorType get_ErrorType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.AllTypesFilter : AllFilter`1<ITypeElement> {
    public static AllTypesFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static AllTypesFilter();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.ApplicableToDelegateFilter : object {
    private IDelegate myDelegate;
    private ISubstitution mySubstitution;
    private IVBExpression myExpression;
    private IVBTypeConversionRule myRule;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ApplicableToDelegateFilter(IDelegate delegate, ISubstitution substitution, IVBExpression expression, IVBTypeConversionRule rule);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.ClassTypeParameterNumberFilter : SimpleSymbolFilter {
    [CompilerGeneratedAttribute]
private int <typeParameterCount>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ClassTypeParameterNumberFilter(int typeParameterCount);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.CoClassEventFilter : object {
    private static IClrTypeName ourCoClassAttribute;
    private IInterface myQualifierInterface;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public CoClassEventFilter(IInterface qualifierInterface);
    private static CoClassEventFilter();
    private bool HasSomebodyCoClassAttribute(IInterface methodInterface, IInterface eventInterface);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.CTypeDynamicFilter : SimpleSymbolFilter {
    public static ISymbolFilter INSTANCE;
    private static string CTypeDynamicName;
    private static string ConversionTypeName;
    private static string ConversionTypeFullName;
    public ResolveErrorType ErrorType { get; }
    private static CTypeDynamicFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.DefaultPropertyFilter : SimpleSymbolFilter {
    public static DefaultPropertyFilter INSTANCE;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    private static DefaultPropertyFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.ExtensionBetterThanNonInstanceFilter : object {
    private JetHashSet`1<ITypeElement> myInstanceTypes;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ExtensionBetterThanNonInstanceFilter(ITypeElement containingTypeElement);
    [NullableContextAttribute("2")]
public static ISymbolFilter GetInstance(IVBExpression qualifier, IVBTreeNode context);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.ExtensionMethodsLevelFilter : object {
    public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static ExtensionMethodsLevelFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.FieldThanEventFieldFilter : object {
    public static FieldThanEventFieldFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static FieldThanEventFieldFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.GeneratedInstancesFilter : SimpleSymbolFilter {
    public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static GeneratedInstancesFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.InterfaceMemberSpecifierSignatureFilter : SimpleSymbolFilter {
    private DeclaredElementType myElementType;
    [NullableAttribute("2")]
private InvocableSignature mySignature;
    [NullableAttribute("2")]
private IType myReturnType;
    public ResolveErrorType ErrorType { get; }
    public InterfaceMemberSpecifierSignatureFilter(IDeclaredElement element);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.MemberInitializerFilter : SimpleSymbolFilter {
    private IAccessContext myAccessContext;
    private ITreeNode myUsageContext;
    public ResolveErrorType ErrorType { get; }
    public MemberInitializerFilter(IAccessContext accessContext, ITreeNode usageContext);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.MethodTypeParameterNumberFilter : SimpleSymbolInfoFilter {
    [CompilerGeneratedAttribute]
private int <typeParameterCount>P;
    public ResolveErrorType ErrorType { get; }
    public MethodTypeParameterNumberFilter(int typeParameterCount);
    public virtual bool Accepts(ISymbolInfo info);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.PublicThanProtectedFilter : object {
    public static PublicThanProtectedFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static PublicThanProtectedFilter();
    private bool IsProtected(AccessRights accessRights);
    [NullableContextAttribute("2")]
private bool HasEqualSignatures(IParametersOwner parametersOwner1, IParametersOwner parametersOwner2);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.SkipAccessorsFilter : SimpleSymbolFilter {
    public static SkipAccessorsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static SkipAccessorsFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.TypeThanNamespaceFilter : object {
    public static TypeThanNamespaceFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static TypeThanNamespaceFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.UseLocalVariableBeforeDeclarationFilter : UseLocalVariableBeforeDeclarationFilterBase {
    protected bool IsCaseSensitive { get; }
    public ResolveErrorType ErrorType { get; }
    public UseLocalVariableBeforeDeclarationFilter(ITreeNode usage);
    protected virtual bool get_IsCaseSensitive();
    protected virtual ITreeNode GetDeclarationNode(IDeclaredElement element);
    protected virtual bool UsedBeforeDeclaration(ITreeNode declaration, PooledList`1& usagePathToRoot, PooledList`1& declarationPathToRoot);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBAccessRightsFilter : AccessRightsFilter {
    public VBAccessRightsFilter(IAccessContext context);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBAttributeFilter : object {
    public static VBAttributeFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static VBAttributeFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBInitializerReferenceFilter : InitializerReferenceFilter {
    public VBInitializerReferenceFilter(IAccessContext context, ITreeNode element);
    protected virtual IDeclaredElement GetInitializerOwner(ITreeNode element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBLastCandidateIsLocalFilter : object {
    public static VBLastCandidateIsLocalFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static VBLastCandidateIsLocalFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBMemberFilter : SimpleSymbolFilter {
    public static VBMemberFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static VBMemberFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBMethodGroupConvertibleFilter : SimpleSymbolFilter {
    private DeclaredElementInstance`1<IDelegate> myDelegate;
    private VBLanguageLevel myLanguageLevel;
    private IVBTypeConversionRule myRule;
    public ResolveErrorType ErrorType { get; }
    public VBMethodGroupConvertibleFilter(DeclaredElementInstance`1<IDelegate> expectedType, VBLanguageLevel languageLevel, IVBTypeConversionRule rule);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBOverriddenFilter : OverriddenFilter`1<ISymbolInfo> {
    public static VBOverriddenFilter INSTANCE;
    private static VBOverriddenFilter();
    protected virtual bool IsShadowed(ISymbolInfo left, int leftIndex, ISymbolInfo right, int rightIndex, IList`1<ISymbolInfo> data, Object[]& additionalData);
    protected virtual ISymbolInfo GetSymbolInfo(ISymbolInfo symbolInfo);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBStaticCompletionFilter : SimpleSymbolInfoFilter {
    private IAccessContext myContext;
    public ResolveErrorType ErrorType { get; }
    public VBStaticCompletionFilter(IAccessContext context);
    public virtual bool Accepts(ISymbolInfo info);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Filters.VBValidNamesFilter : ValidNamesFilter {
    [NullableAttribute("1")]
public static VBValidNamesFilter INSTANCE;
    private static VBValidNamesFilter();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.IArgumentsMatcher {
    public abstract virtual bool CheckParametersCount(IList`1<IParameter> parameters);
    public abstract virtual Nullable`1<ArgumentsMatchResult> Match(DeclaredElementInstance`1<IParametersOwner> parametersOwner, IMatchingPolicy matchingPolicy, VBLanguageLevel languageLevel);
    [CanBeNullAttribute]
public abstract virtual DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IVBArgumentInfo argumentInfo, DeclaredElementInstance`1<IParametersOwner> elementInstance);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Invocation : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IVBTreeNode <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private VBLanguageLevel <LanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private IVBTypeConversionRule <TypeConversionRule>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccessContext <AccessContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolFilter[] <PreInvocationFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolTable <SymbolTable>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IType> <TypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IVBArgumentInfo> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IVBArgumentInfo <Qualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeInferenceRule <TypeInferenceRule>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ISymbolInfo> <ExtensionMethodCandidates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictOffMethodGroup>k__BackingField;
    [NotNullAttribute]
private string Name { get; private set; }
    [NotNullAttribute]
private IResolveContext ResolveContext { get; private set; }
    [NotNullAttribute]
private IVBTreeNode Context { get; private set; }
    [NotNullAttribute]
private VBLanguageLevel LanguageLevel { get; private set; }
    [NotNullAttribute]
private IPsiModule Module { get; private set; }
    [NotNullAttribute]
private IVBTypeConversionRule TypeConversionRule { get; private set; }
    [NotNullAttribute]
private IAccessContext AccessContext { get; private set; }
    [NotNullAttribute]
private ISymbolFilter[] PreInvocationFilters { get; private set; }
    [NotNullAttribute]
private ISymbolTable SymbolTable { get; private set; }
    [NotNullAttribute]
private IList`1<IType> TypeArguments { get; private set; }
    [NotNullAttribute]
private IList`1<IVBArgumentInfo> Arguments { get; private set; }
    [CanBeNullAttribute]
private IVBArgumentInfo Qualifier { get; private set; }
    [NotNullAttribute]
private ITypeInferenceRule TypeInferenceRule { get; private set; }
    [CanBeNullAttribute]
private IList`1<ISymbolInfo> ExtensionMethodCandidates { get; private set; }
    private bool StrictOffMethodGroup { get; private set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
private void set_ResolveContext(IResolveContext value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IVBTreeNode get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(IVBTreeNode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private VBLanguageLevel get_LanguageLevel();
    [CompilerGeneratedAttribute]
private void set_LanguageLevel(VBLanguageLevel value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IPsiModule get_Module();
    [CompilerGeneratedAttribute]
private void set_Module(IPsiModule value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IVBTypeConversionRule get_TypeConversionRule();
    [CompilerGeneratedAttribute]
private void set_TypeConversionRule(IVBTypeConversionRule value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IAccessContext get_AccessContext();
    [CompilerGeneratedAttribute]
private void set_AccessContext(IAccessContext value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private ISymbolFilter[] get_PreInvocationFilters();
    [CompilerGeneratedAttribute]
private void set_PreInvocationFilters(ISymbolFilter[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private ISymbolTable get_SymbolTable();
    [CompilerGeneratedAttribute]
private void set_SymbolTable(ISymbolTable value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IList`1<IType> get_TypeArguments();
    [CompilerGeneratedAttribute]
private void set_TypeArguments(IList`1<IType> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IList`1<IVBArgumentInfo> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(IList`1<IVBArgumentInfo> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IVBArgumentInfo get_Qualifier();
    [CompilerGeneratedAttribute]
private void set_Qualifier(IVBArgumentInfo value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private ITypeInferenceRule get_TypeInferenceRule();
    [CompilerGeneratedAttribute]
private void set_TypeInferenceRule(ITypeInferenceRule value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private IList`1<ISymbolInfo> get_ExtensionMethodCandidates();
    [CompilerGeneratedAttribute]
private void set_ExtensionMethodCandidates(IList`1<ISymbolInfo> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool get_StrictOffMethodGroup();
    [CompilerGeneratedAttribute]
private void set_StrictOffMethodGroup(bool value);
    private ResolveResultWithInfo Resolve(bool resolveToExtensionMethods);
    private bool HasInstanceEntities(IList`1<ISymbolInfo> candidates);
    private IOverloadResolutionResult ResolveExtensionMethod();
    private ResolveResultWithInfo Combine(IOverloadResolutionResult instance, IOverloadResolutionResult extension);
    public static ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable, IList`1<ISymbolFilter> filters, string name, IList`1<IVBArgumentInfo> arguments, IVBArgumentInfo qualifier, IVBTreeNode context, IAccessContext accessContext, IList`1<IType> typeArguments, bool resolveToExtensionMethods);
    public static ResolveResultWithInfo ResolveWithoutExtensions(IResolveContext resolveContext, ISymbolTable symbolTable, IList`1<ISymbolFilter> filters, string name, IList`1<IVBArgumentInfo> arguments, IVBTreeNode context);
    public static ResolveResultWithInfo ResolveMethodGroup(IResolveContext resolveContext, ISymbolTable symbolTable, IList`1<ISymbolFilter> filters, string name, IList`1<IVBArgumentInfo> arguments, IVBArgumentInfo qualifier, IVBTreeNode context, IAccessContext accessContext, IList`1<IType> typeArguments, IType delegateReturnType);
    public static ResolveResultWithInfo ResolveExtensionMethod(DeclaredElementInstance`1<IMethod> method, IList`1<IVBArgumentInfo> arguments, IVBArgumentInfo qualifier, IList`1<IType> typeArguments, IVBTreeNode context);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.InvokedSymbolInfo : ValueType {
    public ISymbolInfo SymbolInfo;
    public IArgumentsMatcher Matcher;
    public InvokedSymbolInfo(ISymbolInfo symbolInfo, IArgumentsMatcher matcher);
}
internal interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.IVBInvocationCandidatesProvider {
    public abstract virtual bool ShouldInferTypeArguments();
    [NotNullAttribute]
public abstract virtual IList`1<InvokedSymbolInfo> GetCandidatesWithMatchers();
}
public static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.LambdaUtil : object {
    public static IList`1<ILambdaParameter> GetImplicitLambdaParameters(IVBExpression expression);
    public static bool HasImplicitLambdaParameters(IVBExpression expression);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OperatorArgumentsMatcher : object {
    private IList`1<IVBArgumentInfo> myArguments;
    public OperatorArgumentsMatcher(IList`1<IVBArgumentInfo> arguments);
    public sealed virtual bool CheckParametersCount(IList`1<IParameter> parameters);
    public sealed virtual Nullable`1<ArgumentsMatchResult> Match(DeclaredElementInstance`1<IParametersOwner> parametersOwner, IMatchingPolicy matchingPolicy, VBLanguageLevel languageLevel);
    public sealed virtual DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IVBArgumentInfo argumentInfo, DeclaredElementInstance`1<IParametersOwner> elementInstance);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.ApplicabilityFailed : OverloadResolutionResultBase`1<ICandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    internal ApplicabilityFailed(IList`1<InferredCandidate> candidates, IResolveContext parentContext);
    internal ApplicabilityFailed(IList`1<ForkedCandidate> candidates, IResolveContext parentContext);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.ApplicableCandidate : object {
    private ForkedCandidate myCandidate;
    private ConversionClassification myConversionClassification;
    private IList`1<ArgumentMatchWithType> myMatchResultThroughtTuples;
    public IResolveContext ResolveContext { get; }
    public ArgumentsMatchResult MatchResult { get; }
    public ConversionClassification ConversionClassification { get; }
    public bool ToDelegate { get; }
    public ISymbolInfo SymbolInfo { get; }
    public ISubstitution InferredSubstitution { get; }
    public TypeInferenceInfo TypeInferenceInfo { get; }
    public DeclaredElementInstance`1<IParametersOwner> SignatureOwner { get; }
    public IReadOnlyList`1<ITypeParameter> InferrableTypeParameters { get; }
    internal ApplicableCandidate(ForkedCandidate candidate, ConversionClassification conversionClassification, IList`1<ArgumentMatchWithType> matchResultThroughtTuples);
    public sealed virtual IResolveContext get_ResolveContext();
    public ArgumentsMatchResult get_MatchResult();
    public ConversionClassification get_ConversionClassification();
    public sealed virtual bool get_ToDelegate();
    public sealed virtual ISymbolInfo get_SymbolInfo();
    public sealed virtual ISubstitution get_InferredSubstitution();
    public TypeInferenceInfo get_TypeInferenceInfo();
    public DeclaredElementInstance`1<IParametersOwner> get_SignatureOwner();
    public IList`1<ArgumentMatchWithType> MatchResultThroughtTuples();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_InferrableTypeParameters();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.ArgumentMatchWithType : ValueType {
    [CompilerGeneratedAttribute]
private bool <CheckParamArray>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionType <ArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgumentMatch <Match>k__BackingField;
    public bool CheckParamArray { get; }
    public IType ParameterType { get; }
    public IExpressionType ArgumentType { get; }
    public IVBArgumentInfo Argument { get; }
    [CanBeNullAttribute]
public IParameter Parameter { get; }
    public ExpandedKind Expanded { get; }
    internal ArgumentMatch Match { get; }
    public ArgumentMatchWithType(ArgumentMatch argumentMatch, IExpressionType argumentType, IType parameterType, bool checkParamArray);
    [CompilerGeneratedAttribute]
public bool get_CheckParamArray();
    [CompilerGeneratedAttribute]
public IType get_ParameterType();
    [CompilerGeneratedAttribute]
public IExpressionType get_ArgumentType();
    public IVBArgumentInfo get_Argument();
    public IParameter get_Parameter();
    public ExpandedKind get_Expanded();
    [CompilerGeneratedAttribute]
internal ArgumentMatch get_Match();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.ArgumentsMismatch : OverloadResolutionResultBase`1<Candidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public ArgumentsMismatch(IList`1<Candidate> candidates);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.Candidate : object {
    [CompilerGeneratedAttribute]
private bool <ToDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredElementInstance`1<IParametersOwner> <SignatureOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolInfo <SymbolInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITypeParameter> <InferrableTypeParameters>k__BackingField;
    public bool ToDelegate { get; }
    public IResolveContext ResolveContext { get; public set; }
    [NotNullAttribute]
public IList`1<IParameter> Parameters { get; }
    public DeclaredElementInstance`1<IParametersOwner> SignatureOwner { get; }
    public ISymbolInfo SymbolInfo { get; }
    public ISubstitution InferredSubstitution { get; }
    public IReadOnlyList`1<ITypeParameter> InferrableTypeParameters { get; }
    public Candidate(IResolveContext resolveContext, ISymbolInfo symbolInfo, DeclaredElementInstance`1<IParametersOwner> signatureOwner, bool toDelegate);
    [NotNullAttribute]
private IReadOnlyList`1<ITypeParameter> GetInferrableTypeParameters();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ToDelegate();
    [CompilerGeneratedAttribute]
public sealed virtual IResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public void set_ResolveContext(IResolveContext value);
    public IList`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public DeclaredElementInstance`1<IParametersOwner> get_SignatureOwner();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbolInfo get_SymbolInfo();
    public sealed virtual ISubstitution get_InferredSubstitution();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ITypeParameter> get_InferrableTypeParameters();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.DefaultTypeInferenceRule : object {
    public static DefaultTypeInferenceRule Instance;
    private static DefaultTypeInferenceRule();
    public sealed virtual Pair`2<ISubstitution, TypeInferenceInfo> Inference(IResolveContext& resolveContext, IMethod method, ISubstitution qualifierSubstitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, ArgumentsMatchResult matchResult, IVBTypeConversionRule rule, VBLanguageLevel languageLevel);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.ForkedCandidate : object {
    private InferredCandidate myCandidate;
    public IResolveContext ResolveContext { get; }
    public ArgumentsMatchResult MatchResult { get; }
    public ISubstitution InferredSubstitution { get; }
    public TypeInferenceInfo TypeInferenceInfo { get; }
    public bool ToDelegate { get; }
    public ISymbolInfo SymbolInfo { get; }
    public DeclaredElementInstance`1<IParametersOwner> SignatureOwner { get; }
    public IReadOnlyList`1<ITypeParameter> InferrableTypeParameters { get; }
    public ForkedCandidate(InferredCandidate candidate);
    public sealed virtual IResolveContext get_ResolveContext();
    public ArgumentsMatchResult get_MatchResult();
    public sealed virtual ISubstitution get_InferredSubstitution();
    public TypeInferenceInfo get_TypeInferenceInfo();
    public sealed virtual bool get_ToDelegate();
    public sealed virtual ISymbolInfo get_SymbolInfo();
    public DeclaredElementInstance`1<IParametersOwner> get_SignatureOwner();
    public IEnumerable`1<ArgumentMatchWithType> MatchResultWithTypes();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_InferrableTypeParameters();
}
internal static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.GreaterDepthOfGenericitySelector : object {
    public static IList`1<ApplicableCandidate> SelectGreaterDepthOfGenericity(IList`1<ApplicableCandidate> candidates);
    private static bool AreEqualTypesThroughtDelegates(IType type1, IType type2);
    private static Result CompareDepthOfGenericity(ApplicableCandidate candidate, ApplicableCandidate otherCandidate);
    private static Result CompareDepthOfGenericity(IType type1, IType type2);
}
internal interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.ICandidate {
    public ISymbolInfo SymbolInfo { get; }
    public ISubstitution InferredSubstitution { get; }
    public IReadOnlyList`1<ITypeParameter> InferrableTypeParameters { get; }
    public bool ToDelegate { get; }
    [CanBeNullAttribute]
public IResolveContext ResolveContext { get; }
    public abstract virtual ISymbolInfo get_SymbolInfo();
    public abstract virtual ISubstitution get_InferredSubstitution();
    public abstract virtual IReadOnlyList`1<ITypeParameter> get_InferrableTypeParameters();
    public abstract virtual bool get_ToDelegate();
    public abstract virtual IResolveContext get_ResolveContext();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.ILateBoundSelector {
    public abstract virtual IList`1<ApplicableCandidate> SelectCandidate(IList`1<ApplicableCandidate> candidates);
}
public interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.IMoreSpecificSelector {
    public abstract virtual IList`1<ApplicableCandidate> SelectCandidate(IList`1<ApplicableCandidate> candidates);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.IncorrectParameterNumber : OverloadResolutionResultBase`1<Candidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public IncorrectParameterNumber(IList`1<Candidate> candidates);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.IncorrectTypeParameterNumber : OverloadResolutionResultBase`1<Candidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public IncorrectTypeParameterNumber(IList`1<Candidate> candidates);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.InferredCandidate : object {
    private MatchedCandidate myCandidate;
    [CompilerGeneratedAttribute]
private ISubstitution <InferredSubstitution>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInferenceInfo <TypeInferenceInfo>k__BackingField;
    public ISubstitution InferredSubstitution { get; }
    public TypeInferenceInfo TypeInferenceInfo { get; }
    public ArgumentsMatchResult MatchResult { get; }
    public IResolveContext ResolveContext { get; public set; }
    public bool ToDelegate { get; }
    public ISymbolInfo SymbolInfo { get; }
    public DeclaredElementInstance`1<IParametersOwner> SignatureOwner { get; }
    public IReadOnlyList`1<ITypeParameter> InferrableTypeParameters { get; }
    public InferredCandidate(MatchedCandidate candidate, ISubstitution inferredSubstitution, TypeInferenceInfo typeInferenceInfo);
    [CompilerGeneratedAttribute]
public sealed virtual ISubstitution get_InferredSubstitution();
    [CompilerGeneratedAttribute]
public TypeInferenceInfo get_TypeInferenceInfo();
    public ArgumentsMatchResult get_MatchResult();
    public sealed virtual IResolveContext get_ResolveContext();
    public void set_ResolveContext(IResolveContext value);
    public sealed virtual bool get_ToDelegate();
    public sealed virtual ISymbolInfo get_SymbolInfo();
    public DeclaredElementInstance`1<IParametersOwner> get_SignatureOwner();
    public IEnumerable`1<ArgumentMatchWithType> MatchResultWithTypes();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_InferrableTypeParameters();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.IPreFilterNarrowingCandidates {
    public abstract virtual IList`1<ApplicableCandidate> Filter(IList`1<ApplicableCandidate> candidates);
}
public interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.ITypeInferenceRule {
    public abstract virtual Pair`2<ISubstitution, TypeInferenceInfo> Inference(IResolveContext& resolveContext, IMethod method, ISubstitution qualifierSubstitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, ArgumentsMatchResult matchResult, IVBTypeConversionRule rule, VBLanguageLevel languageLevel);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.LateBoundResult : OverloadResolutionResultBase`1<ApplicableCandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public LateBoundResult(IList`1<ApplicableCandidate> candidates, IResolveContext parentContext);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.LateBoundSelector : object {
    public static ILateBoundSelector Instance;
    private static LateBoundSelector();
    public sealed virtual IList`1<ApplicableCandidate> SelectCandidate(IList`1<ApplicableCandidate> candidates);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.LateBoundSelectorForExtensionMethods : object {
    public static ILateBoundSelector INSTANCE;
    private static LateBoundSelectorForExtensionMethods();
    public sealed virtual IList`1<ApplicableCandidate> SelectCandidate(IList`1<ApplicableCandidate> candidates);
}
internal static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.LessGenericSelectorUtil : object {
    public static IList`1<ApplicableCandidate> SelectLessGeneric(IList`1<ApplicableCandidate> candidates);
    public static IList`1<ApplicableCandidate> SelectLessGenericByExtensionArgument(IList`1<ApplicableCandidate> candidates);
    private static bool IsWorseThenSomeone(IList`1<TypeClassifications> candidate, IList`1<List`1<TypeClassifications>> allCandidates);
    private static bool IsMethodTypeParameter(TypeClassifications cls1);
    private static bool IsTypeParameter(TypeClassifications cls1);
    private static bool IsWorse(IList`1<TypeClassifications> cls1, IList`1<TypeClassifications> cls2);
    private static TypeClassifications GetTypeClassification(IParameter parameter, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.LifterOperatorsFilter : object {
    public static IPreFilterNarrowingCandidates Instance;
    private static LifterOperatorsFilter();
    public sealed virtual IList`1<ApplicableCandidate> Filter(IList`1<ApplicableCandidate> candidates);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MatchedCandidate : object {
    private Candidate myCandidate;
    private ArgumentsMatchResult myMatchResult;
    public ArgumentsMatchResult MatchResult { get; }
    public DeclaredElementInstance`1<IParametersOwner> SignatureOwner { get; }
    public IResolveContext ResolveContext { get; public set; }
    public bool ToDelegate { get; }
    public ISymbolInfo SymbolInfo { get; }
    public ISubstitution InferredSubstitution { get; }
    public IReadOnlyList`1<ITypeParameter> InferrableTypeParameters { get; }
    public MatchedCandidate(Candidate candidate, ArgumentsMatchResult matchResult);
    public ArgumentsMatchResult get_MatchResult();
    public DeclaredElementInstance`1<IParametersOwner> get_SignatureOwner();
    public sealed virtual IResolveContext get_ResolveContext();
    public void set_ResolveContext(IResolveContext value);
    public sealed virtual bool get_ToDelegate();
    public sealed virtual ISymbolInfo get_SymbolInfo();
    public sealed virtual ISubstitution get_InferredSubstitution();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_InferrableTypeParameters();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MethodGroupTypeInferenceRule : object {
    private IType myDelegateReturnType;
    public MethodGroupTypeInferenceRule(IType delegateReturnType);
    public sealed virtual Pair`2<ISubstitution, TypeInferenceInfo> Inference(IResolveContext& resolveContext, IMethod method, ISubstitution qualifierSubstitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, ArgumentsMatchResult matchResult, IVBTypeConversionRule rule, VBLanguageLevel languageLevel);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MoreApplicableNotFound : OverloadResolutionResultBase`1<ApplicableCandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public MoreApplicableNotFound(IList`1<ApplicableCandidate> candidates, IResolveContext parentContext);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
public enum JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MoreApplicableResult : Enum {
    public int value__;
    public static MoreApplicableResult EquallyApplicable;
    public static MoreApplicableResult MoreApplicable;
    public static MoreApplicableResult LessApplicable;
    public static MoreApplicableResult NotComparable;
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MoreApplicableSelector : object {
    [ExtensionAttribute]
public static MoreApplicableResult IsMoreApplicable2(ApplicableCandidate better, ApplicableCandidate worse, IPsiModule module);
    private static MoreApplicableResult IsMoreApplicable2(ArgumentMatchWithType betterMatch, ArgumentMatchWithType worseMatch, IVBTypeConversionRule rule);
    private static bool IsMoreApplicableNumeric(IType better, IType worse);
    private static MoreApplicableResult IsMoreApplicable2(IType better, IType worse, IExpressionType betterArgumentType, IExpressionType worseArgumentType, IVBTypeConversionRule rule, bool stopAnalyse);
    private static IExpressionType ArgumentReturnType(IExpressionType expressionType, IVBTypeConversionRule rule);
    private static MoreApplicableResult IsDelegateMoreApplicable2(IType better, IType worse, IExpressionType betterArgumentType, IExpressionType worseArgumentType, IVBTypeConversionRule rule);
    [ExtensionAttribute]
public static bool AreEquallyApplicable(ApplicableCandidate first, ApplicableCandidate second);
    private static bool AreEquallyApplicable(ArgumentMatchWithType betterMatch, ArgumentMatchWithType worseMatch);
    [ExtensionAttribute]
public static bool IsMoreApplicable(ApplicableCandidate better, ApplicableCandidate worse, IPsiModule module);
    private static bool IsMoreApplicable(ArgumentMatchWithType betterMatch, ArgumentMatchWithType worseMatch, IVBTypeConversionRule rule);
    private static bool IsMoreApplicable(IType better, IType worse, IExpressionType betterArgumentType, IExpressionType worseArgumentType, IVBTypeConversionRule rule, bool stopAnalyse);
    private static bool IsDelegateMoreApplicable(IType better, IType worse, IVBTypeConversionRule rule);
    private static bool IsLambdaMoreApplicable(IType better, IType worse, IVBLambdaExpressionType betterLambdaType, IVBLambdaExpressionType worseLambdaType, IVBTypeConversionRule rule);
    private static bool IsMethodGroupMoreApplicable(IType better, IType worse, IVBMethodGroupType betterMethodGroup, IVBMethodGroupType worseMethodGroup, IVBTypeConversionRule rule);
    private static bool IsPureZero(IExpressionType expressionType);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MoreSpecificNotFound : OverloadResolutionResultBase`1<ApplicableCandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public MoreSpecificNotFound(IList`1<ApplicableCandidate> candidates, IResolveContext parentContext);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MoreSpecificSelector : object {
    public static IMoreSpecificSelector Instance;
    private static MoreSpecificSelector();
    public sealed virtual IList`1<ApplicableCandidate> SelectCandidate(IList`1<ApplicableCandidate> candidates);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MoreSpecificSelectorForExtensionMethods : object {
    public static IMoreSpecificSelector INSTANCE;
    private static MoreSpecificSelectorForExtensionMethods();
    public sealed virtual IList`1<ApplicableCandidate> SelectCandidate(IList`1<ApplicableCandidate> candidates);
}
internal static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.MoreSpecificSelectorUtil : object {
    [NotNullAttribute]
public static IList`1<ApplicableCandidate> SelectNotLifted(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
public static IList`1<ApplicableCandidate> SelectMoreExpanded(IList`1<ApplicableCandidate> candidates);
    private static int CalculateExpandedCount(ApplicableCandidate candidate);
    [NotNullAttribute]
public static IList`1<ApplicableCandidate> SelectMoreDerived(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
public static IList`1<ApplicableCandidate> SelectCandidatesNotUsingOptionalDefaults(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
public static IList`1<ApplicableCandidate> SelectMoreSpecificByExtensionArgument(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
public static IList`1<ApplicableCandidate> SelectFewerTypeParameters(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
public static IList`1<ApplicableCandidate> SelectCloserToUsage(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
private static IList`1<ApplicableCandidate> SelectBestWithMeasure(IList`1<ApplicableCandidate> candidates, Func`2<ApplicableCandidate, int> measure);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.NotSignatureOwnerFound : OverloadResolutionResultBase`1<SymbolInfoCandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public NotSignatureOwnerFound(IList`1<ISymbolInfo> infos);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.OverloadResolutionData : ValueType {
    [CompilerGeneratedAttribute]
private IResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IArgumentsMatcher <ArgumentsMatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IType> <TypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TypesAreAlreadyInfered>k__BackingField;
    [CompilerGeneratedAttribute]
private IVBTypeConversionRule <TypeConversionRule>k__BackingField;
    [CompilerGeneratedAttribute]
private VBLanguageLevel <LanguageLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private ILateBoundSelector <LateBoundSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private IMoreSpecificSelector <MoreSpecificSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private IPreFilterNarrowingCandidates <PreFilterNarrowingCandidates>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeInferenceRule <TypeInferenceRule>k__BackingField;
    public IResolveContext ResolveContext { get; public set; }
    public IArgumentsMatcher ArgumentsMatcher { get; public set; }
    public IList`1<IType> TypeArguments { get; public set; }
    public bool TypesAreAlreadyInfered { get; public set; }
    public IVBTypeConversionRule TypeConversionRule { get; public set; }
    public VBLanguageLevel LanguageLevel { get; public set; }
    public IPsiModule Module { get; public set; }
    public ILateBoundSelector LateBoundSelector { get; public set; }
    public IMoreSpecificSelector MoreSpecificSelector { get; public set; }
    public IPreFilterNarrowingCandidates PreFilterNarrowingCandidates { get; public set; }
    public ITypeInferenceRule TypeInferenceRule { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public void set_ResolveContext(IResolveContext value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IArgumentsMatcher get_ArgumentsMatcher();
    [CompilerGeneratedAttribute]
public void set_ArgumentsMatcher(IArgumentsMatcher value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IList`1<IType> get_TypeArguments();
    [CompilerGeneratedAttribute]
public void set_TypeArguments(IList`1<IType> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool get_TypesAreAlreadyInfered();
    [CompilerGeneratedAttribute]
public void set_TypesAreAlreadyInfered(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IVBTypeConversionRule get_TypeConversionRule();
    [CompilerGeneratedAttribute]
public void set_TypeConversionRule(IVBTypeConversionRule value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual VBLanguageLevel get_LanguageLevel();
    [CompilerGeneratedAttribute]
public void set_LanguageLevel(VBLanguageLevel value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public void set_Module(IPsiModule value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ILateBoundSelector get_LateBoundSelector();
    [CompilerGeneratedAttribute]
public void set_LateBoundSelector(ILateBoundSelector value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IMoreSpecificSelector get_MoreSpecificSelector();
    [CompilerGeneratedAttribute]
public void set_MoreSpecificSelector(IMoreSpecificSelector value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IPreFilterNarrowingCandidates get_PreFilterNarrowingCandidates();
    [CompilerGeneratedAttribute]
public void set_PreFilterNarrowingCandidates(IPreFilterNarrowingCandidates value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ITypeInferenceRule get_TypeInferenceRule();
    [CompilerGeneratedAttribute]
public void set_TypeInferenceRule(ITypeInferenceRule value);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.OverloadResolutionEngine : object {
    private IOverloadResolutionData myData;
    public OverloadResolutionEngine(IOverloadResolutionData data);
    [NotNullAttribute]
public IOverloadResolutionResult ResolveOverloads(IList`1<ISymbolInfo> infos);
    [NotNullAttribute]
private static IList`1<ApplicableCandidate> EliminateInferenceLowPriority(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> StrictOffCandidates(IList`1<ApplicableCandidate> candidates);
    private static bool Same(IType parameterType1, IType parameterType2, IExpressionType argumentType1, IExpressionType argumentType2);
    private bool Same(ApplicableCandidate candidate1, ApplicableCandidate candidate2);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> FindMoreSpecific(IList`1<ApplicableCandidate> candidates);
    private static bool IsTypeSupported(IType type);
    private bool IsSupportedSymbol(DeclaredElementInstance`1<IParametersOwner> signatureOwner);
    [NotNullAttribute]
private IList`1<Candidate> FilterUnsupported(IList`1<Candidate> candidates);
    public static bool IsApplicable(IResolveContext resolveContext, ArgumentsMatchResult matchResult, ISubstitution inferredSubstitution, IVBTypeConversionRule rule);
    public static bool IsApplicableWithoutLambdas(IResolveContext resolveContext, ArgumentsMatchResult matchResult, ISubstitution inferredSubstitution, IVBTypeConversionRule rule);
    [NotNullAttribute]
private static IList`1<ApplicableCandidate> Verify(IList`1<ApplicableCandidate> candidates);
    private static bool Verify(ApplicableCandidate candidate);
    private IList`1<ApplicableCandidate> FindMoreSpecificForSameSignatures(IList`1<ApplicableCandidate> candidates);
    private DelegatePriority CalculatePriorityForLambda(IVBLambdaExpressionType lambdaExpressionType, DeclaredElementInstance`1<IDelegate> delegate);
    private DelegatePriority CalculatePriorityForMethodGroup(IVBMethodGroupType methodGroupType, DeclaredElementInstance`1<IDelegate> delegate);
    private DelegatePriority CalculateDelegatePriority(ApplicableCandidate candidate);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> BetterDelegateSignature(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> MoreApplicableAreBetter(IList`1<ApplicableCandidate> candidates);
    private IList`1<ApplicableCandidate> FindLateBound(IList`1<ApplicableCandidate> candidates);
    private IList`1<ApplicableCandidate> EliminateLateBound(IList`1<ApplicableCandidate> candidates);
    private IList`1<ApplicableCandidate> EliminateMostOfNonStrictVB10(IList`1<ApplicableCandidate> candidates);
    private IList`1<ApplicableCandidate> EliminateNonStrictVB11(IList`1<ApplicableCandidate> candidates);
    [NotNullAttribute]
private IList`1<ApplicableCandidate> CheckApplicability(IList`1<ForkedCandidate> candidates);
    [NotNullAttribute]
private static IList`1<ApplicableCandidate> CheckApplicability(IList`1<ForkedCandidate> candidates, IVBTypeConversionRule rule);
    private static ConversionClassification IsApplicable(ForkedCandidate candidate, IVBTypeConversionRule rule, IList`1& matchResultWithTypes);
    private static bool FixParamArrayParameter(ForkedCandidate candidate, IVBTypeConversionRule rule);
    [NotNullAttribute]
private static IList`1<ForkedCandidate> ForkImplicitlyConvertedTo(IList`1<InferredCandidate> candidates);
    [NotNullAttribute]
private static List`1<ValueTuple`2<IManagedConvertible, IType>> BuildForkAssumptions(InferredCandidate candidate);
    private bool IsSubstitutionFull(ISubstitution substitution, ICollection`1<ITypeParameter> typeParameters);
    [NotNullAttribute]
private IList`1<InferredCandidate> InferTypeParameters(IList`1<MatchedCandidate> candidates);
    [NotNullAttribute]
private IList`1<Candidate> ExtractSignatureOwner(IList`1<ISymbolInfo> infos, IList`1& otherInfos);
    [NotNullAttribute]
private IList`1<Candidate> MatchParametersCount(IList`1<Candidate> candidates);
    private IList`1<Candidate> MatchTypeParametersCount(IList`1<Candidate> candidates);
    [NotNullAttribute]
private IList`1<MatchedCandidate> MatchArgumentsAgainstParameters(IList`1<Candidate> candidates);
    [CompilerGeneratedAttribute]
private bool <FilterUnsupported>b__10_0(Candidate candidate);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.OverloadResolutionResultBase`1 : object {
    [CanBeNullAttribute]
private IResolveContext myParentContext;
    protected IList`1<TCandidate> myCandidates;
    public ResolveErrorType ErrorType { get; }
    public bool IsApplicableResolveResult { get; }
    public bool HasModuleMethod { get; }
    protected OverloadResolutionResultBase`1(IList`1<TCandidate> candidates, IResolveContext parentContext);
    public virtual ResolveResultWithInfo GetResolveResult();
    public sealed virtual ResolveResultWithInfo CommitResolveResult();
    private ISubstitution GetSubstitution(ICandidate candidate);
    public abstract virtual ResolveErrorType get_ErrorType();
    public virtual bool get_IsApplicableResolveResult();
    public sealed virtual bool get_HasModuleMethod();
    private static bool GetIsModuleMethod(IDeclaredElement element);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.SignatureOwnerNotFound : OverloadResolutionResultBase`1<SymbolInfoCandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public SignatureOwnerNotFound(IList`1<ISymbolInfo> infos);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.StrictnessFailed : OverloadResolutionResultBase`1<ApplicableCandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    internal StrictnessFailed(IList`1<ApplicableCandidate> candidates, IResolveContext parentContext);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.SymbolInfoCandidate : object {
    private ISymbolInfo mySymbolInfo;
    public ISymbolInfo SymbolInfo { get; }
    public ISubstitution InferredSubstitution { get; }
    public bool ToDelegate { get; }
    public IResolveContext ResolveContext { get; }
    public IReadOnlyList`1<ITypeParameter> InferrableTypeParameters { get; }
    public SymbolInfoCandidate(ISymbolInfo symbolInfo);
    public sealed virtual ISymbolInfo get_SymbolInfo();
    public sealed virtual ISubstitution get_InferredSubstitution();
    public sealed virtual bool get_ToDelegate();
    public sealed virtual IResolveContext get_ResolveContext();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_InferrableTypeParameters();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.TheBest : OverloadResolutionResultBase`1<ApplicableCandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    public TheBest(IList`1<ApplicableCandidate> candidates, IResolveContext parentContext);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.TypeInferenceFailed : OverloadResolutionResultBase`1<MatchedCandidate> {
    public bool IsApplicableResolveResult { get; }
    public ResolveErrorType ErrorType { get; }
    internal TypeInferenceFailed(IList`1<MatchedCandidate> candidates);
    public virtual bool get_IsApplicableResolveResult();
    public virtual ResolveErrorType get_ErrorType();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.TypeInferenceInfo : Enum {
    public sbyte value__;
    public static TypeInferenceInfo None;
    public static TypeInferenceInfo IgnorableInferenceResult;
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.OverloadResolution.UnsupportedCandidates : OverloadResolutionResultBase`1<Candidate> {
    public ResolveErrorType ErrorType { get; }
    public UnsupportedCandidates(IList`1<Candidate> candidates);
    public virtual ResolveErrorType get_ErrorType();
}
internal interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.Implicit.IQueryImplicitLambdaParameter {
    public abstract virtual void SetOwner(QueryImplicitAnonymousMethod parameter);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.Implicit.QueryImplicitAnonymousMethod : object {
    private IList`1<IQueryImplicitLambdaParameter> myParameters;
    private IVBTreeNode myElement;
    private QueryChainTypeBase myReturnType;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public QueryImplicitAnonymousMethod(IVBTreeNode element, QueryChainTypeBase reutrnType, IList`1<IQueryImplicitLambdaParameter> parameters);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    [NotNullAttribute]
public IReadOnlyList`1<QueryImplicitLambdaParameterBase> GetQueryLambdaParameters();
    public bool Equals(QueryImplicitAnonymousMethod obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.Implicit.QueryImplicitLambdaArgument : PositionalArgumentInfoBase {
    private QueryImplicitAnonymousMethod myMethod;
    private QueryChainTypeBase myReturnType;
    public QueryImplicitAnonymousMethod Method { get; }
    public QueryImplicitLambdaArgument(IVBTreeNode element, IVBInvocationInfo invocation, QueryImplicitAnonymousMethod method, QueryChainTypeBase returnType);
    public QueryImplicitAnonymousMethod get_Method();
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public bool Equals(QueryImplicitLambdaArgument other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.Implicit.QueryImplicitLambdaExpressionType : VBLambdaExpressionTypeBase {
    private IVBTreeNode myElement;
    private IReadOnlyList`1<QueryImplicitLambdaParameterBase> myParameters;
    private QueryChainExpressionTypeBase myBodyType;
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public IVBTreeNode VerificationScope { get; }
    public QueryImplicitLambdaExpressionType(IResolveContext resolveContext, IReadOnlyList`1<QueryImplicitLambdaParameterBase> parameters, IVBTreeNode anchor, QueryChainExpressionTypeBase bodyType);
    public virtual IReadOnlyList`1<ILambdaParameter> GetImplicitLambdaParameters();
    public virtual IType CreateFunctionType();
    public virtual bool HasImplicitLambdaParameters();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    public virtual IVBTreeNode get_VerificationScope();
    public virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> GetParameterTypesAndKinds();
    protected virtual IExpressionType InferResultType();
    public virtual bool IsValid();
    public bool Equals(QueryImplicitLambdaExpressionType obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private Pair`2<IType, ParameterKind> <GetParameterTypesAndKinds>b__13_0(QueryImplicitLambdaParameterBase x);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.Implicit.QueryImplicitLambdaParameterBase : object {
    private QueryImplicitAnonymousMethod myParametersOwner;
    private ITreeNode myElement;
    private IQueryReferenceImpl myInvocation;
    private int myIndex;
    private CachedPsiValue`1<IType> myCachedType;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IType Type { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsValueVariable { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public bool IsImplicitlyTyped { get; }
    public bool IsExplicitlyTyped { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    protected QueryImplicitLambdaParameterBase(ITreeNode element, IQueryReferenceImpl invocation, int index);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public abstract virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IType get_Type();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual bool get_IsImplicitlyTyped();
    public sealed virtual bool get_IsExplicitlyTyped();
    private sealed virtual override void JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.Implicit.IQueryImplicitLambdaParameter.SetOwner(QueryImplicitAnonymousMethod parameter);
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public bool Equals(QueryImplicitLambdaParameterBase obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.Implicit.QueryImplicitLambdaParameterGroupVariable : QueryImplicitLambdaParameterBase {
    public string ShortName { get; }
    public QueryImplicitLambdaParameterGroupVariable(ITreeNode element, IQueryReferenceImpl invocation, int index);
    public virtual string get_ShortName();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.Implicit.QueryImplicitLambdaParameterOfRangeVariable : QueryImplicitLambdaParameterBase {
    public string ShortName { get; }
    public QueryImplicitLambdaParameterOfRangeVariable(ITreeNode element, IQueryReferenceImpl invocation, int index);
    public virtual string get_ShortName();
}
internal interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.IQueryQualifier {
}
internal interface JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.IQueryReferenceImpl {
    public abstract virtual IType GetMethodReturnType(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.QueryChainReferenceBase`1 : QueryReferenceBase`1<TOwnerElement> {
    protected QueryChainReferenceBase`1(TOwnerElement owner);
    [NotNullAttribute]
public virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    public virtual IExpressionType GetExtensionArgumentExpressionType(IResolveContext resolveContext);
    public virtual IVBArgumentInfo GetExtensionQualifier(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.QueryExtensionArgumentInfoOfAggregatedCollection : ExtensionArgumentInfoBase {
    private IAggregatedCollectionOwner myAggregatedCollectionOwner;
    public QueryExtensionArgumentInfoOfAggregatedCollection(IVBInvocationInfo invocation, IAggregatedCollectionOwner aggregatedCollectionOwner);
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool IsValid();
    public bool Equals(QueryExtensionArgumentInfoOfAggregatedCollection other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.QueryExtensionArgumentInfoOfReference : ExtensionArgumentInfoBase {
    private IQueryReferenceImpl myReference;
    public QueryExtensionArgumentInfoOfReference(IQueryReferenceImpl reference, IVBInvocationInfo invocation);
    public virtual DocumentRange GetDocumentRange();
    public virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool IsValid();
    public bool Equals(QueryExtensionArgumentInfoOfReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.QueryQualifier : object {
    private IQueryReferenceImpl myReference;
    private IResolveContext myResolveContext;
    public bool Resolved { get; }
    internal QueryQualifier(IResolveContext resolveContext, IQueryReferenceImpl qualifierReference);
    public sealed virtual bool get_Resolved();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.QueryQualifierWithType : object {
    private IPsiModule myModule;
    private IType myType;
    public bool Resolved { get; }
    internal QueryQualifierWithType(IPsiModule module, IType type);
    public sealed virtual bool get_Resolved();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Query.QueryReferenceBase`1 : ManagedOnePhaseReferenceImplBase`1<TOwnerElement> {
    protected TOwnerElement myOwner;
    public IPsiModule PsiModule { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IVBTreeNode Node { get; }
    public IVBInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public bool IsQualified { get; }
    private IVBInvocationInfo JetBrains.ReSharper.Psi.VB.IVBInvocationReference.Invocation { get; }
    protected QueryReferenceBase`1(TOwnerElement owner);
    public abstract virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    public sealed virtual IPsiModule get_PsiModule();
    public abstract virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    public abstract virtual IVBArgumentInfo GetExtensionQualifier(IResolveContext resolveContext);
    public virtual IExpressionType GetExtensionArgumentExpressionType(IResolveContext resolveContext);
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual IType GetMethodReturnType(IResolveContext resolveContext);
    public sealed virtual IList`1<InvokedSymbolInfo> GetCandidatesWithMatchers();
    public virtual bool ShouldInferTypeArguments();
    public sealed virtual IVBTreeNode get_Node();
    public sealed virtual IVBInvocationReference get_Reference();
    public virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual bool get_IsQualified();
    public virtual IQualifier GetQualifier(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    public sealed virtual string InvocationName();
    private sealed virtual override IVBInvocationInfo JetBrains.ReSharper.Psi.VB.IVBInvocationReference.get_Invocation();
    private sealed virtual override IPsiServices JetBrains.ReSharper.Psi.IInvocationInfo.GetPsiServices();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ResolveArgumentsMatcher : object {
    private ArgumentsMatcher myArgumentsMatcher;
    public ResolveArgumentsMatcher(IList`1<IVBArgumentInfo> arguments);
    public sealed virtual bool CheckParametersCount(IList`1<IParameter> parameters);
    public sealed virtual Nullable`1<ArgumentsMatchResult> Match(DeclaredElementInstance`1<IParametersOwner> parametersOwner, IMatchingPolicy matchingPolicy, VBLanguageLevel languageLevel);
    public sealed virtual DeclaredElementInstance`1<IParameter> GetParameterMatchingArgument(IVBArgumentInfo argumentInfo, DeclaredElementInstance`1<IParametersOwner> elementInstance);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ResolveResults.InvocationResolveResult : ResolveResultWithSubstitution {
    [NotNullAttribute]
private IResolveResult myResolveResult;
    public ExtensionInstance`1<IDeclaredElement> ElementExtensionInstance { get; }
    public IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> CandidateExtensionInstances { get; }
    protected InvocationResolveResult(IResolveResult resolveResult);
    public IResolveResult GetResolveResult();
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
    public static InvocationResolveResult Create(IResolveResult resolveResult);
    public static IResolveResult GetSimpleResolveResult(IResolveResult resolveResult);
    public sealed virtual ExtensionInstance`1<IDeclaredElement> get_ElementExtensionInstance();
    public sealed virtual IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> get_CandidateExtensionInstances();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ResolveResults.MethodGroupResolveResult : InvocationResolveResult {
    private string myName;
    private IVBTreeNode myContext;
    private IVBArgumentInfo myExtensionArgument;
    private IAccessContext myAccessContext;
    private IList`1<IType> myTypeArguments;
    public MethodGroupResolveResult(IResolveResult resolveResult, string name, IVBTreeNode context, IVBArgumentInfo extensionArgument, IAccessContext accessContext, IList`1<IType> typeArguments);
    public DeclaredElementInstance`1<IMethod> ResolveToMethodWithDelegate(IResolveContext resolveContext, IDelegate delegate, ISubstitution substitution);
    public ResolveResultWithInfo ResolveWithDelegate(IResolveContext resolveContext, IDelegate delegate, ISubstitution substitution);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ResolveResults.MultipleNamespacesResolveResult : ResolveResultWithSubstitution {
    private ResolveResultWithInfo myMultipleResults;
    public ResolveResultWithInfo MultipleResult { get; }
    protected MultipleNamespacesResolveResult(ResolveResultWithInfo multipleResults);
    [CanBeNullAttribute]
public static ResolveResultWithInfo Create(ITreeNode treeNode, ResolveResultWithInfo multipleResult);
    public ResolveResultWithInfo get_MultipleResult();
    [CanBeNullAttribute]
private IImportClause FindImportClause(IPsiModule module, INamespace ns, IResolveInfo resolveInfo);
    public ResolveResultWithInfo GetSingleResult(IPsiModule module, INamespace nmsp);
    public ISymbolTable GetSymbolTable(IPsiModule module, SymbolTableMode mode);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.ResolveResults.ReturnValueResolveResult : ResolveResultWithSubstitution {
    public ReturnValueResolveResult(IDeclaredElement element, ISubstitution substitution, IList`1<IDeclaredElement> candidates, IList`1<ISubstitution> candidateSubstitutions);
    public ReturnValueResolveResult(IDeclaredElement element, ISubstitution substitution);
    public ReturnValueResolveResult(IDeclaredElement element);
    public ReturnValueResolveResult(IList`1<IDeclaredElement> candidates, IList`1<ISubstitution> candidateSubstitutions);
    public ReturnValueResolveResult(IList`1<IDeclaredElement> candidates);
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Resolve.VBArgumentInfoBase : object {
    private IVBInvocationInfo myInvocation;
    private IVBTreeNode myNode;
    protected IVBTreeNode Node { get; }
    public DeclaredElementInstance`1<IParameter> MatchingParameter { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public IVBInvocationInfo Invocation { get; }
    public ArgumentKind Kind { get; }
    public string ArgumentName { get; }
    public IManagedConvertible ManagedConvertible { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public IPsiModule PsiModule { get; }
    protected VBArgumentInfoBase(IVBInvocationInfo invocation, IVBTreeNode node);
    protected IVBTreeNode get_Node();
    public sealed virtual DeclaredElementInstance`1<IParameter> get_MatchingParameter();
    public virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IVBInvocationInfo get_Invocation();
    public virtual ArgumentKind get_Kind();
    public virtual string get_ArgumentName();
    public virtual IManagedConvertible get_ManagedConvertible();
    public abstract virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_PsiModule();
    public virtual DocumentRange GetDocumentRange();
    public virtual bool IsValid();
    public virtual bool Equals(object obj);
    public bool Equals(VBArgumentInfoBase other);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.VBExtensionSymbolInfo : VBSymbolInfo {
    [CompilerGeneratedAttribute]
private int <ExtensionMethodLevel>k__BackingField;
    public int ExtensionMethodLevel { get; }
    public VBExtensionSymbolInfo(IImportClause importClause, string aliasName, IDeclaredElement declaredElement, ISubstitution substitution, int extensionMethodLevel);
    [CompilerGeneratedAttribute]
public int get_ExtensionMethodLevel();
    public virtual ISymbolInfo ReplaceSubstitution(ISubstitution composedSubstitution);
    public virtual ISymbolInfo ReplaceLevel(int level);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.VBResolveUtil : object {
    public static ISymbolTable AddDeclarationsForNamespace(IPsiModule module, INamespace namespace, IImportClause importClause, int currentLevel, SymbolTableMode mode, ISymbolScope cachedSymbolScope);
    [NotNullAttribute]
internal static ISymbolTable GetSymbolTableForUntypedElements(ITreeNode context, IResolveResult result, SymbolTableMode mode);
    [CanBeNullAttribute]
private static ISymbolTable GetSymbolTableForUntypedElementsImpl(ITreeNode context, IDeclaredElement element, ISubstitution substitution, SymbolTableMode mode);
    [NotNullAttribute]
internal static ISymbolTable GetSymbolTable(IResolveContext resolveContext, ITreeNode context, IClrDeclaredElement element, ISubstitution substitution, SymbolTableMode mode);
    public static ISymbolTable GetSymbolTableWithIndexers(ISymbolTable baseTable);
    [NotNullAttribute]
public static IType GetType(IResolveContext resolveContext, IClrDeclaredElement declaredElement, ISubstitution substitution);
    public static ResolveResultWithInfo ResolveConstructor(IResolveContext resolveContext, ISymbolTable table, IAccessContext accessContext, IList`1<IVBArgumentInfo> arguments, IVBTreeNode context);
    [CanBeNullAttribute]
public static ArrayIndexer CreateArrayIndexer(IResolveContext resolveContext, IArrayType arrayType, IList`1<IVBArgument> arguments);
    public static Staticness GetQualifierStaticness(IQualifier qualifier);
    internal static bool CheckOperatorArgumentsConversion(ISignOperator signOperator, ISubstitution substitution, IList`1<IExpressionType> argumentTypes, ITypeConversionRule rule);
    public static ResolveResultWithInfo ResolveOperator(IResolveContext resolveContext, IPsiModule module, string name, IList`1<IVBArgumentInfo> arguments, IVBTreeNode context);
    private static IList`1<DeclaredElementInstance> CollectUserDefinedOperators(string name, IList`1<IExpressionType> operands);
    [NotNullAttribute]
internal static ISymbolTable CreateOperatorsTable(IResolveContext resolveContext, string name, IVBExpression[] operands);
    private static IList`1<DeclaredElementInstance> GetOperatorsFromType(string name, IType type, List`1<IDeclaredType> visited);
    public static IVBExpression GetEnclosingWithExpression(ITreeNode element);
    [CanBeNullAttribute]
public static IAnonymousObjectCreationExpression GetEnclosingAnonymousObjectCreationExpression(ITreeNode element);
    [CanBeNullAttribute]
private static TElement GetQualifierProviderElement(ITreeNode element);
    public static IEnumerable`1<ExtensionInstance`1<IParametersOwner>> GetParametersOwnersWithLifted(IResolveContext resolveContext, IResolveResult resolveResult);
    private static IEnumerable`1<ExtensionInstance`1<IParametersOwner>> GetParametersOwners(IResolveContext resolveContext, IResolveResult result);
    [CanBeNullAttribute]
private static ExtensionInstance`1<IParametersOwner> GetParametersOwnerInstance(IResolveContext resolveContext, ExtensionInstance`1<IDeclaredElement> instance);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IImportClause GetImport(ISymbolInfo symbolInfo);
    [CanBeNullAttribute]
public static DeclaredElementInstance`1<IDelegate> GetDelegateType(IType type, bool forLambda);
    [ExtensionAttribute]
public static ResolveResultWithInfo GetVBResolveResult(ISymbolTable symbolTable, string name);
    [CanBeNullAttribute]
public static IImportClause GetImportClause(ISymbolInfo info);
    [ExtensionAttribute]
public static IResolveInfo ChangeResolveErrorType(IResolveInfo originalInfo, ResolveErrorType errorType);
    [NotNullAttribute]
public static IReadOnlyList`1<ITypeParameter> InferableTypeParameters(ISymbolInfo symbolInfo);
    [CanBeNullAttribute]
public static ITypeMember GetAccessContainingTypeMember(ITreeNode node);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Resolve.VBSymbolInfo : SymbolInfo {
    [CompilerGeneratedAttribute]
private IImportClause <ImportClause>k__BackingField;
    [CanBeNullAttribute]
public IImportClause ImportClause { get; }
    public VBSymbolInfo(IImportClause importClause, string aliasName, IDeclaredElement declaredElement, ISubstitution substitution, int importLevel, Nullable`1<int> inheritanceLevel);
    [CompilerGeneratedAttribute]
public IImportClause get_ImportClause();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual ISymbolInfo ReplaceSubstitution(ISubstitution composedSubstitution);
    public virtual ISymbolInfo ReplaceLevel(int level);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolInfo Create(IImportClause importClause, string shortName, IDeclaredElement declaredElement, ISubstitution substitution, int importLevel, Nullable`1<int> inheritanceLevel);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Impl.Resolve.VBSymbolInfoExt : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExtensionMethod(ISymbolInfo info);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Verification.AccessorAvailabilityVerifier : object {
    public static object GETTER;
    public static object SETTER;
    public static object INIT_ONLY;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static AccessorAvailabilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Verification.AnonymousTypePropertyVerifier : object {
    public static object CIRCULAR_USAGE;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static AnonymousTypePropertyVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Verification.AssignmentTypeCompatibilityVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static AssignmentTypeCompatibilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Verification.DictionaryAccessExpressionResolveVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static DictionaryAccessExpressionResolveVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Verification.InvocationResolveVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static InvocationResolveVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Verification.ReferenceExpressionResolveVerifier : object {
    private static object NOT_RESOLVED;
    private static object MULTITYPE;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static ReferenceExpressionResolveVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Verification.VariableDeclarationTypeCompatibilityVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static VariableDeclarationTypeCompatibilityVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[VerifierAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.Resolve.Verification.XmlMemberAccessResolveVerifier : object {
    private static object NOT_NULL;
    public IEnumerable`1<NodeType> Nodes { get; }
    private static XmlMemberAccessResolveVerifier();
    public sealed virtual IEnumerable`1<NodeType> get_Nodes();
    public sealed virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AccessorDeclaration : ParametersOwnerDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short MODIFIER_LIST;
    public static short KEYWORD;
    public static short VB_PARAMETERS_LIST;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BODY;
    public static short END_DECLARATION;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public IBlock Block { get; }
    public ITokenNode EndDeclaration { get; }
    public ITokenNode Keyword { get; }
    public IModifiersList ModifiersList { get; }
    public IRegularParameterList ParameterList { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public string DeclaredName { get; }
    internal string MemberNamePrefix { get; }
    public int LevelDelta { get; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    public IOverridableMember OwnerMember { get; }
    public AccessorKind Kind { get; }
    public bool IsIterator { get; }
    public bool IsValueParameterDeclared { get; }
    internal Pair`2<bool, IVBParameterDeclaration> ValueParameterDeclaration { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IAccessor JetBrains.ReSharper.Psi.VB.Tree.IAccessorDeclaration.AccessorElement { get; }
    private IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.FunctionElement { get; }
    public ITokenNode StartDeclaration { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndDeclaration();
    public virtual ITokenNode get_Keyword();
    public virtual IModifiersList get_ModifiersList();
    public virtual IRegularParameterList get_ParameterList();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IBlock SetBlock(IBlock param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public virtual string ToString();
    public virtual void SetAbstract(bool value);
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual string get_DeclaredName();
    internal string get_MemberNamePrefix();
    protected internal virtual string GetShortNameOfDeclaredElement();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public virtual AccessRights GetAccessRights();
    protected virtual IRegularParameterList GetParameterListNode();
    protected virtual IRegularParameterList CreateEmptyParameterListNode();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    public IOverridableMember get_OwnerMember();
    public sealed virtual AccessorKind get_Kind();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsValueParameterDeclared();
    internal Pair`2<bool, IVBParameterDeclaration> get_ValueParameterDeclaration();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IAccessor JetBrains.ReSharper.Psi.VB.Tree.IAccessorDeclaration.get_AccessorElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.get_FunctionElement();
    public sealed virtual ITokenNode get_StartDeclaration();
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AddHandlerStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EVENT_EXPR;
    public static short VB_COMMA;
    public static short HANDLER_EXPR;
    public NodeType NodeType { get; }
    public ITokenNode AddHandlerKeyword { get; }
    public ITokenNode Comma { get; }
    public IVBExpression EventExpression { get; }
    public IVBExpression HandlerExpression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AddHandlerKeyword();
    public virtual ITokenNode get_Comma();
    public virtual IVBExpression get_EventExpression();
    public virtual IVBExpression get_HandlerExpression();
    public virtual IVBExpression SetEventExpression(IVBExpression param);
    public virtual IVBExpression SetHandlerExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AdditiveExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AddressOfExpression : VBExpressionBase {
    public static short VB_KEYWORD;
    public static short EXPRESSION;
    public NodeType NodeType { get; }
    public ITokenNode AddressOfKeyword { get; }
    public IPrimaryExpression Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AddressOfKeyword();
    public virtual IPrimaryExpression get_Expression();
    public virtual IPrimaryExpression SetExpression(IPrimaryExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AggregatedRangeVariableDeclaration : VBNonCachedDeclarationBase {
    public static short VB_NAME;
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    private QueryAggregationFunctionReferenceImpl myReferencesImpl;
    private CachedPsiValue`1<IType> myCachedType;
    public NodeType NodeType { get; }
    public ITokenNode EqSign { get; }
    public IQueryAggregatedParameterPlatform Expression { get; }
    public IVBIdentifier Name { get; }
    private bool IsGroup { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    private IVBIdentifier ProjectedIdentifier { get; }
    public string DeclaredName { get; }
    public IType Type { get; }
    private IQueryAnonymousTypeProperty JetBrains.ReSharper.Psi.VB.Tree.IAggregatedRangeVariableDeclaration.DeclaredElement { get; }
    public IDeclaredElement DeclaredElement { get; }
    public IQueryExpression QueryExpression { get; }
    public IVBArgumentInfo ExtensionArgument { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EqSign();
    public virtual IQueryAggregatedParameterPlatform get_Expression();
    public virtual IVBIdentifier get_Name();
    public virtual IQueryAggregatedParameterPlatform SetExpression(IQueryAggregatedParameterPlatform param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    private bool get_IsGroup();
    public virtual ReferenceCollection GetFirstClassReferences();
    private IAggregatedCollectionOwner GetAggregatedCollection();
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public virtual DeclaredElementType GetElementType();
    private IVBIdentifier get_ProjectedIdentifier();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual IType get_Type();
    private sealed virtual override IQueryAnonymousTypeProperty JetBrains.ReSharper.Psi.VB.Tree.IAggregatedRangeVariableDeclaration.get_DeclaredElement();
    public virtual IDeclaredElement get_DeclaredElement();
    public IQueryExpression get_QueryExpression();
    public bool IsSelector();
    public QueryChainTypeBase GetQueryChainType();
    public IVBArgumentInfo get_ExtensionArgument();
    public IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AggregatedRangeVariableDeclarationList : VBCompositeElement {
    public static short DECLARATION;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> DeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> get_Declarations();
    public virtual TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> get_DeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AggregateQueryOperator : QueryOperatorBase {
    public static short AGGREGATE_KEYWORD;
    public static short COLLECTION_DECLARATION_LIST;
    public static short QUERY_OPERATOR;
    public static short INTO_CLAUSE;
    private AggregateReferenceImpl[] myReferences;
    public NodeType NodeType { get; }
    public ITokenNode AggregateKeyword { get; }
    public IQueryCollectionRangeVariableDeclarationList DeclarationList { get; }
    public IIntoOfAggregateQueryOperator IntoClause { get; }
    public TreeNodeCollection`1<IQueryOperator> QueryOperators { get; }
    public TreeNodeEnumerable`1<IQueryOperator> QueryOperatorsEnumerable { get; }
    public TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> CollectionVariables { get; }
    public TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> CollectionVariablesEnumerable { get; }
    public bool IsStandalone { get; }
    public bool HasSignleInto { get; }
    public IQueryReference AggregateReference { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AggregateKeyword();
    public virtual IQueryCollectionRangeVariableDeclarationList get_DeclarationList();
    public virtual IIntoOfAggregateQueryOperator get_IntoClause();
    public virtual TreeNodeCollection`1<IQueryOperator> get_QueryOperators();
    public virtual TreeNodeEnumerable`1<IQueryOperator> get_QueryOperatorsEnumerable();
    public virtual TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> get_CollectionVariables();
    public virtual TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> get_CollectionVariablesEnumerable();
    public virtual IQueryCollectionRangeVariableDeclarationList SetDeclarationList(IQueryCollectionRangeVariableDeclarationList param);
    public virtual IIntoOfAggregateQueryOperator SetIntoClause(IIntoOfAggregateQueryOperator param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual bool get_IsStandalone();
    public bool get_HasSignleInto();
    public sealed virtual IQueryReference get_AggregateReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public IType GetAggregatedType(IResolveContext resolveContext);
    public sealed virtual IType GetGroupVariableType(IResolveContext resolveContext);
    public sealed virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    public sealed virtual QueryChainTypeBase GetAggregatedChainType();
    public virtual ITokenNode get_FirstKeyword();
    [CompilerGeneratedAttribute]
private QueryChainTypeBase <TransitChainType>b__37_0(IAggregatedRangeVariableDeclaration x);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AliasClause : VBCompositeElement {
    public static short ALIAS_KEWORD;
    public static short STRING;
    public NodeType NodeType { get; }
    public ITokenNode AliasKeyword { get; }
    public ITokenNode AliasName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AliasKeyword();
    public virtual ITokenNode get_AliasName();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AnonymousArrayCreationExpression : VBExpressionBase {
    public static short VB_LBRACE;
    public static short VB_INITIALIZER;
    public static short VB_COMMA;
    public static short VB_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IVBExpression> Initializer { get; }
    public TreeNodeEnumerable`1<IVBExpression> InitializerEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IVBExpression> get_Initializer();
    public virtual TreeNodeEnumerable`1<IVBExpression> get_InitializerEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual string ToString();
    internal static bool IsConvertibleAnonymousArrayUsage(IAnonymousArrayCreationExpression expression);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual IType Type(IResolveContext resolveContext);
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
    public sealed virtual IVBExpression AddElementInitializerAfter(IVBExpression param, IVBExpression anchor);
    public sealed virtual IVBExpression AddElementInitializerBefore(IVBExpression param, IVBExpression anchor);
    public sealed virtual void RemoveElementInitializer(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Impl.Tree.AnonymousArrayCreationExpressionUtil : object {
    private static IType GetGenericEnumerableElementType(IType arrayLikeType);
    private static IType GetConvertibleToType(IAnonymousArrayCreationExpression expression, IResolveContext resolveContext);
    public static IType TryGetTargetType(IAnonymousArrayCreationExpression expression);
    internal static IType TryGetTargetType(IAnonymousArrayCreationExpression expression, IResolveContext resolveContext);
    private static IList`1<DeclaredElementInstance`1<IConversionOperator>> GetConversionOperatorsIfUsed(IVBExpression expression, IResolveContext resolveContext, IType conversionTo);
    private static IType GetConvertibleToTypeThroughConversion(IVBExpression expression, IResolveContext resolveContext, IType conversionTo);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AnonymousMemberDeclaration : VBCompositeElement {
    public static short KEY;
    public static short DOT;
    public static short IDENTIFIER;
    public static short VB_EQ;
    public static short EXPRESSION;
    private MyReference myReference;
    private VBAnonymousTypeProperty myProperty;
    public NodeType NodeType { get; }
    public ITokenNode Dot { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public ITokenNode Key { get; }
    public IVBIdentifier Name { get; }
    private IVBAnonymousTypeProperty AnonymousTypeProperty { get; }
    public bool IsKey { get; }
    public IReference ReferenceToProperty { get; }
    public bool IsProjectionInitializer { get; }
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Dot();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_Key();
    public virtual IVBIdentifier get_Name();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    private IVBAnonymousTypeProperty get_AnonymousTypeProperty();
    public sealed virtual string GetName();
    public sealed virtual bool get_IsKey();
    public sealed virtual TreeTextRange GetNameTextRange();
    public sealed virtual DocumentRange GetNameDocumentRange();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual IReference get_ReferenceToProperty();
    public sealed virtual bool get_IsProjectionInitializer();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public sealed virtual TreeTextRange GetNameRange();
    public sealed virtual bool IsSynthetic();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AnonymousObjectCreationExpression : VBExpressionBase {
    public static short VB_KEYWORD;
    public static short INITIALIZER;
    public NodeType NodeType { get; }
    public IAnonymousObjectInitializer Initializer { get; }
    public ITokenNode NewKeyword { get; }
    public TreeNodeCollection`1<IAnonymousMemberDeclaration> MemberDeclarations { get; }
    public TreeNodeEnumerable`1<IAnonymousMemberDeclaration> MemberDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAnonymousObjectInitializer get_Initializer();
    public virtual ITokenNode get_NewKeyword();
    public virtual TreeNodeCollection`1<IAnonymousMemberDeclaration> get_MemberDeclarations();
    public virtual TreeNodeEnumerable`1<IAnonymousMemberDeclaration> get_MemberDeclarationsEnumerable();
    public virtual IAnonymousObjectInitializer SetInitializer(IAnonymousObjectInitializer param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    private IList`1<IVBAnonymousTypeProperty> GetProperties(IResolveContext resolveContext);
    private IType GetPropertyType(IResolveContext resolveContext, IVBExpression initializer);
    private IList`1<AnonymousTypeDescriptor> GetTypeDescriptor(IResolveContext resolveContext);
    public sealed virtual IList`1<AnonymousTypeDescriptor> GetTypeDescriptor();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AnonymousObjectInitializer : VBCompositeElement {
    public static short WITH_KEYWORD;
    public static short VB_LBRACE;
    public static short MEMBER_DECLARATION;
    public static short VB_COMMA;
    public static short VB_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IAnonymousMemberDeclaration> MemberDeclarations { get; }
    public TreeNodeEnumerable`1<IAnonymousMemberDeclaration> MemberDeclarationsEnumerable { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode WithKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IAnonymousMemberDeclaration> get_MemberDeclarations();
    public virtual TreeNodeEnumerable`1<IAnonymousMemberDeclaration> get_MemberDeclarationsEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual ITokenNode get_WithKeyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AnonymousTypeCreationQualifier : object {
    [NotNullAttribute]
private IAnonymousObjectCreationExpression myObjectCreationExpression;
    [NotNullAttribute]
private ITreeNode myElement;
    public bool Resolved { get; }
    public AnonymousTypeCreationQualifier(IAnonymousObjectCreationExpression objectCreationExpression, ITreeNode element);
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public sealed virtual ITypeElement GetQualifierTypeElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ArgumentList : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short VB_RPARENTH;
    public static short VB_ARGUMENT;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ArrayBound : VBCompositeElement {
    public static short BOUND1;
    public static short TO_KEYWORD;
    public static short BOUND2;
    public NodeType NodeType { get; }
    public IVBExpression Bound1 { get; }
    public IVBExpression Bound2 { get; }
    public ITokenNode ToKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Bound1();
    public virtual IVBExpression get_Bound2();
    public virtual ITokenNode get_ToKeyword();
    public virtual IVBExpression SetBound1(IVBExpression param);
    public virtual IVBExpression SetBound2(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ArrayCreationExpression : VBExpressionBase {
    public static short VB_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public static short VB_INITIALIZER;
    public NodeType NodeType { get; }
    public IAnonymousArrayCreationExpression ArrayInitializer { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode NewLeyword { get; }
    public ITokenNode NullableMark { get; }
    public IDeclaredTypeUsage TypeUsage { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAnonymousArrayCreationExpression get_ArrayInitializer();
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual ITokenNode get_NewLeyword();
    public virtual ITokenNode get_NullableMark();
    public virtual IDeclaredTypeUsage get_TypeUsage();
    public virtual IAnonymousArrayCreationExpression SetArrayInitializer(IAnonymousArrayCreationExpression param);
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual IDeclaredTypeUsage SetTypeUsage(IDeclaredTypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual void SetArrayType(IArrayType arrayType);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ArrayModifier : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short ARRAY_BOUND;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IArrayBound> ArrayBounds { get; }
    public TreeNodeEnumerable`1<IArrayBound> ArrayBoundsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IArrayBound> get_ArrayBounds();
    public virtual TreeNodeEnumerable`1<IArrayBound> get_ArrayBoundsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ArrayModifiersList : VBCompositeElement {
    public static short ARRAY_MODIFIER;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IArrayModifier> ArrayModifiers { get; }
    public TreeNodeEnumerable`1<IArrayModifier> ArrayModifiersEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IArrayModifier> get_ArrayModifiers();
    public virtual TreeNodeEnumerable`1<IArrayModifier> get_ArrayModifiersEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AssignmentStatement : StatementBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    private BinaryOperatorReference myReference;
    public NodeType NodeType { get; }
    public IVBExpression LValue { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RValue { get; }
    public bool IsCompoundAssignment { get; }
    public AssignmentType AssignmentType { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    public IVBTreeNode Node { get; }
    private IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.Reference { get; }
    public ITokenNode Sign { get; }
    public IList`1<IType> TypeArguments { get; }
    public IVBOperatorReference Reference { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IVBExpression Left { get; }
    public IVBExpression Right { get; }
    public TokenNodeType SignTokenType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LValue();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RValue();
    public virtual IVBExpression SetLValue(IVBExpression param);
    public virtual IVBExpression SetRValue(IVBExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual bool get_IsCompoundAssignment();
    public sealed virtual AssignmentType get_AssignmentType();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    public sealed virtual IVBTreeNode get_Node();
    private sealed virtual override IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_Reference();
    public sealed virtual ITokenNode get_Sign();
    public sealed virtual IList`1<IType> get_TypeArguments();
    public sealed virtual IVBOperatorReference get_Reference();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IVBExpression get_Left();
    public sealed virtual IVBExpression get_Right();
    public sealed virtual IAccessContext GetAccessContext();
    public sealed virtual TokenNodeType get_SignTokenType();
    public sealed virtual TreeTextRange GetSignTreeTextRange();
    public virtual ReferenceCollection GetFirstClassReferences();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.Attribute : VBCompositeElement {
    public static short TARGET;
    public static short VB_COLON;
    public static short VB_TYPE_USAGE;
    public static short VB_ARGUMENT_LIST;
    private MyConstructorReference myReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public IReferenceName AttributeType { get; }
    public ITokenNode Colon { get; }
    public ITokenNode Target { get; }
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public IReference ConstructorReference { get; }
    public IReference TypeReference { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    private IList`1<IVBArgumentInfo> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.InvocationArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    public IVBTreeNode Node { get; }
    public IVBInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual IReferenceName get_AttributeType();
    public virtual ITokenNode get_Colon();
    public virtual ITokenNode get_Target();
    public virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual IReferenceName SetAttributeType(IReferenceName param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IReference get_ConstructorReference();
    public sealed virtual IReference get_TypeReference();
    public Hash AddToHash(Hash hash);
    public sealed virtual T AddArgumentBefore(T argument, IVBArgument anchor);
    public sealed virtual T AddArgumentAfter(T argument, IVBArgument anchor);
    public sealed virtual void RemoveArgument(IVBArgument argument);
    public sealed virtual T ReplaceArgument(IVBArgument oldArgument, T newArgument);
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    private sealed virtual override IList`1<IVBArgumentInfo> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_InvocationArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    public sealed virtual IVBTreeNode get_Node();
    public sealed virtual IVBInvocationReference get_Reference();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AttributeList : VBCompositeElement {
    public static short VB_LT;
    public static short ATTRIBUTE;
    public static short VB_COMMA;
    public static short VB_GT;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> LeftAngle { get; }
    public TreeNodeEnumerable`1<ITokenNode> LeftAngleEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> RightAngle { get; }
    public TreeNodeEnumerable`1<ITokenNode> RightAngleEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_LeftAngle();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_LeftAngleEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_RightAngle();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_RightAngleEnumerable();
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.AttributesOwnerDeclarationBase : VBDeclarationBase {
    internal IAttributeListOwner AttributeListOwner { get; }
    protected ICollection`1<SpecialDependencyKind> SpecialDepependencies { get; }
    private IEnumerable`1<IVBHashableDeclaration> JetBrains.ReSharper.Psi.VB.Impl.Tree.IVBHashableDeclaration.Children { get; }
    public bool IsInternal { get; }
    internal abstract virtual IAttributeListOwner get_AttributeListOwner();
    public virtual bool IsSynthetic();
    public sealed virtual void RemoveAttribute(IAttribute attribute);
    public sealed virtual IAttribute AddAttribute(IAttribute attribute);
    public virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    protected IHashableEntityInfo CalcMainHash(string parentQualifiedName, String& qualifiedName);
    protected virtual Hash CalculateHashInternal();
    public sealed virtual Hash CalcHash();
    protected virtual ICollection`1<SpecialDependencyKind> get_SpecialDepependencies();
    private sealed virtual override IEnumerable`1<IVBHashableDeclaration> JetBrains.ReSharper.Psi.VB.Impl.Tree.IVBHashableDeclaration.get_Children();
    public virtual bool get_IsInternal();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AwaitExpression : VBExpressionBase {
    public static short VB_KEYWORD;
    public static short EXPRESSION;
    private MyGetAwaiterReference myGetAwaiterReference;
    private MyAwaiterGetResultReference myAwaiterGetResultReference;
    private MyAwaiterOnCompletedReference myAwaiterOnCompletedReference;
    private MyAwaiterIsCompletedReference myAwaiterIsCompletedReference;
    public NodeType NodeType { get; }
    public ITokenNode AwaitKeyword { get; }
    public IPrimaryExpression Expression { get; }
    public IManagedReference GetAwaiterReference { get; }
    public IManagedReference AwaiterGetResultReference { get; }
    public IManagedReference AwaiterOnCompletedReference { get; }
    public IManagedReference AwaiterIsCompletedReference { get; }
    public IType AwaitableType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AwaitKeyword();
    public virtual IPrimaryExpression get_Expression();
    public virtual IPrimaryExpression SetExpression(IPrimaryExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IManagedReference get_GetAwaiterReference();
    public sealed virtual IManagedReference get_AwaiterGetResultReference();
    public sealed virtual IManagedReference get_AwaiterOnCompletedReference();
    public sealed virtual IManagedReference get_AwaiterIsCompletedReference();
    public sealed virtual IType get_AwaitableType();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.AwaitStatement : StatementBase {
    public static short EXPR;
    public NodeType NodeType { get; }
    public IAwaitExpression Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAwaitExpression get_Expression();
    public virtual IAwaitExpression SetExpression(IAwaitExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.BinaryOperatorReference : ManagedNonQualifiableReferenceBase`1<IVBBinaryOperatorNodeImpl> {
    public IVBInvocationInfo Invocation { get; }
    public BinaryOperatorReference(IVBBinaryOperatorNodeImpl owner);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public sealed virtual IList`1<InvokedSymbolInfo> GetCandidatesWithMatchers();
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    private sealed virtual override IVBOperatorNode JetBrains.ReSharper.Psi.VB.Tree.IVBOperatorReference.GetTreeNode();
    public virtual string GetName();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual TreeTextRange GetTreeTextRange();
    public sealed virtual bool ShouldInferTypeArguments();
    public sealed virtual string InvocationName();
    public sealed virtual IVBInvocationInfo get_Invocation();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.Block : VBCompositeElement {
    public static short VB_STATEMENT_TERMINATOR;
    public static short STATEMENT;
    private int myModificationStamp;
    private CompactOneToListMap`2 modreq(System.Runtime.CompilerServices.IsVolatile) myLabels;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IVBStatement> Statements { get; }
    public TreeNodeEnumerable`1<IVBStatement> StatementsEnumerable { get; }
    private Nullable`1<int> JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.ModificationStamp { get; private set; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public bool IsBody { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IVBStatement> get_Statements();
    public virtual TreeNodeEnumerable`1<IVBStatement> get_StatementsEnumerable();
    public virtual string ToString();
    private sealed virtual override Nullable`1<int> JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.get_ModificationStamp();
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.set_ModificationStamp(Nullable`1<int> value);
    protected virtual void ClearCachedData();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    internal static IEnumerable`1<IDeclaredElement> GetLocalVariables(IVBTreeNode scope, Func`1<ISymbolTable> parentTable, IEnumerable`1<IVBStatement> statements);
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IList`1<ILabel> GetLabelByName(string name);
    public sealed virtual IList`1<ILabel> GetAllLabels();
    public sealed virtual void RemoveStatement(IVBStatement statement);
    public sealed virtual IVBStatement AddStatementBefore(IVBStatement statement, IVBStatementsRange anchorRange);
    public sealed virtual IVBStatement AddStatementAfter(IVBStatement statement, IVBStatementsRange anchorRange);
    public sealed virtual IVBStatement AddStatement(IVBStatement statement, IVBStatement anchorStatement, bool before);
    public sealed virtual IVBStatementsRange GetAllStatementsRange();
    public sealed virtual IVBStatementsRange GetStatementsRange(TreeTextRange textRange);
    public sealed virtual IVBStatementsRange GetStatementsRange(IVBStatement first, IVBStatement last);
    public sealed virtual void RemoveStatementsRange(IVBStatementsRange range);
    public sealed virtual IVBStatementsRange AddStatementsRange(IVBStatementsRange range, ITreeNode anchor, bool before);
    public sealed virtual bool get_IsBody();
    public sealed virtual IBlock ReplaceBy(IBlock block);
    [CompilerGeneratedAttribute]
private ISymbolTable <get_LocalVariables>b__29_0();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.BlockIfStatement : StatementBase {
    public static short IF_KEYWORD;
    public static short EXPRESSION;
    public static short THEN_KEYWORD;
    public static short VB_BLOCK;
    public static short ELSEIF_STMT;
    public static short ELSE_STMT;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public TreeNodeCollection`1<IElseIfStatement> ElseIfStatements { get; }
    public TreeNodeEnumerable`1<IElseIfStatement> ElseIfStatementsEnumerable { get; }
    public IElseStatement ElseStatement { get; }
    public ITokenNode EndIf { get; }
    public IVBExpression Expression { get; }
    public ITokenNode IfKeyword { get; }
    public ITokenNode ThenKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual TreeNodeCollection`1<IElseIfStatement> get_ElseIfStatements();
    public virtual TreeNodeEnumerable`1<IElseIfStatement> get_ElseIfStatementsEnumerable();
    public virtual IElseStatement get_ElseStatement();
    public virtual ITokenNode get_EndIf();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_IfKeyword();
    public virtual ITokenNode get_ThenKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IElseStatement SetElseStatement(IElseStatement param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.CaseClause : VBCompositeElement {
    public static short IS_KEYWORD;
    public static short EXPRESSION;
    public static short TO_KEYWORD;
    public static short TO_EXPRESSION;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode IsKeyword { get; }
    public IVBExpression ToExpression { get; }
    public ITokenNode ToKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_IsKeyword();
    public virtual IVBExpression get_ToExpression();
    public virtual ITokenNode get_ToKeyword();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual IVBExpression SetToExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.CaseStatement : CaseStatementStub {
    public virtual IBlock SetBlock(IBlock param);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.CaseStatementStub : StatementBase {
    public static short CASE_KEYWORD;
    public static short CASE_CLAUSE;
    public static short VB_COMMA;
    public static short ELSE_KEYWORD;
    public static short VB_BLOCK;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public TreeNodeCollection`1<ICaseClause> CaseClauses { get; }
    public TreeNodeEnumerable`1<ICaseClause> CaseClausesEnumerable { get; }
    public ITokenNode CaseKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ElseKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual TreeNodeCollection`1<ICaseClause> get_CaseClauses();
    public virtual TreeNodeEnumerable`1<ICaseClause> get_CaseClausesEnumerable();
    public virtual ITokenNode get_CaseKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_ElseKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.CastExpression : VBExpressionBase {
    public static short VB_KEYWORD;
    public static short VB_LPARENTH;
    public static short EXPRESSION;
    public static short VB_COMMA;
    public static short VB_TYPE_USAGE;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public ITokenNode Comma { get; }
    public IVBExpression Expression { get; }
    public ITokenNode Keyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    public CastExpressionKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Comma();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_Keyword();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IType GetCastType();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual CastExpressionKind get_Kind();
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.CatchStatement : StatementBase {
    public static short CATCH_KEYWORD;
    public static short CATCH_VAR;
    public static short CATCH_EXPR;
    public static short WHEN_KEYWORD;
    public static short EXPR;
    public static short VB_BLOCK;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode CatchKeyword { get; }
    public ICatchVariableDeclaration CatchVariableDeclaration { get; }
    public IReferenceExpression CatchVariableExpression { get; }
    public IVBExpression Expression { get; }
    public ITokenNode WhenKeyword { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public IDeclaredType ExceptionType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_CatchKeyword();
    public virtual ICatchVariableDeclaration get_CatchVariableDeclaration();
    public virtual IReferenceExpression get_CatchVariableExpression();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_WhenKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual ICatchVariableDeclaration SetCatchVariableDeclaration(ICatchVariableDeclaration param);
    public virtual IReferenceExpression SetCatchVariableExpression(IReferenceExpression param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IDeclaredType get_ExceptionType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.CatchVariableDeclaration : LocalVariableDeclarationBase {
    public static short VB_NAME;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    public string DeclaredName { get; }
    public ILocalVariable DeclaredVariable { get; }
    public bool IsImplicitlyTyped { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual IVBIdentifier get_Name();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ILocalVariable get_DeclaredVariable();
    public virtual IType CalculateType(IResolveContext resolveContext);
    public virtual bool get_IsImplicitlyTyped();
    public sealed virtual void SetType(IType type);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ChameleonBlock : Block {
    private bool myOpened;
    private object mySyncObject;
    public bool IsOpened { get; }
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public ChameleonBlock(ClosedChameleonElement closedChameleonElement);
    public ChameleonBlock(int length);
    public ChameleonBlock(IBuffer buffer, TreeOffset startOffset, int length);
    internal ChameleonBlock(CompositeElement block);
    public sealed virtual bool get_IsOpened();
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    protected virtual TreeElement DeepClone(TreeNodeCopyContext context);
    public virtual IBuffer GetTextAsBuffer();
    private void OpenChameleon();
    private void OpenChameleonFrom(ITreeNode chameleon);
    public virtual string ToString();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual ITreeNode FindNodeAt(TreeTextRange treeRange);
    public virtual void FindNodesAtInternal(TreeTextRange relativeRange, List`1<ITreeNode> result, bool includeContainingNodes);
    public static bool IsStopWordForBlock(TokenNodeType nodeType);
    public static Nullable`1<int> ScanChameleon(ILexer lexer);
    public sealed virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    [CompilerGeneratedAttribute]
private ITreeNode <OpenChameleon>b__17_0(IParser parser);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.CharsetModifier : VBCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ClassBaseClause : VBCompositeElement {
    public static short INHERITS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public NodeType NodeType { get; }
    public ITokenNode InheritsKeyword { get; }
    public IDeclaredTypeUsage InheritsType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_InheritsKeyword();
    public virtual IDeclaredTypeUsage get_InheritsType();
    public virtual IDeclaredTypeUsage SetInheritsType(IDeclaredTypeUsage param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ClassBody : VBCompositeElement {
    public static short VB_STATEMENT_TERMINATOR;
    public static short TYPE_DECLARATION;
    public static short EVENT_DECLARATION;
    public static short EXTERNAL_METHOD_DECLARATION;
    public static short PROPERTY_DECLARATION;
    public static short SIGN_OPERATOR_DECLARATION;
    public static short CONVERSION_OPERATOR_DECLARATION;
    public static short CONSTANT_DECLARATION;
    public static short VARIABLE_DECLARATION;
    public static short METHOD_DECLARATION;
    public static short CONSTRUCTOR_DECLARATION;
    private CachedPsiValue`1<Tuple`3<ISymbolTable, int, SymbolTableMode>> myTableCache;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConversionOperatorDeclaration> ConversionOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IConversionOperatorDeclaration> ConversionOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IExternalMethodDeclaration> ExternalMethodDeclarations { get; }
    public TreeNodeEnumerable`1<IExternalMethodDeclaration> ExternalMethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMultipleConstantDeclaration> MultipleConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleConstantDeclaration> MultipleConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMultipleVariableDeclaration> MultipleVariableDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleVariableDeclaration> MultipleVariableDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ISignOperatorDeclaration> SignOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<ISignOperatorDeclaration> SignOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> TypeDeclarationsEnumerable { get; }
    public int LevelDelta { get; }
    public Tuple`3<ISymbolTable, int, SymbolTableMode> CachedTable { get; public set; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IExternalMethodDeclaration> get_ExternalMethodDeclarations();
    public virtual TreeNodeEnumerable`1<IExternalMethodDeclaration> get_ExternalMethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IMultipleConstantDeclaration> get_MultipleConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IMultipleConstantDeclaration> get_MultipleConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IMultipleVariableDeclaration> get_MultipleVariableDeclarations();
    public virtual TreeNodeEnumerable`1<IMultipleVariableDeclaration> get_MultipleVariableDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ISignOperatorDeclaration> get_SignOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<ISignOperatorDeclaration> get_SignOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IVBTreeNode> get_TypeDeclarations();
    public virtual TreeNodeEnumerable`1<IVBTreeNode> get_TypeDeclarationsEnumerable();
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual Tuple`3<ISymbolTable, int, SymbolTableMode> get_CachedTable();
    public sealed virtual void set_CachedTable(Tuple`3<ISymbolTable, int, SymbolTableMode> value);
    protected virtual void PreInit();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ClassDeclaration : ClassLikeDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short CLASS_KEYWORD;
    public static short VB_NAME;
    public static short VB_TYPE_PARAMETERS_LIST;
    public static short VB_STATEMENT_TERMINATOR;
    public static short INHERITS_CLAUSE;
    public static short IMPLEMENTS_CLAUSE;
    public static short VB_BODY;
    public static short VB_END_DECLARATION;
    private IVBIdentifier myCachedName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedNameValid;
    private ITypeParameterOfTypeList myCachedTypeParameterList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedTypeParameterListValid;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public IClassBaseClause BaseClause { get; }
    public IClassBody Body { get; }
    public ITokenNode ClassKeyword { get; }
    public ITokenNode EndClass { get; }
    public TreeNodeCollection`1<ITypeImplementsClause> ImplementsClauses { get; }
    public TreeNodeEnumerable`1<ITypeImplementsClause> ImplementsClausesEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IVBIdentifier Name { get; }
    protected IVBIdentifier _Name { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    protected ITypeParameterOfTypeList _TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConversionOperatorDeclaration> ConversionOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IConversionOperatorDeclaration> ConversionOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> ImplementsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> ImplementsTypesEnumerable { get; }
    public IDeclaredTypeUsage InheritsType { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> NestedTypeDeclarationsEnumerable { get; }
    public IVBNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ISignOperatorDeclaration> SignOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<ISignOperatorDeclaration> SignOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> TypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    public TreeNodeCollection`1<IVBTypeMemberDeclaration> MemberDeclarations { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarationsEnumerable { get; }
    public IList`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public IEnumerable`1<IDeclaredTypeUsage> ExtendsListTypeUsages { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.TypeElement { get; }
    public ITokenNode OpenKeyword { get; }
    public ITokenNode EndKeyword { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IClass JetBrains.ReSharper.Psi.VB.Tree.IClassDeclaration.DeclaredElement { get; }
    public int LevelDelta { get; }
    public bool IsPartial { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual IClassBaseClause get_BaseClause();
    public virtual IClassBody get_Body();
    public virtual ITokenNode get_ClassKeyword();
    public virtual ITokenNode get_EndClass();
    public virtual TreeNodeCollection`1<ITypeImplementsClause> get_ImplementsClauses();
    public virtual TreeNodeEnumerable`1<ITypeImplementsClause> get_ImplementsClausesEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public sealed virtual IVBIdentifier get_Name();
    protected virtual IVBIdentifier get__Name();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public sealed virtual ITypeParameterOfTypeList get_TypeParameterList();
    protected virtual ITypeParameterOfTypeList get__TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_ImplementsTypes();
    public virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_ImplementsTypesEnumerable();
    public virtual IDeclaredTypeUsage get_InheritsType();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVBTreeNode> get_NestedTypeDeclarations();
    public virtual TreeNodeEnumerable`1<IVBTreeNode> get_NestedTypeDeclarationsEnumerable();
    public virtual IVBNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ISignOperatorDeclaration> get_SignOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<ISignOperatorDeclaration> get_SignOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVBTreeNode> get_TypeDeclarations();
    public virtual TreeNodeEnumerable`1<IVBTreeNode> get_TypeDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<IVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IClassBaseClause SetBaseClause(IClassBaseClause param);
    public virtual IClassBody SetBody(IClassBody param);
    public virtual IDeclaredTypeUsage SetInheritsType(IDeclaredTypeUsage param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    protected virtual IClassBody GetBody();
    public sealed virtual TreeNodeCollection`1<IVBTypeMemberDeclaration> get_MemberDeclarations();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarationsEnumerable();
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration param);
    public sealed virtual IList`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Tree.ClassDeclaration/<get_ExtendsListTypeUsages>d__132")]
public virtual IEnumerable`1<IDeclaredTypeUsage> get_ExtendsListTypeUsages();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.get_TypeElement();
    public sealed virtual ITokenNode get_OpenKeyword();
    public sealed virtual ITokenNode get_EndKeyword();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IClass JetBrains.ReSharper.Psi.VB.Tree.IClassDeclaration.get_DeclaredElement();
    private ISymbolTable AddClassGlobalDeclarations(int level, SymbolTableMode mode);
    private ISymbolTable AddSuperClassDeclarations(int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    [NotNullAttribute]
private ISymbolTable CreateClassSymbolTable(int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual ITypeImplementsClause AddImplementsClauseBefore(ITypeImplementsClause param, ITypeImplementsClause anchor);
    public sealed virtual ITypeImplementsClause AddImplementsClauseAfter(ITypeImplementsClause param, ITypeImplementsClause anchor);
    public sealed virtual void SetBaseClass(IDeclaredType base);
    public sealed virtual void AddImplementsType(IDeclaredType implementsType);
    public sealed virtual void RemoveImplementsType(IDeclaredType implementsType);
    public sealed virtual bool get_IsPartial();
    public sealed virtual void SetPartial(bool value);
    public sealed virtual void SetExtern(bool value);
    public sealed virtual void SetUnsafe(bool value);
    public sealed virtual void SetVolatile(bool value);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.ClassLikeDeclarationBase : TypeElementDeclarationBase {
    public IEnumerable`1<IDeclaredTypeUsage> ExtendsListTypeUsages { get; }
    public IEnumerable`1<IDeclaredType> SuperTypes { get; }
    public bool HasAccessRights { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsOverloads { get; }
    public bool IsWriteonly { get; }
    public abstract virtual IEnumerable`1<IDeclaredTypeUsage> get_ExtendsListTypeUsages();
    public sealed virtual IEnumerable`1<IDeclaredType> get_SuperTypes();
    [CanBeNullAttribute]
protected abstract virtual IClassBody GetBody();
    public sealed virtual TTypeMemberDeclaration AddTypeMemberDeclarationAfter(TTypeMemberDeclaration member, IVBTypeMemberDeclaration anchor);
    private TTypeMemberDeclaration DoAddTypeMemberDeclarationAfter(TTypeMemberDeclaration member, ITreeNode anchor);
    public sealed virtual TTypeMemberDeclaration AddTypeMemberDeclarationBefore(TTypeMemberDeclaration member, IVBTypeMemberDeclaration anchor);
    public virtual IClassLikeDeclaration GetContainingClassLikeDeclaration();
    public sealed virtual void RemoveTypeMemberDeclaration(IVBTypeMemberDeclaration member);
    public sealed virtual TTypeMemberDeclaration AddTypeMemberDeclaration(TTypeMemberDeclaration member);
    public sealed virtual TTypeMemberDeclaration InsertAtSpecificPosition(TTypeMemberDeclaration param, ITreeNode anchor);
    public sealed virtual TreeTextRange GetBodyTreeRange();
    public sealed virtual bool get_HasAccessRights();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsOverloads();
    public sealed virtual bool get_IsWriteonly();
    public sealed virtual void SetAccessRights(AccessRights rights);
    public sealed virtual void SetAbstract(bool value);
    public sealed virtual void SetSealed(bool value);
    public sealed virtual void SetVirtual(bool value);
    public sealed virtual void SetOverride(bool value);
    public sealed virtual void SetStatic(bool value);
    public sealed virtual void SetOverloads(bool value);
    public sealed virtual void SetReadonly(bool value);
    public sealed virtual void SetWriteonly(bool value);
    public sealed virtual IDeclarationsRange GetAllDeclarationsRange();
    public sealed virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange range);
    public sealed virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    [NotNullAttribute]
private static ITreeRange FixupDeclarationsRange(IDeclarationsRange range);
    [CanBeNullAttribute]
private static ITreeNode FixupAnchor(ITreeNode anchor, bool willInsertBefore);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.CollectionElementInitializer : VBCompositeElement {
    public static short VB_LBRACE;
    public static short VB_INITIALIZER;
    public static short VB_COMMA;
    public static short VB_RBRACE;
    public static short EXPRESSION;
    private MyReference myReference;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<IVBExpression> Initializer { get; }
    public TreeNodeEnumerable`1<IVBExpression> InitializerEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public IPsiModule PsiModule { get; }
    private IObjectCreationExpression CreationExpression { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IVBTreeNode Node { get; }
    [NotNullAttribute]
public IVBInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    [NotNullAttribute]
private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual IVBExpression get_Expression();
    public virtual TreeNodeCollection`1<IVBExpression> get_Initializer();
    public virtual TreeNodeEnumerable`1<IVBExpression> get_InitializerEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IPsiModule get_PsiModule();
    private IObjectCreationExpression get_CreationExpression();
    public sealed virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual IVBTreeNode get_Node();
    public sealed virtual IVBInvocationReference get_Reference();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual void RemoveInitializerArgumentAt(int index);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.CollectionRangeVariableDeclarationBase : VBNonCachedDeclarationBase {
    private AsQueryableReferenceImpl myAsQueryableReference;
    private AsEnumerableReferenceImpl myAsEnumerableReference;
    private DirectCastReferenceImpl myDirectCastingReference;
    private CastingSelectReferenceImpl mySelectReference;
    private CachedPsiValue`1<IType> myCachedType;
    protected ITypeUsage TypeUsage2 { get; }
    protected IVBExpression Expression2 { get; }
    protected IVBIdentifier Name2 { get; }
    protected ITokenNode AsKeyword2 { get; }
    protected TreeTextRange ReferencesTextRange { get; }
    public string DeclaredName { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public IType Type { get; }
    public IDeclaredElement DeclaredElement { get; }
    public IQueryReference AsQueryableReference { get; }
    public IQueryReference AsEnumerableReference { get; }
    public IQueryReference DirectCastingReference { get; }
    public IQueryReference SelectReference { get; }
    protected abstract virtual ITypeUsage get_TypeUsage2();
    protected abstract virtual IVBExpression get_Expression2();
    protected abstract virtual IVBIdentifier get_Name2();
    protected abstract virtual ITokenNode get_AsKeyword2();
    protected abstract virtual TreeTextRange get_ReferencesTextRange();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IType CalculateType(IResolveContext resolveContext);
    protected IType CalculateTypeFromExpression(IResolveContext resolveContext);
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual bool HasAsEnumerableReference(IResolveContext resolveContext);
    public sealed virtual bool HasAsQueryableReference(IResolveContext resolveContext);
    public sealed virtual bool HasDirectCastReference(IResolveContext resolveContext);
    public virtual bool HasSelectReference(IResolveContext resolveContext);
    public virtual IExpressionType GetCastedCollectionType(IResolveContext resolveContext);
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IType get_Type();
    public virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual IQueryReference get_AsQueryableReference();
    public sealed virtual IQueryReference get_AsEnumerableReference();
    public sealed virtual IQueryReference get_DirectCastingReference();
    public IQueryReference get_SelectReference();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.Comment : VBToken {
    public CommentType CommentType { get; }
    public string CommentText { get; }
    public bool IsOpened { get; }
    public Comment(NodeType type, IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public virtual bool IsFiltered();
    public sealed virtual CommentType get_CommentType();
    public sealed virtual string get_CommentText();
    public sealed virtual TreeTextRange GetCommentRange();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    public sealed virtual bool get_IsOpened();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ConcatenationExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ConditionalAccessSign : VBCompositeElement {
    public static short VB_OP_SIGN;
    public NodeType NodeType { get; }
    public ITokenNode Question { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Question();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ConditionalExpression : VBExpressionBase {
    public static short IF_KEYWORD;
    public static short VB_ARGUMENT_LIST;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public ITokenNode IfKeyword { get; }
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public ConditionalExpressionKind Kind { get; }
    public IVBExpression Condition { get; }
    public IVBExpression ThenExpression { get; }
    public IVBExpression ElseExpression { get; }
    public IVBExpression FirstOperandOfNullCoalescing { get; }
    public IVBExpression SecondOperandOfNullCoalescing { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual ITokenNode get_IfKeyword();
    public virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual string ToString();
    public sealed virtual ConditionalExpressionKind get_Kind();
    public sealed virtual IVBExpression get_Condition();
    public sealed virtual IVBExpression get_ThenExpression();
    public sealed virtual IVBExpression get_ElseExpression();
    public sealed virtual IVBExpression get_FirstOperandOfNullCoalescing();
    public sealed virtual IVBExpression get_SecondOperandOfNullCoalescing();
    [CanBeNullAttribute]
private IVBExpression GetExpression(ConditionalExpressionKind predicateKind, int i);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    [NotNullAttribute]
private IExpressionType GetNonconstantExpressionType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ConstantDeclaration : TypeMemberDeclarationBase {
    public static short VB_NAME;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    private JetHashSet`1<Thread> myComputationThreads;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    public string DeclaredName { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IField JetBrains.ReSharper.Psi.VB.Tree.IConstantDeclaration.ConstantElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public IType Type { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Initializer();
    public virtual IVBIdentifier get_Name();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    private void RemoveCurrentThreadFromTable();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    public ConstantValue CalculateConstantValue();
    public virtual string get_DeclaredName();
    public virtual TreeTextRange GetNameRange();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    public virtual void SetAccessRights(AccessRights rights);
    public virtual void SetName(string name);
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    protected virtual Hash CalculateHashInternal();
    protected virtual IDeclaredElement CreateDeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IField JetBrains.ReSharper.Psi.VB.Tree.IConstantDeclaration.get_ConstantElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public virtual AccessRights GetAccessRights();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ConstPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short CONST_KEYWORD;
    public static short VB_NAME;
    public static short VB_EQ;
    public static short EXPRESSION;
    public NodeType NodeType { get; }
    public ITokenNode ConstKeyword { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode Sharp { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ConstKeyword();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Expression();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_Sharp();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ConstructorDeclaration : ParametersOwnerDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short SUB_KEYWORD;
    public static short VB_NAME;
    public static short VB_PARAMETERS_LIST;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BODY;
    public static short END_DECLARATION;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public IBlock Block { get; }
    public ITokenNode EndDeclaration { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode NewKeyword { get; }
    public IRegularParameterList ParameterList { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode SubKeyword { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    public int LevelDelta { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.FunctionElement { get; }
    public ITokenNode StartDeclaration { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public IIndexExpression Initializer { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    private IConstructor JetBrains.ReSharper.Psi.VB.Tree.IConstructorDeclaration.ConstructorElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndDeclaration();
    public virtual IModifiersList get_ModifiersList();
    public virtual ITokenNode get_NewKeyword();
    public virtual IRegularParameterList get_ParameterList();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITokenNode get_SubKeyword();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IBlock SetBlock(IBlock param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    protected internal virtual string GetShortNameOfDeclaredElement();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.get_FunctionElement();
    public sealed virtual ITokenNode get_StartDeclaration();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    protected virtual IRegularParameterList GetParameterListNode();
    protected virtual IRegularParameterList CreateEmptyParameterListNode();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IIndexExpression get_Initializer();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    protected virtual IDeclaredElement CreateDeclaredElement();
    private sealed virtual override IConstructor JetBrains.ReSharper.Psi.VB.Tree.IConstructorDeclaration.get_ConstructorElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ContinueStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short CONTINUE_KIND;
    public NodeType NodeType { get; }
    public ITokenNode ContinueKeyword { get; }
    public ITokenNode ContinueKind { get; }
    public ContinueStatementKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ContinueKeyword();
    public virtual ITokenNode get_ContinueKind();
    public virtual string ToString();
    public sealed virtual ContinueStatementKind get_Kind();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ControlReference : VBCompositeElement {
    public static short VB_QUALIFIER;
    public static short VB_DOT;
    public static short MEMBER_NAME;
    private MyReference myReference;
    public NodeType NodeType { get; }
    public IVBIdentifier ControlName { get; }
    public ITokenNode Dot { get; }
    public IControlReference Qualifier { get; }
    public IReference Reference { get; }
    public bool Resolved { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBIdentifier get_ControlName();
    public virtual ITokenNode get_Dot();
    public virtual IControlReference get_Qualifier();
    public virtual IVBIdentifier SetControlName(IVBIdentifier param);
    public virtual IControlReference SetQualifier(IControlReference param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IReference get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public sealed virtual ITypeElement GetQualifierTypeElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ConversionOperatorDeclaration : OperatorDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short OPERATOR_KEYWORD;
    public static short CTYPE_KEYWORD;
    public static short VB_PARAMETERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_RETURN_ATTRIBUTE_LIST;
    public static short RETURN_TYPE;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BODY;
    public static short END_DECLARATION;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public IBlock Block { get; }
    public ITokenNode CTypeKeyword { get; }
    public ITokenNode EndDeclaration { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode OperatorKeyword { get; }
    public IRegularParameterList ParameterList { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage ReturnType { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.FunctionElement { get; }
    public ITokenNode StartDeclaration { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public string DeclaredName { get; }
    public bool IsExplicitCast { get; }
    public bool IsImplicitCast { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual IBlock get_Block();
    public virtual ITokenNode get_CTypeKeyword();
    public virtual ITokenNode get_EndDeclaration();
    public virtual IModifiersList get_ModifiersList();
    public virtual ITokenNode get_OperatorKeyword();
    public virtual IRegularParameterList get_ParameterList();
    public virtual IReturnAttributeList get_ReturnAttributeList();
    public virtual ITypeUsage get_ReturnType();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IBlock SetBlock(IBlock param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public virtual ITypeUsage SetReturnType(ITypeUsage param);
    public virtual string ToString();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.get_FunctionElement();
    public sealed virtual ITokenNode get_StartDeclaration();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual string get_DeclaredName();
    public bool get_IsExplicitCast();
    public bool get_IsImplicitCast();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    protected virtual Hash CalculateHashInternal();
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.DelegateDeclaration : TypeElementDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short DELEGATE_KEYWORD;
    public static short SUB_KEYWORD;
    public static short FUNCTION_KEYWORD;
    public static short VB_NAME;
    public static short VB_TYPE_PARAMETERS_LIST;
    public static short VB_PARAMETERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_RETURN_ATTRIBUTE_LIST;
    public static short VB_TYPE_USAGE;
    private IVBIdentifier myCachedName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedNameValid;
    private ITypeParameterOfTypeList myCachedTypeParameterList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedTypeParameterListValid;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public ITokenNode DelegateKeyword { get; }
    public ITokenNode FunctionKeyword { get; }
    public IModifiersList ModifiersList { get; }
    public IVBIdentifier Name { get; }
    protected IVBIdentifier _Name { get; }
    public IRegularParameterList ParameterList { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage ReturnTypeUsage { get; }
    public ITokenNode SubKeyword { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    protected ITypeParameterOfTypeList _TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IVBNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private IDelegate JetBrains.ReSharper.Psi.VB.Tree.IDelegateDeclaration.DeclaredElement { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    public int LevelDelta { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    public IReadOnlyList`1<ITypeDeclaration> NestedTypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public IList`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public IType ReturnType { get; }
    public IType Type { get; }
    public IEnumerable`1<IDeclaredType> SuperTypes { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool HasAccessRights { get; }
    public bool IsWriteonly { get; }
    public bool IsOverloads { get; }
    public bool IsPartial { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual ITokenNode get_DelegateKeyword();
    public virtual ITokenNode get_FunctionKeyword();
    public virtual IModifiersList get_ModifiersList();
    public sealed virtual IVBIdentifier get_Name();
    protected virtual IVBIdentifier get__Name();
    public virtual IRegularParameterList get_ParameterList();
    public virtual IReturnAttributeList get_ReturnAttributeList();
    public virtual ITypeUsage get_ReturnTypeUsage();
    public virtual ITokenNode get_SubKeyword();
    public sealed virtual ITypeParameterOfTypeList get_TypeParameterList();
    protected virtual ITypeParameterOfTypeList get__TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IVBNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public virtual ITypeUsage SetReturnTypeUsage(ITypeUsage param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public virtual string get_DeclaredName();
    private sealed virtual override IDelegate JetBrains.ReSharper.Psi.VB.Tree.IDelegateDeclaration.get_DeclaredElement();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IClassLikeDeclaration GetContainingClassLikeDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_NestedTypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    public sealed virtual IList`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration param);
    public sealed virtual IType get_ReturnType();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public sealed virtual IEnumerable`1<IDeclaredType> get_SuperTypes();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_HasAccessRights();
    public sealed virtual void SetAccessRights(AccessRights rights);
    public sealed virtual void SetAbstract(bool value);
    public sealed virtual void SetSealed(bool value);
    public sealed virtual void SetVirtual(bool value);
    public sealed virtual void SetOverride(bool value);
    public sealed virtual void SetStatic(bool value);
    public sealed virtual void SetOverloads(bool value);
    public sealed virtual void SetReadonly(bool value);
    public sealed virtual void SetWriteonly(bool value);
    public sealed virtual bool get_IsWriteonly();
    public sealed virtual bool get_IsOverloads();
    private IRegularParameterList CreateEmptyParameterListNode();
    public sealed virtual IRegularParameterDeclaration AddParameterDeclarationBefore(IRegularParameterDeclaration parameter, IRegularParameterDeclaration anchor);
    public sealed virtual IRegularParameterDeclaration AddParameterDeclarationAfter(IRegularParameterDeclaration parameter, IRegularParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(IRegularParameterDeclaration parameter);
    public sealed virtual void RemoveParameterDeclaration(int index);
    protected virtual Hash CalculateHashInternal();
    public sealed virtual bool get_IsPartial();
    public sealed virtual void SetPartial(bool value);
    public sealed virtual void SetExtern(bool value);
    public sealed virtual void SetUnsafe(bool value);
    public sealed virtual void SetVolatile(bool value);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.DictionaryAccessExpression : VBExpressionBase {
    public static short BASE_EXPR;
    public static short VB_OP_SIGN;
    public static short VB_EXCL;
    public static short IDENTIFIER;
    private MyReference myReference;
    public NodeType NodeType { get; }
    public IVBIdentifier Argument { get; }
    public IPrimaryExpression BaseExpression { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode ExclSign { get; }
    public IVBTreeNode Node { get; }
    public IVBInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public bool HasConditionalAccessSign { get; }
    public IVBExpression ConditionalQualifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBIdentifier get_Argument();
    public virtual IPrimaryExpression get_BaseExpression();
    public virtual IConditionalAccessSign get_ConditionalAccessSign();
    public virtual ITokenNode get_ExclSign();
    public virtual IVBIdentifier SetArgument(IVBIdentifier param);
    public virtual IPrimaryExpression SetBaseExpression(IPrimaryExpression param);
    public virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IVBTreeNode get_Node();
    public sealed virtual IVBInvocationReference get_Reference();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public IExpressionType CalculateOriginalExpressionType(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
    [CanBeNullAttribute]
public IVBExpression FindQualifierExpression();
    public sealed virtual bool get_HasConditionalAccessSign();
    public sealed virtual IVBExpression get_ConditionalQualifier();
    public sealed virtual void SetConditionalAccessSign(bool value);
    public sealed virtual IExpressionType UnliftedExpressionType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.DisableWarningPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short DISABLEWORD;
    public static short WARNINGWORD;
    public static short VB_NAME;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode DisableWord { get; }
    public TreeNodeCollection`1<IVBIdentifier> Names { get; }
    public TreeNodeEnumerable`1<IVBIdentifier> NamesEnumerable { get; }
    public ITokenNode Sharp { get; }
    public ITokenNode WarningWord { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_DisableWord();
    public virtual TreeNodeCollection`1<IVBIdentifier> get_Names();
    public virtual TreeNodeEnumerable`1<IVBIdentifier> get_NamesEnumerable();
    public virtual ITokenNode get_Sharp();
    public virtual ITokenNode get_WarningWord();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.DistinctQueryOperator : QueryOperatorBase {
    public static short DISTINCT_KEYWORD;
    private DistinctReferenceImpl myReference;
    public NodeType NodeType { get; }
    public ITokenNode DistinctKeyword { get; }
    public IQueryReference DistinctReference { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_DistinctKeyword();
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IQueryReference get_DistinctReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.DocComment : Comment {
    public DocComment(NodeType type, IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    public sealed virtual IDocComment ReplaceBy(IDocComment docCommentNode);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.DocCommentBlock : VBCompositeElement {
    private List`1<BaseVBDocCommentReference> myReferences;
    private List`1<DocCommentError> myErrors;
    private int myInLocalBind;
    private Dictionary`2<IDocCommentReference, string> myMajorReferenceToCRefText;
    [CanBeNullAttribute]
private VBDocCommentXmlPsi modreq(System.Runtime.CompilerServices.IsVolatile) myDocCommentXmlPsi;
    public TreeNodeCollection`1<IDocComment> DocComments { get; }
    public NodeType NodeType { get; }
    private bool IsInLocalBind { get; }
    public virtual bool IsFiltered();
    public sealed virtual TreeNodeCollection`1<IDocComment> get_DocComments();
    public sealed virtual IDocComment AddDocCommentBefore(IDocComment nodeToAdd, IDocComment anchor);
    public sealed virtual IDocComment AddDocCommentAfter(IDocComment nodeToAdd, IDocComment anchor);
    public sealed virtual void RemoveDocComment(IDocComment docCommentNode);
    protected virtual void PreInit();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    public sealed virtual IDocCommentXmlPsi GetXmlPsi();
    public virtual NodeType get_NodeType();
    private bool get_IsInLocalBind();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IReadOnlyCollection`1<DocCommentError> GetErrors();
    protected virtual void ClearCachedData();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    private void Parse();
    public sealed virtual XmlNode GetXML(ITypeMember element);
    private void CompileXmlNode(XmlNode node);
    private void CompileCRefReference(XmlAttribute crefAttribute);
    private ICommentNode ReplaceSubText(ICommentNode comment, TreeTextRange oldRange, string text);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.DoLoopStatement : StatementBase {
    public static short DO_KEYWORD;
    public static short PRECONDITION;
    public static short VB_BLOCK;
    public static short VB_STATEMENT_TERMINATOR;
    public static short LOOP_KEYWORD;
    public static short POSTCONDITION;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode DoKeyword { get; }
    public ITokenNode LoopKeyword { get; }
    public IWhileUntilCondition PostCondition { get; }
    public IWhileUntilCondition PreCondition { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_DoKeyword();
    public virtual ITokenNode get_LoopKeyword();
    public virtual IWhileUntilCondition get_PostCondition();
    public virtual IWhileUntilCondition get_PreCondition();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IWhileUntilCondition SetPostCondition(IWhileUntilCondition param);
    public virtual IWhileUntilCondition SetPreCondition(IWhileUntilCondition param);
    public virtual string ToString();
}
public static class JetBrains.ReSharper.Psi.VB.Impl.Tree.ElementBitsets : object {
    public static NodeTypeSet ACCESSOR_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet ATTRIBUTE_LIST_OWNER_BIT_SET;
    public static NodeTypeSet ATTRIBUTES_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet CLASS_LIKE_DECLARATION_BIT_SET;
    public static NodeTypeSet COLLECTION_RANGE_VARIABLE_DECLARATION_BIT_SET;
    public static NodeTypeSet CONDITIONAL_ACCESS_EXPRESSION_BIT_SET;
    public static NodeTypeSet DECLARED_TYPE_USAGE_BIT_SET;
    public static NodeTypeSet EXPRESSION_ARGUMENT_BIT_SET;
    public static NodeTypeSet IMPORT_CLAUSE_BIT_SET;
    public static NodeTypeSet LABEL_REFERENCING_STATEMENT_BIT_SET;
    public static NodeTypeSet LAMBDA_EXPRESSION_BIT_SET;
    public static NodeTypeSet LOOP_STATEMENT_BIT_SET;
    public static NodeTypeSet MEMBER_ACCESS_EXPRESSION_BIT_SET;
    public static NodeTypeSet METHOD_DECLARATION_BASE_BIT_SET;
    public static NodeTypeSet MODIFIERS_LIST_OWNER_BIT_SET;
    public static NodeTypeSet NAMESPACE_MEMBER_DECLARATION_BIT_SET;
    public static NodeTypeSet NEW_EXPRESSION_BIT_SET;
    public static NodeTypeSet OPERATOR_DECLARATION_BIT_SET;
    public static NodeTypeSet PREPROCESSOR_DIRECTIVE_BIT_SET;
    public static NodeTypeSet PRIMARY_EXPRESSION_BIT_SET;
    public static NodeTypeSet QUERY_OPERATOR_BIT_SET;
    public static NodeTypeSet TYPE_MEMBER_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet TYPE_PARAMETER_DECLARATION_BIT_SET;
    public static NodeTypeSet TYPE_USAGE_BIT_SET;
    public static NodeTypeSet V_B_ARGUMENT_BIT_SET;
    public static NodeTypeSet V_B_ARGUMENTS_OWNER_BIT_SET;
    public static NodeTypeSet V_B_BINARY_EXPRESSION_BIT_SET;
    public static NodeTypeSet V_B_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_EXPRESSION_BIT_SET;
    public static NodeTypeSet V_B_FUNCTION_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_LOCAL_VARIABLE_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_MODIFIERS_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_PARAMETER_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_PARAMETER_DECLARATION_LIST_BIT_SET;
    public static NodeTypeSet V_B_PARAMETERS_OWNER_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_STATEMENT_BIT_SET;
    public static NodeTypeSet V_B_TYPE_AND_NAMESPACE_HOLDER_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_TYPE_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_TYPE_MEMBER_DECLARATION_BIT_SET;
    public static NodeTypeSet V_B_UNARY_EXPRESSION_BIT_SET;
    public static NodeTypeSet WARNING_PREPROCESSOR_DIRECTIVE_BIT_SET;
    private static ElementBitsets();
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.ElementType : object {
    public static CompositeNodeType ERROR_ELEMENT;
    public static int ERROR_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ACCESSOR_DECLARATION;
    public static int ACCESSOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType ADD_HANDLER_STATEMENT;
    public static int ADD_HANDLER_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ADDITIVE_EXPRESSION;
    public static int ADDITIVE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ADDRESS_OF_EXPRESSION;
    public static int ADDRESS_OF_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType AGGREGATE_QUERY_OPERATOR;
    public static int AGGREGATE_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType AGGREGATED_RANGE_VARIABLE_DECLARATION;
    public static int AGGREGATED_RANGE_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType AGGREGATED_RANGE_VARIABLE_DECLARATION_LIST;
    public static int AGGREGATED_RANGE_VARIABLE_DECLARATION_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType ALIAS_CLAUSE;
    public static int ALIAS_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType ANONYMOUS_ARRAY_CREATION_EXPRESSION;
    public static int ANONYMOUS_ARRAY_CREATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ANONYMOUS_MEMBER_DECLARATION;
    public static int ANONYMOUS_MEMBER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType ANONYMOUS_OBJECT_CREATION_EXPRESSION;
    public static int ANONYMOUS_OBJECT_CREATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ANONYMOUS_OBJECT_INITIALIZER;
    public static int ANONYMOUS_OBJECT_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType ARGUMENT_LIST;
    public static int ARGUMENT_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType ARRAY_BOUND;
    public static int ARRAY_BOUND_NODE_TYPE_INDEX;
    public static CompositeNodeType ARRAY_CREATION_EXPRESSION;
    public static int ARRAY_CREATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType ARRAY_MODIFIER;
    public static int ARRAY_MODIFIER_NODE_TYPE_INDEX;
    public static CompositeNodeType ARRAY_MODIFIERS_LIST;
    public static int ARRAY_MODIFIERS_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType ASSIGNMENT_STATEMENT;
    public static int ASSIGNMENT_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ATTRIBUTE;
    public static int ATTRIBUTE_NODE_TYPE_INDEX;
    public static CompositeNodeType ATTRIBUTE_LIST;
    public static int ATTRIBUTE_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType AWAIT_EXPRESSION;
    public static int AWAIT_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType AWAIT_STATEMENT;
    public static int AWAIT_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType BLOCK;
    public static int BLOCK_NODE_TYPE_INDEX;
    public static CompositeNodeType BLOCK_IF_STATEMENT;
    public static int BLOCK_IF_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType CASE_CLAUSE;
    public static int CASE_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType CASE_STATEMENT;
    public static int CASE_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType CAST_EXPRESSION;
    public static int CAST_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType CATCH_STATEMENT;
    public static int CATCH_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType CATCH_VARIABLE_DECLARATION;
    public static int CATCH_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType CHARSET_MODIFIER;
    public static int CHARSET_MODIFIER_NODE_TYPE_INDEX;
    public static CompositeNodeType CLASS_BASE_CLAUSE;
    public static int CLASS_BASE_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType CLASS_BODY;
    public static int CLASS_BODY_NODE_TYPE_INDEX;
    public static CompositeNodeType CLASS_DECLARATION;
    public static int CLASS_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType COLLECTION_ELEMENT_INITIALIZER;
    public static int COLLECTION_ELEMENT_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType CONCATENATION_EXPRESSION;
    public static int CONCATENATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONDITIONAL_ACCESS_SIGN;
    public static int CONDITIONAL_ACCESS_SIGN_NODE_TYPE_INDEX;
    public static CompositeNodeType CONDITIONAL_EXPRESSION;
    public static int CONDITIONAL_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONST_PREPROCESSOR_DIRECTIVE;
    public static int CONST_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType CONSTANT_DECLARATION;
    public static int CONSTANT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONSTRUCTOR_DECLARATION;
    public static int CONSTRUCTOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType CONTINUE_STATEMENT;
    public static int CONTINUE_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType CONTROL_REFERENCE;
    public static int CONTROL_REFERENCE_NODE_TYPE_INDEX;
    public static CompositeNodeType CONVERSION_OPERATOR_DECLARATION;
    public static int CONVERSION_OPERATOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType DELEGATE_DECLARATION;
    public static int DELEGATE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType DICTIONARY_ACCESS_EXPRESSION;
    public static int DICTIONARY_ACCESS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType DISABLE_WARNING_PREPROCESSOR_DIRECTIVE;
    public static int DISABLE_WARNING_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType DISTINCT_QUERY_OPERATOR;
    public static int DISTINCT_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType DO_LOOP_STATEMENT;
    public static int DO_LOOP_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ELSE_IF_PREPROCESSOR_DIRECTIVE;
    public static int ELSE_IF_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType ELSE_IF_STATEMENT;
    public static int ELSE_IF_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ELSE_PREPROCESSOR_DIRECTIVE;
    public static int ELSE_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType ELSE_STATEMENT;
    public static int ELSE_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType EMPTY_ARGUMENT;
    public static int EMPTY_ARGUMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ENABLE_WARNING_PREPROCESSOR_DIRECTIVE;
    public static int ENABLE_WARNING_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType END_EXTERNAL_SOURCE_PREPROCESSOR_DIRECTIVE;
    public static int END_EXTERNAL_SOURCE_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType END_IF_PREPROCESSOR_DIRECTIVE;
    public static int END_IF_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType END_REGION_PREPROCESSOR_DIRECTIVE;
    public static int END_REGION_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType END_STATEMENT;
    public static int END_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ENUM_DECLARATION;
    public static int ENUM_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType ENUM_MEMBER_DECLARATION;
    public static int ENUM_MEMBER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType ERASE_STATEMENT;
    public static int ERASE_STATEMENT_NODE_TYPE_INDEX;
    public static NodeType _ERROR_ELEMENT;
    public static int _ERROR_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType ERROR_STATEMENT;
    public static int ERROR_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType EVENT_DECLARATION;
    public static int EVENT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType EVENT_SPECIFIER;
    public static int EVENT_SPECIFIER_NODE_TYPE_INDEX;
    public static CompositeNodeType EXIT_STATEMENT;
    public static int EXIT_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType EXPONENTIATION_EXPRESSION;
    public static int EXPONENTIATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType EXPRESSION_RANGE_VARIABLE_DECLARATION;
    public static int EXPRESSION_RANGE_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType EXPRESSION_RANGE_VARIABLE_DECLARATION_LIST;
    public static int EXPRESSION_RANGE_VARIABLE_DECLARATION_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType EXPRESSION_STATEMENT;
    public static int EXPRESSION_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType EXTERNAL_CHECKSUM_PREPROCESSOR_DIRECTIVE;
    public static int EXTERNAL_CHECKSUM_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType EXTERNAL_METHOD_DECLARATION;
    public static int EXTERNAL_METHOD_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType EXTERNAL_SOURCE_PREPROCESSOR_DIRECTIVE;
    public static int EXTERNAL_SOURCE_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType FINALLY_STATEMENT;
    public static int FINALLY_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType FOR_EACH_STATEMENT;
    public static int FOR_EACH_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType FOR_STATEMENT;
    public static int FOR_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType FROM_QUERY_OPERATOR;
    public static int FROM_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType GET_TYPE_EXPRESSION;
    public static int GET_TYPE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType GET_XML_NAMESPACE_EXPRESSION;
    public static int GET_XML_NAMESPACE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType GOTO_STATEMENT;
    public static int GOTO_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType GROUP_BY_QUERY_OPERATOR;
    public static int GROUP_BY_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType GROUP_JOIN_QUERY_OPERATOR;
    public static int GROUP_JOIN_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType HANDLES_CLAUSE;
    public static int HANDLES_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType IF_PREPROCESSOR_DIRECTIVE;
    public static int IF_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType IMPLEMENTS_CLAUSE;
    public static int IMPLEMENTS_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType IMPORT_ALIAS_CLAUSE;
    public static int IMPORT_ALIAS_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType IMPORT_DIRECTIVE;
    public static int IMPORT_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType IMPORT_DIRECTIVES_SECTION;
    public static int IMPORT_DIRECTIVES_SECTION_NODE_TYPE_INDEX;
    public static CompositeNodeType IMPORT_NAMESPACE_CLAUSE;
    public static int IMPORT_NAMESPACE_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType IMPORT_X_M_L_NAMESPACE_CLAUSE;
    public static int IMPORT_X_M_L_NAMESPACE_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType INDEX_EXPRESSION;
    public static int INDEX_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType INSTANCE_EXPRESSION;
    public static int INSTANCE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType INTEGER_DIVISION_EXPRESSION;
    public static int INTEGER_DIVISION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType INTERFACE_DECLARATION;
    public static int INTERFACE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType INTERFACE_INHERITS_CLAUSE;
    public static int INTERFACE_INHERITS_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType INTERFACE_MEMBER_SPECIFIER;
    public static int INTERFACE_MEMBER_SPECIFIER_NODE_TYPE_INDEX;
    public static CompositeNodeType INTERPOLATED_STRING_EXPRESSION;
    public static int INTERPOLATED_STRING_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType INTERPOLATED_STRING_INSERT;
    public static int INTERPOLATED_STRING_INSERT_NODE_TYPE_INDEX;
    public static CompositeNodeType INTO_OF_AGGREGATE_QUERY_OPERATOR;
    public static int INTO_OF_AGGREGATE_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType INVOCATION_STATEMENT;
    public static int INVOCATION_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType IS_EXPRESSION;
    public static int IS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType IS_NOT_EXPRESSION;
    public static int IS_NOT_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType JOIN_COLLECTION_RANGE_VARIABLE_DECLARATION;
    public static int JOIN_COLLECTION_RANGE_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType JOIN_CONDITION;
    public static int JOIN_CONDITION_NODE_TYPE_INDEX;
    public static CompositeNodeType JOIN_QUERY_CONDITIONS_LIST_FAKE;
    public static int JOIN_QUERY_CONDITIONS_LIST_FAKE_NODE_TYPE_INDEX;
    public static CompositeNodeType JOIN_QUERY_OPERATOR;
    public static int JOIN_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType LABEL_DECLARATION;
    public static int LABEL_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LABEL_NAME;
    public static int LABEL_NAME_NODE_TYPE_INDEX;
    public static CompositeNodeType LABEL_STATEMENT;
    public static int LABEL_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType LAMBDA_FUNCTION_EXPRESSION;
    public static int LAMBDA_FUNCTION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType LAMBDA_PARAMETER_DECLARATION;
    public static int LAMBDA_PARAMETER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LAMBDA_SIGNATURE;
    public static int LAMBDA_SIGNATURE_NODE_TYPE_INDEX;
    public static CompositeNodeType LAMBDA_SUB_EXPRESSION;
    public static int LAMBDA_SUB_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType LET_QUERY_OPERATOR;
    public static int LET_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType LIBRARY_CLAUSE;
    public static int LIBRARY_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType LIKE_EXPRESSION;
    public static int LIKE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType LINE_IF_STATEMENT;
    public static int LINE_IF_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType LINE_IF_STATEMENT_BODY;
    public static int LINE_IF_STATEMENT_BODY_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_DECLARATION_LIST;
    public static int LOCAL_DECLARATION_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_DECLARATION_STATEMENT;
    public static int LOCAL_DECLARATION_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType LOCAL_VARIABLE_DECLARATION;
    public static int LOCAL_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOGICAL_AND_EXPRESSION;
    public static int LOGICAL_AND_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOGICAL_NOT_EXPRESSION;
    public static int LOGICAL_NOT_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOGICAL_OR_EXPRESSION;
    public static int LOGICAL_OR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOGICAL_XOR_EXPRESSION;
    public static int LOGICAL_XOR_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType LOOP_CONTROL_VARIABLE_DECLARATION;
    public static int LOOP_CONTROL_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MEMBER_INITIALIZER;
    public static int MEMBER_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType METHOD_DECLARATION;
    public static int METHOD_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MID_ASSIGNMENT_STATEMENT;
    public static int MID_ASSIGNMENT_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType MODIFIERS_LIST;
    public static int MODIFIERS_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType MODULE_DECLARATION;
    public static int MODULE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MODULUS_EXPRESSION;
    public static int MODULUS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLE_CONSTANT_DECLARATION;
    public static int MULTIPLE_CONSTANT_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLE_VARIABLE_DECLARATION;
    public static int MULTIPLE_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType MULTIPLICATIVE_EXPRESSION;
    public static int MULTIPLICATIVE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType NAMED_ARGUMENT;
    public static int NAMED_ARGUMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType NAMESPACE_PREFIX_EXPRESSION;
    public static int NAMESPACE_PREFIX_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType NEXT_CLAUSE;
    public static int NEXT_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType OBJECT_COLLECTION_INITIALIZER;
    public static int OBJECT_COLLECTION_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType OBJECT_CREATION_EXPRESSION;
    public static int OBJECT_CREATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType OBJECT_CREATION_INITIALIZER;
    public static int OBJECT_CREATION_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType ON_ERROR_SPECIAL_LABEL;
    public static int ON_ERROR_SPECIAL_LABEL_NODE_TYPE_INDEX;
    public static CompositeNodeType ON_ERROR_STATEMENT;
    public static int ON_ERROR_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType OPTION_STATEMENT;
    public static int OPTION_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType OPTION_STATEMENTS_SECTION;
    public static int OPTION_STATEMENTS_SECTION_NODE_TYPE_INDEX;
    public static CompositeNodeType ORDER_BY_QUERY_OPERATOR;
    public static int ORDER_BY_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType ORDER_EXPRESSION;
    public static int ORDER_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PARENTHESIZED_EXPRESSION;
    public static int PARENTHESIZED_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType PARTITION_QUERY_OPERATOR;
    public static int PARTITION_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType POSITIONAL_ARGUMENT;
    public static int POSITIONAL_ARGUMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType PROPERTY_DECLARATION;
    public static int PROPERTY_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType PROPERTY_INITIALIZER;
    public static int PROPERTY_INITIALIZER_NODE_TYPE_INDEX;
    public static CompositeNodeType QUALIFIED_NAMESPACE_NAME;
    public static int QUALIFIED_NAMESPACE_NAME_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_AGGREGATED_PARAMETER_PLATFORM;
    public static int QUERY_AGGREGATED_PARAMETER_PLATFORM_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_COLLECTION_RANGE_VARIABLE_DECLARATION;
    public static int QUERY_COLLECTION_RANGE_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_COLLECTION_RANGE_VARIABLE_DECLARATION_LIST;
    public static int QUERY_COLLECTION_RANGE_VARIABLE_DECLARATION_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_CONDITIONS_LIST;
    public static int QUERY_CONDITIONS_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_EXPRESSION;
    public static int QUERY_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_PARAMETER;
    public static int QUERY_PARAMETER_NODE_TYPE_INDEX;
    public static CompositeNodeType QUERY_PARAMETER_PLATFORM;
    public static int QUERY_PARAMETER_PLATFORM_NODE_TYPE_INDEX;
    public static CompositeNodeType RAISE_EVENT_STATEMENT;
    public static int RAISE_EVENT_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType REDIM_CLAUSE;
    public static int REDIM_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType REDIM_STATEMENT;
    public static int REDIM_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType REFERENCE_EXPRESSION;
    public static int REFERENCE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType REFERENCE_NAME;
    public static int REFERENCE_NAME_NODE_TYPE_INDEX;
    public static CompositeNodeType REGION_PREPROCESSOR_DIRECTIVE;
    public static int REGION_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType REGULAR_PARAMETER_DECLARATION;
    public static int REGULAR_PARAMETER_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType REGULAR_PARAMETER_LIST;
    public static int REGULAR_PARAMETER_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType RELATIONAL_EXPRESSION;
    public static int RELATIONAL_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType REMOVE_HANDLER_STATEMENT;
    public static int REMOVE_HANDLER_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType RESUME_STATEMENT;
    public static int RESUME_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType RETURN_ATTRIBUTE_LIST;
    public static int RETURN_ATTRIBUTE_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType RETURN_STATEMENT;
    public static int RETURN_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType SELECT_QUERY_OPERATOR;
    public static int SELECT_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType SELECT_STATEMENT;
    public static int SELECT_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType SHIFT_EXPRESSION;
    public static int SHIFT_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType SIGN_OPERATOR_DECLARATION;
    public static int SIGN_OPERATOR_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType STOP_STATEMENT;
    public static int STOP_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType STRUCTURE_DECLARATION;
    public static int STRUCTURE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType SYNC_LOCK_STATEMENT;
    public static int SYNC_LOCK_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType THROW_STATEMENT;
    public static int THROW_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType TRY_STATEMENT;
    public static int TRY_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_COMPONENT;
    public static int TUPLE_COMPONENT_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_DECLARED_TYPE_USAGE;
    public static int TUPLE_DECLARED_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_EXPRESSION;
    public static int TUPLE_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_TYPE_COMPONENT;
    public static int TUPLE_TYPE_COMPONENT_NODE_TYPE_INDEX;
    public static CompositeNodeType TUPLE_TYPE_USAGE;
    public static int TUPLE_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_ARGUMENT_LIST;
    public static int TYPE_ARGUMENT_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_IMPLEMENTS_CLAUSE;
    public static int TYPE_IMPLEMENTS_CLAUSE_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_OF_IS_EXPRESSION;
    public static int TYPE_OF_IS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_CONSTRAINT;
    public static int TYPE_PARAMETER_CONSTRAINT_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_CONSTRAINT_LIST;
    public static int TYPE_PARAMETER_CONSTRAINT_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_METHOD_DECLARATION;
    public static int TYPE_PARAMETER_OF_METHOD_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_METHOD_LIST;
    public static int TYPE_PARAMETER_OF_METHOD_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_TYPE_DECLARATION;
    public static int TYPE_PARAMETER_OF_TYPE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType TYPE_PARAMETER_OF_TYPE_LIST;
    public static int TYPE_PARAMETER_OF_TYPE_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType UNARY_NEGATION_EXPRESSION;
    public static int UNARY_NEGATION_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType UNKNOWN_PREPROCESSOR_DIRECTIVE;
    public static int UNKNOWN_PREPROCESSOR_DIRECTIVE_NODE_TYPE_INDEX;
    public static CompositeNodeType USER_DECLARED_TYPE_USAGE;
    public static int USER_DECLARED_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType USER_TYPE_USAGE;
    public static int USER_TYPE_USAGE_NODE_TYPE_INDEX;
    public static CompositeNodeType USING_STATEMENT;
    public static int USING_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType USING_VARIABLE_DECLARATION;
    public static int USING_VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_FILE;
    public static int V_B_FILE_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_IDENTIFIER;
    public static int V_B_IDENTIFIER_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_LITERAL_EXPRESSION;
    public static int V_B_LITERAL_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_NAMESPACE_DECLARATION;
    public static int V_B_NAMESPACE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_ATTRIBUTE;
    public static int V_B_XML_ATTRIBUTE_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_C_DATA_SECTION;
    public static int V_B_XML_C_DATA_SECTION_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_COMMENT;
    public static int V_B_XML_COMMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_DOCUMENT;
    public static int V_B_XML_DOCUMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_ELEMENT;
    public static int V_B_XML_ELEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_ELEMENT_FOOTER;
    public static int V_B_XML_ELEMENT_FOOTER_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_ELEMENT_HEADER;
    public static int V_B_XML_ELEMENT_HEADER_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_EMBEDDED_EXPRESSION;
    public static int V_B_XML_EMBEDDED_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_LITERAL_EXPRESSION;
    public static int V_B_XML_LITERAL_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_MEMBER_ACCESS_EXPRESSION;
    public static int V_B_XML_MEMBER_ACCESS_EXPRESSION_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_MISC;
    public static int V_B_XML_MISC_NODE_TYPE_INDEX;
    public static CompositeNodeType V_B_XML_PROCESSING_INSTRUCTION;
    public static int V_B_XML_PROCESSING_INSTRUCTION_NODE_TYPE_INDEX;
    public static CompositeNodeType VARIABLE_DECLARATION;
    public static int VARIABLE_DECLARATION_NODE_TYPE_INDEX;
    public static CompositeNodeType VARIABLE_DECLARATION_LIST;
    public static int VARIABLE_DECLARATION_LIST_NODE_TYPE_INDEX;
    public static CompositeNodeType WHERE_QUERY_OPERATOR;
    public static int WHERE_QUERY_OPERATOR_NODE_TYPE_INDEX;
    public static CompositeNodeType WHILE_STATEMENT;
    public static int WHILE_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType WHILE_UNTIL_CONDITION;
    public static int WHILE_UNTIL_CONDITION_NODE_TYPE_INDEX;
    public static CompositeNodeType WITH_STATEMENT;
    public static int WITH_STATEMENT_NODE_TYPE_INDEX;
    public static CompositeNodeType YIELD_STATEMENT;
    public static int YIELD_STATEMENT_NODE_TYPE_INDEX;
    private static ElementType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ElseIfPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short ELSEIF_KEYWORD;
    public static short EXPRESSION;
    public static short THEN_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode ElseIfKeyword { get; }
    public IVBExpression Expression { get; }
    public ITokenNode Sharp { get; }
    public ITokenNode ThenKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ElseIfKeyword();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_Sharp();
    public virtual ITokenNode get_ThenKeyword();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ElseIfStatement : StatementBase {
    public static short ELSEIF_KEYWORD;
    public static short EXPRESSION;
    public static short THEN_KEYWORD;
    public static short VB_BLOCK;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode ElseIfKeyword { get; }
    public IVBExpression Expression { get; }
    public ITokenNode ThenKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_ElseIfKeyword();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_ThenKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ElsePreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short ELSE_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode ElseKeyword { get; }
    public ITokenNode Sharp { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ElseKeyword();
    public virtual ITokenNode get_Sharp();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ElseStatement : StatementBase {
    public static short ELSE_KEYWORD;
    public static short VB_BLOCK;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode ElseKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_ElseKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EmptyArgument : VBCompositeElement {
    public NodeType NodeType { get; }
    public IManagedConvertible ManagedConvertible { get; }
    public DeclaredElementInstance`1<IParameter> MatchingParameter { get; }
    public IVBInvocationInfo Invocation { get; }
    public IPsiModule PsiModule { get; }
    public ArgumentKind Kind { get; }
    public string ArgumentName { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public bool IsExtensionInvocationQualifier { get; }
    public IExpression Expression { get; }
    private IVBExpression JetBrains.ReSharper.Psi.VB.Tree.IVBArgument.Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
    public sealed virtual IVBArgument ReplaceBy(IVBArgument argument);
    private sealed virtual override DocumentRange JetBrains.ReSharper.Psi.IArgumentInfo.GetDocumentRange();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
    public sealed virtual DeclaredElementInstance`1<IParameter> get_MatchingParameter();
    public sealed virtual IVBInvocationInfo get_Invocation();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual string get_ArgumentName();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    public sealed virtual IExpression get_Expression();
    private sealed virtual override IVBExpression JetBrains.ReSharper.Psi.VB.Tree.IVBArgument.get_Expression();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EnableWarningPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short ENABLEWORD;
    public static short WARNINGWORD;
    public static short VB_NAME;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode EnableWord { get; }
    public TreeNodeCollection`1<IVBIdentifier> Names { get; }
    public TreeNodeEnumerable`1<IVBIdentifier> NamesEnumerable { get; }
    public ITokenNode Sharp { get; }
    public ITokenNode WarningWord { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_EnableWord();
    public virtual TreeNodeCollection`1<IVBIdentifier> get_Names();
    public virtual TreeNodeEnumerable`1<IVBIdentifier> get_NamesEnumerable();
    public virtual ITokenNode get_Sharp();
    public virtual ITokenNode get_WarningWord();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EndExternalSourcePreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short END_KEYWORD;
    public static short EXTERNALSOURCE;
    public NodeType NodeType { get; }
    public ITokenNode EndKeyword { get; }
    public ITokenNode ExternalSourceWord { get; }
    public ITokenNode Sharp { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EndKeyword();
    public virtual ITokenNode get_ExternalSourceWord();
    public virtual ITokenNode get_Sharp();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EndIfPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short ENDIF_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode EndIf { get; }
    public ITokenNode Sharp { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EndIf();
    public virtual ITokenNode get_Sharp();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EndRegionPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short END_KEYWORD;
    public static short REGION;
    public NodeType NodeType { get; }
    public ITokenNode EndKeyword { get; }
    public ITokenNode RegionWord { get; }
    public ITokenNode Sharp { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EndKeyword();
    public virtual ITokenNode get_RegionWord();
    public virtual ITokenNode get_Sharp();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EndStatement : StatementBase {
    public static short VB_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode EndKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EndKeyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EnumDeclaration : TypeElementDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short ENUM_KEYWORD;
    public static short VB_NAME;
    public static short AS_KEYWORD;
    public static short TYPE_NAME;
    public static short VB_STATEMENT_TERMINATOR;
    public static short MEMBER_DECLARATION;
    public static short VB_END_DECLARATION;
    private Dictionary`2<IEnumMemberDeclaration, Hash> myCachedMemberHashes;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public IDeclaredTypeUsage BaseTypeName { get; }
    public ITokenNode EndEnum { get; }
    public ITokenNode EnumKeyword { get; }
    public TreeNodeCollection`1<IEnumMemberDeclaration> EnumMemberDeclarations { get; }
    public TreeNodeEnumerable`1<IEnumMemberDeclaration> EnumMemberDeclarationsEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IVBIdentifier Name { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IVBNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public string DeclaredName { get; }
    public int LevelDelta { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.TypeElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IEnum JetBrains.ReSharper.Psi.VB.Tree.IEnumDeclaration.DeclaredElement { get; }
    public TreeNodeCollection`1<IVBTypeMemberDeclaration> MemberDeclarations { get; }
    public IEnumerable`1<IDeclaredType> SuperTypes { get; }
    public IReadOnlyList`1<ITypeDeclaration> NestedTypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    public IReadOnlyList`1<ITypeDeclaration> TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsOverloads { get; }
    public bool HasAccessRights { get; }
    public bool IsWriteonly { get; }
    public bool IsPartial { get; }
    public Dictionary`2<IEnumMemberDeclaration, Hash> CachedMemberHashes { get; }
    private ITreeNode TopAnchor { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual IDeclaredTypeUsage get_BaseTypeName();
    public virtual ITokenNode get_EndEnum();
    public virtual ITokenNode get_EnumKeyword();
    public virtual TreeNodeCollection`1<IEnumMemberDeclaration> get_EnumMemberDeclarations();
    public virtual TreeNodeEnumerable`1<IEnumMemberDeclaration> get_EnumMemberDeclarationsEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual IVBIdentifier get_Name();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IVBNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IDeclaredTypeUsage SetBaseTypeName(IDeclaredTypeUsage param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IClassLikeDeclaration GetContainingClassLikeDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.get_TypeElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IEnum JetBrains.ReSharper.Psi.VB.Tree.IEnumDeclaration.get_DeclaredElement();
    public sealed virtual TreeNodeCollection`1<IVBTypeMemberDeclaration> get_MemberDeclarations();
    public sealed virtual IEnumerable`1<IDeclaredType> get_SuperTypes();
    public sealed virtual IType GetUnderlyingType();
    public sealed virtual IEnumMemberDeclaration AddEnumMemberDeclaration(IEnumMemberDeclaration param, IEnumMemberDeclaration anchor, bool before);
    public sealed virtual void RemoveEnumMemberDeclaration(IEnumMemberDeclaration param);
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_NestedTypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsOverloads();
    public sealed virtual bool get_HasAccessRights();
    public sealed virtual void SetAccessRights(AccessRights rights);
    public sealed virtual void SetAbstract(bool value);
    public sealed virtual void SetSealed(bool value);
    public sealed virtual void SetVirtual(bool value);
    public sealed virtual void SetOverride(bool value);
    public sealed virtual void SetStatic(bool value);
    public sealed virtual void SetOverloads(bool value);
    public sealed virtual void SetReadonly(bool value);
    public sealed virtual void SetWriteonly(bool value);
    public sealed virtual bool get_IsWriteonly();
    public sealed virtual bool get_IsPartial();
    public sealed virtual void SetPartial(bool value);
    protected virtual Hash CalculateHashInternal();
    protected virtual void PreInit();
    protected virtual void ClearCachedData();
    public Dictionary`2<IEnumMemberDeclaration, Hash> get_CachedMemberHashes();
    public sealed virtual void SetExtern(bool value);
    public sealed virtual void SetUnsafe(bool value);
    public sealed virtual void SetVolatile(bool value);
    private ITreeNode get_TopAnchor();
    public sealed virtual IDeclarationsRange GetAllDeclarationsRange();
    public sealed virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange range);
    public sealed virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    private static ITreeRange FixupDeclarationsRange(IDeclarationsRange range);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EnumMemberDeclaration : TypeMemberDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_NAME;
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public IVBIdentifier Name { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public string DeclaredName { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsOverloads { get; }
    public bool IsWriteonly { get; }
    private IEnumMemberDeclaration PreviousDeclaration { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    public IField EnumMember { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Initializer();
    public virtual IVBIdentifier get_Name();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public virtual AccessRights GetAccessRights();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsWriteonly();
    public virtual void SetAccessRights(AccessRights rights);
    public virtual void SetAbstract(bool value);
    public virtual void SetSealed(bool value);
    public virtual void SetVirtual(bool value);
    public virtual void SetOverride(bool value);
    public virtual void SetStatic(bool value);
    public virtual void SetOverloads(bool value);
    public virtual void SetReadonly(bool value);
    public virtual void SetWriteonly(bool value);
    internal ConstantValue CalculateConstantValue();
    private IEnumMemberDeclaration get_PreviousDeclaration();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    public sealed virtual IField get_EnumMember();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    protected virtual Hash CalculateHashInternal();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EraseStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXPR;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode EraseKeyword { get; }
    public TreeNodeCollection`1<IPrimaryExpression> Expressions { get; }
    public TreeNodeEnumerable`1<IPrimaryExpression> ExpressionsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_EraseKeyword();
    public virtual TreeNodeCollection`1<IPrimaryExpression> get_Expressions();
    public virtual TreeNodeEnumerable`1<IPrimaryExpression> get_ExpressionsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ErrorStatement : StatementBase {
    public static short ERROR_KEYWORD;
    public static short NEXT_EXPR;
    public NodeType NodeType { get; }
    public ITokenNode ErrorKeyword { get; }
    public IVBExpression NextExpression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ErrorKeyword();
    public virtual IVBExpression get_NextExpression();
    public virtual IVBExpression SetNextExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EventDeclaration : EventDeclarationStub {
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.EventDeclarationStub : TypeMemberDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short EVENT_KEYWORD;
    public static short VB_NAME;
    public static short VB_PARAMETERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short IMPLEMENTS_CLAUSE;
    public static short CUSTOM_KEYWORD;
    public static short VB_STATEMENT_TERMINATOR;
    public static short ACCESSOR;
    public static short VB_END_DECLARATION;
    private IImplementsClause myCachedImplementsClause;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedImplementsClauseValid;
    private static string myEventHandlerPostfix;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IAccessorDeclaration> AccessorDeclarations { get; }
    public TreeNodeEnumerable`1<IAccessorDeclaration> AccessorDeclarationsEnumerable { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public ITokenNode CustomKeyword { get; }
    public IRegularParameterList DelegateParameterList { get; }
    public IDeclaredTypeUsage DelegateTypeUsage { get; }
    public ITokenNode EndEvent { get; }
    public ITokenNode EventKeyword { get; }
    public IImplementsClause ImplementsClause { get; }
    protected IImplementsClause _ImplementsClause { get; }
    public IModifiersList ModifiersList { get; }
    public IVBIdentifier Name { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> DelegateParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> DelegateParameterDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    public bool IsCustom { get; }
    public string EventHandlerShortName { get; }
    public IType Type { get; }
    private IEvent JetBrains.ReSharper.Psi.VB.Tree.IEventDeclaration.DeclaredElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IAccessorOwnerDeclaration.AccessorOwnerElement { get; }
    public ITokenNode OpenKeyword { get; }
    public ITokenNode EndKeyword { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public IList`1<IInterfaceMemberSpecifier> MemberSpecifiers { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IAccessorDeclaration> get_AccessorDeclarations();
    public virtual TreeNodeEnumerable`1<IAccessorDeclaration> get_AccessorDeclarationsEnumerable();
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual ITokenNode get_CustomKeyword();
    public virtual IRegularParameterList get_DelegateParameterList();
    public virtual IDeclaredTypeUsage get_DelegateTypeUsage();
    public virtual ITokenNode get_EndEvent();
    public virtual ITokenNode get_EventKeyword();
    public sealed virtual IImplementsClause get_ImplementsClause();
    protected virtual IImplementsClause get__ImplementsClause();
    public virtual IModifiersList get_ModifiersList();
    public virtual IVBIdentifier get_Name();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_DelegateParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_DelegateParameterDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IRegularParameterList SetDelegateParameterList(IRegularParameterList param);
    public virtual IDeclaredTypeUsage SetDelegateTypeUsage(IDeclaredTypeUsage param);
    public virtual IImplementsClause SetImplementsClause(IImplementsClause param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    public sealed virtual bool HasEventField();
    public sealed virtual bool get_IsCustom();
    public sealed virtual bool HasEventHandler();
    public sealed virtual string get_EventHandlerShortName();
    public sealed virtual void RemoveAccessorDeclaration(IAccessorDeclaration param);
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationBefore(IAccessorDeclaration param, IAccessorDeclaration anchor);
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationAfter(IAccessorDeclaration param, IAccessorDeclaration anchor);
    private IRegularParameterList CreateEmptyParameterListNode();
    public sealed virtual IVBParameterDeclaration AddParameterDeclarationBefore(IVBParameterDeclaration parameter, IVBParameterDeclaration anchor);
    public sealed virtual IVBParameterDeclaration AddParameterDeclarationAfter(IVBParameterDeclaration parameter, IVBParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(IVBParameterDeclaration parameter);
    public sealed virtual void AddImplementsSpecification(IDeclaredType interfaceType, string name);
    public sealed virtual void RemoveImplementsSpecification(IDeclaredType interfaceType);
    private sealed virtual override IImplementsClause JetBrains.ReSharper.Psi.VB.Tree.IAccessorOwnerDeclaration.SetImplementsClause(IImplementsClause param);
    public sealed virtual void RemoveAllImplementsSpecifications();
    public virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    protected virtual Hash CalculateHashInternal();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    private sealed virtual override IEvent JetBrains.ReSharper.Psi.VB.Tree.IEventDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IAccessorOwnerDeclaration.get_AccessorOwnerElement();
    public sealed virtual ITokenNode get_OpenKeyword();
    public sealed virtual ITokenNode get_EndKeyword();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public sealed virtual IList`1<IInterfaceMemberSpecifier> get_MemberSpecifiers();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.EventSpecifier : VBCompositeElement {
    public static short BASE;
    public static short DOT;
    public static short MEMBER_NAME;
    private MyEventReference myEventReference;
    public NodeType NodeType { get; }
    public IVBTreeNode Base { get; }
    public ITokenNode Dot { get; }
    public IVBIdentifier MemberName { get; }
    public IReference FieldReference { get; }
    public IReference EventReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBTreeNode get_Base();
    public virtual ITokenNode get_Dot();
    public virtual IVBIdentifier get_MemberName();
    public virtual IVBIdentifier SetMemberName(IVBIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IReference get_FieldReference();
    public sealed virtual IReference get_EventReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    private IType GetEventContainingType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExitStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXIT_KIND;
    public NodeType NodeType { get; }
    public ITokenNode ExitKeyword { get; }
    public ITokenNode ExitKind { get; }
    public ExitStatementKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ExitKeyword();
    public virtual ITokenNode get_ExitKind();
    public virtual string ToString();
    public sealed virtual ExitStatementKind get_Kind();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExponentiationExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExpressionArgument : VBCompositeElement {
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExpressionRangeVariableDeclaration : VBNonCachedDeclarationBase {
    public static short VB_NAME;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    private CachedPsiValue`1<IType> myCachedType;
    private LetReferenceImpl myReference;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public ITokenNode EqSign { get; }
    public IQueryParameterPlatform Expression { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public string DeclaredName { get; }
    public IType Type { get; }
    private IQueryAnonymousTypeProperty JetBrains.ReSharper.Psi.VB.Tree.IExpressionRangeVariableDeclaration.DeclaredElement { get; }
    public IDeclaredElement DeclaredElement { get; }
    public IQueryExpression QueryExpression { get; }
    public IQueryReference LetReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual ITokenNode get_EqSign();
    public virtual IQueryParameterPlatform get_Expression();
    public virtual IVBIdentifier get_Name();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public virtual DeclaredElementType GetElementType();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual IType get_Type();
    private sealed virtual override IQueryAnonymousTypeProperty JetBrains.ReSharper.Psi.VB.Tree.IExpressionRangeVariableDeclaration.get_DeclaredElement();
    public virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual IQueryExpression get_QueryExpression();
    protected virtual void PreInit();
    public sealed virtual IQueryReference get_LetReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExpressionRangeVariableDeclarationList : VBCompositeElement {
    public static short DECLARATION;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> DeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_Declarations();
    public virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_DeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExpressionStatement : StatementBase {
    public static short EXPR;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExternalChecksumPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short EXTERNALChecksum;
    public static short VB_LPARENTH;
    public static short SOURCE;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Checksum { get; }
    public TreeNodeEnumerable`1<ITokenNode> ChecksumEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ExternalChecksumWord { get; }
    public TreeNodeCollection`1<ITokenNode> Guid { get; }
    public TreeNodeEnumerable`1<ITokenNode> GuidEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Sharp { get; }
    public TreeNodeCollection`1<ITokenNode> Source { get; }
    public TreeNodeEnumerable`1<ITokenNode> SourceEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Checksum();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ChecksumEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_ExternalChecksumWord();
    public virtual TreeNodeCollection`1<ITokenNode> get_Guid();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_GuidEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Sharp();
    public virtual TreeNodeCollection`1<ITokenNode> get_Source();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_SourceEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExternalMethodDeclaration : MethodDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short DECLARE_KEYWORD;
    public static short CHARSET_MODIFIER;
    public static short SUB_KEYWORD;
    public static short FUNCTION_KEYWORD;
    public static short VB_NAME;
    public static short VB_TYPE_PARAMETERS_LIST;
    public static short LIBRARY_CLAUSE;
    public static short ALIAS_CLAUSE;
    public static short VB_PARAMETERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_RETURN_ATTRIBUTE_LIST;
    public static short VB_TYPE_USAGE;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BODY;
    public static short END_DECLARATION;
    private IVBIdentifier myCachedName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedNameValid;
    private ITypeParameterOfMethodList myCachedTypeParameterList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedTypeParameterListValid;
    public NodeType NodeType { get; }
    public IAliasClause AliasClause { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public IBlock Block { get; }
    public ICharsetModifier CharsetModifier { get; }
    public ITokenNode DeclareKeyword { get; }
    public ITokenNode EndDeclaration { get; }
    public ITokenNode FunctionKeyword { get; }
    public ILibraryClause LibraryClause { get; }
    public IModifiersList ModifiersList { get; }
    public IVBIdentifier Name { get; }
    protected IVBIdentifier _Name { get; }
    public IRegularParameterList ParameterList { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage ReturnTypeUsage { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode SubKeyword { get; }
    public ITypeParameterOfMethodList TypeParameterList { get; }
    protected ITypeParameterOfMethodList _TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IMethod JetBrains.ReSharper.Psi.VB.Tree.IMethodDeclarationBase.MethodElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public bool IsStatic { get; }
    public bool IsExtern { get; }
    public MethodDeclarationKind Kind { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    private IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.FunctionElement { get; }
    public ITokenNode StartDeclaration { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAliasClause get_AliasClause();
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual IBlock get_Block();
    public virtual ICharsetModifier get_CharsetModifier();
    public virtual ITokenNode get_DeclareKeyword();
    public virtual ITokenNode get_EndDeclaration();
    public virtual ITokenNode get_FunctionKeyword();
    public virtual ILibraryClause get_LibraryClause();
    public virtual IModifiersList get_ModifiersList();
    public sealed virtual IVBIdentifier get_Name();
    protected virtual IVBIdentifier get__Name();
    public virtual IRegularParameterList get_ParameterList();
    public virtual IReturnAttributeList get_ReturnAttributeList();
    public virtual ITypeUsage get_ReturnTypeUsage();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITokenNode get_SubKeyword();
    public sealed virtual ITypeParameterOfMethodList get_TypeParameterList();
    protected virtual ITypeParameterOfMethodList get__TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual IAliasClause SetAliasClause(IAliasClause param);
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IBlock SetBlock(IBlock param);
    public virtual ICharsetModifier SetCharsetModifier(ICharsetModifier param);
    public virtual ILibraryClause SetLibraryClause(ILibraryClause param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public virtual ITypeUsage SetReturnTypeUsage(ITypeUsage param);
    public virtual ITypeParameterOfMethodList SetTypeParameterList(ITypeParameterOfMethodList param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public virtual string get_DeclaredName();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IMethod JetBrains.ReSharper.Psi.VB.Tree.IMethodDeclarationBase.get_MethodElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public virtual bool get_IsStatic();
    public virtual bool get_IsExtern();
    public sealed virtual MethodDeclarationKind get_Kind();
    protected virtual IRegularParameterList GetParameterListNode();
    protected virtual IRegularParameterList CreateEmptyParameterListNode();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.get_FunctionElement();
    public sealed virtual ITokenNode get_StartDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ExternalSourcePreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short EXTERNALSOURCE;
    public static short VB_LPARENTH;
    public static short SOURCE;
    public static short VB_COMMA;
    public static short LINE;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public ITokenNode Comma { get; }
    public ITokenNode ExternalSourceWord { get; }
    public ITokenNode LPar { get; }
    public ITokenNode Line { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Sharp { get; }
    public ITokenNode Source { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Comma();
    public virtual ITokenNode get_ExternalSourceWord();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_Line();
    public virtual ITokenNode get_RPar();
    public virtual ITokenNode get_Sharp();
    public virtual ITokenNode get_Source();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.FinallyStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short VB_BLOCK;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode FinallyKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_FinallyKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ForEachStatement : StatementBase {
    public static short FOR_KEYWORD;
    public static short EACH_KEYWORD;
    public static short LOOP_VAR_DECL;
    public static short LOOP_VAR_EXPR;
    public static short IN_KEYWORD;
    public static short EXPR;
    public static short VB_BLOCK;
    public static short NEXT_CLAUSE;
    private MyGetEnumeratorReference myGetEnumeratorReference;
    private MyMoveNextReference myMoveNextReference;
    private MyCurrentReference myCurrentReference;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode EachKeyword { get; }
    public IVBExpression Expression { get; }
    public ITokenNode ForKeyword { get; }
    public ITokenNode InKeyword { get; }
    public ILoopControlVariableDeclaration LoopVariableDeclaration { get; }
    public IPrimaryExpression LoopVariableExpression { get; }
    public INextClause NextClause { get; }
    public IForEachStatementReference GetEnumeratorReference { get; }
    public IForEachStatementReference MoveNextReference { get; }
    public IForEachStatementReference CurrentReference { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EachKeyword();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_ForKeyword();
    public virtual ITokenNode get_InKeyword();
    public virtual ILoopControlVariableDeclaration get_LoopVariableDeclaration();
    public virtual IPrimaryExpression get_LoopVariableExpression();
    public virtual INextClause get_NextClause();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual ILoopControlVariableDeclaration SetLoopVariableDeclaration(ILoopControlVariableDeclaration param);
    public virtual IPrimaryExpression SetLoopVariableExpression(IPrimaryExpression param);
    public virtual INextClause SetNextClause(INextClause param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IForEachStatementReference get_GetEnumeratorReference();
    public sealed virtual IForEachStatementReference get_MoveNextReference();
    public sealed virtual IForEachStatementReference get_CurrentReference();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    [CanBeNullAttribute]
private IDeclaredElement GetLocalVariable(Func`1<ISymbolTable> parentTable);
    [CompilerGeneratedAttribute]
private ISymbolTable <get_LocalVariables>b__52_0();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ForStatement : StatementBase {
    public static short FOR_KEYWORD;
    public static short LOOP_VAR_DECL;
    public static short LOOP_VAR_EXPR;
    public static short VB_EQ;
    public static short START_EXPR;
    public static short TO_KEYWORD;
    public static short END_EXPR;
    public static short STEP_KEYWORD;
    public static short STEP_EXPR;
    public static short VB_BLOCK;
    public static short NEXT_CLAUSE;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public IVBExpression EndExpression { get; }
    public ITokenNode EqSign { get; }
    public ITokenNode ForKeyword { get; }
    public ILoopControlVariableDeclaration LoopVariableDeclaration { get; }
    public IPrimaryExpression LoopVariableExpression { get; }
    public INextClause NextClause { get; }
    public IVBExpression StartExpression { get; }
    public IVBExpression StepExpression { get; }
    public ITokenNode StepKeyword { get; }
    public ITokenNode ToKeyword { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual IVBExpression get_EndExpression();
    public virtual ITokenNode get_EqSign();
    public virtual ITokenNode get_ForKeyword();
    public virtual ILoopControlVariableDeclaration get_LoopVariableDeclaration();
    public virtual IPrimaryExpression get_LoopVariableExpression();
    public virtual INextClause get_NextClause();
    public virtual IVBExpression get_StartExpression();
    public virtual IVBExpression get_StepExpression();
    public virtual ITokenNode get_StepKeyword();
    public virtual ITokenNode get_ToKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IVBExpression SetEndExpression(IVBExpression param);
    public virtual ILoopControlVariableDeclaration SetLoopVariableDeclaration(ILoopControlVariableDeclaration param);
    public virtual IPrimaryExpression SetLoopVariableExpression(IPrimaryExpression param);
    public virtual INextClause SetNextClause(INextClause param);
    public virtual IVBExpression SetStartExpression(IVBExpression param);
    public virtual IVBExpression SetStepExpression(IVBExpression param);
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    [CanBeNullAttribute]
private IDeclaredElement GetLocalVariable(Func`1<ISymbolTable> parentTable);
    [CompilerGeneratedAttribute]
private ISymbolTable <get_LocalVariables>b__52_0();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.FromQueryOperator : QueryOperatorBase {
    public static short FROM_KEYWORD;
    public static short DECLARATION_LIST;
    public NodeType NodeType { get; }
    public IQueryCollectionRangeVariableDeclarationList DeclarationList { get; }
    public ITokenNode FromKeyword { get; }
    public TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryCollectionRangeVariableDeclarationList get_DeclarationList();
    public virtual ITokenNode get_FromKeyword();
    public virtual TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IQueryCollectionRangeVariableDeclarationList SetDeclarationList(IQueryCollectionRangeVariableDeclarationList param);
    public virtual string ToString();
    public virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.GetTypeExpression : VBExpressionBase {
    public static short VB_KEYWORD;
    public static short VB_LPARENTH;
    public static short VB_TYPE_USAGE;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public ITokenNode GetTypeKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    public IType ArgumentType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_GetTypeKeyword();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual ITypeUsage get_TypeUsage();
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual IType get_ArgumentType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.GetXmlNamespaceExpression : VBExpressionBase {
    public static short GETXMLNAMESPACE_KEYWORD;
    public static short VB_LPARENTH;
    public static short XML_IDENTIFIER;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public ITokenNode GetXmlNamespaceKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode NamespaceName { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_GetXmlNamespaceKeyword();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_NamespaceName();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.GotoStatement : LabelReferencingStatementBase {
    public static short VB_KEYWORD;
    public static short LABEL_NAME;
    public NodeType NodeType { get; }
    public ITokenNode GotoKeyword { get; }
    public ILabelName LabelName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_GotoKeyword();
    public virtual ILabelName get_LabelName();
    public virtual ILabelName SetLabelName(ILabelName param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.GroupByQueryOperator : QueryOperatorBase {
    public static short GROUP_KEYWORD;
    public static short BY_KEYWORD;
    public static short DECLARATION_LIST1;
    public static short DECLARATION_LIST2;
    public static short INTO_KEYWORD;
    public static short DECLARATION_LIST3;
    private GroupByReferenceImpl myReference;
    public NodeType NodeType { get; }
    public ITokenNode ByKeyword { get; }
    public ITokenNode GroupKeyword { get; }
    public ITokenNode IntoKeyword { get; }
    public IExpressionRangeVariableDeclarationList KeyDeclarationsList { get; }
    public IAggregatedRangeVariableDeclarationList ResultDeclarationsList { get; }
    public IExpressionRangeVariableDeclarationList SelectorDeclarationsList { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> KeyDeclarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> KeyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> ResultDeclarations { get; }
    public TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> ResultDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> SelectorDeclarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> SelectorDeclarationsEnumerable { get; }
    public bool HasSelectors { get; }
    public IQueryReference GroupByReference { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ByKeyword();
    public virtual ITokenNode get_GroupKeyword();
    public virtual ITokenNode get_IntoKeyword();
    public virtual IExpressionRangeVariableDeclarationList get_KeyDeclarationsList();
    public virtual IAggregatedRangeVariableDeclarationList get_ResultDeclarationsList();
    public virtual IExpressionRangeVariableDeclarationList get_SelectorDeclarationsList();
    public virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_KeyDeclarations();
    public virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_KeyDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> get_ResultDeclarations();
    public virtual TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> get_ResultDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_SelectorDeclarations();
    public virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_SelectorDeclarationsEnumerable();
    public virtual IExpressionRangeVariableDeclarationList SetKeyDeclarationsList(IExpressionRangeVariableDeclarationList param);
    public virtual IAggregatedRangeVariableDeclarationList SetResultDeclarationsList(IAggregatedRangeVariableDeclarationList param);
    public virtual IExpressionRangeVariableDeclarationList SetSelectorDeclarationsList(IExpressionRangeVariableDeclarationList param);
    public virtual string ToString();
    public bool get_HasSelectors();
    public sealed virtual bool IsSelector();
    protected virtual void PreInit();
    public sealed virtual IQueryReference get_GroupByReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    internal QueryImplicitAnonymousMethod GetLastLambda(IQueryReferenceImpl invocation);
    public sealed virtual IType GetGroupVariableType(IResolveContext resolveResolveContext);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    public sealed virtual QueryChainTypeBase GetAggregatedChainType();
    public virtual ITokenNode get_FirstKeyword();
    [CompilerGeneratedAttribute]
private QueryChainTypeBase <TransitChainType>b__49_0(IExpressionRangeVariableDeclaration el);
    [CompilerGeneratedAttribute]
private QueryChainTypeBase <TransitChainType>b__49_1(IAggregatedRangeVariableDeclaration el);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.GroupJoinQueryOperator : QueryOperatorBase {
    public static short GROUP_KEYWORD;
    public static short JOIN_OPERATOR;
    public static short INTO_KEYWORD;
    public static short DECLARATION_LIST;
    private GroupJoinReferenceImpl myReference;
    public NodeType NodeType { get; }
    public IAggregatedRangeVariableDeclarationList DeclarationList { get; }
    public ITokenNode GroupKeyword { get; }
    public ITokenNode IntoKeyword { get; }
    public IJoinQueryOperator JoinOperator { get; }
    public TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> ResultDeclarations { get; }
    public TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> ResultDeclarationsEnumerable { get; }
    public IQueryReference GroupJoinReference { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAggregatedRangeVariableDeclarationList get_DeclarationList();
    public virtual ITokenNode get_GroupKeyword();
    public virtual ITokenNode get_IntoKeyword();
    public virtual IJoinQueryOperator get_JoinOperator();
    public virtual TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> get_ResultDeclarations();
    public virtual TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> get_ResultDeclarationsEnumerable();
    public virtual IAggregatedRangeVariableDeclarationList SetDeclarationList(IAggregatedRangeVariableDeclarationList param);
    public virtual IJoinQueryOperator SetJoinOperator(IJoinQueryOperator param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IQueryReference get_GroupJoinReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    internal QueryImplicitAnonymousMethod GetLastLambda(IQueryReferenceImpl invocation);
    public sealed virtual IType GetGroupVariableType(IResolveContext resolveResolveContext);
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    public sealed virtual QueryChainTypeBase GetAggregatedChainType();
    public sealed virtual bool IsSelector();
    public virtual ITokenNode get_FirstKeyword();
    [CompilerGeneratedAttribute]
private QueryChainTypeBase <TransitChainType>b__33_0(IAggregatedRangeVariableDeclaration el);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.HandlesClause : VBCompositeElement {
    public static short HANDLES_KEYWORD;
    public static short EVENT_SPECIFIER;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IEventSpecifier> EventSpecifiers { get; }
    public TreeNodeEnumerable`1<IEventSpecifier> EventSpecifiersEnumerable { get; }
    public ITokenNode HandlesKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IEventSpecifier> get_EventSpecifiers();
    public virtual TreeNodeEnumerable`1<IEventSpecifier> get_EventSpecifiersEnumerable();
    public virtual ITokenNode get_HandlesKeyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.IfPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short IF_KEYWORD;
    public static short EXPRESSION;
    public static short THEN_KEYWORD;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode IfKeyword { get; }
    public ITokenNode Sharp { get; }
    public ITokenNode ThenKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_IfKeyword();
    public virtual ITokenNode get_Sharp();
    public virtual ITokenNode get_ThenKeyword();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ImplementsClause : VBCompositeElement {
    public static short IMPLEMENTS_KEYWORD;
    public static short MEMBER_SPECIFIER;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ImplementsKeyword { get; }
    public TreeNodeCollection`1<IInterfaceMemberSpecifier> MemberSpecifiers { get; }
    public TreeNodeEnumerable`1<IInterfaceMemberSpecifier> MemberSpecifiersEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_ImplementsKeyword();
    public virtual TreeNodeCollection`1<IInterfaceMemberSpecifier> get_MemberSpecifiers();
    public virtual TreeNodeEnumerable`1<IInterfaceMemberSpecifier> get_MemberSpecifiersEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ImplicitLineContinuation : VBWhiteSpaceTokenBase {
    public NodeType NodeType { get; }
    public ImplicitLineContinuation(string text);
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ImportAliasClause : VBCompositeElement {
    public static short VB_NAME;
    public static short VB_EQ;
    public static short VB_TYPE_USAGE;
    public NodeType NodeType { get; }
    public IVBIdentifier Alias { get; }
    public ITokenNode EqSign { get; }
    public IReferenceName ImportedSymbol { get; }
    public string AliasName { get; }
    [CanBeNullAttribute]
public IReference ImportedSymbolReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBIdentifier get_Alias();
    public virtual ITokenNode get_EqSign();
    public virtual IReferenceName get_ImportedSymbol();
    public virtual IVBIdentifier SetAlias(IVBIdentifier param);
    public virtual IReferenceName SetImportedSymbol(IReferenceName param);
    public virtual string ToString();
    public sealed virtual string get_AliasName();
    public sealed virtual IReference get_ImportedSymbolReference();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ImportDirective : VBCompositeElement {
    public static short KEYWORD;
    public static short IMPORT_CLAUSE;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IImportClause> ImportClauses { get; }
    public TreeNodeEnumerable`1<IImportClause> ImportClausesEnumerable { get; }
    public ITokenNode ImportsKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IImportClause> get_ImportClauses();
    public virtual TreeNodeEnumerable`1<IImportClause> get_ImportClausesEnumerable();
    public virtual ITokenNode get_ImportsKeyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ImportDirectivesSection : VBCompositeElement {
    public static short IMPORT_DIRECTIVE;
    public static short VB_STATEMENT_TERMINATOR;
    private CachedPsiValue`1<Dictionary`2<string, ResolveResultWithInfo>> myUsingNamespaceResolveCache;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IImportDirective> ImportDirectives { get; }
    public TreeNodeEnumerable`1<IImportDirective> ImportDirectivesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IImportDirective> get_ImportDirectives();
    public virtual TreeNodeEnumerable`1<IImportDirective> get_ImportDirectivesEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual string ToString();
    protected virtual void PreInit();
    public ResolveResultWithInfo GetCachedResult(string name);
    public void SetCachedResult(string name, ResolveResultWithInfo result);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ImportNamespaceClause : VBCompositeElement {
    public static short NAMESPACE_REFERENCE;
    public NodeType NodeType { get; }
    public IReferenceName ImportedNamespaceReferenceName { get; }
    public IReference Reference { get; }
    public IDeclaredElement ImportedElement { get; }
    public INamespace ImportedNamespace { get; }
    public ITypeElement ImportedType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IReferenceName get_ImportedNamespaceReferenceName();
    public virtual IReferenceName SetImportedNamespaceReferenceName(IReferenceName param);
    public virtual string ToString();
    public sealed virtual IReference get_Reference();
    public sealed virtual IDeclaredElement get_ImportedElement();
    public INamespace get_ImportedNamespace();
    public ITypeElement get_ImportedType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ImportXMLNamespaceClause : VBCompositeElement {
    public static short TAG_START;
    public static short IDENTIFIER;
    public static short SPACE;
    public static short EQ;
    public static short STRING;
    public static short TAG_END;
    public NodeType NodeType { get; }
    public ITokenNode EqSign { get; }
    public ITokenNode Identifier { get; }
    public TreeNodeCollection`1<ITokenNode> Space { get; }
    public TreeNodeEnumerable`1<ITokenNode> SpaceEnumerable { get; }
    public ITokenNode String { get; }
    public ITokenNode TagEnd { get; }
    public ITokenNode TagStart { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EqSign();
    public virtual ITokenNode get_Identifier();
    public virtual TreeNodeCollection`1<ITokenNode> get_Space();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_SpaceEnumerable();
    public virtual ITokenNode get_String();
    public virtual ITokenNode get_TagEnd();
    public virtual ITokenNode get_TagStart();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InactivePreprocessorBranchElement : VBCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual string ToString();
    public virtual void Accept(TreeNodeVisitor visitor);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InactivePreprocessorBranchNodeType : VBCompositeNodeType {
    internal static InactivePreprocessorBranchNodeType INSTANCE;
    private static InactivePreprocessorBranchNodeType();
    public virtual CompositeElement Create();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.IndexExpression : VBExpressionBase {
    public static short EXPRESSION;
    public static short VB_OP_SIGN;
    public static short VB_ARGUMENT_LIST;
    private static string CHR;
    private static string CHRW;
    private static string ASC;
    private static string ASCW;
    private MyReference myReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public IPrimaryExpression Expression { get; }
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    private IList`1<IVBArgumentInfo> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.InvocationArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    public IVBTreeNode Node { get; }
    public IIndexExpressionReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.Reference { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public bool HasConditionalAccessSign { get; }
    public IVBExpression ConditionalQualifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual IConditionalAccessSign get_ConditionalAccessSign();
    public virtual IPrimaryExpression get_Expression();
    public virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public virtual IPrimaryExpression SetExpression(IPrimaryExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public IExpressionType CalculateOriginalExpressionType(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    private sealed virtual override IList`1<IVBArgumentInfo> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_InvocationArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    public sealed virtual IVBTreeNode get_Node();
    public sealed virtual IIndexExpressionReference get_Reference();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_Reference();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    private IVBExpression GetMethodInvocationQualifier();
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual T AddArgumentBefore(T argument, IVBArgument anchor);
    public sealed virtual T AddArgumentAfter(T argument, IVBArgument anchor);
    public sealed virtual T ReplaceArgument(IVBArgument oldArgument, T newArgument);
    public sealed virtual void RemoveArgument(IVBArgument argument);
    public sealed virtual bool get_HasConditionalAccessSign();
    public sealed virtual IVBExpression get_ConditionalQualifier();
    public sealed virtual void SetConditionalAccessSign(bool value);
    public sealed virtual IExpressionType UnliftedExpressionType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InstanceExpression : VBExpressionBase {
    public static short INSTANCE;
    public NodeType NodeType { get; }
    public ITokenNode Instance { get; }
    public InstanceExpressionKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Instance();
    public virtual string ToString();
    private IDeclaredType GetBaseType(ITypeElement typeElement);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual IDeclaredType GetInstanceType();
    public QualifierKind GetKind();
    public sealed virtual InstanceExpressionKind get_Kind();
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.IntegerDivisionExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InterfaceDeclaration : ClassLikeDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short INTERFACE_KEYWORD;
    public static short VB_NAME;
    public static short VB_TYPE_PARAMETERS_LIST;
    public static short VB_STATEMENT_TERMINATOR;
    public static short INHERITS_CLAUSE;
    public static short VB_BODY;
    public static short VB_END_DECLARATION;
    private IVBIdentifier myCachedName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedNameValid;
    private ITypeParameterOfTypeList myCachedTypeParameterList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedTypeParameterListValid;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public IClassBody Body { get; }
    public ITokenNode EndInterface { get; }
    public TreeNodeCollection`1<IInterfaceInheritsClause> InheritsClauses { get; }
    public TreeNodeEnumerable`1<IInterfaceInheritsClause> InheritsClausesEnumerable { get; }
    public ITokenNode InterfaceKeyword { get; }
    public IModifiersList ModifiersList { get; }
    public IVBIdentifier Name { get; }
    protected IVBIdentifier _Name { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    protected ITypeParameterOfTypeList _TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConversionOperatorDeclaration> ConversionOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IConversionOperatorDeclaration> ConversionOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> InheritsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> InheritsTypesEnumerable { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public IVBNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ISignOperatorDeclaration> SignOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<ISignOperatorDeclaration> SignOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> TypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.TypeElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public TreeNodeCollection`1<IVBTypeMemberDeclaration> MemberDeclarations { get; }
    public IList`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public IEnumerable`1<IDeclaredTypeUsage> ExtendsListTypeUsages { get; }
    public IReadOnlyList`1<ITypeDeclaration> NestedTypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public ITokenNode OpenKeyword { get; }
    public ITokenNode EndKeyword { get; }
    public int LevelDelta { get; }
    public bool IsPartial { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual IClassBody get_Body();
    public virtual ITokenNode get_EndInterface();
    public virtual TreeNodeCollection`1<IInterfaceInheritsClause> get_InheritsClauses();
    public virtual TreeNodeEnumerable`1<IInterfaceInheritsClause> get_InheritsClausesEnumerable();
    public virtual ITokenNode get_InterfaceKeyword();
    public virtual IModifiersList get_ModifiersList();
    public sealed virtual IVBIdentifier get_Name();
    protected virtual IVBIdentifier get__Name();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public sealed virtual ITypeParameterOfTypeList get_TypeParameterList();
    protected virtual ITypeParameterOfTypeList get__TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_InheritsTypes();
    public virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_InheritsTypesEnumerable();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual IVBNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ISignOperatorDeclaration> get_SignOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<ISignOperatorDeclaration> get_SignOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVBTreeNode> get_TypeDeclarations();
    public virtual TreeNodeEnumerable`1<IVBTreeNode> get_TypeDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<IVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IClassBody SetBody(IClassBody param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    protected virtual IClassBody GetBody();
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration param);
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.get_TypeElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public sealed virtual TreeNodeCollection`1<IVBTypeMemberDeclaration> get_MemberDeclarations();
    public sealed virtual IList`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public virtual IEnumerable`1<IDeclaredTypeUsage> get_ExtendsListTypeUsages();
    public sealed virtual IReadOnlyList`1<ITypeDeclaration> get_NestedTypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    public sealed virtual ITokenNode get_OpenKeyword();
    public sealed virtual ITokenNode get_EndKeyword();
    private ISymbolTable GetInterfaceGlobalDeclarations(SymbolTableMode mode, int level);
    private ISymbolTable GetSuperTypesDeclarations(int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual IInterfaceInheritsClause AddInheritsClauseBefore(IInterfaceInheritsClause param, IInterfaceInheritsClause anchor);
    public sealed virtual IInterfaceInheritsClause AddInheritsClauseAfter(IInterfaceInheritsClause param, IInterfaceInheritsClause anchor);
    public sealed virtual void AddInheritsType(IDeclaredType implementsType);
    public sealed virtual void RemoveInheritsType(IDeclaredType implementsType);
    public sealed virtual bool get_IsPartial();
    public sealed virtual void SetPartial(bool value);
    public sealed virtual void SetExtern(bool value);
    public sealed virtual void SetUnsafe(bool value);
    public sealed virtual void SetVolatile(bool value);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InterfaceInheritsClause : VBCompositeElement {
    public static short INHERITS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode InheritsKeyword { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> InheritsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> InheritsTypesEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_InheritsKeyword();
    public virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_InheritsTypes();
    public virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_InheritsTypesEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InterfaceMemberSpecifier : VBCompositeElement {
    public static short QUALIFIER;
    public static short DOT;
    public static short MEMBER_NAME;
    private MyReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode Dot { get; }
    public IReferenceName InterfaceQualification { get; }
    public IVBIdentifier MemberName { get; }
    public IReference Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Dot();
    public virtual IReferenceName get_InterfaceQualification();
    public virtual IVBIdentifier get_MemberName();
    public virtual IReferenceName SetInterfaceQualification(IReferenceName param);
    public virtual IVBIdentifier SetMemberName(IVBIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IReference get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InterpolatedStringExpression : VBExpressionBase {
    public static short LITERAL;
    public static short INSERT;
    [NotNullAttribute]
private InterpolatedStringReference myReference;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IInterpolatedStringInsert> Inserts { get; }
    public TreeNodeEnumerable`1<IInterpolatedStringInsert> InsertsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Literals { get; }
    public TreeNodeEnumerable`1<ITokenNode> LiteralsEnumerable { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IVBArgumentInfo JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.ExtensionQualifier { get; }
    private IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.Reference { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    private IList`1<IType> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.TypeArguments { get; }
    private IVBTreeNode JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.Node { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    private IPsiModule JetBrains.ReSharper.Psi.IInvocationInfo.PsiModule { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IInterpolatedStringInsert> get_Inserts();
    public virtual TreeNodeEnumerable`1<IInterpolatedStringInsert> get_InsertsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Literals();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_LiteralsEnumerable();
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IVBArgumentInfo JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_Reference();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    private sealed virtual override IList`1<IType> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_TypeArguments();
    private sealed virtual override IVBTreeNode JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_Node();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.IInvocationInfo.get_PsiModule();
    public sealed virtual bool IsDefaultInterpolation();
    public virtual IType Type(IResolveContext resolveContext);
    public sealed virtual bool IsDefaultInterpolation(IResolveContext resolveContext);
    public sealed virtual IType GetInterpolationType();
    public sealed virtual IType GetInterpolationType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InterpolatedStringInsert : VBCompositeElement {
    public static short EXPR1;
    public static short VB_COMMA;
    public static short LITERAL;
    public static short FORMAT_SPECIFIER;
    public NodeType NodeType { get; }
    public ITokenNode Alignment { get; }
    public ITokenNode Comma { get; }
    public IVBExpression Expression { get; }
    public ITokenNode FormatSpecifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Alignment();
    public virtual ITokenNode get_Comma();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_FormatSpecifier();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.IntoOfAggregateQueryOperator : QueryOperatorBase {
    public static short INTO_KEYWORD;
    public static short EXPRESSION_DECLARATION_LIST;
    private IntoOfAggregateReferenceImpl myReference;
    public NodeType NodeType { get; }
    public IAggregatedRangeVariableDeclarationList AggregatedRangeVariableDeclarationList { get; }
    public ITokenNode IntoKeyword { get; }
    public TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> Variables { get; }
    public TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> VariablesEnumerable { get; }
    public bool IsStandalone { get; }
    public IQueryReference SelectReference { get; }
    public bool HasSignleInto { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAggregatedRangeVariableDeclarationList get_AggregatedRangeVariableDeclarationList();
    public virtual ITokenNode get_IntoKeyword();
    public virtual TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> get_Variables();
    public virtual TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> get_VariablesEnumerable();
    public virtual IAggregatedRangeVariableDeclarationList SetAggregatedRangeVariableDeclarationList(IAggregatedRangeVariableDeclarationList param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual bool get_IsStandalone();
    public sealed virtual IQueryReference get_SelectReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public sealed virtual bool get_HasSignleInto();
    public IType GetReturnType(IResolveContext resolveContext);
    public virtual ITokenNode get_FirstKeyword();
    [CompilerGeneratedAttribute]
private QueryChainTypeBase <TransitChainType>b__26_0(IAggregatedRangeVariableDeclaration x);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.InvocationStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXPR;
    public NodeType NodeType { get; }
    public ITokenNode CallKeyword { get; }
    public IVBExpression Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_CallKeyword();
    public virtual IVBExpression get_Expression();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.IsExpression : VBExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public virtual bool IsConstantValue(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.IsNotExpression : VBExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
}
internal interface JetBrains.ReSharper.Psi.VB.Impl.Tree.IVBBinaryOperatorNodeImpl {
    public IVBExpression Right { get; }
    public IVBExpression Left { get; }
    public TokenNodeType SignTokenType { get; }
    public abstract virtual IVBExpression get_Right();
    public abstract virtual IVBExpression get_Left();
    public abstract virtual IAccessContext GetAccessContext();
    public abstract virtual TokenNodeType get_SignTokenType();
    public abstract virtual TreeTextRange GetSignTreeTextRange();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.Tree.IVBHashableDeclaration {
    public IEnumerable`1<IVBHashableDeclaration> Children { get; }
    public bool IsInternal { get; }
    public abstract virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    public abstract virtual IEnumerable`1<IVBHashableDeclaration> get_Children();
    public abstract virtual bool get_IsInternal();
}
public interface JetBrains.ReSharper.Psi.VB.Impl.Tree.IVBXmlMemberAccessReference {
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.JoinCollectionRangeVariableDeclaration : CollectionRangeVariableDeclarationBase {
    public static short VB_NAME;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short IN_KEYWORD;
    public static short VALUE;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public ITokenNode InKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    public IVBExpression Value { get; }
    protected ITypeUsage TypeUsage2 { get; }
    protected IVBExpression Expression2 { get; }
    protected IVBIdentifier Name2 { get; }
    protected ITokenNode AsKeyword2 { get; }
    protected TreeTextRange ReferencesTextRange { get; }
    private IQueryRangeVariable JetBrains.ReSharper.Psi.VB.Tree.IJoinCollectionRangeVariableDeclaration.DeclaredElement { get; }
    public IQueryExpression QueryExpression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual ITokenNode get_InKeyword();
    public virtual IVBIdentifier get_Name();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IVBExpression get_Value();
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual IVBExpression SetValue(IVBExpression param);
    public virtual string ToString();
    protected virtual ITypeUsage get_TypeUsage2();
    protected virtual IVBExpression get_Expression2();
    protected virtual IVBIdentifier get_Name2();
    protected virtual ITokenNode get_AsKeyword2();
    protected virtual TreeTextRange get_ReferencesTextRange();
    public virtual IExpressionType GetCastedCollectionType(IResolveContext resolveContext);
    private sealed virtual override IQueryRangeVariable JetBrains.ReSharper.Psi.VB.Tree.IJoinCollectionRangeVariableDeclaration.get_DeclaredElement();
    public sealed virtual IQueryExpression get_QueryExpression();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.JoinCondition : VBCompositeElement {
    public static short VB_OP1;
    public static short EQUALS_KEYWORD;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public ITokenNode EqualsKeyword { get; }
    public IQueryParameterPlatform LeftExpression { get; }
    public IQueryParameterPlatform RightExpression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EqualsKeyword();
    public virtual IQueryParameterPlatform get_LeftExpression();
    public virtual IQueryParameterPlatform get_RightExpression();
    public virtual IQueryParameterPlatform SetLeftExpression(IQueryParameterPlatform param);
    public virtual IQueryParameterPlatform SetRightExpression(IQueryParameterPlatform param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.JoinQueryConditionsListFake : VBCompositeElement {
    public static short EXPRESSION;
    public static short EQUALS_KEYWORD;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> EqualsKeyword { get; }
    public TreeNodeEnumerable`1<ITokenNode> EqualsKeywordEnumerable { get; }
    public TreeNodeCollection`1<IVBExpression> Expression { get; }
    public TreeNodeEnumerable`1<IVBExpression> ExpressionEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_EqualsKeyword();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_EqualsKeywordEnumerable();
    public virtual TreeNodeCollection`1<IVBExpression> get_Expression();
    public virtual TreeNodeEnumerable`1<IVBExpression> get_ExpressionEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.JoinQueryOperator : QueryOperatorBase {
    public static short JOIN_KEYWORD;
    public static short DECLARATION;
    public static short JOIN_QUERY_OPERATOR;
    public static short ON_KEYWORD;
    public static short JOIN_CONDITIONS_LIST;
    private JoinReferenceImpl myReference;
    public NodeType NodeType { get; }
    public IQueryConditionsList ConditionsList { get; }
    public IJoinCollectionRangeVariableDeclaration Declaration { get; }
    public ITokenNode JoinKeyword { get; }
    public IJoinQueryOperator NestedJoinQueryOperator { get; }
    public ITokenNode OnKeyword { get; }
    public TreeNodeCollection`1<IJoinCondition> Conditions { get; }
    public TreeNodeEnumerable`1<IJoinCondition> ConditionsEnumerable { get; }
    public IQueryReference JoinReference { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryConditionsList get_ConditionsList();
    public virtual IJoinCollectionRangeVariableDeclaration get_Declaration();
    public virtual ITokenNode get_JoinKeyword();
    public virtual IJoinQueryOperator get_NestedJoinQueryOperator();
    public virtual ITokenNode get_OnKeyword();
    public virtual TreeNodeCollection`1<IJoinCondition> get_Conditions();
    public virtual TreeNodeEnumerable`1<IJoinCondition> get_ConditionsEnumerable();
    public virtual IQueryConditionsList SetConditionsList(IQueryConditionsList param);
    public virtual IJoinCollectionRangeVariableDeclaration SetDeclaration(IJoinCollectionRangeVariableDeclaration param);
    public virtual IJoinQueryOperator SetNestedJoinQueryOperator(IJoinQueryOperator param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IQueryReference get_JoinReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    [CanBeNullAttribute]
internal IList`1<IVBArgumentInfo> GetSharedArguments(IVBInvocationInfo invocationInfo, QueryChainTypeBase chainType);
    internal QueryChainTypeBase GetJoinedChainType();
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LabelDeclaration : VBNonCachedDeclarationBase {
    public static short LABEL_NAME;
    public NodeType NodeType { get; }
    public ILabelName LabelName { get; }
    public string DeclaredName { get; }
    private ILabel JetBrains.ReSharper.Psi.VB.Tree.ILabelDeclaration.DeclaredElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ILabelName get_LabelName();
    public virtual ILabelName SetLabelName(ILabelName param);
    public virtual string ToString();
    public virtual DeclaredElementType GetElementType();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    private sealed virtual override ILabel JetBrains.ReSharper.Psi.VB.Tree.ILabelDeclaration.get_DeclaredElement();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LabelName : VBCompositeElement {
    public static short VB_NAME;
    private LabelReference myLabelReference;
    public NodeType NodeType { get; }
    public IVBTreeNode Name { get; }
    public IReference Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBTreeNode get_Name();
    public virtual string ToString();
    protected virtual void PreInit();
    public IReference get_Reference();
    public virtual ReferenceCollection GetFirstClassReferences();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.LabelReferencingStatementBase : StatementBase {
    public string Label { get; }
    public IReference Reference { get; }
    public sealed virtual string get_Label();
    public virtual IReference get_Reference();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LabelStatement : StatementBase {
    public static short DECLARATION;
    public NodeType NodeType { get; }
    public ILabelDeclaration Declaration { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ILabelDeclaration get_Declaration();
    public virtual ILabelDeclaration SetDeclaration(ILabelDeclaration param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LambdaFunctionExpression : VBLambdaExpression {
    public static short ASYNC_KEYWORD;
    public static short ITERATOR_KEYWORD;
    public static short FUNCTION_KEYWORD;
    public static short SIGNATURE;
    public static short EXPRESSION;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BLOCK;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public ITokenNode AsyncKeyword { get; }
    public IBlock Block { get; }
    public ITokenNode EndFunction { get; }
    public IVBExpression Expression { get; }
    public ITokenNode FunctionKeyword { get; }
    public ITokenNode IteratorKeyword { get; }
    public ITypeUsage ReturnTypeUsage { get; }
    public ILambdaSignature Signature { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<ILambdaParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILambdaParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public bool IsMultiline { get; }
    public bool IsIterator { get; }
    public bool IsAsynchronous { get; }
    public ITokenNode StartDeclaration { get; }
    public ITokenNode EndDeclaration { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual ITokenNode get_AsyncKeyword();
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndFunction();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_FunctionKeyword();
    public virtual ITokenNode get_IteratorKeyword();
    public virtual ITypeUsage get_ReturnTypeUsage();
    public virtual ILambdaSignature get_Signature();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<ILambdaParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ILambdaParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual ITypeUsage SetReturnTypeUsage(ITypeUsage param);
    public virtual ILambdaSignature SetSignature(ILambdaSignature param);
    public virtual string ToString();
    public virtual TreeTextRange GetNameRange();
    public virtual IType GetReturnType(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual bool get_IsMultiline();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsynchronous();
    public sealed virtual void SetIterator(bool value);
    public sealed virtual void SetAsync(bool value);
    public sealed virtual ITokenNode get_StartDeclaration();
    public sealed virtual ITokenNode get_EndDeclaration();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LambdaParameterDeclaration : VBNonCachedDeclarationBase {
    public static short VB_MODIFIER;
    public static short VB_NAME;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    private CachedPsiValue`1<IType> myCachedType;
    public NodeType NodeType { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode AsKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Modifier { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifierEnumerable { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode NullableMark { get; }
    public ITypeUsage TypeUsage { get; }
    public ILambdaParameter DeclaredElement { get; }
    private IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.DeclaredElement { get; }
    public string DeclaredName { get; }
    public IType Type { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public bool IsExplicitlyTyped { get; }
    public bool IsImplicitlyTyped { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsValueVariable { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual ITokenNode get_AsKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_Modifier();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifierEnumerable();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_NullableMark();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual ILambdaParameter get_DeclaredElement();
    private sealed virtual override IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.get_DeclaredElement();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    public sealed virtual IType get_Type();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    public sealed virtual bool get_IsExplicitlyTyped();
    public sealed virtual bool get_IsImplicitlyTyped();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual void SetType(IType type);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LambdaSignature : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short PARAMETER_DECL;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public TreeNodeCollection`1<ILambdaParameterDeclaration> LambdaParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILambdaParameterDeclaration> LambdaParameterDeclarationsEnumerable { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<IVBParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IVBParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual TreeNodeCollection`1<ILambdaParameterDeclaration> get_LambdaParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ILambdaParameterDeclaration> get_LambdaParameterDeclarationsEnumerable();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
    public sealed virtual TreeNodeCollection`1<IVBParameterDeclaration> get_ParameterDeclarations();
    public sealed virtual TreeNodeEnumerable`1<IVBParameterDeclaration> get_ParameterDeclarationsEnumerable();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LambdaSubExpression : VBLambdaExpression {
    public static short ASYNC_KEYWORD;
    public static short ITERATOR_KEYWORD;
    public static short SUB_KEYWORD;
    public static short SIGNATURE;
    public static short STATEMENT;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BLOCK;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public ITokenNode AsyncKeyword { get; }
    public IBlock Block { get; }
    public ITokenNode EndSub { get; }
    public ITokenNode IteratorKeyword { get; }
    public ILambdaSignature Signature { get; }
    public IVBStatement Statement { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode SubKeyword { get; }
    public TreeNodeCollection`1<ILambdaParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILambdaParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public bool IsMultiline { get; }
    public bool IsIterator { get; }
    public bool IsAsynchronous { get; }
    public ITokenNode StartDeclaration { get; }
    public ITokenNode EndDeclaration { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsyncKeyword();
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndSub();
    public virtual ITokenNode get_IteratorKeyword();
    public virtual ILambdaSignature get_Signature();
    public virtual IVBStatement get_Statement();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITokenNode get_SubKeyword();
    public virtual TreeNodeCollection`1<ILambdaParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ILambdaParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IBlock SetBlock(IBlock param);
    public virtual ILambdaSignature SetSignature(ILambdaSignature param);
    public virtual IVBStatement SetStatement(IVBStatement param);
    public virtual string ToString();
    public virtual IType GetReturnType(IResolveContext resolveContext);
    public virtual TreeTextRange GetNameRange();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual bool get_IsMultiline();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAsynchronous();
    public sealed virtual void SetIterator(bool value);
    public sealed virtual void SetAsync(bool value);
    public sealed virtual ITokenNode get_StartDeclaration();
    public sealed virtual ITokenNode get_EndDeclaration();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LetQueryOperator : QueryOperatorBase {
    public static short LET_KEYWORD;
    public static short DECLARATION_LIST;
    public NodeType NodeType { get; }
    public IExpressionRangeVariableDeclarationList DeclarationList { get; }
    public ITokenNode LetKeyword { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IExpressionRangeVariableDeclarationList get_DeclarationList();
    public virtual ITokenNode get_LetKeyword();
    public virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IExpressionRangeVariableDeclarationList SetDeclarationList(IExpressionRangeVariableDeclarationList param);
    public virtual string ToString();
    public virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LibraryClause : VBCompositeElement {
    public static short LIB_KEYWORD;
    public static short STRING;
    public NodeType NodeType { get; }
    public ITokenNode LibKeyword { get; }
    public ITokenNode LibName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LibKeyword();
    public virtual ITokenNode get_LibName();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LikeExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LineContinuation : VBWhiteSpaceTokenBase {
    public NodeType NodeType { get; }
    public LineContinuation(string text);
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LineIfStatement : StatementBase {
    public static short IF_KEYWORD;
    public static short EXPRESSION;
    public static short THEN_KEYWORD;
    public static short IF_STMT_SEQ;
    public static short ELSEIF_KEYWORD;
    public static short ELSEIF_EXPRESSION;
    public static short ELSEIF_STMT_SEQ;
    public static short ELSE_KEYWORD;
    public static short ELSE_STMT_SEQ;
    public NodeType NodeType { get; }
    public ILineIfStatementBody ElseBranch { get; }
    public TreeNodeCollection`1<ILineIfStatementBody> ElseIfBranch { get; }
    public TreeNodeEnumerable`1<ILineIfStatementBody> ElseIfBranchEnumerable { get; }
    public TreeNodeCollection`1<IVBExpression> ElseIfExpression { get; }
    public TreeNodeEnumerable`1<IVBExpression> ElseIfExpressionEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ElseIfKeyword { get; }
    public TreeNodeEnumerable`1<ITokenNode> ElseIfKeywordEnumerable { get; }
    public ITokenNode ElseKeyword { get; }
    public IVBExpression Expression { get; }
    public ILineIfStatementBody IfBranch { get; }
    public ITokenNode IfKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> ThenKeyword { get; }
    public TreeNodeEnumerable`1<ITokenNode> ThenKeywordEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ILineIfStatementBody get_ElseBranch();
    public virtual TreeNodeCollection`1<ILineIfStatementBody> get_ElseIfBranch();
    public virtual TreeNodeEnumerable`1<ILineIfStatementBody> get_ElseIfBranchEnumerable();
    public virtual TreeNodeCollection`1<IVBExpression> get_ElseIfExpression();
    public virtual TreeNodeEnumerable`1<IVBExpression> get_ElseIfExpressionEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_ElseIfKeyword();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ElseIfKeywordEnumerable();
    public virtual ITokenNode get_ElseKeyword();
    public virtual IVBExpression get_Expression();
    public virtual ILineIfStatementBody get_IfBranch();
    public virtual ITokenNode get_IfKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_ThenKeyword();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ThenKeywordEnumerable();
    public virtual ILineIfStatementBody SetElseBranch(ILineIfStatementBody param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual ILineIfStatementBody SetIfBranch(ILineIfStatementBody param);
    public virtual string ToString();
    public sealed virtual IList`1<IVBStatement> GetElseIfStatements(IVBExpression elseIfCondition);
    public sealed virtual TreeNodeCollection`1<IVBStatement> GetIfStatements();
    public sealed virtual TreeNodeCollection`1<IVBStatement> GetElseStatements();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LineIfStatementBody : VBCompositeElement {
    public static short STATEMENT;
    public static short VB_COLON;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Colons { get; }
    public TreeNodeEnumerable`1<ITokenNode> ColonsEnumerable { get; }
    public TreeNodeCollection`1<IVBStatement> Statements { get; }
    public TreeNodeEnumerable`1<IVBStatement> StatementsEnumerable { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Colons();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ColonsEnumerable();
    public virtual TreeNodeCollection`1<IVBStatement> get_Statements();
    public virtual TreeNodeEnumerable`1<IVBStatement> get_StatementsEnumerable();
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual void RemoveStatement(IVBStatement statement);
    [CompilerGeneratedAttribute]
private ISymbolTable <get_LocalVariables>b__22_0();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LineTerminator : VBFloatingLeafElement {
    private string myText;
    public NodeType NodeType { get; }
    public LineTerminator(string text);
    public virtual NodeType get_NodeType();
    public virtual int GetTextLength();
    public virtual string GetText();
}
public enum JetBrains.ReSharper.Psi.VB.Impl.Tree.LiteralExpressionType : Enum {
    public int value__;
    public static LiteralExpressionType XElement;
    public static LiteralExpressionType XDocument;
    public static LiteralExpressionType XProcessingInstruction;
    public static LiteralExpressionType XFragment;
    public static LiteralExpressionType XComment;
    public static LiteralExpressionType XData;
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LocalDeclarationList : LocalDeclarationListStub {
    public virtual IVBExpression SetInitializer(IVBExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.LocalDeclarationListStub : VBCompositeElement {
    public static short DECLARATION;
    public static short VB_COMMA;
    public static short AS_KEYWORD;
    public static short CREATION_EXPRESSION;
    public static short VB_TYPE_USAGE;
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public TreeNodeCollection`1<ILocalVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<ILocalVariableDeclaration> DeclarationsEnumerable { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public ITypeUsage TypeUsage { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual IObjectCreationExpression get_CreationExpression();
    public virtual TreeNodeCollection`1<ILocalVariableDeclaration> get_Declarations();
    public virtual TreeNodeEnumerable`1<ILocalVariableDeclaration> get_DeclarationsEnumerable();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Initializer();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LocalDeclarationStatement : StatementBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short KEYWORD;
    public static short LOCAL_DECL_LIST;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ILocalDeclarationList> DeclarationLists { get; }
    public TreeNodeEnumerable`1<ILocalDeclarationList> DeclarationListsEnumerable { get; }
    public ITokenNode Keyword { get; }
    public IList`1<ILocalVariableDeclaration> VariableDeclarations { get; }
    public LocalDeclarationKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ILocalDeclarationList> get_DeclarationLists();
    public virtual TreeNodeEnumerable`1<ILocalDeclarationList> get_DeclarationListsEnumerable();
    public virtual ITokenNode get_Keyword();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual string ToString();
    public sealed virtual void RemoveVariableDeclaration(ILocalVariableDeclaration declaration);
    public sealed virtual IList`1<ILocalVariableDeclaration> get_VariableDeclarations();
    public sealed virtual LocalDeclarationKind get_Kind();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LocalVariableDeclaration : LocalVariableDeclarationStub {
    public virtual IVBExpression SetInitializer(IVBExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.LocalVariableDeclarationBase : VBNonCachedDeclarationBase {
    private CachedPsiValue`1<IType> myCachedType;
    public IType Type { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public bool IsImplicitlyTyped { get; }
    public bool IsWritable { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsConstant { get; }
    public ConstantValue ConstantValue { get; }
    protected virtual void PreInit();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IType get_Type();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
    protected IType CalculateExplicitType(ITypeUsage typeUsage, ITokenNode nullableMark, IArrayModifiersList arrayModifiersList, IObjectCreationExpression creationExpression, IVBIdentifier nameIdentifier);
    protected IType CalculateImplicitType(IResolveContext resolveContext, IVBExpression initializer, ITokenNode nullableMark, IArrayModifiersList arrayModifiersList);
    public abstract virtual IType CalculateType(IResolveContext resolveContext);
    public abstract virtual bool get_IsImplicitlyTyped();
    public virtual bool get_IsWritable();
    public virtual bool get_IsStatic();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public virtual bool get_IsConstant();
    public virtual ConstantValue get_ConstantValue();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.LocalVariableDeclarationStub : LocalVariableDeclarationBase {
    public static short VB_NAME;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    private JetHashSet`1<Thread> myComputationThreads;
    private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    public NodeType NodeType { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode NullableMark { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public ILocalDeclarationList DeclarationsList { get; }
    public IVBExpression Initializer { get; }
    public ITypeUsage TypeUsage { get; }
    public string DeclaredName { get; }
    public bool IsStatic { get; }
    public bool IsConstant { get; }
    public bool IsWritable { get; }
    public ConstantValue ConstantValue { get; }
    public ConstantValue CachedConstantValue { get; public set; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    public ILocalVariable DeclaredVariable { get; }
    public bool IsImplicitlyTyped { get; }
    private IVBLocalVariable JetBrains.ReSharper.Psi.VB.Tree.ILocalVariableDeclaration.DeclaredElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_NullableMark();
    public virtual IObjectCreationExpression get_CreationExpression();
    public virtual ILocalDeclarationList get_DeclarationsList();
    public virtual IVBExpression get_Initializer();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    private void RemoveCurrentThreadFromTable();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    private ITokenNode GetDeclarationStatementKeyword();
    public virtual bool get_IsStatic();
    public virtual bool get_IsConstant();
    public virtual bool get_IsWritable();
    public virtual ConstantValue get_ConstantValue();
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public sealed virtual ConstantValue get_CachedConstantValue();
    public sealed virtual void set_CachedConstantValue(ConstantValue value);
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    public sealed virtual ILocalVariable get_DeclaredVariable();
    public virtual IType CalculateType(IResolveContext resolveContext);
    public virtual bool get_IsImplicitlyTyped();
    private sealed virtual override IVBLocalVariable JetBrains.ReSharper.Psi.VB.Tree.ILocalVariableDeclaration.get_DeclaredElement();
    public sealed virtual void SetType(IType iType);
    private sealed virtual override IObjectCreationExpression JetBrains.ReSharper.Psi.VB.Tree.ILocalVariableDeclaration.SetCreationExpression(IObjectCreationExpression param);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LogicalAndExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LogicalNotExpression : VBUnaryExpressionBase {
    public static short VB_OP_SIGN;
    public static short EXPRESSION;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode OpSign { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LogicalOrExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LogicalXorExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.LoopControlVariableDeclaration : LocalVariableDeclarationBase {
    public static short VB_NAME;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public NodeType NodeType { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode AsKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode NullableMark { get; }
    public ITypeUsage TypeUsage { get; }
    internal IVBStatement LoopStatement { get; }
    public string DeclaredName { get; }
    public ILocalVariable DeclaredVariable { get; }
    public bool IsWritable { get; }
    public bool IsImplicitlyTyped { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual ITokenNode get_AsKeyword();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_NullableMark();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    internal IVBStatement get_LoopStatement();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual ILocalVariable get_DeclaredVariable();
    public virtual IType CalculateType(IResolveContext resolveContext);
    public virtual bool get_IsWritable();
    public virtual bool get_IsImplicitlyTyped();
    public sealed virtual void SetType(IType type);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.MemberInitializer : VBCompositeElement {
    public static short DOT;
    public static short IDENTIFIER;
    public static short VB_EQ;
    public static short EXPRESSION;
    private MyReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode Dot { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public IVBIdentifier Name { get; }
    public IObjectCreationExpression ObjectCreationExpression { get; }
    public IReference Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Dot();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Expression();
    public virtual IVBIdentifier get_Name();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public IObjectCreationExpression get_ObjectCreationExpression();
    public sealed virtual IReference get_Reference();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.MethodDeclaration : MethodDeclarationStub {
    public virtual IBlock SetBlock(IBlock param);
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.MethodDeclarationBase : ParametersOwnerDeclarationBase {
    public int LevelDelta { get; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    public IMethod DeclaredElement { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    public IMethod get_DeclaredElement();
    internal abstract virtual IAttributeListOwner get_AttributeListOwner();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.MethodDeclarationStub : MethodDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short SUB_KEYWORD;
    public static short FUNCTION_KEYWORD;
    public static short VB_NAME;
    public static short VB_TYPE_PARAMETERS_LIST;
    public static short VB_PARAMETERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_RETURN_ATTRIBUTE_LIST;
    public static short VB_TYPE_USAGE;
    public static short HANDLES_CLAUSE;
    public static short IMPLEMENTS_CLAUSE;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BODY;
    public static short END_DECLARATION;
    private IModifiersList myCachedModifiersList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedModifiersListValid;
    private ITokenNode myCachedSubKeyword;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedSubKeywordValid;
    private ITokenNode myCachedFunctionKeyword;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedFunctionKeywordValid;
    private IVBIdentifier myCachedName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedNameValid;
    private ITypeParameterOfMethodList myCachedTypeParameterList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedTypeParameterListValid;
    private IRegularParameterList myCachedParameterList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedParameterListValid;
    private ITypeUsage myCachedReturnTypeUsage;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedReturnTypeUsageValid;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public IBlock Block { get; }
    public ITokenNode EndDeclaration { get; }
    public ITokenNode FunctionKeyword { get; }
    protected ITokenNode _FunctionKeyword { get; }
    public IHandlesClause HandlesClause { get; }
    public IImplementsClause ImplementsClause { get; }
    public IModifiersList ModifiersList { get; }
    protected IModifiersList _ModifiersList { get; }
    public IVBIdentifier Name { get; }
    protected IVBIdentifier _Name { get; }
    public IRegularParameterList ParameterList { get; }
    protected IRegularParameterList _ParameterList { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage ReturnTypeUsage { get; }
    protected ITypeUsage _ReturnTypeUsage { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode SubKeyword { get; }
    protected ITokenNode _SubKeyword { get; }
    public ITypeParameterOfMethodList TypeParameterList { get; }
    protected ITypeParameterOfMethodList _TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public bool IsPartial { get; }
    public bool IsAsynchronous { get; }
    public bool IsIterator { get; }
    public bool IsExtensionMethodPossible { get; }
    public MethodDeclarationKind Kind { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    public IType Type { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.FunctionElement { get; }
    public ITokenNode StartDeclaration { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IMethod JetBrains.ReSharper.Psi.VB.Tree.IMethodDeclaration.MethodElement { get; }
    private IMethod JetBrains.ReSharper.Psi.VB.Tree.IMethodDeclarationBase.MethodElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    public IList`1<IInterfaceMemberSpecifier> MemberSpecifiers { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndDeclaration();
    public sealed virtual ITokenNode get_FunctionKeyword();
    protected virtual ITokenNode get__FunctionKeyword();
    public virtual IHandlesClause get_HandlesClause();
    public virtual IImplementsClause get_ImplementsClause();
    public sealed virtual IModifiersList get_ModifiersList();
    protected virtual IModifiersList get__ModifiersList();
    public sealed virtual IVBIdentifier get_Name();
    protected virtual IVBIdentifier get__Name();
    public sealed virtual IRegularParameterList get_ParameterList();
    protected virtual IRegularParameterList get__ParameterList();
    public virtual IReturnAttributeList get_ReturnAttributeList();
    public sealed virtual ITypeUsage get_ReturnTypeUsage();
    protected virtual ITypeUsage get__ReturnTypeUsage();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public sealed virtual ITokenNode get_SubKeyword();
    protected virtual ITokenNode get__SubKeyword();
    public sealed virtual ITypeParameterOfMethodList get_TypeParameterList();
    protected virtual ITypeParameterOfMethodList get__TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IBlock SetBlock(IBlock param);
    public virtual IHandlesClause SetHandlesClause(IHandlesClause param);
    public virtual IImplementsClause SetImplementsClause(IImplementsClause param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public virtual ITypeUsage SetReturnTypeUsage(ITypeUsage param);
    public virtual ITypeParameterOfMethodList SetTypeParameterList(ITypeParameterOfMethodList param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public virtual void SetAbstract(bool value);
    public virtual string get_DeclaredName();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual bool get_IsPartial();
    public sealed virtual bool get_IsAsynchronous();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsExtensionMethodPossible();
    public sealed virtual MethodDeclarationKind get_Kind();
    public sealed virtual ITypeParameterOfMethodDeclaration AddTypeParameterBefore(ITypeParameterOfMethodDeclaration param, ITypeParameterOfMethodDeclaration anchor);
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfMethodDeclaration param);
    public sealed virtual void SetPartial(bool value);
    public sealed virtual void SetAsync(bool value);
    public sealed virtual void SetIterator(bool value);
    protected virtual IRegularParameterList GetParameterListNode();
    protected virtual IRegularParameterList CreateEmptyParameterListNode();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    public sealed virtual void SetType(IType returnType);
    public sealed virtual IType get_Type();
    public sealed virtual void AddImplementsSpecification(IDeclaredType interfaceType, string name);
    public sealed virtual void RemoveImplementsSpecification(IDeclaredType interfaceType);
    public sealed virtual void RemoveAllImplementsSpecifications();
    public virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.get_FunctionElement();
    public sealed virtual ITokenNode get_StartDeclaration();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IMethod JetBrains.ReSharper.Psi.VB.Tree.IMethodDeclaration.get_MethodElement();
    private sealed virtual override IMethod JetBrains.ReSharper.Psi.VB.Tree.IMethodDeclarationBase.get_MethodElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    public sealed virtual IList`1<IInterfaceMemberSpecifier> get_MemberSpecifiers();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.MidAssignmentStatement : StatementBase {
    public static short MID_KEYWORD;
    public static short TYPE_CHAR;
    public static short VB_ARGUMENT_LIST;
    public static short EQ_SIGN;
    public static short VB_OP2;
    private MyReference myReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public ITokenNode Eq { get; }
    public ITokenNode MidKeyword { get; }
    public IVBExpression RValue { get; }
    public ITokenNode TypeChar { get; }
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public IVBInvocationReference Reference { get; }
    private IList`1<IVBArgumentInfo> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.InvocationArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    public IList`1<IType> TypeArguments { get; }
    public IVBTreeNode Node { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual ITokenNode get_Eq();
    public virtual ITokenNode get_MidKeyword();
    public virtual IVBExpression get_RValue();
    public virtual ITokenNode get_TypeChar();
    public virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual IVBExpression SetRValue(IVBExpression param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IVBInvocationReference get_Reference();
    private sealed virtual override IList`1<IVBArgumentInfo> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_InvocationArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    public sealed virtual IList`1<IType> get_TypeArguments();
    public sealed virtual IVBTreeNode get_Node();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual T AddArgumentBefore(T argument, IVBArgument anchor);
    public sealed virtual T AddArgumentAfter(T argument, IVBArgument anchor);
    public sealed virtual T ReplaceArgument(IVBArgument oldArgument, T newArgument);
    public sealed virtual void RemoveArgument(IVBArgument argument);
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ModifiersList : VBCompositeElement {
    public static short VB_MODIFIER;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Modifiers { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersEnumerable { get; }
    public AccessRights AccessRightsModifiers { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Modifiers();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersEnumerable();
    public virtual string ToString();
    public sealed virtual bool HasModifier(TokenNodeType tType);
    public sealed virtual AccessRights get_AccessRightsModifiers();
    public sealed virtual void AddModifier(ITokenNode modifierNode);
    public sealed virtual void RemoveModifier(ITokenNode modifierNode);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ModuleDeclaration : ClassLikeDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short MODULE_KEYWORD;
    public static short VB_NAME;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BODY;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public IClassBody Body { get; }
    public ITokenNode EndModule { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode ModuleKeyword { get; }
    public IVBIdentifier Name { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConversionOperatorDeclaration> ConversionOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IConversionOperatorDeclaration> ConversionOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> NestedTypeDeclarationsEnumerable { get; }
    public IVBNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ISignOperatorDeclaration> SignOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<ISignOperatorDeclaration> SignOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.TypeElement { get; }
    public ITokenNode OpenKeyword { get; }
    public ITokenNode EndKeyword { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVBTypeMemberDeclaration> MemberDeclarations { get; }
    public IEnumerable`1<IDeclaredTypeUsage> ExtendsListTypeUsages { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public bool IsPartial { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual IClassBody get_Body();
    public virtual ITokenNode get_EndModule();
    public virtual IModifiersList get_ModifiersList();
    public virtual ITokenNode get_ModuleKeyword();
    public virtual IVBIdentifier get_Name();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVBTreeNode> get_NestedTypeDeclarations();
    public virtual TreeNodeEnumerable`1<IVBTreeNode> get_NestedTypeDeclarationsEnumerable();
    public virtual IVBNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ISignOperatorDeclaration> get_SignOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<ISignOperatorDeclaration> get_SignOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<IVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IClassBody SetBody(IClassBody param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    protected virtual IClassBody GetBody();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.get_TypeElement();
    public sealed virtual ITokenNode get_OpenKeyword();
    public sealed virtual ITokenNode get_EndKeyword();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarationsEnumerable();
    public sealed virtual TreeNodeCollection`1<IVBTypeMemberDeclaration> get_MemberDeclarations();
    public virtual IEnumerable`1<IDeclaredTypeUsage> get_ExtendsListTypeUsages();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    public sealed virtual bool get_IsPartial();
    public sealed virtual void SetPartial(bool value);
    public sealed virtual void SetExtern(bool value);
    public sealed virtual void SetUnsafe(bool value);
    public sealed virtual void SetVolatile(bool value);
    private ISymbolTable GetModuleGlobalDeclarations(int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ModulusExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.MultipleConstantDeclaration : VBCompositeElement {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short CONST_KEYWORD;
    public static short DECLARATION;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ConstKeyword { get; }
    public TreeNodeCollection`1<IConstantDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> DeclarationsEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_ConstKeyword();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_Declarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_DeclarationsEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual string ToString();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.MultipleVariableDeclaration : VBCompositeElement {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short DECLARATION_LIST;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IVariableDeclarationList> DeclarationLists { get; }
    public TreeNodeEnumerable`1<IVariableDeclarationList> DeclarationListsEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public IList`1<IVariableDeclaration> VariableDeclarations { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IVariableDeclarationList> get_DeclarationLists();
    public virtual TreeNodeEnumerable`1<IVariableDeclarationList> get_DeclarationListsEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual string ToString();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual IList`1<IVariableDeclaration> get_VariableDeclarations();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.MultiplicativeExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.NamedArgument : ExpressionArgument {
    public static short IDENTIFIER;
    public static short VB_COLON;
    public static short VB_EQ;
    public static short EXPRESSION;
    private NamedParameterReference myParameterReference;
    private AttributePropertyReference myAttributePropertyReference;
    public NodeType NodeType { get; }
    public ITokenNode ColonSign { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public IVBIdentifier Name { get; }
    public IReference Reference { get; }
    public string ParameterName { get; }
    public IManagedConvertible ManagedConvertible { get; }
    public DeclaredElementInstance`1<IParameter> MatchingParameter { get; }
    public IVBInvocationInfo Invocation { get; }
    public IPsiModule PsiModule { get; }
    public ArgumentKind Kind { get; }
    public string ArgumentName { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public bool IsExtensionInvocationQualifier { get; }
    private IExpression JetBrains.ReSharper.Psi.Tree.IArgument.Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ColonSign();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Expression();
    public virtual IVBIdentifier get_Name();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    private sealed virtual override DocumentRange JetBrains.ReSharper.Psi.IArgumentInfo.GetDocumentRange();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IReference get_Reference();
    public sealed virtual string get_ParameterName();
    public sealed virtual void SetName(string name);
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
    public sealed virtual DeclaredElementInstance`1<IParameter> get_MatchingParameter();
    public sealed virtual IVBInvocationInfo get_Invocation();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual string get_ArgumentName();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IVBArgument ReplaceBy(IVBArgument argument);
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    private sealed virtual override IExpression JetBrains.ReSharper.Psi.Tree.IArgument.get_Expression();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.NamespacePrefixExpression : VBExpressionBase {
    public static short NAME;
    private LocalUserDataHolder myUserDataHolder;
    private CachedPsiValue`1<ResolveResultWithInfo> myResolveCache;
    public NodeType NodeType { get; }
    public ITokenNode Name { get; }
    public IReference Reference { get; }
    public bool HasMultipleNames { get; }
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Name();
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T val);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual IReference get_Reference();
    private sealed virtual override TreeTextRange JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeTextRange();
    public sealed virtual ITreeNode GetTreeNode();
    public sealed virtual string GetName();
    public sealed virtual bool get_HasMultipleNames();
    public sealed virtual HybridCollection`1<string> GetAllNames();
    public sealed virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public sealed virtual ResolveResultWithInfo Resolve();
    public sealed virtual IReference BindTo(IDeclaredElement element);
    public sealed virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual IAccessContext GetAccessContext();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ResolveResultWithInfo get_CurrentResolveResult();
    public sealed virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.NextClause : VBCompositeElement {
    public static short VB_KEYWORD;
    public static short NEXT_EXPR;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IVBExpression> NextExpressions { get; }
    public TreeNodeEnumerable`1<IVBExpression> NextExpressionsEnumerable { get; }
    public ITokenNode NextKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IVBExpression> get_NextExpressions();
    public virtual TreeNodeEnumerable`1<IVBExpression> get_NextExpressionsEnumerable();
    public virtual ITokenNode get_NextKeyword();
    public virtual string ToString();
    public sealed virtual ILoopStatement FindOutermostClosedForLoop();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ObjectCollectionInitializer : VBCompositeElement {
    public static short FROM_KEYWORD;
    public static short VB_LBRACE;
    public static short VB_INITIALIZER;
    public static short VB_COMMA;
    public static short VB_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode FromKeyword { get; }
    public TreeNodeCollection`1<ICollectionElementInitializer> Initializer { get; }
    public TreeNodeEnumerable`1<ICollectionElementInitializer> InitializerEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_FromKeyword();
    public virtual TreeNodeCollection`1<ICollectionElementInitializer> get_Initializer();
    public virtual TreeNodeEnumerable`1<ICollectionElementInitializer> get_InitializerEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ObjectCreationExpression : VBExpressionBase {
    public static short VB_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short NULLABLE_MARK;
    public static short VB_ARGUMENT_LIST;
    public static short VB_INITIALIZER;
    public static short COLLECTION_INITIALIZER;
    private MyConstructorReference myConstructorReference;
    public NodeType NodeType { get; }
    public IArgumentList ArgumentList { get; }
    public IObjectCollectionInitializer CollectionInitializer { get; }
    public ITokenNode NewKeyword { get; }
    public ITokenNode NullableMark { get; }
    public IObjectCreationInitializer ObjectInitializer { get; }
    public IDeclaredTypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public IReference ConstructorReference { get; }
    public IReference TypeReference { get; }
    public IPsiModule PsiModule { get; }
    private IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.Arguments { get; }
    private IList`1<IVBArgumentInfo> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.InvocationArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    public IVBTreeNode Node { get; }
    public IVBInvocationReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArgumentList get_ArgumentList();
    public virtual IObjectCollectionInitializer get_CollectionInitializer();
    public virtual ITokenNode get_NewKeyword();
    public virtual ITokenNode get_NullableMark();
    public virtual IObjectCreationInitializer get_ObjectInitializer();
    public virtual IDeclaredTypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public virtual IArgumentList SetArgumentList(IArgumentList param);
    public virtual IObjectCollectionInitializer SetCollectionInitializer(IObjectCollectionInitializer param);
    public virtual IObjectCreationInitializer SetObjectInitializer(IObjectCreationInitializer param);
    public virtual IDeclaredTypeUsage SetTypeUsage(IDeclaredTypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IReference get_ConstructorReference();
    public sealed virtual IReference get_TypeReference();
    public sealed virtual IPsiModule get_PsiModule();
    private sealed virtual override IList`1<IArgument> JetBrains.ReSharper.Psi.Tree.IArgumentsOwner.get_Arguments();
    private sealed virtual override IList`1<IVBArgumentInfo> JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_InvocationArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual T AddArgumentBefore(T argument, IVBArgument anchor);
    public sealed virtual T AddArgumentAfter(T argument, IVBArgument anchor);
    public sealed virtual T ReplaceArgument(IVBArgument oldArgument, T newArgument);
    public sealed virtual void RemoveArgument(IVBArgument argument);
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    public sealed virtual IVBTreeNode get_Node();
    public sealed virtual IVBInvocationReference get_Reference();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ObjectCreationInitializer : VBCompositeElement {
    public static short WITH_KEYWORD;
    public static short VB_LBRACE;
    public static short MEMBER_INITIALIZER;
    public static short VB_COMMA;
    public static short VB_RBRACE;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IMemberInitializer> MemberInitializers { get; }
    public TreeNodeEnumerable`1<IMemberInitializer> MemberInitializersEnumerable { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode WithKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual TreeNodeCollection`1<IMemberInitializer> get_MemberInitializers();
    public virtual TreeNodeEnumerable`1<IMemberInitializer> get_MemberInitializersEnumerable();
    public virtual ITokenNode get_RBrace();
    public virtual ITokenNode get_WithKeyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.OnErrorSpecialLabel : VBCompositeElement {
    public static short MINUS;
    public static short LITERAL;
    public NodeType NodeType { get; }
    public ITokenNode LiteralAfterMinus { get; }
    public ITokenNode Minus { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_LiteralAfterMinus();
    public virtual ITokenNode get_Minus();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.OnErrorStatement : LabelReferencingStatementBase {
    public static short ON_KEYWORD;
    public static short ERROR_KEYWORD;
    public static short GOTO_KEYWORD;
    public static short LABEL_NAME;
    public static short SPEC_NAME;
    public static short RESUME_KEYWORD;
    public static short NEXT_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode ErrorKeyword { get; }
    public ITokenNode GotoKeyword { get; }
    public ILabelName LabelName { get; }
    public ITokenNode NextKeyword { get; }
    public ITokenNode OnKeyword { get; }
    public ITokenNode ResumeKeyword { get; }
    public IOnErrorSpecialLabel SpecialLabel { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ErrorKeyword();
    public virtual ITokenNode get_GotoKeyword();
    public virtual ILabelName get_LabelName();
    public virtual ITokenNode get_NextKeyword();
    public virtual ITokenNode get_OnKeyword();
    public virtual ITokenNode get_ResumeKeyword();
    public virtual IOnErrorSpecialLabel get_SpecialLabel();
    public virtual ILabelName SetLabelName(ILabelName param);
    public virtual IOnErrorSpecialLabel SetSpecialLabel(IOnErrorSpecialLabel param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.OperatorDeclarationBase : ParametersOwnerDeclarationBase {
    internal IModifiersListOwner ModifiersListOwner { get; }
    public IType Type { get; }
    public IOperator DeclaredElement { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    protected virtual IRegularParameterList GetParameterListNode();
    protected virtual IRegularParameterList CreateEmptyParameterListNode();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    public sealed virtual void SetType(IType _type);
    public sealed virtual IType get_Type();
    public sealed virtual IOperator get_DeclaredElement();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.OptionStatement : VBCompositeElement {
    public static short KEYWORD;
    public static short VB_NAME;
    public static short VALUE;
    public NodeType NodeType { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode OptionKeyword { get; }
    public IVBIdentifier Value { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_OptionKeyword();
    public virtual IVBIdentifier get_Value();
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual IVBIdentifier SetValue(IVBIdentifier param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.OptionStatementsSection : VBCompositeElement {
    public static short OPTION_STATEMENT;
    public static short VB_STATEMENT_TERMINATOR;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IOptionStatement> OptionStatements { get; }
    public TreeNodeEnumerable`1<IOptionStatement> OptionStatementsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IOptionStatement> get_OptionStatements();
    public virtual TreeNodeEnumerable`1<IOptionStatement> get_OptionStatementsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.OrderByQueryOperator : QueryOperatorBase {
    public static short ORDER_KEYWORD;
    public static short BY_KEYWORD;
    public static short ORDER_EXPRESSION;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public ITokenNode ByKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IOrderExpression> OrderExpressions { get; }
    public TreeNodeEnumerable`1<IOrderExpression> OrderExpressionsEnumerable { get; }
    public ITokenNode OrderKeyword { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ByKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IOrderExpression> get_OrderExpressions();
    public virtual TreeNodeEnumerable`1<IOrderExpression> get_OrderExpressionsEnumerable();
    public virtual ITokenNode get_OrderKeyword();
    public virtual string ToString();
    public virtual ITokenNode get_FirstKeyword();
}
public enum JetBrains.ReSharper.Psi.VB.Impl.Tree.OrderByTypes : Enum {
    public int value__;
    public static OrderByTypes Order;
    public static OrderByTypes OrderDescending;
    public static OrderByTypes Then;
    public static OrderByTypes ThenDescending;
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.OrderExpression : VBCompositeElement {
    public static short EXPRESSION;
    public static short ASCENDING_KEYWORD;
    public static short DESCENDING_KEYWORD;
    private OrderReferenceImpl myReference;
    public NodeType NodeType { get; }
    public ITokenNode AscendingKeyword { get; }
    public ITokenNode DescendingKeyword { get; }
    public IQueryParameterPlatform Expression { get; }
    public OrderByTypes OrderByType { get; }
    public IQueryExpression QueryExpression { get; }
    public IQueryReference SelectReference { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AscendingKeyword();
    public virtual ITokenNode get_DescendingKeyword();
    public virtual IQueryParameterPlatform get_Expression();
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual string ToString();
    public OrderByTypes get_OrderByType();
    public sealed virtual IQueryExpression get_QueryExpression();
    protected virtual void PreInit();
    public IQueryReference get_SelectReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.ParametersOwnerDeclarationBase : TypeMemberDeclarationBase {
    protected abstract virtual IRegularParameterList GetParameterListNode();
    protected abstract virtual IRegularParameterList CreateEmptyParameterListNode();
    public sealed virtual IRegularParameterDeclaration AddParameterDeclarationBefore(IRegularParameterDeclaration parameter, IRegularParameterDeclaration anchor);
    public sealed virtual IRegularParameterDeclaration AddParameterDeclarationAfter(IRegularParameterDeclaration parameter, IRegularParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(IRegularParameterDeclaration parameter);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    protected virtual Hash CalculateHashInternal();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ParenthesizedExpression : VBExpressionBase {
    public static short VB_LPARENTH;
    public static short EXPRESSION;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.PartialyApplicableMethodFilter : object {
}
public enum JetBrains.ReSharper.Psi.VB.Impl.Tree.PartitionOperatorKinds : Enum {
    public int value__;
    public static PartitionOperatorKinds Take;
    public static PartitionOperatorKinds Skip;
    public static PartitionOperatorKinds TakeWhile;
    public static PartitionOperatorKinds SkipWhile;
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.PartitionQueryOperator : QueryOperatorBase {
    public static short TAKE_KEYWORD;
    public static short SKIP_KEYWORD;
    public static short WHILE_KEYWORD;
    public static short EXPRESSION;
    private PartitionReferenceImpl myReference;
    public NodeType NodeType { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode SkipKeyword { get; }
    public ITokenNode TakeKeyword { get; }
    public ITokenNode WhileKeyword { get; }
    public IQueryReference SelectReference { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryParameterPlatform get_Expression();
    public virtual ITokenNode get_SkipKeyword();
    public virtual ITokenNode get_TakeKeyword();
    public virtual ITokenNode get_WhileKeyword();
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual string ToString();
    public sealed virtual PartitionOperatorKinds GetKind();
    protected virtual void PreInit();
    public IQueryReference get_SelectReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.PositionalArgument : ExpressionArgument {
    public static short EXPRESSION;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public IManagedConvertible ManagedConvertible { get; }
    public DeclaredElementInstance`1<IParameter> MatchingParameter { get; }
    public IVBInvocationInfo Invocation { get; }
    public IPsiModule PsiModule { get; }
    public ArgumentKind Kind { get; }
    public string ArgumentName { get; }
    private IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.Invocation { get; }
    public bool IsExtensionInvocationQualifier { get; }
    private IExpression JetBrains.ReSharper.Psi.Tree.IArgument.Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
    public sealed virtual IVBArgument ReplaceBy(IVBArgument argument);
    private sealed virtual override DocumentRange JetBrains.ReSharper.Psi.IArgumentInfo.GetDocumentRange();
    public sealed virtual IManagedConvertible get_ManagedConvertible();
    public sealed virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public sealed virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
    public sealed virtual DeclaredElementInstance`1<IParameter> get_MatchingParameter();
    public sealed virtual IVBInvocationInfo get_Invocation();
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual ArgumentKind get_Kind();
    public sealed virtual string get_ArgumentName();
    private sealed virtual override IInvocationInfo JetBrains.ReSharper.Psi.IArgumentInfo.get_Invocation();
    public sealed virtual bool get_IsExtensionInvocationQualifier();
    public sealed virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
    private sealed virtual override IExpression JetBrains.ReSharper.Psi.Tree.IArgument.get_Expression();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.PropertyDeclaration : PropertyDeclarationStub {
    protected virtual IDeclaredElement CreateDeclaredElement();
    [CanBeNullAttribute]
public virtual IVBExpression SetInitializer(IVBExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.PropertyDeclarationStub : ParametersOwnerDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short PROPERTY_KEYWORD;
    public static short VB_NAME;
    public static short VB_PARAMETERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_RETURN_ATTRIBUTE_LIST;
    public static short CREATION_EXPRESSION;
    public static short VB_TYPE_USAGE;
    public static short PROPERTY_INITIALIZER;
    public static short IMPLEMENTS_CLAUSE;
    public static short VB_STATEMENT_TERMINATOR;
    public static short ACCESSOR;
    public static short VB_END_DECLARATION;
    private IImplementsClause myCachedImplementsClause;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedImplementsClauseValid;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IAccessorDeclaration> AccessorDeclarations { get; }
    public TreeNodeEnumerable`1<IAccessorDeclaration> AccessorDeclarationsEnumerable { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public ITokenNode EndProperty { get; }
    public IImplementsClause ImplementsClause { get; }
    protected IImplementsClause _ImplementsClause { get; }
    public IModifiersList ModifiersList { get; }
    public IVBIdentifier Name { get; }
    public IRegularParameterList ParameterList { get; }
    public IPropertyInitializer PropertyInitializer { get; }
    public ITokenNode PropertyKeyword { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IVBExpression Initializer { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    public bool IsIterator { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IAccessorOwnerDeclaration.AccessorOwnerElement { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public ITokenNode OpenKeyword { get; }
    public ITokenNode EndKeyword { get; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsDefault { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public IType Type { get; }
    public bool IsAuto { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private IProperty JetBrains.ReSharper.Psi.VB.Tree.IPropertyDeclaration.PropertyElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    public IList`1<IInterfaceMemberSpecifier> MemberSpecifiers { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IAccessorDeclaration> get_AccessorDeclarations();
    public virtual TreeNodeEnumerable`1<IAccessorDeclaration> get_AccessorDeclarationsEnumerable();
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual IObjectCreationExpression get_CreationExpression();
    public virtual ITokenNode get_EndProperty();
    public sealed virtual IImplementsClause get_ImplementsClause();
    protected virtual IImplementsClause get__ImplementsClause();
    public virtual IModifiersList get_ModifiersList();
    public virtual IVBIdentifier get_Name();
    public virtual IRegularParameterList get_ParameterList();
    public virtual IPropertyInitializer get_PropertyInitializer();
    public virtual ITokenNode get_PropertyKeyword();
    public virtual IReturnAttributeList get_ReturnAttributeList();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IVBExpression get_Initializer();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public virtual IImplementsClause SetImplementsClause(IImplementsClause param);
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public virtual IPropertyInitializer SetPropertyInitializer(IPropertyInitializer param);
    public virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public virtual void SetAbstract(bool value);
    public virtual string get_DeclaredName();
    public sealed virtual bool get_IsIterator();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    public sealed virtual void SetIterator(bool value);
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IAccessorOwnerDeclaration.get_AccessorOwnerElement();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public sealed virtual ITokenNode get_OpenKeyword();
    public sealed virtual ITokenNode get_EndKeyword();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    protected virtual IRegularParameterList GetParameterListNode();
    protected virtual IRegularParameterList CreateEmptyParameterListNode();
    public bool get_IsReadable();
    public bool get_IsWritable();
    public sealed virtual bool get_IsDefault();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationBefore(IAccessorDeclaration param, IAccessorDeclaration anchor);
    public sealed virtual IAccessorDeclaration AddAccessorDeclarationAfter(IAccessorDeclaration param, IAccessorDeclaration anchor);
    public sealed virtual void RemoveAccessorDeclaration(IAccessorDeclaration param);
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public sealed virtual void AddImplementsSpecification(IDeclaredType interfaceType, string name);
    public sealed virtual void RemoveImplementsSpecification(IDeclaredType interfaceType);
    public sealed virtual void RemoveAllImplementsSpecifications();
    [CanBeNullAttribute]
private static ITreeNode FindHeaderAnchor(IPropertyDeclaration node);
    public sealed virtual void AddRemoveBody(bool add);
    public sealed virtual bool get_IsAuto();
    public virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override IProperty JetBrains.ReSharper.Psi.VB.Tree.IPropertyDeclaration.get_PropertyElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    public sealed virtual IList`1<IInterfaceMemberSpecifier> get_MemberSpecifiers();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.PropertyInitializer : VBCompositeElement {
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    public NodeType NodeType { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Initializer();
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Tree.PsiGeneratedGetterTestUtil : PsiGetterTestUtil {
    internal static void TestAccessorDeclaration(int level, IAccessorDeclaration param, string caller);
    internal static void TestAccessorOwnerDeclaration(int level, IAccessorOwnerDeclaration param, string caller);
    internal static void TestAddHandlerStatement(int level, IAddHandlerStatement param, string caller);
    internal static void TestAdditiveExpression(int level, IAdditiveExpression param, string caller);
    internal static void TestAddressOfExpression(int level, IAddressOfExpression param, string caller);
    internal static void TestAggregateQueryOperator(int level, IAggregateQueryOperator param, string caller);
    internal static void TestAggregatedRangeVariableDeclaration(int level, IAggregatedRangeVariableDeclaration param, string caller);
    internal static void TestAggregatedRangeVariableDeclarationList(int level, IAggregatedRangeVariableDeclarationList param, string caller);
    internal static void TestAliasClause(int level, IAliasClause param, string caller);
    internal static void TestAnonymousArrayCreationExpression(int level, IAnonymousArrayCreationExpression param, string caller);
    internal static void TestAnonymousMemberDeclaration(int level, IAnonymousMemberDeclaration param, string caller);
    internal static void TestAnonymousObjectCreationExpression(int level, IAnonymousObjectCreationExpression param, string caller);
    internal static void TestAnonymousObjectInitializer(int level, IAnonymousObjectInitializer param, string caller);
    internal static void TestArgumentList(int level, IArgumentList param, string caller);
    internal static void TestArrayBound(int level, IArrayBound param, string caller);
    internal static void TestArrayCreationExpression(int level, IArrayCreationExpression param, string caller);
    internal static void TestArrayModifier(int level, IArrayModifier param, string caller);
    internal static void TestArrayModifiersList(int level, IArrayModifiersList param, string caller);
    internal static void TestAssignmentStatement(int level, IAssignmentStatement param, string caller);
    internal static void TestAttribute(int level, IAttribute param, string caller);
    internal static void TestAttributeList(int level, IAttributeList param, string caller);
    internal static void TestAttributeListOwner(int level, IAttributeListOwner param, string caller);
    internal static void TestAttributesOwnerDeclaration(int level, IAttributesOwnerDeclaration param, string caller);
    internal static void TestAwaitExpression(int level, IAwaitExpression param, string caller);
    internal static void TestAwaitStatement(int level, IAwaitStatement param, string caller);
    internal static void TestBlock(int level, IBlock param, string caller);
    internal static void TestBlockIfStatement(int level, IBlockIfStatement param, string caller);
    internal static void TestCaseClause(int level, ICaseClause param, string caller);
    internal static void TestCaseStatement(int level, ICaseStatement param, string caller);
    internal static void TestCastExpression(int level, ICastExpression param, string caller);
    internal static void TestCatchStatement(int level, ICatchStatement param, string caller);
    internal static void TestCatchVariableDeclaration(int level, ICatchVariableDeclaration param, string caller);
    internal static void TestCharsetModifier(int level, ICharsetModifier param, string caller);
    internal static void TestClassBaseClause(int level, IClassBaseClause param, string caller);
    internal static void TestClassBody(int level, IClassBody param, string caller);
    internal static void TestClassDeclaration(int level, IClassDeclaration param, string caller);
    internal static void TestClassLikeDeclaration(int level, IClassLikeDeclaration param, string caller);
    internal static void TestCollectionElementInitializer(int level, ICollectionElementInitializer param, string caller);
    internal static void TestCollectionRangeVariableDeclaration(int level, ICollectionRangeVariableDeclaration param, string caller);
    internal static void TestConcatenationExpression(int level, IConcatenationExpression param, string caller);
    internal static void TestConditionalAccessExpression(int level, IConditionalAccessExpression param, string caller);
    internal static void TestConditionalAccessSign(int level, IConditionalAccessSign param, string caller);
    internal static void TestConditionalExpression(int level, IConditionalExpression param, string caller);
    internal static void TestConstPreprocessorDirective(int level, IConstPreprocessorDirective param, string caller);
    internal static void TestConstantDeclaration(int level, IConstantDeclaration param, string caller);
    internal static void TestConstructorDeclaration(int level, IConstructorDeclaration param, string caller);
    internal static void TestContinueStatement(int level, IContinueStatement param, string caller);
    internal static void TestControlReference(int level, IControlReference param, string caller);
    internal static void TestConversionOperatorDeclaration(int level, IConversionOperatorDeclaration param, string caller);
    internal static void TestDeclaredTypeUsage(int level, IDeclaredTypeUsage param, string caller);
    internal static void TestDelegateDeclaration(int level, IDelegateDeclaration param, string caller);
    internal static void TestDictionaryAccessExpression(int level, IDictionaryAccessExpression param, string caller);
    internal static void TestDisableWarningPreprocessorDirective(int level, IDisableWarningPreprocessorDirective param, string caller);
    internal static void TestDistinctQueryOperator(int level, IDistinctQueryOperator param, string caller);
    internal static void TestDoLoopStatement(int level, IDoLoopStatement param, string caller);
    internal static void TestElseIfPreprocessorDirective(int level, IElseIfPreprocessorDirective param, string caller);
    internal static void TestElseIfStatement(int level, IElseIfStatement param, string caller);
    internal static void TestElsePreprocessorDirective(int level, IElsePreprocessorDirective param, string caller);
    internal static void TestElseStatement(int level, IElseStatement param, string caller);
    internal static void TestEmptyArgument(int level, IEmptyArgument param, string caller);
    internal static void TestEnableWarningPreprocessorDirective(int level, IEnableWarningPreprocessorDirective param, string caller);
    internal static void TestEndExternalSourcePreprocessorDirective(int level, IEndExternalSourcePreprocessorDirective param, string caller);
    internal static void TestEndIfPreprocessorDirective(int level, IEndIfPreprocessorDirective param, string caller);
    internal static void TestEndRegionPreprocessorDirective(int level, IEndRegionPreprocessorDirective param, string caller);
    internal static void TestEndStatement(int level, IEndStatement param, string caller);
    internal static void TestEnumDeclaration(int level, IEnumDeclaration param, string caller);
    internal static void TestEnumMemberDeclaration(int level, IEnumMemberDeclaration param, string caller);
    internal static void TestEraseStatement(int level, IEraseStatement param, string caller);
    internal static void TestErrorElement(int level, IErrorElement param, string caller);
    internal static void TestErrorStatement(int level, IErrorStatement param, string caller);
    internal static void TestEventDeclaration(int level, IEventDeclaration param, string caller);
    internal static void TestEventSpecifier(int level, IEventSpecifier param, string caller);
    internal static void TestExitStatement(int level, IExitStatement param, string caller);
    internal static void TestExponentiationExpression(int level, IExponentiationExpression param, string caller);
    internal static void TestExpressionArgument(int level, IExpressionArgument param, string caller);
    internal static void TestExpressionRangeVariableDeclaration(int level, IExpressionRangeVariableDeclaration param, string caller);
    internal static void TestExpressionRangeVariableDeclarationList(int level, IExpressionRangeVariableDeclarationList param, string caller);
    internal static void TestExpressionStatement(int level, IExpressionStatement param, string caller);
    internal static void TestExternalChecksumPreprocessorDirective(int level, IExternalChecksumPreprocessorDirective param, string caller);
    internal static void TestExternalMethodDeclaration(int level, IExternalMethodDeclaration param, string caller);
    internal static void TestExternalSourcePreprocessorDirective(int level, IExternalSourcePreprocessorDirective param, string caller);
    internal static void TestFinallyStatement(int level, IFinallyStatement param, string caller);
    internal static void TestForEachStatement(int level, IForEachStatement param, string caller);
    internal static void TestForStatement(int level, IForStatement param, string caller);
    internal static void TestFromQueryOperator(int level, IFromQueryOperator param, string caller);
    internal static void TestGetTypeExpression(int level, IGetTypeExpression param, string caller);
    internal static void TestGetXmlNamespaceExpression(int level, IGetXmlNamespaceExpression param, string caller);
    internal static void TestGotoStatement(int level, IGotoStatement param, string caller);
    internal static void TestGroupByQueryOperator(int level, IGroupByQueryOperator param, string caller);
    internal static void TestGroupJoinQueryOperator(int level, IGroupJoinQueryOperator param, string caller);
    internal static void TestHandlesClause(int level, IHandlesClause param, string caller);
    internal static void TestIfPreprocessorDirective(int level, IIfPreprocessorDirective param, string caller);
    internal static void TestImplementsClause(int level, IImplementsClause param, string caller);
    internal static void TestImportAliasClause(int level, IImportAliasClause param, string caller);
    internal static void TestImportClause(int level, IImportClause param, string caller);
    internal static void TestImportDirective(int level, IImportDirective param, string caller);
    internal static void TestImportDirectivesSection(int level, IImportDirectivesSection param, string caller);
    internal static void TestImportNamespaceClause(int level, IImportNamespaceClause param, string caller);
    internal static void TestImportXMLNamespaceClause(int level, IImportXMLNamespaceClause param, string caller);
    internal static void TestIndexExpression(int level, IIndexExpression param, string caller);
    internal static void TestInstanceExpression(int level, IInstanceExpression param, string caller);
    internal static void TestIntegerDivisionExpression(int level, IIntegerDivisionExpression param, string caller);
    internal static void TestInterfaceDeclaration(int level, IInterfaceDeclaration param, string caller);
    internal static void TestInterfaceInheritsClause(int level, IInterfaceInheritsClause param, string caller);
    internal static void TestInterfaceMemberSpecifier(int level, IInterfaceMemberSpecifier param, string caller);
    internal static void TestInterpolatedStringExpression(int level, IInterpolatedStringExpression param, string caller);
    internal static void TestInterpolatedStringInsert(int level, IInterpolatedStringInsert param, string caller);
    internal static void TestIntoOfAggregateQueryOperator(int level, IIntoOfAggregateQueryOperator param, string caller);
    internal static void TestInvocationStatement(int level, IInvocationStatement param, string caller);
    internal static void TestIsExpression(int level, IIsExpression param, string caller);
    internal static void TestIsNotExpression(int level, IIsNotExpression param, string caller);
    internal static void TestJoinCollectionRangeVariableDeclaration(int level, IJoinCollectionRangeVariableDeclaration param, string caller);
    internal static void TestJoinCondition(int level, IJoinCondition param, string caller);
    internal static void TestJoinQueryConditionsListFake(int level, IJoinQueryConditionsListFake param, string caller);
    internal static void TestJoinQueryOperator(int level, IJoinQueryOperator param, string caller);
    internal static void TestLabelDeclaration(int level, ILabelDeclaration param, string caller);
    internal static void TestLabelName(int level, ILabelName param, string caller);
    internal static void TestLabelReferencingStatement(int level, ILabelReferencingStatement param, string caller);
    internal static void TestLabelStatement(int level, ILabelStatement param, string caller);
    internal static void TestLambdaExpression(int level, ILambdaExpression param, string caller);
    internal static void TestLambdaFunctionExpression(int level, ILambdaFunctionExpression param, string caller);
    internal static void TestLambdaParameterDeclaration(int level, ILambdaParameterDeclaration param, string caller);
    internal static void TestLambdaSignature(int level, ILambdaSignature param, string caller);
    internal static void TestLambdaSubExpression(int level, ILambdaSubExpression param, string caller);
    internal static void TestLetQueryOperator(int level, ILetQueryOperator param, string caller);
    internal static void TestLibraryClause(int level, ILibraryClause param, string caller);
    internal static void TestLikeExpression(int level, ILikeExpression param, string caller);
    internal static void TestLineIfStatement(int level, ILineIfStatement param, string caller);
    internal static void TestLineIfStatementBody(int level, ILineIfStatementBody param, string caller);
    internal static void TestLocalDeclarationList(int level, ILocalDeclarationList param, string caller);
    internal static void TestLocalDeclarationStatement(int level, ILocalDeclarationStatement param, string caller);
    internal static void TestLocalVariableDeclaration(int level, ILocalVariableDeclaration param, string caller);
    internal static void TestLogicalAndExpression(int level, ILogicalAndExpression param, string caller);
    internal static void TestLogicalNotExpression(int level, ILogicalNotExpression param, string caller);
    internal static void TestLogicalOrExpression(int level, ILogicalOrExpression param, string caller);
    internal static void TestLogicalXorExpression(int level, ILogicalXorExpression param, string caller);
    internal static void TestLoopControlVariableDeclaration(int level, ILoopControlVariableDeclaration param, string caller);
    internal static void TestLoopStatement(int level, ILoopStatement param, string caller);
    internal static void TestMemberAccessExpression(int level, IMemberAccessExpression param, string caller);
    internal static void TestMemberInitializer(int level, IMemberInitializer param, string caller);
    internal static void TestMethodDeclaration(int level, IMethodDeclaration param, string caller);
    internal static void TestMethodDeclarationBase(int level, IMethodDeclarationBase param, string caller);
    internal static void TestMidAssignmentStatement(int level, IMidAssignmentStatement param, string caller);
    internal static void TestModifiersList(int level, IModifiersList param, string caller);
    internal static void TestModifiersListOwner(int level, IModifiersListOwner param, string caller);
    internal static void TestModuleDeclaration(int level, IModuleDeclaration param, string caller);
    internal static void TestModulusExpression(int level, IModulusExpression param, string caller);
    internal static void TestMultipleConstantDeclaration(int level, IMultipleConstantDeclaration param, string caller);
    internal static void TestMultipleVariableDeclaration(int level, IMultipleVariableDeclaration param, string caller);
    internal static void TestMultiplicativeExpression(int level, IMultiplicativeExpression param, string caller);
    internal static void TestNamedArgument(int level, INamedArgument param, string caller);
    internal static void TestNamespaceMemberDeclaration(int level, INamespaceMemberDeclaration param, string caller);
    internal static void TestNamespacePrefixExpression(int level, INamespacePrefixExpression param, string caller);
    internal static void TestNewExpression(int level, INewExpression param, string caller);
    internal static void TestNextClause(int level, INextClause param, string caller);
    internal static void TestObjectCollectionInitializer(int level, IObjectCollectionInitializer param, string caller);
    internal static void TestObjectCreationExpression(int level, IObjectCreationExpression param, string caller);
    internal static void TestObjectCreationInitializer(int level, IObjectCreationInitializer param, string caller);
    internal static void TestOnErrorSpecialLabel(int level, IOnErrorSpecialLabel param, string caller);
    internal static void TestOnErrorStatement(int level, IOnErrorStatement param, string caller);
    internal static void TestOperatorDeclaration(int level, IOperatorDeclaration param, string caller);
    internal static void TestOptionStatement(int level, IOptionStatement param, string caller);
    internal static void TestOptionStatementsSection(int level, IOptionStatementsSection param, string caller);
    internal static void TestOrderByQueryOperator(int level, IOrderByQueryOperator param, string caller);
    internal static void TestOrderExpression(int level, IOrderExpression param, string caller);
    internal static void TestParenthesizedExpression(int level, IParenthesizedExpression param, string caller);
    internal static void TestPartitionQueryOperator(int level, IPartitionQueryOperator param, string caller);
    internal static void TestPositionalArgument(int level, IPositionalArgument param, string caller);
    internal static void TestPreprocessorDirective(int level, IPreprocessorDirective param, string caller);
    internal static void TestPrimaryExpression(int level, IPrimaryExpression param, string caller);
    internal static void TestPropertyDeclaration(int level, IPropertyDeclaration param, string caller);
    internal static void TestPropertyInitializer(int level, IPropertyInitializer param, string caller);
    internal static void TestQualifiedNamespaceName(int level, IQualifiedNamespaceName param, string caller);
    internal static void TestQueryAggregatedParameterPlatform(int level, IQueryAggregatedParameterPlatform param, string caller);
    internal static void TestQueryCollectionRangeVariableDeclaration(int level, IQueryCollectionRangeVariableDeclaration param, string caller);
    internal static void TestQueryCollectionRangeVariableDeclarationList(int level, IQueryCollectionRangeVariableDeclarationList param, string caller);
    internal static void TestQueryConditionsList(int level, IQueryConditionsList param, string caller);
    internal static void TestQueryExpression(int level, IQueryExpression param, string caller);
    internal static void TestQueryOperator(int level, IQueryOperator param, string caller);
    internal static void TestQueryParameter(int level, IQueryParameter param, string caller);
    internal static void TestQueryParameterPlatform(int level, IQueryParameterPlatform param, string caller);
    internal static void TestRaiseEventStatement(int level, IRaiseEventStatement param, string caller);
    internal static void TestRedimClause(int level, IRedimClause param, string caller);
    internal static void TestRedimStatement(int level, IRedimStatement param, string caller);
    internal static void TestReferenceExpression(int level, IReferenceExpression param, string caller);
    internal static void TestReferenceName(int level, IReferenceName param, string caller);
    internal static void TestRegionPreprocessorDirective(int level, IRegionPreprocessorDirective param, string caller);
    internal static void TestRegularParameterDeclaration(int level, IRegularParameterDeclaration param, string caller);
    internal static void TestRegularParameterList(int level, IRegularParameterList param, string caller);
    internal static void TestRelationalExpression(int level, IRelationalExpression param, string caller);
    internal static void TestRemoveHandlerStatement(int level, IRemoveHandlerStatement param, string caller);
    internal static void TestResumeStatement(int level, IResumeStatement param, string caller);
    internal static void TestReturnAttributeList(int level, IReturnAttributeList param, string caller);
    internal static void TestReturnStatement(int level, IReturnStatement param, string caller);
    internal static void TestSelectQueryOperator(int level, ISelectQueryOperator param, string caller);
    internal static void TestSelectStatement(int level, ISelectStatement param, string caller);
    internal static void TestShiftExpression(int level, IShiftExpression param, string caller);
    internal static void TestSignOperatorDeclaration(int level, ISignOperatorDeclaration param, string caller);
    internal static void TestStopStatement(int level, IStopStatement param, string caller);
    internal static void TestStructureDeclaration(int level, IStructureDeclaration param, string caller);
    internal static void TestSyncLockStatement(int level, ISyncLockStatement param, string caller);
    internal static void TestThrowStatement(int level, IThrowStatement param, string caller);
    internal static void TestTryStatement(int level, ITryStatement param, string caller);
    internal static void TestTupleComponent(int level, ITupleComponent param, string caller);
    internal static void TestTupleDeclaredTypeUsage(int level, ITupleDeclaredTypeUsage param, string caller);
    internal static void TestTupleExpression(int level, ITupleExpression param, string caller);
    internal static void TestTupleTypeComponent(int level, ITupleTypeComponent param, string caller);
    internal static void TestTupleTypeUsage(int level, ITupleTypeUsage param, string caller);
    internal static void TestTypeArgumentList(int level, ITypeArgumentList param, string caller);
    internal static void TestTypeImplementsClause(int level, ITypeImplementsClause param, string caller);
    internal static void TestTypeMemberOwnerDeclaration(int level, ITypeMemberOwnerDeclaration param, string caller);
    internal static void TestTypeOfIsExpression(int level, ITypeOfIsExpression param, string caller);
    internal static void TestTypeParameterConstraint(int level, ITypeParameterConstraint param, string caller);
    internal static void TestTypeParameterConstraintList(int level, ITypeParameterConstraintList param, string caller);
    internal static void TestTypeParameterDeclaration(int level, ITypeParameterDeclaration param, string caller);
    internal static void TestTypeParameterOfMethodDeclaration(int level, ITypeParameterOfMethodDeclaration param, string caller);
    internal static void TestTypeParameterOfMethodList(int level, ITypeParameterOfMethodList param, string caller);
    internal static void TestTypeParameterOfTypeDeclaration(int level, ITypeParameterOfTypeDeclaration param, string caller);
    internal static void TestTypeParameterOfTypeList(int level, ITypeParameterOfTypeList param, string caller);
    internal static void TestTypeUsage(int level, ITypeUsage param, string caller);
    internal static void TestUnaryNegationExpression(int level, IUnaryNegationExpression param, string caller);
    internal static void TestUnknownPreprocessorDirective(int level, IUnknownPreprocessorDirective param, string caller);
    internal static void TestUserDeclaredTypeUsage(int level, IUserDeclaredTypeUsage param, string caller);
    internal static void TestUserTypeUsage(int level, IUserTypeUsage param, string caller);
    internal static void TestUsingStatement(int level, IUsingStatement param, string caller);
    internal static void TestUsingVariableDeclaration(int level, IUsingVariableDeclaration param, string caller);
    internal static void TestVBArgument(int level, IVBArgument param, string caller);
    internal static void TestVBArgumentsOwner(int level, IVBArgumentsOwner param, string caller);
    internal static void TestVBBinaryExpression(int level, IVBBinaryExpression param, string caller);
    internal static void TestVBDeclaration(int level, IVBDeclaration param, string caller);
    internal static void TestVBExpression(int level, IVBExpression param, string caller);
    internal static void TestVBFile(int level, IVBFile param, string caller);
    internal static void TestVBFunctionDeclaration(int level, IVBFunctionDeclaration param, string caller);
    internal static void TestVBIdentifier(int level, IVBIdentifier param, string caller);
    internal static void TestVBLiteralExpression(int level, IVBLiteralExpression param, string caller);
    internal static void TestVBLocalVariableDeclaration(int level, IVBLocalVariableDeclaration param, string caller);
    internal static void TestVBModifiersOwnerDeclaration(int level, IVBModifiersOwnerDeclaration param, string caller);
    internal static void TestVBNamespaceDeclaration(int level, IVBNamespaceDeclaration param, string caller);
    internal static void TestVBParameterDeclaration(int level, IVBParameterDeclaration param, string caller);
    internal static void TestVBParameterDeclarationList(int level, IVBParameterDeclarationList param, string caller);
    internal static void TestVBParametersOwnerDeclaration(int level, IVBParametersOwnerDeclaration param, string caller);
    internal static void TestVBStatement(int level, IVBStatement param, string caller);
    internal static void TestVBTypeAndNamespaceHolderDeclaration(int level, IVBTypeAndNamespaceHolderDeclaration param, string caller);
    internal static void TestVBTypeDeclaration(int level, IVBTypeDeclaration param, string caller);
    internal static void TestVBTypeMemberDeclaration(int level, IVBTypeMemberDeclaration param, string caller);
    internal static void TestVBUnaryExpression(int level, IVBUnaryExpression param, string caller);
    internal static void TestVBXmlAttribute(int level, IVBXmlAttribute param, string caller);
    internal static void TestVBXmlCDataSection(int level, IVBXmlCDataSection param, string caller);
    internal static void TestVBXmlComment(int level, IVBXmlComment param, string caller);
    internal static void TestVBXmlDocument(int level, IVBXmlDocument param, string caller);
    internal static void TestVBXmlElement(int level, IVBXmlElement param, string caller);
    internal static void TestVBXmlElementFooter(int level, IVBXmlElementFooter param, string caller);
    internal static void TestVBXmlElementHeader(int level, IVBXmlElementHeader param, string caller);
    internal static void TestVBXmlEmbeddedExpression(int level, IVBXmlEmbeddedExpression param, string caller);
    internal static void TestVBXmlLiteralExpression(int level, IVBXmlLiteralExpression param, string caller);
    internal static void TestVBXmlMemberAccessExpression(int level, IVBXmlMemberAccessExpression param, string caller);
    internal static void TestVBXmlMisc(int level, IVBXmlMisc param, string caller);
    internal static void TestVBXmlProcessingInstruction(int level, IVBXmlProcessingInstruction param, string caller);
    internal static void TestVariableDeclaration(int level, IVariableDeclaration param, string caller);
    internal static void TestVariableDeclarationList(int level, IVariableDeclarationList param, string caller);
    internal static void TestWarningPreprocessorDirective(int level, IWarningPreprocessorDirective param, string caller);
    internal static void TestWhereQueryOperator(int level, IWhereQueryOperator param, string caller);
    internal static void TestWhileStatement(int level, IWhileStatement param, string caller);
    internal static void TestWhileUntilCondition(int level, IWhileUntilCondition param, string caller);
    internal static void TestWithStatement(int level, IWithStatement param, string caller);
    internal static void TestYieldStatement(int level, IYieldStatement param, string caller);
    public static void TestVBTreeNode(int level, ITreeNode param, string caller);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.QualifiedNamespaceName : VBCompositeElement {
    public static short QUALIFIER;
    public static short VB_DOT;
    public static short VB_NAME;
    private MyReference modreq(System.Runtime.CompilerServices.IsVolatile) myReference;
    public NodeType NodeType { get; }
    public ITokenNode Dot { get; }
    public IVBIdentifier Name { get; }
    public IQualifiedNamespaceName Qualifier { get; }
    public IReference Reference { get; }
    public bool Resolved { get; }
    public string DeclaredName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Dot();
    public virtual IVBIdentifier get_Name();
    public virtual IQualifiedNamespaceName get_Qualifier();
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual IQualifiedNamespaceName SetQualifier(IQualifiedNamespaceName param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    public sealed virtual IReference get_Reference();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual IQualifiedNamespaceName ReplaceBy(IQualifiedNamespaceName node);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.QueryAggregatedParameterPlatform : VBCompositeElement {
    public static short IDENTIFIER;
    public static short VB_LPARENTH;
    public static short PLATFORM;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public IVBIdentifier Ident { get; }
    public ITokenNode LPar { get; }
    public IQueryParameterPlatform Platform { get; }
    public ITokenNode RPar { get; }
    public bool IsGroup { get; }
    public string MethodName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBIdentifier get_Ident();
    public virtual ITokenNode get_LPar();
    public virtual IQueryParameterPlatform get_Platform();
    public virtual ITokenNode get_RPar();
    public virtual IVBIdentifier SetIdent(IVBIdentifier param);
    public virtual IQueryParameterPlatform SetPlatform(IQueryParameterPlatform param);
    public virtual string ToString();
    public sealed virtual bool get_IsGroup();
    public sealed virtual string get_MethodName();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.QueryCollectionRangeVariableDeclaration : CollectionRangeVariableDeclarationBase {
    public static short VB_NAME;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short IN_KEYWORD;
    public static short VB_INITIALIZER;
    private FromReferenceImpl mySelectManyReference;
    private CastingInnerSelectReferenceImpl myInnerSelectReference;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode InKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    private IQueryRangeVariable JetBrains.ReSharper.Psi.VB.Tree.IQueryCollectionRangeVariableDeclaration.DeclaredElement { get; }
    protected ITypeUsage TypeUsage2 { get; }
    protected IVBExpression Expression2 { get; }
    protected IVBIdentifier Name2 { get; }
    protected ITokenNode AsKeyword2 { get; }
    protected TreeTextRange ReferencesTextRange { get; }
    public IQueryReference SelectManyReference { get; }
    public IQueryExpression QueryExpression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual IQueryParameterPlatform get_Expression();
    public virtual ITokenNode get_InKeyword();
    public virtual IVBIdentifier get_Name();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    private sealed virtual override IQueryRangeVariable JetBrains.ReSharper.Psi.VB.Tree.IQueryCollectionRangeVariableDeclaration.get_DeclaredElement();
    protected virtual ITypeUsage get_TypeUsage2();
    protected virtual IVBExpression get_Expression2();
    protected virtual IVBIdentifier get_Name2();
    protected virtual ITokenNode get_AsKeyword2();
    protected virtual TreeTextRange get_ReferencesTextRange();
    public virtual bool HasSelectReference(IResolveContext resolveContext);
    public bool HasInnerSelectReference(IResolveContext resolveContext);
    public virtual IExpressionType GetCastedCollectionType(IResolveContext resolveContext);
    public sealed virtual IQueryReference get_SelectManyReference();
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryExpression get_QueryExpression();
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.QueryCollectionRangeVariableDeclarationList : VBCompositeElement {
    public static short DECLARATION;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> DeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> get_Declarations();
    public virtual TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> get_DeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.QueryConditionsList : VBCompositeElement {
    public static short JOIN_CONDITION;
    public static short AND_KEYWORD;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> AndKeywords { get; }
    public TreeNodeEnumerable`1<ITokenNode> AndKeywordsEnumerable { get; }
    public TreeNodeCollection`1<IJoinCondition> joinCondition { get; }
    public TreeNodeEnumerable`1<IJoinCondition> joinConditionEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_AndKeywords();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_AndKeywordsEnumerable();
    public virtual TreeNodeCollection`1<IJoinCondition> get_joinCondition();
    public virtual TreeNodeEnumerable`1<IJoinCondition> get_joinConditionEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.QueryExpression : VBExpressionBase {
    public static short FIRST_QUERY_OPERATOR;
    public static short QUERY_OPERATOR;
    private QueryVariablesCache myVariablesCache;
    public NodeType NodeType { get; }
    public IQueryOperator FirstQueryOperator { get; }
    public TreeNodeCollection`1<IQueryOperator> QueryOperators { get; }
    public TreeNodeEnumerable`1<IQueryOperator> QueryOperatorsEnumerable { get; }
    private IQueryExpression JetBrains.ReSharper.Psi.VB.Tree.IQueryCallsChainOwner.QueryExpression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryOperator get_FirstQueryOperator();
    public virtual TreeNodeCollection`1<IQueryOperator> get_QueryOperators();
    public virtual TreeNodeEnumerable`1<IQueryOperator> get_QueryOperatorsEnumerable();
    public virtual IQueryOperator SetFirstQueryOperator(IQueryOperator param);
    public virtual string ToString();
    internal QueryVariablesCache GetVariablesCache();
    protected virtual void ClearCachedData();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    private sealed virtual override IQueryExpression JetBrains.ReSharper.Psi.VB.Tree.IQueryCallsChainOwner.get_QueryExpression();
    [CompilerGeneratedAttribute]
private QueryChainTypeBase <CalculateExpressionType>b__20_0(IAggregatedRangeVariableDeclaration elements);
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.QueryOperatorBase : VBCompositeElement {
    public IQueryExpression QueryExpression { get; }
    public ITokenNode FirstKeyword { get; }
    public sealed virtual IQueryExpression get_QueryExpression();
    public abstract virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.QueryParameter : VBCompositeElement {
    public static short VALUE;
    public NodeType NodeType { get; }
    public IVBExpression Value { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Value();
    public virtual IVBExpression SetValue(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.QueryParameterPlatform : VBCompositeElement {
    public static short VALUE;
    public NodeType NodeType { get; }
    public IVBExpression Value { get; }
    public int LevelDelta { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Value();
    public virtual IVBExpression SetValue(IVBExpression param);
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.RaiseEventStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXPR;
    public NodeType NodeType { get; }
    public IPrimaryExpression Expression { get; }
    public ITokenNode RaiseEventKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPrimaryExpression get_Expression();
    public virtual ITokenNode get_RaiseEventKeyword();
    public virtual IPrimaryExpression SetExpression(IPrimaryExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.RedimClause : VBCompositeElement {
    public static short EXPR;
    public static short SIZE;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public IArrayModifier SizeModifier { get; }
    public TreeNodeCollection`1<IArrayBound> ArrayBounds { get; }
    public TreeNodeEnumerable`1<IArrayBound> ArrayBoundsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual IArrayModifier get_SizeModifier();
    public virtual TreeNodeCollection`1<IArrayBound> get_ArrayBounds();
    public virtual TreeNodeEnumerable`1<IArrayBound> get_ArrayBoundsEnumerable();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual IArrayModifier SetSizeModifier(IArrayModifier param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.RedimStatement : StatementBase {
    public static short REDIM_KEYWORD;
    public static short PRESERVE_KEYWORD;
    public static short REDIM_CLAUSE;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode PreserveKeyword { get; }
    public TreeNodeCollection`1<IRedimClause> RedimClauses { get; }
    public TreeNodeEnumerable`1<IRedimClause> RedimClausesEnumerable { get; }
    public ITokenNode RedimKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_PreserveKeyword();
    public virtual TreeNodeCollection`1<IRedimClause> get_RedimClauses();
    public virtual TreeNodeEnumerable`1<IRedimClause> get_RedimClausesEnumerable();
    public virtual ITokenNode get_RedimKeyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ReferenceExpression : ReferenceExpressionStub {
    private ReferenceExpressionReference modreq(System.Runtime.CompilerServices.IsVolatile) myReference;
    public IVBExpression ConditionalQualifier { get; }
    public IVBExpression QualifierExpression { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    public IReferenceExpressionReference Reference { get; }
    public int TypeArgumentsNumber { get; }
    public IList`1<IType> TypeArguments { get; }
    public bool HasConditionalAccessSign { get; }
    protected virtual void PreInit();
    private ConstantValue CalculatePreprocessorConstantValue(IPreprocessorDirective preprocessor);
    public virtual IVBExpression get_ConditionalQualifier();
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    [NotNullAttribute]
public IExpressionType CalculateOriginalExpressionType(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual IVBExpression get_QualifierExpression();
    public virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    public virtual IVBArgumentInfo get_ExtensionQualifier();
    public virtual IReferenceExpressionReference get_Reference();
    public virtual int get_TypeArgumentsNumber();
    public virtual void SetQualifierExpression(QualifierUsage qualifierUsage);
    public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public virtual IList`1<IType> get_TypeArguments();
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public virtual void SetTypeArguments(ICollection`1<IType> typeArguments);
    public virtual bool get_HasConditionalAccessSign();
    public virtual void SetConditionalAccessSign(bool value);
    public virtual IExpressionType UnliftedExpressionType();
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
}
[DebuggerDisplayAttribute("ReferenceExpression ({GetName()})")]
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ReferenceExpressionReference : ManagedTwoPhaseReferenceImplBase`1<ReferenceExpression> {
    private static HashSet`1<string> ourObjectMemeberNames;
    private static IClrTypeName WinFormsClassName;
    private static string DefaultWinFormCollector;
    private static string VALUE;
    private IQualifiableReference NonManagedReference { get; }
    public bool IsQualified { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    private IVBInvocationInfo JetBrains.ReSharper.Psi.VB.IVBInvocationReference.Invocation { get; }
    public ReferenceExpressionReference(ReferenceExpression owner);
    private static ReferenceExpressionReference();
    private IQualifiableReference get_NonManagedReference();
    public bool IsConstructorReference();
    private bool IsParameterOfNameof();
    public bool IsNameOfOperator();
    public sealed virtual ReferenceExpressionKind GetKind();
    public sealed virtual IReferenceExpression GetTreeNode();
    public virtual string GetName();
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    private IType GetQualifierType(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo PreResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    private ResolveResultWithInfo ResolveConstructor(IResolveContext resolveContext, IAccessContext accessContext, ISymbolTable symbolTable);
    private ResolveResultWithInfo ResolvePredefinedType();
    private bool IsMultipleTargetReference(IResolveContext resolveContext);
    private List`1<ISymbolFilter> GetBasicFilters(IResolveContext resolveContext, IAccessContext accessContext);
    private ResolveResultWithInfo ResolveEvent(IResolveContext resolveContext, IAccessContext accessContext, ISymbolTable symbolTable);
    private ResolveResultWithInfo DoInvocation(ResolveResultWithInfo resolveResult);
    private ResolveResultWithInfo ResolveAddressOf(IResolveContext resolveContext, IAccessContext accessContext, ISymbolTable symbolTable);
    private bool CheckMethodWithoutParenthesis(IDeclaredElement declaredElement, bool isExtensionMethod);
    private ResolveResultWithInfo ResolveIndex(IResolveContext resolveContext, IAccessContext accessContext, ISymbolTable symbolTable);
    private ResolveResultWithInfo TryResolveToValueProperty(string name, IResolveContext resolveContext, ResolveResultWithInfo resolve);
    private static FilterType DetermineKind(ISymbolInfo info);
    private static FilterType GetFilterTypes(ICollection`1<ISymbolInfo> infos);
    private bool CanResolveToReturnValue(IDeclaredElement& returnValueElement);
    private ResolveResultWithInfo ResolveSimple(IResolveContext resolveContext, IAccessContext accessContext, ISymbolTable symbolTable);
    [CanBeNullAttribute]
private ResolveResultWithInfo TryCreatePartialTypeOrMemberResolveResult(ResolveResultWithInfo oldResult, IResolveContext resolveContext, Func`1<ResolveResultWithInfo> resolveAsReferenceName);
    [CanBeNullAttribute]
private ResolveResultWithInfo TryCreatePartialTypeOrInstanceObjectResolveResult(ResolveResultWithInfo resolve, ISymbolTable table, IResolveContext resolveContext);
    private ISymbolFilter GetCoClassEventFilter(IResolveContext resolveContext);
    private ResolveResultWithInfo ResolveNotInvocables(ISymbolTable symbolTable, string name, IAccessContext accessContext);
    private DeclaredElementInstance`1<IDelegate> GetExpectedDelegate(IResolveContext resolveContext);
    protected virtual ResolveResultWithInfo RefineResolve(IResolveContext resolveContext, ResolveResultWithInfo preResolve);
    private ResolveResultWithInfo DoRefineResolve(IResolveContext resolveContext, ResolveResultWithInfo preResolve);
    private ResolveResultWithInfo CheckResolveResult(IResolveContext resolveContext, ResolveResultWithInfo resolveResult);
    private ResolveErrorType CheckIndex(IResolveContext resolveContext, IAccessContext accessContext, IResolveResult resolveResult);
    private bool HasProblemWithExtensionArgumentConversion(IResolveContext resolveContext, IResolveResult resolveResult);
    private ResolveErrorType CheckEvent(IResolveContext resolveContext, IAccessContext accessContext, IResolveResult resolveResult);
    private ResolveErrorType CheckAddressOf(IResolveContext resolveContext, IAccessContext accessContext, IResolveResult resolveResult);
    private ResolveErrorType CheckSimple(IResolveContext resolveContext, IAccessContext accessContext, IResolveResult resolveResult);
    private bool HasProblemWithStatic(IResolveContext resolveContext, IAccessContext accessContext, IResolveResult resolveResult);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual bool get_IsQualified();
    public virtual IQualifier GetQualifier(IResolveContext resolveContext);
    public virtual IVBArgumentInfo get_ExtensionQualifier();
    public virtual TreeTextRange GetTreeTextRange();
    public sealed virtual Refers RefersToDeclaredElement(IDeclaredElement declaredElement);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual ISymbolTable GetCompletionSymbolTable();
    private ISymbolTable PredefinedTypeCompletionTable();
    private ISymbolTable EventCompletionTable();
    private ISymbolTable AddressOfCompletionTable();
    private ISymbolTable IndexCompletionTable();
    private ISymbolTable SimpleCompletionTable();
    private List`1<ISymbolFilter> GetBasicCompletionFilters();
    private ISymbolTable XLinqValueProvider(ISymbolTable completionTable);
    public virtual string Dump();
    public sealed virtual string InvocationName();
    private sealed virtual override IVBInvocationInfo JetBrains.ReSharper.Psi.VB.IVBInvocationReference.get_Invocation();
    public virtual ResolveResultWithInfo ResolveAsUnqualified(ISymbolTable symbolTable);
    private IResolveContext GetNewResolveContext();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.ReferenceExpressionStub : VBExpressionBase {
    public static short VB_QUALIFIER;
    public static short VB_OP_SIGN;
    public static short VB_DOT;
    public static short VB_REFERENCE;
    public static short VB_TYPE_ARGUMENT_LIST;
    private ITypeArgumentList myCachedTypeArgumentList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedTypeArgumentListValid;
    public NodeType NodeType { get; }
    public IPrimaryExpression BaseExpression { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode Dot { get; }
    public IVBIdentifier NameIdentifier { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    protected ITypeArgumentList _TypeArgumentList { get; }
    public IVBExpression QualifierExpression { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    public IReferenceExpressionReference Reference { get; }
    public int TypeArgumentsNumber { get; }
    public IList`1<IType> TypeArguments { get; }
    public IVBTreeNode Node { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    private IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.Reference { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public IVBExpression ConditionalQualifier { get; }
    public bool HasConditionalAccessSign { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IPrimaryExpression get_BaseExpression();
    public virtual IConditionalAccessSign get_ConditionalAccessSign();
    public virtual ITokenNode get_Dot();
    public virtual IVBIdentifier get_NameIdentifier();
    public sealed virtual ITypeArgumentList get_TypeArgumentList();
    protected virtual ITypeArgumentList get__TypeArgumentList();
    public virtual IPrimaryExpression SetBaseExpression(IPrimaryExpression param);
    public virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public virtual IVBIdentifier SetNameIdentifier(IVBIdentifier param);
    public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public abstract virtual IVBExpression get_QualifierExpression();
    public sealed virtual IPsiModule get_PsiModule();
    public abstract virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    public abstract virtual IVBArgumentInfo get_ExtensionQualifier();
    public abstract virtual IReferenceExpressionReference get_Reference();
    public abstract virtual void SetTypeArguments(ICollection`1<IType> typeArguments);
    public abstract virtual int get_TypeArgumentsNumber();
    public abstract virtual IList`1<IType> get_TypeArguments();
    public abstract virtual void SetQualifierExpression(QualifierUsage qualifierUsage);
    public sealed virtual IVBTreeNode get_Node();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    private sealed virtual override IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_Reference();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public abstract virtual IVBExpression get_ConditionalQualifier();
    public abstract virtual bool get_HasConditionalAccessSign();
    public abstract virtual void SetConditionalAccessSign(bool value);
    public abstract virtual IExpressionType UnliftedExpressionType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ReferenceName : ReferenceNameStub {
    public virtual IVBIdentifier SetNameIdentifier(IVBIdentifier param);
    public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public virtual IReferenceName SetQualifier(IReferenceName newQuilifier);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.ReferenceNameStub : VBCompositeElement {
    public static short VB_QUALIFIER;
    public static short VB_DOT;
    public static short VB_REFERENCE;
    public static short VB_TYPE_ARGUMENT_LIST;
    private ReferenceNameReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode Dot { get; }
    public IVBIdentifier NameIdentifier { get; }
    public IReferenceName QualifierInternal { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    public IAttribute ContainingAttribute { get; }
    public IObjectCreationExpression ContainingCreationExpression { get; }
    public IReferenceName Qualifier { get; }
    public string ShortName { get; }
    public string QualifiedName { get; }
    public IReferenceNameReference Reference { get; }
    public bool IsGlobalNamespacePrefix { get; }
    public int TypeArgumentsNumber { get; }
    public IList`1<IType> TypeArguments { get; }
    [CanBeNullAttribute]
private TokenNodeType SpecialToken { get; }
    public bool Resolved { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Dot();
    public virtual IVBIdentifier get_NameIdentifier();
    public virtual IReferenceName get_QualifierInternal();
    public virtual ITypeArgumentList get_TypeArgumentList();
    public virtual IAttribute get_ContainingAttribute();
    public virtual IObjectCreationExpression get_ContainingCreationExpression();
    public virtual IReferenceName get_Qualifier();
    public virtual IVBIdentifier SetNameIdentifier(IVBIdentifier param);
    public virtual IReferenceName SetQualifier(IReferenceName param);
    public virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual string get_ShortName();
    private string GetName();
    public sealed virtual string get_QualifiedName();
    public sealed virtual IReferenceNameReference get_Reference();
    public virtual bool get_IsGlobalNamespacePrefix();
    public virtual int get_TypeArgumentsNumber();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private TokenNodeType get_SpecialToken();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    [CanBeNullAttribute]
private ISymbolTable MultipleNamespaceReferenceSymbolTable(IResolveResult result, SymbolTableMode mode);
    private bool IsInheritsListReferenceSymbolTableCase(IResolveResult result);
    [CanBeNullAttribute]
private ISymbolTable InheritsListReferenceSymbolTable(IResolveResult result);
    [CanBeNullAttribute]
private ISymbolTable ImportAliasReferenceSymbolTable(IResolveResult result);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IReferenceName ReplaceBy(IReferenceName name);
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.RegionPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public static short REGION;
    public static short REGION_NAME;
    public NodeType NodeType { get; }
    public ITokenNode RegionName { get; }
    public ITokenNode RegionWord { get; }
    public ITokenNode Sharp { get; }
    public string RegionNameText { get; }
    public IEndRegionPreprocessorDirective EndRegion { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_RegionName();
    public virtual ITokenNode get_RegionWord();
    public virtual ITokenNode get_Sharp();
    public virtual string ToString();
    public sealed virtual string get_RegionNameText();
    public sealed virtual IEndRegionPreprocessorDirective get_EndRegion();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.RegularParameterDeclaration : RegularParameterDeclarationStub {
    public virtual IVBExpression SetDefaultInitializer(IVBExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.RegularParameterDeclarationStub : VBDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIER;
    public static short VB_NAME;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    private IDeclaredElement modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDeclaredElement;
    public NodeType NodeType { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public IVBExpression DefaultInitializer { get; }
    public ITokenNode EqSign { get; }
    public TreeNodeCollection`1<ITokenNode> Modifier { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifierEnumerable { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode NullableMark { get; }
    public ITypeUsage TypeUsage { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IDeclaredElement DeclaredElement { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.CachedDeclaredElement { get; private set; }
    private IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.DeclaredElement { get; }
    public string DeclaredName { get; }
    public IType Type { get; }
    public bool IsParameterArray { get; }
    public bool IsOptional { get; }
    public ParameterKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual IVBExpression get_DefaultInitializer();
    public virtual ITokenNode get_EqSign();
    public virtual TreeNodeCollection`1<ITokenNode> get_Modifier();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_ModifierEnumerable();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_NullableMark();
    public virtual ITypeUsage get_TypeUsage();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IVBExpression SetDefaultInitializer(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.get_CachedDeclaredElement();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.set_CachedDeclaredElement(IDeclaredElement value);
    private sealed virtual override IParameter JetBrains.ReSharper.Psi.Tree.IParameterDeclaration.get_DeclaredElement();
    public virtual string get_DeclaredName();
    public virtual TreeTextRange GetNameRange();
    public virtual void SetName(string name);
    public sealed virtual IType get_Type();
    public sealed virtual void SetType(IType type);
    public sealed virtual void SetParamArray(bool isParamArray);
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsOptional();
    public sealed virtual ParameterKind get_Kind();
    private bool IsParamterOfExternalMethod();
    public sealed virtual void SetKind(ParameterKind kind);
    public sealed virtual IRegularParameterDeclaration ReplaceBy(IRegularParameterDeclaration declaration);
    public sealed virtual IAttribute AddAttribute(IAttribute attribute);
    public sealed virtual void RemoveAttribute(IAttribute attribute);
    public virtual bool IsSynthetic();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.RegularParameterList : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short PARAMETER_DECL;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> RegularParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> RegularParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVBParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IVBParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_RegularParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_RegularParameterDeclarationsEnumerable();
    public virtual string ToString();
    public sealed virtual TreeNodeCollection`1<IVBParameterDeclaration> get_ParameterDeclarations();
    public sealed virtual TreeNodeEnumerable`1<IVBParameterDeclaration> get_ParameterDeclarationsEnumerable();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.RelationalExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.RemoveHandlerStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EVENT_EXPR;
    public static short VB_COMMA;
    public static short HANDLER_EXPR;
    public NodeType NodeType { get; }
    public ITokenNode Comma { get; }
    public IVBExpression EventExpression { get; }
    public IVBExpression HandlerExpression { get; }
    public ITokenNode RemoveHandlerKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Comma();
    public virtual IVBExpression get_EventExpression();
    public virtual IVBExpression get_HandlerExpression();
    public virtual ITokenNode get_RemoveHandlerKeyword();
    public virtual IVBExpression SetEventExpression(IVBExpression param);
    public virtual IVBExpression SetHandlerExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ResumeStatement : LabelReferencingStatementBase {
    public static short RESUME_KEYWORD;
    public static short NEXT_KEYWORD;
    public static short LABEL_NAME;
    public NodeType NodeType { get; }
    public ILabelName LabelName { get; }
    public ITokenNode NextKeyword { get; }
    public ITokenNode ResumeKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ILabelName get_LabelName();
    public virtual ITokenNode get_NextKeyword();
    public virtual ITokenNode get_ResumeKeyword();
    public virtual ILabelName SetLabelName(ILabelName param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ReturnAttributeList : VBCompositeElement {
    public static short ATTRIBUTE_LIST;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ReturnStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXPR;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode ReturnKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_ReturnKeyword();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.SelectQueryOperator : QueryOperatorBase {
    public static short SELECT_KEYWORD;
    public static short DECLARATION_LIST;
    private SelectReferenceImpl myReference;
    public NodeType NodeType { get; }
    public IExpressionRangeVariableDeclarationList DeclarationList { get; }
    public ITokenNode SelectKeyword { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public IQueryReference SelectReference { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IExpressionRangeVariableDeclarationList get_DeclarationList();
    public virtual ITokenNode get_SelectKeyword();
    public virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IExpressionRangeVariableDeclarationList SetDeclarationList(IExpressionRangeVariableDeclarationList param);
    public virtual string ToString();
    protected virtual void PreInit();
    public sealed virtual IQueryReference get_SelectReference();
    public sealed virtual bool HasReference();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    internal QueryChainTypeBase TransitChainTypeImpl();
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public virtual ITokenNode get_FirstKeyword();
    [CompilerGeneratedAttribute]
private QueryChainTypeBase <TransitChainTypeImpl>b__26_0(IExpressionRangeVariableDeclaration elements);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.SelectStatement : StatementBase {
    public static short SELECT_KEYWORD;
    public static short CASE_KEYWORD;
    public static short EXPRESSION;
    public static short VB_STATEMENT_TERMINATOR;
    public static short CASE_STMT;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public ITokenNode CaseKeyword { get; }
    public TreeNodeCollection`1<ICaseStatement> CaseStatements { get; }
    public TreeNodeEnumerable`1<ICaseStatement> CaseStatementsEnumerable { get; }
    public ITokenNode EndSelect { get; }
    public IVBExpression Expression { get; }
    public ITokenNode SelectKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_CaseKeyword();
    public virtual TreeNodeCollection`1<ICaseStatement> get_CaseStatements();
    public virtual TreeNodeEnumerable`1<ICaseStatement> get_CaseStatementsEnumerable();
    public virtual ITokenNode get_EndSelect();
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_SelectKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
    public sealed virtual ICaseStatement AddCaseStatement(ICaseStatement param, ICaseStatement anchor, bool before);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ShiftExpression : VBBinaryExpressionBase {
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public NodeType NodeType { get; }
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_LeftExpr();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression get_RightExpr();
    public virtual IVBExpression SetLeftExpr(IVBExpression param);
    public virtual IVBExpression SetRightExpr(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.SignOperatorDeclaration : OperatorDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short OPERATOR_KEYWORD;
    public static short OP_SIGN;
    public static short VB_PARAMETERS_LIST;
    public static short AS_KEYWORD;
    public static short VB_RETURN_ATTRIBUTE_LIST;
    public static short RETURN_TYPE;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_BODY;
    public static short END_DECLARATION;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public IAttributeList AttributeList { get; }
    public IBlock Block { get; }
    public ITokenNode EndDeclaration { get; }
    public IModifiersList ModifiersList { get; }
    public ITokenNode OpSign { get; }
    public ITokenNode OperatorKeyword { get; }
    public IRegularParameterList ParameterList { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage ReturnType { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.DeclaredElement { get; }
    public string DeclaredName { get; }
    private IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.DeclaredParametersOwner { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.FunctionElement { get; }
    public ITokenNode StartDeclaration { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual IAttributeList get_AttributeList();
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndDeclaration();
    public virtual IModifiersList get_ModifiersList();
    public virtual ITokenNode get_OpSign();
    public virtual ITokenNode get_OperatorKeyword();
    public virtual IRegularParameterList get_ParameterList();
    public virtual IReturnAttributeList get_ReturnAttributeList();
    public virtual ITypeUsage get_ReturnType();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IBlock SetBlock(IBlock param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public virtual ITypeUsage SetReturnType(ITypeUsage param);
    public virtual string ToString();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration.get_DeclaredElement();
    public virtual string get_DeclaredName();
    protected internal virtual string GetShortNameOfDeclaredElement();
    private sealed virtual override IParametersOwner JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_DeclaredParametersOwner();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IFunction JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration.get_FunctionElement();
    public sealed virtual ITokenNode get_StartDeclaration();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    protected virtual Hash CalculateHashInternal();
    protected virtual IDeclaredElement CreateDeclaredElement();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.StatementBase : VBCompositeElement {
    public sealed virtual TStatement ReplaceBy(TStatement stmt);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.StopStatement : StatementBase {
    public static short VB_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode StopKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_StopKeyword();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.StructureDeclaration : ClassLikeDeclarationBase {
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_MODIFIERS_LIST;
    public static short STRUCTURE_KEYWORD;
    public static short VB_NAME;
    public static short VB_TYPE_PARAMETERS_LIST;
    public static short VB_STATEMENT_TERMINATOR;
    public static short IMPLEMENTS_CLAUSE;
    public static short VB_BODY;
    public static short VB_END_DECLARATION;
    private IVBIdentifier myCachedName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedNameValid;
    private ITypeParameterOfTypeList myCachedTypeParameterList;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myCachedTypeParameterListValid;
    public NodeType NodeType { get; }
    public IAttributeList AttributeList { get; }
    public IClassBody Body { get; }
    public ITokenNode EndStructure { get; }
    public TreeNodeCollection`1<ITypeImplementsClause> ImplementsClauses { get; }
    public TreeNodeEnumerable`1<ITypeImplementsClause> ImplementsClausesEnumerable { get; }
    public IModifiersList ModifiersList { get; }
    public IVBIdentifier Name { get; }
    protected IVBIdentifier _Name { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode StructureKeyword { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    protected ITypeParameterOfTypeList _TypeParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConversionOperatorDeclaration> ConversionOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IConversionOperatorDeclaration> ConversionOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> ImplementsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> ImplementsTypesEnumerable { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> NestedTypeDeclarationsEnumerable { get; }
    public IVBNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ISignOperatorDeclaration> SignOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<ISignOperatorDeclaration> SignOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public string DeclaredName { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    private ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.TypeElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    public ITokenNode OpenKeyword { get; }
    public ITokenNode EndKeyword { get; }
    public TreeNodeCollection`1<IVBTypeMemberDeclaration> MemberDeclarations { get; }
    public IList`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public IEnumerable`1<IDeclaredTypeUsage> ExtendsListTypeUsages { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.NestedTypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.MemberDeclarations { get; }
    public int LevelDelta { get; }
    public bool IsPartial { get; }
    public bool IsSealed { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_AttributeList();
    public virtual IClassBody get_Body();
    public virtual ITokenNode get_EndStructure();
    public virtual TreeNodeCollection`1<ITypeImplementsClause> get_ImplementsClauses();
    public virtual TreeNodeEnumerable`1<ITypeImplementsClause> get_ImplementsClausesEnumerable();
    public virtual IModifiersList get_ModifiersList();
    public sealed virtual IVBIdentifier get_Name();
    protected virtual IVBIdentifier get__Name();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITokenNode get_StructureKeyword();
    public sealed virtual ITypeParameterOfTypeList get_TypeParameterList();
    protected virtual ITypeParameterOfTypeList get__TypeParameterList();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_ImplementsTypes();
    public virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_ImplementsTypesEnumerable();
    public virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVBTreeNode> get_NestedTypeDeclarations();
    public virtual TreeNodeEnumerable`1<IVBTreeNode> get_NestedTypeDeclarationsEnumerable();
    public virtual IVBNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ISignOperatorDeclaration> get_SignOperatorDeclarations();
    public virtual TreeNodeEnumerable`1<ISignOperatorDeclaration> get_SignOperatorDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<IVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IAttributeList SetAttributeList(IAttributeList param);
    public virtual IClassBody SetBody(IClassBody param);
    public virtual IModifiersList SetModifiersList(IModifiersList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public virtual string ToString();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    protected virtual IClassBody GetBody();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration.get_TypeElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    public sealed virtual ITokenNode get_OpenKeyword();
    public sealed virtual ITokenNode get_EndKeyword();
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public sealed virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration param);
    public sealed virtual TreeNodeCollection`1<IVBTypeMemberDeclaration> get_MemberDeclarations();
    public sealed virtual IList`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public virtual IEnumerable`1<IDeclaredTypeUsage> get_ExtendsListTypeUsages();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_NestedTypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    public sealed virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeMemberDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclaration.get_MemberDeclarations();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    private ISymbolTable AddStructureGlobalDeclarations(int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public sealed virtual ITypeImplementsClause AddImplementsClauseBefore(ITypeImplementsClause param, ITypeImplementsClause anchor);
    public sealed virtual ITypeImplementsClause AddImplementsClauseAfter(ITypeImplementsClause param, ITypeImplementsClause anchor);
    public sealed virtual void AddImplementsType(IDeclaredType implementsType);
    public sealed virtual void RemoveImplementsType(IDeclaredType implementsType);
    public sealed virtual bool get_IsPartial();
    public virtual bool get_IsSealed();
    public sealed virtual void SetPartial(bool value);
    public sealed virtual void SetExtern(bool value);
    public sealed virtual void SetUnsafe(bool value);
    public sealed virtual void SetVolatile(bool value);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.SyncLockStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXPR;
    public static short VB_BLOCK;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode EndSyncLock { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode SyncLockKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndSyncLock();
    public virtual IVBExpression get_Expression();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITokenNode get_SyncLockKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.ThrowStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXPR;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode ThrowKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_ThrowKeyword();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TryStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short VB_BLOCK;
    public static short CATCH_STMT;
    public static short FINALLY_STMT;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ICatchStatement> CatchStatements { get; }
    public TreeNodeEnumerable`1<ICatchStatement> CatchStatementsEnumerable { get; }
    public ITokenNode EndTry { get; }
    public IFinallyStatement FinallyStatement { get; }
    public IBlock TryBlock { get; }
    public ITokenNode TryKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ICatchStatement> get_CatchStatements();
    public virtual TreeNodeEnumerable`1<ICatchStatement> get_CatchStatementsEnumerable();
    public virtual ITokenNode get_EndTry();
    public virtual IFinallyStatement get_FinallyStatement();
    public virtual IBlock get_TryBlock();
    public virtual ITokenNode get_TryKeyword();
    public virtual IFinallyStatement SetFinallyStatement(IFinallyStatement param);
    public virtual IBlock SetTryBlock(IBlock param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TupleComponent : VBCompositeElement {
    public static short IDENTIFIER;
    public static short VB_COLON;
    public static short VB_EQ;
    public static short EXPRESSION;
    public NodeType NodeType { get; }
    public ITokenNode ColonSign { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public IVBIdentifier Name { get; }
    public string ExplicitOrInferredName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ColonSign();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Expression();
    public virtual IVBIdentifier get_Name();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    public sealed virtual string get_ExplicitOrInferredName();
    private bool HasDuplicateName(string name);
    public sealed virtual int IndexOf();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TupleDeclaredTypeUsage : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short TUPLE_COMPONENT;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITupleTypeComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleTypeComponent> ComponentsEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ITupleTypeComponent> get_Components();
    public virtual TreeNodeEnumerable`1<ITupleTypeComponent> get_ComponentsEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TupleExpression : VBExpressionBase {
    public static short VB_LPARENTH;
    public static short TUPLE_COMPONENT;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITupleComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleComponent> ComponentsEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ITupleComponent> get_Components();
    public virtual TreeNodeEnumerable`1<ITupleComponent> get_ComponentsEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TupleTypeComponent : VBCompositeElement {
    public static short VB_NAME;
    public static short AS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    public string ExplicitName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual IVBIdentifier get_Name();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public sealed virtual string get_ExplicitName();
    public sealed virtual int IndexOf();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TupleTypeUsage : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short COMPONENT;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public NodeType NodeType { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITupleTypeComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleTypeComponent> ComponentsEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode NullableMark { get; }
    public ITokenNode RPar { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ITupleTypeComponent> get_Components();
    public virtual TreeNodeEnumerable`1<ITupleTypeComponent> get_ComponentsEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_NullableMark();
    public virtual ITokenNode get_RPar();
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual string ToString();
    public sealed virtual ITypeUsage ReplaceBy(ITypeUsage typeUsage);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeArgumentList : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short OF_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode OfKeyword { get; }
    public ITokenNode RPar { get; }
    public IList`1<ITypeUsage> TypeArguments { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_OfKeyword();
    public virtual ITokenNode get_RPar();
    public virtual string ToString();
    public sealed virtual IList`1<ITypeUsage> get_TypeArguments();
    public sealed virtual void SetTypeArguments(IType[] types);
    public sealed virtual void SetTypeArguments(ITypeUsage[] typeNodes);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeElementDeclarationBase : VBCachedDeclarationBase {
    public ITypeElement TypeElement { get; }
    public ITypeElement DeclaredElement { get; }
    public string CLRName { get; }
    public IDocCommentBlock DocCommentBlock { get; }
    public IEnumerable`1<IVBHashableDeclaration> Children { get; }
    private bool JetBrains.ReSharper.Psi.VB.Impl.Tree.IVBHashableDeclaration.IsInternal { get; }
    public sealed virtual ITypeElement get_TypeElement();
    public sealed virtual ITypeElement get_DeclaredElement();
    public sealed virtual string get_CLRName();
    public sealed virtual IDocCommentBlock get_DocCommentBlock();
    public sealed virtual void SetDocCommentBlock(IDocCommentBlock block);
    public sealed virtual void RemoveAttribute(IAttribute attribute);
    public sealed virtual IAttribute AddAttribute(IAttribute attribute);
    public sealed virtual IHashableEntityInfo[] CalcAllHashes(string parentQualifiedName, String& qualifiedName);
    private IHashableEntityInfo CalcMainHash(string parentQualifiedName, String& qualifiedName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeElementDeclarationBase/<get_Children>d__14")]
public sealed virtual IEnumerable`1<IVBHashableDeclaration> get_Children();
    private static bool CanSkip(IVBTypeMemberDeclaration member);
    protected virtual Hash CalculateHashInternal();
    public sealed virtual Hash CalcHash();
    private sealed virtual override bool JetBrains.ReSharper.Psi.VB.Impl.Tree.IVBHashableDeclaration.get_IsInternal();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeImplementsClause : VBCompositeElement {
    public static short IMPLEMENTS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public static short VB_COMMA;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ImplementsKeyword { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> ImplementsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> ImplementsTypesEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_ImplementsKeyword();
    public virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_ImplementsTypes();
    public virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_ImplementsTypesEnumerable();
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeMemberDeclarationBase : AttributesOwnerDeclarationBase {
    private IDeclaredElement modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDeclaredElement;
    private static SpecialDependencyKind[] ALL_ABSTRACT_MEMBERS;
    public IDeclaredElement DeclaredElement { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.CachedDeclaredElement { get; private set; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool HasAccessRights { get; }
    public bool IsOverloads { get; }
    public bool IsWriteonly { get; }
    protected ICollection`1<SpecialDependencyKind> SpecialDepependencies { get; }
    public bool IsInternal { get; }
    private static TypeMemberDeclarationBase();
    protected virtual void PreInit();
    public virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.get_CachedDeclaredElement();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.set_CachedDeclaredElement(IDeclaredElement value);
    protected abstract virtual IDeclaredElement CreateDeclaredElement();
    internal abstract virtual IModifiersListOwner get_ModifiersListOwner();
    public virtual AccessRights GetAccessRights();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_HasAccessRights();
    public virtual void SetAccessRights(AccessRights rights);
    public virtual void SetAbstract(bool value);
    public virtual void SetSealed(bool value);
    public virtual void SetVirtual(bool value);
    public virtual void SetOverride(bool value);
    public virtual void SetStatic(bool value);
    public virtual void SetOverloads(bool value);
    public virtual bool get_IsOverloads();
    public virtual void SetReadonly(bool value);
    public virtual void SetWriteonly(bool value);
    public virtual bool get_IsWriteonly();
    public virtual void SetDefault(bool value);
    public sealed virtual void SetExtern(bool value);
    public sealed virtual void SetUnsafe(bool value);
    public sealed virtual void SetVolatile(bool value);
    protected virtual Hash CalculateHashInternal();
    protected virtual ICollection`1<SpecialDependencyKind> get_SpecialDepependencies();
    public virtual bool get_IsInternal();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeOfIsExpression : VBExpressionBase {
    public static short TYPEOF_KEYWORD;
    public static short EXPRESSION;
    public static short IS_KEYWORD;
    public static short VB_TYPE_USAGE;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode IsOrIsNotKeyword { get; }
    public ITokenNode TypeOfKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public TypeOfExpressionKind Kind { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_IsOrIsNotKeyword();
    public virtual ITokenNode get_TypeOfKeyword();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual TypeOfExpressionKind get_Kind();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeParameterConstraint : VBCompositeElement {
    public static short VB_TYPE_USAGE;
    public static short NEW_KEYWORD;
    public static short CLASS_KEYWORD;
    public static short STRUCTURE_KEYWORD;
    public NodeType NodeType { get; }
    public ITokenNode ClassKeyword { get; }
    public ITokenNode NewKeyword { get; }
    public ITokenNode StructureKeyword { get; }
    public IUserTypeUsage TypeUsage { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_ClassKeyword();
    public virtual ITokenNode get_NewKeyword();
    public virtual ITokenNode get_StructureKeyword();
    public virtual IUserTypeUsage get_TypeUsage();
    public virtual IUserTypeUsage SetTypeUsage(IUserTypeUsage param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeParameterConstraintList : VBCompositeElement {
    public static short AS_KEYWORD;
    public static short CONSTRAINT;
    public static short VB_LBRACE;
    public static short VB_COMMA;
    public static short VB_RBRACE;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> Constraint { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> ConstraintEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_Constraint();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_ConstraintEnumerable();
    public virtual ITokenNode get_LBrace();
    public virtual ITokenNode get_RBrace();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeParameterOfMethodDeclaration : VBDeclarationBase {
    public static short IN_KEYWORD;
    public static short OUT_KEYWORD;
    public static short VB_NAME;
    public static short CONSTRAINTS;
    private IDeclaredElement modreq(System.Runtime.CompilerServices.IsVolatile) myCachedDeclaredElement;
    public NodeType NodeType { get; }
    public ITypeParameterConstraintList ConstraintList { get; }
    public ITokenNode InKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode OutKeyword { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> Constraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> ConstraintsEnumerable { get; }
    public IDeclaredElement DeclaredElement { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.CachedDeclaredElement { get; private set; }
    private ITypeParameter JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterDeclaration.DeclaredElement { get; }
    public string DeclaredName { get; }
    public IList`1<IDeclaredType> DeclaredTypeConstraints { get; }
    public TypeParameterConstraintFlags ConstraintFlags { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITypeParameterConstraintList get_ConstraintList();
    public virtual ITokenNode get_InKeyword();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_OutKeyword();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_Constraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_ConstraintsEnumerable();
    public virtual ITypeParameterConstraintList SetConstraintList(ITypeParameterConstraintList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.get_CachedDeclaredElement();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration.set_CachedDeclaredElement(IDeclaredElement value);
    private sealed virtual override ITypeParameter JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterDeclaration.get_DeclaredElement();
    public virtual string get_DeclaredName();
    public virtual TreeTextRange GetNameRange();
    public virtual void SetName(string name);
    public sealed virtual IList`1<IDeclaredType> get_DeclaredTypeConstraints();
    public sealed virtual TypeParameterConstraintFlags get_ConstraintFlags();
    public virtual bool IsSynthetic();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeParameterOfMethodList : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short VB_KEYWORD;
    public static short TYPE_PARAMETER;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode OfKeyword { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_OfKeyword();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeParameterOfTypeDeclaration : VBCachedDeclarationBase {
    public static short IN_KEYWORD;
    public static short OUT_KEYWORD;
    public static short VB_NAME;
    public static short CONSTRAINTS;
    public NodeType NodeType { get; }
    public ITypeParameterConstraintList ConstraintList { get; }
    public ITokenNode InKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode OutKeyword { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> Constraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> ConstraintsEnumerable { get; }
    private ITypeParameter JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterDeclaration.DeclaredElement { get; }
    public TypeParameterVariance Variance { get; }
    public string DeclaredName { get; }
    public IList`1<IDeclaredType> DeclaredTypeConstraints { get; }
    public TypeParameterConstraintFlags ConstraintFlags { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITypeParameterConstraintList get_ConstraintList();
    public virtual ITokenNode get_InKeyword();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_OutKeyword();
    public virtual TreeNodeCollection`1<ITypeParameterConstraint> get_Constraints();
    public virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_ConstraintsEnumerable();
    public virtual ITypeParameterConstraintList SetConstraintList(ITypeParameterConstraintList param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual string ToString();
    private sealed virtual override ITypeParameter JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterDeclaration.get_DeclaredElement();
    public sealed virtual TypeParameterVariance get_Variance();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual IList`1<IDeclaredType> get_DeclaredTypeConstraints();
    public sealed virtual TypeParameterConstraintFlags get_ConstraintFlags();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.TypeParameterOfTypeList : VBCompositeElement {
    public static short VB_LPARENTH;
    public static short VB_KEYWORD;
    public static short TYPE_PARAMETER;
    public static short VB_COMMA;
    public static short VB_RPARENTH;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode OfKeyword { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_LPar();
    public virtual ITokenNode get_OfKeyword();
    public virtual ITokenNode get_RPar();
    public virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.UnaryNegationExpression : VBUnaryExpressionBase {
    public static short VB_OP_SIGN;
    public static short VB_OP1;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode OpSign { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_OpSign();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.UnknownPreprocessorDirective : VBPreprocessorElementBase {
    public static short SHARP;
    public NodeType NodeType { get; }
    public ITokenNode Sharp { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Sharp();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.UserDeclaredTypeUsage : VBCompositeElement {
    public static short TYPE_NAME;
    public NodeType NodeType { get; }
    public IReferenceName TypeName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IReferenceName get_TypeName();
    public virtual IReferenceName SetTypeName(IReferenceName param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.UserTypeUsage : VBCompositeElement {
    public static short TYPE_NAME;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public NodeType NodeType { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode NullableMark { get; }
    public IReferenceName TypeName { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual ITokenNode get_NullableMark();
    public virtual IReferenceName get_TypeName();
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual IReferenceName SetTypeName(IReferenceName param);
    public virtual string ToString();
    public sealed virtual ITypeUsage ReplaceBy(ITypeUsage typeUsage);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.UsingStatement : UsingStatementStub {
    public virtual IVBExpression SetExpression(IVBExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.UsingStatementStub : StatementBase {
    public static short VB_KEYWORD;
    public static short VAR_DECL;
    public static short VB_COMMA;
    public static short EXPRESSION;
    public static short VB_BLOCK;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode EndUsing { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode UsingKeyword { get; }
    public TreeNodeCollection`1<IUsingVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IUsingVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual ITokenNode get_EndUsing();
    public virtual IVBExpression get_Expression();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITokenNode get_UsingKeyword();
    public virtual TreeNodeCollection`1<IUsingVariableDeclaration> get_VariableDeclarations();
    public virtual TreeNodeEnumerable`1<IUsingVariableDeclaration> get_VariableDeclarationsEnumerable();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.UsingVariableDeclaration : UsingVariableDeclarationStub {
    [CanBeNullAttribute]
public virtual IVBExpression SetInitializer(IVBExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.UsingVariableDeclarationStub : LocalVariableDeclarationBase {
    public static short VB_NAME;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public static short AS_KEYWORD;
    public static short EXPRESSION;
    public static short VB_TYPE_USAGE;
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    public NodeType NodeType { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode AsKeyword { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode NullableMark { get; }
    public ITypeUsage TypeUsage { get; }
    public string DeclaredName { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    [NotNullAttribute]
public ILocalVariable DeclaredVariable { get; }
    public bool IsImplicitlyTyped { get; }
    [NotNullAttribute]
public IVBLocalVariable DeclaredElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual ITokenNode get_AsKeyword();
    public virtual IObjectCreationExpression get_CreationExpression();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Initializer();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_NullableMark();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual TreeTextRange GetNameRange();
    public virtual void SetName(string name);
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    public sealed virtual ILocalVariable get_DeclaredVariable();
    public virtual IType CalculateType(IResolveContext resolveContext);
    public virtual bool get_IsImplicitlyTyped();
    public sealed virtual IVBLocalVariable get_DeclaredElement();
    public sealed virtual void SetType(IType type);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VariableDeclaration : VariableDeclarationStub {
    [NotNullAttribute]
protected virtual IDeclaredElement CreateDeclaredElement();
    public virtual IVBExpression SetInitializer(IVBExpression param);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VariableDeclarationList : VariableDeclarationListStub {
    public virtual IVBExpression SetInitializer(IVBExpression param);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VariableDeclarationListStub : VBCompositeElement {
    public static short DECLARATION;
    public static short VB_COMMA;
    public static short AS_KEYWORD;
    public static short CREATION_EXPRESSION;
    public static short VB_TYPE_USAGE;
    public static short VB_EQ;
    public static short VB_INITIALIZER;
    public NodeType NodeType { get; }
    public ITokenNode AsKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public TreeNodeCollection`1<IVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IVariableDeclaration> DeclarationsEnumerable { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public ITypeUsage TypeUsage { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AsKeyword();
    public virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public virtual IObjectCreationExpression get_CreationExpression();
    public virtual TreeNodeCollection`1<IVariableDeclaration> get_Declarations();
    public virtual TreeNodeEnumerable`1<IVariableDeclaration> get_DeclarationsEnumerable();
    public virtual ITokenNode get_EqSign();
    public virtual IVBExpression get_Initializer();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VariableDeclarationStub : TypeMemberDeclarationBase {
    public static short VB_NAME;
    public static short NULLABLE_MARK;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public NodeType NodeType { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode NullableMark { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public IVariableDeclarationList DeclarationsList { get; }
    public IVBExpression Initializer { get; }
    public IMultipleVariableDeclaration MultipleDeclaration { get; }
    public ITypeUsage TypeUsage { get; }
    public string DeclaredName { get; }
    public bool WithEvents { get; }
    private ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.MemberElement { get; }
    private ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.DeclaredElement { get; }
    private IField JetBrains.ReSharper.Psi.VB.Tree.IVariableDeclaration.VariableElement { get; }
    private IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.ModifiersOwner { get; }
    internal IModifiersListOwner ModifiersListOwner { get; }
    internal IAttributeListOwner AttributeListOwner { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.Initializer { get; }
    public bool IsOverloads { get; }
    public IType Type { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IArrayModifiersList get_ArrayModifiersList();
    public virtual IVBIdentifier get_Name();
    public virtual ITokenNode get_NullableMark();
    public virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public virtual IObjectCreationExpression get_CreationExpression();
    public virtual IVariableDeclarationList get_DeclarationsList();
    public virtual IVBExpression get_Initializer();
    public virtual IMultipleVariableDeclaration get_MultipleDeclaration();
    public virtual ITypeUsage get_TypeUsage();
    public virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public virtual IVBExpression SetInitializer(IVBExpression param);
    public virtual IVBIdentifier SetName(IVBIdentifier param);
    public virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public virtual string ToString();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    public sealed virtual bool get_WithEvents();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.get_MemberElement();
    private sealed virtual override ITypeMember JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.get_DeclaredElement();
    private sealed virtual override IField JetBrains.ReSharper.Psi.VB.Tree.IVariableDeclaration.get_VariableElement();
    private sealed virtual override IModifiersOwner JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration.get_ModifiersOwner();
    internal virtual IModifiersListOwner get_ModifiersListOwner();
    internal virtual IAttributeListOwner get_AttributeListOwner();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration.get_Initializer();
    private sealed virtual override ITypeDeclaration JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration.GetContainingTypeDeclaration();
    private sealed virtual override IVBTypeDeclaration JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration.GetContainingVbTypeDeclaration();
    private void AddOrRemoveDimKeyword();
    private static bool HasAssessModifier(IModifiersList modifiersList);
    public virtual void SetAccessRights(AccessRights rights);
    public virtual bool get_IsOverloads();
    public virtual void SetOverloads(bool value);
    public virtual void SetStatic(bool value);
    public virtual void SetReadonly(bool value);
    public virtual void SetWriteonly(bool value);
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    protected virtual Hash CalculateHashInternal();
    public sealed virtual void SetType(IType type);
    public sealed virtual IType get_Type();
    public virtual AccessRights GetAccessRights();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBBinaryExpressionBase : VBExpressionBase {
    private BinaryOperatorReference modreq(System.Runtime.CompilerServices.IsVolatile) myReference;
    public IVBTreeNode Node { get; }
    private IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.Reference { get; }
    private ITokenNode JetBrains.ReSharper.Psi.VB.Tree.IVBOperatorNode.Sign { get; }
    public IVBOperatorReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    private ITokenNode Sign { get; }
    public IVBExpression Left { get; }
    public IVBExpression Right { get; }
    public TokenNodeType SignTokenType { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    protected virtual void PreInit();
    public sealed virtual IVBTreeNode get_Node();
    private sealed virtual override IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_Reference();
    private sealed virtual override ITokenNode JetBrains.ReSharper.Psi.VB.Tree.IVBOperatorNode.get_Sign();
    public virtual IVBOperatorReference get_Reference();
    public sealed virtual IList`1<IType> get_TypeArguments();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public sealed virtual IAccessContext GetAccessContext();
    private ITokenNode get_Sign();
    public sealed virtual IVBExpression get_Left();
    public sealed virtual IVBExpression get_Right();
    public sealed virtual TokenNodeType get_SignTokenType();
    public DocumentRange GetSignDocumentRange();
    public sealed virtual TreeTextRange GetSignTreeTextRange();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBCachedDeclarationBase : VBCompositeElement {
    private IDeclaredElement myCaches2DeclaredElement;
    public string DeclaredName { get; }
    public IDeclaredElement DeclaredElement { get; }
    public IDeclaredElement CacheDeclaredElement { get; public set; }
    public abstract virtual string get_DeclaredName();
    public abstract virtual void SetName(string name);
    public abstract virtual TreeTextRange GetNameRange();
    public sealed virtual bool IsSynthetic();
    protected virtual void PreInit();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual IDeclaredElement get_CacheDeclaredElement();
    public sealed virtual void set_CacheDeclaredElement(IDeclaredElement value);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBChildRole : object {
    public static short NONE;
    public static short VB_DOT;
    public static short VB_EQ;
    public static short VB_LT;
    public static short VB_GT;
    public static short VB_COMMA;
    public static short VB_COLON;
    public static short VB_LPARENTH;
    public static short VB_RPARENTH;
    public static short VB_LBRACE;
    public static short VB_RBRACE;
    public static short VB_EXCL;
    public static short VB_KEYWORD;
    public static short VB_QUALIFIER;
    public static short VB_REFERENCE;
    public static short VB_OP1;
    public static short VB_OP_SIGN;
    public static short VB_OP2;
    public static short VB_TYPE_ARGUMENT_LIST;
    public static short VB_TYPE_PARAMETERS_LIST;
    public static short VB_ARGUMENT;
    public static short VB_ARGUMENT_LIST;
    public static short VB_TYPE_USAGE;
    public static short VB_ATTRIBUTE_LIST;
    public static short VB_RETURN_ATTRIBUTE_LIST;
    public static short VB_PARAMETERS_LIST;
    public static short VB_INITIALIZER;
    public static short VB_MODIFIER;
    public static short VB_ARRAY_MODIFIERS_LIST;
    public static short VB_NAME;
    public static short VB_BODY;
    public static short VB_BLOCK;
    public static short VB_END_DECLARATION;
    public static short VB_MODIFIERS_LIST;
    public static short VB_STATEMENT_TERMINATOR;
    public static short LAST;
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBCompositeElement : CompositeElement {
    public PsiLanguageType Language { get; }
    public virtual PsiLanguageType get_Language();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public sealed virtual IVBNamespaceDeclaration GetContainingNamespaceDeclaration();
    public sealed virtual IVBTypeMemberDeclaration GetContainingTypeMemberDeclaration();
    public sealed virtual IVBTypeDeclaration GetContainingTypeDeclaration();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBDeclarationBase : VBCompositeElement {
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public abstract virtual IDeclaredElement get_DeclaredElement();
    public abstract virtual string get_DeclaredName();
    public abstract virtual void SetName(string name);
    public abstract virtual TreeTextRange GetNameRange();
    public abstract virtual bool IsSynthetic();
    protected internal virtual string GetShortNameOfDeclaredElement();
    public virtual XmlNode GetXMLDoc(bool inherit);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBDelimiterToken : VBFloatingLeafElement {
    private TokenNodeType myType;
    private string myText;
    public NodeType NodeType { get; }
    public VBDelimiterToken(TokenNodeType type, string text);
    public virtual NodeType get_NodeType();
    public virtual int GetTextLength();
    public virtual string GetText();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBExpressionBase : VBCompositeElement {
    private CachedPsiValue`1<ConstantValue> myCachedConstantValue;
    private CachedPsiValue`1<IExpressionType> myCachedExpressionType;
    public ConstantValue CachedConstantValue { get; public set; }
    public IExpressionType CachedExpressionType { get; public set; }
    public ConstantValue ConstantValue { get; }
    protected virtual void PreInit();
    public sealed virtual bool IsConstantValue();
    public virtual bool IsConstantValue(IResolveContext resolveContext);
    public sealed virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public sealed virtual ConstantValue get_CachedConstantValue();
    public sealed virtual void set_CachedConstantValue(ConstantValue value);
    public sealed virtual IExpressionType get_CachedExpressionType();
    public sealed virtual void set_CachedExpressionType(IExpressionType value);
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual IType Type();
    public virtual IType Type(IResolveContext resolveContext);
    public abstract virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public sealed virtual IExpressionType GetExpressionType();
    public sealed virtual IType GetImplicitlyConvertedTo();
    public virtual IType GetImplicitlyConvertedTo(IResolveContext resolveContext);
    public sealed virtual ExpressionAccessType GetAccessType();
    public sealed virtual ExpressionAccessType GetAccessType(IResolveContext resolveContext);
    public sealed virtual IVBExpression ReplaceBy(IVBExpression expr);
    private bool NeedToParenthise(IVBExpression expr);
    private static int CalcExpressionPriority(IVBExpression expr);
    public sealed virtual ExpressionClassification GetClassification();
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBFile : VBFileElement {
    public static short VB_STATEMENT_TERMINATOR;
    public static short OPTIONS_SECTION;
    public static short IMPORTS;
    public static short GLOBAL_ATTRIBUTE;
    public static short NAMESPACE_DECLARATION;
    public static short TYPE_DECLARATION;
    private OptionValues[] myOptionsOverriddenForFile;
    private static ModuleProperty[] MODULE_PROPERTY_DEPENDENCIES;
    internal PreProcessingDirectivesInFile myConditionalSymbolNames;
    public NodeType NodeType { get; }
    public IAttributeList GlobalAttributes { get; }
    public IImportDirectivesSection ImportsSection { get; }
    public TreeNodeCollection`1<IVBNamespaceDeclaration> NamespaceDeclarations { get; }
    public TreeNodeEnumerable`1<IVBNamespaceDeclaration> NamespaceDeclarationsEnumerable { get; }
    public IOptionStatementsSection OptionsSection { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IVBTypeDeclaration> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTypeDeclaration> TypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IImportClause> Imports { get; }
    public TreeNodeEnumerable`1<IImportClause> ImportsEnumerable { get; }
    public TreeNodeCollection`1<IOptionStatement> Options { get; }
    public TreeNodeEnumerable`1<IOptionStatement> OptionsEnumerable { get; }
    public int LevelDelta { get; }
    private int DefaultNamespaceDepth { get; }
    public IList`1<IVBDeclaration> TypeAndNamespaceDeclarations { get; }
    private ITypeAndNamespaceHolderDeclaration JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration.ContainingTypeAndNamespaceHolder { get; }
    private IReadOnlyList`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.NamespaceDeclarations { get; }
    private IEnumerable`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.NamespaceDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarationsEnumerable { get; }
    public string DefaultNamespaceName { get; }
    public INamespace DefaultNamespace { get; }
    public Nullable`1<VBFileOption> StrictOption { get; }
    public Nullable`1<VBFileOption> InferOption { get; }
    public Nullable`1<VBFileOption> ExplicitOption { get; }
    private IEnumerable`1<ModuleProperty> JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies.ModulePropertyDependencies { get; }
    public PsiLanguageType Language { get; }
    private static VBFile();
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IAttributeList get_GlobalAttributes();
    public virtual IImportDirectivesSection get_ImportsSection();
    public virtual TreeNodeCollection`1<IVBNamespaceDeclaration> get_NamespaceDeclarations();
    public virtual TreeNodeEnumerable`1<IVBNamespaceDeclaration> get_NamespaceDeclarationsEnumerable();
    public virtual IOptionStatementsSection get_OptionsSection();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IVBTypeDeclaration> get_TypeDeclarations();
    public virtual TreeNodeEnumerable`1<IVBTypeDeclaration> get_TypeDeclarationsEnumerable();
    public virtual TreeNodeCollection`1<IImportClause> get_Imports();
    public virtual TreeNodeEnumerable`1<IImportClause> get_ImportsEnumerable();
    public virtual TreeNodeCollection`1<IOptionStatement> get_Options();
    public virtual TreeNodeEnumerable`1<IOptionStatement> get_OptionsEnumerable();
    public virtual IAttributeList SetGlobalAttributes(IAttributeList param);
    public virtual IImportDirectivesSection SetImportsSection(IImportDirectivesSection param);
    public virtual IOptionStatementsSection SetOptionsSection(IOptionStatementsSection param);
    public virtual string ToString();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    public sealed virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    private ISymbolTable MergeTableForElement(ISymbolTable table, IDeclaredElement declaredElement, ISubstitution substitution, IImportClause clause, IPsiModule module, int level, SymbolTableMode mode);
    private ISymbolTable AddPreImportedNamespaces(ISymbolScope cache, int preimportedElementsLevel, IPsiModule module, SymbolTableMode mode);
    private ISymbolTable AddImportedElements(int aliasedLevel, int importedElementsLevel, SymbolTableMode mode);
    private ISymbolTable AddDefaultNamespaceDeclarations(int level, IPsiModule module, SymbolTableMode mode, Int32& defaultNamespaceDepth);
    public sealed virtual int get_LevelDelta();
    private int get_DefaultNamespaceDepth();
    public sealed virtual IList`1<IVBDeclaration> get_TypeAndNamespaceDeclarations();
    private sealed virtual override ITypeAndNamespaceHolderDeclaration JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration.get_ContainingTypeAndNamespaceHolder();
    private sealed virtual override IReadOnlyList`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.get_NamespaceDeclarations();
    private sealed virtual override IEnumerable`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.get_NamespaceDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarationsEnumerable();
    public sealed virtual string get_DefaultNamespaceName();
    public sealed virtual INamespace get_DefaultNamespace();
    private Nullable`1<VBFileOption> CalcFileOption(FileOptions fileOption);
    private Nullable`1<VBFileOption> GetFileOption(FileOptions fileOption);
    public sealed virtual Nullable`1<VBFileOption> get_StrictOption();
    public sealed virtual Nullable`1<VBFileOption> get_InferOption();
    public sealed virtual Nullable`1<VBFileOption> get_ExplicitOption();
    public sealed virtual IDeclarationsRange GetAllDeclarationsRange();
    public sealed virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange textRange);
    public sealed virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    public sealed virtual IImportDirective AddImportAfter(IImportDirective param, IImportDirective anchor);
    public sealed virtual IImportDirective AddImportBefore(IImportDirective param, IImportDirective anchor);
    public sealed virtual IImportDirective AddImport(IImportDirective param, bool saveUsingListPosition);
    public sealed virtual void RemoveImport(IImportDirective param);
    public sealed virtual void RemoveImportClause(IImportClause clause);
    public sealed virtual IVBNamespaceDeclaration AddNamespaceDeclarationAfter(IVBNamespaceDeclaration param, IVBNamespaceDeclaration anchor);
    public sealed virtual IVBNamespaceDeclaration AddNamespaceDeclarationBefore(IVBNamespaceDeclaration param, IVBNamespaceDeclaration anchor);
    public sealed virtual void RemoveNamespaceDeclaration(IVBNamespaceDeclaration param);
    public sealed virtual T AddTypeDeclarationAfter(T param, IVBTypeDeclaration anchor);
    public sealed virtual T AddTypeDeclarationBefore(T param, IVBTypeDeclaration anchor);
    public sealed virtual void RemoveTypeDeclaration(IVBTypeDeclaration param);
    public sealed virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
    private sealed virtual override IEnumerable`1<Pair`2<object, IUsingsInfo>> JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies.GetTopLevelHashableEntities();
    private sealed virtual override ICollection`1<string> JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies.GetEmptyNamespaceDeclarations();
    private sealed virtual override IEnumerable`1<ModuleProperty> JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies.get_ModulePropertyDependencies();
    private static void AddEmptyNamespaceDeclarations(IVBTypeAndNamespaceHolderDeclaration holder, List`1<string> list);
    private static IEnumerable`1<Pair`2<object, IUsingsInfo>> EnumerateTypeDeclarations(IVBTypeAndNamespaceHolderDeclaration holder, VBFile file);
    public sealed virtual IHashableEntityInfo[] CalcAllEntityHashes(object hashableEntity, string parentQualifiedName, String& qualifiedName);
    public sealed virtual IEnumerable EntityChildren(object hashableEntity);
    public sealed virtual bool IsEntityInternal(object hashableEntity);
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    public sealed virtual PreProcessingDirectivesInFile GetPreprocessorConditionals();
    public sealed virtual IOptionStatementsSection SetOptions(IOptionStatementsSection param);
    public virtual PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
internal static void <EnumerateTypeDeclarations>g__Inner|104_0(IVBTypeAndNamespaceHolderDeclaration me, <>c__DisplayClass104_0& );
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBFileElement : FileElementBase {
    public sealed virtual IVBNamespaceDeclaration GetContainingNamespaceDeclaration();
    public sealed virtual IVBTypeMemberDeclaration GetContainingTypeMemberDeclaration();
    public sealed virtual IVBTypeDeclaration GetContainingTypeDeclaration();
    public abstract virtual void Accept(TreeNodeVisitor visitor);
    public abstract virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public abstract virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBFloatingLeafElement : LeafElementBase {
    public PsiLanguageType Language { get; }
    public virtual PsiLanguageType get_Language();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TResult Accept(TreeNodeVisitor`2<TContext, TResult> visitor, TContext context);
    public sealed virtual IVBNamespaceDeclaration GetContainingNamespaceDeclaration();
    public sealed virtual IVBTypeMemberDeclaration GetContainingTypeMemberDeclaration();
    public sealed virtual IVBTypeDeclaration GetContainingTypeDeclaration();
    public sealed virtual TokenNodeType GetTokenType();
    public virtual string ToString();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
}
internal static class JetBrains.ReSharper.Psi.VB.Impl.Tree.VbHashableEntityUtil : object {
    public static Hash PutParameters(Hash hash, IEnumerable`1<IRegularParameterDeclaration> parameters);
    public static Hash PutTypeParameters(Hash hash, IEnumerable`1<T> typeParameters);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBIdentifier : VBCompositeElement {
    public static short VB_NAME;
    public static short TYPECHAR;
    public NodeType NodeType { get; }
    public ITokenNode NameToken { get; }
    public ITokenNode TypeChar { get; }
    public string Name { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_NameToken();
    public virtual ITokenNode get_TypeChar();
    public virtual string ToString();
    public sealed virtual string get_Name();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBIdentifierToken : VBFloatingLeafElement {
    private string myText;
    public NodeType NodeType { get; }
    public VBIdentifierToken(string text);
    public virtual NodeType get_NodeType();
    public virtual int GetTextLength();
    public virtual string GetText();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBKeywordToken : VBFloatingLeafElement {
    private TokenNodeType myType;
    private string myText;
    public NodeType NodeType { get; }
    public VBKeywordToken(TokenNodeType type, string text);
    public virtual bool IsFiltered();
    public virtual NodeType get_NodeType();
    public virtual int GetTextLength();
    public virtual string GetText();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBLambdaExpression : VBExpressionBase {
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public PsiLanguageType PresentationLanguage { get; }
    private ILambdaExpression LambdaExpression { get; }
    private TreeNodeCollection`1<ILambdaParameterDeclaration> ParameterDeclarations { get; }
    private ILambdaSignature Signature { get; }
    public bool HasImplicitlyTypedParameters { get; }
    public int LevelDelta { get; }
    public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public IDeclaredElement DeclaredElement { get; }
    public string DeclaredName { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameter> Parameters { get; }
    private IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.ParameterDeclarations { get; }
    public IParametersOwner DeclaredParametersOwner { get; }
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public abstract virtual IType GetReturnType(IResolveContext resolveContext);
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    private ILambdaExpression get_LambdaExpression();
    private TreeNodeCollection`1<ILambdaParameterDeclaration> get_ParameterDeclarations();
    private ILambdaSignature get_Signature();
    public sealed virtual bool get_HasImplicitlyTypedParameters();
    public virtual IType GetImplicitlyConvertedTo(IResolveContext resolveContext);
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual string get_DeclaredName();
    public sealed virtual void SetName(string name);
    public abstract virtual TreeTextRange GetNameRange();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsSynthetic();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    private sealed virtual override IList`1<IParameterDeclaration> JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration.get_ParameterDeclarations();
    public sealed virtual IParametersOwner get_DeclaredParametersOwner();
    public sealed virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public sealed virtual ILambdaParameterDeclaration AddParameterDeclarationBefore(ILambdaParameterDeclaration param, ILambdaParameterDeclaration anchor);
    public sealed virtual ILambdaParameterDeclaration AddParameterDeclarationAfter(ILambdaParameterDeclaration param, ILambdaParameterDeclaration anchor);
    public sealed virtual void RemoveParameterDeclaration(int index);
    public sealed virtual void RemoveParameterDeclaration(ILambdaParameterDeclaration param);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBLiteralExpression : VBExpressionBase {
    public static short LITERAL;
    [NotNullAttribute]
private static Char[] DigitSeparatorChars;
    public NodeType NodeType { get; }
    public ITokenNode Literal { get; }
    private static VBLiteralExpression();
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Literal();
    public virtual string ToString();
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
private ConstantValue ParseIntegerLiteral(string literalText);
    [PureAttribute]
private static IntegerLiteralBase GetIntegerLiteralBase(string literalText, Int32& startOffset);
    [PureAttribute]
private static IntegerLiteralSuffix GetIntegerLiteralSuffix(string literalText, Int32& endOffset, Boolean& isUnsigned);
    [NotNullAttribute]
[PureAttribute]
private ConstantValue ParseStringLiteral(string text);
    [NotNullAttribute]
[PureAttribute]
private ConstantValue ParseCharLiteral(string text);
    [NotNullAttribute]
private ConstantValue ParseFloatLiteral(string text);
    [NotNullAttribute]
private ConstantValue ParseDateLiteral(string text);
    public virtual bool IsConstantValue(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    [NotNullAttribute]
private IExpressionType GetIntegerType(string text);
    [NotNullAttribute]
private IExpressionType GetFloatPointType(string text);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBNamespaceDeclaration : VBCachedDeclarationBase {
    public static short NAMESPACE_KEYWORD;
    public static short VB_NAME;
    public static short VB_STATEMENT_TERMINATOR;
    public static short NAMESPACE_DECLARATION;
    public static short TYPE_DECLARATION;
    public static short VB_END_DECLARATION;
    private CachedPsiValue`1<Tuple`3<ISymbolTable, int, SymbolTableMode>> myTableCache;
    public NodeType NodeType { get; }
    public ITokenNode EndNamespace { get; }
    public TreeNodeCollection`1<IVBNamespaceDeclaration> NamespaceDeclarations { get; }
    public TreeNodeEnumerable`1<IVBNamespaceDeclaration> NamespaceDeclarationsEnumerable { get; }
    public ITokenNode NamespaceKeyword { get; }
    public IQualifiedNamespaceName QualifiedNamespaceName { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IVBTypeDeclaration> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTypeDeclaration> TypeDeclarationsEnumerable { get; }
    public INamespace DeclaredElement { get; }
    public string DeclaredName { get; }
    private ITypeAndNamespaceHolderDeclaration JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration.ContainingTypeAndNamespaceHolder { get; }
    public IList`1<IVBDeclaration> TypeAndNamespaceDeclarations { get; }
    private IReadOnlyList`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.NamespaceDeclarations { get; }
    private IEnumerable`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.NamespaceDeclarationsEnumerable { get; }
    private IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarations { get; }
    private IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.TypeDeclarationsEnumerable { get; }
    public IVBNamespaceDeclaration ContainingNamespace { get; }
    public string ShortName { get; }
    public string QualifiedName { get; }
    public int LevelDelta { get; }
    public Tuple`3<ISymbolTable, int, SymbolTableMode> CachedTable { get; public set; }
    public bool IsGlobal { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EndNamespace();
    public virtual TreeNodeCollection`1<IVBNamespaceDeclaration> get_NamespaceDeclarations();
    public virtual TreeNodeEnumerable`1<IVBNamespaceDeclaration> get_NamespaceDeclarationsEnumerable();
    public virtual ITokenNode get_NamespaceKeyword();
    public virtual IQualifiedNamespaceName get_QualifiedNamespaceName();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual TreeNodeCollection`1<IVBTypeDeclaration> get_TypeDeclarations();
    public virtual TreeNodeEnumerable`1<IVBTypeDeclaration> get_TypeDeclarationsEnumerable();
    public virtual IQualifiedNamespaceName SetQualifiedNamespaceName(IQualifiedNamespaceName param);
    public virtual string ToString();
    protected virtual void PreInit();
    private static string BuildDeclaredName(IQualifiedNamespaceName node);
    public sealed virtual INamespace get_DeclaredElement();
    public virtual string get_DeclaredName();
    public virtual void SetName(string name);
    public virtual TreeTextRange GetNameRange();
    private sealed virtual override ITypeAndNamespaceHolderDeclaration JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration.get_ContainingTypeAndNamespaceHolder();
    public sealed virtual IList`1<IVBDeclaration> get_TypeAndNamespaceDeclarations();
    public sealed virtual IVBNamespaceDeclaration AddNamespaceDeclarationAfter(IVBNamespaceDeclaration param, IVBNamespaceDeclaration anchor);
    public sealed virtual IVBNamespaceDeclaration AddNamespaceDeclarationBefore(IVBNamespaceDeclaration param, IVBNamespaceDeclaration anchor);
    public sealed virtual void RemoveNamespaceDeclaration(IVBNamespaceDeclaration param);
    public sealed virtual T AddTypeDeclarationAfter(T param, IVBTypeDeclaration anchor);
    public sealed virtual TTypeDeclaration AddTypeDeclarationBefore(TTypeDeclaration param, IVBTypeDeclaration anchor);
    public sealed virtual void RemoveTypeDeclaration(IVBTypeDeclaration param);
    private sealed virtual override IReadOnlyList`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.get_NamespaceDeclarations();
    private sealed virtual override IEnumerable`1<INamespaceDeclaration> JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder.get_NamespaceDeclarationsEnumerable();
    private sealed virtual override IReadOnlyList`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarations();
    private sealed virtual override IEnumerable`1<ITypeDeclaration> JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder.get_TypeDeclarationsEnumerable();
    public sealed virtual IVBNamespaceDeclaration get_ContainingNamespace();
    public sealed virtual string get_ShortName();
    public sealed virtual string get_QualifiedName();
    public sealed virtual void SetQualifiedName(string qualifiedName);
    public sealed virtual DocumentRange GetDeclaredNameDocumentRange();
    public sealed virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public sealed virtual int get_LevelDelta();
    public sealed virtual Tuple`3<ISymbolTable, int, SymbolTableMode> get_CachedTable();
    public sealed virtual void set_CachedTable(Tuple`3<ISymbolTable, int, SymbolTableMode> value);
    public sealed virtual IDeclarationsRange GetAllDeclarationsRange();
    public sealed virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange textRange);
    public sealed virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    public sealed virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
    public sealed virtual bool get_IsGlobal();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBNonCachedDeclarationBase : VBDeclarationBase {
    public IDeclaredElement DeclaredElement { get; }
    public string ShortName { get; }
    public ISubstitution IdSubstitution { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public bool CaseSensitiveName { get; }
    public IPsiModule Module { get; }
    public virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual string get_ShortName();
    public virtual ISubstitution get_IdSubstitution();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual bool get_CaseSensitiveName();
    public abstract virtual DeclaredElementType GetElementType();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    private sealed virtual override HybridCollection`1<IPsiSourceFile> JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(IPsiSourceFile sourceFile);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBPreprocessorElementBase : VBCompositeElement {
    private CalculateValue myValueCalculator;
    unknown CalculateValue ValueCalculator {internal set; }
    public virtual bool IsFiltered();
    public sealed virtual ConstantValue GetConstantValue(string name);
    internal void set_ValueCalculator(CalculateValue value);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBToken : BoundToBufferLeafElement {
    public PsiLanguageType Language { get; }
    public VBToken(NodeType type, IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public virtual PsiLanguageType get_Language();
    public virtual bool IsFiltered();
    public sealed virtual TokenNodeType GetTokenType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TResult Accept(TreeNodeVisitor`2<TContext, TResult> visitor, TContext context);
    public sealed virtual IVBNamespaceDeclaration GetContainingNamespaceDeclaration();
    public sealed virtual IVBTypeMemberDeclaration GetContainingTypeMemberDeclaration();
    public sealed virtual IVBTypeDeclaration GetContainingTypeDeclaration();
    public virtual string ToString();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBUnaryExpressionBase : VBExpressionBase {
    private UnaryOperatorReference myReference;
    public ITokenNode Sign { get; }
    public IVBExpression Operand { get; }
    public IPsiModule PsiModule { get; }
    public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    private IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.Arguments { get; }
    private IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.ExtensionQualifier { get; }
    public IVBTreeNode Node { get; }
    private IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.Reference { get; }
    public IVBOperatorReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    public IVBArgumentInfo ExtensionQualifier { get; }
    [NotNullAttribute]
private IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.Reference { get; }
    public sealed virtual ITokenNode get_Sign();
    public IVBExpression get_Operand();
    protected virtual void PreInit();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    private sealed virtual override IList`1<IArgumentInfo> JetBrains.ReSharper.Psi.IInvocationInfo.get_Arguments();
    private sealed virtual override IArgumentInfo JetBrains.ReSharper.Psi.IInvocationInfo.get_ExtensionQualifier();
    public sealed virtual IVBTreeNode get_Node();
    private sealed virtual override IVBInvocationReference JetBrains.ReSharper.Psi.VB.IVBInvocationInfo.get_Reference();
    public sealed virtual IVBOperatorReference get_Reference();
    public sealed virtual IList`1<IType> get_TypeArguments();
    public sealed virtual IVBArgumentInfo get_ExtensionQualifier();
    private sealed virtual override IManagedReference JetBrains.ReSharper.Psi.IInvocationInfo.get_Reference();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    public virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBWhiteSpaceTokenBase : VBFloatingLeafElement {
    [NotNullAttribute]
private string myText;
    protected VBWhiteSpaceTokenBase(string text);
    public virtual bool IsFiltered();
    public virtual int GetTextLength();
    public virtual string GetText();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlAttribute : VBCompositeElement {
    public static short IDENTIFIER;
    public static short WHITESPACE;
    public static short EQ;
    public static short XML_STRING;
    public static short EXPRESSION;
    public static short ATTRIBUTE;
    public NodeType NodeType { get; }
    public ITokenNode AttributeName { get; }
    public IVBTreeNode AttributeValue { get; }
    public IVBXmlEmbeddedExpression EmbeddedAttribute { get; }
    public ITokenNode EqSign { get; }
    public TreeNodeCollection`1<ITokenNode> Whitespace { get; }
    public TreeNodeEnumerable`1<ITokenNode> WhitespaceEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AttributeName();
    public virtual IVBTreeNode get_AttributeValue();
    public virtual IVBXmlEmbeddedExpression get_EmbeddedAttribute();
    public virtual ITokenNode get_EqSign();
    public virtual TreeNodeCollection`1<ITokenNode> get_Whitespace();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_WhitespaceEnumerable();
    public virtual IVBXmlEmbeddedExpression SetEmbeddedAttribute(IVBXmlEmbeddedExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlCDataSection : VBCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlComment : VBCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
}
[LanguageDefinitionAttribute("VB_XMLDOC")]
public class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlDocLanguage : XmlDocLanguage {
    public static string Name;
    [CompilerGeneratedAttribute]
private static VBXmlDocLanguage <Instance>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static VBXmlDocLanguage Instance { get; private set; }
    [CompilerGeneratedAttribute]
public static VBXmlDocLanguage get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(VBXmlDocLanguage value);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlDocument : VBCompositeElement {
    public static short XML_DOCUMENT_EXPR;
    public static short XML_DOCUMENT_BODY;
    public NodeType NodeType { get; }
    public IVBXmlElement XmlDocumentElement { get; }
    public IVBXmlEmbeddedExpression XmlDocumentExpression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBXmlElement get_XmlDocumentElement();
    public virtual IVBXmlEmbeddedExpression get_XmlDocumentExpression();
    public virtual IVBXmlElement SetXmlDocumentElement(IVBXmlElement param);
    public virtual IVBXmlEmbeddedExpression SetXmlDocumentExpression(IVBXmlEmbeddedExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlElement : VBCompositeElement {
    public static short XML_ELEMENT_HEADER;
    public static short TEXT;
    public static short XML_ELEMENT;
    public static short XML_EMBEDDED_EXPRESSION;
    public static short XML_FOOTER_HEADER;
    public NodeType NodeType { get; }
    public IVBXmlElementFooter ElementFooter { get; }
    public IVBXmlElementHeader ElementHeader { get; }
    public TreeNodeCollection`1<IVBXmlEmbeddedExpression> EmbeddedExpressios { get; }
    public TreeNodeEnumerable`1<IVBXmlEmbeddedExpression> EmbeddedExpressiosEnumerable { get; }
    public TreeNodeCollection`1<IVBXmlElement> NestedElements { get; }
    public TreeNodeEnumerable`1<IVBXmlElement> NestedElementsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Text { get; }
    public TreeNodeEnumerable`1<ITokenNode> TextEnumerable { get; }
    private bool IsEmptyElement { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBXmlElementFooter get_ElementFooter();
    public virtual IVBXmlElementHeader get_ElementHeader();
    public virtual TreeNodeCollection`1<IVBXmlEmbeddedExpression> get_EmbeddedExpressios();
    public virtual TreeNodeEnumerable`1<IVBXmlEmbeddedExpression> get_EmbeddedExpressiosEnumerable();
    public virtual TreeNodeCollection`1<IVBXmlElement> get_NestedElements();
    public virtual TreeNodeEnumerable`1<IVBXmlElement> get_NestedElementsEnumerable();
    public virtual TreeNodeCollection`1<ITokenNode> get_Text();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_TextEnumerable();
    public virtual IVBXmlElementFooter SetElementFooter(IVBXmlElementFooter param);
    public virtual IVBXmlElementHeader SetElementHeader(IVBXmlElementHeader param);
    public virtual string ToString();
    public sealed virtual IVBXmlElement AddElementAfter(IVBXmlElement element, IVBXmlElement anchor);
    public sealed virtual IVBXmlElement AddElementBefore(IVBXmlElement tag, IVBXmlElement anchor);
    public sealed virtual void RemoveElement(IVBXmlElement element);
    private bool get_IsEmptyElement();
    private void MakeCompound();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlElementFooter : VBCompositeElement {
    public static short TAG_START;
    public static short IDENTIFIER;
    public static short WHITESPACE;
    public static short TAG_END;
    public NodeType NodeType { get; }
    public ITokenNode Name { get; }
    public ITokenNode TagEnd { get; }
    public ITokenNode TagStart { get; }
    public TreeNodeCollection`1<ITokenNode> Whitespace { get; }
    public TreeNodeEnumerable`1<ITokenNode> WhitespaceEnumerable { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_Name();
    public virtual ITokenNode get_TagEnd();
    public virtual ITokenNode get_TagStart();
    public virtual TreeNodeCollection`1<ITokenNode> get_Whitespace();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_WhitespaceEnumerable();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlElementHeader : VBCompositeElement {
    public static short TAG_START;
    public static short IDENTIFIER;
    public static short EXPRESSION;
    public static short WHITESPACE;
    public static short XML_ATTRIBUTE;
    public static short TAG_END;
    public NodeType NodeType { get; }
    public TreeNodeCollection`1<IVBXmlAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IVBXmlAttribute> AttributesEnumerable { get; }
    public ITokenNode ElementName { get; }
    public IVBXmlEmbeddedExpression EmbeddedExpression { get; }
    public ITokenNode TagEnd { get; }
    public ITokenNode TagStart { get; }
    public TreeNodeCollection`1<ITokenNode> Whitespace { get; }
    public TreeNodeEnumerable`1<ITokenNode> WhitespaceEnumerable { get; }
    public bool IsClosed { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual TreeNodeCollection`1<IVBXmlAttribute> get_Attributes();
    public virtual TreeNodeEnumerable`1<IVBXmlAttribute> get_AttributesEnumerable();
    public virtual ITokenNode get_ElementName();
    public virtual IVBXmlEmbeddedExpression get_EmbeddedExpression();
    public virtual ITokenNode get_TagEnd();
    public virtual ITokenNode get_TagStart();
    public virtual TreeNodeCollection`1<ITokenNode> get_Whitespace();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_WhitespaceEnumerable();
    public virtual IVBXmlEmbeddedExpression SetEmbeddedExpression(IVBXmlEmbeddedExpression param);
    public virtual string ToString();
    public sealed virtual bool get_IsClosed();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlEmbeddedExpression : VBCompositeElement {
    public static short XML_SCRIPLET_START;
    public static short EXPRESSION;
    public static short XML_SCRIPLET_END;
    public NodeType NodeType { get; }
    public ITokenNode EmbeddedExpressionEnd { get; }
    public ITokenNode EmbeddedExpressionStart { get; }
    public IVBExpression Expression { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_EmbeddedExpressionEnd();
    public virtual ITokenNode get_EmbeddedExpressionStart();
    public virtual IVBExpression get_Expression();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlLiteralExpression : VBExpressionBase {
    public static short XML_DOCUMENT;
    public static short XML_CDATA;
    public NodeType NodeType { get; }
    public IVBXmlCDataSection XmlCData { get; }
    public IVBXmlDocument XmlDocument { get; }
    public LiteralExpressionType LiteralExpressionType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBXmlCDataSection get_XmlCData();
    public virtual IVBXmlDocument get_XmlDocument();
    public virtual IVBXmlCDataSection SetXmlCData(IVBXmlCDataSection param);
    public virtual IVBXmlDocument SetXmlDocument(IVBXmlDocument param);
    public virtual string ToString();
    public LiteralExpressionType get_LiteralExpressionType();
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlMemberAccessExpression : VBExpressionBase {
    public static short VB_QUALIFIER;
    public static short VB_OP_SIGN;
    public static short VB_DOT;
    public static short XML_IDENTIFIER;
    public static short AT;
    public static short VB_NAME;
    private VBXmlMemberAccessReference myReference;
    public NodeType NodeType { get; }
    public ITokenNode AtSign { get; }
    public IVBIdentifier AttributeName { get; }
    public IPrimaryExpression BaseExpression { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode Dot { get; }
    public ITokenNode Name { get; }
    public XmlMemberAccessType MemberAccessType { get; }
    [CanBeNullAttribute]
public IManagedReference Reference { get; }
    internal VBXmlMemberAccessReference ReferenceImpl { get; }
    public bool HasConditionalAccessSign { get; }
    public IVBExpression ConditionalQualifier { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual ITokenNode get_AtSign();
    public virtual IVBIdentifier get_AttributeName();
    public virtual IPrimaryExpression get_BaseExpression();
    public virtual IConditionalAccessSign get_ConditionalAccessSign();
    public virtual ITokenNode get_Dot();
    public virtual ITokenNode get_Name();
    public virtual IVBIdentifier SetAttributeName(IVBIdentifier param);
    public virtual IPrimaryExpression SetBaseExpression(IPrimaryExpression param);
    public virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public virtual string ToString();
    protected virtual void PreInit();
    public XmlMemberAccessType get_MemberAccessType();
    public sealed virtual IManagedReference get_Reference();
    public IExpressionType CalculateOriginalExpressionType(IResolveContext resolveContext);
    public virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public virtual ReferenceCollection GetFirstClassReferences();
    internal VBXmlMemberAccessReference get_ReferenceImpl();
    [CanBeNullAttribute]
public IVBExpression FindQualifierExpression();
    public sealed virtual bool get_HasConditionalAccessSign();
    public sealed virtual IVBExpression get_ConditionalQualifier();
    public sealed virtual void SetConditionalAccessSign(bool value);
    public sealed virtual IExpressionType UnliftedExpressionType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlMemberAccessReference : ManagedNonQualifiableReferenceBase`1<VBXmlMemberAccessExpression> {
    private static string ELEMENTS;
    private static string DESCENDANTS;
    private static string ATTRIBUTES;
    private XmlMemberAccessType myMemberAccessType;
    public VBXmlMemberAccessReference(VBXmlMemberAccessExpression owner, XmlMemberAccessType memberAccessType);
    public virtual string GetName();
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual TreeTextRange GetTreeTextRange();
    private MyFilterInstance GetInstanceFilter();
    private MyFilterExtensions GetExtensionsFilter();
    private bool CanApplyMethods(ITypeElement typeElement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlMisc : VBCompositeElement {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.VBXmlProcessingInstruction : VBCompositeElement {
    public NodeType NodeType { get; }
    public bool IsXmlProlog { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual string ToString();
    public sealed virtual bool get_IsXmlProlog();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.WhereQueryOperator : QueryOperatorBase {
    public static short WHERE_KEYWORD;
    public static short EXPRESSION;
    private WhereReferenceImpl myReference;
    public NodeType NodeType { get; }
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode WhereKeyword { get; }
    public ITokenNode FirstKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IQueryParameterPlatform get_Expression();
    public virtual ITokenNode get_WhereKeyword();
    public virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public virtual string ToString();
    protected virtual void PreInit();
    public virtual ReferenceCollection GetFirstClassReferences();
    public sealed virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
    public sealed virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public sealed virtual bool IsSelector();
    public virtual ITokenNode get_FirstKeyword();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.WhileStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXPRESSION;
    public static short VB_BLOCK;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode EndWhile { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode WhileKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndWhile();
    public virtual IVBExpression get_Expression();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITokenNode get_WhileKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.WhileUntilCondition : VBCompositeElement {
    public static short VB_KEYWORD;
    public static short EXPRESSION;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode Keyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_Keyword();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.Whitespace : VBWhiteSpaceTokenBase {
    public NodeType NodeType { get; }
    public Whitespace(string text);
    public virtual NodeType get_NodeType();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.WithStatement : StatementBase {
    public static short WITH_KEYWORD;
    public static short EXPRESSION;
    public static short VB_BLOCK;
    public static short VB_STATEMENT_TERMINATOR;
    public static short VB_END_DECLARATION;
    public NodeType NodeType { get; }
    public IBlock Block { get; }
    public ITokenNode EndWith { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode WithKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IBlock get_Block();
    public virtual ITokenNode get_EndWith();
    public virtual IVBExpression get_Expression();
    public virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public virtual ITokenNode get_WithKeyword();
    public virtual IBlock SetBlock(IBlock param);
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.VB.Impl.Tree.XmlMemberAccessType : Enum {
    public int value__;
    public static XmlMemberAccessType Elements;
    public static XmlMemberAccessType Descendants;
    public static XmlMemberAccessType Attribute;
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Tree.YieldStatement : StatementBase {
    public static short VB_KEYWORD;
    public static short EXPR;
    public NodeType NodeType { get; }
    public IVBExpression Expression { get; }
    public ITokenNode YieldKeyword { get; }
    public virtual NodeType get_NodeType();
    public virtual void Accept(TreeNodeVisitor visitor);
    public virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    public virtual short GetChildRole(TreeElement child);
    public virtual IVBExpression get_Expression();
    public virtual ITokenNode get_YieldKeyword();
    public virtual IVBExpression SetExpression(IVBExpression param);
    public virtual string ToString();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.VB.Impl.Types.ConversionKind : Enum {
    public int value__;
    public static ConversionKind FailedDueToNumericOverflow;
    public static ConversionKind FailedDueToIntegerOverflow;
    public static ConversionKind FailedDueToNumericOverflowMask;
    public static ConversionKind FailedDueToQueryLambdaBodyMismatch;
    public static ConversionKind FailedDueToArrayLiteralElementConversion;
    public static ConversionKind Widening;
    public static ConversionKind Narrowing;
    public static ConversionKind Identity;
    public static ConversionKind Numeric;
    public static ConversionKind WideningNumeric;
    public static ConversionKind NarrowingNumeric;
    public static ConversionKind Nullable;
    public static ConversionKind WideningNullable;
    public static ConversionKind NarrowingNullable;
    public static ConversionKind Reference;
    public static ConversionKind WideningReference;
    public static ConversionKind NarrowingReference;
    public static ConversionKind Array;
    public static ConversionKind WideningArray;
    public static ConversionKind NarrowingArray;
    public static ConversionKind TypeParameter;
    public static ConversionKind WideningTypeParameter;
    public static ConversionKind NarrowingTypeParameter;
    public static ConversionKind Value;
    public static ConversionKind WideningValue;
    public static ConversionKind NarrowingValue;
    public static ConversionKind String;
    public static ConversionKind WideningString;
    public static ConversionKind NarrowingString;
    public static ConversionKind Boolean;
    public static ConversionKind NarrowingBoolean;
    public static ConversionKind WideningNothingLiteral;
    public static ConversionKind InvolvesNarrowingFromNumericConstant;
    public static ConversionKind InvolvesEnumTypeConversions;
    public static ConversionKind Lambda;
    public static ConversionKind DelegateRelaxationLevelNone;
    public static ConversionKind DelegateRelaxationLevelWidening;
    public static ConversionKind DelegateRelaxationLevelWideningDropReturnOrArgs;
    public static ConversionKind DelegateRelaxationLevelWideningToNonLambda;
    public static ConversionKind DelegateRelaxationLevelNarrowing;
    public static ConversionKind DelegateRelaxationLevelInvalid;
    public static ConversionKind DelegateRelaxationLevelMask;
    public static ConversionKind VarianceConversionAmbiguity;
    public static ConversionKind MightSucceedAtRuntime;
    public static ConversionKind AnonymousDelegate;
    public static ConversionKind NeedAStub;
    public static ConversionKind ConvertedToExpressionTree;
    public static ConversionKind UserDefined;
    public static ConversionKind NarrowingDueToContraVarianceInDelegate;
    public static ConversionKind InterpolatedString;
    public static ConversionKind Tuple;
    public static ConversionKind WideningTuple;
    public static ConversionKind NarrowingTuple;
    public static ConversionKind WideningNullableTuple;
    public static ConversionKind NarrowingNullableTuple;
}
public static class JetBrains.ReSharper.Psi.VB.Impl.Types.Conversions : object {
    public static bool IsWideningConversionExist(IType from, IType to, IVBTypeConversionRule rule);
    public static bool IsNarrowingConversionExist(IType from, IType to, bool noWideningConversionKnown, IVBTypeConversionRule rule);
    private static bool IsNarrowingConversionSpecific(IType from, IType to, bool noWideningConversionKnown, IVBTypeConversionRule rule, Func`5<IType, IType, bool, IVBTypeConversionRule, bool> conversion);
    public static bool IsWideningConversionSpecific(IType from, IType to, IVBTypeConversionRule rule, Func`4<IType, IType, IVBTypeConversionRule, bool> conversion);
    public static bool IsFunctionTypeConvertible(DecoratedType`1<VBFunctionTypeDecoration> functionType, IType to, ITypeConversionRule rule);
    private static IDelegate GetDelegateType(IType type, ISubstitution& substitution);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("type:null => null")]
public static IDelegate GetDelegateTypeThroughExpression(IType type, ISubstitution& substitution);
    public static bool IsWideningAnonymousTypeConversion(IVBAnonymousType anonymousType, IType to);
    private static bool IsWideningArrayConversion(IType from, IType to, IPsiModule module);
    public static bool IsReferenceConversion(IType from, IType to);
    private static bool IsWideningConversionPredefinedFullForTuples(IType from, IType to, IVBTypeConversionRule rule, Func`3<IType, IType, bool> conversion);
    public static bool IsWideningConversionPredefinedFull(IType from, IType to, IVBTypeConversionRule rule);
    public static bool IsWideningConversionPredefined(IType from, IType to, IPsiModule module);
    private static bool IsTupleConvertible(DecoratedType`1<TupleTypeDecoration> fromTupleType, DecoratedType`1<TupleTypeDecoration> toTupleType, IVBTypeConversionRule rule, Func`5<IType, IType, bool, IVBTypeConversionRule, bool> conversion, bool noWideningConversionKnown);
    private static bool IsInterpolatedStringConversionExist(IType to, IPsiModule module, IVBTypeConversionRule rule, Func`4<IVBTypeConversionRule, IExpressionType, IType, bool> conversion);
    private static bool IsTupleConversionExist(VBTupleExpressionType tupleExpressionType, IType to, IVBTypeConversionRule rule, Func`4<IVBTypeConversionRule, IExpressionType, IType, bool> conversion);
    private static bool IsWideningConstantConversionExist(IVBConstantType constantType, IType to, IVBTypeConversionRule rule, Func`4<IVBTypeConversionRule, IExpressionType, IType, bool> conversion);
    private static bool IsNarrowingConstantConversionExist(IVBConstantType constantType, IType to, IVBTypeConversionRule rule, Func`4<IVBTypeConversionRule, IExpressionType, IType, bool> conversion);
    private static bool IsMethodGroupConversionExist(VBMethodGroupType methodGroupType, IType to, IVBTypeConversionRule rule);
    private static bool IsLambdaConversionExist(IVBLambdaExpressionType lambdaExpressionType, IType to, Func`3<IExpressionType, IType, bool> conversion, IVBTypeConversionRule rule);
    public static bool IsLambdaSignatureConvertible(IVBLambdaExpressionType lambda, IDelegate delegate, ISubstitution delegateSubstitution, Func`3<IExpressionType, IType, bool> conversion);
    public static bool IsLambdaReturnTypeConvertible(IVBLambdaExpressionType lambda, IDelegate delegate, ISubstitution delegateSubstitution, Func`3<IExpressionType, IType, bool> conversion);
    private static bool IsAnonymousArrayConversionExist(IVBAnonymousArrayType from, IType to, IVBTypeConversionRule rule, Func`4<IVBTypeConversionRule, IExpressionType, IType, bool> conversion, Func`4<IVBTypeConversionRule, IExpressionType, IType, bool> conversion2);
    private static bool ImplicitVariantConvertible(IDeclaredType declaredFrom, IDeclaredType declaredTo);
    public static bool IsNarrowingConversionPredefinedFull(IType from, IType to, bool noWideningConversionKnown, IVBTypeConversionRule rule);
    public static bool IsNarrowingConversionPredefined(IType from, IType to, bool noWideningConversionKnown, IPsiModule module);
    public static bool IsWideningConversionUserDefined(IExpressionType from, IType to, IVBTypeConversionRule rule);
    public static bool IsNarrowingConversionUserDefined(IExpressionType from, IType to, IVBTypeConversionRule rule);
    [CanBeNullAttribute]
public static IType ToITypeWithNothing(IExpressionType expressionType, IPsiModule module);
    private static bool NumericWideningExists(IPsiModule module, IType from, IType to);
    private static bool IsSubTypeForDeclaredTypes(IType from, IType to);
    private static bool IsSimplePredefinedExceptChar(IType type);
    public static bool IsNarrowingConversionFromExpressionExist(IExpressionType from, IType to, IVBTypeConversionRule rule, bool predefined);
    public static bool IsWideningConversionFromExpressionExist(IExpressionType from, IType to, IVBTypeConversionRule rule, bool predefined);
    private static void UnliftTypes(IType& source, IType& target);
    public static IList`1<DeclaredElementInstance`1<IConversionOperator>> GetWideningConversionOperators(IDeclaredType declaredType, IExpressionType from, IType to, IVBTypeConversionRule rule);
    public static IList`1<DeclaredElementInstance`1<IConversionOperator>> GetNarrowingConversionOperators(IDeclaredType declaredType, IExpressionType from, IType to, IVBTypeConversionRule rule);
    private static IList`1<DeclaredElementInstance`1<IConversionOperator>> GetConversionOperators(IDeclaredType type, IExpressionType from, IType to, string operatorName, Func`4<IVBTypeConversionRule, IExpressionType, IType, bool> conversion, IVBTypeConversionRule rule);
    private static bool CheckCustomConversionValidity(IExpressionType source, IType target);
    private static DeclaredElementInstance`1<IConversionOperator> ResolveMultipleOperators(IList`1<DeclaredElementInstance`1<IConversionOperator>> operators, IType from, IType to, IVBTypeConversionRule rule);
    public static ConversionKind ClassifyIdentityConversion(IType from, IType to);
    private static ConversionKind ClassifyValueTypeConversion(IType from, IType to);
    public static bool ConversionExists(ConversionKind conversion);
    public static bool IsWideningConversion(ConversionKind conversion);
    public static ConversionKind ClassifyDirectCastConversion(IType from, IType to, IPsiModule psiModule);
    public static ConversionKind ClassifyTryCastConversion(IExpressionType fromExpressionType, IType to, IVBTypeConversionRule rule);
    private static ConversionKind ClassifyExpressionReclassification(IExpressionType fromExpressionType, IType to, IVBTypeConversionRule rule);
    private static ConversionKind ClassifyNothingLiteralConversion(IVBNothingType nothingType, IType to);
    public static ConversionKind ClassifyTryCastConversion(IType from, IType to, IPsiModule module);
    private static ConversionKind ClassifyTryCastConversionForTypeParameters(IType from, IType to, IPsiModule module);
    private static bool ClassOrBaseSatisfyConstraint(IType class, ITypeParameter typeParameter);
    private static IType GetNonInterfaceTypeConstraintOrSelf(IType type, PredefinedType predefinedType);
    [CompilerGeneratedAttribute]
internal static bool <IsAnonymousArrayConversionExist>g__IsEnumerableOrCollection|22_0(IType type);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.DeclaredTypeFromReferenceName : DeclaredTypeBase {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IPsiModule myPsiModule;
    [NotNullAttribute]
private IResolveResult myResolveResult;
    [CanBeNullAttribute]
private string myUnresolvedPresentation;
    [CanBeNullAttribute]
private IList`1<IType> myUnresolvedPresentationTypeArgs;
    [CompilerGeneratedAttribute]
private TypeDecorationSet <TypeDecorations>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public DeclaredTypeFromReferenceName(IReferenceName referenceName, IResolveResult result);
    public virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public virtual TypeDecorationSet get_TypeDecorations();
    public virtual IPsiServices GetPsiServices();
    protected virtual IResolveResult Resolve(IModuleReferenceResolveContext resolveContext);
    protected virtual IResolveResult ResolveNoRetargeting();
    public virtual bool IsValid();
    protected virtual ITypeElement GetTypeElement(IModuleReferenceResolveContext resolveContext);
    protected virtual ITypeElement GetTypeElementNoRetargeting();
    protected virtual RichText GetUnresolvedPresentation(NullableAnnotation nullableAnnotation, ITypePresenter presenter, TypePresentationStyle typePresentationStyle);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.FunctionBlockLambdaExpressionType : TreeLambdaExpressionType {
    private IBlock myBody;
    private IType myReturnType;
    public IType DeclaredReturnType { get; }
    public IVBTreeNode VerificationScope { get; }
    public FunctionBlockLambdaExpressionType(IResolveContext resolveContext, ILambdaFunctionExpression lambdaExpression);
    public FunctionBlockLambdaExpressionType(IResolveContext resolveContext, IList`1<ILambdaParameter> parameters, IBlock body, IType returnType, bool isAsync, bool isIterator);
    public virtual IReadOnlyList`1<IExpressionType> GetReturnValues();
    public virtual IType get_DeclaredReturnType();
    protected virtual IExpressionType InferResultType();
    public virtual IVBTreeNode get_VerificationScope();
    public virtual bool IsValid();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.FunctionLambdaExpressionType : TreeLambdaExpressionType {
    private IVBExpression myBody;
    public IVBTreeNode VerificationScope { get; }
    public FunctionLambdaExpressionType(IResolveContext resolveContext, IList`1<ILambdaParameter> parameters, IVBExpression body, bool isAsync, bool isIterator);
    public virtual IVBTreeNode get_VerificationScope();
    protected virtual IExpressionType InferResultType();
    public virtual bool IsValid();
}
internal abstract class JetBrains.ReSharper.Psi.VB.Impl.Types.ResultTypeCollectorBase : TreeNodeVisitor {
    protected IResolveContext myResolveContext;
    protected List`1<IExpressionType> myCollectedTypes;
    public IReadOnlyList`1<IExpressionType> CollectedTypes { get; }
    public bool ProcessingIsFinished { get; }
    protected ResultTypeCollectorBase(IResolveContext resolveContext);
    public IReadOnlyList`1<IExpressionType> get_CollectedTypes();
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.ReturnTypeCollector : ResultTypeCollectorBase {
    public ReturnTypeCollector(IResolveContext resolveContext);
    public virtual void VisitReturnStatement(IReturnStatement returnStatement);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.StrictPolicy : ValueType {
    private bool myIsStrictOff;
    private Kind myValue;
    public bool IsStrictOff { get; }
    internal bool IsStrictnessFailed { get; }
    internal bool IsLateBound { get; }
    internal bool IsFailed { get; }
    public StrictPolicy(bool strictOff);
    public bool get_IsStrictOff();
    internal void Fail(IType fromType);
    internal bool get_IsStrictnessFailed();
    internal bool get_IsLateBound();
    internal bool get_IsFailed();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.SubLambdaExpressionType : TreeLambdaExpressionType {
    private IVBTreeNode myBody;
    public IType DeclaredReturnType { get; }
    public IVBTreeNode VerificationScope { get; }
    public SubLambdaExpressionType(IResolveContext resolveContext, IList`1<ILambdaParameter> parameters, IVBTreeNode body, bool isAsync, bool isIterator);
    protected virtual IExpressionType InferResultType();
    public virtual IType get_DeclaredReturnType();
    public virtual IVBTreeNode get_VerificationScope();
    public virtual bool IsValid();
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Types.TreeLambdaExpressionType : VBLambdaExpressionTypeBase {
    private IList`1<ILambdaParameter> myParameters;
    [CompilerGeneratedAttribute]
private bool <IsIterator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public bool IsIterator { get; }
    public bool IsAsync { get; }
    public IList`1<string> ParameterNames { get; }
    protected TreeLambdaExpressionType(IResolveContext resolveContext, IList`1<ILambdaParameter> parameters, bool isAsync, bool isIterator);
    [CompilerGeneratedAttribute]
public virtual bool get_IsIterator();
    [CompilerGeneratedAttribute]
public virtual bool get_IsAsync();
    public IList`1<string> get_ParameterNames();
    public virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> GetParameterTypesAndKinds();
    public virtual IType CreateFunctionType();
    public virtual IReadOnlyList`1<ILambdaParameter> GetImplicitLambdaParameters();
    public virtual bool HasImplicitLambdaParameters();
    public virtual bool IsValid();
    [CompilerGeneratedAttribute]
private Pair`2<IType, ParameterKind> <GetParameterTypesAndKinds>b__10_0(ILambdaParameter x);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.VBAnonymousArrayType : object {
    protected IAnonymousArrayCreationExpression myElement;
    protected IExpressionType[] myElementsExpressionTypes;
    public IReadOnlyList`1<IExpressionType> ElementsExpressionTypes { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public VBAnonymousArrayType(IAnonymousArrayCreationExpression element, IExpressionType[] elementsExpressionTypes);
    public sealed virtual bool IsEmpty();
    public sealed virtual int Rank();
    public sealed virtual IReadOnlyList`1<IExpressionType> get_ElementsExpressionTypes();
    public sealed virtual IType ToIType();
    [NotNullAttribute]
private IType ToITypeInternal();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.VBAnonymousType : object {
    [NotNullAttribute]
private IPsiModule myPsiModule;
    [NotNullAttribute]
private IList`1<AnonymousTypeDescriptor> myDescriptor;
    [CanBeNullAttribute]
private IVBAnonymousTypeProperty[] myProperties;
    public bool CaseSensitive { get; }
    public IList`1<AnonymousTypeDescriptor> TypeDescriptor { get; }
    public IList`1<IVBAnonymousTypeProperty> Properties { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    internal VBAnonymousType(IPsiModule module, IList`1<AnonymousTypeDescriptor> descriptor);
    public sealed virtual bool get_CaseSensitive();
    public sealed virtual IList`1<AnonymousTypeDescriptor> get_TypeDescriptor();
    public virtual IList`1<IVBAnonymousTypeProperty> get_Properties();
    public virtual bool Equals(object obj);
    public virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public virtual int GetHashCode();
    public sealed virtual bool get_IsOpenType();
    public sealed virtual TypeClassification get_Classify();
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual ITypePointer CreatePointer();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual IType WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IType WithNullableAnnotation(NullableAnnotation annotation);
    public sealed virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
    public sealed virtual void Accept(TypeVisitor typeVisitor);
    public sealed virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    public sealed virtual IDeclaredType GetScalarType();
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IPsiServices GetPsiServices();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.VBAnonymousType3 : VBAnonymousType {
    private IList`1<IVBAnonymousTypeProperty> myProperties;
    public IList`1<IVBAnonymousTypeProperty> Properties { get; }
    public VBAnonymousType3(IPsiModule module, IList`1<AnonymousTypeDescriptor> descriptor, IList`1<IVBAnonymousTypeProperty> properties);
    public virtual IList`1<IVBAnonymousTypeProperty> get_Properties();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.VBAnonymousTypeProperty : object {
    [NotNullAttribute]
private AnonymousMemberDeclaration myDeclaration;
    [NotNullAttribute]
private CachedPsiValue`1<IType> myCachedType;
    [NotNullAttribute]
public IAnonymousMemberDeclaration PropertyDeclaration { get; }
    public bool IsKey { get; }
    private IAnonymousType JetBrains.ReSharper.Psi.IAnonymousTypeProperty.ContainingType { get; }
    public IVBAnonymousType ContainingType { get; }
    public int Index { get; }
    public IList`1<AnonymousTypePropertyDescriptor> AnonymousTypePropertyDescriptor { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public IType Type { get; }
    private IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.CachedType { get; private set; }
    public VBAnonymousTypeProperty(AnonymousMemberDeclaration declaration);
    public sealed virtual IAnonymousMemberDeclaration get_PropertyDeclaration();
    public sealed virtual bool get_IsKey();
    private sealed virtual override IAnonymousType JetBrains.ReSharper.Psi.IAnonymousTypeProperty.get_ContainingType();
    public sealed virtual IVBAnonymousType get_ContainingType();
    public sealed virtual int get_Index();
    public sealed virtual IList`1<AnonymousTypePropertyDescriptor> get_AnonymousTypePropertyDescriptor();
    public sealed virtual IAnonymousTypeProperty SetName(string name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IType get_Type();
    public sealed virtual IType CalculateType(IResolveContext resolveContext);
    public virtual string ToString();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.get_CachedType();
    private sealed virtual override void JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl.set_CachedType(IType value);
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.VBConstantType : object {
    private ConstantValue myValue;
    private IPsiModule myPsiModule;
    public IPsiModule Module { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public VBConstantType(ConstantValue value, IPsiModule module);
    public sealed virtual IType GetDefaultType();
    public sealed virtual ConstantValue GetConstantValue();
    public sealed virtual bool IsPureZeroType();
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.VBInvocationType : object {
    private IPsiModule myModule;
    private InvocationResolveResult myInvocationResolveResult;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public IResolveResult InvocationResult { get; }
    public VBInvocationType(IPsiModule module, InvocationResolveResult invocationResolveResult);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool IsValid();
    public sealed virtual IVBMethodGroupType CreateMethodGroupType(IResolveContext resolveContext, VBLanguageLevel languageLevel);
    public IResolveResult get_InvocationResult();
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Types.VBLambdaExpressionTypeBase : object {
    [NotNullAttribute]
protected IResolveContext myResolveContext;
    public IPsiModule Module { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public IVBTreeNode VerificationScope { get; }
    public IType DeclaredReturnType { get; }
    public bool IsNonCacheable { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    protected VBLambdaExpressionTypeBase(IResolveContext resolveContext);
    public sealed virtual IPsiModule get_Module();
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsIterator();
    public sealed virtual IType ToIType();
    public abstract virtual IVBTreeNode get_VerificationScope();
    public abstract virtual IReadOnlyList`1<ILambdaParameter> GetImplicitLambdaParameters();
    public abstract virtual bool HasImplicitLambdaParameters();
    public abstract virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> GetParameterTypesAndKinds();
    public abstract virtual IType CreateFunctionType();
    protected abstract virtual IExpressionType InferResultType();
    public virtual IReadOnlyList`1<IExpressionType> GetReturnValues();
    public virtual IType get_DeclaredReturnType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsNonCacheable();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public abstract virtual bool IsValid();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.VBMethodGroupType : object {
    private IResolveContext myResolveContext;
    private MethodGroupResolveResult myResolveResult;
    private VBLanguageLevel myLanguageLevel;
    public IPsiModule Module { get; }
    public bool IsNonCacheable { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public VBMethodGroupType(ExtensionInstance`1<IMethod> method, IVBTreeNode context);
    public VBMethodGroupType(IList`1<ExtensionInstance`1<IMethod>> methods, string name, IVBExpression expression);
    public VBMethodGroupType(IResolveContext resolveContext, MethodGroupResolveResult resolveResult, VBLanguageLevel languageLevel);
    public bool IsConvertibleTo(IDelegate delegate, ISubstitution substitution, IVBTypeConversionRule rule);
    public ResolveResultWithInfo ResolveWithDelegate(IDelegate delegate, ISubstitution substitution, IVBTypeConversionRule rule);
    private bool IsApplicableToDelegateVB9(IDelegate delegate, ISubstitution delegateSubstitution, IVBTypeConversionRule rule);
    private bool IsApplicableToDelegateVB8(IDelegate delegate, ISubstitution delegateSubstitution);
    internal static bool IsApplicableToDelegate(IMethod method, ISubstitution methodSubstitution, bool isExtension, IDelegate delegate, ISubstitution delegateSubstitution, IVBTypeConversionRule rule, VBLanguageLevel languageLevel);
    private static bool IsApplicableToDelegateVB9(IMethod method, ISubstitution methodSubstitution, bool isExtension, IDelegate delegate, ISubstitution delegateSubstitution, IVBTypeConversionRule rule, VBLanguageLevel languageLevel);
    private static bool IsApplicableToDelegateVB8(IMethod method, ISubstitution methodSubstitution, IDelegate delegate, ISubstitution delegateSubstitution);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IType ReturnTypeWithDelegate(IDelegate delegate, ISubstitution delegateSubstitution);
    public sealed virtual DeclaredElementInstance`1<IMethod> ResolveWithDelegate(IDelegate delegate, ISubstitution delegateSubstitution);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsNonCacheable();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.VBNonCacheableAnonymousArrayType : VBAnonymousArrayType {
    public bool IsNonCacheable { get; }
    public VBNonCacheableAnonymousArrayType(IAnonymousArrayCreationExpression element, IExpressionType[] elementsExpressionTypes);
    public sealed virtual bool get_IsNonCacheable();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.VBNonStrictTypeConversionRule : VBTypeConversionRuleBase {
    internal VBNonStrictTypeConversionRule(IPsiModule module);
    public virtual void SetStrictOffConversionIsUsed();
    public virtual bool IsImplicitlyConvertibleTo(IType from, IType to);
    public virtual bool IsExplicitlyConvertibleTo(IType from, IType to);
    public virtual bool IsImplicitlyConvertiblePredefined(IType from, IType to);
    public virtual bool IsExplicitlyConvertiblePredefined(IType from, IType to);
    public virtual bool IsImplicitlyConvertibleTo(IExpressionType from, IType to);
    public virtual bool IsExplicitlyConvertibleTo(IExpressionType from, IType to);
    public virtual bool IsImplicitlyConvertiblePredefined(IExpressionType from, IType to);
    public virtual bool IsExplicitlyConvertiblePredefined(IExpressionType from, IType to);
    public virtual bool IsImplicitlyConvertibleUserDefined(IExpressionType from, IType to);
    public virtual bool IsExplicitlyConvertibleUserDefined(IExpressionType from, IType to);
    public virtual bool HasStandardImplicitConversion(IType from, IType to);
    public virtual bool HasExtensionMethodThisArgumentConversion(IType from, IType to, ParameterKind thisParameterKind);
    public virtual bool HasIdentityConversion(IType from, IType to);
    protected virtual VBNonStrictTypeConversionRuleWithPolicy GetRuleWithPolicy();
    public virtual ConversionClassification IsImplicitlyConvertibleToClassify(IExpressionType from, IType to);
    public virtual bool IsStrictOff();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.VBNonStrictTypeConversionRuleWithPolicy : VBNonStrictTypeConversionRule {
    [CompilerGeneratedAttribute]
private bool <IsStrictOffConversionUsed>k__BackingField;
    public bool IsStrictOffConversionUsed { get; private set; }
    internal VBNonStrictTypeConversionRuleWithPolicy(IPsiModule module);
    [CompilerGeneratedAttribute]
public bool get_IsStrictOffConversionUsed();
    [CompilerGeneratedAttribute]
private void set_IsStrictOffConversionUsed(bool value);
    public virtual void SetStrictOffConversionIsUsed();
    protected virtual VBNonStrictTypeConversionRuleWithPolicy GetRuleWithPolicy();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.VBNothingType : object {
    private IPsiModule myPsiModule;
    public IPsiModule Module { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public VBNothingType(IPsiModule module);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.VBStrictTypeConversionRule : VBTypeConversionRuleBase {
    internal VBStrictTypeConversionRule(IPsiModule module);
    public virtual bool IsImplicitlyConvertibleTo(IType from, IType to);
    public virtual bool IsExplicitlyConvertibleTo(IType from, IType to);
    public virtual bool IsImplicitlyConvertiblePredefined(IType from, IType to);
    public virtual bool IsExplicitlyConvertiblePredefined(IType from, IType to);
    public virtual bool IsImplicitlyConvertibleTo(IExpressionType from, IType to);
    public virtual bool IsExplicitlyConvertibleTo(IExpressionType from, IType to);
    public virtual bool IsImplicitlyConvertiblePredefined(IExpressionType from, IType to);
    public virtual bool IsExplicitlyConvertiblePredefined(IExpressionType from, IType to);
    public virtual bool IsImplicitlyConvertibleUserDefined(IExpressionType from, IType to);
    public virtual bool IsExplicitlyConvertibleUserDefined(IExpressionType from, IType to);
    public virtual bool HasStandardImplicitConversion(IType from, IType to);
    public virtual bool HasExtensionMethodThisArgumentConversion(IType from, IType to, ParameterKind thisParameterKind);
    public virtual bool HasIdentityConversion(IType from, IType to);
    public virtual ConversionClassification IsImplicitlyConvertibleToClassify(IExpressionType from, IType to);
    public virtual bool IsStrictOff();
}
public class JetBrains.ReSharper.Psi.VB.Impl.Types.VBTupleExpressionType : TupleExpressionTypeBase {
    public VBTupleExpressionType(IPsiModule module, TupleExpressionTypeComponent[] component);
    protected virtual IType GetIType(IExpressionType type);
}
public abstract class JetBrains.ReSharper.Psi.VB.Impl.Types.VBTypeConversionRuleBase : object {
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    public IPsiModule Module { get; }
    public IEqualityComparer`1<IType> EqualityComparer { get; }
    protected VBTypeConversionRuleBase(IPsiModule module);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual IEqualityComparer`1<IType> get_EqualityComparer();
    public abstract virtual bool IsImplicitlyConvertibleTo(IType from, IType to);
    public abstract virtual bool IsExplicitlyConvertibleTo(IType from, IType to);
    public abstract virtual bool IsImplicitlyConvertiblePredefined(IType from, IType to);
    public abstract virtual bool IsExplicitlyConvertiblePredefined(IType from, IType to);
    public abstract virtual bool IsImplicitlyConvertibleTo(IExpressionType from, IType to);
    public abstract virtual bool IsExplicitlyConvertibleTo(IExpressionType from, IType to);
    public abstract virtual bool IsImplicitlyConvertiblePredefined(IExpressionType from, IType to);
    public abstract virtual bool IsExplicitlyConvertiblePredefined(IExpressionType from, IType to);
    public abstract virtual bool IsImplicitlyConvertibleUserDefined(IExpressionType from, IType to);
    public abstract virtual bool IsExplicitlyConvertibleUserDefined(IExpressionType from, IType to);
    public abstract virtual bool HasStandardImplicitConversion(IType from, IType to);
    public abstract virtual bool HasExtensionMethodThisArgumentConversion(IType from, IType to, ParameterKind thisParameterKind);
    public abstract virtual bool HasIdentityConversion(IType from, IType to);
    public abstract virtual ConversionClassification IsImplicitlyConvertibleToClassify(IExpressionType from, IType to);
    public abstract virtual bool IsStrictOff();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.Types.YieldTypeCollector : ResultTypeCollectorBase {
    public YieldTypeCollector(IResolveContext resolveContext);
    public virtual void VisitYieldStatement(IYieldStatement yieldStatement);
}
public class JetBrains.ReSharper.Psi.VB.Impl.UsingRegionsInspector : object {
    [NotNullAttribute]
private IRegionStructure myRegionStructure;
    public UsingRegionsInspector(IRegionStructure regionStructure);
    public sealed virtual ITreeRange FindUsingListStartBorder();
    public sealed virtual ITreeRange FindUsingListEndBorder();
    public sealed virtual Nullable`1<bool> IsContainingPreprocessorRegionRecommended(ITreeNode treeNode);
    public sealed virtual ICodeRegion FindStartAnchorRegion(ITreeNode anchorImport);
    public sealed virtual ICodeRegion FindEndAnchorRegion(ITreeNode anchorImport);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBAnonymousTypeSearcher : object {
    private IList`1<AnonymousTypeDescriptor> myTypeDescription;
    public VBAnonymousTypeSearcher(IList`1<AnonymousTypeDescriptor> typeDescription);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    private bool EqualsDescriptor(IList`1<AnonymousTypeDescriptor> descriptor);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBAttributeInstance : object {
    [NotNullAttribute]
private IAttribute myAttribute;
    [NotNullAttribute]
public IAttribute Attribute { get; }
    public IConstructor Constructor { get; }
    public int PositionParameterCount { get; }
    public int NamedParameterCount { get; }
    public VBAttributeInstance(IAttribute attribute);
    public IAttribute get_Attribute();
    public sealed virtual IDeclaredType GetAttributeType();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual string GetAttributeShortName();
    public sealed virtual IConstructor get_Constructor();
    private static AttributeValue GetAttributeValue(IVBExpression value, IType targetType);
    public sealed virtual int get_PositionParameterCount();
    public sealed virtual AttributeValue PositionParameter(int paramIndex);
    public sealed virtual IEnumerable`1<AttributeValue> PositionParameters();
    private AttributeValue[] GetPositionalParameters();
    private static AttributeValue GetAttributeValue(INamedArgument namedArgument);
    public sealed virtual int get_NamedParameterCount();
    public sealed virtual AttributeValue NamedParameter(string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.VBAttributeInstance/<NamedParameters>d__19")]
public sealed virtual IEnumerable`1<Pair`2<string, AttributeValue>> NamedParameters();
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBCodeAnnotationProvider : object {
    public sealed virtual Nullable`1<CodeAnnotationNullableValue> GetNullableAttribute(IDeclaredElement element);
    public sealed virtual Nullable`1<CodeAnnotationNullableValue> GetContainerElementNullableAttribute(IDeclaredElement element);
    public sealed virtual ICollection`1<IAttributeInstance> GetSpecialAttributeInstances(IClrDeclaredElement element, AttributeInstanceCollection attributeInstanceCollection);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBConstructorSpecialReferenceSearcher : object {
    private JetHashSet`1<IConstructor> myConstructors;
    public VBConstructorSpecialReferenceSearcher(IEnumerable`1<IConstructor> constructors);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
}
[DeclaredElementIconProviderAttribute("0", "16")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBDeclaredElementImageProvider : object {
    public sealed virtual IconId GetImageId(IDeclaredElement declaredElement, PsiLanguageType languageType, Boolean& canApplyExtensions);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.VB.Impl.VBDeclaredElementPresenter : object {
    [NotNullAttribute]
public static VBDeclaredElementPresenter Instance { get; }
    public static VBDeclaredElementPresenter get_Instance();
    public virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement declaredElement, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    [NotNullAttribute]
public virtual string Format(ParameterKind parameterKind);
    [NotNullAttribute]
public virtual string Format(AccessRights accessRights);
    private static bool ShowParameterList(IDeclaredElement element, DeclaredElementPresenterStyle style);
    [NotNullAttribute]
private static RichText GetQualifiedNameRichText(DeclaredElementPresenterStyle presenter, ITypeElement typeElement, ISubstitution substitution, bool appendOwnTypeParameters);
    [NotNullAttribute]
private static RichText GetNestedTypeNameRichText(DeclaredElementPresenterStyle presenter, ITypeElement typeElement, ISubstitution substitution, bool appendOwnTypeParameters);
    [NotNullAttribute]
private static RichText GetTypeParametersRichText(DeclaredElementPresenterStyle presenter, IList`1<ITypeParameter> typeParameters, ISubstitution substitution, int currentLength, TextRange[]& typeParameterRanges);
    private static bool CheckIsMember(IDeclaredElement declaredElement);
    private static bool CheckIsType(IDeclaredElement declaredElement);
    private static bool CheckIsNamespace(IDeclaredElement element);
    private static TextRange AppendString(RichText sb, string substr, TextStyle textStyle);
    private static TextRange AppendRichText(RichText sb, RichText substr);
    public virtual string GetEntityKind(IDeclaredElement declaredElement);
    [PureAttribute]
[NotNullAttribute]
public static string AccessorName(AccessorKind accessorKind);
    [NotNullAttribute]
private static string GetElementNameStr(IDeclaredElement declaredElement, DeclaredElementPresenterStyle style);
    [NotNullAttribute]
private static string GetConstantValueStr(IDeclaredElement element, ISubstitution substitution);
    [CanBeNullAttribute]
private static IType GetElementType(IDeclaredElement declaredElement, ISubstitution substitution);
    [NotNullAttribute]
private static string GetParameterKindStr(DeclaredElementPresenterStyle presenter, IParameter parameter);
    [NotNullAttribute]
private static RichText GetElementTypeRichText(DeclaredElementPresenterStyle presenter, IDeclaredElement declaredElement, ISubstitution substitution, TextRange& scalarRange);
    private static void FormatInvocableParameter(DeclaredElementPresenterStyle style, IParameter param, RichText richText, ISubstitution substitution, Parameter& range);
    [NotNullAttribute]
private static string GetParameterDefaultValueStr(IParameter parameter, ISubstitution substitution);
    [NotNullAttribute]
private static RichText GetParametersListRichText(DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, Parameter[]& ranges);
    [NotNullAttribute]
private RichText GetContainerRichText(DeclaredElementPresenterStyle presenter, IDeclaredElement declaredElement, ISubstitution substitution, TextRange& containerNameRange);
    [NotNullAttribute]
private static IList`1<ITypeParameter> GetTypeParameters(IDeclaredElement declaredElement);
    private static bool HasTypeParameters(ITypeElement element);
    [NotNullAttribute]
private RichText FormatAnonymousMethod(DeclaredElementPresenterStyle style, IAnonymousMethod anonymousMethod, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
}
public class JetBrains.ReSharper.Psi.VB.Impl.VBDeclaredElementType : DeclaredElementTypeBase {
    public static DeclaredElementType ANONYMOUS_METHOD;
    protected IDeclaredElementPresenter DefaultPresenter { get; }
    private VBDeclaredElementType(string name, IconId imageName);
    private static VBDeclaredElementType();
    protected virtual IDeclaredElementPresenter get_DefaultPresenter();
    public virtual bool IsPresentable(PsiLanguageType language);
}
public class JetBrains.ReSharper.Psi.VB.Impl.VBElementFactoryImpl : VBElementFactory {
    private LanguageService myLanguageService;
    private IPsiServices myPsiServices;
    private IPsiModule myModule;
    private ISolution mySolution;
    private bool myApplyCodeFormatter;
    private VBLanguageLevelProjectProperty myVbLanguageLevelProjectProperty;
    private static string ConstantsClrName;
    private bool IsVB9Supported { get; }
    public VBElementFactoryImpl(IPsiModule module, bool applyCodeFormatter);
    private VBElementFactoryImpl(IPsiModule module, ISolution solution, bool applyCodeFormatter);
    private IVBParser CreateParser(string text);
    private bool get_IsVB9Supported();
    private ParameterMarker[] ParseFormatString(String& format, Object[] args);
    public virtual IModuleDeclaration CreateModuleDeclaration(string name);
    public static string ObfuscateVBIdentifier(string name);
    [CanBeNullAttribute]
private T ExtractNode(T element);
    private static TNodeType FindNodeAtRangeByType(ITreeNode node);
    [NotNullAttribute]
private ITreeNode SubstituteNodes(ITreeNode root, ParameterMarker[] markers, Object[] args);
    public virtual IVBFile CreateFile(string text, Object[] args);
    public virtual IVBTypeMemberDeclaration CreateTypeMemberDeclaration(string format, bool inInterface, Object[] args);
    public virtual IConstructorDeclaration CreateConstructorDeclaration();
    public virtual IVBStatement CreateStatement(string format, Object[] args);
    public virtual IVBArgument CreateArgument(IVBExpression arg);
    public virtual IVBExpression CreateExpressionAsIs(string format);
    public virtual IVBExpression CreateExpression(string expr, Object[] args);
    public virtual ITypeUsage CreateTypeUsageNode(string typeText, Object[] args);
    public virtual IExpressionArgument CreateExpressionArgument(IVBExpression expression);
    public virtual INamedArgument CreateNamedArgument(string name, IVBExpression expression);
    private IDeclaredTypeUsage CreateDeclaredTypeUsageNode(string typeName);
    public virtual IDeclaredTypeUsage CreateDeclaredTypeUsageNode(IDeclaredType type);
    private ITypeUsage CreateTypeUsageNode(string typeName);
    public virtual ITypeUsage CreateTypeUsageNode(IType type);
    private void BindTypeUsage(IType type, ITypeUsage typeUsage);
    private string BuildTypeString(IType& type);
    public virtual IRegularParameterDeclaration CreateParameterDeclaration(IType type, string name, ParameterKind kind, bool isParamArray);
    public virtual IImportDirective CreateImportDirective(string qualifiedName);
    public virtual IImportDirective CreateImportDirective(INamespace namespace);
    public virtual IImportDirective CreateImportAliasDirective(string alias, ITypeElement typeElement, ISubstitution substitution);
    public virtual IReferenceExpression CreateReferenceExpression(string expr, Object[] args);
    public virtual IReferenceName CreateReferenceName(string name, Object[] args);
    public virtual IVBNamespaceDeclaration CreateNamespaceDeclaration(string name);
    public virtual IAccessorDeclaration CreateAccessorDeclaration(AccessorKind kind, IType type);
    public virtual IAccessorDeclaration CreateAccessorDeclaration(AccessorKind kind);
    public virtual IBlock CreateEmptyBlock();
    public virtual IBlock CreateBlock(string format, Object[] args);
    private static string CreateTypeParameterDeclarationString(ITypeParameter typeParameter, ArrayList& arguments);
    public virtual ITypeParameterOfMethodDeclaration CreateTypeParameterOfMethodDeclaration(ITypeParameter typeParameter);
    public virtual ITypeParameterOfMethodDeclaration CreateTypeParameterOfMethodDeclaration(string typeParameter);
    public virtual ITypeParameterOfTypeDeclaration CreateTypeParameterOfTypeDeclaration(ITypeParameter typeParameter);
    public virtual ITypeParameterOfTypeDeclaration CreateTypeParameterOfTypeDeclaration(string typeParameter);
    public virtual IRegularParameterList CreateEmptyParameterList();
    private IDeclaredElement GetFormatConstantElement(string name);
    private void AddFormatLine(StringBuilder builder, string name, IList`1& declaredElements, Int32& formatIndex);
    private string Format(string string, IList`1& declaredElements);
    public virtual IVBExpression CreateExpressionByConstantValue(ConstantValue value);
    public virtual IVBXmlElement CreateVBXmlElement(string xmlString);
    public virtual IVBExpression CreateExpressionByConstantValue(ConstantValue value, bool safeConstantValueExactType);
    public virtual IVBExpression CreateExpressionByDefaultValue(DefaultValue value);
    public virtual IDocComment CreateDocComment(string text);
    public virtual ILambdaParameterDeclaration CreateLambdaFunctionParameterDeclaration(IType type, string parameterName, ParameterKind kind);
    public virtual IDocCommentBlock CreateDocCommentBlock(string xmlText);
    public virtual IPropertyDeclaration CreatePropertyDeclaration(IType type, string name, bool inInterface);
    public virtual IEventDeclaration CreateEventDeclaration(IDeclaredType type, string name);
    public virtual IVBIdentifier CreateIdentifier(string name);
    public virtual IDelegateDeclaration CreateDelegateDeclaration();
    public virtual IEnumMemberDeclaration CreateEnumMemberDeclaration(string enumMemberName);
    public virtual ILoopControlVariableDeclaration CreateLoopControlVariableDeclaration(string name, IType type);
    public virtual ITypeParameterConstraintList CreateTypeParameterConstraintsList(ITypeParameter typeParameter, ISubstitution substitution, string parameterName);
    public virtual Pair`2<IRegionPreprocessorDirective, IEndRegionPreprocessorDirective> CreateRegionDirective(string name);
    public virtual IAttribute CreateAttribute(ITypeElement attributeClass, AttributeValue[] fixedArguments, Pair`2[] namedArguments);
    private static string FormatAttributeValue(AttributeValue value, IList parameters);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBEventAccessTypeProvider : EventAccessTypeProvider {
    public virtual EventAccessType GetEventAccessType(IReference reference);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBExplicitImplementation : object {
    private IOverridableMember myImplementedMember;
    private ISubstitution mySubstitution;
    public IDeclaredType DeclaringType { get; }
    public string MemberName { get; }
    public VBExplicitImplementation(IOverridableMember implementedMember, ISubstitution substitution);
    public sealed virtual IDeclaredType get_DeclaringType();
    public sealed virtual string get_MemberName();
    [NotNullAttribute]
public sealed virtual OverridableMemberInstance Resolve();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Psi.VB.Impl.VBGeneratedFilesCacheProvider : object {
    public sealed virtual bool IsGeneratedFile(IPsiSourceFile sourceFile);
}
internal static class JetBrains.ReSharper.Psi.VB.Impl.VBImplicitlyConvertedToTypeUtil : object {
    [NotNullAttribute]
public static IType ExpressionImplicitlyConvertedToType(IResolveContext resolveContext, IVBExpression expression);
    public static IType LambdaExpressionImplicitlyConvertedToType(IResolveContext resolveContext, ILambdaExpression lambdaExpression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Impl.VBImplUtil : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static string GetName(IIdentifier identifier);
    [PureAttribute]
[NotNullAttribute]
public static string GetName(string name);
    [NotNullAttribute]
public static string MakeClrName(IVBTypeDeclaration declaration);
    public static ITreeNode GetProjectedIdentifierNode(IVBExpression expression);
    [NotNullAttribute]
public static string GetProjectedIdentifierName(IVBExpression expression);
    public static TreeTextRange GetNameRange(IVBIdentifier identifier);
    public static void ReplaceIdentifier(IVBIdentifier node, string name);
    public static TreeNodeCollection`1<IVBTypeMemberDeclaration> GetTypeMemberDeclarations(ITreeNode body);
    [NotNullAttribute]
public static IList`1<IExplicitImplementation> BuildExplicitImplementations(IImplementsClause implementsClause);
    [NotNullAttribute]
public static IList`1<IDeclaredType> GetTypeParameterDeclaredTypeConstraints(ITypeParameterDeclaration declaration);
    public static TypeParameterConstraintFlags GetTypeParameterConstraintFlags(ITypeParameterDeclaration declaration);
    [NotNullAttribute]
public static string NormalizeName(string name);
    public static bool CaseInsensitiveEquals(string name1, string name2);
    [NotNullAttribute]
public static IList`1<IAttributeInstance> GetAttributeInstances(IAttributeListOwner attributeListOwnerNode);
    [ExtensionAttribute]
[NotNullAttribute]
public static IAttributeInstance GetAttributeInstance(IAttribute attributeNode);
    public static bool HasAttributeInstances(IAttributeListOwner attributeListOwnerNode, IClrTypeName clrName);
    [NotNullAttribute]
public static ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeOwnerDeclaration typeDeclaration, ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    [NotNullAttribute]
public static ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeOwnerDeclaration typeDeclaration, ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    [NotNullAttribute]
public static ITypeParameterOfMethodDeclaration AddTypeParameterBefore(IMethodDeclaration methodDeclaration, ITypeParameterOfMethodDeclaration param, ITypeParameterOfMethodDeclaration anchor);
    public static void RemoveTypeParameter(ITypeParameterOfTypeOwnerDeclaration typeDeclaration, ITypeParameterOfTypeDeclaration param);
    public static void RemoveTypeParameter(IMethodDeclaration methodDeclaration, ITypeParameterOfMethodDeclaration param);
    public static IVBArgument AddArgumentBefore(IVBArgumentsOwner argumentsOwner, IArgumentList argumentList, IVBArgument argument, IVBArgument anchor);
    public static IVBArgument AddArgumentAfter(IVBArgumentsOwner expression, IArgumentList argumentList, IVBArgument argument, IVBArgument anchor);
    public static void RemoveArgument(IArgumentList argumentList, IVBArgument argument);
    public static IVBParameterDeclaration AddParameterBefore(IVBParameterDeclarationList parameterList, IVBParameterDeclaration parameter, IVBParameterDeclaration anchor);
    public static IVBParameterDeclaration AddParameterAfter(IVBParameterDeclarationList parameterList, IVBParameterDeclaration parameter, IVBParameterDeclaration anchor);
    public static void RemoveParameter(IVBParameterDeclarationList parameterList, IVBParameterDeclaration parameter);
    public static IAttribute AddAttribute(IAttributeListOwner attributeListOwner, IAttribute attribute);
    public static void RemoveAttribute(IAttribute attribute);
    [NotNullAttribute]
public static IVBArgument ReplaceArgument(IVBArgument argument, IVBArgument newArgument);
    [CanBeNullAttribute]
public static IDocCommentBlock GetDocCommentBlock(IVBDeclaration declaration);
    [NotNullAttribute]
public static IParameter[] GetParameters(IVBParametersOwnerDeclaration declaration);
    [NotNullAttribute]
public static IParameter[] GetParameters(IRegularParameterList parameterList);
    public static string MakeSafeName(string name);
    public static void SetKeywordAtFirstPlace(bool value, ITreeNode root, ITokenNode keyword, TokenNodeType keywordType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Impl.VBImportsUtil : object {
    public static bool AlreadyImported(IVBFile file, INamespace namespace);
    public static string FindAliasTo(IVBFile file, INamespace namespace);
    public static string FindAliasTo(IVBFile file, DeclaredElementInstance`1<ITypeElement> target);
    public static bool IsAliasValid(IVBFile file, string alias);
    internal static List`1<Conflict> GetImportConflictsInternal(IVBFile file, IImportDirective directive, Key`1<DeclaredElementInstance> filterKey, IReference referenceToTryResolve, IResolveResult& resolveResult);
    public static List`1<Conflict> GetImportConflicts(IVBFile scope, INamespace ns);
    public static IImportDirective AddImportAfter(IVBFile file, ITreeNode anchor, IImportDirective directive);
    public static IImportDirective AddImportBefore(IVBFile file, ITreeNode anchor, IImportDirective directive);
    public static IImportDirective AddImport(IVBFile file, INamespace namespace);
    private static int CompareDirectiveNames(string directive1, string directive2);
    public static IImportDirective AddImport(IVBFile file, IImportDirective directive, bool saveUsingListPosition);
    public static void RemoveImport(IImportDirective directive);
    public static void RemoveImportClause(IImportClause clause);
    public static IDictionary`2<IImportClause, IList`1<IReference>> GetImportClausesUsages(IVBFile file);
    [ExtensionAttribute]
public static bool IsTrivialAlias(IImportAliasClause clause);
    public static IImportClause GetImportOf(IQualifiableReference reference);
    private static IEnumerable`1<ITypeElement> CollectNamespaceExports(IPsiModule module, INamespace namespace);
    public static void RemoveUnusedImports(IDocument document, IVBFile file);
}
public static class JetBrains.ReSharper.Psi.VB.Impl.VBInvocableSignatureComparer : object {
    [NotNullAttribute]
public static ISignatureComparer Override;
    [CanBeNullAttribute]
private static ISignatureComparer myVB10Overload;
    [CanBeNullAttribute]
private static ISignatureComparer myVB11Overload;
    private static VBInvocableSignatureComparer();
    [NotNullAttribute]
public static ISignatureComparer Overload(VBLanguageLevel languageLevel);
    [NotNullAttribute]
private static ISignatureComparer GetVB11OverloadSignatureComparer();
    [NotNullAttribute]
private static ISignatureComparer GetVB10OverloadSignatureComparer();
}
public enum JetBrains.ReSharper.Psi.VB.Impl.VBLanguageLevel : Enum {
    public int value__;
    public static VBLanguageLevel Vb8;
    public static VBLanguageLevel Vb9;
    public static VBLanguageLevel Vb10;
    public static VBLanguageLevel Vb11;
    public static VBLanguageLevel Vb12;
    public static VBLanguageLevel Vb14;
    public static VBLanguageLevel Vb15;
    public static VBLanguageLevel Vb15_3;
    public static VBLanguageLevel Vb15_5;
    public static VBLanguageLevel Vb16;
    public static VBLanguageLevel Vb16_9;
    public static VBLanguageLevel Latest;
}
public class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageLevelComparer : object {
    [NotNullAttribute]
public static VBLanguageLevelComparer Instance;
    private static VBLanguageLevelComparer();
    public sealed virtual int Compare(VBLanguageLevel x, VBLanguageLevel y);
}
public class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageLevelHelper : RoslynBasedLanguageLevelHelper`1<VBLanguageLevel> {
    public string LanguageName { get; }
    public VBLanguageLevelHelper(ILogger logger, ISolutionToolset solutionToolset);
    public virtual string get_LanguageName();
    public bool IsAvailable(VBLanguageVersion languageVersion);
    public bool IsAvailable(VBLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
private bool IsAvailableCore(VBLanguageVersion languageVersion, VBLanguageLevel convertedLanguageLevel, VBLanguageLevel latestAvailableLanguageLevel);
    public VBLanguageLevel GetLatestAvailableLanguageLevelImpl(IProject project, TargetFrameworkId targetFrameworkId);
    public VBLanguageLevel ConvertToLanguageLevel(VBLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
public VBLanguageLevel ConvertToLanguageLevel(VBLanguageVersion languageVersion, IVBProjectConfiguration configuration);
    public virtual VBLanguageLevel GetLanguageLevelByToolsetVersion(Version2 toolsetVersion);
    public virtual Nullable`1<VersionMapping<VBLanguageLevel>> GetLanguageLevelByCompilerVersion(Version2 roslynVersion);
    public string GetPresentation(VBLanguageVersion languageVersion, LanguageVersionPresentationOptions options);
}
[SolutionComponentAttribute("2")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageLevelProjectProperty : OverridableLanguageLevelProjectProperty`2<VBLanguageLevel, VBLanguageVersion> {
    [NotNullAttribute]
private VBLanguageLevelHelper myHelper;
    [CanBeNullAttribute]
public Version2 ToolsetVersion { get; }
    [NotNullAttribute]
public ILogger Logger { get; }
    public IComparer`1<VBLanguageLevel> LanguageLevelComparer { get; }
    public string LanguageName { get; }
    public VBLanguageLevelProjectProperty(Lifetime lifetime, ILogger logger, ISettingsStore settingsStore, IShellLocks locks, ProjectSettingsStorageComponent projectSettings, ProjectPropertiesListener projectPropertiesListener, PersistentProjectItemProperties persistentProjectItemProperties, ISolutionToolset solutionToolset);
    public Version2 get_ToolsetVersion();
    public ILogger get_Logger();
    public virtual VBLanguageVersion GetLanguageVersion(IProject project, TargetFrameworkId targetFrameworkId);
    public virtual IComparer`1<VBLanguageLevel> get_LanguageLevelComparer();
    public virtual VBLanguageVersion ConvertToLanguageVersion(VBLanguageLevel languageLevel);
    public virtual Nullable`1<VBLanguageVersion> TryParseCompilationOption(string languageVersion);
    public virtual string ConvertToCompilationOption(VBLanguageVersion languageVersion);
    public virtual VBLanguageLevel GetDefaultLanguageLevel(IProject project, TargetFrameworkId targetFrameworkId);
    protected virtual VBLanguageLevel GetLatestAvailableLanguageLevelImpl(IProject project, TargetFrameworkId targetFrameworkId);
    public virtual VBLanguageLevel GetLatestAvailableLanguageLevel(VirtualFileSystemPath compilerDirectoryPath);
    public virtual bool IsAvailable(VBLanguageLevel languageLevel, IProject project, TargetFrameworkId targetFrameworkId);
    public virtual bool IsAvailable(VBLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    public virtual VBLanguageLevel ConvertToLanguageLevel(VBLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
public VBLanguageLevel ConvertToLanguageLevel(VBLanguageVersion languageVersion, VirtualFileSystemPath compilerDirectoryPath);
    protected virtual Nullable`1<VBLanguageLevel> GetOverriddenLanguageLevelFromSettings(IContextBoundSettingsStore settingsStore);
    protected virtual void SetOverridenLanguageLevelInSettings(IContextBoundSettingsStore settingsStore, Nullable`1<VBLanguageLevel> languageLevel);
    protected virtual bool IsApplicableToProject(IProject project);
    public virtual string get_LanguageName();
    public virtual string GetPresentation(VBLanguageVersion languageVersion, LanguageVersionPresentationOptions options, IProject project, TargetFrameworkId targetFrameworkId);
}
[SolutionFeaturePartAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageLevelProvider : VBLanguageLevelProviderForAnyModule {
    [CompilerGeneratedAttribute]
private VBLanguageLevelProjectProperty <ProjectProperty>k__BackingField;
    [CanBeNullAttribute]
private Lazy`1<ILanguageVersionModifier`1<VBLanguageVersion>> myLanguageVersionModifierLazy;
    [CompilerGeneratedAttribute]
private ILanguageLevelOverrider`1<VBLanguageLevel> <LanguageLevelOverrider>k__BackingField;
    [NotNullAttribute]
public VBLanguageLevelProjectProperty ProjectProperty { get; }
    public ILanguageVersionModifier`1<VBLanguageVersion> LanguageVersionModifier { get; }
    public ILanguageLevelOverrider`1<VBLanguageLevel> LanguageLevelOverrider { get; }
    public VBLanguageLevelProvider(VBLanguageLevelProjectProperty projectProperty, ILanguageLevelOverrider`1<VBLanguageLevel> languageLevelOverrider, Lazy`1<ILanguageVersionModifier`1<VBLanguageVersion>> languageVersionModifier);
    [CompilerGeneratedAttribute]
public VBLanguageLevelProjectProperty get_ProjectProperty();
    public virtual bool IsApplicable(IPsiModule psiModule);
    public virtual VBLanguageLevel GetLanguageLevel(IPsiModule psiModule);
    public virtual Nullable`1<VBLanguageVersion> TryGetLanguageVersion(IPsiModule psiModule);
    public virtual bool IsAvailable(VBLanguageLevel languageLevel, IPsiModule psiModule);
    public virtual bool IsAvailable(VBLanguageVersion languageVersion, IPsiModule psiModule);
    public virtual VBLanguageLevel ConvertToLanguageLevel(VBLanguageVersion languageVersion, IPsiModule psiModule);
    [PureAttribute]
public virtual VBLanguageLevel GetLatestAvailableLanguageLevel(IPsiModule psiModule);
    public virtual ILanguageVersionModifier`1<VBLanguageVersion> get_LanguageVersionModifier();
    [CompilerGeneratedAttribute]
public virtual ILanguageLevelOverrider`1<VBLanguageLevel> get_LanguageLevelOverrider();
}
[SolutionFeaturePartAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageLevelProviderForAnyModule : object {
    public ILanguageVersionModifier`1<VBLanguageVersion> LanguageVersionModifier { get; }
    public ILanguageLevelOverrider`1<VBLanguageLevel> LanguageLevelOverrider { get; }
    public virtual bool IsApplicable(IPsiModule psiModule);
    public virtual VBLanguageLevel GetLanguageLevel(IPsiModule psiModule);
    public virtual Nullable`1<VBLanguageVersion> TryGetLanguageVersion(IPsiModule psiModule);
    public virtual bool IsAvailable(VBLanguageLevel languageLevel, IPsiModule psiModule);
    public virtual bool IsAvailable(VBLanguageVersion languageVersion, IPsiModule psiModule);
    public virtual VBLanguageLevel ConvertToLanguageLevel(VBLanguageVersion languageVersion, IPsiModule psiModule);
    public virtual VBLanguageVersion ConvertToLanguageVersion(VBLanguageLevel languageLevel);
    public virtual VBLanguageLevel GetLatestAvailableLanguageLevel(IPsiModule psiModule);
    public virtual ILanguageVersionModifier`1<VBLanguageVersion> get_LanguageVersionModifier();
    public virtual ILanguageLevelOverrider`1<VBLanguageLevel> get_LanguageLevelOverrider();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageLevelUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string ToDisplayValue(VBLanguageLevel languageLevel);
    [PureAttribute]
public static VBLanguageLevel ParseDisplayValue(string languageLevel, Nullable`1<VBLanguageLevel> unknownLevel);
    [ExtensionAttribute]
[PureAttribute]
public static VBLanguageVersion ToLanguageVersion(VBLanguageLevel languageLevel);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeInspectionSettings", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "VBNETLanguageSettingsSettingDescription")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageProjectSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "VBNETLanguageLevelSettingDescription")]
public ReSharperSettingsVBLanguageLevel LanguageLevel;
    [NotNullAttribute]
public static Expression`1<Func`2<VBLanguageProjectSettings, ReSharperSettingsVBLanguageLevel>> LanguageLevelSelector;
    private static VBLanguageProjectSettings();
}
[ProjectSettingsUpgraderAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageProjectSettingsUpgrader : object {
    private IContextBoundSettingsStore myStore;
    public sealed virtual void Upgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime);
    private sealed virtual override void JetBrains.Application.Configuration.IXmlReadable.ReadFromXml(XmlElement element);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBLanguageServiceImpl : LanguageService {
    [NotNullAttribute]
private IVBCodeFormatter myCodeFormatter;
    private CommonIdentifierIntern myCommonIdentifierIntern;
    private static string MEMBER_DECLARATION_CAPABILITY;
    private static string STATEMENT_CAPABILITY;
    private static string EXPRESSION_CAPABILITY;
    [CompilerGeneratedAttribute]
private ILanguageCacheProvider <CacheProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypePresenter <TypePresenter>k__BackingField;
    public bool IsCaseSensitive { get; }
    [NotNullAttribute]
public ILanguageCacheProvider CacheProvider { get; }
    public bool SupportTypeMemberCache { get; }
    public ICodeFormatter CodeFormatter { get; }
    public ITypePresenter TypePresenter { get; }
    public IDeclaredElementPresenter DeclaredElementPresenter { get; }
    public VBLanguageServiceImpl(VBLanguage vbLanguage, IConstantValueService constantValueService, VBConstantCalculator constantCalculator, IVBCodeFormatter codeFormatter, CommonIdentifierIntern commonIdentifierIntern, ILanguageCacheProvider cacheProvider);
    public virtual ILexerFactory GetPrimaryLexerFactory();
    public virtual ILexer CreateFilteringLexer(ILexer lexer);
    public virtual bool IsValidName(DeclaredElementType elementType, string name);
    public virtual IParser CreateParser(ILexer lexer, IPsiModule module, IPsiSourceFile sourceFile);
    public virtual IEnumerable`1<string> EnumerateParserCapabilities();
    public virtual ITreeNode ParseUsingCapability(string text, string capability, IPsiModule psiModule);
    public virtual bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public virtual ILanguageCacheProvider get_CacheProvider();
    public virtual bool get_SupportTypeMemberCache();
    public virtual ICodeFormatter get_CodeFormatter();
    public virtual void OptimizeImportsAndRefs(IFile file, IRangeMarker rangeMarker, bool optimizeUsings, bool shortenReferences, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public virtual IReferenceContextCodec CreateReferenceContextCodec();
    [NotNullAttribute]
public virtual ITypeConversionRule GetTypeConversionRule(ITreeNode context, bool useStrict);
    [CompilerGeneratedAttribute]
public virtual ITypePresenter get_TypePresenter();
    public virtual IDeclaredElementPresenter get_DeclaredElementPresenter();
    public virtual bool IsTypeMemberVisible(ITypeMember member);
    public virtual ReferenceAccessType GetReferenceAccessType(IDeclaredElement target, IReference reference);
    public virtual IDeclaredElementPointer`1<T> CreateElementPointer(T declaredElement);
    public virtual PreProcessingDirectivesInFile GetUsedConditionalSymbols(IPsiSourceFile sourceFile);
    public virtual bool CanContainCachableDeclarations(ITreeNode node);
    public virtual IEnumerable`1<ITypeDeclaration> FindTypeDeclarations(IFile file);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.VBLanguageServiceImpl/<EnumerateTypeDeclarations>d__37")]
private static IEnumerable`1<ITypeDeclaration> EnumerateTypeDeclarations(IVBTypeAndNamespaceHolderDeclaration typeAndNamespaceHolderDeclaration);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.VBLanguageServiceImpl/<EnumerateTypeDeclarations>d__38")]
private static IEnumerable`1<ITypeDeclaration> EnumerateTypeDeclarations(IVBTypeDeclaration vbTypeDeclaration);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBMethodsReferencedByDelegateSearcher : object {
    private IDelegate myDelegate;
    public VBMethodsReferencedByDelegateSearcher(IDelegate delegate);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
}
public static class JetBrains.ReSharper.Psi.VB.Impl.VBModifiersUtil : object {
    private static NodeTypeSet ourModifiers;
    public static String[] DefaultModifiersOrder;
    private static VBModifiersUtil();
    public static int CompareModifierOrder(ITokenNode mod1, ITokenNode mod2);
    private static JetHashSet`1<TokenNodeType> GetSourceModifiers(IModifiersList modifiersList);
    public static ITokenNode GetSourceModifier(IModifiersList modifiersList, TokenNodeType modifier);
    public static bool HasSourceModifier(IModifiersList modifiersList, TokenNodeType modifier);
    public static void SetSourceModifiers(IModifiersListOwner node, ICollection`1<TokenNodeType> modsToAdd, ICollection`1<TokenNodeType> modsToRemove);
    private static void AddRemoveModifier(IModifiersListOwner node, bool bAdd, TokenNodeType modifier);
    public static AccessRights GetAccessRightsModifiers(IModifiersList node);
    public static AccessRights GetAccessRightsModifiers(IModifiersListOwner node);
    public static void SetAccessRightsModifiers(IModifiersListOwner node, AccessRights rights);
    public static bool HasAbstract(IModifiersListOwner node);
    public static ITokenNode GetAbstract(IModifiersListOwner node);
    public static void SetAbstract(IModifiersListOwner node, bool value);
    public static bool HasSealed(IModifiersListOwner node);
    public static ITokenNode GetSealed(IModifiersListOwner node);
    public static void SetSealed(IModifiersListOwner node, bool value);
    public static bool HasVirtual(IModifiersListOwner node);
    public static ITokenNode GetVirtual(IModifiersListOwner node);
    public static void SetVirtual(IModifiersListOwner node, bool value);
    public static bool HasOverload(IModifiersListOwner node);
    public static ITokenNode GetOverload(IModifiersListOwner node);
    public static bool HasOverride(IModifiersListOwner node);
    public static ITokenNode GetOverride(IModifiersListOwner node);
    public static void SetOverride(IModifiersListOwner node, bool value);
    public static bool HasStatic(IModifiersListOwner node);
    public static ITokenNode GetStatic(IModifiersListOwner node);
    public static void SetOverload(IModifiersListOwner node, bool value);
    public static void SetShadows(IModifiersListOwner node, bool value);
    public static void SetStatic(IModifiersListOwner node, bool value);
    public static void SetPartial(IModifiersListOwner node, bool value);
    public static void SetAsync(IModifiersListOwner node, bool value);
    public static void SetIterator(IModifiersListOwner node, bool value);
    public static bool HasReadonly(IModifiersListOwner node);
    public static ITokenNode GetReadonly(IModifiersListOwner node);
    public static void SetReadonly(IModifiersListOwner node, bool value);
    public static void SetDefault(IModifiersListOwner node, bool value);
    public static bool HasWriteonly(IModifiersListOwner node);
    public static ITokenNode GetWriteonly(IModifiersListOwner node);
    public static void SetWriteonly(IModifiersListOwner node, bool value);
    public static bool HasWithEvents(IModifiersListOwner node);
    public static ITokenNode GetWithEvents(IModifiersListOwner node);
    public static void SetWithEvents(IModifiersListOwner node, bool value);
    public static bool HasPartial(IModifiersListOwner node);
    public static ITokenNode GetPartial(IModifiersListOwner node);
    public static bool HasAsync(IModifiersListOwner node);
    public static ITokenNode GetAsync(IModifiersListOwner node);
    public static bool HasIterator(IModifiersListOwner node);
    public static ITokenNode GetIterator(IModifiersListOwner node);
    public static bool HasOverloads(IModifiersListOwner node);
    public static ITokenNode GetOverloads(IModifiersListOwner node);
    public static bool HasShadows(IModifiersListOwner node);
    public static ITokenNode GetShadows(IModifiersListOwner node);
    public static MemberDecoration GetDecoration(IModifiersListOwner node);
    public static MemberHidePolicy GetHidePolicy(IModifiersListOwner node);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBModuleCache : InvalidatingPsiCache {
    private object myLock;
    private OneToListMap`2<INamespace, ITypeElement> myModuleCache;
    [NotNullAttribute]
public IEnumerable`1<ITypeElement> GetModulesInNamespace(INamespace ns);
    protected virtual void InvalidateOnPhysicalChange(PsiChangedElementType elementType);
    private void Clear();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Psi.VB.Impl.VBNamedArgumentsCacheProvider : object {
    [NullableContextAttribute("1")]
public sealed virtual String[] GetPossibleNamedArguments(IPsiSourceFile sourceFile);
}
public static class JetBrains.ReSharper.Psi.VB.Impl.VBNamespaceUtil : object {
    [NotNullAttribute]
[PublicAPIAttribute]
public static string CutDefaultNamespacePrefix(INamespace namespace, ITreeNode node);
    [NotNullAttribute]
[PublicAPIAttribute]
public static string CutDefaultNamespacePrefix(INamespace namespace, IPsiSourceFile sourceFile);
    [NotNullAttribute]
private static string CutDefaultNamespacePrefix(INamespace namespace, string defaultNamespaceName);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBPredefinedOperatorsImpl : VBPredefinedOperators {
    private PredefinedType myTypes;
    private Dictionary`2<string, Dictionary`2<Pair`2<string, string>, ISignOperator>> myBinaryOperators;
    private Dictionary`2<string, Dictionary`2<string, ISignOperator>> myUnaryOperators;
    private Dictionary`2<string, IList`1<OperatorInstance>> myOperatorsByName;
    public VBPredefinedOperatorsImpl(IPsiModule module);
    public virtual bool IsOperatorName(string name, int parameterCount);
    public virtual IList`1<OperatorInstance> GetOperatorsByName(string name);
    public virtual ISignOperator GetBinaryOperator(string name, IType leftType, IType rightType);
    public virtual ISignOperator GetUnaryOperator(string name, IType type);
    public virtual ISignOperator[] GetBinaryOperators();
    public virtual ISignOperator[] GetUnaryOperators();
    private static ISignOperator[] GetAllOperators(IEnumerable`1<KeyValuePair`2<string, Dictionary`2<T, ISignOperator>>> operators);
    private void CreateUnaryOperators();
    private void CreateBinaryOperators();
    private void CreateUnaryOperators(IEnumerable`1<IType> types, String[] names);
    private void CreateBinaryOperators(CreateKey createKey, CreateOperator createOperator, IEnumerable`1<IType> types, String[] names);
    private void InitializeOperatorsByName();
    private static void InitializeOperatorsByName(IEnumerable`1<KeyValuePair`2<string, Dictionary`2<T, ISignOperator>>> operators, IDictionary`2<string, IList`1<OperatorInstance>> operatorsByName);
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.VB.Impl.VBPredefinedOperatorsManager : object {
    private Dictionary`2<IPsiModule, VBPredefinedOperators> myPredefineds;
    public sealed virtual void Dispose();
    public VBPredefinedOperators GetPredefined(IPsiModule module);
}
[ProjectFileTypeAttribute("JetBrains.ProjectModel.VBProjectFileType", "16")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBProjectFileCustomPsiPropertiesProvider : object {
    public virtual T GetCustomProperties(IPsiSourceFile sourceFile);
}
[ProjectFileTypeAttribute("JetBrains.ProjectModel.VBProjectFileType", "16")]
public class JetBrains.ReSharper.Psi.VB.Impl.VBProjectFileLanguageService : object {
    private VBProjectFileType myVBProjectFileType;
    private static string DEFINE_CONFIG;
    private static string DEFINE_DEBUG;
    private static string DEFINE_PLATFORM;
    private static string DEFINE_TARGET;
    private static string DEFINE_TRACE;
    private static string DEFINE_VERSION;
    public static string DEFINE_MYTYPE;
    public ProjectFileType LanguageType { get; }
    public IconId Icon { get; }
    public VBProjectFileLanguageService(VBProjectFileType vbProjectFileType);
    public sealed virtual ProjectFileType get_LanguageType();
    public sealed virtual IconId get_Icon();
    public sealed virtual PsiLanguageType GetPsiLanguageType(IProjectFile projectFile);
    public sealed virtual PsiLanguageType GetPsiLanguageType(IPsiSourceFile sourceFile);
    public sealed virtual PsiLanguageType GetPsiLanguageType(ProjectFileType languageType);
    public sealed virtual ILexerFactory GetMixedLexerFactory(ISolution solution, IBuffer buffer, IPsiSourceFile sourceFile);
    public sealed virtual PreProcessingDirective[] GetPreprocessorDefines(IProject project, TargetFrameworkId targetFrameworkId);
    public sealed virtual IPsiSourceFileProperties GetPsiProperties(IProjectFile projectFile, IPsiSourceFile sourceFile, IsCompileService isCompileService);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBReferenceContextCodec : ReferenceContextCodec {
    public virtual IEnumerable`1<IReference> ExtractBindableReferences(ITreeNode element);
    [CompilerGeneratedAttribute]
internal static bool <ExtractBindableReferences>g__FilterBindableReference|0_0(IReference reference);
}
[ReferenceProviderFactoryAttribute("0")]
internal class JetBrains.ReSharper.Psi.VB.Impl.VBReferenceProviderFactory : object {
    private VBReferenceProvider myReferenceProvider;
    private Lazy`1<NotifyPropertyChangedAnnotationProvider> myNotifyPropertyChangedAnnotationProvider;
    private Lazy`1<InvokerParameterNameAnnotationProvider> myInvokerParameterNameAnnotationProvider;
    [CompilerGeneratedAttribute]
private ISignal`1<IReferenceProviderFactory> <Changed>k__BackingField;
    public ISignal`1<IReferenceProviderFactory> Changed { get; }
    public VBReferenceProviderFactory(Lifetime lifetime, CodeAnnotationsCache codeAnnotationsCache);
    public sealed virtual IReferenceFactory CreateFactory(IPsiSourceFile sourceFile, IFile file, IWordIndex wordIndexForChecks);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<IReferenceProviderFactory> get_Changed();
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBReferenceSearcher : object {
    private IDeclaredElementsSet myElements;
    private ReferenceSearcherParameters myReferenceSearcherParameters;
    private JetHashSet`1<string> myElementNames;
    private bool mySearchLateBound;
    private bool myHasUnnamedElement;
    public VBReferenceSearcher(IDomainSpecificSearcherFactory factory, IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters, bool searchLateBound);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    private bool IsSkipped(IFindResultReference reference);
    [CompilerGeneratedAttribute]
private FindResult <ProcessElement>b__7_0(FindResult fr);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.VB.Impl.VBReferenceUtil : object {
    [ExtensionAttribute]
private static bool IsGoodResolveResult(IReference reference, bool checkWithSubstitution);
    public static bool CheckResolvedTo(IReference reference, IDeclaredElement target);
    private static bool CheckResolvedTo(IReference reference, DeclaredElementInstance target);
    private static void PatchElementName(IReference reference, IDeclaredElement element, IVBIdentifier identifierNode);
    public static string SuggestShortReferenceName(IReference reference, IDeclaredElement target, bool verbatim);
    public static IQualifiableReference ReplaceReferenceElement(ITreeNode element, string refto, bool keepExistingTypeArguments);
    private static ITypeArgumentList GetTypeArgumentsList(ITreeNode element);
    private static ITypeArgumentList SetTypeArgumentList(ITreeNode element, ITypeArgumentList list);
    private static int GetTypeArgumentsNumber(ITreeNode element);
    private static IQualifiableReference ExtractQualifierReference(IReference reference);
    private static string ObfuscateQualifiedName(string name);
    private static bool IsQualifiedWithGlobal(IQualifiableReference reference);
    private static IQualifiableReference BindToNamespace(IQualifiableReference reference, INamespace namespace);
    private static IQualifiableReference UseExistingAlias(IQualifiableReference reference, DeclaredElementInstance`1<ITypeElement> target);
    private static IQualifiableReference BindToTypeElementNoImport(IQualifiableReference reference, ITypeElement target, bool allowAlias);
    private static IQualifiableReference BindToTypeElement(IQualifiableReference reference, ITypeElement target);
    private static IQualifiableReference BindToTypeElementWithSubstitution(IQualifiableReference reference, DeclaredElementInstance`1<ITypeElement> target);
    private static void ReconstructTypeParameters(ITreeNode element, ISubstitution substitution, ITypeParametersOwner target, bool applyExtensionMethodCurrying);
    private static IQualifiableReference BindToStaticTypeMember(IQualifiableReference reference, ITypeMember member);
    private static IQualifiableReference BindToStaticTypeMemberWithSubstitution(IQualifiableReference reference, ITypeMember member, ISubstitution substitution);
    private static IQualifiableReference BindToInstanceTypeMemberWithSubstitution(IQualifiableReference reference, ITypeMember target, ISubstitution substitution);
    private static IQualifiableReference BindToExtensionMethod(IQualifiableReference reference, IMethod method);
    private static IQualifiableReference BindToExtensionMethodAsStaticCall(IQualifiableReference reference, IMethod method, bool canUseNamespaceImport);
    private static void BindToTypeElement(IQualifiableReference reference, ITypeElement target, bool canUseNamespaceImport);
    private static IQualifiableReference BindToModuleMember(IQualifiableReference reference, ITypeMember typeMember);
    private static bool TryBindUsingImport(IReference reference, IDeclaredElement target, INamespace namespace, Boolean& hasSameNameConflict);
    private static IQualifiableReference BindToInstanceMember(IQualifiableReference reference, ITypeMember member);
    private static T FakeBindTo(T reference, IDeclaredElement target, ISubstitution substitution);
    private static void PossibleReferenceUpgrade(IReference reference, IDeclaredElement element, IVBIdentifier identifierNode);
    public static IQualifiableReference BindReferenceTo(IQualifiableReference reference, IDeclaredElement element, IVBIdentifier identifierNode);
    public static IQualifiableReference BindReferenceTo(IQualifiableReference reference, IDeclaredElement target, ISubstitution substitution, IVBIdentifier identifierNode);
    public static IQueryReference BindQueryReferenceTo(IQueryReference reference, IDeclaredElement target);
    public static IQueryReference BindQueryReferenceTo(IQueryReference reference, IDeclaredElement target, ISubstitution substitution);
    private static bool RebindConflictedReferences(IEnumerable`1<Conflict> allConflicts);
}
[PsiSharedComponentAttribute]
internal class JetBrains.ReSharper.Psi.VB.Impl.VBSearcherFactory : DomainSpecificSearcherFactoryBase {
    private SearchDomainFactory mySearchDomainFactory;
    public VBSearcherFactory(SearchDomainFactory searchDomainFactory);
    public virtual IEnumerable`1<string> GetAllPossibleWordsInFile(IDeclaredElement element);
    private static void AddPossibleAliasesForElement(IDeclaredElement element, ICollection`1<string> names);
    private static bool MayHaveAttributeAlias(IDeclaredElement class, string name);
    public virtual bool IsCompatibleWithLanguage(PsiLanguageType languageType);
    public virtual IDomainSpecificSearcher CreateConstructorSpecialReferenceSearcher(ICollection`1<IConstructor> constructors);
    public virtual IDomainSpecificSearcher CreateMethodsReferencedByDelegateSearcher(IDelegate delegate);
    public virtual IDomainSpecificSearcher CreateReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    public virtual IDomainSpecificSearcher CreateTextOccurrenceSearcher(IDeclaredElementsSet elements);
    public virtual IDomainSpecificSearcher CreateTextOccurrenceSearcher(string subject);
    public virtual IDomainSpecificSearcher CreateLateBoundReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    public virtual IDomainSpecificSearcher CreateAnonymousTypeSearcher(IList`1<AnonymousTypeDescriptor> typeDescription, bool caseSensitive);
    public virtual IDomainSpecificSearcher CreateConstantExpressionSearcher(ConstantValue constantValue, bool onlyLiteralExpression);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.VBSearcherFactory/<GetRelatedDeclaredElements>d__14")]
public virtual IEnumerable`1<RelatedDeclaredElement> GetRelatedDeclaredElements(IDeclaredElement element);
    public virtual NavigateTargets GetNavigateToTargets(IDeclaredElement element);
    public virtual ISearchDomain GetDeclaredElementSearchDomain(IDeclaredElement declaredElement);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VbTextOccurrenceSearcher : TextOccurrenceSearcherBase`1<VBLanguage> {
    protected Predicate`1<ITreeNode> Predicate { get; }
    public VbTextOccurrenceSearcher(IEnumerable`1<IDeclaredElement> elements);
    public VbTextOccurrenceSearcher(string subject);
    protected virtual Predicate`1<ITreeNode> get_Predicate();
    private sealed virtual override bool JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcher.ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBTreeRange : TreeRange {
    public VBTreeRange(ITreeNode first, ITreeNode last);
    public static TreeRange BuildByTextRange(ITreeRange nodes, TreeTextRange textRange);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Impl.VBTreeRange/<GetPlainNodes>d__2")]
private static IEnumerable`1<ITreeNode> GetPlainNodes(ITreeRange nodes);
}
internal class JetBrains.ReSharper.Psi.VB.Impl.VBTypePresenter : object {
    private VBLanguage myLanguage;
    public VBTypePresenter(VBLanguage language);
    public sealed virtual RichText GetPresentableName(IType type, TypePresentationStyle typePresentationStyle);
    public sealed virtual RichText GetUnresolvedScalarTypePresentation(string name, ICollection`1<IType> typeArguments, NullableAnnotation nullableAnnotation, TypePresentationStyle typePresentationStyle);
    private void BuildPresentableName(IType type, RichText builder, TypePresentationStyle typePresentationStyle);
    private static void BuildPointerTypeString(IPointerType pointerType, RichText builder, TypePresenter presenter);
    private static void BuildArrayTypeString(IArrayType arrayType, RichText builder, TypePresenter presenter);
    private void BuildDeclaredTypePresentableName(IDeclaredType declaredType, RichText builder, TypePresentationStyle typePresentationStyle);
    private static void BuildTypeArgumentList(ITypeElement element, ISubstitution substitution, RichText builder, TypePresenter presenter);
}
[PolymorphicMarshallerAttribute]
internal class JetBrains.ReSharper.Psi.VB.Impl.VBUsingsInfo : object {
    private string myFileName;
    private string myText;
    [UsedImplicitlyAttribute]
public static ReadDelegate`1<object> ReadDelegate;
    [UsedImplicitlyAttribute]
public static WriteDelegate`1<object> WriteDelegate;
    [CompilerGeneratedAttribute]
private List`1<string> <ShortNames>k__BackingField;
    public List`1<string> ShortNames { get; public set; }
    public string FileName { get; }
    public VBUsingsInfo(string fileName, string text);
    private static VBUsingsInfo();
    public static VBUsingsInfo Create(IVBFile file);
    public static VBUsingsInfo Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, VBUsingsInfo info);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<string> get_ShortNames();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShortNames(List`1<string> value);
    public sealed virtual Hash GetHash();
    public sealed virtual string get_FileName();
    public virtual string ToString();
    public sealed virtual void TestDump(TextWriter builder);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.InvocationInfoExtension : object {
    [ExtensionAttribute]
public static IList`1<IVBArgumentInfo> AllArguments(IVBInvocationInfo invocation, bool isCandidateExtension);
    [ExtensionAttribute]
internal static IVBArgumentInfo CreateExpressionArgument(IVBInvocationInfo invocation, IVBExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.InvocationReferenceExtension : object {
    [ExtensionAttribute]
public static bool IsMeaningLess(IReference reference);
}
public interface JetBrains.ReSharper.Psi.VB.IVBArgumentInfo {
    [CanBeNullAttribute]
public IVBInvocationInfo Invocation { get; }
    public ArgumentKind Kind { get; }
    public string ArgumentName { get; }
    [CanBeNullAttribute]
public IManagedConvertible ManagedConvertible { get; }
    public abstract virtual IVBInvocationInfo get_Invocation();
    public abstract virtual ArgumentKind get_Kind();
    public abstract virtual string get_ArgumentName();
    public abstract virtual IManagedConvertible get_ManagedConvertible();
    public abstract virtual IExpressionType GetExpressionType(IResolveContext resolveContext);
    public abstract virtual bool IsClassifiedAsVariable(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.VB.IVBGroupCollectionMember {
    [NotNullAttribute]
public ITypeElement Owner { get; }
    [NotNullAttribute]
public ITypeElement Referee { get; }
    public abstract virtual ITypeElement get_Owner();
    public abstract virtual ITypeElement get_Referee();
}
public interface JetBrains.ReSharper.Psi.VB.IVBInvocationInfo {
    [NotNullAttribute]
public IList`1<IVBArgumentInfo> InvocationArguments { get; }
    [NotNullAttribute]
public IList`1<IType> TypeArguments { get; }
    [NotNullAttribute]
public IVBTreeNode Node { get; }
    [CanBeNullAttribute]
public IVBInvocationReference Reference { get; }
    [CanBeNullAttribute]
public IVBArgumentInfo ExtensionQualifier { get; }
    public abstract virtual IList`1<IVBArgumentInfo> get_InvocationArguments();
    public abstract virtual IList`1<IType> get_TypeArguments();
    public abstract virtual IVBTreeNode get_Node();
    public abstract virtual IVBInvocationReference get_Reference();
    public abstract virtual IVBArgumentInfo get_ExtensionQualifier();
}
public interface JetBrains.ReSharper.Psi.VB.IVBInvocationReference {
    [NotNullAttribute]
public IVBInvocationInfo Invocation { get; }
    public abstract virtual string InvocationName();
    public abstract virtual IVBInvocationInfo get_Invocation();
}
public interface JetBrains.ReSharper.Psi.VB.IVBLocalVariable {
    public bool IsImplicitlyTyped { get; }
    public abstract virtual bool get_IsImplicitlyTyped();
}
public interface JetBrains.ReSharper.Psi.VB.IVBModule {
}
public interface JetBrains.ReSharper.Psi.VB.IVBPsiSourceFileProperties {
    public bool TreatWarningsAsErrors { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> SuppressWarnings { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<string> WarningsAsErrors { get; }
    public abstract virtual bool ProjectStrictOff();
    public abstract virtual bool ProjectExplicitOff();
    public abstract virtual bool ProjectInferOff();
    public abstract virtual bool get_TreatWarningsAsErrors();
    public abstract virtual IReadOnlyCollection`1<string> get_SuppressWarnings();
    public abstract virtual IReadOnlyCollection`1<string> get_WarningsAsErrors();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Psi.VB.Naming.NameCanoniser : object {
    public sealed virtual string GetCanonicalShortName(string name);
    public sealed virtual string GetCanonicalQualifiedName(string name);
    private static string TrimName(string name);
}
public class JetBrains.ReSharper.Psi.VB.Naming.ValidityChecker : object {
    public static bool IsValidIdentifier(string identifier);
    public static bool IsValidName(string identifier);
    public static bool IsValidExpression(string expression);
    private static IVBExpression Expression(string expr);
    public static bool IsValidType(string typeUsage);
    public static bool IsValidTypeElement(string typeUsage);
    private static ITypeUsage TypeUsage(string typeUsage);
    public static bool IsValidNamespaceOrTypeName(string qualifiedName);
    private static IVBParser CreateParser(string text);
    private static ILexer CreateLexer(string text);
}
public static class JetBrains.ReSharper.Psi.VB.Naming.VBNameCompletionUtil : object {
    private static IList`1<NameRoot> GetNameRoots(IDeclaration declaration, ITypeUsage typeUsage, NamingManager namingManager, PsiLanguageType vbLanguage, PluralityKinds pluralityKinds);
    private static NamingPolicy GetNamingPolicyForParameterDeclaration(IDeclaration declaration, INamingPolicyProvider namingPolicyProvider);
    private static NamingPolicy GetNamingPolicyForLocalVariables(IDeclaration declaration, PsiLanguageType vbLanguage, INamingPolicyProvider namingPolicyProvider);
    [NotNullAttribute]
public static IList`1<string> SuggestNamesOfIdentifier(IVBIdentifier identifier, string prefix);
    private static IList`1<string> SuggestNameForTypeOwner(IType type, IDeclaration declaration, NamedElementKinds elementKinds, string prefix, INamingPolicyProvider namingPolicyProvider, IElementKind elementKind);
    private static IEnumerable`1<string> SuggestNamesImpl(IEnumerable`1<NameRoot> roots, string prefix, NamingPolicy namingPolicy, PsiLanguageType language, ISolution solution, INamingPolicyProvider policyProvider);
}
[NamedElementsBagAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage")]
public class JetBrains.ReSharper.Psi.VB.Naming2.VBElementKindOfElementType : ElementKindOfElementType {
    public static IElementKind ASYNC_METHOD;
    public PsiLanguageType Language { get; }
    [ObsoleteAttribute("Consider to use overload with resourceType and resourceName instead of presentableName.")]
protected VBElementKindOfElementType(string name, string presentableName, Func`2<IDeclaredElement, bool> isApplicable, IElementKind parent);
    protected VBElementKindOfElementType(string name, Type resourceType, string resourceName, Func`2<IDeclaredElement, bool> isApplicable, IElementKind parent);
    private static VBElementKindOfElementType();
    public virtual PsiLanguageType get_Language();
}
public class JetBrains.ReSharper.Psi.VB.Naming2.VBNamingPolicyProvider : ClrPolicyProviderBase`1<VBNamingSettings> {
    protected bool UsePredefinedNamingSettings { get; }
    public VBNamingPolicyProvider(PsiLanguageType language, IPsiSourceFile sourceFile, IContextBoundSettingsStore settings);
    protected virtual bool get_UsePredefinedNamingSettings();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Naming2.VBNamingPolicyProviderFactory : object {
    private PsiLanguageType myLanguageType;
    public VBNamingPolicyProviderFactory(PsiLanguageType languageType);
    public sealed virtual INamingPolicyProvider CreatePolicyProvider(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Naming2.VBNamingService : ClrNamingLanguageServiceBase {
    private IVBExpectedTypesProvider myExpectedTypeProvider;
    private Dictionary`2<string, string> myNamesMap;
    private JetHashSet`1<string> myReservedNames;
    public bool IsSameNestedNameAllowedForMembers { get; }
    public VBNamingService(VBLanguage vbLanguage, IEnumerable`1<IClrNamingSuggestionAdviser> namingSuggestionAdvisers, IVBExpectedTypesProvider expectedTypeProvider);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Naming2.VBNamingService/<SuggestRoots>d__4")]
[NotNullAttribute]
public virtual IEnumerable`1<NameRoot> SuggestRoots(ITreeNode element, bool fromExpectedTypes, INamingPolicyProvider policyProvider);
    public virtual IEnumerable`1<NameRoot> SuggestRoots(IDeclaredElement declaredElement, INamingPolicyProvider policyProvider);
    protected virtual bool IsLocalDeclaration(IDeclaration declaration);
    public virtual bool get_IsSameNestedNameAllowedForMembers();
    public virtual ScopeKind GetScopeKind(IDeclaredElement element);
    protected virtual NameRoot GetAbbreviation(NameRoot root);
    public virtual string MangleNameIfNecessary(string name, ITreeNode usageContext);
    protected virtual string Unmangle(string name);
    protected virtual bool IsMangled(string name);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.Naming.Settings.NamingSettings", "JetBrains.ReSharper.Psi.VB.Resources.Strings", "VBNETNamingSettingsSettingDescription")]
public class JetBrains.ReSharper.Psi.VB.Naming2.VBNamingSettings : ClrLanguageNamingSettingsKeyBase {
}
public class JetBrains.ReSharper.Psi.VB.OperatorInstance : DeclaredElementInstance`1<ISignOperator> {
    public ISignOperator Operator { get; }
    public OperatorInstance(ISignOperator element);
    public OperatorInstance(ISignOperator element, ISubstitution baseSubstitution);
    public ISignOperator get_Operator();
}
internal interface JetBrains.ReSharper.Psi.VB.Parsing.IVBLexer {
    public TokenNodeType PrevToken { get; }
    public bool HasSkippedLineContinuation { get; }
    public abstract virtual TokenNodeType get_PrevToken();
    public abstract virtual bool get_HasSkippedLineContinuation();
}
public interface JetBrains.ReSharper.Psi.VB.Parsing.IVBParser {
    public Func`3<TreeTextRange, TreeElement, CompositeElement> OpenChameleonStrategy { get; }
    public Func`3<TreeTextRange, TreeElement, CompositeElement> BindedToBufferChameleonStrategy { get; }
    public abstract virtual IFile ParseFile(Func`3<TreeTextRange, TreeElement, CompositeElement> chameleonStrategy);
    public abstract virtual IBlock ParseBlock();
    public abstract virtual IBlock OpenChameleonBlock(ITreeNode owner);
    public abstract virtual ITreeNode ParseMemberDeclaration();
    public abstract virtual IVBStatement ParseStatement();
    public abstract virtual IVBExpression ParseExpression();
    public abstract virtual Func`3<TreeTextRange, TreeElement, CompositeElement> get_OpenChameleonStrategy();
    public abstract virtual Func`3<TreeTextRange, TreeElement, CompositeElement> get_BindedToBufferChameleonStrategy();
}
public static class JetBrains.ReSharper.Psi.VB.Parsing.ParserMessages : object {
    public static string IDS_EXPECTED_SYMBOL;
    public static string IDS_EXPECTED_TWO_SYMBOLS;
    public static string IDS_UNEXPECTED_TOKEN;
    public static string IDS_UNEXPECTED_EOF;
    public static string IDS_IMPLICIT_LINE_CONTINUATION;
    public static string IDS_V_B_IDENTIFIER;
    public static string IDS__SIMPLEREFERENCENAME;
    public static string IDS_EXPRESSION_ARGUMENT;
    public static string IDS_V_B_ARGUMENT;
    public static string IDS_BUILT_IN_TYPE_NAME;
    public static string IDS_CAST_TARGET;
    public static string IDS_IMPORT_CLAUSE;
    public static string IDS_DECLARED_TYPE_USAGE;
    public static string IDS_TYPE_USAGE;
    public static string IDS_REGULAR_PARAMETER_LIST;
    public static string IDS_FLOATING_POINT_TYPE_NAME;
    public static string IDS_HANDLES_OR_IMPLEMENTS_CLAUSE;
    public static string IDS_INTEGRAL_TYPE_NAME;
    public static string IDS_PRIMITIVE_TYPE_NAME;
    public static string IDS_NUMERIC_TYPE_NAME;
    public static string IDS_TYPE_CHAR;
    public static string IDS_PROPERTY_INITIALIZER;
    public static string IDS_VARIABLE_INITIALIZER;
    public static string IDS_OBJECT_CREATION_INITIALIZER;
    public static string IDS_OBJECT_COLLECTION_INITIALIZER;
    public static string IDS_OBJECT_CREATION_EXPRESSION_INITIALIZER;
    public static string IDS_ACCESSOR_KEYWORD;
    public static string IDS_ACCESS_MODIFIER;
    public static string IDS_OVERLOAD_OPERATOR_SIGN;
    public static string IDS_ASSIGNMENT_OP_SIGN;
    public static string IDS_CASE_CLAUSE;
    public static string IDS_COMPARISON_OPERATOR;
    public static string IDS_EXIT_KIND;
    public static string IDS_LABEL_NAME;
    public static string IDS_LOOP_CONTROL_VARIABLE;
    public static string IDS_CONTINUE_KIND;
    public static string IDS_TYPE_PARAMETER_CONSTRAINT;
    public static string IDS_TYPE_PARAMETER_DECLARATION;
    public static string IDS_COLLECTION_ELEMENT_INITIALIZER;
    public static string IDS__ON_ERROR_GOTO_LABEL_AUX;
    public static string IDS_IMPLEMENTS_CLAUSE;
    public static string IDS_HANDLES_CLAUSE;
    public static string IDS_MODIFIER;
    public static string IDS_PARAMETER_MODIFIER;
    public static string IDS_ARRAY_MODIFIER;
    public static string IDS_ARRAY_RANK_MODIFIER;
    public static string IDS_ARRAY_SIZE_MODIFIER;
    public static string IDS_CHARSET_MODIFIER;
    public static string IDS_QUERY_OPERATOR;
    public static string IDS_AGGREGATE_QUERY_OPERATOR;
    public static string IDS_FROM_QUERY_OPERATOR;
    public static string IDS_GROUP_BY_QUERY_OPERATOR;
    public static string IDS_GROUP_JOIN_QUERY_OPERATOR;
    public static string IDS_CONVERSION_OPERATOR_DECLARATION;
    public static string IDS_SIGN_OPERATOR_DECLARATION;
    public static string IDS_EVENT_DECLARATION;
    public static string IDS_V_B_EXPRESSION;
    public static string IDS_CAST_EXPRESSION;
    public static string IDS_INSTANCE_EXPRESSION;
    public static string IDS_V_B_LITERAL_EXPRESSION;
    public static string IDS_NEW_EXPRESSION;
    public static string IDS_PRIMARY_EXPRESSION;
    public static string IDS_ANONYMOUS_OBJECT_CREATION_EXPRESSION;
    public static string IDS_LAMBDA_EXPRESSION;
    public static string IDS_LAMBDA_FUNCTION_EXPRESSION;
    public static string IDS_LAMBDA_SUB_EXPRESSION;
    public static string IDS_BLOCK_IF_STATEMENT;
    public static string IDS_LINE_IF_STATEMENT;
    public static string IDS_FOR_EACH_STATEMENT;
    public static string IDS_FOR_STATEMENT;
    public static string IDS_LOOP_STATEMENT;
    public static string IDS_LABEL_OR_STATEMENT_AUX;
    public static string IDS_USING_STATEMENT_RESOURCES;
    public static string IDS_END_REGION_PREPROCESSOR_DIRECTIVE;
    public static string IDS_END_EXTERNAL_SOURCE_PREPROCESSOR_DIRECTIVE;
    public static string IDS_EXPRESSION_RANGE_VARIABLE_DECLARATION_LIST;
    public static string IDS_INTERPOLATED_STRING_EXPRESSION;
    public static string IDS_WARNING_PREPROCESSOR_DIRECTIVE;
    public static string IDS_V_B_XML_MISC;
    public static string IDS_V_B_XML_EMBEDDED_EXPRESSION;
    public static string IDS_V_B_XML_LITERAL_EXPRESSION;
    public static string IDS_V_B_XML_MEMBER_ACCESS_EXPRESSION;
    public static string IDS_V_B_XML_ELEMENT;
    public static string IDS_V_B_XML_ATTRIBUTE;
    public static string GetString(string id);
    public static string GetUnexpectedTokenMessage();
    public static string GetUnexpectedTokenMessage(TokenNodeType tokenType);
    public static string GetUnexpectedEofMessage();
    public static string GetExpectedMessage(string expectedSymbol);
    public static string GetExpectedMessage(string firstExpectedSymbol, string secondExpectedSymbol);
}
internal class JetBrains.ReSharper.Psi.VB.Parsing.VBFilteringLexer : FilteringLexer {
    private TokenNodeType myPrevToken;
    private bool mySkippedLineContinuation;
    private VBPreProcessor myPreProcessor;
    public object CurrentPosition { get; public set; }
    public TokenNodeType PrevToken { get; }
    public bool HasSkippedLineContinuation { get; }
    public VBFilteringLexer(ILexer lexer, VBPreProcessor preProcessor);
    protected virtual bool Skip(TokenNodeType tokenType);
    public virtual void Start();
    public virtual void Advance();
    public virtual object get_CurrentPosition();
    public virtual void set_CurrentPosition(object value);
    public sealed virtual TokenNodeType get_PrevToken();
    public sealed virtual bool get_HasSkippedLineContinuation();
}
public class JetBrains.ReSharper.Psi.VB.Parsing.VBLexer : object {
    private IBuffer myBuffer;
    private VBLexerState myState;
    private IIncrementalLexer myUnderlyingLexer;
    private static NodeTypeSet ourDeclarationsWithParameterList;
    private static NodeTypeSet ourPrevTokensForImplicitLineContinuation;
    private static NodeTypeSet ourNextTokensForImplicitLineContinuation;
    private static NodeTypeSet ourSkipTokens;
    private static NodeTypeSet ourVBTokensToStartXMLAfter;
    public object CurrentPosition { get; public set; }
    public int TokenEnd { get; }
    public int TokenStart { get; }
    public TokenNodeType TokenType { get; }
    public IBuffer Buffer { get; }
    public VBLexer(IBuffer buffer);
    private static VBLexer();
    public static bool IsKeyword(string str);
    [CanBeNullAttribute]
public static TokenNodeType GetKeyword(string keyword);
    public sealed virtual void Start();
    public sealed virtual void Advance();
    private bool IsImplicitLineContinuation();
    private Nullable`1<ParsingMode> TrySwitchLexingMode();
    private bool LambdaWithXmlCase();
    private bool HeurisitcallyShouldParseAsAttribute(IList`1<TokenNodeType> tokensAtLine);
    private ParsingMode ShouldSwitchToVBAfterXml();
    private void SwitchLexingMode(ParsingMode newMode);
    public sealed virtual object get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(object value);
    public sealed virtual int get_TokenEnd();
    public sealed virtual int get_TokenStart();
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual IBuffer get_Buffer();
}
public class JetBrains.ReSharper.Psi.VB.Parsing.VBLexerGenerated : object {
    private static int YY_F;
    private static int YY_NO_STATE;
    private static int YY_NOT_ACCEPT;
    private static int YY_START;
    private static int YY_END;
    private static int YY_NO_ANCHOR;
    private static int YY_BOL;
    private static int YY_EOF;
    private int yy_buffer_index;
    private int yy_buffer_start;
    private int yy_buffer_end;
    private IBuffer yy_buffer;
    private int yy_eof_pos;
    private bool yy_at_bol;
    private int yy_lexical_state;
    protected static int INTERPOLATEDAFTERIDENTIFIER;
    protected static int YYINITIAL;
    protected static int AFTERIDENTIFIER;
    protected static int INTERPOLATED;
    protected static int AFTERDOT;
    private static Int32[] yy_state_dtrans;
    private static int YY_E_INTERNAL;
    private static int YY_E_MATCH;
    private static String[] yy_error_string;
    private static Int32[] yy_acpt;
    private static Int32[] yy_cmap;
    private static Int32[] yy_rmap;
    private static Int32[0...,0...] yy_nxt;
    protected TokenNodeType currTokenType;
    private ulong interpolationDepth;
    private ReusableBufferRange myBuffer;
    protected internal static LexerDictionary`1<TokenNodeType> keywords;
    public UInt32 LexerStateEx { get; }
    public VBLexerState CurrentPosition { get; public set; }
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public int LexemIndent { get; }
    public IBuffer Buffer { get; }
    protected int BufferIndex { get; protected set; }
    protected int BufferStart { get; protected set; }
    protected int BufferEnd { get; protected set; }
    public int EOFPos { get; }
    protected int LexicalState { get; protected set; }
    public VBLexerGenerated(IBuffer buffer);
    public VBLexerGenerated(IBuffer buffer, int startOffset, int endOffset);
    private static VBLexerGenerated();
    private void yybegin(int state);
    private void yy_move_end();
    private static bool yy_isnewline(char c);
    internal string yytext();
    private int yylength();
    private void yy_error(int code, bool fatal);
    public TokenNodeType _locateToken();
    private TokenNodeType FindKeywordByCurrentToken();
    protected TokenNodeType makeToken(TokenNodeType type);
    protected TokenNodeType makeKeywordToken(TokenNodeType type);
    private void enterInterpolation();
    private void exitInterpolation();
    public sealed virtual void Start();
    public sealed virtual void Start(int startOffset, int endOffset, UInt32 state);
    public sealed virtual void Advance();
    public sealed virtual UInt32 get_LexerStateEx();
    public sealed virtual VBLexerState get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(VBLexerState value);
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual int get_LexemIndent();
    public sealed virtual IBuffer get_Buffer();
    protected int get_BufferIndex();
    protected void set_BufferIndex(int value);
    protected int get_BufferStart();
    protected void set_BufferStart(int value);
    protected int get_BufferEnd();
    protected void set_BufferEnd(int value);
    public sealed virtual int get_EOFPos();
    protected int get_LexicalState();
    protected void set_LexicalState(int value);
    protected virtual void locateToken();
}
public class JetBrains.ReSharper.Psi.VB.Parsing.VBLexerState : ValueType {
    public TokenNodeType currTokenType;
    public ulong interpolationDepth;
    public int yy_buffer_index;
    public int yy_buffer_start;
    public int yy_buffer_end;
    public int yy_lexical_state;
}
internal class JetBrains.ReSharper.Psi.VB.Parsing.VBMissingTokensInserter : MissingTokenInserterBase {
    private ILexer myLexer;
    private PreProcessorParser myPreProcessorParser;
    private Func`2<ILexer, LeafElementBase> myTokenFactory;
    private VBMissingTokensInserter(ILexer lexer, ITokenOffsetProvider offsetProvider, PreProcessorParser preProcessorParser, Func`2<ILexer, LeafElementBase> tokenFactory, ITokenIntern intern);
    protected virtual void ProcessLeafElement(TreeElement root);
    private TreeElement CreateMissingElement();
    [CanBeNullAttribute]
private static TreeElement FindDocCommentTarget(TreeElement element);
    private void Patch(CompositeElement root);
    private static bool ShouldMoveToFileHeader(ITreeNode node);
    public static void Run(TreeElement node, ILexer lexer, ITokenOffsetProvider offsetProvider, bool trimTokens, PreProcessorParser preProcessorParser, Func`2<ILexer, LeafElementBase> tokenFactory, ITokenIntern intern);
}
internal class JetBrains.ReSharper.Psi.VB.Parsing.VBParser : VBParserGenerated {
    private ILexer`1<int> myOriginalLexer;
    private CommonIdentifierIntern myCommonIdentifierIntern;
    private VBPreProcessor myPreProcessor;
    private bool myIsForLoopBlock;
    private int myPendingNextClauseExpressions;
    private CompositeElement myInnermostUnclosedFor;
    private Func`3<TreeTextRange, TreeElement, CompositeElement> myOpenChameleons;
    private static NodeTypeSet ourLineTerminatorSet;
    private static NodeTypeSet ourLineTerminatorAndColonSet;
    private HashSet`1<TreeElement> mySimpleReferenceNameFromTypeName;
    private HashSet`1<int> mySkippedImplicitLineContinuations;
    private ITokenIntern myTokenIntern;
    private static NodeTypeSet ourEndFunctionTokens;
    private static NodeTypeSet LogicalXorExpressionOps;
    private static NodeTypeSet LogicalOrExpressionOps;
    private static NodeTypeSet LogicalAndExpressionOps;
    private static NodeTypeSet LogicalNotExpressionOps;
    private static NodeTypeSet ShiftExpressionOps;
    private static NodeTypeSet ConcatenationExpressionOps;
    private static NodeTypeSet AdditiveExpressionOps;
    private static NodeTypeSet ModulusExpressionOps;
    private static NodeTypeSet IntegerDivisionExpressionOps;
    private static NodeTypeSet MultiplicativeExpressionOps;
    private static NodeTypeSet UnaryNegationExpressionOps;
    private static NodeTypeSet ExponentiationExpressionOps;
    private static int BalanceThreshold;
    public Func`3<TreeTextRange, TreeElement, CompositeElement> OpenChameleonStrategy { get; }
    public Func`3<TreeTextRange, TreeElement, CompositeElement> BindedToBufferChameleonStrategy { get; }
    public ITokenIntern TokenIntern { get; }
    public VBParser(ILexer`1<int> lexer, IPsiModule psiModule, IEnumerable`1<PreProcessingDirective> defines, CommonIdentifierIntern commonIdentifierIntern);
    private static VBParser();
    private void InsertMissingTokens(TreeElement result, bool trimMissingTokens, ITokenIntern intern);
    public sealed virtual IFile ParseFile();
    public sealed virtual IFile ParseFile(Func`3<TreeTextRange, TreeElement, CompositeElement> chameleonStrategy);
    private sealed virtual override IBlock JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.ParseBlock();
    private sealed virtual override IBlock JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.OpenChameleonBlock(ITreeNode owner);
    private sealed virtual override IVBExpression JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.ParseExpression();
    private sealed virtual override IVBStatement JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.ParseStatement();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.ParseMemberDeclaration();
    protected virtual TreeElement CreateToken();
    private TreeElement createToken(TokenNodeType tokenType);
    public virtual TreeElement ParseErrorElement();
    public virtual void ParseLineTerminators(CompositeElement result);
    public virtual void ParseImplicitLineContinuation(CompositeElement result);
    public virtual void ParseStatementTerminator(CompositeElement result);
    private void ParseStatementTerminator(CompositeElement result, bool hungry);
    private bool ExpectStatementTerminator();
    public virtual void ParseDeclarationTerminator(CompositeElement result);
    private void skipLineTerminators();
    protected virtual TreeElement MatchImplicitLineContinuation();
    protected virtual bool ExpectImplicitLineContinuation();
    protected bool ExpectImplicitLineContinuation(TokenNodeType firstTokenType, TokenNodeType nextTokenType);
    public virtual TreeElement ParseVBFile();
    private TreeElement TryParseGlobalAttributeList();
    private bool ExpectGlobalAttributeSection();
    protected virtual CompositeElement HandleErrorInAccessorDeclaration(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseAttributeList();
    public virtual TreeElement ParseVBArgument();
    public virtual TreeElement ParseEmptyArgument();
    protected virtual TreeElement MatchAutoKeyword();
    protected virtual bool ExpectAutoKeyword();
    protected virtual TreeElement MatchAnsiKeyword();
    protected virtual bool ExpectAnsiKeyword();
    protected virtual TreeElement MatchUnicodeKeyword();
    protected virtual bool ExpectUnicodeKeyword();
    protected virtual TreeElement MatchisCustomKeyword();
    protected virtual bool ExpectisCustomKeyword();
    protected virtual TreeElement MatchisPreserveKeyword();
    protected virtual bool ExpectisPreserveKeyword();
    private static bool IsIdentifierOrKeyword(NodeType tokenType);
    protected virtual TreeElement MatchvBAttributeTargert();
    protected virtual bool ExpectvBAttributeTargert();
    private bool ExpectIdentifierKeyword(string text);
    public virtual TreeElement ParseIdentifierOrKeyword();
    public virtual TreeElement ParseVBIdentifier();
    private TreeElement MatchIdentifierKeyword(TokenNodeType type);
    protected virtual TreeElement MatchregionPPDirective();
    protected virtual bool ExpectregionPPDirective();
    protected virtual TreeElement MatchEnablePPDirective();
    protected virtual bool ExpectEnablePPDirective();
    protected virtual TreeElement MatchDisablePPDirective();
    protected virtual bool ExpectDisablePPDirective();
    protected virtual TreeElement MatchWarningPPDirective();
    protected virtual bool ExpectWarningPPDirective();
    protected virtual TreeElement MatchexternalSourcePPDirective();
    protected virtual bool ExpectexternalSourcePPDirective();
    protected virtual TreeElement MatchexternalChecksumPPDirective();
    protected virtual bool ExpectexternalChecksumPPDirective();
    protected virtual TreeElement MatchIsTrueKeyword();
    protected virtual bool ExpectIsTrueKeyword();
    protected virtual TreeElement MatchIsFalseKeyword();
    protected virtual bool ExpectIsFalseKeyword();
    protected virtual TreeElement MatchOutKeyword();
    protected virtual bool ExpectOutKeyword();
    protected virtual TreeElement MatchUntilKeyword();
    protected virtual bool ExpectUntilKeyword();
    protected virtual TreeElement MatchMidKeyword();
    protected virtual bool ExpectMidKeyword();
    protected virtual TreeElement MatchKeySpecifier();
    protected virtual bool ExpectKeySpecifier();
    protected virtual TreeElement MatchIteratorKeyword();
    protected virtual bool ExpectIteratorKeyword();
    protected virtual TreeElement MatchAsyncKeyword();
    protected virtual bool ExpectAsyncKeyword();
    protected virtual TreeElement MatchYieldKeyword();
    protected virtual bool ExpectYieldKeyword();
    private TokenNodeType LookaheadThroughStatementTerminators();
    public virtual TreeElement ParseOptionStatementsSection();
    public virtual TreeElement ParseImportDirectivesSection();
    public virtual TreeElement ParseImportClause();
    public virtual TreeElement ParseSimpleReferenceName();
    public virtual TreeElement ParseQualifiedNamespaceName();
    public virtual TreeElement ParseReferenceName(TreeElement id);
    public virtual TreeElement ParseClassBody();
    public virtual void ParseRegularTypeMemberDeclarationAux(CompositeElement result, TreeElement attr, TreeElement mods);
    public virtual void ParseNameWithTypeParameterAux(CompositeElement result);
    public virtual void ParseNameWithTypeParameterOfMethodAux(CompositeElement result);
    public virtual TreeElement ParseTupleTypeComponent();
    private TreeElement ParseTupleUsage(ICompositeNodeType elementType);
    public virtual TreeElement ParseTupleTypeUsage();
    public virtual TreeElement ParseTupleDeclaredTypeUsage();
    public virtual TreeElement ParseTypeDeclarationError(TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseRegularTypeMemberDeclarationAuxError(TreeElement attrs, TreeElement mods);
    private static bool HasModifier(IModifiersList list, TokenNodeType modifier);
    public virtual TreeElement ParsePropertyDeclaration(TreeElement attrs, TreeElement mods);
    private bool IsDeclaredAutoProperty(IPropertyDeclaration header);
    public virtual TreeElement ParseEventDeclaration(TreeElement attrs, TreeElement mods);
    public virtual TreeElement ParseMethodDeclaration(TreeElement attrs, TreeElement mods);
    public virtual void ParseStatementAux(CompositeElement result);
    public sealed virtual Func`3<TreeTextRange, TreeElement, CompositeElement> get_OpenChameleonStrategy();
    public sealed virtual Func`3<TreeTextRange, TreeElement, CompositeElement> get_BindedToBufferChameleonStrategy();
    public ITokenIntern get_TokenIntern();
    private NodeTypeSet GetCorrespondingEndToken(TreeElement declaration);
    public virtual void ParseBody(CompositeElement result);
    private string GetEndConstructTest(CompositeElement result);
    public virtual void ParseLambdaBlock(CompositeElement result);
    private bool ShouldProceedBodyBlock(TokenNodeType nodeType, bool isFunctionBody, NodeTypeSet endTokens);
    private TreeElement ParseStatementBodyBlock(NodeTypeSet startToken, bool isFunctionBody, NodeTypeSet endTokens);
    public virtual TreeElement ParseBlock();
    public virtual void ParseLoopControlVariable(CompositeElement result);
    private bool IsLoopControlVariableDeclaration();
    public virtual void ParseLabelOrStatementAux(CompositeElement result);
    public virtual void ParseIfStatement(CompositeElement result);
    private bool IsUsingStatementVariableDeclaration();
    private void skipIntoErrorUntil(CompositeElement result, Func`1<bool> expectToken, string message);
    public virtual void ParseUsingStatementResources(CompositeElement result);
    public virtual void ParseForLoopBodyAux(CompositeElement result);
    public virtual void ParseCatchVariableResource(CompositeElement result);
    protected virtual CompositeElement HandleErrorInPreprocessorDirective(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseInterfaceMemberSpecifier();
    protected virtual CompositeElement HandleErrorInRegularParameterList(CompositeElement result, SyntaxError error);
    public virtual TreeElement ParseRedimClause();
    public virtual TreeElement ParseExternalMethodDeclaration(TreeElement attr, TreeElement mods);
    public virtual TreeElement ParseUnknownPreprocessorDirective(TreeElement sharp);
    public virtual TreeElement ParseLambdaSignature();
    public virtual TreeElement ParseSimpleControlReference();
    public virtual TreeElement ParseControlReference(TreeElement id);
    public virtual TreeElement ParseEventSpecifier();
    public virtual TreeElement ParseVBExpression();
    public virtual TreeElement ParseLogicalXorExpression();
    public virtual TreeElement ParseLogicalOrExpression();
    public virtual TreeElement ParseLogicalAndExpression();
    public virtual TreeElement ParseLogicalNotExpression();
    public virtual TreeElement ParseShiftExpression();
    public virtual TreeElement ParseConcatenationExpression();
    public virtual TreeElement ParseAdditiveExpression();
    public virtual TreeElement ParseModulusExpression();
    public virtual TreeElement ParseIntegerDivisionExpression();
    public virtual TreeElement ParseMultiplicativeExpression();
    public virtual TreeElement ParseUnaryNegationExpression();
    public virtual TreeElement ParseExponentiationExpression();
    private TreeElement ParseExponentiationExpressionSecondOperand();
    private TreeElement ParseBalancedBinaryExpression(CompositeNodeType nodeType, NodeTypeSet ops, Func`1<TreeElement> firstOpParser, Func`1<TreeElement> secondOpParser);
    private TreeElement ParseBinaryExpression(CompositeNodeType nodeType, NodeTypeSet ops, Func`1<TreeElement> firstOpParser, Func`1<TreeElement> secondOpParser);
    private TreeElement ParseUnaryExpression(CompositeNodeType nodeType, NodeTypeSet ops, Func`1<TreeElement> operandParser);
    public virtual TreeElement ParseRelationalExpression();
    private TreeElement ParseLikeOrIsExpressionAux(CompositeNodeType elementType, TreeElement leftOperand);
    private TreeElement ParseRelationalExpressionAux(CompositeNodeType elementType, TreeElement leftOperand);
    public virtual TreeElement ParseIsExpression();
    public virtual TreeElement ParseIsNotExpression();
    public virtual TreeElement ParseLikeExpression();
    public virtual TreeElement ParseTypeOfIsExpression();
    protected virtual TreeElement MatchFromKeyword();
    protected virtual bool ExpectFromKeyword();
    protected virtual TreeElement MatchAggregateKeyword();
    protected virtual bool ExpectAggregateKeyword();
    protected virtual TreeElement MatchAscendingKeyword();
    protected virtual bool ExpectAscendingKeyword();
    protected virtual TreeElement MatchByKeyword();
    protected virtual bool ExpectByKeyword();
    protected virtual TreeElement MatchDescendingKeyword();
    protected virtual bool ExpectDescendingKeyword();
    protected virtual TreeElement MatchDistinctKeyword();
    protected virtual bool ExpectDistinctKeyword();
    protected virtual TreeElement MatchEqualsKeyword();
    protected virtual bool ExpectEqualsKeyword();
    protected virtual TreeElement MatchGroupKeyword();
    protected virtual bool ExpectGroupKeyword();
    protected virtual TreeElement MatchIntoKeyword();
    protected virtual bool ExpectIntoKeyword();
    protected virtual TreeElement MatchJoinKeyword();
    protected virtual bool ExpectJoinKeyword();
    protected virtual TreeElement MatchOrderKeyword();
    protected virtual bool ExpectOrderKeyword();
    protected virtual TreeElement MatchSkipKeyword();
    protected virtual bool ExpectSkipKeyword();
    protected virtual TreeElement MatchTakeKeyword();
    protected virtual bool ExpectTakeKeyword();
    protected virtual TreeElement MatchWhereKeyword();
    protected virtual bool ExpectWhereKeyword();
    protected virtual TreeElement MatchAwaitKeyword();
    protected virtual bool ExpectAwaitKeyword();
    private bool IsQueryExpressionStarts();
    private bool IsLamdaExpressionStarts();
    private TreeElement ParseSimplePrimaryExpression();
    public virtual TreeElement ParseTupleExpression();
    public virtual TreeElement ParseTupleComponent();
    private CompositeElement ParseTupleExpression(TreeElement lParenth, TreeElement continuation, TreeElement firstComponent);
    private CompositeElement ParseParenthesizedExpression(TreeElement lParenth, TreeElement continuation, TreeElement expression);
    private TreeElement ParseParenthesizedOrTupleExpression();
    public virtual TreeElement ParsePrimaryExpression();
    private TreeElement TryParseCommonExpressions(TreeElement operand);
    public virtual TreeElement ParseNewExpression();
    private bool IsArrayCreation();
    private bool ExpectObjectCreationInitializer();
    private bool ExpectObjectCollectionInitializer();
    public virtual void ParseObjectCreationExpressionInitializer(CompositeElement result);
    public virtual TreeElement ParseSimpleReferenceExpression();
    public virtual TreeElement ParseReferenceExpression(TreeElement expr, TreeElement quest, TreeElement dot);
    public virtual TreeElement ParseAnonymousMemberDeclaration();
    public virtual TreeElement ParseExpressionRangeVariableDeclaration();
    public virtual TreeElement ParseAggregatedRangeVariableDeclaration();
    public virtual TreeElement ParseMemberAccessExpression(TreeElement expr);
    public virtual TreeElement ParseMemberAccessExpressionError(TreeElement expr, TreeElement quest, TreeElement dot);
    private bool ExpectQueryOperator();
    public virtual TreeElement ParseQueryExpression();
    public virtual TreeElement ParseJoinQueryConditionsListFake();
    public virtual TreeElement ParseQueryConditionsList();
    private static CompositeElement EnPlatform(TreeElement expression);
    private bool ExpectRBrace();
    public virtual void ParseMultiArgumentCollectionElementInitializer(CompositeElement result);
    public virtual void ParseOnErrorGotoLabelAux(CompositeElement result);
    private bool IsOnErrorSpecialLabel();
    public virtual TreeElement ParseVBXmlElement();
    public virtual TreeElement ParseVBXmlProcessingInstruction();
    [CompilerGeneratedAttribute]
private LeafElementBase <InsertMissingTokens>b__11_0(ILexer lexer);
    [CompilerGeneratedAttribute]
private VBFile <ParseFile>b__12_0(ITokenIntern intern);
    [CompilerGeneratedAttribute]
private IBlock <JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.ParseBlock>b__14_0(ITokenIntern intern);
    [CompilerGeneratedAttribute]
private IVBExpression <JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.ParseExpression>b__16_0(ITokenIntern intern);
    [CompilerGeneratedAttribute]
private IVBStatement <JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.ParseStatement>b__17_0(ITokenIntern intern);
    [CompilerGeneratedAttribute]
private TreeElement <JetBrains.ReSharper.Psi.VB.Parsing.IVBParser.ParseMemberDeclaration>b__18_0(ITokenIntern intern);
    [CompilerGeneratedAttribute]
private CompositeElement <get_OpenChameleonStrategy>b__113_0(TreeTextRange range, TreeElement owner);
    [CompilerGeneratedAttribute]
private CompositeElement <get_BindedToBufferChameleonStrategy>b__115_0(TreeTextRange range, TreeElement owner);
    [CompilerGeneratedAttribute]
private bool <ParseCatchVariableResource>b__133_0();
}
internal class JetBrains.ReSharper.Psi.VB.Parsing.VBPartLexer : VBLexerGenerated {
    [NotNullAttribute]
private static Dictionary`2<TokenNodeType, TokenNodeType> ourCompoundTokens;
    private static VBPartLexer();
    public VBPartLexer(IBuffer buffer);
    public VBPartLexer(IBuffer buffer, int startOffset, int endOffset);
    protected virtual void locateToken();
}
internal class JetBrains.ReSharper.Psi.VB.Parsing.VBPreProcessor : object {
    private ITokenOffsetProvider myOffsetProvider;
    private IPsiModule myPsiModule;
    private Dictionary`2<string, Func`1<ConstantValue>> myConstantValueCalculators;
    private Dictionary`2<string, ConstantValue> myConstantValueCache;
    private Stack`1<bool> myIfBranchesStack;
    private Dictionary`2<int, ParsedPPDirective> myPpDirectiveByOffset;
    private List`1<TextRange> myPPRanges;
    private HashSet`1<string> myUsedConditionalNames;
    private HashSet`1<string> myDefinedConditionalNames;
    private JetHashSet`1<string> myNamesInProgress;
    private bool myHavePpDirectives;
    private bool myIsNotPreprocessing;
    private bool myHasLastPpRange;
    private bool myLastPpRangeValue;
    private int myLastPpRangeStart;
    private int myLastPpRangeEnd;
    public PreProcessingDirectivesInFile ConditionalNames { get; }
    public bool HasPPDirectives { get; }
    public VBPreProcessor(ITokenOffsetProvider offsetProvider, IPsiModule psiModule, IEnumerable`1<PreProcessingDirective> defines);
    public bool IsPPToken(int startOffset);
    public PreProcessingDirectivesInFile get_ConditionalNames();
    public bool get_HasPPDirectives();
    public bool HasPPDirectiveInRange(TextRange range);
    public void PreProcess(ILexer originalLexer, VBFilteringLexer lexer, VBParser parser, ITokenIntern intern);
    private ConstantValue GetValueByName(string name);
    private void HandleConstDirective(IConstPreprocessorDirective node);
    private void HandleIfDirective(VBFilteringLexer lexer, IIfPreprocessorDirective node);
    private void HandleElseIfDirective(VBFilteringLexer lexer, IElseIfPreprocessorDirective node);
    private void HandleElseDirective(VBFilteringLexer lexer, IElsePreprocessorDirective node);
    private void HandleEndIfDirective();
    private void ParseInactiveBranch(VBFilteringLexer lexer, CompositeElement ppDirective);
    private bool CalculateBoolExpression(IVBExpression expression);
    private ConstantValue CalculateExpression(IVBExpression expression);
    private static ITreeNode FindFirstTokenIn(ITreeNode parent);
    private void PlanarizeElement(ITreeNode node);
    private void PlanarizePPDirective(ParsedPPDirective directive);
    public TreeElement GetPPDirectiveAtPosition(int offset);
}
public class JetBrains.ReSharper.Psi.VB.Parsing.VBTokenType : object {
    public static int ADDHANDLER_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ADDHANDLER_KEYWORD;
    public static int ADDRESSOF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ADDRESSOF_KEYWORD;
    public static int ALIAS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ALIAS_KEYWORD;
    public static int AND_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType AND_KEYWORD;
    public static int ANDALSO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ANDALSO_KEYWORD;
    public static int ANSI_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ANSI_KEYWORD;
    public static int AS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType AS_KEYWORD;
    public static int AUTO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType AUTO_KEYWORD;
    public static int BOOLEAN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BOOLEAN_KEYWORD;
    public static int BYREF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BYREF_KEYWORD;
    public static int BYTE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BYTE_KEYWORD;
    public static int BYVAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BYVAL_KEYWORD;
    public static int CALL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CALL_KEYWORD;
    public static int CASE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CASE_KEYWORD;
    public static int CATCH_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CATCH_KEYWORD;
    public static int CBOOL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CBOOL_KEYWORD;
    public static int CBYTE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CBYTE_KEYWORD;
    public static int CCHAR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CCHAR_KEYWORD;
    public static int CDATE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CDATE_KEYWORD;
    public static int CDBL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CDBL_KEYWORD;
    public static int CDEC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CDEC_KEYWORD;
    public static int CHAR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CHAR_KEYWORD;
    public static int CINT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CINT_KEYWORD;
    public static int CLASS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CLASS_KEYWORD;
    public static int CLNG_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CLNG_KEYWORD;
    public static int COBJ_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType COBJ_KEYWORD;
    public static int CONST_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CONST_KEYWORD;
    public static int CSHORT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CSHORT_KEYWORD;
    public static int CSNG_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CSNG_KEYWORD;
    public static int CSTR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CSTR_KEYWORD;
    public static int CTYPE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CTYPE_KEYWORD;
    public static int DATE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DATE_KEYWORD;
    public static int DECIMAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DECIMAL_KEYWORD;
    public static int DECLARE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DECLARE_KEYWORD;
    public static int DEFAULT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DEFAULT_KEYWORD;
    public static int DELEGATE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DELEGATE_KEYWORD;
    public static int DIM_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DIM_KEYWORD;
    public static int DIRECTCAST_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DIRECTCAST_KEYWORD;
    public static int DO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DO_KEYWORD;
    public static int DOUBLE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DOUBLE_KEYWORD;
    public static int EACH_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType EACH_KEYWORD;
    public static int ELSE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ELSE_KEYWORD;
    public static int ELSEIF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ELSEIF_KEYWORD;
    public static int END_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType END_KEYWORD;
    public static int ENDIF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ENDIF_KEYWORD;
    public static int ENUM_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ENUM_KEYWORD;
    public static int ERASE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ERASE_KEYWORD;
    public static int ERROR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ERROR_KEYWORD;
    public static int EVENT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType EVENT_KEYWORD;
    public static int EXIT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType EXIT_KEYWORD;
    public static int FALSE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FALSE_KEYWORD;
    public static int FINALLY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FINALLY_KEYWORD;
    public static int FOR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FOR_KEYWORD;
    public static int FRIEND_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FRIEND_KEYWORD;
    public static int FUNCTION_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FUNCTION_KEYWORD;
    public static int GET_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GET_KEYWORD;
    public static int GETTYPE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GETTYPE_KEYWORD;
    public static int GOSUB_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GOSUB_KEYWORD;
    public static int GOTO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GOTO_KEYWORD;
    public static int HANDLES_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType HANDLES_KEYWORD;
    public static int IF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IF_KEYWORD;
    public static int IMPLEMENTS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IMPLEMENTS_KEYWORD;
    public static int IMPORTS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IMPORTS_KEYWORD;
    public static int IN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IN_KEYWORD;
    public static int INHERITS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType INHERITS_KEYWORD;
    public static int INTEGER_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType INTEGER_KEYWORD;
    public static int INTERFACE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType INTERFACE_KEYWORD;
    public static int IS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType IS_KEYWORD;
    public static int LET_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LET_KEYWORD;
    public static int LIB_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LIB_KEYWORD;
    public static int LIKE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LIKE_KEYWORD;
    public static int LONG_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LONG_KEYWORD;
    public static int LOOP_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType LOOP_KEYWORD;
    public static int ME_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ME_KEYWORD;
    public static int MOD_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType MOD_KEYWORD;
    public static int MODULE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType MODULE_KEYWORD;
    public static int MUSTINHERIT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType MUSTINHERIT_KEYWORD;
    public static int MUSTOVERRIDE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType MUSTOVERRIDE_KEYWORD;
    public static int MYBASE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType MYBASE_KEYWORD;
    public static int MYCLASS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType MYCLASS_KEYWORD;
    public static int NAMESPACE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NAMESPACE_KEYWORD;
    public static int NEW_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NEW_KEYWORD;
    public static int NEXT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NEXT_KEYWORD;
    public static int NOT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NOT_KEYWORD;
    public static int NOTHING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NOTHING_KEYWORD;
    public static int NOTINHERITABLE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NOTINHERITABLE_KEYWORD;
    public static int NOTOVERRIDABLE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NOTOVERRIDABLE_KEYWORD;
    public static int OBJECT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OBJECT_KEYWORD;
    public static int ON_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ON_KEYWORD;
    public static int OPTION_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OPTION_KEYWORD;
    public static int OPTIONAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OPTIONAL_KEYWORD;
    public static int OR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OR_KEYWORD;
    public static int ORELSE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ORELSE_KEYWORD;
    public static int OVERLOADS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OVERLOADS_KEYWORD;
    public static int OVERRIDABLE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OVERRIDABLE_KEYWORD;
    public static int OVERRIDES_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OVERRIDES_KEYWORD;
    public static int PARAMARRAY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PARAMARRAY_KEYWORD;
    public static int PRESERVE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PRESERVE_KEYWORD;
    public static int PRIVATE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PRIVATE_KEYWORD;
    public static int PROPERTY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PROPERTY_KEYWORD;
    public static int PROTECTED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PROTECTED_KEYWORD;
    public static int PUBLIC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PUBLIC_KEYWORD;
    public static int RAISEEVENT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType RAISEEVENT_KEYWORD;
    public static int READONLY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType READONLY_KEYWORD;
    public static int REDIM_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType REDIM_KEYWORD;
    public static int REM_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType REM_KEYWORD;
    public static int REMOVEHANDLER_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType REMOVEHANDLER_KEYWORD;
    public static int RESUME_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType RESUME_KEYWORD;
    public static int RETURN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType RETURN_KEYWORD;
    public static int SELECT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SELECT_KEYWORD;
    public static int SET_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SET_KEYWORD;
    public static int SHADOWS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SHADOWS_KEYWORD;
    public static int SHARED_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SHARED_KEYWORD;
    public static int SHORT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SHORT_KEYWORD;
    public static int SINGLE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SINGLE_KEYWORD;
    public static int STATIC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STATIC_KEYWORD;
    public static int STEP_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STEP_KEYWORD;
    public static int STOP_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STOP_KEYWORD;
    public static int STRING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STRING_KEYWORD;
    public static int STRUCTURE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType STRUCTURE_KEYWORD;
    public static int SUB_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SUB_KEYWORD;
    public static int SYNCLOCK_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SYNCLOCK_KEYWORD;
    public static int THEN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType THEN_KEYWORD;
    public static int THROW_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType THROW_KEYWORD;
    public static int TO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TO_KEYWORD;
    public static int TRUE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TRUE_KEYWORD;
    public static int TRY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TRY_KEYWORD;
    public static int TYPEOF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TYPEOF_KEYWORD;
    public static int UNICODE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType UNICODE_KEYWORD;
    public static int VARIANT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType VARIANT_KEYWORD;
    public static int WEND_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WEND_KEYWORD;
    public static int WHEN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WHEN_KEYWORD;
    public static int WHILE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WHILE_KEYWORD;
    public static int WITH_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WITH_KEYWORD;
    public static int WITHEVENTS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WITHEVENTS_KEYWORD;
    public static int WRITEONLY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WRITEONLY_KEYWORD;
    public static int XOR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType XOR_KEYWORD;
    public static int CSBYTE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CSBYTE_KEYWORD;
    public static int CUSHORT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CUSHORT_KEYWORD;
    public static int CUINT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CUINT_KEYWORD;
    public static int CULNG_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CULNG_KEYWORD;
    public static int CUSTOM_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CUSTOM_KEYWORD;
    public static int SBYTE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SBYTE_KEYWORD;
    public static int USHORT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType USHORT_KEYWORD;
    public static int UINTEGER_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType UINTEGER_KEYWORD;
    public static int ULONG_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ULONG_KEYWORD;
    public static int USING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType USING_KEYWORD;
    public static int CONTINUE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType CONTINUE_KEYWORD;
    public static int TRYCAST_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TRYCAST_KEYWORD;
    public static int GLOBAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GLOBAL_KEYWORD;
    public static int ISNOT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ISNOT_KEYWORD;
    public static int PARTIAL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType PARTIAL_KEYWORD;
    public static int OF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OF_KEYWORD;
    public static int OPERATOR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OPERATOR_KEYWORD;
    public static int WIDENING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WIDENING_KEYWORD;
    public static int NARROWING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NARROWING_KEYWORD;
    public static int GETXMLNAMESPACE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GETXMLNAMESPACE_KEYWORD;
    public static int ISTRUE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ISTRUE_KEYWORD;
    public static int ISFALSE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ISFALSE_KEYWORD;
    public static int FROM_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType FROM_KEYWORD;
    public static int AGGREGATE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType AGGREGATE_KEYWORD;
    public static int JOIN_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType JOIN_KEYWORD;
    public static int EQUALS_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType EQUALS_KEYWORD;
    public static int DISTINCT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DISTINCT_KEYWORD;
    public static int TAKE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType TAKE_KEYWORD;
    public static int SKIP_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType SKIP_KEYWORD;
    public static int INTO_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType INTO_KEYWORD;
    public static int GROUP_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType GROUP_KEYWORD;
    public static int ASCENDING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ASCENDING_KEYWORD;
    public static int DESCENDING_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType DESCENDING_KEYWORD;
    public static int ORDER_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ORDER_KEYWORD;
    public static int BY_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType BY_KEYWORD;
    public static int WHERE_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType WHERE_KEYWORD;
    public static int OUT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType OUT_KEYWORD;
    public static int UNTIL_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType UNTIL_KEYWORD;
    public static int MID_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType MID_KEYWORD;
    public static int ITERATOR_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ITERATOR_KEYWORD;
    public static int ASYNC_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType ASYNC_KEYWORD;
    public static int YIELD_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType YIELD_KEYWORD;
    public static int AWAIT_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType AWAIT_KEYWORD;
    public static int END_ADDHANDLER_NODE_TYPE_INDEX;
    public static TokenNodeType END_ADDHANDLER;
    public static int END_CLASS_NODE_TYPE_INDEX;
    public static TokenNodeType END_CLASS;
    public static int END_ENUM_NODE_TYPE_INDEX;
    public static TokenNodeType END_ENUM;
    public static int END_EVENT_NODE_TYPE_INDEX;
    public static TokenNodeType END_EVENT;
    public static int END_FUNCTION_NODE_TYPE_INDEX;
    public static TokenNodeType END_FUNCTION;
    public static int END_GET_NODE_TYPE_INDEX;
    public static TokenNodeType END_GET;
    public static int END_IF_NODE_TYPE_INDEX;
    public static TokenNodeType END_IF;
    public static int END_INTERFACE_NODE_TYPE_INDEX;
    public static TokenNodeType END_INTERFACE;
    public static int END_MODULE_NODE_TYPE_INDEX;
    public static TokenNodeType END_MODULE;
    public static int END_NAMESPACE_NODE_TYPE_INDEX;
    public static TokenNodeType END_NAMESPACE;
    public static int END_PROPERTY_NODE_TYPE_INDEX;
    public static TokenNodeType END_PROPERTY;
    public static int END_RAISEEVENT_NODE_TYPE_INDEX;
    public static TokenNodeType END_RAISEEVENT;
    public static int END_REMOVEHANDLER_NODE_TYPE_INDEX;
    public static TokenNodeType END_REMOVEHANDLER;
    public static int END_SELECT_NODE_TYPE_INDEX;
    public static TokenNodeType END_SELECT;
    public static int END_SET_NODE_TYPE_INDEX;
    public static TokenNodeType END_SET;
    public static int END_STRUCTURE_NODE_TYPE_INDEX;
    public static TokenNodeType END_STRUCTURE;
    public static int END_SUB_NODE_TYPE_INDEX;
    public static TokenNodeType END_SUB;
    public static int END_SYNCLOCK_NODE_TYPE_INDEX;
    public static TokenNodeType END_SYNCLOCK;
    public static int END_TRY_NODE_TYPE_INDEX;
    public static TokenNodeType END_TRY;
    public static int END_WHILE_NODE_TYPE_INDEX;
    public static TokenNodeType END_WHILE;
    public static int END_WITH_NODE_TYPE_INDEX;
    public static TokenNodeType END_WITH;
    public static int END_OPERATOR_NODE_TYPE_INDEX;
    public static TokenNodeType END_OPERATOR;
    public static int END_USING_NODE_TYPE_INDEX;
    public static TokenNodeType END_USING;
    public static int NAMEOF_KEYWORD_NODE_TYPE_INDEX;
    public static TokenNodeType NAMEOF_KEYWORD;
    public static int BAD_TOKEN_NODE_TYPE_INDEX;
    public static TokenNodeType BAD_TOKEN;
    public static int INTEGER_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType INTEGER_LITERAL;
    public static int FLOATPOINT_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType FLOATPOINT_LITERAL;
    public static int STRING_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType STRING_LITERAL;
    public static int CHAR_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType CHAR_LITERAL;
    public static int DATE_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType DATE_LITERAL;
    public static int MULTILINE_STRING_LITERAL_NODE_TYPE_INDEX;
    public static TokenNodeType MULTILINE_STRING_LITERAL;
    public static int DUMMY_TERMINATOR_NODE_TYPE_INDEX;
    public static TokenNodeType DUMMY_TERMINATOR;
    public static int XML_SCRIPLET_START_NODE_TYPE_INDEX;
    public static TokenNodeType XML_SCRIPLET_START;
    public static int XML_SCRIPLET_END_NODE_TYPE_INDEX;
    public static TokenNodeType XML_SCRIPLET_END;
    public static int LPARENTH_NODE_TYPE_INDEX;
    public static TokenNodeType LPARENTH;
    public static int RPARENTH_NODE_TYPE_INDEX;
    public static TokenNodeType RPARENTH;
    public static int LBRACE_NODE_TYPE_INDEX;
    public static TokenNodeType LBRACE;
    public static int RBRACE_NODE_TYPE_INDEX;
    public static TokenNodeType RBRACE;
    public static int COMMA_NODE_TYPE_INDEX;
    public static TokenNodeType COMMA;
    public static int DOT_NODE_TYPE_INDEX;
    public static TokenNodeType DOT;
    public static int EQ_NODE_TYPE_INDEX;
    public static TokenNodeType EQ;
    public static int GT_NODE_TYPE_INDEX;
    public static TokenNodeType GT;
    public static int GE_NODE_TYPE_INDEX;
    public static TokenNodeType GE;
    public static int LT_NODE_TYPE_INDEX;
    public static TokenNodeType LT;
    public static int LE_NODE_TYPE_INDEX;
    public static TokenNodeType LE;
    public static int NE_NODE_TYPE_INDEX;
    public static TokenNodeType NE;
    public static int EXCL_NODE_TYPE_INDEX;
    public static TokenNodeType EXCL;
    public static int AT_NODE_TYPE_INDEX;
    public static TokenNodeType AT;
    public static int COLON_NODE_TYPE_INDEX;
    public static TokenNodeType COLON;
    public static int PLUS_NODE_TYPE_INDEX;
    public static TokenNodeType PLUS;
    public static int PLUSEQ_NODE_TYPE_INDEX;
    public static TokenNodeType PLUSEQ;
    public static int MINUS_NODE_TYPE_INDEX;
    public static TokenNodeType MINUS;
    public static int MINUSEQ_NODE_TYPE_INDEX;
    public static TokenNodeType MINUSEQ;
    public static int ASTERISK_NODE_TYPE_INDEX;
    public static TokenNodeType ASTERISK;
    public static int ASTERISKEQ_NODE_TYPE_INDEX;
    public static TokenNodeType ASTERISKEQ;
    public static int DIV_NODE_TYPE_INDEX;
    public static TokenNodeType DIV;
    public static int DIVEQ_NODE_TYPE_INDEX;
    public static TokenNodeType DIVEQ;
    public static int AND_NODE_TYPE_INDEX;
    public static TokenNodeType AND;
    public static int ANDEQ_NODE_TYPE_INDEX;
    public static TokenNodeType ANDEQ;
    public static int XOR_NODE_TYPE_INDEX;
    public static TokenNodeType XOR;
    public static int XOREQ_NODE_TYPE_INDEX;
    public static TokenNodeType XOREQ;
    public static int SHARP_NODE_TYPE_INDEX;
    public static TokenNodeType SHARP;
    public static int BACKSLASH_NODE_TYPE_INDEX;
    public static TokenNodeType BACKSLASH;
    public static int BACKSLASHEQ_NODE_TYPE_INDEX;
    public static TokenNodeType BACKSLASHEQ;
    public static int LTLT_NODE_TYPE_INDEX;
    public static TokenNodeType LTLT;
    public static int GTGT_NODE_TYPE_INDEX;
    public static TokenNodeType GTGT;
    public static int LTLTEQ_NODE_TYPE_INDEX;
    public static TokenNodeType LTLTEQ;
    public static int GTGTEQ_NODE_TYPE_INDEX;
    public static TokenNodeType GTGTEQ;
    public static int QUESTION_NODE_TYPE_INDEX;
    public static TokenNodeType QUESTION;
    public static int TYPECHAR_PERC_NODE_TYPE_INDEX;
    public static TokenNodeType TYPECHAR_PERC;
    public static int TYPECHAR_AND_NODE_TYPE_INDEX;
    public static TokenNodeType TYPECHAR_AND;
    public static int TYPECHAR_AT_NODE_TYPE_INDEX;
    public static TokenNodeType TYPECHAR_AT;
    public static int TYPECHAR_EXCL_NODE_TYPE_INDEX;
    public static TokenNodeType TYPECHAR_EXCL;
    public static int TYPECHAR_SHARP_NODE_TYPE_INDEX;
    public static TokenNodeType TYPECHAR_SHARP;
    public static int TYPECHAR_DOLLAR_NODE_TYPE_INDEX;
    public static TokenNodeType TYPECHAR_DOLLAR;
    public static int INTERPOLATED_STRING_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING;
    public static int INTERPOLATED_STRING_START_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_START;
    public static int INTERPOLATED_STRING_MIDDLE_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_MIDDLE;
    public static int INTERPOLATED_STRING_END_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_STRING_END;
    public static int INTERPOLATED_FORMAT_SPECIFIER_NODE_TYPE_INDEX;
    public static TokenNodeType INTERPOLATED_FORMAT_SPECIFIER;
    private static int LAST_GENERATED_TOKEN_TYPE_INDEX;
    public static int LINE_TERMINATOR_NODE_TYPE_INDEX;
    public static TokenNodeType LINE_TERMINATOR;
    public static int COMMENT_NODE_TYPE_INDEX;
    public static TokenNodeType COMMENT;
    public static int LINE_CONTINUATION_NODE_TYPE_INDEX;
    public static TokenNodeType LINE_CONTINUATION;
    public static int IMPLICIT_LINE_CONTINUATION_NODE_TYPE_INDEX;
    public static TokenNodeType IMPLICIT_LINE_CONTINUATION;
    public static int WHITE_SPACE_NODE_TYPE_INDEX;
    public static TokenNodeType WHITE_SPACE;
    public static int IDENTIFIER_NODE_TYPE_INDEX;
    public static TokenNodeType IDENTIFIER;
    public static XmlTokenTypes XmlTokens;
    public static int XML_COMMENT_START_NODE_TYPE_INDEX;
    public static TokenNodeType XML_COMMENT_START;
    public static int XML_COMMENT_BODY_NODE_TYPE_INDEX;
    public static TokenNodeType XML_COMMENT_BODY;
    public static int XML_COMMENT_END_NODE_TYPE_INDEX;
    public static TokenNodeType XML_COMMENT_END;
    public static int XML_SPACE_NODE_TYPE_INDEX;
    public static TokenNodeType XML_SPACE;
    public static int XML_NEW_LINE_NODE_TYPE_INDEX;
    public static TokenNodeType XML_NEW_LINE;
    public static int XML_TAG_START_NODE_TYPE_INDEX;
    public static TokenNodeType XML_TAG_START;
    public static int XML_TAG_START1_NODE_TYPE_INDEX;
    public static TokenNodeType XML_TAG_START1;
    public static int XML_TEXT_NODE_TYPE_INDEX;
    public static TokenNodeType XML_TEXT;
    public static int XML_ENTITY_REF_NODE_TYPE_INDEX;
    public static TokenNodeType XML_ENTITY_REF;
    public static int XML_CHAR_REF_NODE_TYPE_INDEX;
    public static TokenNodeType XML_CHAR_REF;
    public static int XML_TAG_END_NODE_TYPE_INDEX;
    public static TokenNodeType XML_TAG_END;
    public static int XML_TAG_END1_NODE_TYPE_INDEX;
    public static TokenNodeType XML_TAG_END1;
    public static int XML_PI_START_NODE_TYPE_INDEX;
    public static TokenNodeType XML_PI_START;
    public static int XML_PI_BODY_NODE_TYPE_INDEX;
    public static TokenNodeType XML_PI_BODY;
    public static int XML_PI_END_NODE_TYPE_INDEX;
    public static TokenNodeType XML_PI_END;
    public static int XML_STRING_NODE_TYPE_INDEX;
    public static TokenNodeType XML_STRING;
    public static int XML_UNFINISHED_STRING_NODE_TYPE_INDEX;
    public static TokenNodeType XML_UNFINISHED_STRING;
    public static int XML_EQ_NODE_TYPE_INDEX;
    public static TokenNodeType XML_EQ;
    public static int XML_IDENTIFIER_NODE_TYPE_INDEX;
    public static TokenNodeType XML_IDENTIFIER;
    public static int XML_CDATA_START_NODE_TYPE_INDEX;
    public static TokenNodeType XML_CDATA_START;
    public static int XML_CDATA_BODY_NODE_TYPE_INDEX;
    public static TokenNodeType XML_CDATA_BODY;
    public static int XML_CDATA_END_NODE_TYPE_INDEX;
    public static TokenNodeType XML_CDATA_END;
    public static int XML_ERROR_NODE_TYPE_INDEX;
    public static TokenNodeType XML_ERROR;
    public static NodeTypeSet LITERALS;
    public static NodeTypeSet TYPE_NAME;
    public static NodeTypeSet END_DECLARATION;
    public static NodeTypeSet END_TOPLEVEL_DECLARATION;
    public static NodeTypeSet COMPOUND_END_TOKEN;
    public static NodeTypeSet STOP_WORDS_FOR_BLOCK;
    public static NodeTypeSet TYPECHARS;
    public static NodeTypeSet KEYWORDS;
    public static NodeTypeSet IDENTIFIER_KEYWORDS;
    public static NodeTypeSet ACCESS_MODIFIERS;
    public static NodeTypeSet WHITESPACE_OR_COMMENT;
    public static Dictionary`2<string, TokenNodeType> ReferenceNameSpecialTokens;
    private static VBTokenType();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Parsing.VBXmlTokenBuilder : object {
    public sealed virtual LeafElementBase CreateToken(XmlTokenNodeType tokenType, IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
internal class JetBrains.ReSharper.Psi.VB.Parsing.VBXmlTokenNodeType : XmlTokenNodeType {
    public VBXmlTokenNodeType(string s, XmlTokenTypes types, int index, bool isFilteredNode);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
internal class JetBrains.ReSharper.Psi.VB.Parsing.VBXmlTokenTypes : XmlTokenTypes {
    internal void Init();
}
public class JetBrains.ReSharper.Psi.VB.Parsing.XmlPartLexer : XmlLexerGenerated {
    public XmlPartLexer(IBuffer buffer);
    protected virtual void locateToken();
}
public class JetBrains.ReSharper.Psi.VB.Properties.AssemblyReferenceClass_PsiFeaturesPsiVb : AssemblyReferenceClass_ComponentModel {
}
public static class JetBrains.ReSharper.Psi.VB.ReSharperControlConstructIDs : object {
    public static string UnusedImportClause;
    public static string RedundantQualifier;
}
public interface JetBrains.ReSharper.Psi.VB.Resolve.IOverloadResolutionData {
    public IResolveContext ResolveContext { get; }
    public IArgumentsMatcher ArgumentsMatcher { get; }
    public IList`1<IType> TypeArguments { get; }
    public bool TypesAreAlreadyInfered { get; }
    public IVBTypeConversionRule TypeConversionRule { get; }
    public VBLanguageLevel LanguageLevel { get; }
    public IPsiModule Module { get; }
    public ILateBoundSelector LateBoundSelector { get; }
    public IMoreSpecificSelector MoreSpecificSelector { get; }
    public IPreFilterNarrowingCandidates PreFilterNarrowingCandidates { get; }
    public ITypeInferenceRule TypeInferenceRule { get; }
    public abstract virtual IResolveContext get_ResolveContext();
    public abstract virtual IArgumentsMatcher get_ArgumentsMatcher();
    public abstract virtual IList`1<IType> get_TypeArguments();
    public abstract virtual bool get_TypesAreAlreadyInfered();
    public abstract virtual IVBTypeConversionRule get_TypeConversionRule();
    public abstract virtual VBLanguageLevel get_LanguageLevel();
    public abstract virtual IPsiModule get_Module();
    public abstract virtual ILateBoundSelector get_LateBoundSelector();
    public abstract virtual IMoreSpecificSelector get_MoreSpecificSelector();
    public abstract virtual IPreFilterNarrowingCandidates get_PreFilterNarrowingCandidates();
    public abstract virtual ITypeInferenceRule get_TypeInferenceRule();
}
public interface JetBrains.ReSharper.Psi.VB.Resolve.IOverloadResolutionResult {
    public bool IsApplicableResolveResult { get; }
    public bool HasModuleMethod { get; }
    public ResolveErrorType ErrorType { get; }
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo CommitResolveResult();
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo GetResolveResult();
    public abstract virtual bool get_IsApplicableResolveResult();
    public abstract virtual bool get_HasModuleMethod();
    public abstract virtual ResolveErrorType get_ErrorType();
}
public interface JetBrains.ReSharper.Psi.VB.Resolve.IResolveInfoWithImports {
    public ICollection`1<IImportClause> ImportClauses { get; }
    public abstract virtual ICollection`1<IImportClause> get_ImportClauses();
}
public class JetBrains.ReSharper.Psi.VB.Resolve.ResolveInfoWithImport : object {
    [NotNullAttribute]
private IImportClause myImportClause;
    [NotNullAttribute]
private IResolveInfo myResolveInfo;
    public ICollection`1<IImportClause> ImportClauses { get; }
    public ResolveErrorType ResolveErrorType { get; }
    public ResolveInfoWithImport(IImportClause importClause, IResolveInfo resolveInfo);
    public sealed virtual ICollection`1<IImportClause> get_ImportClauses();
    public sealed virtual ResolveErrorType get_ResolveErrorType();
}
public class JetBrains.ReSharper.Psi.VB.Resolve.ResolveInfoWithImports : object {
    [NotNullAttribute]
private IResolveInfo myResolveInfo;
    [CompilerGeneratedAttribute]
private ICollection`1<IImportClause> <ImportClauses>k__BackingField;
    public ICollection`1<IImportClause> ImportClauses { get; }
    public ResolveErrorType ResolveErrorType { get; }
    public ResolveInfoWithImports(ICollection`1<IImportClause> importClauses, IResolveInfo resolveInfo);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IImportClause> get_ImportClauses();
    public sealed virtual ResolveErrorType get_ResolveErrorType();
}
internal interface JetBrains.ReSharper.Psi.VB.Resolve.TypeInference.ITypeInferenceArgument {
    public IPsiModule PsiModule { get; }
    public abstract virtual IExpressionType CalculateArgumentType(IResolveContext resolveContext);
    public abstract virtual IList`1<IType> ParameterTypes();
    public abstract virtual IPsiModule get_PsiModule();
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.VB.Resolve.TypeInference.TypeInferenceMatch : ValueType {
    [CompilerGeneratedAttribute]
private ITypeInferenceArgument <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionType <ArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckParamArray>k__BackingField;
    public ITypeInferenceArgument Argument { get; }
    public IExpressionType ArgumentType { get; }
    public IType ParameterType { get; }
    public bool CheckParamArray { get; }
    public TypeInferenceMatch(ITypeInferenceArgument argument, IExpressionType argumentType, IType parameterType, bool checkParamArray);
    [CompilerGeneratedAttribute]
public ITypeInferenceArgument get_Argument();
    [CompilerGeneratedAttribute]
public IExpressionType get_ArgumentType();
    [CompilerGeneratedAttribute]
public IType get_ParameterType();
    [CompilerGeneratedAttribute]
public bool get_CheckParamArray();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Resolve.TypeInference.VBTypeInferenceBoundsSolver : object {
    public sealed virtual ISubstitution SolveLikeResolve(IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> typeBounds, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ITypeConversionRule conversionRule);
    public sealed virtual IReadOnlyList`1<ISubstitution> Solve(IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> typeBounds, ITypeConversionRule conversionRule);
    [CanBeNullAttribute]
private IDictionary`2<ITypeParameter, IType> SolveSingleSolution(Dictionary`2<ITypeParameter, TypeInferenceBoundsSet> solution, ITypeConversionRule typeConversionRule);
    [CanBeNullAttribute]
private IDictionary`2<ITypeParameter, IType> SolveSingleSolution(OneToSetMap`2<ITypeParameter, TypeInferenceBound> solution, ITypeConversionRule typeConversionRule);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Resolve.TypeInference.VBTypeInferenceEngine : object {
    [CanBeNullAttribute]
public static ISubstitution ExplicitInference(ITypeParametersOwner element, ISubstitution substitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, IList`1<IType> typeArguments);
    [CanBeNullAttribute]
public static ISubstitution ImplicitInference(IResolveContext& resolveContext, IMethod method, ISubstitution qualifierSubstitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, IList`1<IVBArgumentInfo> arguments, IVBTreeNode context);
    [CanBeNullAttribute]
public static ISubstitution ImplicitInference(IResolveContext& resolveContext, IMethod method, ISubstitution qualifierSubstitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, ArgumentsMatchResult matchResult, IVBTypeConversionRule rule, VBLanguageLevel languageLevel);
    [CanBeNullAttribute]
public static Pair`2<ISubstitution, TypeInferenceInfo> ImplicitInferenceWithInfo(IResolveContext& resolveContext, IMethod method, ISubstitution qualifierSubstitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, ArgumentsMatchResult matchResult, IVBTypeConversionRule rule, VBLanguageLevel languageLevel);
    [CanBeNullAttribute]
private static ISubstitution ImplicitInferenceVB8(IResolveContext resolveContext, IMethod method, ISubstitution qualifierSubstitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, ArgumentsMatchResult matchResult);
    private static Pair`2<ISubstitution, TypeInferenceInfo> ImplicitInferenceVB9(IResolveContext& resolveContext, IMethod method, ISubstitution qualifierSubstitution, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters, ArgumentsMatchResult matchResult, IVBTypeConversionRule rule);
    [NotNullAttribute]
private static DirectedGraph`1<object> BuildDependencies(ISubstitution substitution, JetHashSet`1<ITypeParameter> inferrableTypeParameters, IEnumerable`1<TypeInferenceMatch> matchResult);
    private static void DependenciesForFunction(DirectedGraph`1<object> graph, ITypeInferenceArgument argument, IDelegate delegate, ISubstitution delegateSubstitution, JetHashSet`1<ITypeParameter> methodTypeParameters, bool inferFunctionParameters);
    [NotNullAttribute]
private static ICollection`1<ITypeParameter> TypeParametersUsedInType(IType type, JetHashSet`1<ITypeParameter> typeParameters);
    [ExtensionAttribute]
public static IType SolveTypeInferenceBounds(ICollection`1<TypeInferenceBound> bounds, IVBTypeConversionRule typeConversionRule);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Resolve.TypeInference.VBTypeInferenceEngine/<MatchForTypeInference>d__10")]
internal static IEnumerable`1<TypeInferenceMatch> MatchForTypeInference(ArgumentsMatchResult matchResult, IResolveContext resolveContext);
}
internal class JetBrains.ReSharper.Psi.VB.Resolve.TypeInference.VBTypeInferenceGenie : object {
    private DirectedGraph`1<object> myGraph;
    private ISubstitution myMethodSubstitution;
    private IList`1<TypeInferenceMatch> myMatchResult;
    private IPsiModule myModule;
    private JetHashSet`1<object> myCompleted;
    private TypeInferenceState myState;
    public bool CurrentInferenceLowPriority { get; }
    public VBTypeInferenceGenie(IPsiModule module, DirectedGraph`1<object> graph, ISubstitution methodSubstitution, IEnumerable`1<ITypeParameter> inferrableTypeParameters, IList`1<TypeInferenceMatch> matchResult, IVBTypeConversionRule rule);
    public ISubstitution Inference(IResolveContext& resolveContext);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Resolve.TypeInference.VBTypeInferenceGenie/<UncompletedIncomingNodes>d__8")]
private IEnumerable`1<object> UncompletedIncomingNodes(object node);
    public bool get_CurrentInferenceLowPriority();
    [CompilerGeneratedAttribute]
private bool <Inference>b__7_0(object argument);
    [CompilerGeneratedAttribute]
private bool <Inference>b__7_1(object argument1);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Resolve.TypeInference.VBTypeInferenceMatcher : CLRTypeInferenceMatcher {
    public static VBTypeInferenceMatcher Instance;
    private static VBTypeInferenceMatcher();
    public virtual bool Match(TypeInferenceKind inferenceKind, IType actualType, IType formalTypeWithVariables, ITypeInferenceConsumer consumer);
    protected virtual TypeInferenceKind NextKind(TypeInferenceKind inferenceKind, ITypeParameter typeParameter, IType typeArgument, bool isArray);
}
public class JetBrains.ReSharper.Psi.VB.Resolve.VBImplicitBaseConstructorInvocationReference : ImplicitBaseConstructorInvocationReference {
    public VBImplicitBaseConstructorInvocationReference(IDeclaration ownerElement, IClass baseClass);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.VB.Resolve.VBResolveErrorType : ResolveErrorType {
    [NotNullAttribute]
public static VBResolveErrorType NOT_RESOLVED_TEXT_REFERENCE;
    [NotNullAttribute]
public static VBResolveErrorType STRICTNESS_FAILED;
    [NotNullAttribute]
public static VBResolveErrorType MORE_APPLICABLE_NOT_FOUND;
    [NotNullAttribute]
public static VBResolveErrorType MORE_SPECIFIC_NOT_FOUND;
    [NotNullAttribute]
public static VBResolveErrorType NOT_EVENT;
    [NotNullAttribute]
public static VBResolveErrorType NOT_METHOD;
    [NotNullAttribute]
public static VBResolveErrorType INCORRECT_QUALIFIER_USAGE;
    [NotNullAttribute]
public static VBResolveErrorType DEFAULT_PROPERTY_NOT_RESOLVED;
    [NotNullAttribute]
public static VBResolveErrorType NOT_RESOLVED_INTERFACE_SPECIFIER;
    [NotNullAttribute]
public static VBResolveErrorType NOT_VALID_HERE;
    [NotNullAttribute]
public static VBResolveErrorType NOT_VARIABLE_IN_INITIALIZER;
    [NotNullAttribute]
public static VBResolveErrorType NOT_PROPERTY_IN_DICTIONARY_ACCESS;
    [NotNullAttribute]
public static VBResolveErrorType CANT_USE_ACCESSOR_DIRECTLY;
    [NotNullAttribute]
public static VBResolveErrorType USE_LOCAL_BEFORE_DECLARATION;
    [NotNullAttribute]
public static VBResolveErrorType INCORRECT_PARAMETER_NUMBER_IN_MID;
    [NotNullAttribute]
public static VBResolveErrorType INCORRECT_AWAITABLE_PATTERN;
    [NotNullAttribute]
public static VBResolveErrorType INCORRECT_FOREACH_PATTERN;
    [NotNullAttribute]
public static VBResolveErrorType CANT_USE_TYPE_ARGUMENTS;
    private VBResolveErrorType(string name);
    private static VBResolveErrorType();
}
public static class JetBrains.ReSharper.Psi.VB.Resolve.VBResolveInfoFactory : object {
    public static IResolveInfo Create(ICollection`1<IImportClause> importClauses, IResolveInfo resolveInfo);
    public static IResolveInfo Create(IImportClause importClause, IResolveInfo resolveInfo);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Resolve.VBResolveResultExtensions : object {
    [ExtensionAttribute]
public static bool IsLateBound(ResolveResultWithInfo resultWithInfo);
    [ExtensionAttribute]
public static bool IsReturnValue(IResolveResult resolveResult);
    [ExtensionAttribute]
public static IList`1<IDeclaredElement> LiftedOrSimpleCandidates(IResolveResult resolveResult);
    [ExtensionAttribute]
public static IDeclaredElement LiftedOrSimpleDeclaredElement(IResolveResult resolveResult);
}
public class JetBrains.ReSharper.Psi.VB.Resources.PsiVBThemedIcons : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Psi.VB.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string AddImportsDirectivesOnOptimizationSettingDescription { get; }
    public static string AdditiveOperatorsSettingDescription { get; }
    public static string AfterAttributeTargetColonSettingDescription { get; }
    public static string AfterFileOptionsSectionSettingDescription { get; }
    public static string AfterGlobalAttributeSettingDescription { get; }
    public static string AfterImportsSectionSettingDescription { get; }
    public static string AfterSettingDescription { get; }
    public static string AfterUnaryOperatorsSettingDescription { get; }
    public static string AllowImportsAliasDirectiveSettingDescription { get; }
    public static string AroundMultilineFieldSettingDescription { get; }
    public static string AroundMultilineMethodSettingDescription { get; }
    public static string AroundNamespaceSettingDescription { get; }
    public static string AroundRegionSettingDescription { get; }
    public static string AroundSettingDescription { get; }
    public static string AroundSingleLineFieldSettingDescription { get; }
    public static string AroundSingleLineMethodSettingDescription { get; }
    public static string AroundStatementSettingDescription { get; }
    public static string AroundTypeSettingDescription { get; }
    public static string ArrayInitializerSettingDescription { get; }
    public static string AssignmentOperatorsSettingDescription { get; }
    public static string AsyncMethod_PresentableName_Text { get; }
    public static string BeforeArrayRankParenthesesSettingDescription { get; }
    public static string BeforeAttributeTargetColonSettingDescription { get; }
    public static string BeforeEmptyInvocationParenthesesSettingDescription { get; }
    public static string BeforeEmptyMethodDeclarationParenthesesSettingDescription { get; }
    public static string BeforeInLabelSettingDescription { get; }
    public static string BeforeInvocationParenthesesSettingDescription { get; }
    public static string BeforeMethodDeclarationParenthesesSettingDescription { get; }
    public static string BeforeSettingDescription { get; }
    public static string BeforeTypeParameterParenthesesSettingDescription { get; }
    public static string CodeFormattingInVBNETSettingDescription { get; }
    public static string KeepNonTrivialImportAliasesSettingDescription { get; }
    public static string NoParameters_Text { get; }
    public static string RemoveUnusedOnlyImportAliasesSettingDescription { get; }
    public static string DontIndentCommentsStartedAtFirstColumnSettingDescription { get; }
    public static string ExpressionSettingDescription { get; }
    public static string ImplementsHandlesListSettingDescription { get; }
    public static string InsideRegionSettingDescription { get; }
    public static string InvocationArgumentsSettingDescription { get; }
    public static string KeepExistingLineBreaksSettingDescription { get; }
    public static string KeepImportsDirectivesOnOptimizationSettingDescription { get; }
    public static string KeepMaxBlankLinesInCodeSettingDescription { get; }
    public static string KeepMaxBlankLinesInDeclarationsSettingDescription { get; }
    public static string MethodParametersSettingDescription { get; }
    public static string MultipleDeclarationListSettingDescription { get; }
    public static string MultiplicativeOperatorsSettingDescription { get; }
    public static string NamespacesThatShouldNotBeRemovedFromFullyQualifiedTypeNamesSettingDescription { get; }
    public static string PlaceEventAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceFieldAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceMethodAttributeOnTheSameLineSettingDescription { get; }
    public static string PlacePropertyAttributeOnTheSameLineSettingDescription { get; }
    public static string PlaceTypeAttributeOnTheSameLineSettingDescription { get; }
    public static string PreferFullyQualifiedReferencesSettingDescription { get; }
    public static string PreferWrapBeforeOperatorInBinaryExpressionSettingDescription { get; }
    public static string RelationalOperatorsSettingDescription { get; }
    public static string ShiftOperatorsSettingDescription { get; }
    public static string Unknown_Text { get; }
    public static string VBNETLanguageLevelSettingDescription { get; }
    public static string VBNETLanguageSettingsSettingDescription { get; }
    public static string VBNETNamespaceImportSettingDescription { get; }
    public static string VBNETNamingSettingsSettingDescription { get; }
    public static string WithinArrayInitializationBracesSettingDescription { get; }
    public static string WithinArrayRankParenthesesSettingDescription { get; }
    public static string WithinAttributeAnglesSettingDescription { get; }
    public static string WithinEmptyArrayRankParenthesesSettingDescription { get; }
    public static string WithinEmptyInvocationParenthesesSettingDescription { get; }
    public static string WithinEmptyMethodDeclarationParenthesesSettingDescription { get; }
    public static string WithinExpressionParenthesesSettingDescription { get; }
    public static string WithinInvocationParenthesesSettingDescription { get; }
    public static string WithinMethodDeclarationParenthesesSettingDescription { get; }
    public static string WithinTupleParenthesesSettingDescription { get; }
    public static string WithinTypeParameterParenthesesSettingDescription { get; }
    public static string WrapExtendsImplementsHandlesListSettingDescription { get; }
    public static string WrapFormalParametersSettingDescription { get; }
    public static string WrapInvocationArgumentsSettingDescription { get; }
    public static string WrapMultipleDeclarationsListSettingDescription { get; }
    public static string VBFormatSettingsKey_WrapBeforeInvocationLpar_SettingsDescription { get; }
    public static string VBFormatSettingsKey_WrapBeforeDeclarationLpar_SettingsDescription { get; }
    public static string VBFormatSettingsKey_IndentCaseFromSelect { get; }
    public static string VBFormatting_Text { get; }
    public static string VBIndenting_Text { get; }
    public static string FileIsNotIncludedIntoCompilation_Text { get; }
    public static string UnknownPreprocessorDirective_Text { get; }
    public static string Module_Text { get; }
    public static string Namespace_Text { get; }
    public static string Class_Text { get; }
    public static string Interface_Text { get; }
    public static string Structure_Text { get; }
    public static string DelegateSub_Text { get; }
    public static string DelegateFunction_Text { get; }
    public static string Enum_Text { get; }
    public static string Accessor_Text { get; }
    public static string Sub_Text { get; }
    public static string Function_Text { get; }
    public static string Constructor_Text { get; }
    public static string Operator_Text { get; }
    public static string Field_Text { get; }
    public static string Const_Text { get; }
    public static string EnumMember_Text { get; }
    public static string RangeVariable_Text { get; }
    public static string Property_Text { get; }
    public static string LambdaSub_Text { get; }
    public static string LambdaFunction_Text { get; }
    public static string Event_Text { get; }
    public static string Parameter_Text { get; }
    public static string LocalConstant_Text { get; }
    public static string LocalVariable_Text { get; }
    public static string TypeParameter_Text { get; }
    public static string Label_Text { get; }
    public static string Expected_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_AddImportsDirectivesOnOptimizationSettingDescription();
    public static string get_AdditiveOperatorsSettingDescription();
    public static string get_AfterAttributeTargetColonSettingDescription();
    public static string get_AfterFileOptionsSectionSettingDescription();
    public static string get_AfterGlobalAttributeSettingDescription();
    public static string get_AfterImportsSectionSettingDescription();
    public static string get_AfterSettingDescription();
    public static string get_AfterUnaryOperatorsSettingDescription();
    public static string get_AllowImportsAliasDirectiveSettingDescription();
    public static string get_AroundMultilineFieldSettingDescription();
    public static string get_AroundMultilineMethodSettingDescription();
    public static string get_AroundNamespaceSettingDescription();
    public static string get_AroundRegionSettingDescription();
    public static string get_AroundSettingDescription();
    public static string get_AroundSingleLineFieldSettingDescription();
    public static string get_AroundSingleLineMethodSettingDescription();
    public static string get_AroundStatementSettingDescription();
    public static string get_AroundTypeSettingDescription();
    public static string get_ArrayInitializerSettingDescription();
    public static string get_AssignmentOperatorsSettingDescription();
    public static string get_AsyncMethod_PresentableName_Text();
    public static string get_BeforeArrayRankParenthesesSettingDescription();
    public static string get_BeforeAttributeTargetColonSettingDescription();
    public static string get_BeforeEmptyInvocationParenthesesSettingDescription();
    public static string get_BeforeEmptyMethodDeclarationParenthesesSettingDescription();
    public static string get_BeforeInLabelSettingDescription();
    public static string get_BeforeInvocationParenthesesSettingDescription();
    public static string get_BeforeMethodDeclarationParenthesesSettingDescription();
    public static string get_BeforeSettingDescription();
    public static string get_BeforeTypeParameterParenthesesSettingDescription();
    public static string get_CodeFormattingInVBNETSettingDescription();
    public static string get_KeepNonTrivialImportAliasesSettingDescription();
    public static string get_NoParameters_Text();
    public static string get_RemoveUnusedOnlyImportAliasesSettingDescription();
    public static string get_DontIndentCommentsStartedAtFirstColumnSettingDescription();
    public static string get_ExpressionSettingDescription();
    public static string get_ImplementsHandlesListSettingDescription();
    public static string get_InsideRegionSettingDescription();
    public static string get_InvocationArgumentsSettingDescription();
    public static string get_KeepExistingLineBreaksSettingDescription();
    public static string get_KeepImportsDirectivesOnOptimizationSettingDescription();
    public static string get_KeepMaxBlankLinesInCodeSettingDescription();
    public static string get_KeepMaxBlankLinesInDeclarationsSettingDescription();
    public static string get_MethodParametersSettingDescription();
    public static string get_MultipleDeclarationListSettingDescription();
    public static string get_MultiplicativeOperatorsSettingDescription();
    public static string get_NamespacesThatShouldNotBeRemovedFromFullyQualifiedTypeNamesSettingDescription();
    public static string get_PlaceEventAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceFieldAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceMethodAttributeOnTheSameLineSettingDescription();
    public static string get_PlacePropertyAttributeOnTheSameLineSettingDescription();
    public static string get_PlaceTypeAttributeOnTheSameLineSettingDescription();
    public static string get_PreferFullyQualifiedReferencesSettingDescription();
    public static string get_PreferWrapBeforeOperatorInBinaryExpressionSettingDescription();
    public static string get_RelationalOperatorsSettingDescription();
    public static string get_ShiftOperatorsSettingDescription();
    public static string get_Unknown_Text();
    public static string get_VBNETLanguageLevelSettingDescription();
    public static string get_VBNETLanguageSettingsSettingDescription();
    public static string get_VBNETNamespaceImportSettingDescription();
    public static string get_VBNETNamingSettingsSettingDescription();
    public static string get_WithinArrayInitializationBracesSettingDescription();
    public static string get_WithinArrayRankParenthesesSettingDescription();
    public static string get_WithinAttributeAnglesSettingDescription();
    public static string get_WithinEmptyArrayRankParenthesesSettingDescription();
    public static string get_WithinEmptyInvocationParenthesesSettingDescription();
    public static string get_WithinEmptyMethodDeclarationParenthesesSettingDescription();
    public static string get_WithinExpressionParenthesesSettingDescription();
    public static string get_WithinInvocationParenthesesSettingDescription();
    public static string get_WithinMethodDeclarationParenthesesSettingDescription();
    public static string get_WithinTupleParenthesesSettingDescription();
    public static string get_WithinTypeParameterParenthesesSettingDescription();
    public static string get_WrapExtendsImplementsHandlesListSettingDescription();
    public static string get_WrapFormalParametersSettingDescription();
    public static string get_WrapInvocationArgumentsSettingDescription();
    public static string get_WrapMultipleDeclarationsListSettingDescription();
    public static string get_VBFormatSettingsKey_WrapBeforeInvocationLpar_SettingsDescription();
    public static string get_VBFormatSettingsKey_WrapBeforeDeclarationLpar_SettingsDescription();
    public static string get_VBFormatSettingsKey_IndentCaseFromSelect();
    public static string get_VBFormatting_Text();
    public static string get_VBIndenting_Text();
    public static string get_FileIsNotIncludedIntoCompilation_Text();
    public static string get_UnknownPreprocessorDirective_Text();
    public static string get_Module_Text();
    public static string get_Namespace_Text();
    public static string get_Class_Text();
    public static string get_Interface_Text();
    public static string get_Structure_Text();
    public static string get_DelegateSub_Text();
    public static string get_DelegateFunction_Text();
    public static string get_Enum_Text();
    public static string get_Accessor_Text();
    public static string get_Sub_Text();
    public static string get_Function_Text();
    public static string get_Constructor_Text();
    public static string get_Operator_Text();
    public static string get_Field_Text();
    public static string get_Const_Text();
    public static string get_EnumMember_Text();
    public static string get_RangeVariable_Text();
    public static string get_Property_Text();
    public static string get_LambdaSub_Text();
    public static string get_LambdaFunction_Text();
    public static string get_Event_Text();
    public static string get_Parameter_Text();
    public static string get_LocalConstant_Text();
    public static string get_LocalVariable_Text();
    public static string get_TypeParameter_Text();
    public static string get_Label_Text();
    public static string get_Expected_Text();
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.VB.SourceGenerators.VBSourceGeneratedFilesLanguageProvider : object {
    public ProjectLanguage SupportedProjectLanguage { get; }
    public PsiLanguageType PsiLanguageType { get; }
    public ProjectFileType ProjectFileType { get; }
    public sealed virtual ProjectLanguage get_SupportedProjectLanguage();
    public sealed virtual PsiLanguageType get_PsiLanguageType();
    public sealed virtual ProjectFileType get_ProjectFileType();
}
public class JetBrains.ReSharper.Psi.VB.StatementsRange : object {
    private ITreeRange myTreeRange;
    public ITreeRange TreeRange { get; }
    public IList`1<IStatement> Statements { get; }
    public StatementsRange(ITreeRange treeRange);
    public sealed virtual ITreeRange get_TreeRange();
    public sealed virtual IList`1<IStatement> get_Statements();
    public static IVBStatementsRange FromSingleStatement(IVBStatement statement);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AccessorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorDeclaration GetByParameterList(IRegularParameterList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AccessorOwnerDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByAccessorDeclaration(IAccessorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByImplementsClause(IImplementsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAccessorOwnerDeclaration GetByName(IVBIdentifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AddHandlerStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAddHandlerStatement GetByEventExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAddHandlerStatement GetByHandlerExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AdditiveExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAdditiveExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAdditiveExpression GetByRightExpr(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AddressOfExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAddressOfExpression GetByExpression(IPrimaryExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AggregatedRangeVariableDeclarationListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAggregatedRangeVariableDeclarationList GetByDeclaration(IAggregatedRangeVariableDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AggregatedRangeVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAggregatedRangeVariableDeclaration GetByExpression(IQueryAggregatedParameterPlatform param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAggregatedRangeVariableDeclaration GetByName(IVBIdentifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AggregateQueryOperatorNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAggregateQueryOperator GetByCollectionVariable(IQueryCollectionRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAggregateQueryOperator GetByDeclarationList(IQueryCollectionRangeVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAggregateQueryOperator GetByIntoClause(IIntoOfAggregateQueryOperator param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAggregateQueryOperator GetByQueryOperator(IQueryOperator param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AliasClauseNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AnonymousArrayCreationExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousArrayCreationExpression GetByInitializer(IVBExpression param);
    public static IAnonymousArrayCreationExpression GetTopmostByInitializer(IVBExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.AnonymousArrayCreationExt : object {
    [ExtensionAttribute]
public static IEnumerable`1<IExpressionType> AllElementTypes(IAnonymousArrayCreationExpression arrayCreationExpression);
    [ExtensionAttribute]
public static IEnumerable`1<IExpressionType> AllElementTypes(IAnonymousArrayCreationExpression arrayCreationExpression, IResolveContext resolveContext);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Tree.AnonymousArrayCreationExt/<AllElements>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IVBExpression> AllElements(IAnonymousArrayCreationExpression arrayCreationExpression);
    [ExtensionAttribute]
public static int Rank(IAnonymousArrayCreationExpression creationExpression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AnonymousMemberDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousMemberDeclaration GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousMemberDeclaration GetByName(IVBIdentifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AnonymousObjectCreationExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousObjectCreationExpression GetByInitializer(IAnonymousObjectInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousObjectCreationExpression GetByMemberDeclaration(IAnonymousMemberDeclaration param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AnonymousObjectInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAnonymousObjectInitializer GetByMemberDeclaration(IAnonymousMemberDeclaration param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ArgumentedExpressionNavigator : object {
    public static IVBArgumentsOwner GetByArgument(IVBArgument argument);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ArgumentListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArgumentList GetByArgument(IVBArgument param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ArrayBoundNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayBound GetByBound1(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayBound GetByBound2(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ArrayCreationExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayCreationExpression GetByArrayInitializer(IAnonymousArrayCreationExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayCreationExpression GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayCreationExpression GetByTypeUsage(IDeclaredTypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ArrayModifierNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayModifier GetByArrayBound(IArrayBound param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ArrayModifiersListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IArrayModifiersList GetByArrayModifier(IArrayModifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AssignmentStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAssignmentStatement GetByLValue(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAssignmentStatement GetByRValue(IVBExpression param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.AssignmentType : Enum {
    public int value__;
    public static AssignmentType INVALID;
    public static AssignmentType EQ;
    public static AssignmentType PLUSEQ;
    public static AssignmentType MINUSEQ;
    public static AssignmentType ASTERISKEQ;
    public static AssignmentType DIVEQ;
    public static AssignmentType BACKSLASHEQ;
    public static AssignmentType ANDEQ;
    public static AssignmentType XOREQ;
    public static AssignmentType LTLTEQ;
    public static AssignmentType GTGTEQ;
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AttributeListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttributeList GetByAttribute(IAttribute param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AttributeListOwnerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttributeListOwner GetByAttributeList(IAttributeList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.AttributeNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttribute GetByArgument(IVBArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttribute GetByArgumentList(IArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAttribute GetByAttributeType(IReferenceName param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AttributesOwnerDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static TreeNodeCollection`1<IAttributesOwnerDeclaration> GetByAttribute(IAttribute param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.AwaitExpressionExt : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBDeclaration GetContainingAsyncDeclaration(IAwaitExpression awaitExpression);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IType GetAsyncFunctionReturnType(IAwaitExpression awaitExpression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUnderAsyncDeclaration(IVBTreeNode node);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AwaitExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAwaitExpression GetByExpression(IPrimaryExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.AwaitStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IAwaitStatement GetByExpression(IAwaitExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.BlockIfStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBlockIfStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBlockIfStatement GetByElseIfStatement(IElseIfStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBlockIfStatement GetByElseStatement(IElseStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBlockIfStatement GetByExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.BlockNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IBlock GetByStatement(IVBStatement param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.CaseClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICaseClause GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICaseClause GetByToExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.CaseStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICaseStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICaseStatement GetByCaseClause(ICaseClause param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.CastExpressionKind : Enum {
    public int value__;
    public static CastExpressionKind CType;
    public static CastExpressionKind TryCast;
    public static CastExpressionKind DirectCast;
    public static CastExpressionKind CPredefined;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.CastExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICastExpression GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICastExpression GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.CatchStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchStatement GetByCatchVariableDeclaration(ICatchVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchStatement GetByCatchVariableExpression(IReferenceExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchStatement GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.CatchVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICatchVariableDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.CharsetModifierNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ClassBaseClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBaseClause GetByInheritsType(IDeclaredTypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ClassBodyNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByConversionOperatorDeclaration(IConversionOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByExternalMethodDeclaration(IExternalMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByMultipleConstantDeclaration(IMultipleConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByMultipleVariableDeclaration(IMultipleVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassBody GetBySignOperatorDeclaration(ISignOperatorDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ClassDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByBaseClause(IClassBaseClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByConversionOperatorDeclaration(IConversionOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByImplementsClause(ITypeImplementsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByImplementsType(IDeclaredTypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByInheritsType(IDeclaredTypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetBySignOperatorDeclaration(ISignOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByTypeParameterDeclaration(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassDeclaration GetByVariableDeclaration(IVariableDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ClassLikeDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByConversionOperatorDeclaration(IConversionOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetBySignOperatorDeclaration(ISignOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClassLikeDeclaration GetByVariableDeclaration(IVariableDeclaration param);
    [NullableContextAttribute("0")]
[CanBeNullAttribute]
public static IClassLikeDeclaration GetByBaseTypeSpecification(IReferenceName referenceName);
    [NullableContextAttribute("0")]
public static IClassLikeDeclaration GetByBaseClassSpecification(IReferenceName referenceName);
    [NullableContextAttribute("0")]
public static IClassLikeDeclaration GetByBaseInterfaceSpecification(IReferenceName referenceName);
    [NullableContextAttribute("0")]
public static IClassLikeDeclaration GetByBaseTypeSpecification(IDeclaredTypeUsage declaredTypeUsage);
    [NullableContextAttribute("0")]
public static IClassLikeDeclaration GetByBaseClassSpecification(IDeclaredTypeUsage declaredTypeUsage);
    [NullableContextAttribute("0")]
public static IClassLikeDeclaration GetByBaseInterfaceSpecification(IDeclaredTypeUsage declaredTypeUsage);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.CollectionElementInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICollectionElementInitializer GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICollectionElementInitializer GetByInitializer(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.CollectionRangeVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICollectionRangeVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ICollectionRangeVariableDeclaration GetByTypeUsage(ITypeUsage param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.CommentType : Enum {
    public byte value__;
    public static CommentType END_OF_LINE_COMMENT;
    public static CommentType REM_COMMENT;
    public static CommentType DOC_COMMENT;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ConcatenationExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConcatenationExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConcatenationExpression GetByRightExpr(IVBExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.ConditionalAccessExpressionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPartOfConditionalAccess(IConditionalAccessExpression expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTopPartOfConditionalAccess(IConditionalAccessExpression expression);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ConditionalAccessExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
public static IConditionalAccessExpression GetByQualifier(IVBExpression expression);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ConditionalAccessSignNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.ConditionalExpressionExtensions : object {
    [ExtensionAttribute]
public static Pair`2<IVBExpression, IVBExpression> ConditionedOperands(IConditionalExpression expr);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.ConditionalExpressionKind : Enum {
    public int value__;
    public static ConditionalExpressionKind UNKNOWN;
    public static ConditionalExpressionKind TERNARY;
    public static ConditionalExpressionKind NULL_COALESCING;
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ConditionalExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalExpression GetByArgument(IVBArgument param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConditionalExpression GetByArgumentList(IArgumentList param);
    [CanBeNullAttribute]
public static IConditionalExpression GetByCondition(IVBExpression expression);
    [CanBeNullAttribute]
public static IConditionalExpression GetByThenExpression(IVBExpression expression);
    [CanBeNullAttribute]
public static IConditionalExpression GetByElseExpression(IVBExpression expression);
    [CanBeNullAttribute]
public static IConditionalExpression GetByFirstOperandOfNullCoalescing(IVBExpression expression);
    [CanBeNullAttribute]
public static IConditionalExpression GetBySecondOperandOfNullCoalescing(IVBExpression expression);
    private static IConditionalExpression GetCondition(IVBExpression expression, Func`2<IArgumentList, bool> isTernary, int expectedPosition);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ConstantDeclarationNavigator : object {
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IConstantDeclaration> GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstantDeclaration GetByInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstantDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstantDeclaration GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ConstPreprocessorDirectiveNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstPreprocessorDirective GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstPreprocessorDirective GetByName(IVBIdentifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ConstructorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConstructorDeclaration GetByParameterList(IRegularParameterList param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.ContinueStatementKind : Enum {
    public int value__;
    public static ContinueStatementKind Unknown;
    public static ContinueStatementKind Do;
    public static ContinueStatementKind For;
    public static ContinueStatementKind While;
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ContinueStatementNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ControlReferenceNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IControlReference GetByControlName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IControlReference GetByQualifier(IControlReference param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ConversionOperatorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByReturnAttributeList(IReturnAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IConversionOperatorDeclaration GetByReturnType(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.DeclaredTypeUsageNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.DelegateDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByReturnAttributeList(IReturnAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByReturnTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByTypeParameterDeclaration(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegateDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.DictionaryAccessExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDictionaryAccessExpression GetByArgument(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDictionaryAccessExpression GetByBaseExpression(IPrimaryExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDictionaryAccessExpression GetByConditionalAccessSign(IConditionalAccessSign param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.DisableWarningPreprocessorDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDisableWarningPreprocessorDirective GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.DistinctQueryOperatorNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.DocCommentBlockNodeNavigator : object {
    [CanBeNullAttribute]
public static IVbDocCommentBlock GetByDocCommentNode(IDocComment docCommentNode);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.DoLoopStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDoLoopStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDoLoopStatement GetByPostCondition(IWhileUntilCondition param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDoLoopStatement GetByPreCondition(IWhileUntilCondition param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ElseIfPreprocessorDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElseIfPreprocessorDirective GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ElseIfStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElseIfStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElseIfStatement GetByExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ElsePreprocessorDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ElseStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IElseStatement GetByBlock(IBlock param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.EmptyArgumentNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.EnableWarningPreprocessorDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnableWarningPreprocessorDirective GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.EndExternalSourcePreprocessorDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.EndIfPreprocessorDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.EndRegionPreprocessorDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.EndStatementNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.EnumDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByBaseTypeName(IDeclaredTypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByEnumMemberDeclaration(IEnumMemberDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumDeclaration GetByName(IVBIdentifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.EnumMemberDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumMemberDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumMemberDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumMemberDeclaration GetByInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnumMemberDeclaration GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.EraseStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEraseStatement GetByExpression(IPrimaryExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ErrorStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IErrorStatement GetByNextExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.EventDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByAccessorDeclaration(IAccessorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByDelegateParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByDelegateParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByDelegateTypeUsage(IDeclaredTypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByImplementsClause(IImplementsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventDeclaration GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.EventSpecifierNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEventSpecifier GetByMemberName(IVBIdentifier param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.ExitStatementKind : Enum {
    public int value__;
    public static ExitStatementKind Unknown;
    public static ExitStatementKind For;
    public static ExitStatementKind Do;
    public static ExitStatementKind While;
    public static ExitStatementKind Select;
    public static ExitStatementKind Sub;
    public static ExitStatementKind Function;
    public static ExitStatementKind Property;
    public static ExitStatementKind Try;
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ExitStatementNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ExponentiationExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExponentiationExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExponentiationExpression GetByRightExpr(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ExpressionArgumentNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionArgument GetByExpression(IVBExpression param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.ExpressionClassification : Enum {
    public int value__;
    public static ExpressionClassification Value;
    public static ExpressionClassification Variable;
    public static ExpressionClassification Namespace;
    public static ExpressionClassification Type;
    public static ExpressionClassification Invocation;
    public static ExpressionClassification MethodPointer;
    public static ExpressionClassification LambdaMethod;
    public static ExpressionClassification LateBound;
    public static ExpressionClassification Event;
    public static ExpressionClassification AnonymousArrayCreation;
    public static ExpressionClassification Void;
    public static ExpressionClassification Nothing;
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ExpressionRangeVariableDeclarationListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionRangeVariableDeclarationList GetByDeclaration(IExpressionRangeVariableDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ExpressionRangeVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionRangeVariableDeclaration GetByExpression(IQueryParameterPlatform param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionRangeVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionRangeVariableDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ExpressionStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExpressionStatement GetByExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ExternalChecksumPreprocessorDirectiveNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ExternalMethodDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByAliasClause(IAliasClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByCharsetModifier(ICharsetModifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByLibraryClause(ILibraryClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByReturnAttributeList(IReturnAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByReturnTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByTypeParameterDeclaration(ITypeParameterOfMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IExternalMethodDeclaration GetByTypeParameterList(ITypeParameterOfMethodList param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ExternalSourcePreprocessorDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.FinallyStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFinallyStatement GetByBlock(IBlock param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ForEachStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForEachStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForEachStatement GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForEachStatement GetByLoopVariableDeclaration(ILoopControlVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForEachStatement GetByLoopVariableExpression(IPrimaryExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForEachStatement GetByNextClause(INextClause param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ForStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByEndExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByLoopVariableDeclaration(ILoopControlVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByLoopVariableExpression(IPrimaryExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByNextClause(INextClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByStartExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IForStatement GetByStepExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.FromQueryOperatorNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFromQueryOperator GetByDeclarationList(IQueryCollectionRangeVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IFromQueryOperator GetByVariableDeclaration(IQueryCollectionRangeVariableDeclaration param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.FunctionDeclarationExtensions : object {
    [ExtensionAttribute]
public static bool IsIterator(IVBFunctionDeclaration declaration);
    [ExtensionAttribute]
public static bool IsAsynchronous(IVBFunctionDeclaration declaration);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.GetTypeExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGetTypeExpression GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.GetXmlNamespaceExpressionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.GotoStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGotoStatement GetByLabelName(ILabelName param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.GroupByQueryOperatorNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupByQueryOperator GetByKeyDeclaration(IExpressionRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupByQueryOperator GetByKeyDeclarationsList(IExpressionRangeVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupByQueryOperator GetByResultDeclaration(IAggregatedRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupByQueryOperator GetByResultDeclarationsList(IAggregatedRangeVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupByQueryOperator GetBySelectorDeclaration(IExpressionRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupByQueryOperator GetBySelectorDeclarationsList(IExpressionRangeVariableDeclarationList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.GroupJoinQueryOperatorNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupJoinQueryOperator GetByDeclarationList(IAggregatedRangeVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupJoinQueryOperator GetByJoinOperator(IJoinQueryOperator param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IGroupJoinQueryOperator GetByResultDeclaration(IAggregatedRangeVariableDeclaration param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.HandlesClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IHandlesClause GetByEventSpecifier(IEventSpecifier param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAccessorDeclaration {
    public ITokenNode Keyword { get; }
    public bool IsIterator { get; }
    public AccessorKind Kind { get; }
    public bool IsValueParameterDeclared { get; }
    public IAccessor AccessorElement { get; }
    public IModifiersList ModifiersList { get; }
    public IAttributeList AttributeList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual bool get_IsIterator();
    public abstract virtual AccessorKind get_Kind();
    public abstract virtual bool get_IsValueParameterDeclared();
    public abstract virtual IAccessor get_AccessorElement();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IAttributeList get_AttributeList();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAccessorOwnerDeclaration {
    public TreeNodeCollection`1<IAccessorDeclaration> AccessorDeclarations { get; }
    public TreeNodeEnumerable`1<IAccessorDeclaration> AccessorDeclarationsEnumerable { get; }
    public ITokenNode AsKeyword { get; }
    public IImplementsClause ImplementsClause { get; }
    public IVBIdentifier Name { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITypeMember AccessorOwnerElement { get; }
    public ITokenNode OpenKeyword { get; }
    public ITokenNode EndKeyword { get; }
    public abstract virtual TreeNodeCollection`1<IAccessorDeclaration> get_AccessorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IAccessorDeclaration> get_AccessorDeclarationsEnumerable();
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual IImplementsClause get_ImplementsClause();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual IImplementsClause SetImplementsClause(IImplementsClause param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    [NotNullAttribute]
public abstract virtual IAccessorDeclaration AddAccessorDeclarationBefore(IAccessorDeclaration param, IAccessorDeclaration anchor);
    [NotNullAttribute]
public abstract virtual IAccessorDeclaration AddAccessorDeclarationAfter(IAccessorDeclaration param, IAccessorDeclaration anchor);
    public abstract virtual void RemoveAccessorDeclaration(IAccessorDeclaration param);
    public abstract virtual ITypeMember get_AccessorOwnerElement();
    public abstract virtual ITokenNode get_OpenKeyword();
    public abstract virtual ITokenNode get_EndKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAddHandlerStatement {
    public ITokenNode AddHandlerKeyword { get; }
    public ITokenNode Comma { get; }
    public IVBExpression EventExpression { get; }
    public IVBExpression HandlerExpression { get; }
    public abstract virtual ITokenNode get_AddHandlerKeyword();
    public abstract virtual ITokenNode get_Comma();
    public abstract virtual IVBExpression get_EventExpression();
    public abstract virtual IVBExpression get_HandlerExpression();
    public abstract virtual IVBExpression SetEventExpression(IVBExpression param);
    public abstract virtual IVBExpression SetHandlerExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAdditiveExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAddressOfExpression {
    public ITokenNode AddressOfKeyword { get; }
    public IPrimaryExpression Expression { get; }
    public abstract virtual ITokenNode get_AddressOfKeyword();
    public abstract virtual IPrimaryExpression get_Expression();
    public abstract virtual IPrimaryExpression SetExpression(IPrimaryExpression param);
}
internal interface JetBrains.ReSharper.Psi.VB.Tree.IAggregatedCollectionOwner {
    [NotNullAttribute]
public abstract virtual IType GetGroupVariableType(IResolveContext resolveContext);
    public abstract virtual IQualifierWithTypeElement GetQualifierWithTypeElement(IResolveContext resolveContext);
    public abstract virtual bool IsValid();
    public abstract virtual QueryChainTypeBase GetAggregatedChainType();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAggregatedRangeVariableDeclaration {
    public ITokenNode EqSign { get; }
    public IQueryAggregatedParameterPlatform Expression { get; }
    public IVBIdentifier Name { get; }
    public PsiLanguageType Language { get; }
    public IQueryAnonymousTypeProperty DeclaredElement { get; }
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IQueryAggregatedParameterPlatform get_Expression();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IQueryAggregatedParameterPlatform SetExpression(IQueryAggregatedParameterPlatform param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual bool IsValid();
    public abstract virtual XmlNode GetXMLDoc(bool inherit);
    public abstract virtual bool IsSynthetic();
    public abstract virtual IQueryAnonymousTypeProperty get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAggregatedRangeVariableDeclarationList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> DeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> get_Declarations();
    public abstract virtual TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> get_DeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAggregateQueryOperator {
    public ITokenNode AggregateKeyword { get; }
    public IQueryCollectionRangeVariableDeclarationList DeclarationList { get; }
    public IIntoOfAggregateQueryOperator IntoClause { get; }
    public TreeNodeCollection`1<IQueryOperator> QueryOperators { get; }
    public TreeNodeEnumerable`1<IQueryOperator> QueryOperatorsEnumerable { get; }
    public TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> CollectionVariables { get; }
    public TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> CollectionVariablesEnumerable { get; }
    public bool IsStandalone { get; }
    [CanBeNullAttribute]
public IQueryReference AggregateReference { get; }
    public abstract virtual ITokenNode get_AggregateKeyword();
    public abstract virtual IQueryCollectionRangeVariableDeclarationList get_DeclarationList();
    public abstract virtual IIntoOfAggregateQueryOperator get_IntoClause();
    public abstract virtual TreeNodeCollection`1<IQueryOperator> get_QueryOperators();
    public abstract virtual TreeNodeEnumerable`1<IQueryOperator> get_QueryOperatorsEnumerable();
    public abstract virtual TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> get_CollectionVariables();
    public abstract virtual TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> get_CollectionVariablesEnumerable();
    public abstract virtual IQueryCollectionRangeVariableDeclarationList SetDeclarationList(IQueryCollectionRangeVariableDeclarationList param);
    public abstract virtual IIntoOfAggregateQueryOperator SetIntoClause(IIntoOfAggregateQueryOperator param);
    public abstract virtual bool get_IsStandalone();
    public abstract virtual IQueryReference get_AggregateReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAliasClause {
    public ITokenNode AliasKeyword { get; }
    public ITokenNode AliasName { get; }
    public abstract virtual ITokenNode get_AliasKeyword();
    public abstract virtual ITokenNode get_AliasName();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAnonymousArrayCreationExpression {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IVBExpression> Initializer { get; }
    public TreeNodeEnumerable`1<IVBExpression> InitializerEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBExpression> get_Initializer();
    public abstract virtual TreeNodeEnumerable`1<IVBExpression> get_InitializerEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual IVBExpression AddElementInitializerAfter(IVBExpression param, IVBExpression anchor);
    public abstract virtual IVBExpression AddElementInitializerBefore(IVBExpression param, IVBExpression anchor);
    public abstract virtual void RemoveElementInitializer(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAnonymousMemberDeclaration {
    public ITokenNode Dot { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public ITokenNode Key { get; }
    public IVBIdentifier Name { get; }
    public bool IsKey { get; }
    public bool IsProjectionInitializer { get; }
    public IReference ReferenceToProperty { get; }
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_Key();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual string GetName();
    public abstract virtual bool get_IsKey();
    public abstract virtual bool get_IsProjectionInitializer();
    public abstract virtual IReference get_ReferenceToProperty();
    public abstract virtual TreeTextRange GetNameTextRange();
    public abstract virtual DocumentRange GetNameDocumentRange();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAnonymousObjectCreationExpression {
    public IAnonymousObjectInitializer Initializer { get; }
    public ITokenNode NewKeyword { get; }
    public TreeNodeCollection`1<IAnonymousMemberDeclaration> MemberDeclarations { get; }
    public TreeNodeEnumerable`1<IAnonymousMemberDeclaration> MemberDeclarationsEnumerable { get; }
    public abstract virtual IAnonymousObjectInitializer get_Initializer();
    public abstract virtual ITokenNode get_NewKeyword();
    public abstract virtual TreeNodeCollection`1<IAnonymousMemberDeclaration> get_MemberDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IAnonymousMemberDeclaration> get_MemberDeclarationsEnumerable();
    public abstract virtual IAnonymousObjectInitializer SetInitializer(IAnonymousObjectInitializer param);
    public abstract virtual IList`1<AnonymousTypeDescriptor> GetTypeDescriptor();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAnonymousObjectInitializer {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IAnonymousMemberDeclaration> MemberDeclarations { get; }
    public TreeNodeEnumerable`1<IAnonymousMemberDeclaration> MemberDeclarationsEnumerable { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode WithKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual TreeNodeCollection`1<IAnonymousMemberDeclaration> get_MemberDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IAnonymousMemberDeclaration> get_MemberDeclarationsEnumerable();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual ITokenNode get_WithKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IArgumentList {
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public abstract virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IArrayBound {
    public IVBExpression Bound1 { get; }
    public IVBExpression Bound2 { get; }
    public ITokenNode ToKeyword { get; }
    public abstract virtual IVBExpression get_Bound1();
    public abstract virtual IVBExpression get_Bound2();
    public abstract virtual ITokenNode get_ToKeyword();
    public abstract virtual IVBExpression SetBound1(IVBExpression param);
    public abstract virtual IVBExpression SetBound2(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IArrayCreationExpression {
    public IAnonymousArrayCreationExpression ArrayInitializer { get; }
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode NewLeyword { get; }
    public ITokenNode NullableMark { get; }
    public IDeclaredTypeUsage TypeUsage { get; }
    public abstract virtual IAnonymousArrayCreationExpression get_ArrayInitializer();
    public abstract virtual IArrayModifiersList get_ArrayModifiersList();
    public abstract virtual ITokenNode get_NewLeyword();
    public abstract virtual ITokenNode get_NullableMark();
    public abstract virtual IDeclaredTypeUsage get_TypeUsage();
    public abstract virtual IAnonymousArrayCreationExpression SetArrayInitializer(IAnonymousArrayCreationExpression param);
    public abstract virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public abstract virtual IDeclaredTypeUsage SetTypeUsage(IDeclaredTypeUsage param);
    public abstract virtual void SetArrayType(IArrayType arrayType);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IArrayModifier {
    public TreeNodeCollection`1<IArrayBound> ArrayBounds { get; }
    public TreeNodeEnumerable`1<IArrayBound> ArrayBoundsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual TreeNodeCollection`1<IArrayBound> get_ArrayBounds();
    public abstract virtual TreeNodeEnumerable`1<IArrayBound> get_ArrayBoundsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IArrayModifiersList {
    public TreeNodeCollection`1<IArrayModifier> ArrayModifiers { get; }
    public TreeNodeEnumerable`1<IArrayModifier> ArrayModifiersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IArrayModifier> get_ArrayModifiers();
    public abstract virtual TreeNodeEnumerable`1<IArrayModifier> get_ArrayModifiersEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAssignmentStatement {
    public IVBExpression LValue { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RValue { get; }
    public bool IsCompoundAssignment { get; }
    public AssignmentType AssignmentType { get; }
    public abstract virtual IVBExpression get_LValue();
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IVBExpression get_RValue();
    public abstract virtual IVBExpression SetLValue(IVBExpression param);
    public abstract virtual IVBExpression SetRValue(IVBExpression param);
    public abstract virtual bool get_IsCompoundAssignment();
    public abstract virtual AssignmentType get_AssignmentType();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAttribute {
    public IReferenceName AttributeType { get; }
    public ITokenNode Colon { get; }
    public ITokenNode Target { get; }
    [NotNullAttribute]
public IReference ConstructorReference { get; }
    [CanBeNullAttribute]
public IReference TypeReference { get; }
    public abstract virtual IReferenceName get_AttributeType();
    public abstract virtual ITokenNode get_Colon();
    public abstract virtual ITokenNode get_Target();
    public abstract virtual IReferenceName SetAttributeType(IReferenceName param);
    public abstract virtual IReference get_ConstructorReference();
    public abstract virtual IReference get_TypeReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAttributeList {
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> LeftAngle { get; }
    public TreeNodeEnumerable`1<ITokenNode> LeftAngleEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> RightAngle { get; }
    public TreeNodeEnumerable`1<ITokenNode> RightAngleEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_LeftAngle();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_LeftAngleEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_RightAngle();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_RightAngleEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAttributeListOwner {
    public IAttributeList AttributeList { get; }
    public abstract virtual IAttributeList get_AttributeList();
    public abstract virtual IAttributeList SetAttributeList(IAttributeList param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAttributesOwnerDeclaration {
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public abstract virtual IAttribute AddAttribute(IAttribute attribute);
    public abstract virtual void RemoveAttribute(IAttribute attribute);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAwaitExpression {
    public ITokenNode AwaitKeyword { get; }
    public IPrimaryExpression Expression { get; }
    public IManagedReference GetAwaiterReference { get; }
    public IManagedReference AwaiterGetResultReference { get; }
    public IManagedReference AwaiterOnCompletedReference { get; }
    public IManagedReference AwaiterIsCompletedReference { get; }
    public IType AwaitableType { get; }
    public abstract virtual ITokenNode get_AwaitKeyword();
    public abstract virtual IPrimaryExpression get_Expression();
    public abstract virtual IPrimaryExpression SetExpression(IPrimaryExpression param);
    public abstract virtual IManagedReference get_GetAwaiterReference();
    public abstract virtual IManagedReference get_AwaiterGetResultReference();
    public abstract virtual IManagedReference get_AwaiterOnCompletedReference();
    public abstract virtual IManagedReference get_AwaiterIsCompletedReference();
    public abstract virtual IType get_AwaitableType();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IAwaitStatement {
    public IAwaitExpression Expression { get; }
    public abstract virtual IAwaitExpression get_Expression();
    public abstract virtual IAwaitExpression SetExpression(IAwaitExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IBlock {
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IVBStatement> Statements { get; }
    public TreeNodeEnumerable`1<IVBStatement> StatementsEnumerable { get; }
    public bool IsBody { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBStatement> get_Statements();
    public abstract virtual TreeNodeEnumerable`1<IVBStatement> get_StatementsEnumerable();
    public abstract virtual IList`1<ILabel> GetLabelByName(string name);
    public abstract virtual IList`1<ILabel> GetAllLabels();
    public abstract virtual void RemoveStatement(IVBStatement statement);
    public abstract virtual IVBStatement AddStatement(IVBStatement statement, IVBStatement anchorStatement, bool before);
    public abstract virtual IVBStatement AddStatementBefore(IVBStatement statement, IVBStatementsRange anchorRange);
    public abstract virtual IVBStatement AddStatementAfter(IVBStatement statement, IVBStatementsRange anchorRange);
    public abstract virtual IVBStatementsRange GetAllStatementsRange();
    public abstract virtual IVBStatementsRange GetStatementsRange(TreeTextRange textRange);
    public abstract virtual IVBStatementsRange GetStatementsRange(IVBStatement first, IVBStatement last);
    public abstract virtual void RemoveStatementsRange(IVBStatementsRange range);
    public abstract virtual IVBStatementsRange AddStatementsRange(IVBStatementsRange range, ITreeNode anchor, bool before);
    public abstract virtual bool get_IsBody();
    [NotNullAttribute]
public abstract virtual IBlock ReplaceBy(IBlock block);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IBlockIfStatement {
    public IBlock Block { get; }
    public TreeNodeCollection`1<IElseIfStatement> ElseIfStatements { get; }
    public TreeNodeEnumerable`1<IElseIfStatement> ElseIfStatementsEnumerable { get; }
    public IElseStatement ElseStatement { get; }
    public ITokenNode EndIf { get; }
    public IVBExpression Expression { get; }
    public ITokenNode IfKeyword { get; }
    public ITokenNode ThenKeyword { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual TreeNodeCollection`1<IElseIfStatement> get_ElseIfStatements();
    public abstract virtual TreeNodeEnumerable`1<IElseIfStatement> get_ElseIfStatementsEnumerable();
    public abstract virtual IElseStatement get_ElseStatement();
    public abstract virtual ITokenNode get_EndIf();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_IfKeyword();
    public abstract virtual ITokenNode get_ThenKeyword();
    public abstract virtual IBlock SetBlock(IBlock param);
    public abstract virtual IElseStatement SetElseStatement(IElseStatement param);
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ICaseClause {
    public IVBExpression Expression { get; }
    public ITokenNode IsKeyword { get; }
    public IVBExpression ToExpression { get; }
    public ITokenNode ToKeyword { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_IsKeyword();
    public abstract virtual IVBExpression get_ToExpression();
    public abstract virtual ITokenNode get_ToKeyword();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual IVBExpression SetToExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ICaseStatement {
    public IBlock Block { get; }
    public TreeNodeCollection`1<ICaseClause> CaseClauses { get; }
    public TreeNodeEnumerable`1<ICaseClause> CaseClausesEnumerable { get; }
    public ITokenNode CaseKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ElseKeyword { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual TreeNodeCollection`1<ICaseClause> get_CaseClauses();
    public abstract virtual TreeNodeEnumerable`1<ICaseClause> get_CaseClausesEnumerable();
    public abstract virtual ITokenNode get_CaseKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_ElseKeyword();
    public abstract virtual IBlock SetBlock(IBlock param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ICastExpression {
    public ITokenNode Comma { get; }
    public IVBExpression Expression { get; }
    public ITokenNode Keyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    public CastExpressionKind Kind { get; }
    public abstract virtual ITokenNode get_Comma();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual CastExpressionKind get_Kind();
    public abstract virtual IType GetCastType();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ICatchStatement {
    public IBlock Block { get; }
    public ITokenNode CatchKeyword { get; }
    public ICatchVariableDeclaration CatchVariableDeclaration { get; }
    public IReferenceExpression CatchVariableExpression { get; }
    public IVBExpression Expression { get; }
    public ITokenNode WhenKeyword { get; }
    public IDeclaredType ExceptionType { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual ITokenNode get_CatchKeyword();
    public abstract virtual ICatchVariableDeclaration get_CatchVariableDeclaration();
    public abstract virtual IReferenceExpression get_CatchVariableExpression();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_WhenKeyword();
    public abstract virtual IBlock SetBlock(IBlock param);
    public abstract virtual ICatchVariableDeclaration SetCatchVariableDeclaration(ICatchVariableDeclaration param);
    public abstract virtual IReferenceExpression SetCatchVariableExpression(IReferenceExpression param);
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual IDeclaredType get_ExceptionType();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ICatchVariableDeclaration {
    public ITokenNode AsKeyword { get; }
    public abstract virtual ITokenNode get_AsKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ICharsetModifier {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IClassBaseClause {
    public ITokenNode InheritsKeyword { get; }
    public IDeclaredTypeUsage InheritsType { get; }
    public abstract virtual ITokenNode get_InheritsKeyword();
    public abstract virtual IDeclaredTypeUsage get_InheritsType();
    public abstract virtual IDeclaredTypeUsage SetInheritsType(IDeclaredTypeUsage param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IClassBody {
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConversionOperatorDeclaration> ConversionOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IConversionOperatorDeclaration> ConversionOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IExternalMethodDeclaration> ExternalMethodDeclarations { get; }
    public TreeNodeEnumerable`1<IExternalMethodDeclaration> ExternalMethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMultipleConstantDeclaration> MultipleConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleConstantDeclaration> MultipleConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMultipleVariableDeclaration> MultipleVariableDeclarations { get; }
    public TreeNodeEnumerable`1<IMultipleVariableDeclaration> MultipleVariableDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ISignOperatorDeclaration> SignOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<ISignOperatorDeclaration> SignOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> TypeDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IExternalMethodDeclaration> get_ExternalMethodDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IExternalMethodDeclaration> get_ExternalMethodDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IMultipleConstantDeclaration> get_MultipleConstantDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IMultipleConstantDeclaration> get_MultipleConstantDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IMultipleVariableDeclaration> get_MultipleVariableDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IMultipleVariableDeclaration> get_MultipleVariableDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ISignOperatorDeclaration> get_SignOperatorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ISignOperatorDeclaration> get_SignOperatorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBTreeNode> get_TypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBTreeNode> get_TypeDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IClassDeclaration {
    public IClassBaseClause BaseClause { get; }
    public ITokenNode ClassKeyword { get; }
    public ITokenNode EndClass { get; }
    public TreeNodeCollection`1<ITypeImplementsClause> ImplementsClauses { get; }
    public TreeNodeEnumerable`1<ITypeImplementsClause> ImplementsClausesEnumerable { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> ImplementsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> ImplementsTypesEnumerable { get; }
    public IDeclaredTypeUsage InheritsType { get; }
    public TreeNodeCollection`1<IVBTreeNode> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> NestedTypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> TypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public IClass DeclaredElement { get; }
    public abstract virtual IClassBaseClause get_BaseClause();
    public abstract virtual ITokenNode get_ClassKeyword();
    public abstract virtual ITokenNode get_EndClass();
    public abstract virtual TreeNodeCollection`1<ITypeImplementsClause> get_ImplementsClauses();
    public abstract virtual TreeNodeEnumerable`1<ITypeImplementsClause> get_ImplementsClausesEnumerable();
    public abstract virtual ITypeParameterOfTypeList get_TypeParameterList();
    public abstract virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_ImplementsTypes();
    public abstract virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_ImplementsTypesEnumerable();
    public abstract virtual IDeclaredTypeUsage get_InheritsType();
    public abstract virtual TreeNodeCollection`1<IVBTreeNode> get_NestedTypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBTreeNode> get_NestedTypeDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBTreeNode> get_TypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBTreeNode> get_TypeDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public abstract virtual IClassBaseClause SetBaseClause(IClassBaseClause param);
    public abstract virtual IDeclaredTypeUsage SetInheritsType(IDeclaredTypeUsage param);
    public abstract virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public abstract virtual void SetBaseClass(IDeclaredType base);
    public abstract virtual void AddImplementsType(IDeclaredType implementsType);
    public abstract virtual void RemoveImplementsType(IDeclaredType implementsType);
    public abstract virtual IClass get_DeclaredElement();
    public abstract virtual ITypeImplementsClause AddImplementsClauseBefore(ITypeImplementsClause param, ITypeImplementsClause anchor);
    public abstract virtual ITypeImplementsClause AddImplementsClauseAfter(ITypeImplementsClause param, ITypeImplementsClause anchor);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IClassLikeDeclaration {
    public IClassBody Body { get; }
    public TreeNodeCollection`1<IConstantDeclaration> ConstantDeclarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> ConstantDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConstructorDeclaration> ConstructorDeclarations { get; }
    public TreeNodeEnumerable`1<IConstructorDeclaration> ConstructorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IConversionOperatorDeclaration> ConversionOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<IConversionOperatorDeclaration> ConversionOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IEventDeclaration> EventDeclarations { get; }
    public TreeNodeEnumerable`1<IEventDeclaration> EventDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IMethodDeclaration> MethodDeclarations { get; }
    public TreeNodeEnumerable`1<IMethodDeclaration> MethodDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IPropertyDeclaration> PropertyDeclarations { get; }
    public TreeNodeEnumerable`1<IPropertyDeclaration> PropertyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ISignOperatorDeclaration> SignOperatorDeclarations { get; }
    public TreeNodeEnumerable`1<ISignOperatorDeclaration> SignOperatorDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public IEnumerable`1<IDeclaredTypeUsage> ExtendsListTypeUsages { get; }
    public ITypeElement TypeElement { get; }
    public ITokenNode OpenKeyword { get; }
    public ITokenNode EndKeyword { get; }
    public abstract virtual IClassBody get_Body();
    public abstract virtual TreeNodeCollection`1<IConstantDeclaration> get_ConstantDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConstantDeclaration> get_ConstantDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IConstructorDeclaration> get_ConstructorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConstructorDeclaration> get_ConstructorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IConversionOperatorDeclaration> get_ConversionOperatorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IEventDeclaration> get_EventDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IEventDeclaration> get_EventDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IMethodDeclaration> get_MethodDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IMethodDeclaration> get_MethodDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IPropertyDeclaration> get_PropertyDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IPropertyDeclaration> get_PropertyDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ISignOperatorDeclaration> get_SignOperatorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ISignOperatorDeclaration> get_SignOperatorDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IVariableDeclaration> get_VariableDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVariableDeclaration> get_VariableDeclarationsEnumerable();
    public abstract virtual IClassBody SetBody(IClassBody param);
    public abstract virtual IEnumerable`1<IDeclaredTypeUsage> get_ExtendsListTypeUsages();
    public abstract virtual TTypeMemberDeclaration AddTypeMemberDeclaration(TTypeMemberDeclaration member);
    public abstract virtual TTypeMemberDeclaration AddTypeMemberDeclarationBefore(TTypeMemberDeclaration member, IVBTypeMemberDeclaration anchor);
    public abstract virtual TTypeMemberDeclaration AddTypeMemberDeclarationAfter(TTypeMemberDeclaration member, IVBTypeMemberDeclaration anchor);
    public abstract virtual void RemoveTypeMemberDeclaration(IVBTypeMemberDeclaration member);
    public abstract virtual IVBNamespaceDeclaration GetContainingNamespaceDeclaration();
    public abstract virtual TreeTextRange GetBodyTreeRange();
    public abstract virtual TTypeMemberDeclaration InsertAtSpecificPosition(TTypeMemberDeclaration param, ITreeNode anchor);
    public abstract virtual ITypeElement get_TypeElement();
    public abstract virtual ITokenNode get_OpenKeyword();
    public abstract virtual ITokenNode get_EndKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ICollectionElementInitializer {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<IVBExpression> Initializer { get; }
    public TreeNodeEnumerable`1<IVBExpression> InitializerEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual TreeNodeCollection`1<IVBExpression> get_Initializer();
    public abstract virtual TreeNodeEnumerable`1<IVBExpression> get_InitializerEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual void RemoveInitializerArgumentAt(int index);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ICollectionRangeVariableDeclaration {
    public ITokenNode AsKeyword { get; }
    public ITokenNode InKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    public IQueryReference AsEnumerableReference { get; }
    public IQueryReference AsQueryableReference { get; }
    public IQueryReference DirectCastingReference { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual bool HasAsEnumerableReference(IResolveContext resolveContext);
    public abstract virtual IQueryReference get_AsEnumerableReference();
    public abstract virtual bool HasAsQueryableReference(IResolveContext resolveContext);
    public abstract virtual IQueryReference get_AsQueryableReference();
    public abstract virtual bool HasDirectCastReference(IResolveContext resolveContext);
    public abstract virtual IQueryReference get_DirectCastingReference();
    public abstract virtual IExpressionType GetCastedCollectionType(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IConcatenationExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IConditionalAccessExpression {
    public bool HasConditionalAccessSign { get; }
    [CanBeNullAttribute]
public IVBExpression ConditionalQualifier { get; }
    [CanBeNullAttribute]
public IConditionalAccessSign ConditionalAccessSign { get; }
    public abstract virtual bool get_HasConditionalAccessSign();
    public abstract virtual IVBExpression get_ConditionalQualifier();
    public abstract virtual IConditionalAccessSign get_ConditionalAccessSign();
    public abstract virtual void SetConditionalAccessSign(bool value);
    [NotNullAttribute]
public abstract virtual IExpressionType UnliftedExpressionType();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IConditionalAccessSign {
    public ITokenNode Question { get; }
    public abstract virtual ITokenNode get_Question();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IConditionalExpression {
    public IArgumentList ArgumentList { get; }
    public ITokenNode IfKeyword { get; }
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public ConditionalExpressionKind Kind { get; }
    public IVBExpression Condition { get; }
    public IVBExpression ThenExpression { get; }
    public IVBExpression ElseExpression { get; }
    public IVBExpression FirstOperandOfNullCoalescing { get; }
    public IVBExpression SecondOperandOfNullCoalescing { get; }
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual ITokenNode get_IfKeyword();
    public abstract virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public abstract virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
    public abstract virtual ConditionalExpressionKind get_Kind();
    public abstract virtual IVBExpression get_Condition();
    public abstract virtual IVBExpression get_ThenExpression();
    public abstract virtual IVBExpression get_ElseExpression();
    public abstract virtual IVBExpression get_FirstOperandOfNullCoalescing();
    public abstract virtual IVBExpression get_SecondOperandOfNullCoalescing();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IConstantDeclaration {
    public ITokenNode AsKeyword { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    public IField ConstantElement { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IField get_ConstantElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IConstPreprocessorDirective {
    public ITokenNode ConstKeyword { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public IVBIdentifier Name { get; }
    public abstract virtual ITokenNode get_ConstKeyword();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IConstructorDeclaration {
    public ITokenNode NewKeyword { get; }
    public ITokenNode SubKeyword { get; }
    [CanBeNullAttribute]
public IIndexExpression Initializer { get; }
    public IConstructor ConstructorElement { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public IAttributeList AttributeList { get; }
    public abstract virtual ITokenNode get_NewKeyword();
    public abstract virtual ITokenNode get_SubKeyword();
    public abstract virtual IIndexExpression get_Initializer();
    public abstract virtual IConstructor get_ConstructorElement();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual IAttributeList get_AttributeList();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IContinueStatement {
    public ITokenNode ContinueKeyword { get; }
    public ITokenNode ContinueKind { get; }
    public ContinueStatementKind Kind { get; }
    public abstract virtual ITokenNode get_ContinueKeyword();
    public abstract virtual ITokenNode get_ContinueKind();
    public abstract virtual ContinueStatementKind get_Kind();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IControlReference {
    public IVBIdentifier ControlName { get; }
    public ITokenNode Dot { get; }
    public IControlReference Qualifier { get; }
    public IReference Reference { get; }
    public abstract virtual IVBIdentifier get_ControlName();
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual IControlReference get_Qualifier();
    public abstract virtual IVBIdentifier SetControlName(IVBIdentifier param);
    public abstract virtual IControlReference SetQualifier(IControlReference param);
    public abstract virtual IReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IConversionOperatorDeclaration {
    public ITokenNode CTypeKeyword { get; }
    public abstract virtual ITokenNode get_CTypeKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IDeclaredTypeUsage {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IDelegateDeclaration {
    public ITokenNode AsKeyword { get; }
    public ITokenNode DelegateKeyword { get; }
    public ITokenNode FunctionKeyword { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage ReturnTypeUsage { get; }
    public ITokenNode SubKeyword { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public IType ReturnType { get; }
    public IDelegate DeclaredElement { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public IAttributeList AttributeList { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual ITokenNode get_DelegateKeyword();
    public abstract virtual ITokenNode get_FunctionKeyword();
    public abstract virtual IReturnAttributeList get_ReturnAttributeList();
    public abstract virtual ITypeUsage get_ReturnTypeUsage();
    public abstract virtual ITokenNode get_SubKeyword();
    public abstract virtual ITypeParameterOfTypeList get_TypeParameterList();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public abstract virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public abstract virtual ITypeUsage SetReturnTypeUsage(ITypeUsage param);
    public abstract virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public abstract virtual IType get_ReturnType();
    public abstract virtual IDelegate get_DeclaredElement();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual IAttributeList get_AttributeList();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IDictionaryAccessExpression {
    public IVBIdentifier Argument { get; }
    public IPrimaryExpression BaseExpression { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode ExclSign { get; }
    public abstract virtual IVBIdentifier get_Argument();
    public abstract virtual IPrimaryExpression get_BaseExpression();
    public abstract virtual IConditionalAccessSign get_ConditionalAccessSign();
    public abstract virtual ITokenNode get_ExclSign();
    public abstract virtual IVBIdentifier SetArgument(IVBIdentifier param);
    public abstract virtual IPrimaryExpression SetBaseExpression(IPrimaryExpression param);
    public abstract virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IDisableWarningPreprocessorDirective {
    public ITokenNode DisableWord { get; }
    public abstract virtual ITokenNode get_DisableWord();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IDistinctQueryOperator {
    public ITokenNode DistinctKeyword { get; }
    public IQueryReference DistinctReference { get; }
    public abstract virtual ITokenNode get_DistinctKeyword();
    public abstract virtual IQueryReference get_DistinctReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IDocComment {
    public abstract virtual IDocComment ReplaceBy(IDocComment docCommentNode);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IDoLoopStatement {
    public ITokenNode DoKeyword { get; }
    public ITokenNode LoopKeyword { get; }
    public IWhileUntilCondition PostCondition { get; }
    public IWhileUntilCondition PreCondition { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public abstract virtual ITokenNode get_DoKeyword();
    public abstract virtual ITokenNode get_LoopKeyword();
    public abstract virtual IWhileUntilCondition get_PostCondition();
    public abstract virtual IWhileUntilCondition get_PreCondition();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual IWhileUntilCondition SetPostCondition(IWhileUntilCondition param);
    public abstract virtual IWhileUntilCondition SetPreCondition(IWhileUntilCondition param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IElseIfPreprocessorDirective {
    public ITokenNode ElseIfKeyword { get; }
    public IVBExpression Expression { get; }
    public ITokenNode ThenKeyword { get; }
    public abstract virtual ITokenNode get_ElseIfKeyword();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_ThenKeyword();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IElseIfStatement {
    public IBlock Block { get; }
    public ITokenNode ElseIfKeyword { get; }
    public IVBExpression Expression { get; }
    public ITokenNode ThenKeyword { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual ITokenNode get_ElseIfKeyword();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_ThenKeyword();
    public abstract virtual IBlock SetBlock(IBlock param);
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IElsePreprocessorDirective {
    public ITokenNode ElseKeyword { get; }
    public abstract virtual ITokenNode get_ElseKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IElseStatement {
    public IBlock Block { get; }
    public ITokenNode ElseKeyword { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual ITokenNode get_ElseKeyword();
    public abstract virtual IBlock SetBlock(IBlock param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEmptyArgument {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEnableWarningPreprocessorDirective {
    public ITokenNode EnableWord { get; }
    public abstract virtual ITokenNode get_EnableWord();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEndExternalSourcePreprocessorDirective {
    public ITokenNode EndKeyword { get; }
    public ITokenNode ExternalSourceWord { get; }
    public abstract virtual ITokenNode get_EndKeyword();
    public abstract virtual ITokenNode get_ExternalSourceWord();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEndIfPreprocessorDirective {
    public ITokenNode EndIf { get; }
    public abstract virtual ITokenNode get_EndIf();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEndRegionPreprocessorDirective {
    public ITokenNode EndKeyword { get; }
    public ITokenNode RegionWord { get; }
    public abstract virtual ITokenNode get_EndKeyword();
    public abstract virtual ITokenNode get_RegionWord();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEndStatement {
    public ITokenNode EndKeyword { get; }
    public abstract virtual ITokenNode get_EndKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEnumDeclaration {
    public ITokenNode AsKeyword { get; }
    public IDeclaredTypeUsage BaseTypeName { get; }
    public ITokenNode EndEnum { get; }
    public ITokenNode EnumKeyword { get; }
    public TreeNodeCollection`1<IEnumMemberDeclaration> EnumMemberDeclarations { get; }
    public TreeNodeEnumerable`1<IEnumMemberDeclaration> EnumMemberDeclarationsEnumerable { get; }
    public IEnum DeclaredElement { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual IDeclaredTypeUsage get_BaseTypeName();
    public abstract virtual ITokenNode get_EndEnum();
    public abstract virtual ITokenNode get_EnumKeyword();
    public abstract virtual TreeNodeCollection`1<IEnumMemberDeclaration> get_EnumMemberDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IEnumMemberDeclaration> get_EnumMemberDeclarationsEnumerable();
    public abstract virtual IDeclaredTypeUsage SetBaseTypeName(IDeclaredTypeUsage param);
    public abstract virtual IType GetUnderlyingType();
    public abstract virtual IEnumMemberDeclaration AddEnumMemberDeclaration(IEnumMemberDeclaration param, IEnumMemberDeclaration anchor, bool before);
    public abstract virtual void RemoveEnumMemberDeclaration(IEnumMemberDeclaration param);
    public abstract virtual IEnum get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEnumMemberDeclaration {
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public IVBIdentifier Name { get; }
    public IField EnumMember { get; }
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual IField get_EnumMember();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEraseStatement {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode EraseKeyword { get; }
    public TreeNodeCollection`1<IPrimaryExpression> Expressions { get; }
    public TreeNodeEnumerable`1<IPrimaryExpression> ExpressionsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_EraseKeyword();
    public abstract virtual TreeNodeCollection`1<IPrimaryExpression> get_Expressions();
    public abstract virtual TreeNodeEnumerable`1<IPrimaryExpression> get_ExpressionsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IErrorStatement {
    public ITokenNode ErrorKeyword { get; }
    public IVBExpression NextExpression { get; }
    public abstract virtual ITokenNode get_ErrorKeyword();
    public abstract virtual IVBExpression get_NextExpression();
    public abstract virtual IVBExpression SetNextExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEventDeclaration {
    public ITokenNode CustomKeyword { get; }
    public IRegularParameterList DelegateParameterList { get; }
    public IDeclaredTypeUsage DelegateTypeUsage { get; }
    public ITokenNode EndEvent { get; }
    public ITokenNode EventKeyword { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> DelegateParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> DelegateParameterDeclarationsEnumerable { get; }
    public bool IsCustom { get; }
    public string EventHandlerShortName { get; }
    public IEvent DeclaredElement { get; }
    public abstract virtual ITokenNode get_CustomKeyword();
    public abstract virtual IRegularParameterList get_DelegateParameterList();
    public abstract virtual IDeclaredTypeUsage get_DelegateTypeUsage();
    public abstract virtual ITokenNode get_EndEvent();
    public abstract virtual ITokenNode get_EventKeyword();
    public abstract virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_DelegateParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_DelegateParameterDeclarationsEnumerable();
    public abstract virtual IRegularParameterList SetDelegateParameterList(IRegularParameterList param);
    public abstract virtual IDeclaredTypeUsage SetDelegateTypeUsage(IDeclaredTypeUsage param);
    public abstract virtual bool HasEventHandler();
    public abstract virtual bool HasEventField();
    public abstract virtual bool get_IsCustom();
    public abstract virtual string get_EventHandlerShortName();
    public abstract virtual IEvent get_DeclaredElement();
    public abstract virtual IVBParameterDeclaration AddParameterDeclarationBefore(IVBParameterDeclaration parameter, IVBParameterDeclaration anchor);
    public abstract virtual IVBParameterDeclaration AddParameterDeclarationAfter(IVBParameterDeclaration parameter, IVBParameterDeclaration anchor);
    public abstract virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public abstract virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public abstract virtual void RemoveParameterDeclaration(IVBParameterDeclaration parameter);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IEventSpecifier {
    public IVBTreeNode Base { get; }
    public ITokenNode Dot { get; }
    public IVBIdentifier MemberName { get; }
    [CanBeNullAttribute]
public IReference FieldReference { get; }
    public IReference EventReference { get; }
    public abstract virtual IVBTreeNode get_Base();
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual IVBIdentifier get_MemberName();
    public abstract virtual IVBIdentifier SetMemberName(IVBIdentifier param);
    public abstract virtual IReference get_FieldReference();
    public abstract virtual IReference get_EventReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExitStatement {
    public ITokenNode ExitKeyword { get; }
    public ITokenNode ExitKind { get; }
    public ExitStatementKind Kind { get; }
    public abstract virtual ITokenNode get_ExitKeyword();
    public abstract virtual ITokenNode get_ExitKind();
    public abstract virtual ExitStatementKind get_Kind();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExponentiationExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExpressionArgument {
    public IVBExpression Expression { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExpressionRangeVariableDeclaration {
    public ITokenNode AsKeyword { get; }
    public ITokenNode EqSign { get; }
    public IQueryParameterPlatform Expression { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    public PsiLanguageType Language { get; }
    public IQueryAnonymousTypeProperty DeclaredElement { get; }
    public IQueryReference LetReference { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual bool IsValid();
    public abstract virtual XmlNode GetXMLDoc(bool inherit);
    public abstract virtual bool IsSynthetic();
    public abstract virtual IQueryAnonymousTypeProperty get_DeclaredElement();
    public abstract virtual IQueryReference get_LetReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExpressionRangeVariableDeclarationList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> DeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_Declarations();
    public abstract virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_DeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExpressionStatement {
    public IVBExpression Expression { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExternalChecksumPreprocessorDirective {
    public TreeNodeCollection`1<ITokenNode> Checksum { get; }
    public TreeNodeEnumerable`1<ITokenNode> ChecksumEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ExternalChecksumWord { get; }
    public TreeNodeCollection`1<ITokenNode> Guid { get; }
    public TreeNodeEnumerable`1<ITokenNode> GuidEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITokenNode> Source { get; }
    public TreeNodeEnumerable`1<ITokenNode> SourceEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Checksum();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ChecksumEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_ExternalChecksumWord();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Guid();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_GuidEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Source();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_SourceEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExternalMethodDeclaration {
    public IAliasClause AliasClause { get; }
    public ICharsetModifier CharsetModifier { get; }
    public ITokenNode DeclareKeyword { get; }
    public ILibraryClause LibraryClause { get; }
    public abstract virtual IAliasClause get_AliasClause();
    public abstract virtual ICharsetModifier get_CharsetModifier();
    public abstract virtual ITokenNode get_DeclareKeyword();
    public abstract virtual ILibraryClause get_LibraryClause();
    public abstract virtual IAliasClause SetAliasClause(IAliasClause param);
    public abstract virtual ICharsetModifier SetCharsetModifier(ICharsetModifier param);
    public abstract virtual ILibraryClause SetLibraryClause(ILibraryClause param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IExternalSourcePreprocessorDirective {
    public ITokenNode Comma { get; }
    public ITokenNode ExternalSourceWord { get; }
    public ITokenNode LPar { get; }
    public ITokenNode Line { get; }
    public ITokenNode RPar { get; }
    public ITokenNode Source { get; }
    public abstract virtual ITokenNode get_Comma();
    public abstract virtual ITokenNode get_ExternalSourceWord();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_Line();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITokenNode get_Source();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IFinallyStatement {
    public IBlock Block { get; }
    public ITokenNode FinallyKeyword { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual ITokenNode get_FinallyKeyword();
    public abstract virtual IBlock SetBlock(IBlock param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IForEachStatement {
    public ITokenNode EachKeyword { get; }
    public IVBExpression Expression { get; }
    public ITokenNode ForKeyword { get; }
    public ITokenNode InKeyword { get; }
    public ILoopControlVariableDeclaration LoopVariableDeclaration { get; }
    public IPrimaryExpression LoopVariableExpression { get; }
    public INextClause NextClause { get; }
    public IForEachStatementReference GetEnumeratorReference { get; }
    public IForEachStatementReference MoveNextReference { get; }
    public IForEachStatementReference CurrentReference { get; }
    public abstract virtual ITokenNode get_EachKeyword();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_ForKeyword();
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual ILoopControlVariableDeclaration get_LoopVariableDeclaration();
    public abstract virtual IPrimaryExpression get_LoopVariableExpression();
    public abstract virtual INextClause get_NextClause();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual ILoopControlVariableDeclaration SetLoopVariableDeclaration(ILoopControlVariableDeclaration param);
    public abstract virtual IPrimaryExpression SetLoopVariableExpression(IPrimaryExpression param);
    public abstract virtual INextClause SetNextClause(INextClause param);
    public abstract virtual IForEachStatementReference get_GetEnumeratorReference();
    public abstract virtual IForEachStatementReference get_MoveNextReference();
    public abstract virtual IForEachStatementReference get_CurrentReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IForEachStatementReference {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IForStatement {
    public IVBExpression EndExpression { get; }
    public ITokenNode EqSign { get; }
    public ITokenNode ForKeyword { get; }
    public ILoopControlVariableDeclaration LoopVariableDeclaration { get; }
    public IPrimaryExpression LoopVariableExpression { get; }
    public INextClause NextClause { get; }
    public IVBExpression StartExpression { get; }
    public IVBExpression StepExpression { get; }
    public ITokenNode StepKeyword { get; }
    public ITokenNode ToKeyword { get; }
    public abstract virtual IVBExpression get_EndExpression();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual ITokenNode get_ForKeyword();
    public abstract virtual ILoopControlVariableDeclaration get_LoopVariableDeclaration();
    public abstract virtual IPrimaryExpression get_LoopVariableExpression();
    public abstract virtual INextClause get_NextClause();
    public abstract virtual IVBExpression get_StartExpression();
    public abstract virtual IVBExpression get_StepExpression();
    public abstract virtual ITokenNode get_StepKeyword();
    public abstract virtual ITokenNode get_ToKeyword();
    public abstract virtual IVBExpression SetEndExpression(IVBExpression param);
    public abstract virtual ILoopControlVariableDeclaration SetLoopVariableDeclaration(ILoopControlVariableDeclaration param);
    public abstract virtual IPrimaryExpression SetLoopVariableExpression(IPrimaryExpression param);
    public abstract virtual INextClause SetNextClause(INextClause param);
    public abstract virtual IVBExpression SetStartExpression(IVBExpression param);
    public abstract virtual IVBExpression SetStepExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.IfPreprocessorDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIfPreprocessorDirective GetByExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IFromQueryOperator {
    public IQueryCollectionRangeVariableDeclarationList DeclarationList { get; }
    public ITokenNode FromKeyword { get; }
    public TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public abstract virtual IQueryCollectionRangeVariableDeclarationList get_DeclarationList();
    public abstract virtual ITokenNode get_FromKeyword();
    public abstract virtual TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> get_VariableDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> get_VariableDeclarationsEnumerable();
    public abstract virtual IQueryCollectionRangeVariableDeclarationList SetDeclarationList(IQueryCollectionRangeVariableDeclarationList param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IGetTypeExpression {
    public ITokenNode GetTypeKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public ITypeUsage TypeUsage { get; }
    [NotNullAttribute]
public IType ArgumentType { get; }
    public abstract virtual ITokenNode get_GetTypeKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual IType get_ArgumentType();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IGetXmlNamespaceExpression {
    public ITokenNode GetXmlNamespaceKeyword { get; }
    public ITokenNode LPar { get; }
    public ITokenNode NamespaceName { get; }
    public ITokenNode RPar { get; }
    public abstract virtual ITokenNode get_GetXmlNamespaceKeyword();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_NamespaceName();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IGotoStatement {
    public ITokenNode GotoKeyword { get; }
    public abstract virtual ITokenNode get_GotoKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IGroupByQueryOperator {
    public ITokenNode ByKeyword { get; }
    public ITokenNode GroupKeyword { get; }
    public ITokenNode IntoKeyword { get; }
    public IExpressionRangeVariableDeclarationList KeyDeclarationsList { get; }
    public IAggregatedRangeVariableDeclarationList ResultDeclarationsList { get; }
    public IExpressionRangeVariableDeclarationList SelectorDeclarationsList { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> KeyDeclarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> KeyDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> ResultDeclarations { get; }
    public TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> ResultDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> SelectorDeclarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> SelectorDeclarationsEnumerable { get; }
    public IQueryReference GroupByReference { get; }
    public abstract virtual ITokenNode get_ByKeyword();
    public abstract virtual ITokenNode get_GroupKeyword();
    public abstract virtual ITokenNode get_IntoKeyword();
    public abstract virtual IExpressionRangeVariableDeclarationList get_KeyDeclarationsList();
    public abstract virtual IAggregatedRangeVariableDeclarationList get_ResultDeclarationsList();
    public abstract virtual IExpressionRangeVariableDeclarationList get_SelectorDeclarationsList();
    public abstract virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_KeyDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_KeyDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> get_ResultDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> get_ResultDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_SelectorDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_SelectorDeclarationsEnumerable();
    public abstract virtual IExpressionRangeVariableDeclarationList SetKeyDeclarationsList(IExpressionRangeVariableDeclarationList param);
    public abstract virtual IAggregatedRangeVariableDeclarationList SetResultDeclarationsList(IAggregatedRangeVariableDeclarationList param);
    public abstract virtual IExpressionRangeVariableDeclarationList SetSelectorDeclarationsList(IExpressionRangeVariableDeclarationList param);
    public abstract virtual IQueryReference get_GroupByReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IGroupJoinQueryOperator {
    public IAggregatedRangeVariableDeclarationList DeclarationList { get; }
    public ITokenNode GroupKeyword { get; }
    public ITokenNode IntoKeyword { get; }
    public IJoinQueryOperator JoinOperator { get; }
    public TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> ResultDeclarations { get; }
    public TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> ResultDeclarationsEnumerable { get; }
    public IQueryReference GroupJoinReference { get; }
    public abstract virtual IAggregatedRangeVariableDeclarationList get_DeclarationList();
    public abstract virtual ITokenNode get_GroupKeyword();
    public abstract virtual ITokenNode get_IntoKeyword();
    public abstract virtual IJoinQueryOperator get_JoinOperator();
    public abstract virtual TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> get_ResultDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> get_ResultDeclarationsEnumerable();
    public abstract virtual IAggregatedRangeVariableDeclarationList SetDeclarationList(IAggregatedRangeVariableDeclarationList param);
    public abstract virtual IJoinQueryOperator SetJoinOperator(IJoinQueryOperator param);
    public abstract virtual IQueryReference get_GroupJoinReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IHandlesClause {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IEventSpecifier> EventSpecifiers { get; }
    public TreeNodeEnumerable`1<IEventSpecifier> EventSpecifiersEnumerable { get; }
    public ITokenNode HandlesKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IEventSpecifier> get_EventSpecifiers();
    public abstract virtual TreeNodeEnumerable`1<IEventSpecifier> get_EventSpecifiersEnumerable();
    public abstract virtual ITokenNode get_HandlesKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IIfPreprocessorDirective {
    public IVBExpression Expression { get; }
    public ITokenNode IfKeyword { get; }
    public ITokenNode ThenKeyword { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_IfKeyword();
    public abstract virtual ITokenNode get_ThenKeyword();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IImplementsClause {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ImplementsKeyword { get; }
    public TreeNodeCollection`1<IInterfaceMemberSpecifier> MemberSpecifiers { get; }
    public TreeNodeEnumerable`1<IInterfaceMemberSpecifier> MemberSpecifiersEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_ImplementsKeyword();
    public abstract virtual TreeNodeCollection`1<IInterfaceMemberSpecifier> get_MemberSpecifiers();
    public abstract virtual TreeNodeEnumerable`1<IInterfaceMemberSpecifier> get_MemberSpecifiersEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IImplementsSpecificationOwner {
    [NotNullAttribute]
public IList`1<IInterfaceMemberSpecifier> MemberSpecifiers { get; }
    public abstract virtual IList`1<IInterfaceMemberSpecifier> get_MemberSpecifiers();
    public abstract virtual void AddImplementsSpecification(IDeclaredType interfaceType, string name);
    public abstract virtual void RemoveImplementsSpecification(IDeclaredType interfaceType);
    public abstract virtual void RemoveAllImplementsSpecifications();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IImportAliasClause {
    public IVBIdentifier Alias { get; }
    public ITokenNode EqSign { get; }
    public IReferenceName ImportedSymbol { get; }
    public string AliasName { get; }
    public IReference ImportedSymbolReference { get; }
    public abstract virtual IVBIdentifier get_Alias();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IReferenceName get_ImportedSymbol();
    public abstract virtual IVBIdentifier SetAlias(IVBIdentifier param);
    public abstract virtual IReferenceName SetImportedSymbol(IReferenceName param);
    public abstract virtual string get_AliasName();
    public abstract virtual IReference get_ImportedSymbolReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IImportClause {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IImportDirective {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IImportClause> ImportClauses { get; }
    public TreeNodeEnumerable`1<IImportClause> ImportClausesEnumerable { get; }
    public ITokenNode ImportsKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IImportClause> get_ImportClauses();
    public abstract virtual TreeNodeEnumerable`1<IImportClause> get_ImportClausesEnumerable();
    public abstract virtual ITokenNode get_ImportsKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IImportDirectivesSection {
    public TreeNodeCollection`1<IImportDirective> ImportDirectives { get; }
    public TreeNodeEnumerable`1<IImportDirective> ImportDirectivesEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IImportDirective> get_ImportDirectives();
    public abstract virtual TreeNodeEnumerable`1<IImportDirective> get_ImportDirectivesEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IImportNamespaceClause {
    public IReferenceName ImportedNamespaceReferenceName { get; }
    [CanBeNullAttribute]
public IReference Reference { get; }
    [CanBeNullAttribute]
public IDeclaredElement ImportedElement { get; }
    public abstract virtual IReferenceName get_ImportedNamespaceReferenceName();
    public abstract virtual IReferenceName SetImportedNamespaceReferenceName(IReferenceName param);
    public abstract virtual IReference get_Reference();
    public abstract virtual IDeclaredElement get_ImportedElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IImportXMLNamespaceClause {
    public ITokenNode EqSign { get; }
    public ITokenNode Identifier { get; }
    public TreeNodeCollection`1<ITokenNode> Space { get; }
    public TreeNodeEnumerable`1<ITokenNode> SpaceEnumerable { get; }
    public ITokenNode String { get; }
    public ITokenNode TagEnd { get; }
    public ITokenNode TagStart { get; }
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual ITokenNode get_Identifier();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Space();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_SpaceEnumerable();
    public abstract virtual ITokenNode get_String();
    public abstract virtual ITokenNode get_TagEnd();
    public abstract virtual ITokenNode get_TagStart();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IInactivePreprocessorBranch {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IIndexExpression {
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public IPrimaryExpression Expression { get; }
    public IIndexExpressionReference Reference { get; }
    public abstract virtual IConditionalAccessSign get_ConditionalAccessSign();
    public abstract virtual IPrimaryExpression get_Expression();
    public abstract virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public abstract virtual IPrimaryExpression SetExpression(IPrimaryExpression param);
    public abstract virtual IIndexExpressionReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IIndexExpressionReference {
    public abstract virtual IndexExpressionKind GetKind(IResolveContext resolveContext);
    public abstract virtual IIndexExpression GetTreeNode();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IInstanceExpression {
    public ITokenNode Instance { get; }
    public InstanceExpressionKind Kind { get; }
    public abstract virtual ITokenNode get_Instance();
    public abstract virtual IDeclaredType GetInstanceType();
    public abstract virtual InstanceExpressionKind get_Kind();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IIntegerDivisionExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IInterfaceDeclaration {
    public ITokenNode EndInterface { get; }
    public TreeNodeCollection`1<IInterfaceInheritsClause> InheritsClauses { get; }
    public TreeNodeEnumerable`1<IInterfaceInheritsClause> InheritsClausesEnumerable { get; }
    public ITokenNode InterfaceKeyword { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> InheritsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> InheritsTypesEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> TypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public ITypeElement DeclaredElement { get; }
    public abstract virtual ITokenNode get_EndInterface();
    public abstract virtual TreeNodeCollection`1<IInterfaceInheritsClause> get_InheritsClauses();
    public abstract virtual TreeNodeEnumerable`1<IInterfaceInheritsClause> get_InheritsClausesEnumerable();
    public abstract virtual ITokenNode get_InterfaceKeyword();
    public abstract virtual ITypeParameterOfTypeList get_TypeParameterList();
    public abstract virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_InheritsTypes();
    public abstract virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_InheritsTypesEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBTreeNode> get_TypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBTreeNode> get_TypeDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public abstract virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public abstract virtual void AddInheritsType(IDeclaredType implementsType);
    public abstract virtual void RemoveInheritsType(IDeclaredType implementsType);
    public abstract virtual ITypeElement get_DeclaredElement();
    public abstract virtual IInterfaceInheritsClause AddInheritsClauseBefore(IInterfaceInheritsClause param, IInterfaceInheritsClause anchor);
    public abstract virtual IInterfaceInheritsClause AddInheritsClauseAfter(IInterfaceInheritsClause param, IInterfaceInheritsClause anchor);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IInterfaceInheritsClause {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode InheritsKeyword { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> InheritsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> InheritsTypesEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_InheritsKeyword();
    public abstract virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_InheritsTypes();
    public abstract virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_InheritsTypesEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IInterfaceMemberSpecifier {
    public ITokenNode Dot { get; }
    public IReferenceName InterfaceQualification { get; }
    public IVBIdentifier MemberName { get; }
    [NotNullAttribute]
public IReference Reference { get; }
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual IReferenceName get_InterfaceQualification();
    public abstract virtual IVBIdentifier get_MemberName();
    public abstract virtual IReferenceName SetInterfaceQualification(IReferenceName param);
    public abstract virtual IVBIdentifier SetMemberName(IVBIdentifier param);
    public abstract virtual IReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IInterpolatedStringExpression {
    public TreeNodeCollection`1<IInterpolatedStringInsert> Inserts { get; }
    public TreeNodeEnumerable`1<IInterpolatedStringInsert> InsertsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Literals { get; }
    public TreeNodeEnumerable`1<ITokenNode> LiteralsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IInterpolatedStringInsert> get_Inserts();
    public abstract virtual TreeNodeEnumerable`1<IInterpolatedStringInsert> get_InsertsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Literals();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_LiteralsEnumerable();
    public abstract virtual bool IsDefaultInterpolation();
    public abstract virtual bool IsDefaultInterpolation(IResolveContext resolveContext);
    [NotNullAttribute]
public abstract virtual IType GetInterpolationType();
    [NotNullAttribute]
public abstract virtual IType GetInterpolationType(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IInterpolatedStringInsert {
    public ITokenNode Alignment { get; }
    public ITokenNode Comma { get; }
    public IVBExpression Expression { get; }
    public ITokenNode FormatSpecifier { get; }
    public abstract virtual ITokenNode get_Alignment();
    public abstract virtual ITokenNode get_Comma();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_FormatSpecifier();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IIntoOfAggregateQueryOperator {
    public IAggregatedRangeVariableDeclarationList AggregatedRangeVariableDeclarationList { get; }
    public ITokenNode IntoKeyword { get; }
    public TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> Variables { get; }
    public TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> VariablesEnumerable { get; }
    public bool HasSignleInto { get; }
    public bool IsStandalone { get; }
    [CanBeNullAttribute]
public IQueryReference SelectReference { get; }
    public abstract virtual IAggregatedRangeVariableDeclarationList get_AggregatedRangeVariableDeclarationList();
    public abstract virtual ITokenNode get_IntoKeyword();
    public abstract virtual TreeNodeCollection`1<IAggregatedRangeVariableDeclaration> get_Variables();
    public abstract virtual TreeNodeEnumerable`1<IAggregatedRangeVariableDeclaration> get_VariablesEnumerable();
    public abstract virtual IAggregatedRangeVariableDeclarationList SetAggregatedRangeVariableDeclarationList(IAggregatedRangeVariableDeclarationList param);
    public abstract virtual bool get_HasSignleInto();
    public abstract virtual bool get_IsStandalone();
    public abstract virtual IQueryReference get_SelectReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IInvocationStatement {
    public ITokenNode CallKeyword { get; }
    public IVBExpression Expression { get; }
    public abstract virtual ITokenNode get_CallKeyword();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IIsExpression {
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public abstract virtual IVBExpression get_LeftExpr();
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IVBExpression get_RightExpr();
    public abstract virtual IVBExpression SetLeftExpr(IVBExpression param);
    public abstract virtual IVBExpression SetRightExpr(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IIsNotExpression {
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public abstract virtual IVBExpression get_LeftExpr();
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IVBExpression get_RightExpr();
    public abstract virtual IVBExpression SetLeftExpr(IVBExpression param);
    public abstract virtual IVBExpression SetRightExpr(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IJoinCollectionRangeVariableDeclaration {
    public IVBExpression Value { get; }
    public PsiLanguageType Language { get; }
    public IQueryRangeVariable DeclaredElement { get; }
    public abstract virtual IVBExpression get_Value();
    public abstract virtual IVBExpression SetValue(IVBExpression param);
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual bool IsValid();
    public abstract virtual XmlNode GetXMLDoc(bool inherit);
    public abstract virtual bool IsSynthetic();
    public abstract virtual IQueryRangeVariable get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IJoinCondition {
    public ITokenNode EqualsKeyword { get; }
    public IQueryParameterPlatform LeftExpression { get; }
    public IQueryParameterPlatform RightExpression { get; }
    public abstract virtual ITokenNode get_EqualsKeyword();
    public abstract virtual IQueryParameterPlatform get_LeftExpression();
    public abstract virtual IQueryParameterPlatform get_RightExpression();
    public abstract virtual IQueryParameterPlatform SetLeftExpression(IQueryParameterPlatform param);
    public abstract virtual IQueryParameterPlatform SetRightExpression(IQueryParameterPlatform param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IJoinQueryConditionsListFake {
    public TreeNodeCollection`1<ITokenNode> EqualsKeyword { get; }
    public TreeNodeEnumerable`1<ITokenNode> EqualsKeywordEnumerable { get; }
    public TreeNodeCollection`1<IVBExpression> Expression { get; }
    public TreeNodeEnumerable`1<IVBExpression> ExpressionEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_EqualsKeyword();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_EqualsKeywordEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBExpression> get_Expression();
    public abstract virtual TreeNodeEnumerable`1<IVBExpression> get_ExpressionEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IJoinQueryOperator {
    public IQueryConditionsList ConditionsList { get; }
    public IJoinCollectionRangeVariableDeclaration Declaration { get; }
    public ITokenNode JoinKeyword { get; }
    public IJoinQueryOperator NestedJoinQueryOperator { get; }
    public ITokenNode OnKeyword { get; }
    public TreeNodeCollection`1<IJoinCondition> Conditions { get; }
    public TreeNodeEnumerable`1<IJoinCondition> ConditionsEnumerable { get; }
    public IQueryReference JoinReference { get; }
    public abstract virtual IQueryConditionsList get_ConditionsList();
    public abstract virtual IJoinCollectionRangeVariableDeclaration get_Declaration();
    public abstract virtual ITokenNode get_JoinKeyword();
    public abstract virtual IJoinQueryOperator get_NestedJoinQueryOperator();
    public abstract virtual ITokenNode get_OnKeyword();
    public abstract virtual TreeNodeCollection`1<IJoinCondition> get_Conditions();
    public abstract virtual TreeNodeEnumerable`1<IJoinCondition> get_ConditionsEnumerable();
    public abstract virtual IQueryConditionsList SetConditionsList(IQueryConditionsList param);
    public abstract virtual IJoinCollectionRangeVariableDeclaration SetDeclaration(IJoinCollectionRangeVariableDeclaration param);
    public abstract virtual IJoinQueryOperator SetNestedJoinQueryOperator(IJoinQueryOperator param);
    public abstract virtual IQueryReference get_JoinReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILabelDeclaration {
    public ILabelName LabelName { get; }
    public ILabel DeclaredElement { get; }
    public abstract virtual ILabelName get_LabelName();
    public abstract virtual ILabelName SetLabelName(ILabelName param);
    public abstract virtual ILabel get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILabelName {
    public IVBTreeNode Name { get; }
    public abstract virtual IVBTreeNode get_Name();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILabelReferencingStatement {
    public ILabelName LabelName { get; }
    [CanBeNullAttribute]
public string Label { get; }
    [CanBeNullAttribute]
public IReference Reference { get; }
    public abstract virtual ILabelName get_LabelName();
    public abstract virtual ILabelName SetLabelName(ILabelName param);
    public abstract virtual string get_Label();
    public abstract virtual IReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILabelStatement {
    public ILabelDeclaration Declaration { get; }
    public abstract virtual ILabelDeclaration get_Declaration();
    public abstract virtual ILabelDeclaration SetDeclaration(ILabelDeclaration param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILambdaExpression {
    public ITokenNode AsyncKeyword { get; }
    public IBlock Block { get; }
    public ITokenNode IteratorKeyword { get; }
    public ILambdaSignature Signature { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<ILambdaParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILambdaParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public IType ReturnType { get; }
    public bool HasImplicitlyTypedParameters { get; }
    public bool IsMultiline { get; }
    public bool IsIterator { get; }
    public bool IsAsynchronous { get; }
    public ITokenNode StartDeclaration { get; }
    public ITokenNode EndDeclaration { get; }
    public abstract virtual ITokenNode get_AsyncKeyword();
    public abstract virtual IBlock get_Block();
    public abstract virtual ITokenNode get_IteratorKeyword();
    public abstract virtual ILambdaSignature get_Signature();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual TreeNodeCollection`1<ILambdaParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILambdaParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public abstract virtual IBlock SetBlock(IBlock param);
    public abstract virtual ILambdaSignature SetSignature(ILambdaSignature param);
    public abstract virtual IType get_ReturnType();
    public abstract virtual IType GetReturnType(IResolveContext resolveContext);
    public abstract virtual bool get_HasImplicitlyTypedParameters();
    public abstract virtual bool get_IsMultiline();
    public abstract virtual bool get_IsIterator();
    public abstract virtual bool get_IsAsynchronous();
    public abstract virtual void SetIterator(bool value);
    public abstract virtual void SetAsync(bool value);
    public abstract virtual ILambdaParameterDeclaration AddParameterDeclarationBefore(ILambdaParameterDeclaration param, ILambdaParameterDeclaration anchor);
    public abstract virtual ILambdaParameterDeclaration AddParameterDeclarationAfter(ILambdaParameterDeclaration param, ILambdaParameterDeclaration anchor);
    public abstract virtual void RemoveParameterDeclaration(ILambdaParameterDeclaration param);
    public abstract virtual ITokenNode get_StartDeclaration();
    public abstract virtual ITokenNode get_EndDeclaration();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILambdaFunctionExpression {
    public ITokenNode AsKeyword { get; }
    public ITokenNode EndFunction { get; }
    public IVBExpression Expression { get; }
    public ITokenNode FunctionKeyword { get; }
    public ITypeUsage ReturnTypeUsage { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual ITokenNode get_EndFunction();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_FunctionKeyword();
    public abstract virtual ITypeUsage get_ReturnTypeUsage();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual ITypeUsage SetReturnTypeUsage(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILambdaParameterDeclaration {
    public ILambdaParameter DeclaredElement { get; }
    public bool IsExplicitlyTyped { get; }
    public bool IsImplicitlyTyped { get; }
    public abstract virtual ILambdaParameter get_DeclaredElement();
    public abstract virtual bool get_IsExplicitlyTyped();
    public abstract virtual bool get_IsImplicitlyTyped();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILambdaSignature {
    public TreeNodeCollection`1<ILambdaParameterDeclaration> LambdaParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ILambdaParameterDeclaration> LambdaParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ILambdaParameterDeclaration> get_LambdaParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ILambdaParameterDeclaration> get_LambdaParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILambdaSubExpression {
    public ITokenNode EndSub { get; }
    public IVBStatement Statement { get; }
    public ITokenNode SubKeyword { get; }
    public abstract virtual ITokenNode get_EndSub();
    public abstract virtual IVBStatement get_Statement();
    public abstract virtual ITokenNode get_SubKeyword();
    public abstract virtual IVBStatement SetStatement(IVBStatement param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILetQueryOperator {
    public IExpressionRangeVariableDeclarationList DeclarationList { get; }
    public ITokenNode LetKeyword { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public abstract virtual IExpressionRangeVariableDeclarationList get_DeclarationList();
    public abstract virtual ITokenNode get_LetKeyword();
    public abstract virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_VariableDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_VariableDeclarationsEnumerable();
    public abstract virtual IExpressionRangeVariableDeclarationList SetDeclarationList(IExpressionRangeVariableDeclarationList param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILibraryClause {
    public ITokenNode LibKeyword { get; }
    public ITokenNode LibName { get; }
    public abstract virtual ITokenNode get_LibKeyword();
    public abstract virtual ITokenNode get_LibName();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILikeExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILineIfStatement {
    public ILineIfStatementBody ElseBranch { get; }
    public TreeNodeCollection`1<ILineIfStatementBody> ElseIfBranch { get; }
    public TreeNodeEnumerable`1<ILineIfStatementBody> ElseIfBranchEnumerable { get; }
    public TreeNodeCollection`1<IVBExpression> ElseIfExpression { get; }
    public TreeNodeEnumerable`1<IVBExpression> ElseIfExpressionEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> ElseIfKeyword { get; }
    public TreeNodeEnumerable`1<ITokenNode> ElseIfKeywordEnumerable { get; }
    public ITokenNode ElseKeyword { get; }
    public IVBExpression Expression { get; }
    public ILineIfStatementBody IfBranch { get; }
    public ITokenNode IfKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> ThenKeyword { get; }
    public TreeNodeEnumerable`1<ITokenNode> ThenKeywordEnumerable { get; }
    public abstract virtual ILineIfStatementBody get_ElseBranch();
    public abstract virtual TreeNodeCollection`1<ILineIfStatementBody> get_ElseIfBranch();
    public abstract virtual TreeNodeEnumerable`1<ILineIfStatementBody> get_ElseIfBranchEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBExpression> get_ElseIfExpression();
    public abstract virtual TreeNodeEnumerable`1<IVBExpression> get_ElseIfExpressionEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_ElseIfKeyword();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ElseIfKeywordEnumerable();
    public abstract virtual ITokenNode get_ElseKeyword();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ILineIfStatementBody get_IfBranch();
    public abstract virtual ITokenNode get_IfKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_ThenKeyword();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ThenKeywordEnumerable();
    public abstract virtual ILineIfStatementBody SetElseBranch(ILineIfStatementBody param);
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual ILineIfStatementBody SetIfBranch(ILineIfStatementBody param);
    public abstract virtual IList`1<IVBStatement> GetElseIfStatements(IVBExpression elseIfCondition);
    public abstract virtual TreeNodeCollection`1<IVBStatement> GetIfStatements();
    public abstract virtual TreeNodeCollection`1<IVBStatement> GetElseStatements();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILineIfStatementBody {
    public TreeNodeCollection`1<ITokenNode> Colons { get; }
    public TreeNodeEnumerable`1<ITokenNode> ColonsEnumerable { get; }
    public TreeNodeCollection`1<IVBStatement> Statements { get; }
    public TreeNodeEnumerable`1<IVBStatement> StatementsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Colons();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ColonsEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBStatement> get_Statements();
    public abstract virtual TreeNodeEnumerable`1<IVBStatement> get_StatementsEnumerable();
    public abstract virtual void RemoveStatement(IVBStatement statement);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILocalDeclarationList {
    public ITokenNode AsKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public TreeNodeCollection`1<ILocalVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<ILocalVariableDeclaration> DeclarationsEnumerable { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public ITypeUsage TypeUsage { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual IObjectCreationExpression get_CreationExpression();
    public abstract virtual TreeNodeCollection`1<ILocalVariableDeclaration> get_Declarations();
    public abstract virtual TreeNodeEnumerable`1<ILocalVariableDeclaration> get_DeclarationsEnumerable();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILocalDeclarationStatement {
    public IAttributeList AttributeList { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ILocalDeclarationList> DeclarationLists { get; }
    public TreeNodeEnumerable`1<ILocalDeclarationList> DeclarationListsEnumerable { get; }
    public ITokenNode Keyword { get; }
    public IList`1<ILocalVariableDeclaration> VariableDeclarations { get; }
    public LocalDeclarationKind Kind { get; }
    public abstract virtual IAttributeList get_AttributeList();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ILocalDeclarationList> get_DeclarationLists();
    public abstract virtual TreeNodeEnumerable`1<ILocalDeclarationList> get_DeclarationListsEnumerable();
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual IAttributeList SetAttributeList(IAttributeList param);
    public abstract virtual IList`1<ILocalVariableDeclaration> get_VariableDeclarations();
    public abstract virtual LocalDeclarationKind get_Kind();
    public abstract virtual void RemoveVariableDeclaration(ILocalVariableDeclaration declaration);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILocalVariableDeclaration {
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode NullableMark { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public ILocalDeclarationList DeclarationsList { get; }
    public IVBExpression Initializer { get; }
    public bool IsImplicitlyTyped { get; }
    public IVBLocalVariable DeclaredElement { get; }
    public abstract virtual IArrayModifiersList get_ArrayModifiersList();
    public abstract virtual ITokenNode get_NullableMark();
    public abstract virtual IObjectCreationExpression get_CreationExpression();
    public abstract virtual ILocalDeclarationList get_DeclarationsList();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public abstract virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
    public abstract virtual bool get_IsImplicitlyTyped();
    public abstract virtual IVBLocalVariable get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILogicalAndExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILogicalNotExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILogicalOrExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILogicalXorExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILoopControlVariableDeclaration {
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode AsKeyword { get; }
    public ITokenNode NullableMark { get; }
    public abstract virtual IArrayModifiersList get_ArrayModifiersList();
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual ITokenNode get_NullableMark();
    public abstract virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ILoopStatement {
    public IBlock Block { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual IBlock SetBlock(IBlock param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IMemberAccessExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IMemberInitializer {
    public ITokenNode Dot { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public IVBIdentifier Name { get; }
    public IReference Reference { get; }
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual IReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IMethodDeclaration {
    public IHandlesClause HandlesClause { get; }
    public IImplementsClause ImplementsClause { get; }
    public IMethod MethodElement { get; }
    public bool IsExtensionMethodPossible { get; }
    public bool IsPartial { get; }
    public bool IsAsynchronous { get; }
    public bool IsIterator { get; }
    public IAttributeList AttributeList { get; }
    public IModifiersList ModifiersList { get; }
    public abstract virtual IHandlesClause get_HandlesClause();
    public abstract virtual IImplementsClause get_ImplementsClause();
    public abstract virtual IHandlesClause SetHandlesClause(IHandlesClause param);
    public abstract virtual IImplementsClause SetImplementsClause(IImplementsClause param);
    public abstract virtual IMethod get_MethodElement();
    public abstract virtual bool get_IsExtensionMethodPossible();
    public abstract virtual bool get_IsPartial();
    public abstract virtual bool get_IsAsynchronous();
    public abstract virtual bool get_IsIterator();
    public abstract virtual ITypeParameterOfMethodDeclaration AddTypeParameterBefore(ITypeParameterOfMethodDeclaration param, ITypeParameterOfMethodDeclaration anchor);
    public abstract virtual void RemoveTypeParameter(ITypeParameterOfMethodDeclaration param);
    public abstract virtual void SetPartial(bool value);
    public abstract virtual void SetAsync(bool value);
    public abstract virtual void SetIterator(bool value);
    public abstract virtual IAttributeList get_AttributeList();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IMethodDeclarationBase {
    public ITokenNode AsKeyword { get; }
    public ITokenNode FunctionKeyword { get; }
    public IVBIdentifier Name { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage ReturnTypeUsage { get; }
    public ITokenNode SubKeyword { get; }
    public ITypeParameterOfMethodList TypeParameterList { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public IMethod MethodElement { get; }
    public MethodDeclarationKind Kind { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public IModifiersList ModifiersList { get; }
    public IAttributeList AttributeList { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual ITokenNode get_FunctionKeyword();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IReturnAttributeList get_ReturnAttributeList();
    public abstract virtual ITypeUsage get_ReturnTypeUsage();
    public abstract virtual ITokenNode get_SubKeyword();
    public abstract virtual ITypeParameterOfMethodList get_TypeParameterList();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public abstract virtual ITypeUsage SetReturnTypeUsage(ITypeUsage param);
    public abstract virtual ITypeParameterOfMethodList SetTypeParameterList(ITypeParameterOfMethodList param);
    public abstract virtual IMethod get_MethodElement();
    public abstract virtual MethodDeclarationKind get_Kind();
    public abstract virtual IAttribute AddAttribute(IAttribute attribute);
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IAttributeList get_AttributeList();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IMidAssignmentStatement {
    public ITokenNode Eq { get; }
    public ITokenNode MidKeyword { get; }
    public IVBExpression RValue { get; }
    public ITokenNode TypeChar { get; }
    public abstract virtual ITokenNode get_Eq();
    public abstract virtual ITokenNode get_MidKeyword();
    public abstract virtual IVBExpression get_RValue();
    public abstract virtual ITokenNode get_TypeChar();
    public abstract virtual IVBExpression SetRValue(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IModifiersList {
    public TreeNodeCollection`1<ITokenNode> Modifiers { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifiersEnumerable { get; }
    public AccessRights AccessRightsModifiers { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Modifiers();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ModifiersEnumerable();
    public abstract virtual bool HasModifier(TokenNodeType tType);
    public abstract virtual AccessRights get_AccessRightsModifiers();
    public abstract virtual void AddModifier(ITokenNode modifierNode);
    public abstract virtual void RemoveModifier(ITokenNode modifierNode);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IModifiersListOwner {
    public IModifiersList ModifiersList { get; }
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IModuleDeclaration {
    public ITokenNode EndModule { get; }
    public ITokenNode ModuleKeyword { get; }
    public TreeNodeCollection`1<IVBTreeNode> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> NestedTypeDeclarationsEnumerable { get; }
    public abstract virtual ITokenNode get_EndModule();
    public abstract virtual ITokenNode get_ModuleKeyword();
    public abstract virtual TreeNodeCollection`1<IVBTreeNode> get_NestedTypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBTreeNode> get_NestedTypeDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IModulusExpression {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ImplementsClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IImplementsClause GetByMemberSpecifier(IInterfaceMemberSpecifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ImportAliasClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IImportAliasClause GetByAlias(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IImportAliasClause GetByImportedSymbol(IReferenceName param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ImportClauseNavigator : object {
    [CanBeNullAttribute]
public static IImportClause GetByImportedSymbol(IReferenceName param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ImportDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IImportDirective GetByImportClause(IImportClause param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ImportDirectivesSectionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IImportDirectivesSection GetByImportDirective(IImportDirective param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ImportNamespaceClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IImportNamespaceClause GetByImportedNamespaceReferenceName(IReferenceName param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ImportXMLNamespaceClauseNavigator : object {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IMultipleConstantDeclaration {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ConstKeyword { get; }
    public TreeNodeCollection`1<IConstantDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IConstantDeclaration> DeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_ConstKeyword();
    public abstract virtual TreeNodeCollection`1<IConstantDeclaration> get_Declarations();
    public abstract virtual TreeNodeEnumerable`1<IConstantDeclaration> get_DeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IMultipleVariableDeclaration {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IVariableDeclarationList> DeclarationLists { get; }
    public TreeNodeEnumerable`1<IVariableDeclarationList> DeclarationListsEnumerable { get; }
    public IList`1<IVariableDeclaration> VariableDeclarations { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IVariableDeclarationList> get_DeclarationLists();
    public abstract virtual TreeNodeEnumerable`1<IVariableDeclarationList> get_DeclarationListsEnumerable();
    public abstract virtual IList`1<IVariableDeclaration> get_VariableDeclarations();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IMultiplicativeExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.INamedArgument {
    public ITokenNode ColonSign { get; }
    public ITokenNode EqSign { get; }
    public IVBIdentifier Name { get; }
    [CanBeNullAttribute]
public IReference Reference { get; }
    public string ParameterName { get; }
    public abstract virtual ITokenNode get_ColonSign();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual IReference get_Reference();
    public abstract virtual string get_ParameterName();
    public abstract virtual void SetName(string name);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.INamespaceMemberDeclaration {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.INamespacePrefixExpression {
    public ITokenNode Name { get; }
    public IReference Reference { get; }
    public abstract virtual ITokenNode get_Name();
    public abstract virtual IReference get_Reference();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.IndexExpressionExtentions : object {
    [ExtensionAttribute]
public static bool IsConstructorReference(IIndexExpression indexExpression);
    [ExtensionAttribute]
public static bool IsNameOfOperator(IIndexExpression indexExpression);
    [ExtensionAttribute]
public static bool IsWithEventsInvocation(IIndexExpression indexExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
public static IReferenceExpression InvokedReferenceExpression(IIndexExpression indexExpression);
    [ExtensionAttribute]
public static IReferenceExpressionReference InvokedReferenceExpressionReference(IIndexExpression indexExpression);
    [ExtensionAttribute]
public static IndexExpressionKind GetKind(IIndexExpressionReference reference);
    [CanBeNullAttribute]
public static IVBExpression GetInvocationExpression(IReference reference);
    [CanBeNullAttribute]
public static IVBExpression GetInvocationExpression(IReferenceExpression element);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.IndexExpressionKind : Enum {
    public int value__;
    public static IndexExpressionKind ConstructorInvocation;
    public static IndexExpressionKind MethodInvocation;
    public static IndexExpressionKind DelegateInvocation;
    public static IndexExpressionKind DefaultPropertyInvocation;
    public static IndexExpressionKind ArrayIndexerInvocation;
    public static IndexExpressionKind NameOfOperator;
    public static IndexExpressionKind LateBound;
    public static IndexExpressionKind ResolveFailure;
    public static IndexExpressionKind WithEventsInvocation;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.IndexExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexExpression GetByArgument(IVBArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexExpression GetByArgumentList(IArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexExpression GetByConditionalAccessSign(IConditionalAccessSign param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIndexExpression GetByExpression(IPrimaryExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.INewExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.INextClause {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IVBExpression> NextExpressions { get; }
    public TreeNodeEnumerable`1<IVBExpression> NextExpressionsEnumerable { get; }
    public ITokenNode NextKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBExpression> get_NextExpressions();
    public abstract virtual TreeNodeEnumerable`1<IVBExpression> get_NextExpressionsEnumerable();
    public abstract virtual ITokenNode get_NextKeyword();
    public abstract virtual ILoopStatement FindOutermostClosedForLoop();
}
public static class JetBrains.ReSharper.Psi.VB.Tree.InitializerOwnerDeclarationNavigator : object {
    [ContractAnnotationAttribute("null => null")]
[CanBeNullAttribute]
[PureAttribute]
public static IInitializerOwnerDeclaration ByInitializer(IVBExpression initializer);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.InstanceExpressionKind : Enum {
    public int value__;
    public static InstanceExpressionKind UNKNOWN;
    public static InstanceExpressionKind ME;
    public static InstanceExpressionKind MYCLASS;
    public static InstanceExpressionKind MYBASE;
}
public static class JetBrains.ReSharper.Psi.VB.Tree.InstanceExpressionNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.IntegerDivisionExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIntegerDivisionExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIntegerDivisionExpression GetByRightExpr(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.InterfaceDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByConversionOperatorDeclaration(IConversionOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByInheritsClause(IInterfaceInheritsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByInheritsType(IDeclaredTypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetBySignOperatorDeclaration(ISignOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByTypeParameterDeclaration(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceDeclaration GetByVariableDeclaration(IVariableDeclaration param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.InterfaceInheritsClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceInheritsClause GetByInheritsType(IDeclaredTypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.InterfaceMemberSpecifierNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceMemberSpecifier GetByInterfaceQualification(IReferenceName param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterfaceMemberSpecifier GetByMemberName(IVBIdentifier param);
    public static IVBTypeMemberDeclaration GetContainingDeclaration(IInterfaceMemberSpecifier memberSpecifier);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.InterpolatedStringExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterpolatedStringExpression GetByInsert(IInterpolatedStringInsert param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.InterpolatedStringInsertNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterpolatedStringInsert GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.IntoOfAggregateQueryOperatorNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIntoOfAggregateQueryOperator GetByAggregatedRangeVariableDeclarationList(IAggregatedRangeVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIntoOfAggregateQueryOperator GetByVariable(IAggregatedRangeVariableDeclaration param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.InvocationStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInvocationStatement GetByExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IObjectCollectionInitializer {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode FromKeyword { get; }
    public TreeNodeCollection`1<ICollectionElementInitializer> Initializer { get; }
    public TreeNodeEnumerable`1<ICollectionElementInitializer> InitializerEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_FromKeyword();
    public abstract virtual TreeNodeCollection`1<ICollectionElementInitializer> get_Initializer();
    public abstract virtual TreeNodeEnumerable`1<ICollectionElementInitializer> get_InitializerEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IObjectCreationExpression {
    public IObjectCollectionInitializer CollectionInitializer { get; }
    public ITokenNode NewKeyword { get; }
    public ITokenNode NullableMark { get; }
    public IObjectCreationInitializer ObjectInitializer { get; }
    public IDeclaredTypeUsage TypeUsage { get; }
    public IReference ConstructorReference { get; }
    [CanBeNullAttribute]
public IReference TypeReference { get; }
    public abstract virtual IObjectCollectionInitializer get_CollectionInitializer();
    public abstract virtual ITokenNode get_NewKeyword();
    public abstract virtual ITokenNode get_NullableMark();
    public abstract virtual IObjectCreationInitializer get_ObjectInitializer();
    public abstract virtual IDeclaredTypeUsage get_TypeUsage();
    public abstract virtual IObjectCollectionInitializer SetCollectionInitializer(IObjectCollectionInitializer param);
    public abstract virtual IObjectCreationInitializer SetObjectInitializer(IObjectCreationInitializer param);
    public abstract virtual IDeclaredTypeUsage SetTypeUsage(IDeclaredTypeUsage param);
    public abstract virtual IReference get_ConstructorReference();
    public abstract virtual IReference get_TypeReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IObjectCreationInitializer {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LBrace { get; }
    public TreeNodeCollection`1<IMemberInitializer> MemberInitializers { get; }
    public TreeNodeEnumerable`1<IMemberInitializer> MemberInitializersEnumerable { get; }
    public ITokenNode RBrace { get; }
    public ITokenNode WithKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual TreeNodeCollection`1<IMemberInitializer> get_MemberInitializers();
    public abstract virtual TreeNodeEnumerable`1<IMemberInitializer> get_MemberInitializersEnumerable();
    public abstract virtual ITokenNode get_RBrace();
    public abstract virtual ITokenNode get_WithKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IOnErrorSpecialLabel {
    public ITokenNode LiteralAfterMinus { get; }
    public ITokenNode Minus { get; }
    public abstract virtual ITokenNode get_LiteralAfterMinus();
    public abstract virtual ITokenNode get_Minus();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IOnErrorStatement {
    public ITokenNode ErrorKeyword { get; }
    public ITokenNode GotoKeyword { get; }
    public ITokenNode NextKeyword { get; }
    public ITokenNode OnKeyword { get; }
    public ITokenNode ResumeKeyword { get; }
    public IOnErrorSpecialLabel SpecialLabel { get; }
    public abstract virtual ITokenNode get_ErrorKeyword();
    public abstract virtual ITokenNode get_GotoKeyword();
    public abstract virtual ITokenNode get_NextKeyword();
    public abstract virtual ITokenNode get_OnKeyword();
    public abstract virtual ITokenNode get_ResumeKeyword();
    public abstract virtual IOnErrorSpecialLabel get_SpecialLabel();
    public abstract virtual IOnErrorSpecialLabel SetSpecialLabel(IOnErrorSpecialLabel param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IOperatorDeclaration {
    public ITokenNode AsKeyword { get; }
    public ITokenNode OperatorKeyword { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage ReturnType { get; }
    public IOperator DeclaredElement { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public IAttributeList AttributeList { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual ITokenNode get_OperatorKeyword();
    public abstract virtual IReturnAttributeList get_ReturnAttributeList();
    public abstract virtual ITypeUsage get_ReturnType();
    public abstract virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public abstract virtual ITypeUsage SetReturnType(ITypeUsage param);
    public abstract virtual IOperator get_DeclaredElement();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual IAttributeList get_AttributeList();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IOptionStatement {
    public IVBIdentifier Name { get; }
    public ITokenNode OptionKeyword { get; }
    public IVBIdentifier Value { get; }
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITokenNode get_OptionKeyword();
    public abstract virtual IVBIdentifier get_Value();
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual IVBIdentifier SetValue(IVBIdentifier param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IOptionStatementsSection {
    public TreeNodeCollection`1<IOptionStatement> OptionStatements { get; }
    public TreeNodeEnumerable`1<IOptionStatement> OptionStatementsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IOptionStatement> get_OptionStatements();
    public abstract virtual TreeNodeEnumerable`1<IOptionStatement> get_OptionStatementsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IOrderByQueryOperator {
    public ITokenNode ByKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IOrderExpression> OrderExpressions { get; }
    public TreeNodeEnumerable`1<IOrderExpression> OrderExpressionsEnumerable { get; }
    public ITokenNode OrderKeyword { get; }
    public abstract virtual ITokenNode get_ByKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IOrderExpression> get_OrderExpressions();
    public abstract virtual TreeNodeEnumerable`1<IOrderExpression> get_OrderExpressionsEnumerable();
    public abstract virtual ITokenNode get_OrderKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IOrderExpression {
    public ITokenNode AscendingKeyword { get; }
    public ITokenNode DescendingKeyword { get; }
    public IQueryParameterPlatform Expression { get; }
    public abstract virtual ITokenNode get_AscendingKeyword();
    public abstract virtual ITokenNode get_DescendingKeyword();
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IParenthesizedExpression {
    public IVBExpression Expression { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IPartitionQueryOperator {
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode SkipKeyword { get; }
    public ITokenNode TakeKeyword { get; }
    public ITokenNode WhileKeyword { get; }
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual ITokenNode get_SkipKeyword();
    public abstract virtual ITokenNode get_TakeKeyword();
    public abstract virtual ITokenNode get_WhileKeyword();
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public abstract virtual PartitionOperatorKinds GetKind();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IPositionalArgument {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IPreprocessorDirective {
    public ITokenNode Sharp { get; }
    public abstract virtual ITokenNode get_Sharp();
    public abstract virtual ConstantValue GetConstantValue(string name);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IPrimaryExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IPropertyDeclaration {
    public IObjectCreationExpression CreationExpression { get; }
    public ITokenNode EndProperty { get; }
    public IPropertyInitializer PropertyInitializer { get; }
    public ITokenNode PropertyKeyword { get; }
    public IReturnAttributeList ReturnAttributeList { get; }
    public ITypeUsage TypeUsage { get; }
    public IVBExpression Initializer { get; }
    public bool IsAuto { get; }
    public bool IsDefault { get; }
    public bool IsIterator { get; }
    public IProperty PropertyElement { get; }
    public IModifiersList ModifiersList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public IAttributeList AttributeList { get; }
    public abstract virtual IObjectCreationExpression get_CreationExpression();
    public abstract virtual ITokenNode get_EndProperty();
    public abstract virtual IPropertyInitializer get_PropertyInitializer();
    public abstract virtual ITokenNode get_PropertyKeyword();
    public abstract virtual IReturnAttributeList get_ReturnAttributeList();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
    public abstract virtual IPropertyInitializer SetPropertyInitializer(IPropertyInitializer param);
    public abstract virtual IReturnAttributeList SetReturnAttributeList(IReturnAttributeList param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual void SetIterator(bool value);
    public abstract virtual void SetDefault(bool value);
    public abstract virtual void AddRemoveBody(bool add);
    public abstract virtual bool get_IsAuto();
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool get_IsIterator();
    public abstract virtual IProperty get_PropertyElement();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual IAttributeList get_AttributeList();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IPropertyInitializer {
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQualifiedNamespaceName {
    public ITokenNode Dot { get; }
    public IVBIdentifier Name { get; }
    public IQualifiedNamespaceName Qualifier { get; }
    [CanBeNullAttribute]
public IReference Reference { get; }
    [NotNullAttribute]
public string DeclaredName { get; }
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IQualifiedNamespaceName get_Qualifier();
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual IQualifiedNamespaceName SetQualifier(IQualifiedNamespaceName param);
    public abstract virtual IReference get_Reference();
    public abstract virtual string get_DeclaredName();
    public abstract virtual IQualifiedNamespaceName ReplaceBy(IQualifiedNamespaceName node);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryAggregatedParameterPlatform {
    public IVBIdentifier Ident { get; }
    public ITokenNode LPar { get; }
    public IQueryParameterPlatform Platform { get; }
    public ITokenNode RPar { get; }
    public bool IsGroup { get; }
    [CanBeNullAttribute]
public string MethodName { get; }
    public abstract virtual IVBIdentifier get_Ident();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual IQueryParameterPlatform get_Platform();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IVBIdentifier SetIdent(IVBIdentifier param);
    public abstract virtual IQueryParameterPlatform SetPlatform(IQueryParameterPlatform param);
    public abstract virtual bool get_IsGroup();
    public abstract virtual string get_MethodName();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryCallsChainOwner {
    [CanBeNullAttribute]
public IQueryExpression QueryExpression { get; }
    public abstract virtual IQueryExpression get_QueryExpression();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryCollectionRangeVariableDeclaration {
    public IQueryParameterPlatform Expression { get; }
    public PsiLanguageType Language { get; }
    public IQueryRangeVariable DeclaredElement { get; }
    public IQueryReference SelectManyReference { get; }
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual bool IsValid();
    public abstract virtual XmlNode GetXMLDoc(bool inherit);
    public abstract virtual bool IsSynthetic();
    public abstract virtual IQueryRangeVariable get_DeclaredElement();
    public abstract virtual IQueryReference get_SelectManyReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryCollectionRangeVariableDeclarationList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> DeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IQueryCollectionRangeVariableDeclaration> get_Declarations();
    public abstract virtual TreeNodeEnumerable`1<IQueryCollectionRangeVariableDeclaration> get_DeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryConditionsList {
    public TreeNodeCollection`1<ITokenNode> AndKeywords { get; }
    public TreeNodeEnumerable`1<ITokenNode> AndKeywordsEnumerable { get; }
    public TreeNodeCollection`1<IJoinCondition> joinCondition { get; }
    public TreeNodeEnumerable`1<IJoinCondition> joinConditionEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_AndKeywords();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_AndKeywordsEnumerable();
    public abstract virtual TreeNodeCollection`1<IJoinCondition> get_joinCondition();
    public abstract virtual TreeNodeEnumerable`1<IJoinCondition> get_joinConditionEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryExpression {
    public IQueryOperator FirstQueryOperator { get; }
    public TreeNodeCollection`1<IQueryOperator> QueryOperators { get; }
    public TreeNodeEnumerable`1<IQueryOperator> QueryOperatorsEnumerable { get; }
    public abstract virtual IQueryOperator get_FirstQueryOperator();
    public abstract virtual TreeNodeCollection`1<IQueryOperator> get_QueryOperators();
    public abstract virtual TreeNodeEnumerable`1<IQueryOperator> get_QueryOperatorsEnumerable();
    public abstract virtual IQueryOperator SetFirstQueryOperator(IQueryOperator param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryOperator {
    public ITokenNode FirstKeyword { get; }
    public abstract virtual ITokenNode get_FirstKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryParameter {
    public IVBExpression Value { get; }
    public abstract virtual IVBExpression get_Value();
    public abstract virtual IVBExpression SetValue(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryParameterPlatform {
    public IVBExpression Value { get; }
    public abstract virtual IVBExpression get_Value();
    public abstract virtual IVBExpression SetValue(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryReference {
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IQueryReferenceOwner {
    [CanBeNullAttribute]
public abstract virtual IQueryReference GetQueryLastReference(IResolveContext resolveContext);
    public abstract virtual bool IsSelector();
}
internal interface JetBrains.ReSharper.Psi.VB.Tree.IQueryReferenceOwnerImpl {
    [CanBeNullAttribute]
public IQueryExpression QueryExpression { get; }
    public abstract virtual IQueryExpression get_QueryExpression();
    [CanBeNullAttribute]
public abstract virtual QueryChainTypeBase TransitChainType(QueryChainTypeBase qualifierChainType);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IRaiseEventStatement {
    public IPrimaryExpression Expression { get; }
    public ITokenNode RaiseEventKeyword { get; }
    public abstract virtual IPrimaryExpression get_Expression();
    public abstract virtual ITokenNode get_RaiseEventKeyword();
    public abstract virtual IPrimaryExpression SetExpression(IPrimaryExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IRedimClause {
    public IVBExpression Expression { get; }
    public IArrayModifier SizeModifier { get; }
    public TreeNodeCollection`1<IArrayBound> ArrayBounds { get; }
    public TreeNodeEnumerable`1<IArrayBound> ArrayBoundsEnumerable { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IArrayModifier get_SizeModifier();
    public abstract virtual TreeNodeCollection`1<IArrayBound> get_ArrayBounds();
    public abstract virtual TreeNodeEnumerable`1<IArrayBound> get_ArrayBoundsEnumerable();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual IArrayModifier SetSizeModifier(IArrayModifier param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IRedimStatement {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode PreserveKeyword { get; }
    public TreeNodeCollection`1<IRedimClause> RedimClauses { get; }
    public TreeNodeEnumerable`1<IRedimClause> RedimClausesEnumerable { get; }
    public ITokenNode RedimKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_PreserveKeyword();
    public abstract virtual TreeNodeCollection`1<IRedimClause> get_RedimClauses();
    public abstract virtual TreeNodeEnumerable`1<IRedimClause> get_RedimClausesEnumerable();
    public abstract virtual ITokenNode get_RedimKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IReferenceExpression {
    public IPrimaryExpression BaseExpression { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode Dot { get; }
    public IVBIdentifier NameIdentifier { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    [CanBeNullAttribute]
public IVBExpression QualifierExpression { get; }
    [NotNullAttribute]
public IReferenceExpressionReference Reference { get; }
    public IList`1<IType> TypeArguments { get; }
    public abstract virtual IPrimaryExpression get_BaseExpression();
    public abstract virtual IConditionalAccessSign get_ConditionalAccessSign();
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual IVBIdentifier get_NameIdentifier();
    public abstract virtual ITypeArgumentList get_TypeArgumentList();
    public abstract virtual IPrimaryExpression SetBaseExpression(IPrimaryExpression param);
    public abstract virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public abstract virtual IVBIdentifier SetNameIdentifier(IVBIdentifier param);
    public abstract virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public abstract virtual IVBExpression get_QualifierExpression();
    public abstract virtual IReferenceExpressionReference get_Reference();
    public abstract virtual IList`1<IType> get_TypeArguments();
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual bool IsValid();
    public abstract virtual void SetTypeArguments(ICollection`1<IType> typeArguments);
    public abstract virtual void SetQualifierExpression(QualifierUsage qualifierUsage);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IReferenceExpressionReference {
    public abstract virtual ResolveResultWithInfo ResolveAsUnqualified(ISymbolTable symbolTable);
    public abstract virtual ReferenceExpressionKind GetKind();
    public abstract virtual IReferenceExpression GetTreeNode();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IReferenceName {
    public ITokenNode Dot { get; }
    public IVBIdentifier NameIdentifier { get; }
    public ITypeArgumentList TypeArgumentList { get; }
    public IAttribute ContainingAttribute { get; }
    public IObjectCreationExpression ContainingCreationExpression { get; }
    public IReferenceName Qualifier { get; }
    [NotNullAttribute]
public IReferenceNameReference Reference { get; }
    public string ShortName { get; }
    public string QualifiedName { get; }
    public bool IsGlobalNamespacePrefix { get; }
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual IVBIdentifier get_NameIdentifier();
    public abstract virtual ITypeArgumentList get_TypeArgumentList();
    public abstract virtual IAttribute get_ContainingAttribute();
    public abstract virtual IObjectCreationExpression get_ContainingCreationExpression();
    public abstract virtual IReferenceName get_Qualifier();
    public abstract virtual IVBIdentifier SetNameIdentifier(IVBIdentifier param);
    public abstract virtual IReferenceName SetQualifier(IReferenceName param);
    public abstract virtual ITypeArgumentList SetTypeArgumentList(ITypeArgumentList param);
    public abstract virtual IReferenceNameReference get_Reference();
    public abstract virtual string get_ShortName();
    public abstract virtual string get_QualifiedName();
    public abstract virtual bool get_IsGlobalNamespacePrefix();
    public abstract virtual IReferenceName ReplaceBy(IReferenceName name);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IReferenceNameReference {
    public abstract virtual ResolveResultWithInfo ResolveAsUnqualified(ISymbolTable symbolTable);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IRegionPreprocessorDirective {
    public ITokenNode RegionName { get; }
    public ITokenNode RegionWord { get; }
    [NotNullAttribute]
public string RegionNameText { get; }
    [CanBeNullAttribute]
public IEndRegionPreprocessorDirective EndRegion { get; }
    public abstract virtual ITokenNode get_RegionName();
    public abstract virtual ITokenNode get_RegionWord();
    public abstract virtual string get_RegionNameText();
    public abstract virtual IEndRegionPreprocessorDirective get_EndRegion();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IRegularParameterDeclaration {
    public IVBExpression DefaultInitializer { get; }
    public ITokenNode EqSign { get; }
    public ParameterKind Kind { get; }
    public bool IsParameterArray { get; }
    public bool IsOptional { get; }
    public abstract virtual IVBExpression get_DefaultInitializer();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression SetDefaultInitializer(IVBExpression param);
    public abstract virtual ParameterKind get_Kind();
    public abstract virtual bool get_IsParameterArray();
    public abstract virtual bool get_IsOptional();
    public abstract virtual void SetKind(ParameterKind kind);
    public abstract virtual void SetType(IType type);
    public abstract virtual void SetParamArray(bool isParamArray);
    public abstract virtual IRegularParameterDeclaration ReplaceBy(IRegularParameterDeclaration declaration);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IRegularParameterList {
    public TreeNodeCollection`1<IRegularParameterDeclaration> RegularParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> RegularParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_RegularParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_RegularParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IRelationalExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IRemoveHandlerStatement {
    public ITokenNode Comma { get; }
    public IVBExpression EventExpression { get; }
    public IVBExpression HandlerExpression { get; }
    public ITokenNode RemoveHandlerKeyword { get; }
    public abstract virtual ITokenNode get_Comma();
    public abstract virtual IVBExpression get_EventExpression();
    public abstract virtual IVBExpression get_HandlerExpression();
    public abstract virtual ITokenNode get_RemoveHandlerKeyword();
    public abstract virtual IVBExpression SetEventExpression(IVBExpression param);
    public abstract virtual IVBExpression SetHandlerExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IResumeStatement {
    public ITokenNode NextKeyword { get; }
    public ITokenNode ResumeKeyword { get; }
    public abstract virtual ITokenNode get_NextKeyword();
    public abstract virtual ITokenNode get_ResumeKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IReturnAttributeList {
    public IAttributeList AttributeList { get; }
    public abstract virtual IAttributeList get_AttributeList();
    public abstract virtual IAttributeList SetAttributeList(IAttributeList param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IReturnStatement {
    public IVBExpression Expression { get; }
    public ITokenNode ReturnKeyword { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_ReturnKeyword();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ISelectQueryOperator {
    public IExpressionRangeVariableDeclarationList DeclarationList { get; }
    public ITokenNode SelectKeyword { get; }
    public TreeNodeCollection`1<IExpressionRangeVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> VariableDeclarationsEnumerable { get; }
    [CanBeNullAttribute]
public IQueryReference SelectReference { get; }
    public abstract virtual IExpressionRangeVariableDeclarationList get_DeclarationList();
    public abstract virtual ITokenNode get_SelectKeyword();
    public abstract virtual TreeNodeCollection`1<IExpressionRangeVariableDeclaration> get_VariableDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IExpressionRangeVariableDeclaration> get_VariableDeclarationsEnumerable();
    public abstract virtual IExpressionRangeVariableDeclarationList SetDeclarationList(IExpressionRangeVariableDeclarationList param);
    public abstract virtual bool HasReference();
    public abstract virtual IQueryReference get_SelectReference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ISelectStatement {
    public ITokenNode CaseKeyword { get; }
    public TreeNodeCollection`1<ICaseStatement> CaseStatements { get; }
    public TreeNodeEnumerable`1<ICaseStatement> CaseStatementsEnumerable { get; }
    public ITokenNode EndSelect { get; }
    public IVBExpression Expression { get; }
    public ITokenNode SelectKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public abstract virtual ITokenNode get_CaseKeyword();
    public abstract virtual TreeNodeCollection`1<ICaseStatement> get_CaseStatements();
    public abstract virtual TreeNodeEnumerable`1<ICaseStatement> get_CaseStatementsEnumerable();
    public abstract virtual ITokenNode get_EndSelect();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_SelectKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual ICaseStatement AddCaseStatement(ICaseStatement param, ICaseStatement anchor, bool before);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.IsExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIsExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIsExpression GetByRightExpr(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IShiftExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ISignOperatorDeclaration {
    public ITokenNode OpSign { get; }
    public abstract virtual ITokenNode get_OpSign();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.IsNotExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIsNotExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IIsNotExpression GetByRightExpr(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IStopStatement {
    public ITokenNode StopKeyword { get; }
    public abstract virtual ITokenNode get_StopKeyword();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IStructureDeclaration {
    public ITokenNode EndStructure { get; }
    public TreeNodeCollection`1<ITypeImplementsClause> ImplementsClauses { get; }
    public TreeNodeEnumerable`1<ITypeImplementsClause> ImplementsClausesEnumerable { get; }
    public ITokenNode StructureKeyword { get; }
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> ImplementsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> ImplementsTypesEnumerable { get; }
    public TreeNodeCollection`1<IVBTreeNode> NestedTypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTreeNode> NestedTypeDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public ITypeElement DeclaredElement { get; }
    public abstract virtual ITokenNode get_EndStructure();
    public abstract virtual TreeNodeCollection`1<ITypeImplementsClause> get_ImplementsClauses();
    public abstract virtual TreeNodeEnumerable`1<ITypeImplementsClause> get_ImplementsClausesEnumerable();
    public abstract virtual ITokenNode get_StructureKeyword();
    public abstract virtual ITypeParameterOfTypeList get_TypeParameterList();
    public abstract virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_ImplementsTypes();
    public abstract virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_ImplementsTypesEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBTreeNode> get_NestedTypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBTreeNode> get_NestedTypeDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
    public abstract virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList param);
    public abstract virtual void AddImplementsType(IDeclaredType implementsType);
    public abstract virtual void RemoveImplementsType(IDeclaredType implementsType);
    public abstract virtual ITypeImplementsClause AddImplementsClauseBefore(ITypeImplementsClause param, ITypeImplementsClause anchor);
    public abstract virtual ITypeImplementsClause AddImplementsClauseAfter(ITypeImplementsClause param, ITypeImplementsClause anchor);
    public abstract virtual ITypeElement get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ISyncLockStatement {
    public IBlock Block { get; }
    public ITokenNode EndSyncLock { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode SyncLockKeyword { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual ITokenNode get_EndSyncLock();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual ITokenNode get_SyncLockKeyword();
    public abstract virtual IBlock SetBlock(IBlock param);
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IThrowStatement {
    public IVBExpression Expression { get; }
    public ITokenNode ThrowKeyword { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_ThrowKeyword();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITryStatement {
    public TreeNodeCollection`1<ICatchStatement> CatchStatements { get; }
    public TreeNodeEnumerable`1<ICatchStatement> CatchStatementsEnumerable { get; }
    public ITokenNode EndTry { get; }
    public IFinallyStatement FinallyStatement { get; }
    public IBlock TryBlock { get; }
    public ITokenNode TryKeyword { get; }
    public abstract virtual TreeNodeCollection`1<ICatchStatement> get_CatchStatements();
    public abstract virtual TreeNodeEnumerable`1<ICatchStatement> get_CatchStatementsEnumerable();
    public abstract virtual ITokenNode get_EndTry();
    public abstract virtual IFinallyStatement get_FinallyStatement();
    public abstract virtual IBlock get_TryBlock();
    public abstract virtual ITokenNode get_TryKeyword();
    public abstract virtual IFinallyStatement SetFinallyStatement(IFinallyStatement param);
    public abstract virtual IBlock SetTryBlock(IBlock param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITupleComponent {
    public ITokenNode ColonSign { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Expression { get; }
    public IVBIdentifier Name { get; }
    [CanBeNullAttribute]
public string ExplicitOrInferredName { get; }
    public abstract virtual ITokenNode get_ColonSign();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual string get_ExplicitOrInferredName();
    [PureAttribute]
public abstract virtual int IndexOf();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITupleDeclaredTypeUsage {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITupleTypeComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleTypeComponent> ComponentsEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ITupleTypeComponent> get_Components();
    public abstract virtual TreeNodeEnumerable`1<ITupleTypeComponent> get_ComponentsEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITupleExpression {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITupleComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleComponent> ComponentsEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ITupleComponent> get_Components();
    public abstract virtual TreeNodeEnumerable`1<ITupleComponent> get_ComponentsEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITupleTypeComponent {
    public ITokenNode AsKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    [CanBeNullAttribute]
public string ExplicitName { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual string get_ExplicitName();
    public abstract virtual int IndexOf();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITupleTypeUsage {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITupleTypeComponent> Components { get; }
    public TreeNodeEnumerable`1<ITupleTypeComponent> ComponentsEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ITupleTypeComponent> get_Components();
    public abstract virtual TreeNodeEnumerable`1<ITupleTypeComponent> get_ComponentsEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeArgumentList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode OfKeyword { get; }
    public ITokenNode RPar { get; }
    public IList`1<ITypeUsage> TypeArguments { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_OfKeyword();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual IList`1<ITypeUsage> get_TypeArguments();
    public abstract virtual void SetTypeArguments(IType[] types);
    public abstract virtual void SetTypeArguments(ITypeUsage[] typeNodes);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeImplementsClause {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode ImplementsKeyword { get; }
    public TreeNodeCollection`1<IDeclaredTypeUsage> ImplementsTypes { get; }
    public TreeNodeEnumerable`1<IDeclaredTypeUsage> ImplementsTypesEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_ImplementsKeyword();
    public abstract virtual TreeNodeCollection`1<IDeclaredTypeUsage> get_ImplementsTypes();
    public abstract virtual TreeNodeEnumerable`1<IDeclaredTypeUsage> get_ImplementsTypesEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeMemberOwnerDeclaration {
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IVBTypeMemberDeclaration> MemberDeclarations { get; }
    public ITypeElement TypeElement { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBTypeMemberDeclaration> get_MemberDeclarations();
    public abstract virtual ITypeElement get_TypeElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeOfIsExpression {
    public IVBExpression Expression { get; }
    public ITokenNode IsOrIsNotKeyword { get; }
    public ITokenNode TypeOfKeyword { get; }
    public ITypeUsage TypeUsage { get; }
    public TypeOfExpressionKind Kind { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_IsOrIsNotKeyword();
    public abstract virtual ITokenNode get_TypeOfKeyword();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual TypeOfExpressionKind get_Kind();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterConstraint {
    public ITokenNode ClassKeyword { get; }
    public ITokenNode NewKeyword { get; }
    public ITokenNode StructureKeyword { get; }
    public IUserTypeUsage TypeUsage { get; }
    public abstract virtual ITokenNode get_ClassKeyword();
    public abstract virtual ITokenNode get_NewKeyword();
    public abstract virtual ITokenNode get_StructureKeyword();
    public abstract virtual IUserTypeUsage get_TypeUsage();
    public abstract virtual IUserTypeUsage SetTypeUsage(IUserTypeUsage param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterConstraintList {
    public ITokenNode AsKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> Constraint { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> ConstraintEnumerable { get; }
    public ITokenNode LBrace { get; }
    public ITokenNode RBrace { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_Constraint();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_ConstraintEnumerable();
    public abstract virtual ITokenNode get_LBrace();
    public abstract virtual ITokenNode get_RBrace();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterDeclaration {
    public ITypeParameterConstraintList ConstraintList { get; }
    public ITokenNode InKeyword { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode OutKeyword { get; }
    public TreeNodeCollection`1<ITypeParameterConstraint> Constraints { get; }
    public TreeNodeEnumerable`1<ITypeParameterConstraint> ConstraintsEnumerable { get; }
    public IList`1<IDeclaredType> DeclaredTypeConstraints { get; }
    public TypeParameterConstraintFlags ConstraintFlags { get; }
    public ITypeParameter DeclaredElement { get; }
    public abstract virtual ITypeParameterConstraintList get_ConstraintList();
    public abstract virtual ITokenNode get_InKeyword();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITokenNode get_OutKeyword();
    public abstract virtual TreeNodeCollection`1<ITypeParameterConstraint> get_Constraints();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterConstraint> get_ConstraintsEnumerable();
    public abstract virtual ITypeParameterConstraintList SetConstraintList(ITypeParameterConstraintList param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual IList`1<IDeclaredType> get_DeclaredTypeConstraints();
    public abstract virtual TypeParameterConstraintFlags get_ConstraintFlags();
    public abstract virtual ITypeParameter get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterOfMethodDeclaration {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterOfMethodList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode OfKeyword { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_OfKeyword();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfMethodDeclaration> get_TypeParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterOfTypeDeclaration {
    public TypeParameterVariance Variance { get; }
    public abstract virtual TypeParameterVariance get_Variance();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterOfTypeList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode OfKeyword { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarations { get; }
    public TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> TypeParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_OfKeyword();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<ITypeParameterOfTypeDeclaration> get_TypeParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeParameterOfTypeOwnerDeclaration {
    public ITypeParameterOfTypeList TypeParameterList { get; }
    public IList`1<ITypeParameterOfTypeDeclaration> TypeParameters { get; }
    public abstract virtual ITypeParameterOfTypeList get_TypeParameterList();
    public abstract virtual IList`1<ITypeParameterOfTypeDeclaration> get_TypeParameters();
    public abstract virtual ITypeParameterOfTypeDeclaration AddTypeParameterBefore(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public abstract virtual ITypeParameterOfTypeDeclaration AddTypeParameterAfter(ITypeParameterOfTypeDeclaration param, ITypeParameterOfTypeDeclaration anchor);
    public abstract virtual void RemoveTypeParameter(ITypeParameterOfTypeDeclaration param);
    public abstract virtual ITypeParameterOfTypeList SetTypeParameterList(ITypeParameterOfTypeList list);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.ITypeUsage {
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode NullableMark { get; }
    public abstract virtual IArrayModifiersList get_ArrayModifiersList();
    public abstract virtual ITokenNode get_NullableMark();
    public abstract virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public abstract virtual ITypeUsage ReplaceBy(ITypeUsage typeUsage);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IUnaryNegationExpression {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IUnknownPreprocessorDirective {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IUserDeclaredTypeUsage {
    public IReferenceName TypeName { get; }
    public abstract virtual IReferenceName get_TypeName();
    public abstract virtual IReferenceName SetTypeName(IReferenceName param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IUserTypeUsage {
    public IReferenceName TypeName { get; }
    public abstract virtual IReferenceName get_TypeName();
    public abstract virtual IReferenceName SetTypeName(IReferenceName param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IUsingStatement {
    public IBlock Block { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode EndUsing { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode UsingKeyword { get; }
    public TreeNodeCollection`1<IUsingVariableDeclaration> VariableDeclarations { get; }
    public TreeNodeEnumerable`1<IUsingVariableDeclaration> VariableDeclarationsEnumerable { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_EndUsing();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual ITokenNode get_UsingKeyword();
    public abstract virtual TreeNodeCollection`1<IUsingVariableDeclaration> get_VariableDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IUsingVariableDeclaration> get_VariableDeclarationsEnumerable();
    public abstract virtual IBlock SetBlock(IBlock param);
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IUsingVariableDeclaration {
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode AsKeyword { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public ITokenNode NullableMark { get; }
    public IVBLocalVariable DeclaredElement { get; }
    public bool IsImplicitlyTyped { get; }
    public abstract virtual IArrayModifiersList get_ArrayModifiersList();
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual IObjectCreationExpression get_CreationExpression();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual ITokenNode get_NullableMark();
    public abstract virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public abstract virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
    public abstract virtual IVBLocalVariable get_DeclaredElement();
    public abstract virtual bool get_IsImplicitlyTyped();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVariableDeclaration {
    public IArrayModifiersList ArrayModifiersList { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode NullableMark { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public IVariableDeclarationList DeclarationsList { get; }
    public IVBExpression Initializer { get; }
    public IMultipleVariableDeclaration MultipleDeclaration { get; }
    public ITypeUsage TypeUsage { get; }
    public bool WithEvents { get; }
    public IField VariableElement { get; }
    public abstract virtual IArrayModifiersList get_ArrayModifiersList();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITokenNode get_NullableMark();
    public abstract virtual IObjectCreationExpression get_CreationExpression();
    public abstract virtual IVariableDeclarationList get_DeclarationsList();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual IMultipleVariableDeclaration get_MultipleDeclaration();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public abstract virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual bool get_WithEvents();
    public abstract virtual IField get_VariableElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVariableDeclarationList {
    public ITokenNode AsKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public IObjectCreationExpression CreationExpression { get; }
    public TreeNodeCollection`1<IVariableDeclaration> Declarations { get; }
    public TreeNodeEnumerable`1<IVariableDeclaration> DeclarationsEnumerable { get; }
    public ITokenNode EqSign { get; }
    public IVBExpression Initializer { get; }
    public ITypeUsage TypeUsage { get; }
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual IObjectCreationExpression get_CreationExpression();
    public abstract virtual TreeNodeCollection`1<IVariableDeclaration> get_Declarations();
    public abstract virtual TreeNodeEnumerable`1<IVariableDeclaration> get_DeclarationsEnumerable();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual IVBExpression get_Initializer();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IObjectCreationExpression SetCreationExpression(IObjectCreationExpression param);
    public abstract virtual IVBExpression SetInitializer(IVBExpression param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBArgument {
    public IVBExpression Expression { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual bool IsValid();
    public abstract virtual IVBArgument ReplaceBy(IVBArgument argument);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBArgumentsOwner {
    public IArgumentList ArgumentList { get; }
    public TreeNodeCollection`1<IVBArgument> Arguments { get; }
    public TreeNodeEnumerable`1<IVBArgument> ArgumentsEnumerable { get; }
    public abstract virtual IArgumentList get_ArgumentList();
    public abstract virtual TreeNodeCollection`1<IVBArgument> get_Arguments();
    public abstract virtual TreeNodeEnumerable`1<IVBArgument> get_ArgumentsEnumerable();
    public abstract virtual IArgumentList SetArgumentList(IArgumentList param);
    public abstract virtual T AddArgumentBefore(T argument, IVBArgument anchor);
    public abstract virtual T AddArgumentAfter(T argument, IVBArgument anchor);
    public abstract virtual void RemoveArgument(IVBArgument argument);
    public abstract virtual T ReplaceArgument(IVBArgument oldArgument, T newArgument);
    public abstract virtual bool IsValid();
    public abstract virtual IPsiServices GetPsiServices();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBBinaryExpression {
    public IVBExpression LeftExpr { get; }
    public ITokenNode OpSign { get; }
    public IVBExpression RightExpr { get; }
    public abstract virtual IVBExpression get_LeftExpr();
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IVBExpression get_RightExpr();
    public abstract virtual IVBExpression SetLeftExpr(IVBExpression param);
    public abstract virtual IVBExpression SetRightExpr(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBComment {
    public CommentType CommentType { get; }
    public abstract virtual CommentType get_CommentType();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBDeclaration {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVbDocCommentBlock {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBExpression {
    [NotNullAttribute]
public abstract virtual IVBExpression ReplaceBy(IVBExpression expr);
    public abstract virtual ExpressionAccessType GetAccessType(IResolveContext resolveContext);
    public abstract virtual ExpressionClassification GetClassification();
    public abstract virtual ExpressionClassification GetClassification(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBFile {
    public IAttributeList GlobalAttributes { get; }
    public IImportDirectivesSection ImportsSection { get; }
    public IOptionStatementsSection OptionsSection { get; }
    public TreeNodeCollection`1<IImportClause> Imports { get; }
    public TreeNodeEnumerable`1<IImportClause> ImportsEnumerable { get; }
    public TreeNodeCollection`1<IOptionStatement> Options { get; }
    public TreeNodeEnumerable`1<IOptionStatement> OptionsEnumerable { get; }
    public Nullable`1<VBFileOption> StrictOption { get; }
    public Nullable`1<VBFileOption> InferOption { get; }
    public Nullable`1<VBFileOption> ExplicitOption { get; }
    public abstract virtual IAttributeList get_GlobalAttributes();
    public abstract virtual IImportDirectivesSection get_ImportsSection();
    public abstract virtual IOptionStatementsSection get_OptionsSection();
    public abstract virtual TreeNodeCollection`1<IImportClause> get_Imports();
    public abstract virtual TreeNodeEnumerable`1<IImportClause> get_ImportsEnumerable();
    public abstract virtual TreeNodeCollection`1<IOptionStatement> get_Options();
    public abstract virtual TreeNodeEnumerable`1<IOptionStatement> get_OptionsEnumerable();
    public abstract virtual IAttributeList SetGlobalAttributes(IAttributeList param);
    public abstract virtual IImportDirectivesSection SetImportsSection(IImportDirectivesSection param);
    public abstract virtual IOptionStatementsSection SetOptionsSection(IOptionStatementsSection param);
    public abstract virtual Nullable`1<VBFileOption> get_StrictOption();
    public abstract virtual Nullable`1<VBFileOption> get_InferOption();
    public abstract virtual Nullable`1<VBFileOption> get_ExplicitOption();
    public abstract virtual IImportDirective AddImportAfter(IImportDirective param, IImportDirective anchor);
    public abstract virtual IImportDirective AddImportBefore(IImportDirective param, IImportDirective anchor);
    public abstract virtual IImportDirective AddImport(IImportDirective param, bool saveUsingListPosition);
    public abstract virtual void RemoveImport(IImportDirective param);
    public abstract virtual void RemoveImportClause(IImportClause clause);
    public abstract virtual PreProcessingDirectivesInFile GetPreprocessorConditionals();
    public abstract virtual IOptionStatementsSection SetOptions(IOptionStatementsSection param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBFunctionDeclaration {
    public IBlock Block { get; }
    public ITokenNode EndDeclaration { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public IFunction FunctionElement { get; }
    public ITokenNode StartDeclaration { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual ITokenNode get_EndDeclaration();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual IBlock SetBlock(IBlock param);
    public abstract virtual IFunction get_FunctionElement();
    public abstract virtual ITokenNode get_StartDeclaration();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBIdentifier {
    public ITokenNode NameToken { get; }
    public ITokenNode TypeChar { get; }
    public abstract virtual ITokenNode get_NameToken();
    public abstract virtual ITokenNode get_TypeChar();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBLiteralExpression {
    public ITokenNode Literal { get; }
    public abstract virtual ITokenNode get_Literal();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBLocalVariableDeclaration {
    public IVBIdentifier Name { get; }
    public ITypeUsage TypeUsage { get; }
    public ILocalVariable DeclaredVariable { get; }
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
    public abstract virtual ILocalVariable get_DeclaredVariable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBModifiersOwnerDeclaration {
    public bool IsWriteonly { get; }
    public bool IsOverloads { get; }
    public abstract virtual void SetWriteonly(bool value);
    public abstract virtual bool get_IsWriteonly();
    public abstract virtual void SetOverloads(bool value);
    public abstract virtual bool get_IsOverloads();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBNamespaceDeclaration {
    public ITokenNode EndNamespace { get; }
    public ITokenNode NamespaceKeyword { get; }
    public IQualifiedNamespaceName QualifiedNamespaceName { get; }
    public string ShortName { get; }
    public IVBNamespaceDeclaration ContainingNamespace { get; }
    public bool IsGlobal { get; }
    public abstract virtual ITokenNode get_EndNamespace();
    public abstract virtual ITokenNode get_NamespaceKeyword();
    public abstract virtual IQualifiedNamespaceName get_QualifiedNamespaceName();
    public abstract virtual IQualifiedNamespaceName SetQualifiedNamespaceName(IQualifiedNamespaceName param);
    public abstract virtual string get_ShortName();
    public abstract virtual IVBNamespaceDeclaration get_ContainingNamespace();
    public abstract virtual bool get_IsGlobal();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBNestedTypeDeclaration {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBOperatorNode {
    [CanBeNullAttribute]
public IVBOperatorReference Reference { get; }
    public ITokenNode Sign { get; }
    public abstract virtual IVBOperatorReference get_Reference();
    public abstract virtual ITokenNode get_Sign();
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBOperatorReference {
    public abstract virtual IVBOperatorNode GetTreeNode();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBParameterDeclaration {
    public IArrayModifiersList ArrayModifiersList { get; }
    public ITokenNode AsKeyword { get; }
    public TreeNodeCollection`1<ITokenNode> Modifier { get; }
    public TreeNodeEnumerable`1<ITokenNode> ModifierEnumerable { get; }
    public IVBIdentifier Name { get; }
    public ITokenNode NullableMark { get; }
    public ITypeUsage TypeUsage { get; }
    public abstract virtual IArrayModifiersList get_ArrayModifiersList();
    public abstract virtual ITokenNode get_AsKeyword();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Modifier();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_ModifierEnumerable();
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual ITokenNode get_NullableMark();
    public abstract virtual ITypeUsage get_TypeUsage();
    public abstract virtual IArrayModifiersList SetArrayModifiersList(IArrayModifiersList param);
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual ITypeUsage SetTypeUsage(ITypeUsage param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBParameterDeclarationList {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public ITokenNode LPar { get; }
    public ITokenNode RPar { get; }
    public TreeNodeCollection`1<IVBParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IVBParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual ITokenNode get_LPar();
    public abstract virtual ITokenNode get_RPar();
    public abstract virtual TreeNodeCollection`1<IVBParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBParameterDeclaration> get_ParameterDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBParametersOwnerDeclaration {
    public IAttributeList AttributeList { get; }
    public IModifiersList ModifiersList { get; }
    public IRegularParameterList ParameterList { get; }
    public TreeNodeCollection`1<IAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IAttribute> AttributesEnumerable { get; }
    public TreeNodeCollection`1<IRegularParameterDeclaration> ParameterDeclarations { get; }
    public TreeNodeEnumerable`1<IRegularParameterDeclaration> ParameterDeclarationsEnumerable { get; }
    public abstract virtual IAttributeList get_AttributeList();
    public abstract virtual IModifiersList get_ModifiersList();
    public abstract virtual IRegularParameterList get_ParameterList();
    public abstract virtual TreeNodeCollection`1<IAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IAttribute> get_AttributesEnumerable();
    public abstract virtual TreeNodeCollection`1<IRegularParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IRegularParameterDeclaration> get_ParameterDeclarationsEnumerable();
    public abstract virtual IAttributeList SetAttributeList(IAttributeList param);
    public abstract virtual IModifiersList SetModifiersList(IModifiersList param);
    public abstract virtual IRegularParameterList SetParameterList(IRegularParameterList param);
    public abstract virtual IRegularParameterDeclaration AddParameterDeclarationBefore(IRegularParameterDeclaration parameter, IRegularParameterDeclaration anchor);
    public abstract virtual IRegularParameterDeclaration AddParameterDeclarationAfter(IRegularParameterDeclaration parameter, IRegularParameterDeclaration anchor);
    public abstract virtual void RemoveParameterDeclaration(IRegularParameterDeclaration parameter);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBProperTypeDeclaration {
    public abstract virtual IClassLikeDeclaration GetContainingClassLikeDeclaration();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBStatement {
    [NotNullAttribute]
public abstract virtual TStatement ReplaceBy(TStatement stmt);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBStatementsRange {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBTreeNode {
    public abstract virtual void Accept(TreeNodeVisitor visitor);
    public abstract virtual void Accept(TreeNodeVisitor`1<TContext> visitor, TContext context);
    public abstract virtual TReturn Accept(TreeNodeVisitor`2<TContext, TReturn> visitor, TContext context);
    [PureAttribute]
[CanBeNullAttribute]
public abstract virtual IVBNamespaceDeclaration GetContainingNamespaceDeclaration();
    [PureAttribute]
[CanBeNullAttribute]
public abstract virtual IVBTypeMemberDeclaration GetContainingTypeMemberDeclaration();
    [PureAttribute]
[CanBeNullAttribute]
public abstract virtual IVBTypeDeclaration GetContainingTypeDeclaration();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBTypeAndNamespaceHolderDeclaration {
    public TreeNodeCollection`1<IVBNamespaceDeclaration> NamespaceDeclarations { get; }
    public TreeNodeEnumerable`1<IVBNamespaceDeclaration> NamespaceDeclarationsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public TreeNodeCollection`1<IVBTypeDeclaration> TypeDeclarations { get; }
    public TreeNodeEnumerable`1<IVBTypeDeclaration> TypeDeclarationsEnumerable { get; }
    public IList`1<IVBDeclaration> TypeAndNamespaceDeclarations { get; }
    public abstract virtual TreeNodeCollection`1<IVBNamespaceDeclaration> get_NamespaceDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBNamespaceDeclaration> get_NamespaceDeclarationsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBTypeDeclaration> get_TypeDeclarations();
    public abstract virtual TreeNodeEnumerable`1<IVBTypeDeclaration> get_TypeDeclarationsEnumerable();
    public abstract virtual IList`1<IVBDeclaration> get_TypeAndNamespaceDeclarations();
    public abstract virtual IVBNamespaceDeclaration AddNamespaceDeclarationAfter(IVBNamespaceDeclaration param, IVBNamespaceDeclaration anchor);
    public abstract virtual IVBNamespaceDeclaration AddNamespaceDeclarationBefore(IVBNamespaceDeclaration param, IVBNamespaceDeclaration anchor);
    public abstract virtual void RemoveNamespaceDeclaration(IVBNamespaceDeclaration param);
    public abstract virtual T AddTypeDeclarationAfter(T param, IVBTypeDeclaration anchor);
    public abstract virtual T AddTypeDeclarationBefore(T param, IVBTypeDeclaration anchor);
    public abstract virtual void RemoveTypeDeclaration(IVBTypeDeclaration param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBTypeDeclaration {
    public IVBIdentifier Name { get; }
    public IVBNamespaceDeclaration OwnerNamespaceDeclaration { get; }
    [CanBeNullAttribute]
public ITypeElement TypeElement { get; }
    public bool IsPartial { get; }
    public abstract virtual IVBIdentifier get_Name();
    public abstract virtual IVBNamespaceDeclaration get_OwnerNamespaceDeclaration();
    public abstract virtual IVBIdentifier SetName(IVBIdentifier param);
    public abstract virtual ITypeElement get_TypeElement();
    public abstract virtual bool get_IsPartial();
    public abstract virtual void SetPartial(bool value);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBTypeMemberDeclaration {
    public ITypeMember MemberElement { get; }
    [CanBeNullAttribute]
public abstract virtual IVBTypeDeclaration GetContainingVbTypeDeclaration();
    public abstract virtual ITypeMember get_MemberElement();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBUnaryExpression {
    public IVBExpression Expression { get; }
    public ITokenNode OpSign { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_OpSign();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlAttribute {
    public ITokenNode AttributeName { get; }
    public IVBTreeNode AttributeValue { get; }
    public IVBXmlEmbeddedExpression EmbeddedAttribute { get; }
    public ITokenNode EqSign { get; }
    public TreeNodeCollection`1<ITokenNode> Whitespace { get; }
    public TreeNodeEnumerable`1<ITokenNode> WhitespaceEnumerable { get; }
    public abstract virtual ITokenNode get_AttributeName();
    public abstract virtual IVBTreeNode get_AttributeValue();
    public abstract virtual IVBXmlEmbeddedExpression get_EmbeddedAttribute();
    public abstract virtual ITokenNode get_EqSign();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Whitespace();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_WhitespaceEnumerable();
    public abstract virtual IVBXmlEmbeddedExpression SetEmbeddedAttribute(IVBXmlEmbeddedExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlCDataSection {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlComment {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlDocument {
    public IVBXmlElement XmlDocumentElement { get; }
    public IVBXmlEmbeddedExpression XmlDocumentExpression { get; }
    public abstract virtual IVBXmlElement get_XmlDocumentElement();
    public abstract virtual IVBXmlEmbeddedExpression get_XmlDocumentExpression();
    public abstract virtual IVBXmlElement SetXmlDocumentElement(IVBXmlElement param);
    public abstract virtual IVBXmlEmbeddedExpression SetXmlDocumentExpression(IVBXmlEmbeddedExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlElement {
    public IVBXmlElementFooter ElementFooter { get; }
    public IVBXmlElementHeader ElementHeader { get; }
    public TreeNodeCollection`1<IVBXmlEmbeddedExpression> EmbeddedExpressios { get; }
    public TreeNodeEnumerable`1<IVBXmlEmbeddedExpression> EmbeddedExpressiosEnumerable { get; }
    public TreeNodeCollection`1<IVBXmlElement> NestedElements { get; }
    public TreeNodeEnumerable`1<IVBXmlElement> NestedElementsEnumerable { get; }
    public TreeNodeCollection`1<ITokenNode> Text { get; }
    public TreeNodeEnumerable`1<ITokenNode> TextEnumerable { get; }
    public abstract virtual IVBXmlElementFooter get_ElementFooter();
    public abstract virtual IVBXmlElementHeader get_ElementHeader();
    public abstract virtual TreeNodeCollection`1<IVBXmlEmbeddedExpression> get_EmbeddedExpressios();
    public abstract virtual TreeNodeEnumerable`1<IVBXmlEmbeddedExpression> get_EmbeddedExpressiosEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBXmlElement> get_NestedElements();
    public abstract virtual TreeNodeEnumerable`1<IVBXmlElement> get_NestedElementsEnumerable();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Text();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_TextEnumerable();
    public abstract virtual IVBXmlElementFooter SetElementFooter(IVBXmlElementFooter param);
    public abstract virtual IVBXmlElementHeader SetElementHeader(IVBXmlElementHeader param);
    public abstract virtual IVBXmlElement AddElementAfter(IVBXmlElement element, IVBXmlElement anchor);
    public abstract virtual IVBXmlElement AddElementBefore(IVBXmlElement element, IVBXmlElement anchor);
    public abstract virtual void RemoveElement(IVBXmlElement element);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlElementFooter {
    public ITokenNode Name { get; }
    public ITokenNode TagEnd { get; }
    public ITokenNode TagStart { get; }
    public TreeNodeCollection`1<ITokenNode> Whitespace { get; }
    public TreeNodeEnumerable`1<ITokenNode> WhitespaceEnumerable { get; }
    public abstract virtual ITokenNode get_Name();
    public abstract virtual ITokenNode get_TagEnd();
    public abstract virtual ITokenNode get_TagStart();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Whitespace();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_WhitespaceEnumerable();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlElementHeader {
    public TreeNodeCollection`1<IVBXmlAttribute> Attributes { get; }
    public TreeNodeEnumerable`1<IVBXmlAttribute> AttributesEnumerable { get; }
    public ITokenNode ElementName { get; }
    public IVBXmlEmbeddedExpression EmbeddedExpression { get; }
    public ITokenNode TagEnd { get; }
    public ITokenNode TagStart { get; }
    public TreeNodeCollection`1<ITokenNode> Whitespace { get; }
    public TreeNodeEnumerable`1<ITokenNode> WhitespaceEnumerable { get; }
    public bool IsClosed { get; }
    public abstract virtual TreeNodeCollection`1<IVBXmlAttribute> get_Attributes();
    public abstract virtual TreeNodeEnumerable`1<IVBXmlAttribute> get_AttributesEnumerable();
    public abstract virtual ITokenNode get_ElementName();
    public abstract virtual IVBXmlEmbeddedExpression get_EmbeddedExpression();
    public abstract virtual ITokenNode get_TagEnd();
    public abstract virtual ITokenNode get_TagStart();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Whitespace();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_WhitespaceEnumerable();
    public abstract virtual IVBXmlEmbeddedExpression SetEmbeddedExpression(IVBXmlEmbeddedExpression param);
    public abstract virtual bool get_IsClosed();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlEmbeddedExpression {
    public ITokenNode EmbeddedExpressionEnd { get; }
    public ITokenNode EmbeddedExpressionStart { get; }
    public IVBExpression Expression { get; }
    public abstract virtual ITokenNode get_EmbeddedExpressionEnd();
    public abstract virtual ITokenNode get_EmbeddedExpressionStart();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlLiteralExpression {
    public IVBXmlCDataSection XmlCData { get; }
    public IVBXmlDocument XmlDocument { get; }
    public abstract virtual IVBXmlCDataSection get_XmlCData();
    public abstract virtual IVBXmlDocument get_XmlDocument();
    public abstract virtual IVBXmlCDataSection SetXmlCData(IVBXmlCDataSection param);
    public abstract virtual IVBXmlDocument SetXmlDocument(IVBXmlDocument param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlMemberAccessExpression {
    public ITokenNode AtSign { get; }
    public IVBIdentifier AttributeName { get; }
    public IPrimaryExpression BaseExpression { get; }
    public IConditionalAccessSign ConditionalAccessSign { get; }
    public ITokenNode Dot { get; }
    public ITokenNode Name { get; }
    public IManagedReference Reference { get; }
    public abstract virtual ITokenNode get_AtSign();
    public abstract virtual IVBIdentifier get_AttributeName();
    public abstract virtual IPrimaryExpression get_BaseExpression();
    public abstract virtual IConditionalAccessSign get_ConditionalAccessSign();
    public abstract virtual ITokenNode get_Dot();
    public abstract virtual ITokenNode get_Name();
    public abstract virtual IVBIdentifier SetAttributeName(IVBIdentifier param);
    public abstract virtual IPrimaryExpression SetBaseExpression(IPrimaryExpression param);
    public abstract virtual IConditionalAccessSign SetConditionalAccessSign(IConditionalAccessSign param);
    public abstract virtual IManagedReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlMisc {
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IVBXmlProcessingInstruction {
    public bool IsXmlProlog { get; }
    public abstract virtual bool get_IsXmlProlog();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IWarningPreprocessorDirective {
    public TreeNodeCollection`1<ITokenNode> Comma { get; }
    public TreeNodeEnumerable`1<ITokenNode> CommaEnumerable { get; }
    public TreeNodeCollection`1<IVBIdentifier> Names { get; }
    public TreeNodeEnumerable`1<IVBIdentifier> NamesEnumerable { get; }
    public ITokenNode WarningWord { get; }
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_Comma();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_CommaEnumerable();
    public abstract virtual TreeNodeCollection`1<IVBIdentifier> get_Names();
    public abstract virtual TreeNodeEnumerable`1<IVBIdentifier> get_NamesEnumerable();
    public abstract virtual ITokenNode get_WarningWord();
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IWhereQueryOperator {
    public IQueryParameterPlatform Expression { get; }
    public ITokenNode WhereKeyword { get; }
    public abstract virtual IQueryParameterPlatform get_Expression();
    public abstract virtual ITokenNode get_WhereKeyword();
    public abstract virtual IQueryParameterPlatform SetExpression(IQueryParameterPlatform param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IWhileStatement {
    public ITokenNode EndWhile { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode WhileKeyword { get; }
    public abstract virtual ITokenNode get_EndWhile();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual ITokenNode get_WhileKeyword();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IWhileUntilCondition {
    public IVBExpression Expression { get; }
    public ITokenNode Keyword { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_Keyword();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IWithStatement {
    public IBlock Block { get; }
    public ITokenNode EndWith { get; }
    public IVBExpression Expression { get; }
    public TreeNodeCollection`1<ITokenNode> StatementTerminators { get; }
    public TreeNodeEnumerable`1<ITokenNode> StatementTerminatorsEnumerable { get; }
    public ITokenNode WithKeyword { get; }
    public abstract virtual IBlock get_Block();
    public abstract virtual ITokenNode get_EndWith();
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual TreeNodeCollection`1<ITokenNode> get_StatementTerminators();
    public abstract virtual TreeNodeEnumerable`1<ITokenNode> get_StatementTerminatorsEnumerable();
    public abstract virtual ITokenNode get_WithKeyword();
    public abstract virtual IBlock SetBlock(IBlock param);
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
public interface JetBrains.ReSharper.Psi.VB.Tree.IYieldStatement {
    public IVBExpression Expression { get; }
    public ITokenNode YieldKeyword { get; }
    public abstract virtual IVBExpression get_Expression();
    public abstract virtual ITokenNode get_YieldKeyword();
    public abstract virtual IVBExpression SetExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.JoinCollectionRangeVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinCollectionRangeVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinCollectionRangeVariableDeclaration GetByTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinCollectionRangeVariableDeclaration GetByValue(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.JoinConditionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinCondition GetByLeftExpression(IQueryParameterPlatform param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinCondition GetByRightExpression(IQueryParameterPlatform param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.JoinQueryConditionsListFakeNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinQueryConditionsListFake GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.JoinQueryOperatorNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinQueryOperator GetByCondition(IJoinCondition param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinQueryOperator GetByConditionsList(IQueryConditionsList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinQueryOperator GetByDeclaration(IJoinCollectionRangeVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IJoinQueryOperator GetByNestedJoinQueryOperator(IJoinQueryOperator param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LabelDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILabelDeclaration GetByLabelName(ILabelName param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LabelNameNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LabelReferencingStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILabelReferencingStatement GetByLabelName(ILabelName param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LabelStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILabelStatement GetByDeclaration(ILabelDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LambdaExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetByParameterDeclaration(ILambdaParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaExpression GetBySignature(ILambdaSignature param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LambdaFunctionExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaFunctionExpression GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaFunctionExpression GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaFunctionExpression GetByParameterDeclaration(ILambdaParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaFunctionExpression GetByReturnTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaFunctionExpression GetBySignature(ILambdaSignature param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LambdaParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaParameterDeclaration GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaParameterDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaParameterDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LambdaSignatureNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaSignature GetByLambdaParameterDeclaration(ILambdaParameterDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LambdaSubExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaSubExpression GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaSubExpression GetByParameterDeclaration(ILambdaParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaSubExpression GetBySignature(ILambdaSignature param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILambdaSubExpression GetByStatement(IVBStatement param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LetQueryOperatorNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILetQueryOperator GetByDeclarationList(IExpressionRangeVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILetQueryOperator GetByVariableDeclaration(IExpressionRangeVariableDeclaration param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LibraryClauseNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LikeExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILikeExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILikeExpression GetByRightExpr(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LineIfStatementBodyNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILineIfStatementBody GetByStatement(IVBStatement param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LineIfStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILineIfStatement GetByElseBranch(ILineIfStatementBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILineIfStatement GetByElseIfBranch(ILineIfStatementBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILineIfStatement GetByElseIfExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILineIfStatement GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILineIfStatement GetByIfBranch(ILineIfStatementBody param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.LocalDeclarationKind : Enum {
    public int value__;
    public static LocalDeclarationKind UNKNOWN;
    public static LocalDeclarationKind STATIC;
    public static LocalDeclarationKind CONST;
    public static LocalDeclarationKind DIM;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LocalDeclarationListNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalDeclarationList GetByCreationExpression(IObjectCreationExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalDeclarationList GetByDeclaration(ILocalVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalDeclarationList GetByInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalDeclarationList GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LocalDeclarationStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalDeclarationStatement GetByAttributeList(IAttributeList param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalDeclarationStatement GetByDeclarationList(ILocalDeclarationList param);
    public static ILocalDeclarationStatement GetByVariableDeclaration(ILocalVariableDeclaration declaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LocalVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalVariableDeclaration GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<ILocalVariableDeclaration> GetByCreationExpression(IObjectCreationExpression param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<ILocalVariableDeclaration> GetByInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILocalVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<ILocalVariableDeclaration> GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LogicalAndExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILogicalAndExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILogicalAndExpression GetByRightExpr(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LogicalNotExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILogicalNotExpression GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LogicalOrExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILogicalOrExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILogicalOrExpression GetByRightExpr(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LogicalXorExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILogicalXorExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILogicalXorExpression GetByRightExpr(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.LoopControlVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILoopControlVariableDeclaration GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILoopControlVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ILoopControlVariableDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.LoopStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBStatement GetByBlock(IBlock param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.MemberAccessExpressionNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.MemberInitializerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMemberInitializer GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMemberInitializer GetByName(IVBIdentifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.MethodDeclarationBaseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByReturnAttributeList(IReturnAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByReturnTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByTypeParameterDeclaration(ITypeParameterOfMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclarationBase GetByTypeParameterList(ITypeParameterOfMethodList param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.MethodDeclarationKind : Enum {
    public int value__;
    public static MethodDeclarationKind SUB;
    public static MethodDeclarationKind FUNCTION;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.MethodDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByHandlesClause(IHandlesClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByImplementsClause(IImplementsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByReturnAttributeList(IReturnAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByReturnTypeUsage(ITypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByTypeParameterDeclaration(ITypeParameterOfMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMethodDeclaration GetByTypeParameterList(ITypeParameterOfMethodList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.MidAssignmentStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMidAssignmentStatement GetByArgument(IVBArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMidAssignmentStatement GetByArgumentList(IArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMidAssignmentStatement GetByRValue(IVBExpression param);
    [NullableContextAttribute("0")]
[CanBeNullAttribute]
public static IMidAssignmentStatement GetByArgumentExpression(IVBExpression expression);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ModifiersListNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ModifiersListOwnerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModifiersListOwner GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModifiersListOwner GetByModifiersList(IModifiersList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ModuleDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByConversionOperatorDeclaration(IConversionOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetBySignOperatorDeclaration(ISignOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModuleDeclaration GetByVariableDeclaration(IVariableDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ModulusExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModulusExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IModulusExpression GetByRightExpr(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.MultipleConstantDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleConstantDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleConstantDeclaration GetByDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleConstantDeclaration GetByModifiersList(IModifiersList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.MultipleVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleVariableDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleVariableDeclaration GetByDeclarationList(IVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultipleVariableDeclaration GetByModifiersList(IModifiersList param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.MultiplicativeExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultiplicativeExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IMultiplicativeExpression GetByRightExpr(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.NamedArgumentNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INamedArgument GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INamedArgument GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.NamespaceMemberDeclarationNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.NamespacePrefixExpressionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.NewExpressionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.NextClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static INextClause GetByNextExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ObjectCollectionInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCollectionInitializer GetByInitializer(ICollectionElementInitializer param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ObjectCreationExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByArgument(IVBArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByArgumentList(IArgumentList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByCollectionInitializer(IObjectCollectionInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByObjectInitializer(IObjectCreationInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationExpression GetByTypeUsage(IDeclaredTypeUsage param);
    [NullableContextAttribute("0")]
[CanBeNullAttribute]
public static IObjectCreationExpression GetByReference(IReference reference);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ObjectCreationInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IObjectCreationInitializer GetByMemberInitializer(IMemberInitializer param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.OnErrorSpecialLabelNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.OnErrorStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOnErrorStatement GetByLabelName(ILabelName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOnErrorStatement GetBySpecialLabel(IOnErrorSpecialLabel param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.OperatorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByReturnAttributeList(IReturnAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOperatorDeclaration GetByReturnType(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.OptionStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOptionStatement GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOptionStatement GetByValue(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.OptionStatementsSectionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOptionStatementsSection GetByOptionStatement(IOptionStatement param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.OrderByQueryOperatorNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOrderByQueryOperator GetByOrderExpression(IOrderExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.OrderExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IOrderExpression GetByExpression(IQueryParameterPlatform param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ParenthesizedExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IParenthesizedExpression GetByExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.PartitionQueryOperatorNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPartitionQueryOperator GetByExpression(IQueryParameterPlatform param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.PositionalArgumentNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPositionalArgument GetByExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.PreprocessorDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.PrimaryExpressionNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.PropertyDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByAccessorDeclaration(IAccessorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByCreationExpression(IObjectCreationExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByImplementsClause(IImplementsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByPropertyInitializer(IPropertyInitializer param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByReturnAttributeList(IReturnAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.PropertyInitializerNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IPropertyInitializer GetByInitializer(IVBExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.QualifiedNamespaceNameExtension : object {
    [ExtensionAttribute]
public static bool IsGlobal(IQualifiedNamespaceName qualifiedNamespaceName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.QualifiedNamespaceNameNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQualifiedNamespaceName GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQualifiedNamespaceName GetByQualifier(IQualifiedNamespaceName param);
}
public class JetBrains.ReSharper.Psi.VB.Tree.QualifierUsage : object {
    [CompilerGeneratedAttribute]
private bool <UseDot>k__BackingField;
    [CompilerGeneratedAttribute]
private IVBExpression <QualifierExpression>k__BackingField;
    public bool UseDot { get; }
    public IVBExpression QualifierExpression { get; }
    public static QualifierUsage Unqualified { get; }
    public static QualifierUsage QualifiedByDotOnly { get; }
    private QualifierUsage(bool useDot, IVBExpression qualifierExpression);
    [CompilerGeneratedAttribute]
public bool get_UseDot();
    [CompilerGeneratedAttribute]
public IVBExpression get_QualifierExpression();
    public static QualifierUsage get_Unqualified();
    public static QualifierUsage get_QualifiedByDotOnly();
    public static QualifierUsage QualifiedByExpression(IVBExpression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.QueryAggregatedParameterPlatformNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryAggregatedParameterPlatform GetByIdent(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryAggregatedParameterPlatform GetByPlatform(IQueryParameterPlatform param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.QueryCollectionRangeVariableDeclarationListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryCollectionRangeVariableDeclarationList GetByDeclaration(IQueryCollectionRangeVariableDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.QueryCollectionRangeVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryCollectionRangeVariableDeclaration GetByExpression(IQueryParameterPlatform param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryCollectionRangeVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryCollectionRangeVariableDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.QueryConditionsListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryConditionsList GetByjoinCondition(IJoinCondition param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.QueryExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryExpression GetByFirstQueryOperator(IQueryOperator param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryExpression GetByQueryOperator(IQueryOperator param);
    public static IQueryExpression GetByAggregatedRangeVariableDeclaration(IAggregatedRangeVariableDeclaration declaration);
    public static IQueryExpression GetByExpressionRangeVariableDeclaration(IExpressionRangeVariableDeclaration declaration);
    public static IQueryExpression GetByCollectionRangeVariableDeclaration(IQueryCollectionRangeVariableDeclaration declaration);
    public static IQueryExpression GetByJoinCollectionRangeVariableDeclaration(IJoinCollectionRangeVariableDeclaration declaration);
    public static IQueryExpression GetByPlatform(IQueryParameterPlatform platform);
    public static IQueryExpression GetExpressionThroughOparators(IQueryOperator operatorNode);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.QueryOperatorNavigator : object {
    [CanBeNullAttribute]
public static IQueryOperator GetByPlatform(IQueryParameterPlatform platform);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.QueryParameterNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryParameter GetByValue(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.QueryParameterPlatformNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IQueryParameterPlatform GetByValue(IVBExpression param);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.VB.Tree.QueryReferenceOwnerExtensions : object {
    [ExtensionAttribute]
public static IQueryReferenceOwnerImpl PreviousReferenceOwner(IQueryReferenceOwnerImpl owner);
    [ExtensionAttribute]
public static IQueryReferenceOwnerImpl NextReferenceOwner(IQueryReferenceOwnerImpl owner);
    [ExtensionAttribute]
public static int GetPositionInChain(IQueryReferenceOwnerImpl owner);
    [ExtensionAttribute]
public static QueryChainTypeBase GetQueryChainType(IQueryReferenceOwnerImpl owner);
    [ExtensionAttribute]
public static IQueryReferenceOwnerImpl GetLastChainReferenceOwner(IQueryCallsChainOwner owner);
    [ExtensionAttribute]
[NotNullAttribute]
public static IExpressionType GetChainReturnType(IQueryCallsChainOwner owner, IResolveContext resolveContext);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.RaiseEventStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRaiseEventStatement GetByExpression(IPrimaryExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.RedimClauseNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRedimClause GetByArrayBound(IArrayBound param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRedimClause GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRedimClause GetBySizeModifier(IArrayModifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.RedimStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRedimStatement GetByRedimClause(IRedimClause param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.ReferenceExpressionExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IVBExpression FindQualifierExpression(IReferenceExpression referenceExpression);
    [ExtensionAttribute]
public static bool IsNameOfArgument(IReferenceExpression referenceExpression);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.ReferenceExpressionKind : Enum {
    public int value__;
    public static ReferenceExpressionKind ConstructorReference;
    public static ReferenceExpressionKind SimpleReference;
    public static ReferenceExpressionKind IndexReference;
    public static ReferenceExpressionKind AddressOfReference;
    public static ReferenceExpressionKind EventReference;
    public static ReferenceExpressionKind PredefinedTypeReference;
    public static ReferenceExpressionKind NameOfOperator;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ReferenceExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceExpression GetByBaseExpression(IPrimaryExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceExpression GetByConditionalAccessSign(IConditionalAccessSign param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceExpression GetByNameIdentifier(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceExpression GetByTypeArgumentList(ITypeArgumentList param);
    [NullableContextAttribute("0")]
public static IReferenceExpression GetByQualifierExpression(IVBExpression expr);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ReferenceNameNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceName GetByNameIdentifier(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceName GetByQualifier(IReferenceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReferenceName GetByTypeArgumentList(ITypeArgumentList param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.RegionPreprocessorDirectiveNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.RegularParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRegularParameterDeclaration GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRegularParameterDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRegularParameterDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRegularParameterDeclaration GetByDefaultInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRegularParameterDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRegularParameterDeclaration GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.RegularParameterListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRegularParameterList GetByRegularParameterDeclaration(IRegularParameterDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.RelationalExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRelationalExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRelationalExpression GetByRightExpr(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.RemoveHandlerStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRemoveHandlerStatement GetByEventExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IRemoveHandlerStatement GetByHandlerExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ResumeStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IResumeStatement GetByLabelName(ILabelName param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ReturnAttributeListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReturnAttributeList GetByAttributeList(IAttributeList param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ReturnStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IReturnStatement GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.SelectQueryOperatorNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISelectQueryOperator GetByDeclarationList(IExpressionRangeVariableDeclarationList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISelectQueryOperator GetByVariableDeclaration(IExpressionRangeVariableDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.SelectStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISelectStatement GetByCaseStatement(ICaseStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISelectStatement GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.ShiftExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IShiftExpression GetByLeftExpr(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IShiftExpression GetByRightExpr(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.SignOperatorDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByParameterList(IRegularParameterList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByReturnAttributeList(IReturnAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISignOperatorDeclaration GetByReturnType(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.StopStatementNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.StructureDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByBody(IClassBody param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByConstantDeclaration(IConstantDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByConstructorDeclaration(IConstructorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByConversionOperatorDeclaration(IConversionOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByEventDeclaration(IEventDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByImplementsClause(ITypeImplementsClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByImplementsType(IDeclaredTypeUsage param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByMethodDeclaration(IMethodDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByPropertyDeclaration(IPropertyDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetBySignOperatorDeclaration(ISignOperatorDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByTypeParameterDeclaration(ITypeParameterOfTypeDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByTypeParameterList(ITypeParameterOfTypeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStructureDeclaration GetByVariableDeclaration(IVariableDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.SyncLockStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISyncLockStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ISyncLockStatement GetByExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.ThrowStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IThrowStatement GetByExpression(IVBExpression param);
}
public abstract class JetBrains.ReSharper.Psi.VB.Tree.TreeNodeVisitor : object {
    public virtual void VisitNode(ITreeNode node);
    public virtual void VisitAccessorDeclaration(IAccessorDeclaration accessorDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [propertyDeclaration] that directly implements accessorOwnerDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitAccessorOwnerDeclaration(IAccessorOwnerDeclaration accessorOwnerDeclarationParam);
    public virtual void VisitAddHandlerStatement(IAddHandlerStatement addHandlerStatementParam);
    public virtual void VisitAdditiveExpression(IAdditiveExpression additiveExpressionParam);
    public virtual void VisitAddressOfExpression(IAddressOfExpression addressOfExpressionParam);
    public virtual void VisitAggregateQueryOperator(IAggregateQueryOperator aggregateQueryOperatorParam);
    public virtual void VisitAggregatedRangeVariableDeclaration(IAggregatedRangeVariableDeclaration aggregatedRangeVariableDeclarationParam);
    public virtual void VisitAggregatedRangeVariableDeclarationList(IAggregatedRangeVariableDeclarationList aggregatedRangeVariableDeclarationListParam);
    public virtual void VisitAliasClause(IAliasClause aliasClauseParam);
    public virtual void VisitAnonymousArrayCreationExpression(IAnonymousArrayCreationExpression anonymousArrayCreationExpressionParam);
    public virtual void VisitAnonymousMemberDeclaration(IAnonymousMemberDeclaration anonymousMemberDeclarationParam);
    public virtual void VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreationExpressionParam);
    public virtual void VisitAnonymousObjectInitializer(IAnonymousObjectInitializer anonymousObjectInitializerParam);
    public virtual void VisitArgumentList(IArgumentList argumentListParam);
    public virtual void VisitArrayBound(IArrayBound arrayBoundParam);
    public virtual void VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpressionParam);
    public virtual void VisitArrayModifier(IArrayModifier arrayModifierParam);
    public virtual void VisitArrayModifiersList(IArrayModifiersList arrayModifiersListParam);
    public virtual void VisitAssignmentStatement(IAssignmentStatement assignmentStatementParam);
    public virtual void VisitAttribute(IAttribute attributeParam);
    public virtual void VisitAttributeList(IAttributeList attributeListParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributeListOwner interface, so this visitor member will not be invoked")]
public virtual void VisitAttributeListOwner(IAttributeListOwner attributeListOwnerParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributesOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitAttributesOwnerDeclaration(IAttributesOwnerDeclaration attributesOwnerDeclarationParam);
    public virtual void VisitAwaitExpression(IAwaitExpression awaitExpressionParam);
    public virtual void VisitAwaitStatement(IAwaitStatement awaitStatementParam);
    public virtual void VisitBlock(IBlock blockParam);
    public virtual void VisitBlockIfStatement(IBlockIfStatement blockIfStatementParam);
    public virtual void VisitCaseClause(ICaseClause caseClauseParam);
    public virtual void VisitCaseStatement(ICaseStatement caseStatementParam);
    public virtual void VisitCastExpression(ICastExpression castExpressionParam);
    public virtual void VisitCatchStatement(ICatchStatement catchStatementParam);
    public virtual void VisitCatchVariableDeclaration(ICatchVariableDeclaration catchVariableDeclarationParam);
    public virtual void VisitCharsetModifier(ICharsetModifier charsetModifierParam);
    public virtual void VisitClassBaseClause(IClassBaseClause classBaseClauseParam);
    public virtual void VisitClassBody(IClassBody classBodyParam);
    public virtual void VisitClassDeclaration(IClassDeclaration classDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [classDeclaration, interfaceDeclaration, structureDeclaration] that directly implements classLikeDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitClassLikeDeclaration(IClassLikeDeclaration classLikeDeclarationParam);
    public virtual void VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam);
    public virtual void VisitCollectionRangeVariableDeclaration(ICollectionRangeVariableDeclaration collectionRangeVariableDeclarationParam);
    public virtual void VisitConcatenationExpression(IConcatenationExpression concatenationExpressionParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements conditionalAccessExpression interface, so this visitor member will not be invoked")]
public virtual void VisitConditionalAccessExpression(IConditionalAccessExpression conditionalAccessExpressionParam);
    public virtual void VisitConditionalAccessSign(IConditionalAccessSign conditionalAccessSignParam);
    public virtual void VisitConditionalExpression(IConditionalExpression conditionalExpressionParam);
    public virtual void VisitConstPreprocessorDirective(IConstPreprocessorDirective constPreprocessorDirectiveParam);
    public virtual void VisitConstantDeclaration(IConstantDeclaration constantDeclarationParam);
    public virtual void VisitConstructorDeclaration(IConstructorDeclaration constructorDeclarationParam);
    public virtual void VisitContinueStatement(IContinueStatement continueStatementParam);
    public virtual void VisitControlReference(IControlReference controlReferenceParam);
    public virtual void VisitConversionOperatorDeclaration(IConversionOperatorDeclaration conversionOperatorDeclarationParam);
    public virtual void VisitDeclaredTypeUsage(IDeclaredTypeUsage declaredTypeUsageParam);
    public virtual void VisitDelegateDeclaration(IDelegateDeclaration delegateDeclarationParam);
    public virtual void VisitDictionaryAccessExpression(IDictionaryAccessExpression dictionaryAccessExpressionParam);
    public virtual void VisitDisableWarningPreprocessorDirective(IDisableWarningPreprocessorDirective disableWarningPreprocessorDirectiveParam);
    public virtual void VisitDistinctQueryOperator(IDistinctQueryOperator distinctQueryOperatorParam);
    public virtual void VisitDoLoopStatement(IDoLoopStatement doLoopStatementParam);
    public virtual void VisitElseIfPreprocessorDirective(IElseIfPreprocessorDirective elseIfPreprocessorDirectiveParam);
    public virtual void VisitElseIfStatement(IElseIfStatement elseIfStatementParam);
    public virtual void VisitElsePreprocessorDirective(IElsePreprocessorDirective elsePreprocessorDirectiveParam);
    public virtual void VisitElseStatement(IElseStatement elseStatementParam);
    public virtual void VisitEmptyArgument(IEmptyArgument emptyArgumentParam);
    public virtual void VisitEnableWarningPreprocessorDirective(IEnableWarningPreprocessorDirective enableWarningPreprocessorDirectiveParam);
    public virtual void VisitEndExternalSourcePreprocessorDirective(IEndExternalSourcePreprocessorDirective endExternalSourcePreprocessorDirectiveParam);
    public virtual void VisitEndIfPreprocessorDirective(IEndIfPreprocessorDirective endIfPreprocessorDirectiveParam);
    public virtual void VisitEndRegionPreprocessorDirective(IEndRegionPreprocessorDirective endRegionPreprocessorDirectiveParam);
    public virtual void VisitEndStatement(IEndStatement endStatementParam);
    public virtual void VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam);
    public virtual void VisitEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclarationParam);
    public virtual void VisitEraseStatement(IEraseStatement eraseStatementParam);
    public virtual void VisitErrorStatement(IErrorStatement errorStatementParam);
    public virtual void VisitEventDeclaration(IEventDeclaration eventDeclarationParam);
    public virtual void VisitEventSpecifier(IEventSpecifier eventSpecifierParam);
    public virtual void VisitExitStatement(IExitStatement exitStatementParam);
    public virtual void VisitExponentiationExpression(IExponentiationExpression exponentiationExpressionParam);
    public virtual void VisitExpressionArgument(IExpressionArgument expressionArgumentParam);
    public virtual void VisitExpressionRangeVariableDeclaration(IExpressionRangeVariableDeclaration expressionRangeVariableDeclarationParam);
    public virtual void VisitExpressionRangeVariableDeclarationList(IExpressionRangeVariableDeclarationList expressionRangeVariableDeclarationListParam);
    public virtual void VisitExpressionStatement(IExpressionStatement expressionStatementParam);
    public virtual void VisitExternalChecksumPreprocessorDirective(IExternalChecksumPreprocessorDirective externalChecksumPreprocessorDirectiveParam);
    public virtual void VisitExternalMethodDeclaration(IExternalMethodDeclaration externalMethodDeclarationParam);
    public virtual void VisitExternalSourcePreprocessorDirective(IExternalSourcePreprocessorDirective externalSourcePreprocessorDirectiveParam);
    public virtual void VisitFinallyStatement(IFinallyStatement finallyStatementParam);
    public virtual void VisitForEachStatement(IForEachStatement forEachStatementParam);
    public virtual void VisitForStatement(IForStatement forStatementParam);
    public virtual void VisitFromQueryOperator(IFromQueryOperator fromQueryOperatorParam);
    public virtual void VisitGetTypeExpression(IGetTypeExpression getTypeExpressionParam);
    public virtual void VisitGetXmlNamespaceExpression(IGetXmlNamespaceExpression getXmlNamespaceExpressionParam);
    public virtual void VisitGotoStatement(IGotoStatement gotoStatementParam);
    public virtual void VisitGroupByQueryOperator(IGroupByQueryOperator groupByQueryOperatorParam);
    public virtual void VisitGroupJoinQueryOperator(IGroupJoinQueryOperator groupJoinQueryOperatorParam);
    public virtual void VisitHandlesClause(IHandlesClause handlesClauseParam);
    public virtual void VisitIfPreprocessorDirective(IIfPreprocessorDirective ifPreprocessorDirectiveParam);
    public virtual void VisitImplementsClause(IImplementsClause implementsClauseParam);
    public virtual void VisitImportAliasClause(IImportAliasClause importAliasClauseParam);
    public virtual void VisitImportClause(IImportClause importClauseParam);
    public virtual void VisitImportDirective(IImportDirective importDirectiveParam);
    public virtual void VisitImportDirectivesSection(IImportDirectivesSection importDirectivesSectionParam);
    public virtual void VisitImportNamespaceClause(IImportNamespaceClause importNamespaceClauseParam);
    public virtual void VisitImportXMLNamespaceClause(IImportXMLNamespaceClause importXMLNamespaceClauseParam);
    public virtual void VisitIndexExpression(IIndexExpression indexExpressionParam);
    public virtual void VisitInstanceExpression(IInstanceExpression instanceExpressionParam);
    public virtual void VisitIntegerDivisionExpression(IIntegerDivisionExpression integerDivisionExpressionParam);
    public virtual void VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam);
    public virtual void VisitInterfaceInheritsClause(IInterfaceInheritsClause interfaceInheritsClauseParam);
    public virtual void VisitInterfaceMemberSpecifier(IInterfaceMemberSpecifier interfaceMemberSpecifierParam);
    public virtual void VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam);
    public virtual void VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam);
    public virtual void VisitIntoOfAggregateQueryOperator(IIntoOfAggregateQueryOperator intoOfAggregateQueryOperatorParam);
    public virtual void VisitInvocationStatement(IInvocationStatement invocationStatementParam);
    public virtual void VisitIsExpression(IIsExpression isExpressionParam);
    public virtual void VisitIsNotExpression(IIsNotExpression isNotExpressionParam);
    public virtual void VisitJoinCollectionRangeVariableDeclaration(IJoinCollectionRangeVariableDeclaration joinCollectionRangeVariableDeclarationParam);
    public virtual void VisitJoinCondition(IJoinCondition joinConditionParam);
    public virtual void VisitJoinQueryConditionsListFake(IJoinQueryConditionsListFake joinQueryConditionsListFakeParam);
    public virtual void VisitJoinQueryOperator(IJoinQueryOperator joinQueryOperatorParam);
    public virtual void VisitLabelDeclaration(ILabelDeclaration labelDeclarationParam);
    public virtual void VisitLabelName(ILabelName labelNameParam);
    public virtual void VisitLabelReferencingStatement(ILabelReferencingStatement labelReferencingStatementParam);
    public virtual void VisitLabelStatement(ILabelStatement labelStatementParam);
    public virtual void VisitLambdaExpression(ILambdaExpression lambdaExpressionParam);
    public virtual void VisitLambdaFunctionExpression(ILambdaFunctionExpression lambdaFunctionExpressionParam);
    public virtual void VisitLambdaParameterDeclaration(ILambdaParameterDeclaration lambdaParameterDeclarationParam);
    public virtual void VisitLambdaSignature(ILambdaSignature lambdaSignatureParam);
    public virtual void VisitLambdaSubExpression(ILambdaSubExpression lambdaSubExpressionParam);
    public virtual void VisitLetQueryOperator(ILetQueryOperator letQueryOperatorParam);
    public virtual void VisitLibraryClause(ILibraryClause libraryClauseParam);
    public virtual void VisitLikeExpression(ILikeExpression likeExpressionParam);
    public virtual void VisitLineIfStatement(ILineIfStatement lineIfStatementParam);
    public virtual void VisitLineIfStatementBody(ILineIfStatementBody lineIfStatementBodyParam);
    public virtual void VisitLocalDeclarationList(ILocalDeclarationList localDeclarationListParam);
    public virtual void VisitLocalDeclarationStatement(ILocalDeclarationStatement localDeclarationStatementParam);
    public virtual void VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam);
    public virtual void VisitLogicalAndExpression(ILogicalAndExpression logicalAndExpressionParam);
    public virtual void VisitLogicalNotExpression(ILogicalNotExpression logicalNotExpressionParam);
    public virtual void VisitLogicalOrExpression(ILogicalOrExpression logicalOrExpressionParam);
    public virtual void VisitLogicalXorExpression(ILogicalXorExpression logicalXorExpressionParam);
    public virtual void VisitLoopControlVariableDeclaration(ILoopControlVariableDeclaration loopControlVariableDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements loopStatement interface, so this visitor member will not be invoked")]
public virtual void VisitLoopStatement(ILoopStatement loopStatementParam);
    public virtual void VisitMemberAccessExpression(IMemberAccessExpression memberAccessExpressionParam);
    public virtual void VisitMemberInitializer(IMemberInitializer memberInitializerParam);
    public virtual void VisitMethodDeclaration(IMethodDeclaration methodDeclarationParam);
    public virtual void VisitMethodDeclarationBase(IMethodDeclarationBase methodDeclarationBaseParam);
    public virtual void VisitMidAssignmentStatement(IMidAssignmentStatement midAssignmentStatementParam);
    public virtual void VisitModifiersList(IModifiersList modifiersListParam);
    public virtual void VisitModifiersListOwner(IModifiersListOwner modifiersListOwnerParam);
    public virtual void VisitModuleDeclaration(IModuleDeclaration moduleDeclarationParam);
    public virtual void VisitModulusExpression(IModulusExpression modulusExpressionParam);
    public virtual void VisitMultipleConstantDeclaration(IMultipleConstantDeclaration multipleConstantDeclarationParam);
    public virtual void VisitMultipleVariableDeclaration(IMultipleVariableDeclaration multipleVariableDeclarationParam);
    public virtual void VisitMultiplicativeExpression(IMultiplicativeExpression multiplicativeExpressionParam);
    public virtual void VisitNamedArgument(INamedArgument namedArgumentParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements namespaceMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitNamespaceMemberDeclaration(INamespaceMemberDeclaration namespaceMemberDeclarationParam);
    public virtual void VisitNamespacePrefixExpression(INamespacePrefixExpression namespacePrefixExpressionParam);
    [ObsoleteAttribute("There are Nodes in PSI [objectCreationExpression] that directly implements newExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitNewExpression(INewExpression newExpressionParam);
    public virtual void VisitNextClause(INextClause nextClauseParam);
    public virtual void VisitObjectCollectionInitializer(IObjectCollectionInitializer objectCollectionInitializerParam);
    public virtual void VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam);
    public virtual void VisitObjectCreationInitializer(IObjectCreationInitializer objectCreationInitializerParam);
    public virtual void VisitOnErrorSpecialLabel(IOnErrorSpecialLabel onErrorSpecialLabelParam);
    public virtual void VisitOnErrorStatement(IOnErrorStatement onErrorStatementParam);
    public virtual void VisitOperatorDeclaration(IOperatorDeclaration operatorDeclarationParam);
    public virtual void VisitOptionStatement(IOptionStatement optionStatementParam);
    public virtual void VisitOptionStatementsSection(IOptionStatementsSection optionStatementsSectionParam);
    public virtual void VisitOrderByQueryOperator(IOrderByQueryOperator orderByQueryOperatorParam);
    public virtual void VisitOrderExpression(IOrderExpression orderExpressionParam);
    public virtual void VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam);
    public virtual void VisitPartitionQueryOperator(IPartitionQueryOperator partitionQueryOperatorParam);
    public virtual void VisitPositionalArgument(IPositionalArgument positionalArgumentParam);
    public virtual void VisitPreprocessorDirective(IPreprocessorDirective preprocessorDirectiveParam);
    [ObsoleteAttribute("There are Nodes in PSI [dictionaryAccessExpression, indexExpression] that directly implements primaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitPrimaryExpression(IPrimaryExpression primaryExpressionParam);
    public virtual void VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam);
    public virtual void VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam);
    public virtual void VisitQualifiedNamespaceName(IQualifiedNamespaceName qualifiedNamespaceNameParam);
    public virtual void VisitQueryAggregatedParameterPlatform(IQueryAggregatedParameterPlatform queryAggregatedParameterPlatformParam);
    public virtual void VisitQueryCollectionRangeVariableDeclaration(IQueryCollectionRangeVariableDeclaration queryCollectionRangeVariableDeclarationParam);
    public virtual void VisitQueryCollectionRangeVariableDeclarationList(IQueryCollectionRangeVariableDeclarationList queryCollectionRangeVariableDeclarationListParam);
    public virtual void VisitQueryConditionsList(IQueryConditionsList queryConditionsListParam);
    public virtual void VisitQueryExpression(IQueryExpression queryExpressionParam);
    public virtual void VisitQueryOperator(IQueryOperator queryOperatorParam);
    public virtual void VisitQueryParameter(IQueryParameter queryParameterParam);
    public virtual void VisitQueryParameterPlatform(IQueryParameterPlatform queryParameterPlatformParam);
    public virtual void VisitRaiseEventStatement(IRaiseEventStatement raiseEventStatementParam);
    public virtual void VisitRedimClause(IRedimClause redimClauseParam);
    public virtual void VisitRedimStatement(IRedimStatement redimStatementParam);
    public virtual void VisitReferenceExpression(IReferenceExpression referenceExpressionParam);
    public virtual void VisitReferenceName(IReferenceName referenceNameParam);
    public virtual void VisitRegionPreprocessorDirective(IRegionPreprocessorDirective regionPreprocessorDirectiveParam);
    public virtual void VisitRegularParameterDeclaration(IRegularParameterDeclaration regularParameterDeclarationParam);
    public virtual void VisitRegularParameterList(IRegularParameterList regularParameterListParam);
    public virtual void VisitRelationalExpression(IRelationalExpression relationalExpressionParam);
    public virtual void VisitRemoveHandlerStatement(IRemoveHandlerStatement removeHandlerStatementParam);
    public virtual void VisitResumeStatement(IResumeStatement resumeStatementParam);
    public virtual void VisitReturnAttributeList(IReturnAttributeList returnAttributeListParam);
    public virtual void VisitReturnStatement(IReturnStatement returnStatementParam);
    public virtual void VisitSelectQueryOperator(ISelectQueryOperator selectQueryOperatorParam);
    public virtual void VisitSelectStatement(ISelectStatement selectStatementParam);
    public virtual void VisitShiftExpression(IShiftExpression shiftExpressionParam);
    public virtual void VisitSignOperatorDeclaration(ISignOperatorDeclaration signOperatorDeclarationParam);
    public virtual void VisitStopStatement(IStopStatement stopStatementParam);
    public virtual void VisitStructureDeclaration(IStructureDeclaration structureDeclarationParam);
    public virtual void VisitSyncLockStatement(ISyncLockStatement syncLockStatementParam);
    public virtual void VisitThrowStatement(IThrowStatement throwStatementParam);
    public virtual void VisitTryStatement(ITryStatement tryStatementParam);
    public virtual void VisitTupleComponent(ITupleComponent tupleComponentParam);
    public virtual void VisitTupleDeclaredTypeUsage(ITupleDeclaredTypeUsage tupleDeclaredTypeUsageParam);
    public virtual void VisitTupleExpression(ITupleExpression tupleExpressionParam);
    public virtual void VisitTupleTypeComponent(ITupleTypeComponent tupleTypeComponentParam);
    public virtual void VisitTupleTypeUsage(ITupleTypeUsage tupleTypeUsageParam);
    public virtual void VisitTypeArgumentList(ITypeArgumentList typeArgumentListParam);
    public virtual void VisitTypeImplementsClause(ITypeImplementsClause typeImplementsClauseParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements typeMemberOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitTypeMemberOwnerDeclaration(ITypeMemberOwnerDeclaration typeMemberOwnerDeclarationParam);
    public virtual void VisitTypeOfIsExpression(ITypeOfIsExpression typeOfIsExpressionParam);
    public virtual void VisitTypeParameterConstraint(ITypeParameterConstraint typeParameterConstraintParam);
    public virtual void VisitTypeParameterConstraintList(ITypeParameterConstraintList typeParameterConstraintListParam);
    public virtual void VisitTypeParameterDeclaration(ITypeParameterDeclaration typeParameterDeclarationParam);
    public virtual void VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam);
    public virtual void VisitTypeParameterOfMethodList(ITypeParameterOfMethodList typeParameterOfMethodListParam);
    public virtual void VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam);
    public virtual void VisitTypeParameterOfTypeList(ITypeParameterOfTypeList typeParameterOfTypeListParam);
    public virtual void VisitTypeUsage(ITypeUsage typeUsageParam);
    public virtual void VisitUnaryNegationExpression(IUnaryNegationExpression unaryNegationExpressionParam);
    public virtual void VisitUnknownPreprocessorDirective(IUnknownPreprocessorDirective unknownPreprocessorDirectiveParam);
    public virtual void VisitUserDeclaredTypeUsage(IUserDeclaredTypeUsage userDeclaredTypeUsageParam);
    public virtual void VisitUserTypeUsage(IUserTypeUsage userTypeUsageParam);
    public virtual void VisitUsingStatement(IUsingStatement usingStatementParam);
    public virtual void VisitUsingVariableDeclaration(IUsingVariableDeclaration usingVariableDeclarationParam);
    public virtual void VisitVBArgument(IVBArgument vBArgumentParam);
    [ObsoleteAttribute("There are Nodes in PSI [indexExpression, midAssignmentStatement, objectCreationExpression] that directly implements vBArgumentsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBArgumentsOwner(IVBArgumentsOwner vBArgumentsOwnerParam);
    public virtual void VisitVBBinaryExpression(IVBBinaryExpression vBBinaryExpressionParam);
    public virtual void VisitVBDeclaration(IVBDeclaration vBDeclarationParam);
    public virtual void VisitVBExpression(IVBExpression vBExpressionParam);
    public virtual void VisitVBFile(IVBFile vBFileParam);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration] that directly implements vBFunctionDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBFunctionDeclaration(IVBFunctionDeclaration vBFunctionDeclarationParam);
    public virtual void VisitVBIdentifier(IVBIdentifier vBIdentifierParam);
    public virtual void VisitVBLiteralExpression(IVBLiteralExpression vBLiteralExpressionParam);
    public virtual void VisitVBLocalVariableDeclaration(IVBLocalVariableDeclaration vBLocalVariableDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBModifiersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitVBModifiersOwnerDeclaration(IVBModifiersOwnerDeclaration vBModifiersOwnerDeclarationParam);
    public virtual void VisitVBNamespaceDeclaration(IVBNamespaceDeclaration vBNamespaceDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [regularParameterDeclaration] that directly implements vBParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBParameterDeclaration(IVBParameterDeclaration vBParameterDeclarationParam);
    public virtual void VisitVBParameterDeclarationList(IVBParameterDeclarationList vBParameterDeclarationListParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBParametersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitVBParametersOwnerDeclaration(IVBParametersOwnerDeclaration vBParametersOwnerDeclarationParam);
    [ObsoleteAttribute("There are Nodes in PSI [midAssignmentStatement] that directly implements vBStatement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBStatement(IVBStatement vBStatementParam);
    [ObsoleteAttribute("There are Nodes in PSI [vBNamespaceDeclaration] that directly implements vBTypeAndNamespaceHolderDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBTypeAndNamespaceHolderDeclaration(IVBTypeAndNamespaceHolderDeclaration vBTypeAndNamespaceHolderDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBTypeDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitVBTypeDeclaration(IVBTypeDeclaration vBTypeDeclarationParam);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBTypeMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitVBTypeMemberDeclaration(IVBTypeMemberDeclaration vBTypeMemberDeclarationParam);
    public virtual void VisitVBUnaryExpression(IVBUnaryExpression vBUnaryExpressionParam);
    public virtual void VisitVBXmlAttribute(IVBXmlAttribute vBXmlAttributeParam);
    public virtual void VisitVBXmlCDataSection(IVBXmlCDataSection vBXmlCDataSectionParam);
    public virtual void VisitVBXmlComment(IVBXmlComment vBXmlCommentParam);
    public virtual void VisitVBXmlDocument(IVBXmlDocument vBXmlDocumentParam);
    public virtual void VisitVBXmlElement(IVBXmlElement vBXmlElementParam);
    public virtual void VisitVBXmlElementFooter(IVBXmlElementFooter vBXmlElementFooterParam);
    public virtual void VisitVBXmlElementHeader(IVBXmlElementHeader vBXmlElementHeaderParam);
    public virtual void VisitVBXmlEmbeddedExpression(IVBXmlEmbeddedExpression vBXmlEmbeddedExpressionParam);
    public virtual void VisitVBXmlLiteralExpression(IVBXmlLiteralExpression vBXmlLiteralExpressionParam);
    public virtual void VisitVBXmlMemberAccessExpression(IVBXmlMemberAccessExpression vBXmlMemberAccessExpressionParam);
    public virtual void VisitVBXmlMisc(IVBXmlMisc vBXmlMiscParam);
    public virtual void VisitVBXmlProcessingInstruction(IVBXmlProcessingInstruction vBXmlProcessingInstructionParam);
    public virtual void VisitVariableDeclaration(IVariableDeclaration variableDeclarationParam);
    public virtual void VisitVariableDeclarationList(IVariableDeclarationList variableDeclarationListParam);
    public virtual void VisitWarningPreprocessorDirective(IWarningPreprocessorDirective warningPreprocessorDirectiveParam);
    public virtual void VisitWhereQueryOperator(IWhereQueryOperator whereQueryOperatorParam);
    public virtual void VisitWhileStatement(IWhileStatement whileStatementParam);
    public virtual void VisitWhileUntilCondition(IWhileUntilCondition whileUntilConditionParam);
    public virtual void VisitWithStatement(IWithStatement withStatementParam);
    public virtual void VisitYieldStatement(IYieldStatement yieldStatementParam);
    public virtual void VisitInactivePreprocessorBranchNode(IInactivePreprocessorBranch inactivePreprocessorBranch);
    public virtual void VisitDocCommentBlockNode(IDocCommentBlock xmlDoc);
}
public abstract class JetBrains.ReSharper.Psi.VB.Tree.TreeNodeVisitor`1 : object {
    public virtual void VisitNode(ITreeNode node, TContext context);
    public virtual void VisitAccessorDeclaration(IAccessorDeclaration accessorDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [propertyDeclaration] that directly implements accessorOwnerDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitAccessorOwnerDeclaration(IAccessorOwnerDeclaration accessorOwnerDeclarationParam, TContext context);
    public virtual void VisitAddHandlerStatement(IAddHandlerStatement addHandlerStatementParam, TContext context);
    public virtual void VisitAdditiveExpression(IAdditiveExpression additiveExpressionParam, TContext context);
    public virtual void VisitAddressOfExpression(IAddressOfExpression addressOfExpressionParam, TContext context);
    public virtual void VisitAggregateQueryOperator(IAggregateQueryOperator aggregateQueryOperatorParam, TContext context);
    public virtual void VisitAggregatedRangeVariableDeclaration(IAggregatedRangeVariableDeclaration aggregatedRangeVariableDeclarationParam, TContext context);
    public virtual void VisitAggregatedRangeVariableDeclarationList(IAggregatedRangeVariableDeclarationList aggregatedRangeVariableDeclarationListParam, TContext context);
    public virtual void VisitAliasClause(IAliasClause aliasClauseParam, TContext context);
    public virtual void VisitAnonymousArrayCreationExpression(IAnonymousArrayCreationExpression anonymousArrayCreationExpressionParam, TContext context);
    public virtual void VisitAnonymousMemberDeclaration(IAnonymousMemberDeclaration anonymousMemberDeclarationParam, TContext context);
    public virtual void VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreationExpressionParam, TContext context);
    public virtual void VisitAnonymousObjectInitializer(IAnonymousObjectInitializer anonymousObjectInitializerParam, TContext context);
    public virtual void VisitArgumentList(IArgumentList argumentListParam, TContext context);
    public virtual void VisitArrayBound(IArrayBound arrayBoundParam, TContext context);
    public virtual void VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpressionParam, TContext context);
    public virtual void VisitArrayModifier(IArrayModifier arrayModifierParam, TContext context);
    public virtual void VisitArrayModifiersList(IArrayModifiersList arrayModifiersListParam, TContext context);
    public virtual void VisitAssignmentStatement(IAssignmentStatement assignmentStatementParam, TContext context);
    public virtual void VisitAttribute(IAttribute attributeParam, TContext context);
    public virtual void VisitAttributeList(IAttributeList attributeListParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributeListOwner interface, so this visitor member will not be invoked")]
public virtual void VisitAttributeListOwner(IAttributeListOwner attributeListOwnerParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributesOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitAttributesOwnerDeclaration(IAttributesOwnerDeclaration attributesOwnerDeclarationParam, TContext context);
    public virtual void VisitAwaitExpression(IAwaitExpression awaitExpressionParam, TContext context);
    public virtual void VisitAwaitStatement(IAwaitStatement awaitStatementParam, TContext context);
    public virtual void VisitBlock(IBlock blockParam, TContext context);
    public virtual void VisitBlockIfStatement(IBlockIfStatement blockIfStatementParam, TContext context);
    public virtual void VisitCaseClause(ICaseClause caseClauseParam, TContext context);
    public virtual void VisitCaseStatement(ICaseStatement caseStatementParam, TContext context);
    public virtual void VisitCastExpression(ICastExpression castExpressionParam, TContext context);
    public virtual void VisitCatchStatement(ICatchStatement catchStatementParam, TContext context);
    public virtual void VisitCatchVariableDeclaration(ICatchVariableDeclaration catchVariableDeclarationParam, TContext context);
    public virtual void VisitCharsetModifier(ICharsetModifier charsetModifierParam, TContext context);
    public virtual void VisitClassBaseClause(IClassBaseClause classBaseClauseParam, TContext context);
    public virtual void VisitClassBody(IClassBody classBodyParam, TContext context);
    public virtual void VisitClassDeclaration(IClassDeclaration classDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [classDeclaration, interfaceDeclaration, structureDeclaration] that directly implements classLikeDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitClassLikeDeclaration(IClassLikeDeclaration classLikeDeclarationParam, TContext context);
    public virtual void VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam, TContext context);
    public virtual void VisitCollectionRangeVariableDeclaration(ICollectionRangeVariableDeclaration collectionRangeVariableDeclarationParam, TContext context);
    public virtual void VisitConcatenationExpression(IConcatenationExpression concatenationExpressionParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements conditionalAccessExpression interface, so this visitor member will not be invoked")]
public virtual void VisitConditionalAccessExpression(IConditionalAccessExpression conditionalAccessExpressionParam, TContext context);
    public virtual void VisitConditionalAccessSign(IConditionalAccessSign conditionalAccessSignParam, TContext context);
    public virtual void VisitConditionalExpression(IConditionalExpression conditionalExpressionParam, TContext context);
    public virtual void VisitConstPreprocessorDirective(IConstPreprocessorDirective constPreprocessorDirectiveParam, TContext context);
    public virtual void VisitConstantDeclaration(IConstantDeclaration constantDeclarationParam, TContext context);
    public virtual void VisitConstructorDeclaration(IConstructorDeclaration constructorDeclarationParam, TContext context);
    public virtual void VisitContinueStatement(IContinueStatement continueStatementParam, TContext context);
    public virtual void VisitControlReference(IControlReference controlReferenceParam, TContext context);
    public virtual void VisitConversionOperatorDeclaration(IConversionOperatorDeclaration conversionOperatorDeclarationParam, TContext context);
    public virtual void VisitDeclaredTypeUsage(IDeclaredTypeUsage declaredTypeUsageParam, TContext context);
    public virtual void VisitDelegateDeclaration(IDelegateDeclaration delegateDeclarationParam, TContext context);
    public virtual void VisitDictionaryAccessExpression(IDictionaryAccessExpression dictionaryAccessExpressionParam, TContext context);
    public virtual void VisitDisableWarningPreprocessorDirective(IDisableWarningPreprocessorDirective disableWarningPreprocessorDirectiveParam, TContext context);
    public virtual void VisitDistinctQueryOperator(IDistinctQueryOperator distinctQueryOperatorParam, TContext context);
    public virtual void VisitDoLoopStatement(IDoLoopStatement doLoopStatementParam, TContext context);
    public virtual void VisitElseIfPreprocessorDirective(IElseIfPreprocessorDirective elseIfPreprocessorDirectiveParam, TContext context);
    public virtual void VisitElseIfStatement(IElseIfStatement elseIfStatementParam, TContext context);
    public virtual void VisitElsePreprocessorDirective(IElsePreprocessorDirective elsePreprocessorDirectiveParam, TContext context);
    public virtual void VisitElseStatement(IElseStatement elseStatementParam, TContext context);
    public virtual void VisitEmptyArgument(IEmptyArgument emptyArgumentParam, TContext context);
    public virtual void VisitEnableWarningPreprocessorDirective(IEnableWarningPreprocessorDirective enableWarningPreprocessorDirectiveParam, TContext context);
    public virtual void VisitEndExternalSourcePreprocessorDirective(IEndExternalSourcePreprocessorDirective endExternalSourcePreprocessorDirectiveParam, TContext context);
    public virtual void VisitEndIfPreprocessorDirective(IEndIfPreprocessorDirective endIfPreprocessorDirectiveParam, TContext context);
    public virtual void VisitEndRegionPreprocessorDirective(IEndRegionPreprocessorDirective endRegionPreprocessorDirectiveParam, TContext context);
    public virtual void VisitEndStatement(IEndStatement endStatementParam, TContext context);
    public virtual void VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam, TContext context);
    public virtual void VisitEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclarationParam, TContext context);
    public virtual void VisitEraseStatement(IEraseStatement eraseStatementParam, TContext context);
    public virtual void VisitErrorStatement(IErrorStatement errorStatementParam, TContext context);
    public virtual void VisitEventDeclaration(IEventDeclaration eventDeclarationParam, TContext context);
    public virtual void VisitEventSpecifier(IEventSpecifier eventSpecifierParam, TContext context);
    public virtual void VisitExitStatement(IExitStatement exitStatementParam, TContext context);
    public virtual void VisitExponentiationExpression(IExponentiationExpression exponentiationExpressionParam, TContext context);
    public virtual void VisitExpressionArgument(IExpressionArgument expressionArgumentParam, TContext context);
    public virtual void VisitExpressionRangeVariableDeclaration(IExpressionRangeVariableDeclaration expressionRangeVariableDeclarationParam, TContext context);
    public virtual void VisitExpressionRangeVariableDeclarationList(IExpressionRangeVariableDeclarationList expressionRangeVariableDeclarationListParam, TContext context);
    public virtual void VisitExpressionStatement(IExpressionStatement expressionStatementParam, TContext context);
    public virtual void VisitExternalChecksumPreprocessorDirective(IExternalChecksumPreprocessorDirective externalChecksumPreprocessorDirectiveParam, TContext context);
    public virtual void VisitExternalMethodDeclaration(IExternalMethodDeclaration externalMethodDeclarationParam, TContext context);
    public virtual void VisitExternalSourcePreprocessorDirective(IExternalSourcePreprocessorDirective externalSourcePreprocessorDirectiveParam, TContext context);
    public virtual void VisitFinallyStatement(IFinallyStatement finallyStatementParam, TContext context);
    public virtual void VisitForEachStatement(IForEachStatement forEachStatementParam, TContext context);
    public virtual void VisitForStatement(IForStatement forStatementParam, TContext context);
    public virtual void VisitFromQueryOperator(IFromQueryOperator fromQueryOperatorParam, TContext context);
    public virtual void VisitGetTypeExpression(IGetTypeExpression getTypeExpressionParam, TContext context);
    public virtual void VisitGetXmlNamespaceExpression(IGetXmlNamespaceExpression getXmlNamespaceExpressionParam, TContext context);
    public virtual void VisitGotoStatement(IGotoStatement gotoStatementParam, TContext context);
    public virtual void VisitGroupByQueryOperator(IGroupByQueryOperator groupByQueryOperatorParam, TContext context);
    public virtual void VisitGroupJoinQueryOperator(IGroupJoinQueryOperator groupJoinQueryOperatorParam, TContext context);
    public virtual void VisitHandlesClause(IHandlesClause handlesClauseParam, TContext context);
    public virtual void VisitIfPreprocessorDirective(IIfPreprocessorDirective ifPreprocessorDirectiveParam, TContext context);
    public virtual void VisitImplementsClause(IImplementsClause implementsClauseParam, TContext context);
    public virtual void VisitImportAliasClause(IImportAliasClause importAliasClauseParam, TContext context);
    public virtual void VisitImportClause(IImportClause importClauseParam, TContext context);
    public virtual void VisitImportDirective(IImportDirective importDirectiveParam, TContext context);
    public virtual void VisitImportDirectivesSection(IImportDirectivesSection importDirectivesSectionParam, TContext context);
    public virtual void VisitImportNamespaceClause(IImportNamespaceClause importNamespaceClauseParam, TContext context);
    public virtual void VisitImportXMLNamespaceClause(IImportXMLNamespaceClause importXMLNamespaceClauseParam, TContext context);
    public virtual void VisitIndexExpression(IIndexExpression indexExpressionParam, TContext context);
    public virtual void VisitInstanceExpression(IInstanceExpression instanceExpressionParam, TContext context);
    public virtual void VisitIntegerDivisionExpression(IIntegerDivisionExpression integerDivisionExpressionParam, TContext context);
    public virtual void VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam, TContext context);
    public virtual void VisitInterfaceInheritsClause(IInterfaceInheritsClause interfaceInheritsClauseParam, TContext context);
    public virtual void VisitInterfaceMemberSpecifier(IInterfaceMemberSpecifier interfaceMemberSpecifierParam, TContext context);
    public virtual void VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam, TContext context);
    public virtual void VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam, TContext context);
    public virtual void VisitIntoOfAggregateQueryOperator(IIntoOfAggregateQueryOperator intoOfAggregateQueryOperatorParam, TContext context);
    public virtual void VisitInvocationStatement(IInvocationStatement invocationStatementParam, TContext context);
    public virtual void VisitIsExpression(IIsExpression isExpressionParam, TContext context);
    public virtual void VisitIsNotExpression(IIsNotExpression isNotExpressionParam, TContext context);
    public virtual void VisitJoinCollectionRangeVariableDeclaration(IJoinCollectionRangeVariableDeclaration joinCollectionRangeVariableDeclarationParam, TContext context);
    public virtual void VisitJoinCondition(IJoinCondition joinConditionParam, TContext context);
    public virtual void VisitJoinQueryConditionsListFake(IJoinQueryConditionsListFake joinQueryConditionsListFakeParam, TContext context);
    public virtual void VisitJoinQueryOperator(IJoinQueryOperator joinQueryOperatorParam, TContext context);
    public virtual void VisitLabelDeclaration(ILabelDeclaration labelDeclarationParam, TContext context);
    public virtual void VisitLabelName(ILabelName labelNameParam, TContext context);
    public virtual void VisitLabelReferencingStatement(ILabelReferencingStatement labelReferencingStatementParam, TContext context);
    public virtual void VisitLabelStatement(ILabelStatement labelStatementParam, TContext context);
    public virtual void VisitLambdaExpression(ILambdaExpression lambdaExpressionParam, TContext context);
    public virtual void VisitLambdaFunctionExpression(ILambdaFunctionExpression lambdaFunctionExpressionParam, TContext context);
    public virtual void VisitLambdaParameterDeclaration(ILambdaParameterDeclaration lambdaParameterDeclarationParam, TContext context);
    public virtual void VisitLambdaSignature(ILambdaSignature lambdaSignatureParam, TContext context);
    public virtual void VisitLambdaSubExpression(ILambdaSubExpression lambdaSubExpressionParam, TContext context);
    public virtual void VisitLetQueryOperator(ILetQueryOperator letQueryOperatorParam, TContext context);
    public virtual void VisitLibraryClause(ILibraryClause libraryClauseParam, TContext context);
    public virtual void VisitLikeExpression(ILikeExpression likeExpressionParam, TContext context);
    public virtual void VisitLineIfStatement(ILineIfStatement lineIfStatementParam, TContext context);
    public virtual void VisitLineIfStatementBody(ILineIfStatementBody lineIfStatementBodyParam, TContext context);
    public virtual void VisitLocalDeclarationList(ILocalDeclarationList localDeclarationListParam, TContext context);
    public virtual void VisitLocalDeclarationStatement(ILocalDeclarationStatement localDeclarationStatementParam, TContext context);
    public virtual void VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam, TContext context);
    public virtual void VisitLogicalAndExpression(ILogicalAndExpression logicalAndExpressionParam, TContext context);
    public virtual void VisitLogicalNotExpression(ILogicalNotExpression logicalNotExpressionParam, TContext context);
    public virtual void VisitLogicalOrExpression(ILogicalOrExpression logicalOrExpressionParam, TContext context);
    public virtual void VisitLogicalXorExpression(ILogicalXorExpression logicalXorExpressionParam, TContext context);
    public virtual void VisitLoopControlVariableDeclaration(ILoopControlVariableDeclaration loopControlVariableDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements loopStatement interface, so this visitor member will not be invoked")]
public virtual void VisitLoopStatement(ILoopStatement loopStatementParam, TContext context);
    public virtual void VisitMemberAccessExpression(IMemberAccessExpression memberAccessExpressionParam, TContext context);
    public virtual void VisitMemberInitializer(IMemberInitializer memberInitializerParam, TContext context);
    public virtual void VisitMethodDeclaration(IMethodDeclaration methodDeclarationParam, TContext context);
    public virtual void VisitMethodDeclarationBase(IMethodDeclarationBase methodDeclarationBaseParam, TContext context);
    public virtual void VisitMidAssignmentStatement(IMidAssignmentStatement midAssignmentStatementParam, TContext context);
    public virtual void VisitModifiersList(IModifiersList modifiersListParam, TContext context);
    public virtual void VisitModifiersListOwner(IModifiersListOwner modifiersListOwnerParam, TContext context);
    public virtual void VisitModuleDeclaration(IModuleDeclaration moduleDeclarationParam, TContext context);
    public virtual void VisitModulusExpression(IModulusExpression modulusExpressionParam, TContext context);
    public virtual void VisitMultipleConstantDeclaration(IMultipleConstantDeclaration multipleConstantDeclarationParam, TContext context);
    public virtual void VisitMultipleVariableDeclaration(IMultipleVariableDeclaration multipleVariableDeclarationParam, TContext context);
    public virtual void VisitMultiplicativeExpression(IMultiplicativeExpression multiplicativeExpressionParam, TContext context);
    public virtual void VisitNamedArgument(INamedArgument namedArgumentParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements namespaceMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitNamespaceMemberDeclaration(INamespaceMemberDeclaration namespaceMemberDeclarationParam, TContext context);
    public virtual void VisitNamespacePrefixExpression(INamespacePrefixExpression namespacePrefixExpressionParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [objectCreationExpression] that directly implements newExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitNewExpression(INewExpression newExpressionParam, TContext context);
    public virtual void VisitNextClause(INextClause nextClauseParam, TContext context);
    public virtual void VisitObjectCollectionInitializer(IObjectCollectionInitializer objectCollectionInitializerParam, TContext context);
    public virtual void VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam, TContext context);
    public virtual void VisitObjectCreationInitializer(IObjectCreationInitializer objectCreationInitializerParam, TContext context);
    public virtual void VisitOnErrorSpecialLabel(IOnErrorSpecialLabel onErrorSpecialLabelParam, TContext context);
    public virtual void VisitOnErrorStatement(IOnErrorStatement onErrorStatementParam, TContext context);
    public virtual void VisitOperatorDeclaration(IOperatorDeclaration operatorDeclarationParam, TContext context);
    public virtual void VisitOptionStatement(IOptionStatement optionStatementParam, TContext context);
    public virtual void VisitOptionStatementsSection(IOptionStatementsSection optionStatementsSectionParam, TContext context);
    public virtual void VisitOrderByQueryOperator(IOrderByQueryOperator orderByQueryOperatorParam, TContext context);
    public virtual void VisitOrderExpression(IOrderExpression orderExpressionParam, TContext context);
    public virtual void VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam, TContext context);
    public virtual void VisitPartitionQueryOperator(IPartitionQueryOperator partitionQueryOperatorParam, TContext context);
    public virtual void VisitPositionalArgument(IPositionalArgument positionalArgumentParam, TContext context);
    public virtual void VisitPreprocessorDirective(IPreprocessorDirective preprocessorDirectiveParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [dictionaryAccessExpression, indexExpression] that directly implements primaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitPrimaryExpression(IPrimaryExpression primaryExpressionParam, TContext context);
    public virtual void VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam, TContext context);
    public virtual void VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam, TContext context);
    public virtual void VisitQualifiedNamespaceName(IQualifiedNamespaceName qualifiedNamespaceNameParam, TContext context);
    public virtual void VisitQueryAggregatedParameterPlatform(IQueryAggregatedParameterPlatform queryAggregatedParameterPlatformParam, TContext context);
    public virtual void VisitQueryCollectionRangeVariableDeclaration(IQueryCollectionRangeVariableDeclaration queryCollectionRangeVariableDeclarationParam, TContext context);
    public virtual void VisitQueryCollectionRangeVariableDeclarationList(IQueryCollectionRangeVariableDeclarationList queryCollectionRangeVariableDeclarationListParam, TContext context);
    public virtual void VisitQueryConditionsList(IQueryConditionsList queryConditionsListParam, TContext context);
    public virtual void VisitQueryExpression(IQueryExpression queryExpressionParam, TContext context);
    public virtual void VisitQueryOperator(IQueryOperator queryOperatorParam, TContext context);
    public virtual void VisitQueryParameter(IQueryParameter queryParameterParam, TContext context);
    public virtual void VisitQueryParameterPlatform(IQueryParameterPlatform queryParameterPlatformParam, TContext context);
    public virtual void VisitRaiseEventStatement(IRaiseEventStatement raiseEventStatementParam, TContext context);
    public virtual void VisitRedimClause(IRedimClause redimClauseParam, TContext context);
    public virtual void VisitRedimStatement(IRedimStatement redimStatementParam, TContext context);
    public virtual void VisitReferenceExpression(IReferenceExpression referenceExpressionParam, TContext context);
    public virtual void VisitReferenceName(IReferenceName referenceNameParam, TContext context);
    public virtual void VisitRegionPreprocessorDirective(IRegionPreprocessorDirective regionPreprocessorDirectiveParam, TContext context);
    public virtual void VisitRegularParameterDeclaration(IRegularParameterDeclaration regularParameterDeclarationParam, TContext context);
    public virtual void VisitRegularParameterList(IRegularParameterList regularParameterListParam, TContext context);
    public virtual void VisitRelationalExpression(IRelationalExpression relationalExpressionParam, TContext context);
    public virtual void VisitRemoveHandlerStatement(IRemoveHandlerStatement removeHandlerStatementParam, TContext context);
    public virtual void VisitResumeStatement(IResumeStatement resumeStatementParam, TContext context);
    public virtual void VisitReturnAttributeList(IReturnAttributeList returnAttributeListParam, TContext context);
    public virtual void VisitReturnStatement(IReturnStatement returnStatementParam, TContext context);
    public virtual void VisitSelectQueryOperator(ISelectQueryOperator selectQueryOperatorParam, TContext context);
    public virtual void VisitSelectStatement(ISelectStatement selectStatementParam, TContext context);
    public virtual void VisitShiftExpression(IShiftExpression shiftExpressionParam, TContext context);
    public virtual void VisitSignOperatorDeclaration(ISignOperatorDeclaration signOperatorDeclarationParam, TContext context);
    public virtual void VisitStopStatement(IStopStatement stopStatementParam, TContext context);
    public virtual void VisitStructureDeclaration(IStructureDeclaration structureDeclarationParam, TContext context);
    public virtual void VisitSyncLockStatement(ISyncLockStatement syncLockStatementParam, TContext context);
    public virtual void VisitThrowStatement(IThrowStatement throwStatementParam, TContext context);
    public virtual void VisitTryStatement(ITryStatement tryStatementParam, TContext context);
    public virtual void VisitTupleComponent(ITupleComponent tupleComponentParam, TContext context);
    public virtual void VisitTupleDeclaredTypeUsage(ITupleDeclaredTypeUsage tupleDeclaredTypeUsageParam, TContext context);
    public virtual void VisitTupleExpression(ITupleExpression tupleExpressionParam, TContext context);
    public virtual void VisitTupleTypeComponent(ITupleTypeComponent tupleTypeComponentParam, TContext context);
    public virtual void VisitTupleTypeUsage(ITupleTypeUsage tupleTypeUsageParam, TContext context);
    public virtual void VisitTypeArgumentList(ITypeArgumentList typeArgumentListParam, TContext context);
    public virtual void VisitTypeImplementsClause(ITypeImplementsClause typeImplementsClauseParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements typeMemberOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitTypeMemberOwnerDeclaration(ITypeMemberOwnerDeclaration typeMemberOwnerDeclarationParam, TContext context);
    public virtual void VisitTypeOfIsExpression(ITypeOfIsExpression typeOfIsExpressionParam, TContext context);
    public virtual void VisitTypeParameterConstraint(ITypeParameterConstraint typeParameterConstraintParam, TContext context);
    public virtual void VisitTypeParameterConstraintList(ITypeParameterConstraintList typeParameterConstraintListParam, TContext context);
    public virtual void VisitTypeParameterDeclaration(ITypeParameterDeclaration typeParameterDeclarationParam, TContext context);
    public virtual void VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam, TContext context);
    public virtual void VisitTypeParameterOfMethodList(ITypeParameterOfMethodList typeParameterOfMethodListParam, TContext context);
    public virtual void VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam, TContext context);
    public virtual void VisitTypeParameterOfTypeList(ITypeParameterOfTypeList typeParameterOfTypeListParam, TContext context);
    public virtual void VisitTypeUsage(ITypeUsage typeUsageParam, TContext context);
    public virtual void VisitUnaryNegationExpression(IUnaryNegationExpression unaryNegationExpressionParam, TContext context);
    public virtual void VisitUnknownPreprocessorDirective(IUnknownPreprocessorDirective unknownPreprocessorDirectiveParam, TContext context);
    public virtual void VisitUserDeclaredTypeUsage(IUserDeclaredTypeUsage userDeclaredTypeUsageParam, TContext context);
    public virtual void VisitUserTypeUsage(IUserTypeUsage userTypeUsageParam, TContext context);
    public virtual void VisitUsingStatement(IUsingStatement usingStatementParam, TContext context);
    public virtual void VisitUsingVariableDeclaration(IUsingVariableDeclaration usingVariableDeclarationParam, TContext context);
    public virtual void VisitVBArgument(IVBArgument vBArgumentParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [indexExpression, midAssignmentStatement, objectCreationExpression] that directly implements vBArgumentsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBArgumentsOwner(IVBArgumentsOwner vBArgumentsOwnerParam, TContext context);
    public virtual void VisitVBBinaryExpression(IVBBinaryExpression vBBinaryExpressionParam, TContext context);
    public virtual void VisitVBDeclaration(IVBDeclaration vBDeclarationParam, TContext context);
    public virtual void VisitVBExpression(IVBExpression vBExpressionParam, TContext context);
    public virtual void VisitVBFile(IVBFile vBFileParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration] that directly implements vBFunctionDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBFunctionDeclaration(IVBFunctionDeclaration vBFunctionDeclarationParam, TContext context);
    public virtual void VisitVBIdentifier(IVBIdentifier vBIdentifierParam, TContext context);
    public virtual void VisitVBLiteralExpression(IVBLiteralExpression vBLiteralExpressionParam, TContext context);
    public virtual void VisitVBLocalVariableDeclaration(IVBLocalVariableDeclaration vBLocalVariableDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBModifiersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitVBModifiersOwnerDeclaration(IVBModifiersOwnerDeclaration vBModifiersOwnerDeclarationParam, TContext context);
    public virtual void VisitVBNamespaceDeclaration(IVBNamespaceDeclaration vBNamespaceDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [regularParameterDeclaration] that directly implements vBParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBParameterDeclaration(IVBParameterDeclaration vBParameterDeclarationParam, TContext context);
    public virtual void VisitVBParameterDeclarationList(IVBParameterDeclarationList vBParameterDeclarationListParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBParametersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitVBParametersOwnerDeclaration(IVBParametersOwnerDeclaration vBParametersOwnerDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [midAssignmentStatement] that directly implements vBStatement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBStatement(IVBStatement vBStatementParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [vBNamespaceDeclaration] that directly implements vBTypeAndNamespaceHolderDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual void VisitVBTypeAndNamespaceHolderDeclaration(IVBTypeAndNamespaceHolderDeclaration vBTypeAndNamespaceHolderDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBTypeDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitVBTypeDeclaration(IVBTypeDeclaration vBTypeDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBTypeMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual void VisitVBTypeMemberDeclaration(IVBTypeMemberDeclaration vBTypeMemberDeclarationParam, TContext context);
    public virtual void VisitVBUnaryExpression(IVBUnaryExpression vBUnaryExpressionParam, TContext context);
    public virtual void VisitVBXmlAttribute(IVBXmlAttribute vBXmlAttributeParam, TContext context);
    public virtual void VisitVBXmlCDataSection(IVBXmlCDataSection vBXmlCDataSectionParam, TContext context);
    public virtual void VisitVBXmlComment(IVBXmlComment vBXmlCommentParam, TContext context);
    public virtual void VisitVBXmlDocument(IVBXmlDocument vBXmlDocumentParam, TContext context);
    public virtual void VisitVBXmlElement(IVBXmlElement vBXmlElementParam, TContext context);
    public virtual void VisitVBXmlElementFooter(IVBXmlElementFooter vBXmlElementFooterParam, TContext context);
    public virtual void VisitVBXmlElementHeader(IVBXmlElementHeader vBXmlElementHeaderParam, TContext context);
    public virtual void VisitVBXmlEmbeddedExpression(IVBXmlEmbeddedExpression vBXmlEmbeddedExpressionParam, TContext context);
    public virtual void VisitVBXmlLiteralExpression(IVBXmlLiteralExpression vBXmlLiteralExpressionParam, TContext context);
    public virtual void VisitVBXmlMemberAccessExpression(IVBXmlMemberAccessExpression vBXmlMemberAccessExpressionParam, TContext context);
    public virtual void VisitVBXmlMisc(IVBXmlMisc vBXmlMiscParam, TContext context);
    public virtual void VisitVBXmlProcessingInstruction(IVBXmlProcessingInstruction vBXmlProcessingInstructionParam, TContext context);
    public virtual void VisitVariableDeclaration(IVariableDeclaration variableDeclarationParam, TContext context);
    public virtual void VisitVariableDeclarationList(IVariableDeclarationList variableDeclarationListParam, TContext context);
    public virtual void VisitWarningPreprocessorDirective(IWarningPreprocessorDirective warningPreprocessorDirectiveParam, TContext context);
    public virtual void VisitWhereQueryOperator(IWhereQueryOperator whereQueryOperatorParam, TContext context);
    public virtual void VisitWhileStatement(IWhileStatement whileStatementParam, TContext context);
    public virtual void VisitWhileUntilCondition(IWhileUntilCondition whileUntilConditionParam, TContext context);
    public virtual void VisitWithStatement(IWithStatement withStatementParam, TContext context);
    public virtual void VisitYieldStatement(IYieldStatement yieldStatementParam, TContext context);
    public virtual void VisitDocCommentBlockNode(IDocCommentBlock xmlDoc, TContext context);
}
public abstract class JetBrains.ReSharper.Psi.VB.Tree.TreeNodeVisitor`2 : object {
    public virtual TReturn VisitNode(ITreeNode node, TContext context);
    public virtual TReturn VisitAccessorDeclaration(IAccessorDeclaration accessorDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [propertyDeclaration] that directly implements accessorOwnerDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitAccessorOwnerDeclaration(IAccessorOwnerDeclaration accessorOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitAddHandlerStatement(IAddHandlerStatement addHandlerStatementParam, TContext context);
    public virtual TReturn VisitAdditiveExpression(IAdditiveExpression additiveExpressionParam, TContext context);
    public virtual TReturn VisitAddressOfExpression(IAddressOfExpression addressOfExpressionParam, TContext context);
    public virtual TReturn VisitAggregateQueryOperator(IAggregateQueryOperator aggregateQueryOperatorParam, TContext context);
    public virtual TReturn VisitAggregatedRangeVariableDeclaration(IAggregatedRangeVariableDeclaration aggregatedRangeVariableDeclarationParam, TContext context);
    public virtual TReturn VisitAggregatedRangeVariableDeclarationList(IAggregatedRangeVariableDeclarationList aggregatedRangeVariableDeclarationListParam, TContext context);
    public virtual TReturn VisitAliasClause(IAliasClause aliasClauseParam, TContext context);
    public virtual TReturn VisitAnonymousArrayCreationExpression(IAnonymousArrayCreationExpression anonymousArrayCreationExpressionParam, TContext context);
    public virtual TReturn VisitAnonymousMemberDeclaration(IAnonymousMemberDeclaration anonymousMemberDeclarationParam, TContext context);
    public virtual TReturn VisitAnonymousObjectCreationExpression(IAnonymousObjectCreationExpression anonymousObjectCreationExpressionParam, TContext context);
    public virtual TReturn VisitAnonymousObjectInitializer(IAnonymousObjectInitializer anonymousObjectInitializerParam, TContext context);
    public virtual TReturn VisitArgumentList(IArgumentList argumentListParam, TContext context);
    public virtual TReturn VisitArrayBound(IArrayBound arrayBoundParam, TContext context);
    public virtual TReturn VisitArrayCreationExpression(IArrayCreationExpression arrayCreationExpressionParam, TContext context);
    public virtual TReturn VisitArrayModifier(IArrayModifier arrayModifierParam, TContext context);
    public virtual TReturn VisitArrayModifiersList(IArrayModifiersList arrayModifiersListParam, TContext context);
    public virtual TReturn VisitAssignmentStatement(IAssignmentStatement assignmentStatementParam, TContext context);
    public virtual TReturn VisitAttribute(IAttribute attributeParam, TContext context);
    public virtual TReturn VisitAttributeList(IAttributeList attributeListParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributeListOwner interface, so this visitor member will not be invoked")]
public virtual TReturn VisitAttributeListOwner(IAttributeListOwner attributeListOwnerParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements attributesOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitAttributesOwnerDeclaration(IAttributesOwnerDeclaration attributesOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitAwaitExpression(IAwaitExpression awaitExpressionParam, TContext context);
    public virtual TReturn VisitAwaitStatement(IAwaitStatement awaitStatementParam, TContext context);
    public virtual TReturn VisitBlock(IBlock blockParam, TContext context);
    public virtual TReturn VisitBlockIfStatement(IBlockIfStatement blockIfStatementParam, TContext context);
    public virtual TReturn VisitCaseClause(ICaseClause caseClauseParam, TContext context);
    public virtual TReturn VisitCaseStatement(ICaseStatement caseStatementParam, TContext context);
    public virtual TReturn VisitCastExpression(ICastExpression castExpressionParam, TContext context);
    public virtual TReturn VisitCatchStatement(ICatchStatement catchStatementParam, TContext context);
    public virtual TReturn VisitCatchVariableDeclaration(ICatchVariableDeclaration catchVariableDeclarationParam, TContext context);
    public virtual TReturn VisitCharsetModifier(ICharsetModifier charsetModifierParam, TContext context);
    public virtual TReturn VisitClassBaseClause(IClassBaseClause classBaseClauseParam, TContext context);
    public virtual TReturn VisitClassBody(IClassBody classBodyParam, TContext context);
    public virtual TReturn VisitClassDeclaration(IClassDeclaration classDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [classDeclaration, interfaceDeclaration, structureDeclaration] that directly implements classLikeDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitClassLikeDeclaration(IClassLikeDeclaration classLikeDeclarationParam, TContext context);
    public virtual TReturn VisitCollectionElementInitializer(ICollectionElementInitializer collectionElementInitializerParam, TContext context);
    public virtual TReturn VisitCollectionRangeVariableDeclaration(ICollectionRangeVariableDeclaration collectionRangeVariableDeclarationParam, TContext context);
    public virtual TReturn VisitConcatenationExpression(IConcatenationExpression concatenationExpressionParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements conditionalAccessExpression interface, so this visitor member will not be invoked")]
public virtual TReturn VisitConditionalAccessExpression(IConditionalAccessExpression conditionalAccessExpressionParam, TContext context);
    public virtual TReturn VisitConditionalAccessSign(IConditionalAccessSign conditionalAccessSignParam, TContext context);
    public virtual TReturn VisitConditionalExpression(IConditionalExpression conditionalExpressionParam, TContext context);
    public virtual TReturn VisitConstPreprocessorDirective(IConstPreprocessorDirective constPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitConstantDeclaration(IConstantDeclaration constantDeclarationParam, TContext context);
    public virtual TReturn VisitConstructorDeclaration(IConstructorDeclaration constructorDeclarationParam, TContext context);
    public virtual TReturn VisitContinueStatement(IContinueStatement continueStatementParam, TContext context);
    public virtual TReturn VisitControlReference(IControlReference controlReferenceParam, TContext context);
    public virtual TReturn VisitConversionOperatorDeclaration(IConversionOperatorDeclaration conversionOperatorDeclarationParam, TContext context);
    public virtual TReturn VisitDeclaredTypeUsage(IDeclaredTypeUsage declaredTypeUsageParam, TContext context);
    public virtual TReturn VisitDelegateDeclaration(IDelegateDeclaration delegateDeclarationParam, TContext context);
    public virtual TReturn VisitDictionaryAccessExpression(IDictionaryAccessExpression dictionaryAccessExpressionParam, TContext context);
    public virtual TReturn VisitDisableWarningPreprocessorDirective(IDisableWarningPreprocessorDirective disableWarningPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitDistinctQueryOperator(IDistinctQueryOperator distinctQueryOperatorParam, TContext context);
    public virtual TReturn VisitDoLoopStatement(IDoLoopStatement doLoopStatementParam, TContext context);
    public virtual TReturn VisitElseIfPreprocessorDirective(IElseIfPreprocessorDirective elseIfPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitElseIfStatement(IElseIfStatement elseIfStatementParam, TContext context);
    public virtual TReturn VisitElsePreprocessorDirective(IElsePreprocessorDirective elsePreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitElseStatement(IElseStatement elseStatementParam, TContext context);
    public virtual TReturn VisitEmptyArgument(IEmptyArgument emptyArgumentParam, TContext context);
    public virtual TReturn VisitEnableWarningPreprocessorDirective(IEnableWarningPreprocessorDirective enableWarningPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitEndExternalSourcePreprocessorDirective(IEndExternalSourcePreprocessorDirective endExternalSourcePreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitEndIfPreprocessorDirective(IEndIfPreprocessorDirective endIfPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitEndRegionPreprocessorDirective(IEndRegionPreprocessorDirective endRegionPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitEndStatement(IEndStatement endStatementParam, TContext context);
    public virtual TReturn VisitEnumDeclaration(IEnumDeclaration enumDeclarationParam, TContext context);
    public virtual TReturn VisitEnumMemberDeclaration(IEnumMemberDeclaration enumMemberDeclarationParam, TContext context);
    public virtual TReturn VisitEraseStatement(IEraseStatement eraseStatementParam, TContext context);
    public virtual TReturn VisitErrorStatement(IErrorStatement errorStatementParam, TContext context);
    public virtual TReturn VisitEventDeclaration(IEventDeclaration eventDeclarationParam, TContext context);
    public virtual TReturn VisitEventSpecifier(IEventSpecifier eventSpecifierParam, TContext context);
    public virtual TReturn VisitExitStatement(IExitStatement exitStatementParam, TContext context);
    public virtual TReturn VisitExponentiationExpression(IExponentiationExpression exponentiationExpressionParam, TContext context);
    public virtual TReturn VisitExpressionArgument(IExpressionArgument expressionArgumentParam, TContext context);
    public virtual TReturn VisitExpressionRangeVariableDeclaration(IExpressionRangeVariableDeclaration expressionRangeVariableDeclarationParam, TContext context);
    public virtual TReturn VisitExpressionRangeVariableDeclarationList(IExpressionRangeVariableDeclarationList expressionRangeVariableDeclarationListParam, TContext context);
    public virtual TReturn VisitExpressionStatement(IExpressionStatement expressionStatementParam, TContext context);
    public virtual TReturn VisitExternalChecksumPreprocessorDirective(IExternalChecksumPreprocessorDirective externalChecksumPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitExternalMethodDeclaration(IExternalMethodDeclaration externalMethodDeclarationParam, TContext context);
    public virtual TReturn VisitExternalSourcePreprocessorDirective(IExternalSourcePreprocessorDirective externalSourcePreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitFinallyStatement(IFinallyStatement finallyStatementParam, TContext context);
    public virtual TReturn VisitForEachStatement(IForEachStatement forEachStatementParam, TContext context);
    public virtual TReturn VisitForStatement(IForStatement forStatementParam, TContext context);
    public virtual TReturn VisitFromQueryOperator(IFromQueryOperator fromQueryOperatorParam, TContext context);
    public virtual TReturn VisitGetTypeExpression(IGetTypeExpression getTypeExpressionParam, TContext context);
    public virtual TReturn VisitGetXmlNamespaceExpression(IGetXmlNamespaceExpression getXmlNamespaceExpressionParam, TContext context);
    public virtual TReturn VisitGotoStatement(IGotoStatement gotoStatementParam, TContext context);
    public virtual TReturn VisitGroupByQueryOperator(IGroupByQueryOperator groupByQueryOperatorParam, TContext context);
    public virtual TReturn VisitGroupJoinQueryOperator(IGroupJoinQueryOperator groupJoinQueryOperatorParam, TContext context);
    public virtual TReturn VisitHandlesClause(IHandlesClause handlesClauseParam, TContext context);
    public virtual TReturn VisitIfPreprocessorDirective(IIfPreprocessorDirective ifPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitImplementsClause(IImplementsClause implementsClauseParam, TContext context);
    public virtual TReturn VisitImportAliasClause(IImportAliasClause importAliasClauseParam, TContext context);
    public virtual TReturn VisitImportClause(IImportClause importClauseParam, TContext context);
    public virtual TReturn VisitImportDirective(IImportDirective importDirectiveParam, TContext context);
    public virtual TReturn VisitImportDirectivesSection(IImportDirectivesSection importDirectivesSectionParam, TContext context);
    public virtual TReturn VisitImportNamespaceClause(IImportNamespaceClause importNamespaceClauseParam, TContext context);
    public virtual TReturn VisitImportXMLNamespaceClause(IImportXMLNamespaceClause importXMLNamespaceClauseParam, TContext context);
    public virtual TReturn VisitIndexExpression(IIndexExpression indexExpressionParam, TContext context);
    public virtual TReturn VisitInstanceExpression(IInstanceExpression instanceExpressionParam, TContext context);
    public virtual TReturn VisitIntegerDivisionExpression(IIntegerDivisionExpression integerDivisionExpressionParam, TContext context);
    public virtual TReturn VisitInterfaceDeclaration(IInterfaceDeclaration interfaceDeclarationParam, TContext context);
    public virtual TReturn VisitInterfaceInheritsClause(IInterfaceInheritsClause interfaceInheritsClauseParam, TContext context);
    public virtual TReturn VisitInterfaceMemberSpecifier(IInterfaceMemberSpecifier interfaceMemberSpecifierParam, TContext context);
    public virtual TReturn VisitInterpolatedStringExpression(IInterpolatedStringExpression interpolatedStringExpressionParam, TContext context);
    public virtual TReturn VisitInterpolatedStringInsert(IInterpolatedStringInsert interpolatedStringInsertParam, TContext context);
    public virtual TReturn VisitIntoOfAggregateQueryOperator(IIntoOfAggregateQueryOperator intoOfAggregateQueryOperatorParam, TContext context);
    public virtual TReturn VisitInvocationStatement(IInvocationStatement invocationStatementParam, TContext context);
    public virtual TReturn VisitIsExpression(IIsExpression isExpressionParam, TContext context);
    public virtual TReturn VisitIsNotExpression(IIsNotExpression isNotExpressionParam, TContext context);
    public virtual TReturn VisitJoinCollectionRangeVariableDeclaration(IJoinCollectionRangeVariableDeclaration joinCollectionRangeVariableDeclarationParam, TContext context);
    public virtual TReturn VisitJoinCondition(IJoinCondition joinConditionParam, TContext context);
    public virtual TReturn VisitJoinQueryConditionsListFake(IJoinQueryConditionsListFake joinQueryConditionsListFakeParam, TContext context);
    public virtual TReturn VisitJoinQueryOperator(IJoinQueryOperator joinQueryOperatorParam, TContext context);
    public virtual TReturn VisitLabelDeclaration(ILabelDeclaration labelDeclarationParam, TContext context);
    public virtual TReturn VisitLabelName(ILabelName labelNameParam, TContext context);
    public virtual TReturn VisitLabelReferencingStatement(ILabelReferencingStatement labelReferencingStatementParam, TContext context);
    public virtual TReturn VisitLabelStatement(ILabelStatement labelStatementParam, TContext context);
    public virtual TReturn VisitLambdaExpression(ILambdaExpression lambdaExpressionParam, TContext context);
    public virtual TReturn VisitLambdaFunctionExpression(ILambdaFunctionExpression lambdaFunctionExpressionParam, TContext context);
    public virtual TReturn VisitLambdaParameterDeclaration(ILambdaParameterDeclaration lambdaParameterDeclarationParam, TContext context);
    public virtual TReturn VisitLambdaSignature(ILambdaSignature lambdaSignatureParam, TContext context);
    public virtual TReturn VisitLambdaSubExpression(ILambdaSubExpression lambdaSubExpressionParam, TContext context);
    public virtual TReturn VisitLetQueryOperator(ILetQueryOperator letQueryOperatorParam, TContext context);
    public virtual TReturn VisitLibraryClause(ILibraryClause libraryClauseParam, TContext context);
    public virtual TReturn VisitLikeExpression(ILikeExpression likeExpressionParam, TContext context);
    public virtual TReturn VisitLineIfStatement(ILineIfStatement lineIfStatementParam, TContext context);
    public virtual TReturn VisitLineIfStatementBody(ILineIfStatementBody lineIfStatementBodyParam, TContext context);
    public virtual TReturn VisitLocalDeclarationList(ILocalDeclarationList localDeclarationListParam, TContext context);
    public virtual TReturn VisitLocalDeclarationStatement(ILocalDeclarationStatement localDeclarationStatementParam, TContext context);
    public virtual TReturn VisitLocalVariableDeclaration(ILocalVariableDeclaration localVariableDeclarationParam, TContext context);
    public virtual TReturn VisitLogicalAndExpression(ILogicalAndExpression logicalAndExpressionParam, TContext context);
    public virtual TReturn VisitLogicalNotExpression(ILogicalNotExpression logicalNotExpressionParam, TContext context);
    public virtual TReturn VisitLogicalOrExpression(ILogicalOrExpression logicalOrExpressionParam, TContext context);
    public virtual TReturn VisitLogicalXorExpression(ILogicalXorExpression logicalXorExpressionParam, TContext context);
    public virtual TReturn VisitLoopControlVariableDeclaration(ILoopControlVariableDeclaration loopControlVariableDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements loopStatement interface, so this visitor member will not be invoked")]
public virtual TReturn VisitLoopStatement(ILoopStatement loopStatementParam, TContext context);
    public virtual TReturn VisitMemberAccessExpression(IMemberAccessExpression memberAccessExpressionParam, TContext context);
    public virtual TReturn VisitMemberInitializer(IMemberInitializer memberInitializerParam, TContext context);
    public virtual TReturn VisitMethodDeclaration(IMethodDeclaration methodDeclarationParam, TContext context);
    public virtual TReturn VisitMethodDeclarationBase(IMethodDeclarationBase methodDeclarationBaseParam, TContext context);
    public virtual TReturn VisitMidAssignmentStatement(IMidAssignmentStatement midAssignmentStatementParam, TContext context);
    public virtual TReturn VisitModifiersList(IModifiersList modifiersListParam, TContext context);
    public virtual TReturn VisitModifiersListOwner(IModifiersListOwner modifiersListOwnerParam, TContext context);
    public virtual TReturn VisitModuleDeclaration(IModuleDeclaration moduleDeclarationParam, TContext context);
    public virtual TReturn VisitModulusExpression(IModulusExpression modulusExpressionParam, TContext context);
    public virtual TReturn VisitMultipleConstantDeclaration(IMultipleConstantDeclaration multipleConstantDeclarationParam, TContext context);
    public virtual TReturn VisitMultipleVariableDeclaration(IMultipleVariableDeclaration multipleVariableDeclarationParam, TContext context);
    public virtual TReturn VisitMultiplicativeExpression(IMultiplicativeExpression multiplicativeExpressionParam, TContext context);
    public virtual TReturn VisitNamedArgument(INamedArgument namedArgumentParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements namespaceMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitNamespaceMemberDeclaration(INamespaceMemberDeclaration namespaceMemberDeclarationParam, TContext context);
    public virtual TReturn VisitNamespacePrefixExpression(INamespacePrefixExpression namespacePrefixExpressionParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [objectCreationExpression] that directly implements newExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitNewExpression(INewExpression newExpressionParam, TContext context);
    public virtual TReturn VisitNextClause(INextClause nextClauseParam, TContext context);
    public virtual TReturn VisitObjectCollectionInitializer(IObjectCollectionInitializer objectCollectionInitializerParam, TContext context);
    public virtual TReturn VisitObjectCreationExpression(IObjectCreationExpression objectCreationExpressionParam, TContext context);
    public virtual TReturn VisitObjectCreationInitializer(IObjectCreationInitializer objectCreationInitializerParam, TContext context);
    public virtual TReturn VisitOnErrorSpecialLabel(IOnErrorSpecialLabel onErrorSpecialLabelParam, TContext context);
    public virtual TReturn VisitOnErrorStatement(IOnErrorStatement onErrorStatementParam, TContext context);
    public virtual TReturn VisitOperatorDeclaration(IOperatorDeclaration operatorDeclarationParam, TContext context);
    public virtual TReturn VisitOptionStatement(IOptionStatement optionStatementParam, TContext context);
    public virtual TReturn VisitOptionStatementsSection(IOptionStatementsSection optionStatementsSectionParam, TContext context);
    public virtual TReturn VisitOrderByQueryOperator(IOrderByQueryOperator orderByQueryOperatorParam, TContext context);
    public virtual TReturn VisitOrderExpression(IOrderExpression orderExpressionParam, TContext context);
    public virtual TReturn VisitParenthesizedExpression(IParenthesizedExpression parenthesizedExpressionParam, TContext context);
    public virtual TReturn VisitPartitionQueryOperator(IPartitionQueryOperator partitionQueryOperatorParam, TContext context);
    public virtual TReturn VisitPositionalArgument(IPositionalArgument positionalArgumentParam, TContext context);
    public virtual TReturn VisitPreprocessorDirective(IPreprocessorDirective preprocessorDirectiveParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [dictionaryAccessExpression, indexExpression] that directly implements primaryExpression and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitPrimaryExpression(IPrimaryExpression primaryExpressionParam, TContext context);
    public virtual TReturn VisitPropertyDeclaration(IPropertyDeclaration propertyDeclarationParam, TContext context);
    public virtual TReturn VisitPropertyInitializer(IPropertyInitializer propertyInitializerParam, TContext context);
    public virtual TReturn VisitQualifiedNamespaceName(IQualifiedNamespaceName qualifiedNamespaceNameParam, TContext context);
    public virtual TReturn VisitQueryAggregatedParameterPlatform(IQueryAggregatedParameterPlatform queryAggregatedParameterPlatformParam, TContext context);
    public virtual TReturn VisitQueryCollectionRangeVariableDeclaration(IQueryCollectionRangeVariableDeclaration queryCollectionRangeVariableDeclarationParam, TContext context);
    public virtual TReturn VisitQueryCollectionRangeVariableDeclarationList(IQueryCollectionRangeVariableDeclarationList queryCollectionRangeVariableDeclarationListParam, TContext context);
    public virtual TReturn VisitQueryConditionsList(IQueryConditionsList queryConditionsListParam, TContext context);
    public virtual TReturn VisitQueryExpression(IQueryExpression queryExpressionParam, TContext context);
    public virtual TReturn VisitQueryOperator(IQueryOperator queryOperatorParam, TContext context);
    public virtual TReturn VisitQueryParameter(IQueryParameter queryParameterParam, TContext context);
    public virtual TReturn VisitQueryParameterPlatform(IQueryParameterPlatform queryParameterPlatformParam, TContext context);
    public virtual TReturn VisitRaiseEventStatement(IRaiseEventStatement raiseEventStatementParam, TContext context);
    public virtual TReturn VisitRedimClause(IRedimClause redimClauseParam, TContext context);
    public virtual TReturn VisitRedimStatement(IRedimStatement redimStatementParam, TContext context);
    public virtual TReturn VisitReferenceExpression(IReferenceExpression referenceExpressionParam, TContext context);
    public virtual TReturn VisitReferenceName(IReferenceName referenceNameParam, TContext context);
    public virtual TReturn VisitRegionPreprocessorDirective(IRegionPreprocessorDirective regionPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitRegularParameterDeclaration(IRegularParameterDeclaration regularParameterDeclarationParam, TContext context);
    public virtual TReturn VisitRegularParameterList(IRegularParameterList regularParameterListParam, TContext context);
    public virtual TReturn VisitRelationalExpression(IRelationalExpression relationalExpressionParam, TContext context);
    public virtual TReturn VisitRemoveHandlerStatement(IRemoveHandlerStatement removeHandlerStatementParam, TContext context);
    public virtual TReturn VisitResumeStatement(IResumeStatement resumeStatementParam, TContext context);
    public virtual TReturn VisitReturnAttributeList(IReturnAttributeList returnAttributeListParam, TContext context);
    public virtual TReturn VisitReturnStatement(IReturnStatement returnStatementParam, TContext context);
    public virtual TReturn VisitSelectQueryOperator(ISelectQueryOperator selectQueryOperatorParam, TContext context);
    public virtual TReturn VisitSelectStatement(ISelectStatement selectStatementParam, TContext context);
    public virtual TReturn VisitShiftExpression(IShiftExpression shiftExpressionParam, TContext context);
    public virtual TReturn VisitSignOperatorDeclaration(ISignOperatorDeclaration signOperatorDeclarationParam, TContext context);
    public virtual TReturn VisitStopStatement(IStopStatement stopStatementParam, TContext context);
    public virtual TReturn VisitStructureDeclaration(IStructureDeclaration structureDeclarationParam, TContext context);
    public virtual TReturn VisitSyncLockStatement(ISyncLockStatement syncLockStatementParam, TContext context);
    public virtual TReturn VisitThrowStatement(IThrowStatement throwStatementParam, TContext context);
    public virtual TReturn VisitTryStatement(ITryStatement tryStatementParam, TContext context);
    public virtual TReturn VisitTupleComponent(ITupleComponent tupleComponentParam, TContext context);
    public virtual TReturn VisitTupleDeclaredTypeUsage(ITupleDeclaredTypeUsage tupleDeclaredTypeUsageParam, TContext context);
    public virtual TReturn VisitTupleExpression(ITupleExpression tupleExpressionParam, TContext context);
    public virtual TReturn VisitTupleTypeComponent(ITupleTypeComponent tupleTypeComponentParam, TContext context);
    public virtual TReturn VisitTupleTypeUsage(ITupleTypeUsage tupleTypeUsageParam, TContext context);
    public virtual TReturn VisitTypeArgumentList(ITypeArgumentList typeArgumentListParam, TContext context);
    public virtual TReturn VisitTypeImplementsClause(ITypeImplementsClause typeImplementsClauseParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements typeMemberOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitTypeMemberOwnerDeclaration(ITypeMemberOwnerDeclaration typeMemberOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitTypeOfIsExpression(ITypeOfIsExpression typeOfIsExpressionParam, TContext context);
    public virtual TReturn VisitTypeParameterConstraint(ITypeParameterConstraint typeParameterConstraintParam, TContext context);
    public virtual TReturn VisitTypeParameterConstraintList(ITypeParameterConstraintList typeParameterConstraintListParam, TContext context);
    public virtual TReturn VisitTypeParameterDeclaration(ITypeParameterDeclaration typeParameterDeclarationParam, TContext context);
    public virtual TReturn VisitTypeParameterOfMethodDeclaration(ITypeParameterOfMethodDeclaration typeParameterOfMethodDeclarationParam, TContext context);
    public virtual TReturn VisitTypeParameterOfMethodList(ITypeParameterOfMethodList typeParameterOfMethodListParam, TContext context);
    public virtual TReturn VisitTypeParameterOfTypeDeclaration(ITypeParameterOfTypeDeclaration typeParameterOfTypeDeclarationParam, TContext context);
    public virtual TReturn VisitTypeParameterOfTypeList(ITypeParameterOfTypeList typeParameterOfTypeListParam, TContext context);
    public virtual TReturn VisitTypeUsage(ITypeUsage typeUsageParam, TContext context);
    public virtual TReturn VisitUnaryNegationExpression(IUnaryNegationExpression unaryNegationExpressionParam, TContext context);
    public virtual TReturn VisitUnknownPreprocessorDirective(IUnknownPreprocessorDirective unknownPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitUserDeclaredTypeUsage(IUserDeclaredTypeUsage userDeclaredTypeUsageParam, TContext context);
    public virtual TReturn VisitUserTypeUsage(IUserTypeUsage userTypeUsageParam, TContext context);
    public virtual TReturn VisitUsingStatement(IUsingStatement usingStatementParam, TContext context);
    public virtual TReturn VisitUsingVariableDeclaration(IUsingVariableDeclaration usingVariableDeclarationParam, TContext context);
    public virtual TReturn VisitVBArgument(IVBArgument vBArgumentParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [indexExpression, midAssignmentStatement, objectCreationExpression] that directly implements vBArgumentsOwner and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitVBArgumentsOwner(IVBArgumentsOwner vBArgumentsOwnerParam, TContext context);
    public virtual TReturn VisitVBBinaryExpression(IVBBinaryExpression vBBinaryExpressionParam, TContext context);
    public virtual TReturn VisitVBDeclaration(IVBDeclaration vBDeclarationParam, TContext context);
    public virtual TReturn VisitVBExpression(IVBExpression vBExpressionParam, TContext context);
    public virtual TReturn VisitVBFile(IVBFile vBFileParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [constructorDeclaration] that directly implements vBFunctionDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitVBFunctionDeclaration(IVBFunctionDeclaration vBFunctionDeclarationParam, TContext context);
    public virtual TReturn VisitVBIdentifier(IVBIdentifier vBIdentifierParam, TContext context);
    public virtual TReturn VisitVBLiteralExpression(IVBLiteralExpression vBLiteralExpressionParam, TContext context);
    public virtual TReturn VisitVBLocalVariableDeclaration(IVBLocalVariableDeclaration vBLocalVariableDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBModifiersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitVBModifiersOwnerDeclaration(IVBModifiersOwnerDeclaration vBModifiersOwnerDeclarationParam, TContext context);
    public virtual TReturn VisitVBNamespaceDeclaration(IVBNamespaceDeclaration vBNamespaceDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [regularParameterDeclaration] that directly implements vBParameterDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitVBParameterDeclaration(IVBParameterDeclaration vBParameterDeclarationParam, TContext context);
    public virtual TReturn VisitVBParameterDeclarationList(IVBParameterDeclarationList vBParameterDeclarationListParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBParametersOwnerDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitVBParametersOwnerDeclaration(IVBParametersOwnerDeclaration vBParametersOwnerDeclarationParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [midAssignmentStatement] that directly implements vBStatement and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitVBStatement(IVBStatement vBStatementParam, TContext context);
    [ObsoleteAttribute("There are Nodes in PSI [vBNamespaceDeclaration] that directly implements vBTypeAndNamespaceHolderDeclaration and other interfaces, so this visitor member will not be invoked for these nodes")]
public virtual TReturn VisitVBTypeAndNamespaceHolderDeclaration(IVBTypeAndNamespaceHolderDeclaration vBTypeAndNamespaceHolderDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBTypeDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitVBTypeDeclaration(IVBTypeDeclaration vBTypeDeclarationParam, TContext context);
    [ObsoleteAttribute("There is no Node in PSI that directly implements vBTypeMemberDeclaration interface, so this visitor member will not be invoked")]
public virtual TReturn VisitVBTypeMemberDeclaration(IVBTypeMemberDeclaration vBTypeMemberDeclarationParam, TContext context);
    public virtual TReturn VisitVBUnaryExpression(IVBUnaryExpression vBUnaryExpressionParam, TContext context);
    public virtual TReturn VisitVBXmlAttribute(IVBXmlAttribute vBXmlAttributeParam, TContext context);
    public virtual TReturn VisitVBXmlCDataSection(IVBXmlCDataSection vBXmlCDataSectionParam, TContext context);
    public virtual TReturn VisitVBXmlComment(IVBXmlComment vBXmlCommentParam, TContext context);
    public virtual TReturn VisitVBXmlDocument(IVBXmlDocument vBXmlDocumentParam, TContext context);
    public virtual TReturn VisitVBXmlElement(IVBXmlElement vBXmlElementParam, TContext context);
    public virtual TReturn VisitVBXmlElementFooter(IVBXmlElementFooter vBXmlElementFooterParam, TContext context);
    public virtual TReturn VisitVBXmlElementHeader(IVBXmlElementHeader vBXmlElementHeaderParam, TContext context);
    public virtual TReturn VisitVBXmlEmbeddedExpression(IVBXmlEmbeddedExpression vBXmlEmbeddedExpressionParam, TContext context);
    public virtual TReturn VisitVBXmlLiteralExpression(IVBXmlLiteralExpression vBXmlLiteralExpressionParam, TContext context);
    public virtual TReturn VisitVBXmlMemberAccessExpression(IVBXmlMemberAccessExpression vBXmlMemberAccessExpressionParam, TContext context);
    public virtual TReturn VisitVBXmlMisc(IVBXmlMisc vBXmlMiscParam, TContext context);
    public virtual TReturn VisitVBXmlProcessingInstruction(IVBXmlProcessingInstruction vBXmlProcessingInstructionParam, TContext context);
    public virtual TReturn VisitVariableDeclaration(IVariableDeclaration variableDeclarationParam, TContext context);
    public virtual TReturn VisitVariableDeclarationList(IVariableDeclarationList variableDeclarationListParam, TContext context);
    public virtual TReturn VisitWarningPreprocessorDirective(IWarningPreprocessorDirective warningPreprocessorDirectiveParam, TContext context);
    public virtual TReturn VisitWhereQueryOperator(IWhereQueryOperator whereQueryOperatorParam, TContext context);
    public virtual TReturn VisitWhileStatement(IWhileStatement whileStatementParam, TContext context);
    public virtual TReturn VisitWhileUntilCondition(IWhileUntilCondition whileUntilConditionParam, TContext context);
    public virtual TReturn VisitWithStatement(IWithStatement withStatementParam, TContext context);
    public virtual TReturn VisitYieldStatement(IYieldStatement yieldStatementParam, TContext context);
    public virtual TReturn VisitDocCommentBlockNode(IDocCommentBlock xmlDoc, TContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TryStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITryStatement GetByCatchStatement(ICatchStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITryStatement GetByFinallyStatement(IFinallyStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITryStatement GetByTryBlock(IBlock param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TupleComponentNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleComponent GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleComponent GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TupleDeclaredTypeUsageNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleDeclaredTypeUsage GetByComponent(ITupleTypeComponent param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TupleExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleExpression GetByComponent(ITupleComponent param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TupleTypeComponentNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleTypeComponent GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleTypeComponent GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TupleTypeUsageNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleTypeUsage GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITupleTypeUsage GetByComponent(ITupleTypeComponent param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeArgumentListNavigator : object {
    public static ITypeArgumentList GetByTypeArgument(ITypeUsage typeUsage);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeImplementsClauseNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeImplementsClause GetByImplementsType(IDeclaredTypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeMemberOwnerDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberOwnerDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberOwnerDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberOwnerDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeMemberOwnerDeclaration GetByName(IVBIdentifier param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.TypeOfExpressionKind : Enum {
    public int value__;
    public static TypeOfExpressionKind Is;
    public static TypeOfExpressionKind IsNot;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeOfIsExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeOfIsExpression GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeOfIsExpression GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeParameterConstraintListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterConstraintList GetByConstraint(ITypeParameterConstraint param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeParameterConstraintNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterConstraint GetByTypeUsage(IUserTypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterDeclaration GetByConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterDeclaration GetByConstraintList(ITypeParameterConstraintList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterDeclaration GetByName(IVBIdentifier param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeParameterOfMethodDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfMethodDeclaration GetByConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfMethodDeclaration GetByConstraintList(ITypeParameterConstraintList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfMethodDeclaration GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeParameterOfMethodListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfMethodList GetByTypeParameterDeclaration(ITypeParameterOfMethodDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeParameterOfTypeDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfTypeDeclaration GetByConstraint(ITypeParameterConstraint param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfTypeDeclaration GetByConstraintList(ITypeParameterConstraintList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfTypeDeclaration GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeParameterOfTypeListNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameterOfTypeList GetByTypeParameterDeclaration(ITypeParameterOfTypeDeclaration param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.TypeUsageNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeUsage GetByArrayModifiersList(IArrayModifiersList param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.UnaryNegationExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUnaryNegationExpression GetByExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.UnknownPreprocessorDirectiveNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.UserDeclaredTypeUsageNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUserDeclaredTypeUsage GetByTypeName(IReferenceName param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.UserTypeUsageNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUserTypeUsage GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUserTypeUsage GetByTypeName(IReferenceName param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.UsingStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingStatement GetByExpression(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingStatement GetByVariableDeclaration(IUsingVariableDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.UsingVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingVariableDeclaration GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingVariableDeclaration GetByCreationExpression(IObjectCreationExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingVariableDeclaration GetByInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IUsingVariableDeclaration GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VariableDeclarationListNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVariableDeclarationList GetByCreationExpression(IObjectCreationExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVariableDeclarationList GetByDeclaration(IVariableDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVariableDeclarationList GetByInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVariableDeclarationList GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVariableDeclaration GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IVariableDeclaration> GetByAttribute(IAttribute param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IVariableDeclaration> GetByCreationExpression(IObjectCreationExpression param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IVariableDeclaration> GetByInitializer(IVBExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[NotNullAttribute]
public static TreeNodeCollection`1<IVariableDeclaration> GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBArgumentNavigator : object {
    [CanBeNullAttribute]
public static IVBArgument GetByExpression(IVBExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBArgumentsOwnerExtentions : object {
    [CanBeNullAttribute]
public static IVBArgumentsOwner GetOrCreateArgumentOwner(IReference& reference);
    [ExtensionAttribute]
public static TreeNodeCollection`1<IVBArgument> VbArguments(IVBArgumentsOwner argumentsOwner);
    [CanBeNullAttribute]
public static IVBArgumentsOwner GetArgumentsOwner(IReference reference);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBArgumentsOwnerNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBArgumentsOwner GetByArgument(IVBArgument param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBArgumentsOwner GetByArgumentList(IArgumentList param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBBinaryExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBBinaryExpression GetByLeftExpr(IVBExpression param);
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBBinaryExpression GetByRightExpr(IVBExpression param);
    public static IVBBinaryExpression GetByLeftOperand(IVBExpression leftOperand);
    public static IVBBinaryExpression GetByRightOperand(IVBExpression rightOperand);
}
public abstract class JetBrains.ReSharper.Psi.VB.Tree.VBCompositeNodeType : CompositeNodeType {
    protected VBCompositeNodeType(string s, int index);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBDeclarationNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBExpressionExtensions : object {
    private static bool IsLetVariable(IExpressionRangeVariableDeclaration variable);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IDeclaredElement GetInitializedDeclaredElement(IVBExpression expression);
    [ExtensionAttribute]
public static string GetProjectedIdentifierName(IVBExpression expression);
    [ExtensionAttribute]
public static bool ProvidesProjectedName(IVBExpression expression);
    [ExtensionAttribute]
public static TExpression TransformProjectedNameToExplicit(TExpression expression);
    [ExtensionAttribute]
public static TExpression TransformProjectedNameToImplicit(TExpression expression);
    private static bool TryTransformProjectedNameToExplicitInternal(IVBExpression& expression);
    private static bool TryTransformProjectedNameToImplicitInternal(IVBExpression& expression);
    private static bool ProvidesProjectedNameInternal(IVBExpression expression);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBExpressionNavigator : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBFileExtensions : object {
    private static bool IsOptionOn(IVBFile file, Nullable`1<VBFileOption> fileOption, Func`2<IVBPsiSourceFileProperties, bool> projectIsOn);
    [ExtensionAttribute]
public static bool IsStrictOff(IVBFile file);
    [ExtensionAttribute]
public static bool IsInferOff(IVBFile file);
    [ExtensionAttribute]
public static bool IsExplicitOff(IVBFile file);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBFileNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFile GetByGlobalAttributes(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFile GetByImport(IImportClause param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFile GetByImportsSection(IImportDirectivesSection param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFile GetByNamespaceDeclaration(IVBNamespaceDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFile GetByOption(IOptionStatement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFile GetByOptionsSection(IOptionStatementsSection param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFile GetByTypeDeclaration(IVBTypeDeclaration param);
}
public enum JetBrains.ReSharper.Psi.VB.Tree.VBFileOption : Enum {
    public int value__;
    public static VBFileOption On;
    public static VBFileOption Off;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBFunctionDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFunctionDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFunctionDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFunctionDeclaration GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFunctionDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFunctionDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBFunctionDeclaration GetByParameterList(IRegularParameterList param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBIdentifierNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBLiteralExpressionNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBLocalVariableDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBLocalVariableDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
public static TreeNodeCollection`1<IVBLocalVariableDeclaration> GetByTypeUsage(ITypeUsage param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBModifiersOwnerDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static TreeNodeCollection`1<IVBModifiersOwnerDeclaration> GetByAttribute(IAttribute param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBNamespaceDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBNamespaceDeclaration GetByNamespaceDeclaration(IVBNamespaceDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBNamespaceDeclaration GetByQualifiedNamespaceName(IQualifiedNamespaceName param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBNamespaceDeclaration GetByTypeDeclaration(IVBTypeDeclaration param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBParameterDeclarationListNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBParameterDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBParameterDeclaration GetByArrayModifiersList(IArrayModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBParameterDeclaration GetByName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBParameterDeclaration GetByTypeUsage(ITypeUsage param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBParametersOwnerDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBParametersOwnerDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBParametersOwnerDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBParametersOwnerDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBParametersOwnerDeclaration GetByParameterDeclaration(IRegularParameterDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBParametersOwnerDeclaration GetByParameterList(IRegularParameterList param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBStatementExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IVBStatement GetPreviousStatementInBlock(IVBStatement statement);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IVBStatement GetNextStatementInBlock(IVBStatement statement);
    [ExtensionAttribute]
public static bool TryRemove(IVBStatement statement);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBStatementNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBTypeAndNamespaceHolderDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBTypeAndNamespaceHolderDeclaration GetByNamespaceDeclaration(IVBNamespaceDeclaration param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBTypeAndNamespaceHolderDeclaration GetByTypeDeclaration(IVBTypeDeclaration param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBTypeDeclarationNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBTypeDeclaration GetByAttribute(IAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBTypeDeclaration GetByAttributeList(IAttributeList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBTypeDeclaration GetByModifiersList(IModifiersList param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBTypeDeclaration GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBTypeMemberDeclarationNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static TreeNodeCollection`1<IVBTypeMemberDeclaration> GetByAttribute(IAttribute param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBUnaryExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBUnaryExpression GetByExpression(IVBExpression param);
    public static IVBUnaryExpression GetByOperand(IVBExpression operand);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlAttributeNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlAttribute GetByEmbeddedAttribute(IVBXmlEmbeddedExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlCDataSectionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlCommentNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlDocumentNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlDocument GetByXmlDocumentElement(IVBXmlElement param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlDocument GetByXmlDocumentExpression(IVBXmlEmbeddedExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlElementFooterNavigator : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlElementHeaderNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlElementHeader GetByAttribute(IVBXmlAttribute param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlElementHeader GetByEmbeddedExpression(IVBXmlEmbeddedExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlElementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlElement GetByElementFooter(IVBXmlElementFooter param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlElement GetByElementHeader(IVBXmlElementHeader param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlElement GetByEmbeddedExpressio(IVBXmlEmbeddedExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlElement GetByNestedElement(IVBXmlElement param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlEmbeddedExpressionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlEmbeddedExpression GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlLiteralExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlLiteralExpression GetByXmlCData(IVBXmlCDataSection param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlLiteralExpression GetByXmlDocument(IVBXmlDocument param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlMemberAccessExpressionNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlMemberAccessExpression GetByAttributeName(IVBIdentifier param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlMemberAccessExpression GetByBaseExpression(IPrimaryExpression param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IVBXmlMemberAccessExpression GetByConditionalAccessSign(IConditionalAccessSign param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlMiscNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.VBXmlProcessingInstructionNavigator : object {
}
public static class JetBrains.ReSharper.Psi.VB.Tree.WarningPreprocessorDirectiveNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWarningPreprocessorDirective GetByName(IVBIdentifier param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.WhereQueryOperatorNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWhereQueryOperator GetByExpression(IQueryParameterPlatform param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.WhileStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWhileStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWhileStatement GetByExpression(IVBExpression param);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.WhileUntilConditionNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWhileUntilCondition GetByExpression(IVBExpression param);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.VB.Tree.WithStatementNavigator : object {
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWithStatement GetByBlock(IBlock param);
    [PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IWithStatement GetByExpression(IVBExpression param);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Tree.YieldStatementExt : object {
    [ExtensionAttribute]
public static IVBDeclaration GetContainingIteratorDeclaration(IYieldStatement yieldStatement);
    [ExtensionAttribute]
public static IType GetIteratorFunctionElementType(IYieldStatement yieldStatement);
    [ExtensionAttribute]
public static IType GetIteratorFunctionReturnType(IYieldStatement yieldStatement);
}
public static class JetBrains.ReSharper.Psi.VB.Tree.YieldStatementNavigator : object {
    [NullableContextAttribute("2")]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IYieldStatement GetByExpression(IVBExpression param);
}
public enum JetBrains.ReSharper.Psi.VB.Types.ConversionClassification : Enum {
    public int value__;
    public static ConversionClassification NotConvertible;
    public static ConversionClassification NarrowingStrictOff;
    public static ConversionClassification NarrowingNumericConst;
    public static ConversionClassification NarrowingLateBound;
    public static ConversionClassification WideningStrictOn;
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBAnonymousArrayType {
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IExpressionType> ElementsExpressionTypes { get; }
    [PureAttribute]
public abstract virtual bool IsEmpty();
    [PureAttribute]
public abstract virtual int Rank();
    public abstract virtual IReadOnlyList`1<IExpressionType> get_ElementsExpressionTypes();
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBAnonymousType {
    public IList`1<IVBAnonymousTypeProperty> Properties { get; }
    public abstract virtual IList`1<IVBAnonymousTypeProperty> get_Properties();
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBConstantType {
    public abstract virtual IType GetDefaultType();
    public abstract virtual ConstantValue GetConstantValue();
    public abstract virtual bool IsPureZeroType();
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBInterpolatedStringExpressionType {
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBInvocationType {
    public abstract virtual IVBMethodGroupType CreateMethodGroupType(IResolveContext resolveContext, VBLanguageLevel languageLevel);
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBLambdaExpressionType {
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    [CanBeNullAttribute]
public IType DeclaredReturnType { get; }
    public IVBTreeNode VerificationScope { get; }
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsIterator();
    public abstract virtual IType get_DeclaredReturnType();
    public abstract virtual IReadOnlyList`1<Pair`2<IType, ParameterKind>> GetParameterTypesAndKinds();
    public abstract virtual IReadOnlyList`1<IExpressionType> GetReturnValues();
    public abstract virtual IType CreateFunctionType();
    public abstract virtual IVBTreeNode get_VerificationScope();
    public abstract virtual bool HasImplicitLambdaParameters();
    public abstract virtual IReadOnlyList`1<ILambdaParameter> GetImplicitLambdaParameters();
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBMethodGroupType {
    public abstract virtual IType ReturnTypeWithDelegate(IDelegate delegate, ISubstitution delegateSubstitution);
    public abstract virtual DeclaredElementInstance`1<IMethod> ResolveWithDelegate(IDelegate delegate, ISubstitution delegateSubstitution);
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBNothingType {
}
public interface JetBrains.ReSharper.Psi.VB.Types.IVBTypeConversionRule {
    public IPsiModule Module { get; }
    public abstract virtual ConversionClassification IsImplicitlyConvertibleToClassify(IExpressionType from, IType to);
    public abstract virtual bool IsStrictOff();
    public abstract virtual IPsiModule get_Module();
    public abstract virtual bool IsImplicitlyConvertiblePredefined(IExpressionType from, IType to);
    public abstract virtual bool IsExplicitlyConvertiblePredefined(IExpressionType from, IType to);
    public abstract virtual bool IsImplicitlyConvertibleUserDefined(IExpressionType from, IType to);
    public abstract virtual bool IsExplicitlyConvertibleUserDefined(IExpressionType from, IType to);
}
public class JetBrains.ReSharper.Psi.VB.Types.VBFunctionTypeDecoration : TypeDecoration {
    public static VBFunctionTypeDecoration Instance;
    private static VBFunctionTypeDecoration();
    public virtual ITypeDecorationPointer CreatePointer();
    private sealed virtual override TypeDecoration JetBrains.ReSharper.Psi.ITypeDecorationPointer.Find();
    public virtual bool Equals(TypeDecoration other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string PresentType(IType decoratedType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Types.VBFunctionTypeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsVBFunctionType(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<DecoratedType`1<VBFunctionTypeDecoration>> AsVBFunctionType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IDelegate GetDelegateTypeElement(DecoratedType`1<VBFunctionTypeDecoration> functionType);
}
public class JetBrains.ReSharper.Psi.VB.Types.VBInterpolatedStringExpressionType : object {
    [NotNullAttribute]
private IPsiModule myModule;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public VBInterpolatedStringExpressionType(IPsiModule module);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
    public NullableAnnotation get_NullableAnnotation();
    public static IType GetPrimaryType(PredefinedType predefinedType);
    public static ICollection`1<IType> GetAdditionalTypes(PredefinedType predefinedType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Types.VBLambdaExpressionTypeUtil : object {
    [ExtensionAttribute]
public static IExpressionType InferredResultType(IVBLambdaExpressionType lambdaExpressionType, IVBTypeConversionRule rule);
    [ExtensionAttribute]
public static IExpressionType ReturnType(IVBLambdaExpressionType lambdaExpressionType, IVBTypeConversionRule rule);
    [ExtensionAttribute]
public static bool IsSignatureConvertibleWidening(IVBLambdaExpressionType lambda, IDelegate delegate, ISubstitution delegateSubstitution, ITypeConversionRule rule);
    [ExtensionAttribute]
public static bool IsSignatureConvertibleNarrowing(IVBLambdaExpressionType lambda, IDelegate delegate, ISubstitution delegateSubstitution, ITypeConversionRule rule);
    [ExtensionAttribute]
public static bool IsReturnTypeConvertibleWidening(IVBLambdaExpressionType lambda, IDelegate delegate, ISubstitution delegateSubstitution, ITypeConversionRule rule);
    [ExtensionAttribute]
public static bool IsReturnTypeConvertibleNarrowing(IVBLambdaExpressionType lambda, IDelegate delegate, ISubstitution delegateSubstitution, ITypeConversionRule rule);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Types.VBTypeConversionRule : object {
    [NotNullAttribute]
private static Key`1<IVBTypeConversionRule> ourStrictTypeConversionRuleKey;
    private static Key`1<IVBTypeConversionRule> ourNonStrictTypeConversionRuleKey;
    private static VBTypeConversionRule();
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IType ToITypeWithNothing(IExpressionType expressionType, IPsiModule module);
    [ExtensionAttribute]
[NotNullAttribute]
public static IExpressionType CreateConstantType(ConstantValue constantValue, IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IVBTypeConversionRule GetStrictTypeConversionRule(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IVBTypeConversionRule GetNonStrictTypeConversionRule(IPsiModule module);
    [NotNullAttribute]
[PureAttribute]
public static IVBTypeConversionRule GetInstance(IPsiModule module, bool strictOff);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IVBTypeConversionRule GetTypeConversionRule(ITreeNode context);
    public static void SetStrictOffConversionIsUsed(IVBTypeConversionRule rule);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Util.BlockUtil : object {
    public static IBlock GetFirstBlock(IVBStatement statement);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Util.BlockUtil/<AllBlocks>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<IBlock> AllBlocks(IBlockIfStatement ifStatement);
    [ExtensionAttribute]
public static IEnumerable`1<IBlock> AllBlocks(ISelectStatement selStatement);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Util.BlockUtil/<AllBlocks>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<IBlock> AllBlocks(ITryStatement tryStatement);
    public static IBlock GetPreviousBlock(IVBStatement statement);
    public static IBlock GetNextBlock(IVBStatement statement);
    private static IEnumerable`1<IBlock> GetAllBlocks(IBlock curBlock);
}
public static class JetBrains.ReSharper.Psi.VB.Util.ConditionalExpressionUtil : object {
    private static Pair`2<IExpressionType, TypeErrors> NoConversion;
    private static Pair`2<IExpressionType, TypeErrors> BothConversions;
    private static ConditionalExpressionUtil();
    public static Pair`2<IExpressionType, TypeErrors> GetNullCoalescingDominantType(IExpressionType leftExpressionType, IExpressionType rightExpressionType, IVBTypeConversionRule rule);
    public static Pair`2<IExpressionType, TypeErrors> GetTernaryDominantType(IExpressionType thenExpressionType, IExpressionType elseExpressionType, IVBTypeConversionRule rule);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Util.ConstraintsUtil : object {
    public static void RemoveConstraint(ITypeParameterConstraintList constraintList, ITypeParameterConstraint constraint);
    public static IEnumerable`1<ITypeParameterConstraint> AddConstructorConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddValueConstraint(ITypeParameter typeParameter);
    public static IEnumerable`1<ITypeParameterConstraint> AddClassConstraint(ITypeParameter typeParameter);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Util.ConstraintsUtil/<AddConstraint>d__4")]
private static IEnumerable`1<ITypeParameterConstraint> AddConstraint(string constraintText, ITypeParameter typeParameter);
    [ExtensionAttribute]
public static void AddConstraint(ITypeParameterOfTypeDeclaration typeParameter, ITypeParameterConstraint constraintToAdd);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Util.FunctionInvocationProvider : object {
    public sealed virtual IFunctionInvocationClrWrapper GetFunctionInvocationByArgument(IExpression expression);
    public sealed virtual IFunctionInvocationClrWrapper SurroundWithStaticMethodInvocation(IFunction method, IExpression surroundedExpression, IPsiModule psiModule);
    public sealed virtual bool IsArgumentOfMethodThatHasSimilarFormattingMethod(IExpression argumentExpression, IFunction& properFormattingMethod);
    public sealed virtual bool IsArgumentOfFormattingFunction(IExpression argumentExpression, FormattingFunctionKind& formattingFunctionKind);
    public sealed virtual bool ExpressionCanBeReplacedByMethodInvocation(IExpression expression);
    public sealed virtual IFunctionInvocationClrWrapper GetFunctionInvocationByArgumentsOwner(IArgumentsOwner argumentsOwner);
    public sealed virtual IExpression GetNarrowestContainingArgumentExpression(IExpression expression);
}
public interface JetBrains.ReSharper.Psi.VB.Util.IDomainSpecificWithEventsFieldRecongnizer {
    public abstract virtual bool IsWithEvents(IField field);
}
public static class JetBrains.ReSharper.Psi.VB.Util.IndexExpressionUtil : object {
    public static ExtensionInstance`1<IMethod> GetInvokedMethod(IIndexExpression expression);
}
public static class JetBrains.ReSharper.Psi.VB.Util.MemberInitializerUtil : object {
    public static InitializerErrorType AnalyseDeclaredElement(IDeclaredElement declaredElement, IAccessContext accessContext, ITreeNode usageContext);
}
public class JetBrains.ReSharper.Psi.VB.Util.ReturnTypeCollector : TreeNodeVisitor {
    private IResolveContext myResolveContext;
    private List`1<IExpressionType> myCollectedTypes;
    public IList`1<IExpressionType> CollectedTypes { get; }
    public bool ProcessingIsFinished { get; }
    public ReturnTypeCollector(IPsiModule module);
    public ReturnTypeCollector(IResolveContext resolveContext);
    public IList`1<IExpressionType> get_CollectedTypes();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public virtual void VisitReturnStatement(IReturnStatement returnStatementParam);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Util.StatementUtil : object {
    private static IClrTypeName CodeContractsClass;
    private static StatementUtil();
    public static T InsertStatement(T statement, U& anchor, bool before);
    public static T InsertStatement(T statement, IVBStatementsRange anchor, bool before);
    private static T InsertStatement(T statement, IVBStatementsRange& anchor, bool before);
    public static bool IsMethodBlock(IBlock block);
    public static IBlockIfStatement ConvertToBlock(ILineIfStatement lineIfStatement);
    [ExtensionAttribute]
public static bool IsCheckOfCodeInvariant(IVBStatement statement);
    private static bool IsCheckOfCodeInvariant(IVBStatement statement, IResolveContext resolveContext, Predicate`1<IMethod> isAssertionMethod);
    [CanBeNullAttribute]
[PureAttribute]
private static IVBStatement GetSingleThenStatement(ILineIfStatement ifStatement);
    [CanBeNullAttribute]
[PureAttribute]
private static IVBStatement GetSingleThenStatement(IBlockIfStatement ifStatement);
}
public static class JetBrains.ReSharper.Psi.VB.Util.StringLiteralCharacterUtil : object {
    public static bool TryConvertRegularPresentationToValue(string charPresentation, String& result);
    public static bool TryConvertVerbatimPresentationToValue(string presentation, String& result);
    public static string ConvertPresentationToValue(string presentation);
    public static string ConvertValueToPresentation(string value);
    public static string ConvertValueToRegularPresentation(string value);
    public static string ConvertValueToVerbatimPresentation(string value);
    public static string ConvertValueToPresentationSequence(char value);
}
public static class JetBrains.ReSharper.Psi.VB.Util.StringLiteralUtil : object {
    public static int GetCharPresentationLength(string presentation, int firstCharInPresentationIndex);
    public static string ConvertValueToPresentation(string value);
}
public class JetBrains.ReSharper.Psi.VB.Util.VbArgumentsOwnerInvocationClrWrapper : object {
    [NotNullAttribute]
private IVBArgumentsOwner myVbArgumentsOwner;
    [CanBeNullAttribute]
protected IReadOnlyList`1<IExpression> myArguments;
    public IParametersOwner InvokedFunction { get; }
    public IReadOnlyList`1<IParametersOwner> InvokedFunctionCandidates { get; }
    public IArgumentsOwner ArgumentsOwner { get; }
    public IReadOnlyList`1<IExpression> Arguments { get; }
    public bool ArgumentsByValueAndPositional { get; }
    public VbArgumentsOwnerInvocationClrWrapper(IVBArgumentsOwner invocationExpression);
    public sealed virtual IParametersOwner get_InvokedFunction();
    public sealed virtual IReadOnlyList`1<IParametersOwner> get_InvokedFunctionCandidates();
    public sealed virtual IArgumentsOwner get_ArgumentsOwner();
    public virtual IReadOnlyList`1<IExpression> get_Arguments();
    public sealed virtual bool get_ArgumentsByValueAndPositional();
    public sealed virtual void AddArgument(IExpression newArgumentExpression, int newArgumentIndex);
    public virtual void ChangeInvokedMethod(IMethod newFunction);
    public virtual void RemoveArgumentAt(int argumentToDeleteIndex);
    public sealed virtual void SetArgumentAt(int currentItemIndex, IExpression argumentExpression);
}
public static class JetBrains.ReSharper.Psi.VB.Util.VBCastUtil : object {
    public static Nullable`1<bool> IsValidTryCast(IVBExpression expression, IType targetType);
    public static IDeclaredType GetTypeByCastTarget(TokenNodeType tokenType, PredefinedType predefinedType);
}
public class JetBrains.ReSharper.Psi.VB.Util.VBCharPresentation : object {
    [CompilerGeneratedAttribute]
private string <Presentation>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <RangeInPresentation>k__BackingField;
    public string Presentation { get; }
    public TextRange RangeInPresentation { get; }
    public VBCharPresentation(string presentation, TextRange rangeInPresentation);
    [CompilerGeneratedAttribute]
public string get_Presentation();
    [CompilerGeneratedAttribute]
public TextRange get_RangeInPresentation();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Psi.VB.Util.VBCollectionTypeHelper : object {
    public sealed virtual IType ElementTypeByCollectionType(IType type, IAccessContext accessContext, ITreeNode context, bool isAsyncContext);
    public sealed virtual DeclaredElementInstance`1<IMethod> GetEnumeratorMethod(IType type, IAccessContext accessContext, ITreeNode context, bool isAsyncContext);
}
public class JetBrains.ReSharper.Psi.VB.Util.VBCollectionTypeUtil : CollectionTypeUtil {
    [CanBeNullAttribute]
public static IType ElementTypeByCollectionType(IType type, IAccessContext accessContext, IVBTreeNode context);
    public static DeclaredElementInstance`1<IMethod> GetMoveNextMethod(DeclaredElementInstance`1<IMethod> getEnumerator, IVBTreeNode context);
    public static DeclaredElementInstance`1<IProperty> GetCurrentProperty(DeclaredElementInstance`1<IMethod> getEnumerator, IVBTreeNode context);
    [CanBeNullAttribute]
public static DeclaredElementInstance`1<IMethod> GetEnumeratorMethod(IType type, IVBTreeNode context);
    internal static ResolveResultWithInfo ResolveMoveNextMethod(DeclaredElementInstance`1<IMethod> getEnumerator, IVBTreeNode context);
    internal static ResolveResultWithInfo ResolveCurrentProperty(DeclaredElementInstance`1<IMethod> getEnumerator, IVBTreeNode context);
    [NotNullAttribute]
private static ResolveResultWithInfo ResolveEnumeratorMethod(IDeclaredType declaredType, IAccessContext accessContext, IVBTreeNode context);
    [NotNullAttribute]
internal static ResolveResultWithInfo ResolveEnumeratorMethod(IType type, IVBTreeNode context);
    private static bool PossibleDeclaredType(ITypeElement typeElement);
    private static List`1<ISymbolFilter> GetSymbolFilters(IAccessContext accessContext);
    private static ResolveResultWithInfo GetForEachPatternMember(IDeclaredType declaredType, string name, IVBArgumentInfo extensionArgument, IVBTreeNode context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Util.VBConcatenationWrapperProvider : object {
    public sealed virtual IStringConcatenationClrWrapper TryCreateWidestContaining(IExpression expression);
    public sealed virtual IStringConcatenationClrWrapper TryCreate(IExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Util.VBDeclaredElementUtil : object {
    private static ClrTypeName VBModuleAttribute;
    private static VBDeclaredElementUtil();
    [ExtensionAttribute]
public static bool IsModule(IDeclaredElement element);
    [ExtensionAttribute]
public static bool IsClass(IDeclaredElement element);
    [ExtensionAttribute]
public static bool IsSub(IDeclaredElement element);
    [ExtensionAttribute]
public static bool IsFunction(IDeclaredElement element);
    [ExtensionAttribute]
public static bool IsSubDelegate(IDeclaredElement element);
    [ExtensionAttribute]
public static bool IsFunctionDelegate(IDeclaredElement element);
    [ExtensionAttribute]
public static bool CompareDeclaredElements(IDeclaredElement e1, IDeclaredElement e2);
    public static bool OperatorIsLiftable(IOperator operator, ISubstitution substitution);
    [CanBeNullAttribute]
public static IDeclaredElement EliminateDelegateInvokeMethod(IDeclaredElement declaredElement);
    [ExtensionAttribute]
public static VBSpecificDeclaredElementType GetVBSpecificElementType(IDeclaredElement declaredElement);
    public static bool IsValue(IDeclaredElement element);
    public static bool IsProperty(IDeclaredElement declaredElement);
    public static bool IsLValue(IDeclaredElement declaredElement);
    public static bool IsWithEvents(IDeclaredElement declaredElement);
    public static bool IsContentViaDesignerSerializationVisibility(IAttributesOwner property);
    public static bool IsAsyncMethod(IDeclaredElement declaredElement);
    public static bool IsAutoPropertyBackingField(IDeclaredElement declaredElement);
    public static bool IsEventHandlerField(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
public static INamespace GetContainingNamespaceOfElement(IDeclaredElement element);
    [ExtensionAttribute]
public static bool IsVBDefaultIndexedProperty(IProperty property);
    [ExtensionAttribute]
public static bool DefaultMemberIsVBDefaultIndexedProperty(ITypeElement type);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Util.VBDefaultValueExt : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static DefaultValue GetDefaultValue(IVBExpression expression, IType parameterType);
    [ExtensionAttribute]
[NotNullAttribute]
public static DefaultValue Normalize(DefaultValue value);
    [ExtensionAttribute]
public static bool CompareTo(DefaultValue value, DefaultValue otherValue);
    [ExtensionAttribute]
public static IVBExpression CreateExpressionByDefaultValueSmart(VBElementFactory factory, DefaultValue value, ITreeNode context);
}
public class JetBrains.ReSharper.Psi.VB.Util.VBEnumUtil : object {
    public static IList`1<IField> CalculateEnumMembers(ConstantValue constantValue, IEnum enum);
    private static bool CheckEnumFlags(ConstantValue constantValue, IEnum enum, IList`1<IField> flags, VBConstantCalculator constantCalculator);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Util.VBExpressionUtil : object {
    public static IVBStatement GetAnchorStatementVisibleFromAll(IReadOnlyList`1<ITreeNode> expressions);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IVBExpression GetOperandThroughParenthesis(IVBExpression expression);
    [ExtensionAttribute]
public static IVBExpression GetContainingParenthesizedExpression(IVBExpression expression);
    [ExtensionAttribute]
public static TreeTextRange GetStringLiteralContentTreeRange(IVBLiteralExpression literalExpression);
    [NotNullAttribute]
public static IVBExpression CreateLogicallyNegatedExpression(IVBExpression expression);
    [ExtensionAttribute]
public static IVBExpression GetLargestContainingExpression(IVBExpression expression);
    [ExtensionAttribute]
public static bool IsCondition(IVBExpression expression);
    public static bool IsCondition(IResolveContext resolveContext, IVBExpression expression);
    [ExtensionAttribute]
public static IExpressionType GetRuntimeExpressionType(IVBExpression expression);
    private static IExpressionType GetRuntimeExpressionTypeSafe(IVBExpression parentExpression, IVBExpression expression);
}
public class JetBrains.ReSharper.Psi.VB.Util.VbFunctionInvocationClrWrapper : VbArgumentsOwnerInvocationClrWrapper {
    [NotNullAttribute]
private IIndexExpression myIndexExpression;
    public IReadOnlyList`1<IExpression> Arguments { get; }
    public VbFunctionInvocationClrWrapper(IIndexExpression invocationExpression);
    public virtual IReadOnlyList`1<IExpression> get_Arguments();
    public virtual void ChangeInvokedMethod(IMethod newFunction);
    public virtual void RemoveArgumentAt(int argumentToDeleteIndex);
}
public static class JetBrains.ReSharper.Psi.VB.Util.VBImplicitLineContinuationUtil : object {
    private static NodeTypeSet ourOperatorSigns;
    private static VBImplicitLineContinuationUtil();
    public static bool CanUseImplicitLineContinuationBetween(ITreeNode left, ITreeNode right);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Util.VBLanguageFeatures : object {
    public sealed virtual bool AutoPropertiesAreSupported(ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.VB.Util.VBMainMethodUtil : object {
    [PureAttribute]
public static bool CanBeMainMethod(IMethodDeclaration declaration);
}
public static class JetBrains.ReSharper.Psi.VB.Util.VBMultipleDeclarationUtil : object {
    public static void ExtractVariableDeclaration(IVariableDeclaration declaration);
    public static void SplitDeclarationBefore(IVariableDeclaration declaration);
    public static void SplitDeclarationAfter(IVariableDeclaration declaration);
    public static void DeleteVariableDeclaration(IVariableDeclaration declaration);
    public static IVariableDeclaration CreateCopyInternal(IVariableDeclaration declaration, TreeNodeCopyContext context);
    public static void ExtractConstantDeclaration(IConstantDeclaration declaration);
    public static void SplitDeclarationBefore(IConstantDeclaration declaration);
    public static void SplitDeclarationAfter(IConstantDeclaration declaration);
    public static void DeleteConstantDeclaration(IConstantDeclaration declaration);
    public static IConstantDeclaration CreateCopyInternal(IConstantDeclaration declaration, TreeNodeCopyContext context);
    public static void ExtractVariableDeclaration(ILocalVariableDeclaration declaration);
    public static void SplitDeclarationBefore(ILocalVariableDeclaration declaration);
    public static void SplitDeclarationAfter(ILocalVariableDeclaration declaration);
    public static void DeleteLocalDeclaration(ILocalVariableDeclaration declaration);
    private static T CreateCopyInternalImpl(ITreeNode parent, T element, TreeNodeCopyContext context);
    private static ITreeNode[] GetRange(ITreeNode first, ITreeNode last);
    public static ITreeNode GetPrevComma(ITreeNode node);
    public static ITreeNode GetNextComma(ITreeNode node);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Util.VBNullabilityAnnotator : object {
    public sealed virtual void Annotate(IDeclaration declaration, IAttributeInstance annotation);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Psi.VB.Util.VBNullLiteralProvider : object {
    public sealed virtual IExpression CreateNullLiteral(IPsiModule psiModule);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Util.VBOptionsUtil : object {
    [ExtensionAttribute]
public static bool StrictOff(ITreeNode element);
    public static bool IsExplicitOff(ITreeNode element);
    public static bool IsInferOff(ITreeNode element);
    private static bool IsOptionOff(ITreeNode element, Func`2<IVBFile, bool> isOptionOff);
    [ExtensionAttribute]
[NotNullAttribute]
public static INamespace DefaultNamespace(IVBTreeNode element);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<INamespace> PreImportedDirectives(IVBTreeNode element);
}
public class JetBrains.ReSharper.Psi.VB.Util.VBOverridesUtil : OverridesUtil {
    public static IVBTypeMemberDeclaration OverridableMemberDeclaration(IOverridableMember member, ISubstitution substitution, ITypeElement inheritor, bool addImplements, bool makeAbstract, IPsiModule project);
    private static IVBTypeMemberDeclaration CreateInterfaceMemberDeclaration(StringBuilder pattern, List`1<object> arguments, VBElementFactory factory);
    private static bool UseCustom();
    private static void ProcessTypeParameters(StringBuilder builder, ICollection`1<object> arguments, IMethod method, ISubstitution substitution);
    private static void ProcessAccessRights(IOverridableMember member, StringBuilder pattern);
    private static void ProcessImplements(ICollection`1<object> arguments, IOverridableMember member, StringBuilder pattern, ISubstitution substitution);
    private static void ProcessParameters(StringBuilder pattern, ICollection`1<object> arguments, IParametersOwner parametersOwner, ISubstitution substitution, IPsiModule project);
    private static void AppendParameterToPattern(ICollection`1<object> arguments, StringBuilder pattern, object obj);
    public static ITreeNode[] AddCallToBase(ITypeMemberDeclaration declaration, ISubstitution substitution);
    public static void CallGenericVersion(IMethodDeclaration getEnumeratorDeclaration, OverridableMemberInstance genericMethodInstance);
    private static void AddTypeParameters(StringBuilder pattern, IMethod method, ICollection`1<object> formatParameters, ITypeElement inheritor);
    private static void CollectProhibitedNames(ICollection`1<string> prohibitedNames, ITypeElement inheritor);
}
public enum JetBrains.ReSharper.Psi.VB.Util.VBSpecificDeclaredElementType : Enum {
    public int value__;
    public static VBSpecificDeclaredElementType Class;
    public static VBSpecificDeclaredElementType Struct;
    public static VBSpecificDeclaredElementType Interface;
    public static VBSpecificDeclaredElementType Module;
    public static VBSpecificDeclaredElementType Enum;
    public static VBSpecificDeclaredElementType SubDelegate;
    public static VBSpecificDeclaredElementType FuncDelegate;
    public static VBSpecificDeclaredElementType Constructor;
    public static VBSpecificDeclaredElementType Func;
    public static VBSpecificDeclaredElementType Sub;
    public static VBSpecificDeclaredElementType Property;
    public static VBSpecificDeclaredElementType Accessor;
    public static VBSpecificDeclaredElementType Event;
    public static VBSpecificDeclaredElementType SignOperator;
    public static VBSpecificDeclaredElementType ConversionOperator;
    public static VBSpecificDeclaredElementType Field;
    public static VBSpecificDeclaredElementType Constant;
    public static VBSpecificDeclaredElementType EnumMember;
    public static VBSpecificDeclaredElementType Parameter;
    public static VBSpecificDeclaredElementType TypeParameter;
    public static VBSpecificDeclaredElementType Label;
    public static VBSpecificDeclaredElementType LocalVariable;
    public static VBSpecificDeclaredElementType LocalConstant;
    public static VBSpecificDeclaredElementType QueryVariable;
    public static VBSpecificDeclaredElementType AnonymousMethod;
    public static VBSpecificDeclaredElementType AnonymousTypeProperty;
}
public class JetBrains.ReSharper.Psi.VB.Util.VBStatementVisibleForAllCalculator : StatementVisibleForAllCalculator`1<IVBStatement> {
    [CompilerGeneratedAttribute]
private static StatementVisibleForAllCalculator`1<IVBStatement> <Instance>k__BackingField;
    [NotNullAttribute]
public static StatementVisibleForAllCalculator`1<IVBStatement> Instance { get; }
    private static VBStatementVisibleForAllCalculator();
    [CompilerGeneratedAttribute]
public static StatementVisibleForAllCalculator`1<IVBStatement> get_Instance();
    protected virtual IVBStatement AsStatement(ITreeNode treeNode, ITreeNode contextTreeNode);
    [PureAttribute]
protected virtual bool IsStatementOwnerParent(ITreeNode singleParent, HashSet`1<ITreeNode> childNodes);
    protected virtual ITreeNode ChooseFirstStatementInStatementOwner(ITreeNode singleParent, HashSet`1<ITreeNode> childNodes);
    private static IVBStatement FindLabelReferencesAboveFirstLine(TreeNodeCollection`1<IVBStatement> statements, IVBStatement firstStatement, LocalList`1<ILabel> labelsToCheck);
}
public class JetBrains.ReSharper.Psi.VB.Util.VBStringConcatenationClrWrapper : object {
    private IVBExpression myExpression;
    private IList`1<IVBExpression> myArguments;
    public IExpression Expression { get; }
    public IList`1<IExpression> Arguments { get; }
    public VBStringConcatenationClrWrapper(IVBExpression expression);
    public sealed virtual IExpression get_Expression();
    public sealed virtual IList`1<IExpression> get_Arguments();
    public sealed virtual void SetArgumentAt(int index, IExpression argument);
    public sealed virtual void TryMergeArgumentWithNext(int index);
    public sealed virtual void ReplaceInAllLiterals(string oldValue, string newValue);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.VB.Util.VBStringConcatenationClrWrapper/<GetWidestConstantValues>d__10")]
public sealed virtual IEnumerable`1<string> GetWidestConstantValues();
    public sealed virtual void RemoveAtValueRange(TextRange range);
    public sealed virtual void ReplaceAtValueRange(TextRange range, string newValue);
    public sealed virtual void InsertAtValueIndex(int index, string newValue);
    public sealed virtual IEnumerable`1<IExpression> GetConcatenationArgumentsThatContainValueRange(TextRange range);
    public sealed virtual IList`1<IExpression> GetConcatenationArgumentsThatContainValueRange(TextRange range, IList`1& appropriateValueRanges, bool includeNonLiterals);
    protected IVBExpression CombineArgumentListToConcatenationExpression(IList`1<IVBExpression> argumentsChain, VBElementFactory elementFactory);
    [NotNullAttribute]
private static IList`1<IVBExpression> GetConcatenationArguments(IVBExpression expression);
    [CanBeNullAttribute]
public static IVBExpression GetWidestStringConcatenationExpression(IVBExpression vbExpression);
}
public class JetBrains.ReSharper.Psi.VB.Util.VBStringConcatenationUtil : object {
    public static bool IsConcatenationOperatorExpression(IConcatenationExpression concatenationExpression);
}
public class JetBrains.ReSharper.Psi.VB.Util.VBStringLiteralAlterer : object {
    private IVBLiteralExpression myLiteralExpression;
    private string myCompiledValue;
    private IDictionary`2<int, int> myPresentationToValue;
    private List`1<VBCharPresentation> myCharPresentations;
    private string myPresentation;
    public ILiteralExpression Expression { get; }
    public TreeTextRange UnderQuotesRange { get; }
    public IVBLiteralExpression LiteralExpression { get; }
    public string CompiledValue { get; }
    public DocumentRange LeftQuoteRange { get; }
    private VBStringLiteralAlterer(IVBLiteralExpression literalExpression);
    private void RefreshData();
    public sealed virtual ILiteralExpression get_Expression();
    public sealed virtual TreeTextRange get_UnderQuotesRange();
    public IVBLiteralExpression get_LiteralExpression();
    public sealed virtual string get_CompiledValue();
    public DocumentRange get_LeftQuoteRange();
    private void FillCharacterRanges();
    [CanBeNullAttribute]
public static VBStringLiteralAlterer TryCreateByLiteralExpression(IVBLiteralExpression literalExpression);
    [NotNullAttribute]
public static VBStringLiteralAlterer CreateByLiteralExpression(IVBLiteralExpression literalExpression);
    [NotNullAttribute]
public static VBStringLiteralAlterer CreateByValue(string value, VBElementFactory elementFactory);
    public sealed virtual DocumentRange ValueTextRangeToPresentationDocumentRange(TextRange range);
    public sealed virtual TreeTextRange ValueTextRangeToPresentationTreeTextRange(TextRange range);
    [PureAttribute]
private TextRange ValueTextRangeToPresentationRangeWithinLiteral(TextRange range);
    public sealed virtual int PresentationDocumentOffsetToValueOffset(DocumentOffset documentOffset);
    private int PresentationInsideOffsetToValueOffset(int key);
    public sealed virtual int PresentationTreeOffsetToValueOffset(TreeOffset treeOffset);
    public sealed virtual void Insert(int valueOffset, string valueToInsert);
    public sealed virtual void Replace(string oldValue, string newValue);
    public sealed virtual void Remove(TextRange valueRange);
    public sealed virtual IStringLiteralAlterer Substring(TextRange valueRange);
    [NotNullAttribute]
public static VBStringLiteralAlterer Concat(VBStringLiteralAlterer left, VBStringLiteralAlterer right);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Util.VBStringLiteralAltererProvider : object {
    public sealed virtual IStringLiteralAlterer CreateStringLiteralByCompiledValue(string value, ITreeNode context);
    public sealed virtual IStringLiteralAlterer TryCreateStringLiteralByExpression(IExpression expression);
    public sealed virtual IStringLiteralAlterer CreateStringLiteralByExpression(IExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.Util.VBTypeUtil : object {
    private static ObjectPool`1<PooledHashSet`1<IType>> ourTypesSetPool;
    private static VBTypeUtil();
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
public static IType GetTaskUnderlyingType(IType type);
    public static IType[] GetTypes(IExpressionType[] operands);
    [ExtensionAttribute]
public static bool CanUseExplicitly(IType type, ITreeNode context);
    [ExtensionAttribute]
[ObsoleteAttribute("Does nothing")]
public static IType Normalize(IType type);
    [ExtensionAttribute]
public static IType Normalize(IType type, IType[] types);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<IType> Normalize(IReadOnlyList`1<IType> types);
    [ExtensionAttribute]
public static IType Normalize(IType type, IEnumerable`1<IType> types);
    [NotNullAttribute]
public static IReadOnlyList`1<IType> DominantTypes(IReadOnlyList`1<IType> types, IVBTypeConversionRule rule);
    [CanBeNullAttribute]
public static IType DominantType(IReadOnlyList`1<IType> types, IVBTypeConversionRule rule);
    [CanBeNullAttribute]
internal static IType DominantTypeWithoutNormalization(IReadOnlyList`1<IType> types, IVBTypeConversionRule rule);
    [NotNullAttribute]
public static IReadOnlyList`1<IType> DominantExpressionTypes(IReadOnlyList`1<IExpressionType> expressionTypes, IVBTypeConversionRule rule);
    [CanBeNullAttribute]
public static IType DominantExpressionType(IEnumerable`1<IExpressionType> expressionTypes, IVBTypeConversionRule rule);
    [CanBeNullAttribute]
public static IType DominantTypeWithoutLambdas(IEnumerable`1<IExpressionType> expressionTypes, IVBTypeConversionRule conversionRule);
    public static IType GetReturnExpressionTypeByFunctionReturnType(IType type, bool isAsyncFunction, bool isIterator);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Psi.VB.Util.VBTypeUtilLanguageService : object {
    public sealed virtual bool CanUseExplicitly(IType type, ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.VB.VBAttributeInstanceUtil : object {
    private static JetHashSet`1<string> ourSkipAttributes;
    private static VBAttributeInstanceUtil();
    public static IAttributeInstance[] FilterAttributes(IAttributesSet attributes, bool showNonVisibleMembers, bool showExternalAnnotations, bool showTupleElementNames, bool showNullableAttributes);
}
public abstract class JetBrains.ReSharper.Psi.VB.VBElementFactory : object {
    [PureAttribute]
[NotNullAttribute]
public static VBElementFactory GetInstance(ITreeNode node, bool applyCodeFormatter);
    [PureAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use overload with ITreeNode")]
public static VBElementFactory GetInstance(IPsiModule module, bool applyCodeFormatter);
    [NotNullAttribute]
public abstract virtual IVBFile CreateFile(string text, Object[] args);
    [NotNullAttribute]
public abstract virtual IModuleDeclaration CreateModuleDeclaration(string name);
    [NotNullAttribute]
public abstract virtual IBlock CreateEmptyBlock();
    [NotNullAttribute]
public abstract virtual IBlock CreateBlock(string format, Object[] objects);
    [NotNullAttribute]
public abstract virtual IVBTypeMemberDeclaration CreateTypeMemberDeclaration(string format, bool inInterface, Object[] args);
    [NotNullAttribute]
public abstract virtual IVBExpression CreateExpressionAsIs(string format);
    [NotNullAttribute]
public abstract virtual IVBExpression CreateExpression(string expr, Object[] args);
    [NotNullAttribute]
public abstract virtual ITypeUsage CreateTypeUsageNode(string typeText, Object[] args);
    [NotNullAttribute]
public abstract virtual IVBStatement CreateStatement(string format, Object[] args);
    [NotNullAttribute]
public abstract virtual IVBArgument CreateArgument(IVBExpression arg);
    [NotNullAttribute]
public abstract virtual IConstructorDeclaration CreateConstructorDeclaration();
    [CanBeNullAttribute]
public abstract virtual IDeclaredTypeUsage CreateDeclaredTypeUsageNode(IDeclaredType type);
    [CanBeNullAttribute]
public abstract virtual ITypeUsage CreateTypeUsageNode(IType type);
    [NotNullAttribute]
public abstract virtual IRegularParameterDeclaration CreateParameterDeclaration(IType type, string name, ParameterKind kind, bool isParamArray);
    [NotNullAttribute]
public abstract virtual IExpressionArgument CreateExpressionArgument(IVBExpression expression);
    [NotNullAttribute]
public abstract virtual INamedArgument CreateNamedArgument(string name, IVBExpression expression);
    [NotNullAttribute]
public abstract virtual IImportDirective CreateImportDirective(string qualifiedName);
    [NotNullAttribute]
public abstract virtual IImportDirective CreateImportDirective(INamespace namespace);
    [NotNullAttribute]
public abstract virtual IImportDirective CreateImportAliasDirective(string alias, ITypeElement typeElement, ISubstitution substitution);
    [NotNullAttribute]
public abstract virtual IReferenceExpression CreateReferenceExpression(string expr, Object[] args);
    [NotNullAttribute]
public abstract virtual IReferenceName CreateReferenceName(string name, Object[] args);
    [NotNullAttribute]
public abstract virtual IVBNamespaceDeclaration CreateNamespaceDeclaration(string name);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfMethodDeclaration CreateTypeParameterOfMethodDeclaration(ITypeParameter typeParameter);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfMethodDeclaration CreateTypeParameterOfMethodDeclaration(string typeParameter);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfTypeDeclaration CreateTypeParameterOfTypeDeclaration(ITypeParameter typeParameter);
    [NotNullAttribute]
public abstract virtual IAccessorDeclaration CreateAccessorDeclaration(AccessorKind kind);
    [NotNullAttribute]
public abstract virtual IAccessorDeclaration CreateAccessorDeclaration(AccessorKind kind, IType type);
    [NotNullAttribute]
public abstract virtual IRegularParameterList CreateEmptyParameterList();
    [CanBeNullAttribute]
public abstract virtual IVBExpression CreateExpressionByConstantValue(ConstantValue value);
    [NotNullAttribute]
public abstract virtual IDocCommentBlock CreateDocCommentBlock(string xmlText);
    [NotNullAttribute]
public abstract virtual ITypeParameterOfTypeDeclaration CreateTypeParameterOfTypeDeclaration(string typeParameter);
    [NotNullAttribute]
public abstract virtual IPropertyDeclaration CreatePropertyDeclaration(IType type, string name, bool inInterface);
    [NotNullAttribute]
public abstract virtual IDelegateDeclaration CreateDelegateDeclaration();
    [NotNullAttribute]
public abstract virtual IEnumMemberDeclaration CreateEnumMemberDeclaration(string enumMemberName);
    [NotNullAttribute]
public abstract virtual ILoopControlVariableDeclaration CreateLoopControlVariableDeclaration(string name, IType type);
    [NotNullAttribute]
public abstract virtual IEventDeclaration CreateEventDeclaration(IDeclaredType type, string name);
    [NotNullAttribute]
public abstract virtual IVBIdentifier CreateIdentifier(string name);
    [CanBeNullAttribute]
public abstract virtual ITypeParameterConstraintList CreateTypeParameterConstraintsList(ITypeParameter typeParameter, ISubstitution substitution, string parameterName);
    [NotNullAttribute]
public abstract virtual Pair`2<IRegionPreprocessorDirective, IEndRegionPreprocessorDirective> CreateRegionDirective(string name);
    [NotNullAttribute]
public abstract virtual IAttribute CreateAttribute(ITypeElement attributeClass, AttributeValue[] fixedArguments, Pair`2[] namedArguments);
    [CanBeNullAttribute]
public IAttribute CreateAttribute(ITypeElement attributeClass);
    [NotNullAttribute]
public abstract virtual IVBXmlElement CreateVBXmlElement(string xmlString);
    public abstract virtual IVBExpression CreateExpressionByConstantValue(ConstantValue value, bool safeConstantValueExactType);
    public abstract virtual IVBExpression CreateExpressionByDefaultValue(DefaultValue value);
    public abstract virtual IDocComment CreateDocComment(string text);
    public abstract virtual ILambdaParameterDeclaration CreateLambdaFunctionParameterDeclaration(IType type, string parameterName, ParameterKind kind);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.VB.VBExtensionMethods : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB9Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB10Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB11Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB12Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB14Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB15Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB15_3Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB15_5Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB16Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsVB16_9Supported(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static VBLanguageLevel GetVBLanguageLevel(ITreeNode element);
    [PureAttribute]
[ObsoleteAttribute("SLOW: replace usages with 'ITreeNode' overload")]
public static VBLanguageLevel GetVBLanguageLevel(IPsiModule module);
}
[LanguageDefinitionAttribute("VBASIC")]
public class JetBrains.ReSharper.Psi.VB.VBLanguage : KnownLanguage {
    public static string Name;
    [CompilerGeneratedAttribute]
private static VBLanguage <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Synonyms>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static VBLanguage Instance { get; private set; }
    public PsiLanguageCategories SupportedCategories { get; }
    public String[] Synonyms { get; }
    protected VBLanguage(string name);
    protected VBLanguage(string name, string presentableName);
    [CompilerGeneratedAttribute]
public static VBLanguage get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(VBLanguage value);
    public virtual PsiLanguageCategories get_SupportedCategories();
    [CompilerGeneratedAttribute]
public virtual String[] get_Synonyms();
}
public class JetBrains.ReSharper.Psi.VB.VBNodeTypeIndexer : AbstractNodeTypeIndexer {
    [NullableAttribute("1")]
public static VBNodeTypeIndexer Instance;
    private static VBNodeTypeIndexer();
}
public abstract class JetBrains.ReSharper.Psi.VB.VBPredefinedOperators : object {
    public static string EXPONENT;
    public static string LIKE;
    public static string CONCATENATE;
    public static string INTEGER_DIVISION;
    public static string BINARY_ANDALSO;
    public static string BINARY_ORELSE;
    private static Dictionary`2<TokenNodeType, string> UnaryOperatorNames;
    private static Dictionary`2<TokenNodeType, string> BinaryOperatorNames;
    private static VBPredefinedOperators();
    public static VBPredefinedOperators GetInstance(IPsiModule module);
    public static string GetUnaryOperatorName(TokenNodeType sign);
    public static string GetBinaryOperatorName(TokenNodeType sign);
    public abstract virtual bool IsOperatorName(string name, int parameterCount);
    public abstract virtual IList`1<OperatorInstance> GetOperatorsByName(string name);
    [CanBeNullAttribute]
public abstract virtual ISignOperator GetBinaryOperator(string name, IType leftType, IType rightType);
    [CanBeNullAttribute]
public abstract virtual ISignOperator GetUnaryOperator(string name, IType type);
    public abstract virtual ISignOperator[] GetBinaryOperators();
    public abstract virtual ISignOperator[] GetUnaryOperators();
}
public static class JetBrains.ReSharper.Psi.VB.VBPsiFileCachedDataKeys : object {
    [NotNullAttribute]
public static Key`1<Boxed`1<VBLanguageLevel>> LANGUAGE_LEVEL;
    private static VBPsiFileCachedDataKeys();
}
public static class JetBrains.ReSharper.Psi.VB.VBPsiSourceFilePropertiesExtension : object {
    private static Char[] ourSeparators;
    private static VBPsiSourceFilePropertiesExtension();
    public static String[] ParseCompilerIdList(string value);
}
public static class JetBrains.ReSharper.Psi.VB.VBTypeFactory : object {
    private static BidirectionalMap`2<TokenNodeType, IClrTypeName> ourTypeKeywords;
    private static BidirectionalMap`2<TokenNodeType, IClrTypeName> ourTypeChars;
    private static VBTypeFactory();
    public static IDeclaredType CreatePredefinedTypeByKeyword(TokenNodeType tokenType, IPsiModule module);
    public static IDeclaredType CreatePredefinedTypeByTypeChar(ITokenNode typeCharNode, IPsiModule module);
    public static IType CreateType(ITokenNode typeCharNode, IPsiModule module, ITokenNode nullableMark, IArrayModifiersList arrayModifiersListNode);
    [NotNullAttribute]
[PureAttribute]
public static IDeclaredType CreateDeclaredType(IReferenceName referenceName);
    public static IDeclaredType CreateDeclaredType(IDeclaredTypeUsage typeUsage);
    private static IDeclaredType CreateTupleType(TreeNodeCollection`1<ITupleTypeComponent> tupleComponents, IPsiModule module);
    public static IType CreateType(ITypeUsage typeUsage, ITokenNode nullableMark, IArrayModifiersList arrayModifiersListNode);
    public static IType CreateType(ITypeUsage typeUsage);
    public static IType CreateArrayType(IType type, IArrayModifiersList list);
    public static IType CreateType(string typeName, ITreeNode context);
    public static string GetTypeChar(IClrTypeName clrName);
    public static string GetTypeKeyword(IClrTypeName clrName);
    [CanBeNullAttribute]
public static string GetFullyQualifiedNameByKeyword(string keyword);
    [CanBeNullAttribute]
public static IClrTypeName GetClrNameByKeyword(string keyword);
    public static string GetShortNameByTypeKeyword(TokenNodeType token);
}
public static class JetBrains.ReSharper.Psi.VB.XLinqUtil : object {
    public static IClrTypeName XElement;
    public static IClrTypeName XStreamingElement;
    public static IClrTypeName XName;
    public static IClrTypeName XAttribute;
    public static IClrTypeName XDocument;
    public static IClrTypeName XProcessingInstruction;
    public static IClrTypeName XComment;
    public static IClrTypeName XCData;
    public static IClrTypeName XContainer;
    public static IClrTypeName XElementExtensions;
    public static IClrTypeName XNamespace;
    private static string MyInternalXmlHelper;
    private static string SystemXmlLinq;
    private static string Value;
    private static XLinqUtil();
    public static bool IsXElement(IType type);
    public static IProperty GetValuePropertyFromInternalXmlHelper(IPsiSourceFile psiFile);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Psi.VB.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
